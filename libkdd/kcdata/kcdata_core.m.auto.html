<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kcdata_core.m</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kcdata_core.m&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code <span class="enscript-type">and</span>/<span class="enscript-type">or</span> Modifications of Original Code
 * as defined in <span class="enscript-type">and</span> that are subject to the Apple Public Source License
 * Version 2.0 (the <span class="enscript-string">'License'</span>). You may <span class="enscript-type">not</span> use this file except in
 * compliance with the License. The rights granted to you under the License
 * may <span class="enscript-type">not</span> be used to create, <span class="enscript-type">or</span> enable the creation <span class="enscript-type">or</span> redistribution of,
 * unlawful <span class="enscript-type">or</span> unlicensed copies of an Apple operating system, <span class="enscript-type">or</span> to
 * circumvent, violate, <span class="enscript-type">or</span> enable the circumvention <span class="enscript-type">or</span> violation of, <span class="enscript-type">any</span>
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> <span class="enscript-type">and</span> read it before using this file.
 *
 * The Original Code <span class="enscript-type">and</span> <span class="enscript-type">all</span> software distributed under the License are
 * distributed on an <span class="enscript-string">'AS IS'</span> basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License <span class="enscript-keyword">for</span> the specific language governing rights <span class="enscript-type">and</span>
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */

#include &lt;kern/kern_cdata.h&gt;
#import &lt;Foundation/Foundation.h&gt;
#import &quot;kdd.h&quot;
#import &quot;KCDBasicTypeDescription.h&quot;
#import &quot;KCDStructTypeDescription.h&quot;

#define MAX_KCDATATYPE_BUFFER_SIZE 2048
extern struct kcdata_type_definition *kcdata_get_typedescription(unsigned type_id, uint8_t *buffer, uint32_t buffer_size);


/*!
 * @<span class="enscript-keyword">function</span> getTypeFromTypeDef
 *
 * @abstract
 * Build a KCDataType from a <span class="enscript-type">type</span> definition.
 *
 * @param typeDef
 * A pointer to kcdata_type_definition_t that specifies the <span class="enscript-type">type</span> fields <span class="enscript-type">and</span> has subtype definitions
 * in the memory immediately following the type_definition.
 *
 * @<span class="enscript-keyword">return</span> KCDataType * <span class="enscript-type">type</span> object <span class="enscript-type">which</span> can be used to parse data into dictionaries.
 * This may <span class="enscript-keyword">return</span> nil <span class="enscript-keyword">if</span> it finds the data to be invalid.
 *
 * @discussion
 * This routine tries to decode the typeDef structure <span class="enscript-type">and</span> create either a basic <span class="enscript-type">type</span> (KCDBasicTypeDescription)
 * <span class="enscript-type">or</span> a struct <span class="enscript-type">type</span>.
 */
static KCDataType * getTypeFromTypeDef(struct kcdata_type_definition * typeDef);

static KCDataType *
getTypeFromTypeDef(struct kcdata_type_definition * typeDef)
{
	<span class="enscript-keyword">if</span> (typeDef == NULL) {
		<span class="enscript-keyword">return</span> nil;
	}
	NSString * kct_name = <span class="enscript-type">[</span>NSString stringWithFormat:@&quot;<span class="enscript-comment">%s&quot;, typeDef-&gt;kct_name];
</span>	<span class="enscript-keyword">if</span> (typeDef-&gt;kct_num_elements == 1) {
		KCDBasicTypeDescription * retval = <span class="enscript-type">[</span><span class="enscript-type">[</span>KCDBasicTypeDescription alloc<span class="enscript-type">]</span> initWithKCTypeDesc:&amp;typeDef-&gt;kct_elements<span class="enscript-type">[</span>0<span class="enscript-type">]</span><span class="enscript-type">]</span>;
		<span class="enscript-keyword">return</span> retval;
	} <span class="enscript-keyword">else</span> {
		KCDStructTypeDescription * retval =
		    <span class="enscript-type">[</span><span class="enscript-type">[</span>KCDStructTypeDescription alloc<span class="enscript-type">]</span> initWithType:typeDef-&gt;kct_type_identifier withName:kct_name<span class="enscript-type">]</span>;
		/* need to do work here to <span class="enscript-type">get</span> the array of elements setup here */
		KCDBasicTypeDescription * curField = nil;
		<span class="enscript-keyword">for</span> (unsigned int <span class="enscript-type">i</span> = 0; <span class="enscript-type">i</span> &lt; typeDef-&gt;kct_num_elements; <span class="enscript-type">i</span>++) {
			curField = <span class="enscript-type">[</span><span class="enscript-type">[</span>KCDBasicTypeDescription alloc<span class="enscript-type">]</span> initWithKCTypeDesc:&amp;typeDef-&gt;kct_elements<span class="enscript-type">[</span><span class="enscript-type">i</span><span class="enscript-type">]</span><span class="enscript-type">]</span>;
			<span class="enscript-type">[</span>retval addFieldBasicType:curField<span class="enscript-type">]</span>;
		}
		<span class="enscript-keyword">return</span> retval;
	}
	<span class="enscript-keyword">return</span> nil;
}

KCDataType *
getKCDataTypeForID(uint32_t typeID)
{
	static dispatch_once_t onceToken;
	static NSMutableDictionary * knownTypes = nil;
	dispatch_once(&amp;onceToken, ^{
		<span class="enscript-keyword">if</span> (!knownTypes) {
			knownTypes = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> init<span class="enscript-type">]</span>;
		}
	});
	NSNumber * <span class="enscript-type">type</span> = <span class="enscript-type">[</span>NSNumber numberWithUnsignedInt:typeID<span class="enscript-type">]</span>;
	<span class="enscript-keyword">if</span> (!knownTypes<span class="enscript-type">[</span><span class="enscript-type">type</span><span class="enscript-type">]</span>) {
		/* code to query system <span class="enscript-keyword">for</span> <span class="enscript-type">type</span> information */
		uint8_t buffer<span class="enscript-type">[</span>MAX_KCDATATYPE_BUFFER_SIZE<span class="enscript-type">]</span>;
		struct kcdata_type_definition * sys_def = kcdata_get_typedescription(typeID, buffer, MAX_KCDATATYPE_BUFFER_SIZE);
		<span class="enscript-keyword">if</span> (sys_def == NULL) {
			knownTypes<span class="enscript-type">[</span><span class="enscript-type">type</span><span class="enscript-type">]</span> = <span class="enscript-type">[</span><span class="enscript-type">[</span>KCDBasicTypeDescription alloc<span class="enscript-type">]</span> createDefaultForType:typeID<span class="enscript-type">]</span>;
		} <span class="enscript-keyword">else</span> {
			knownTypes<span class="enscript-type">[</span><span class="enscript-type">type</span><span class="enscript-type">]</span> = getTypeFromTypeDef(sys_def);
		}
	}
	assert(knownTypes<span class="enscript-type">[</span><span class="enscript-type">type</span><span class="enscript-type">]</span> != nil);
	<span class="enscript-keyword">return</span> knownTypes<span class="enscript-type">[</span><span class="enscript-type">type</span><span class="enscript-type">]</span>;
}

NSString *
KCDataTypeNameForID(uint32_t typeID)
{
	NSString * retval = <span class="enscript-type">[</span>NSString stringWithFormat:@&quot;<span class="enscript-comment">%u&quot;, typeID];
</span>	KCDataType * t = getKCDataTypeForID(typeID);

	<span class="enscript-keyword">if</span> (!<span class="enscript-type">[</span><span class="enscript-type">[</span>t name<span class="enscript-type">]</span> containsString:@&quot;Type_&quot;<span class="enscript-type">]</span>) {
		retval = <span class="enscript-type">[</span>t name<span class="enscript-type">]</span>;
	}
	<span class="enscript-keyword">return</span> retval;
}

NSMutableDictionary *
parseKCDataArray(void * dataBuffer)
{
	uint32_t typeID = KCDATA_ITEM_ARRAY_GET_EL_TYPE(dataBuffer);
	uint32_t count = KCDATA_ITEM_ARRAY_GET_EL_COUNT(dataBuffer);
	uint32_t <span class="enscript-type">size</span> = KCDATA_ITEM_ARRAY_GET_EL_SIZE(dataBuffer);
	uint8_t * buffer = (uint8_t *)KCDATA_ITEM_DATA_PTR(dataBuffer);
	KCDataType * datatype = getKCDataTypeForID(typeID);
	NSMutableDictionary * retval = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> initWithCapacity:1<span class="enscript-type">]</span>;
	NSMutableArray * arr = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableArray alloc<span class="enscript-type">]</span> initWithCapacity:count<span class="enscript-type">]</span>;
	retval<span class="enscript-type">[</span><span class="enscript-type">[</span>datatype name<span class="enscript-type">]</span><span class="enscript-type">]</span> = arr;
	NSMutableDictionary * tmpdict = NULL;
	<span class="enscript-keyword">for</span> (uint32_t <span class="enscript-type">i</span> = 0; <span class="enscript-type">i</span> &lt; count; <span class="enscript-type">i</span>++) {
		tmpdict = <span class="enscript-type">[</span>datatype parseData:(void *)&amp;buffer<span class="enscript-type">[</span><span class="enscript-type">i</span> * <span class="enscript-type">size</span><span class="enscript-type">]</span> ofLength:<span class="enscript-type">size</span><span class="enscript-type">]</span>;
		<span class="enscript-type">[</span>arr addObject:tmpdict<span class="enscript-type">]</span>;
	}
	<span class="enscript-keyword">return</span> retval;
}

NSMutableDictionary *
parseKCDataContainer(void * dataBuffer, uint32_t * bytesParsed)
{
	<span class="enscript-keyword">if</span> (bytesParsed == NULL)
		<span class="enscript-keyword">return</span> nil;
	assert(KCDATA_ITEM_TYPE(dataBuffer) == KCDATA_TYPE_CONTAINER_BEGIN);
	uint64_t containerID = KCDATA_CONTAINER_ID(dataBuffer);

	/* setup collection object <span class="enscript-keyword">for</span> sub containers */
	NSMutableDictionary * sub_containers = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> init<span class="enscript-type">]</span>;
	NSMutableDictionary * retval = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> init<span class="enscript-type">]</span>;
	NSMutableDictionary * container = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> init<span class="enscript-type">]</span>;
	struct kcdata_item * buffer = (struct kcdata_item *)KCDATA_ITEM_NEXT_HEADER(dataBuffer);
	KCDataType * tmptype;
	uint32_t _t;
	void * _d;
	NSMutableDictionary * tmpdict;
	retval<span class="enscript-type">[</span>KCDataTypeNameForID(kcdata_get_container_type(dataBuffer))<span class="enscript-type">]</span> = container;

	KCDATA_ITEM_FOREACH(buffer)
	{
		_t = KCDATA_ITEM_TYPE(buffer);
		_d = KCDATA_ITEM_DATA_PTR(buffer);
		<span class="enscript-keyword">if</span> (_t == KCDATA_TYPE_CONTAINER_END) {
			<span class="enscript-keyword">if</span> (KCDATA_CONTAINER_ID(buffer) == containerID) {
				<span class="enscript-keyword">break</span>;
			}
			continue;
		}

		<span class="enscript-keyword">if</span> (_t == KCDATA_TYPE_ARRAY) {
			tmpdict = parseKCDataArray(buffer);
			<span class="enscript-type">[</span>container addEntriesFromDictionary:tmpdict<span class="enscript-type">]</span>;
			continue;
		}

		<span class="enscript-keyword">if</span> (_t == KCDATA_TYPE_CONTAINER_BEGIN) {
			uint32_t container_size = 0;
			tmpdict = parseKCDataContainer(buffer, &amp;container_size);
			NSString * subcontainerID = <span class="enscript-type">[</span>NSString stringWithFormat:@&quot;<span class="enscript-comment">%llu&quot;, KCDATA_CONTAINER_ID(buffer)];
</span>			NSString * k_desc = nil;
			assert(<span class="enscript-type">[</span>tmpdict count<span class="enscript-type">]</span> == 1);
			<span class="enscript-keyword">for</span> (NSString * k in <span class="enscript-type">[</span>tmpdict keyEnumerator<span class="enscript-type">]</span>) {
				k_desc = k;
				<span class="enscript-keyword">if</span> (<span class="enscript-type">[</span>k intValue<span class="enscript-type">]</span> != 0)
					k_desc = KCDataTypeNameForID(<span class="enscript-type">[</span>k intValue<span class="enscript-type">]</span>);

				<span class="enscript-keyword">if</span> (<span class="enscript-type">[</span>sub_containers objectForKey:k_desc<span class="enscript-type">]</span> == nil) {
					sub_containers<span class="enscript-type">[</span>k_desc<span class="enscript-type">]</span> = <span class="enscript-type">[</span><span class="enscript-type">[</span>NSMutableDictionary alloc<span class="enscript-type">]</span> init<span class="enscript-type">]</span>;
				}
				sub_containers<span class="enscript-type">[</span>k_desc<span class="enscript-type">]</span><span class="enscript-type">[</span>subcontainerID<span class="enscript-type">]</span> = tmpdict<span class="enscript-type">[</span>k<span class="enscript-type">]</span>;
			}
			buffer = (struct kcdata_item *)((uintptr_t)buffer + container_size);
			<span class="enscript-keyword">if</span> (KCDATA_ITEM_TYPE(buffer) == KCDATA_TYPE_BUFFER_END) {
				<span class="enscript-keyword">break</span>;
			}
			continue;
		}

		tmptype = getKCDataTypeForID(_t);
		tmpdict = <span class="enscript-type">[</span>tmptype parseData:_d ofLength:KCDATA_ITEM_SIZE(buffer)<span class="enscript-type">]</span>;
		<span class="enscript-keyword">if</span> (<span class="enscript-type">[</span>tmpdict count<span class="enscript-type">]</span> == 1)
			<span class="enscript-type">[</span>container addEntriesFromDictionary:tmpdict<span class="enscript-type">]</span>;
		<span class="enscript-keyword">else</span>
			container<span class="enscript-type">[</span><span class="enscript-type">[</span>tmptype name<span class="enscript-type">]</span><span class="enscript-type">]</span> = tmpdict;
	}
	<span class="enscript-type">[</span>container addEntriesFromDictionary:sub_containers<span class="enscript-type">]</span>;
	*bytesParsed = (uint32_t)((uintptr_t)buffer - (uintptr_t)dataBuffer);
	<span class="enscript-keyword">return</span> retval;
}
</pre>
<hr />
</body></html>