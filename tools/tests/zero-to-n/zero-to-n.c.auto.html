<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>zero-to-n.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">zero-to-n.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;math.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;err.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sysexits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;getopt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;spawn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;spawn_private.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/spawn_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/dyld.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread/qos_private.h&gt;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> wake_type { WAKE_BROADCAST_ONESEM, WAKE_BROADCAST_PERTHREAD, WAKE_CHAIN, WAKE_HOP } wake_type_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> my_policy_type { MY_POLICY_REALTIME, MY_POLICY_TIMESHARE, MY_POLICY_FIXEDPRI } my_policy_type_t;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">mach_assert_zero</span>(error)        do { if ((error) != 0) { fprintf(stderr, <span class="enscript-string">&quot;[FAIL] error %d (%s) &quot;</span>, (error), mach_error_string(error)); assert(error == 0); } } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">mach_assert_zero_t</span>(tid, error) do { if ((error) != 0) { fprintf(stderr, <span class="enscript-string">&quot;[FAIL] Thread %d error %d (%s) &quot;</span>, (tid), (error), mach_error_string(error)); assert(error == 0); } } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">assert_zero_t</span>(tid, error)      do { if ((error) != 0) { fprintf(stderr, <span class="enscript-string">&quot;[FAIL] Thread %d error %d &quot;</span>, (tid), (error)); assert(error == 0); } } while (0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONSTRAINT_NANOS</span>	(20000000ll)	<span class="enscript-comment">/* 20 ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPUTATION_NANOS</span>	(10000000ll)	<span class="enscript-comment">/* 10 ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TRACEWORTHY_NANOS</span>	(10000000ll)	<span class="enscript-comment">/* 10 ms */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">debug_log</span>(args...) printf(args)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">debug_log</span>(args...) do { } while(0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Declarations */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>*                    <span class="enscript-function-name">worker_thread</span>(<span class="enscript-type">void</span> *arg);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>                     <span class="enscript-function-name">usage</span>();
<span class="enscript-type">static</span> <span class="enscript-type">int</span>                      <span class="enscript-function-name">thread_setup</span>(uint32_t my_id);
<span class="enscript-type">static</span> my_policy_type_t         <span class="enscript-function-name">parse_thread_policy</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>                     <span class="enscript-function-name">selfexec_with_apptype</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[]);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>                     <span class="enscript-function-name">parse_args</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[]);

<span class="enscript-comment">/* Global variables (general) */</span>
<span class="enscript-type">static</span> uint32_t                 g_numcpus;
<span class="enscript-type">static</span> uint32_t                 g_numthreads;
<span class="enscript-type">static</span> wake_type_t              g_waketype;
<span class="enscript-type">static</span> policy_t                 g_policy;
<span class="enscript-type">static</span> uint32_t                 g_iterations;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mach_timebase_info g_mti;
<span class="enscript-type">static</span> semaphore_t              g_main_sem;
<span class="enscript-type">static</span> uint64_t                *g_thread_endtimes_abs;
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> uint32_t        g_done_threads;
<span class="enscript-type">static</span> boolean_t                g_verbose       = FALSE;
<span class="enscript-type">static</span> boolean_t                g_do_affinity   = FALSE;
<span class="enscript-type">static</span> uint64_t                 g_starttime_abs;
<span class="enscript-type">static</span> uint32_t                 g_iteration_sleeptime_us = 0;

<span class="enscript-comment">/* Threshold for dropping a 'bad run' tracepoint */</span>
<span class="enscript-type">static</span> uint64_t                 g_traceworthy_latency_ns = TRACEWORTHY_NANOS;

<span class="enscript-comment">/* Have we re-execed to set apptype? */</span>
<span class="enscript-type">static</span> boolean_t                g_seen_apptype = FALSE;

<span class="enscript-comment">/* usleep in betweeen iterations */</span>
<span class="enscript-type">static</span> boolean_t                g_do_sleep      = TRUE;

<span class="enscript-comment">/* Every thread spins until all threads have checked in */</span>
<span class="enscript-type">static</span> boolean_t                g_do_all_spin = FALSE;

<span class="enscript-comment">/* One randomly chosen thread holds up the train for a certain duration. */</span>
<span class="enscript-type">static</span> boolean_t                g_do_one_long_spin = FALSE;
<span class="enscript-type">static</span> uint32_t                 g_one_long_spin_id = 0;
<span class="enscript-type">static</span> uint64_t                 g_one_long_spin_length_abs = 0;
<span class="enscript-type">static</span> uint64_t                 g_one_long_spin_length_ns = 0;

<span class="enscript-comment">/* Each thread spins for a certain duration after waking up before blocking again. */</span>
<span class="enscript-type">static</span> boolean_t                g_do_each_spin = FALSE;
<span class="enscript-type">static</span> uint64_t                 g_each_spin_duration_abs = 0;
<span class="enscript-type">static</span> uint64_t                 g_each_spin_duration_ns = 0;

<span class="enscript-comment">/* Global variables (broadcast) */</span>
<span class="enscript-type">static</span> semaphore_t              g_broadcastsem;
<span class="enscript-type">static</span> semaphore_t              g_leadersem;
<span class="enscript-type">static</span> semaphore_t              g_readysem;
<span class="enscript-type">static</span> semaphore_t              g_donesem;

<span class="enscript-comment">/* Global variables (chain) */</span>
<span class="enscript-type">static</span> semaphore_t             *g_semarr;

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">abs_to_nanos</span>(uint64_t abstime)
{
	<span class="enscript-keyword">return</span> (uint64_t)(abstime * (((<span class="enscript-type">double</span>)g_mti.numer) / ((<span class="enscript-type">double</span>)g_mti.denom)));
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">nanos_to_abs</span>(uint64_t ns)
{
	<span class="enscript-keyword">return</span> (uint64_t)(ns * (((<span class="enscript-type">double</span>)g_mti.denom) / ((<span class="enscript-type">double</span>)g_mti.numer)));
}

<span class="enscript-comment">/*
 * Figure out what thread policy to use 
 */</span>
<span class="enscript-type">static</span> my_policy_type_t
<span class="enscript-function-name">parse_thread_policy</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
	<span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;timeshare&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_TIMESHARE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;realtime&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_REALTIME;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;fixed&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_FIXEDPRI;
	} <span class="enscript-keyword">else</span> {
		errx(EX_USAGE, <span class="enscript-string">&quot;Invalid thread policy \&quot;%s\&quot;&quot;</span>, str);
	}
}

<span class="enscript-comment">/*
 * Figure out what wakeup pattern to use
 */</span>
<span class="enscript-type">static</span> wake_type_t
<span class="enscript-function-name">parse_wakeup_pattern</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str) 
{
	<span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;chain&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> WAKE_CHAIN;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;hop&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> WAKE_HOP;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;broadcast-single-sem&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> WAKE_BROADCAST_ONESEM;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;broadcast-per-thread&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> WAKE_BROADCAST_PERTHREAD;
	} <span class="enscript-keyword">else</span> {
		errx(EX_USAGE, <span class="enscript-string">&quot;Invalid wakeup pattern \&quot;%s\&quot;&quot;</span>, str);
	}
}

<span class="enscript-comment">/*
 * Set policy
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">thread_setup</span>(uint32_t my_id)
{
	kern_return_t kr;
	errno_t ret;
	thread_time_constraint_policy_data_t pol;

	<span class="enscript-keyword">switch</span> (g_policy) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_TIMESHARE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_REALTIME</span>:
			<span class="enscript-comment">/* Hard-coded realtime parameters (similar to what Digi uses) */</span>
			pol.period      = 100000;
			pol.constraint  = (uint32_t) nanos_to_abs(CONSTRAINT_NANOS);
			pol.computation = (uint32_t) nanos_to_abs(COMPUTATION_NANOS);
			pol.preemptible = 0; <span class="enscript-comment">/* Ignored by OS */</span>

			kr = thread_policy_set(mach_thread_self(), THREAD_TIME_CONSTRAINT_POLICY,
			                       (thread_policy_t) &amp;pol, THREAD_TIME_CONSTRAINT_POLICY_COUNT);
			mach_assert_zero_t(my_id, kr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_FIXEDPRI</span>:
			ret = pthread_set_fixedpriority_self();
			<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;pthread_set_fixedpriority_self&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			errx(EX_USAGE, <span class="enscript-string">&quot;invalid policy type %d&quot;</span>, g_policy);
	}

	<span class="enscript-keyword">if</span> (g_do_affinity) {
		thread_affinity_policy_data_t affinity;

		affinity.affinity_tag = my_id % 2;

		kr = thread_policy_set(mach_thread_self(), THREAD_AFFINITY_POLICY,
		                       (thread_policy_t)&amp;affinity, THREAD_AFFINITY_POLICY_COUNT);
		mach_assert_zero_t(my_id, kr);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Wait for a wakeup, potentially wake up another of the &quot;0-N&quot; threads,
 * and notify the main thread when done.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>*
<span class="enscript-function-name">worker_thread</span>(<span class="enscript-type">void</span> *arg)
{
	uint32_t my_id = (uint32_t)(uintptr_t)arg;
	kern_return_t kr;

	<span class="enscript-type">volatile</span> <span class="enscript-type">double</span> x = 0.0;
	<span class="enscript-type">volatile</span> <span class="enscript-type">double</span> y = 0.0;

	<span class="enscript-comment">/* Set policy and so forth */</span>
	thread_setup(my_id);

	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_iterations; i++) {
		<span class="enscript-keyword">if</span> (my_id == 0) {
			<span class="enscript-comment">/*
			 * Leader thread either wakes everyone up or starts the chain going.
			 */</span>

			<span class="enscript-comment">/* Give the worker threads undisturbed time to finish before waiting on them */</span>
			<span class="enscript-keyword">if</span> (g_do_sleep)
				usleep(g_iteration_sleeptime_us);

			debug_log(<span class="enscript-string">&quot;%d Leader thread wait for ready\n&quot;</span>, i);

			<span class="enscript-comment">/*
			 * Wait for everyone else to declare ready
			 * Is there a better way to do this that won't interfere with the rest of the chain?
			 * TODO: Invent 'semaphore wait for N signals'
			 */</span>

			<span class="enscript-keyword">for</span> (uint32_t j = 0 ; j &lt; g_numthreads - 1; j++) {
				kr = semaphore_wait(g_readysem);
				mach_assert_zero_t(my_id, kr);
			}

			debug_log(<span class="enscript-string">&quot;%d Leader thread wait\n&quot;</span>, i);

			<span class="enscript-comment">/* Signal main thread and wait for start of iteration */</span>

			kr = semaphore_wait_signal(g_leadersem, g_main_sem);
			mach_assert_zero_t(my_id, kr);

			g_thread_endtimes_abs[my_id] = mach_absolute_time();

			debug_log(<span class="enscript-string">&quot;%d Leader thread go\n&quot;</span>, i);

			assert_zero_t(my_id, g_done_threads);

			<span class="enscript-keyword">switch</span> (g_waketype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_BROADCAST_ONESEM</span>:
				kr = semaphore_signal_all(g_broadcastsem);
				mach_assert_zero_t(my_id, kr);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_BROADCAST_PERTHREAD</span>:
				<span class="enscript-keyword">for</span> (uint32_t j = 1; j &lt; g_numthreads; j++) {
					kr = semaphore_signal(g_semarr[j]);
					mach_assert_zero_t(my_id, kr);
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_CHAIN</span>:
				kr = semaphore_signal(g_semarr[my_id + 1]);
				mach_assert_zero_t(my_id, kr);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_HOP</span>:
				kr = semaphore_wait_signal(g_donesem, g_semarr[my_id + 1]);
				mach_assert_zero_t(my_id, kr);
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Everyone else waits to be woken up,
			 * records when she wakes up, and possibly
			 * wakes up a friend.
			 */</span>
			<span class="enscript-keyword">switch</span>(g_waketype)  {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_BROADCAST_ONESEM</span>:
				kr = semaphore_wait_signal(g_broadcastsem, g_readysem);
				mach_assert_zero_t(my_id, kr);

				g_thread_endtimes_abs[my_id] = mach_absolute_time();
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_BROADCAST_PERTHREAD</span>:
				kr = semaphore_wait_signal(g_semarr[my_id], g_readysem);
				mach_assert_zero_t(my_id, kr);

				g_thread_endtimes_abs[my_id] = mach_absolute_time();
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_CHAIN</span>:
				kr = semaphore_wait_signal(g_semarr[my_id], g_readysem);
				mach_assert_zero_t(my_id, kr);

				<span class="enscript-comment">/* Signal the next thread *after* recording wake time */</span>

				g_thread_endtimes_abs[my_id] = mach_absolute_time();

				<span class="enscript-keyword">if</span> (my_id &lt; (g_numthreads - 1)) {
					kr = semaphore_signal(g_semarr[my_id + 1]);
					mach_assert_zero_t(my_id, kr);
				}

				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">WAKE_HOP</span>:
				kr = semaphore_wait_signal(g_semarr[my_id], g_readysem);
				mach_assert_zero_t(my_id, kr);

				<span class="enscript-comment">/* Signal the next thread *after* recording wake time */</span>

				g_thread_endtimes_abs[my_id] = mach_absolute_time();

				<span class="enscript-keyword">if</span> (my_id &lt; (g_numthreads - 1)) {
					kr = semaphore_wait_signal(g_donesem, g_semarr[my_id + 1]);
					mach_assert_zero_t(my_id, kr);
				} <span class="enscript-keyword">else</span> {
					kr = semaphore_signal_all(g_donesem);
					mach_assert_zero_t(my_id, kr);
				}

				<span class="enscript-keyword">break</span>;
			}
		}

		debug_log(<span class="enscript-string">&quot;Thread %p woke up for iteration %d.\n&quot;</span>, pthread_self(), i);

		<span class="enscript-keyword">if</span> (g_do_one_long_spin &amp;&amp; g_one_long_spin_id == my_id) {
			<span class="enscript-comment">/* One randomly chosen thread holds up the train for a while. */</span>

			uint64_t endspin = g_starttime_abs + g_one_long_spin_length_abs;
			<span class="enscript-keyword">while</span> (mach_absolute_time() &lt; endspin) {
				y = y + 1.5 + x;
				x = sqrt(y);
			}
		}

		<span class="enscript-keyword">if</span> (g_do_each_spin) {
			<span class="enscript-comment">/* Each thread spins for a certain duration after waking up before blocking again. */</span>

			uint64_t endspin = mach_absolute_time() + g_each_spin_duration_abs;
			<span class="enscript-keyword">while</span> (mach_absolute_time() &lt; endspin) {
				y = y + 1.5 + x;
				x = sqrt(y);
			}
		}

		int32_t new = OSAtomicIncrement32((<span class="enscript-type">volatile</span> int32_t *)&amp;g_done_threads);
		(<span class="enscript-type">void</span>)new;

		debug_log(<span class="enscript-string">&quot;Thread %p new value is %d, iteration %d\n&quot;</span>, pthread_self(), new, i);

		<span class="enscript-keyword">if</span> (g_do_all_spin) {
			<span class="enscript-comment">/* Everyone spins until the last thread checks in. */</span>

			<span class="enscript-keyword">while</span> (g_done_threads &lt; g_numthreads) {
				y = y + 1.5 + x;
				x = sqrt(y);
			}
		}

		debug_log(<span class="enscript-string">&quot;Thread %p done spinning, iteration %d\n&quot;</span>, pthread_self(), i);
	}

	<span class="enscript-keyword">if</span> (my_id == 0) {
		<span class="enscript-comment">/* Give the worker threads undisturbed time to finish before waiting on them */</span>
		<span class="enscript-keyword">if</span> (g_do_sleep)
			usleep(g_iteration_sleeptime_us);

		<span class="enscript-comment">/* Wait for the worker threads to finish */</span>
		<span class="enscript-keyword">for</span> (uint32_t i = 0 ; i &lt; g_numthreads - 1; i++) {
			kr = semaphore_wait(g_readysem);
			mach_assert_zero_t(my_id, kr);
		}

		<span class="enscript-comment">/* Tell everyone and the main thread that the last iteration is done */</span>
		debug_log(<span class="enscript-string">&quot;%d Leader thread done\n&quot;</span>, i);

		kr = semaphore_signal_all(g_main_sem);
		mach_assert_zero_t(my_id, kr);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Hold up thread teardown so it doesn't affect the last iteration */</span>
		kr = semaphore_wait_signal(g_main_sem, g_readysem);
		mach_assert_zero_t(my_id, kr);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Given an array of uint64_t values, compute average, max, min, and standard deviation
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">compute_stats</span>(uint64_t *values, uint64_t count, <span class="enscript-type">float</span> *averagep, uint64_t *maxp, uint64_t *minp, <span class="enscript-type">float</span> *stddevp)
{
	uint32_t i;
	uint64_t _sum = 0;
	uint64_t _max = 0;
	uint64_t _min = UINT64_MAX;
	<span class="enscript-type">float</span>	 _avg = 0;
	<span class="enscript-type">float</span> 	 _dev = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		_sum += values[i];
		_max = values[i] &gt; _max ? values[i] : _max;
		_min = values[i] &lt; _min ? values[i] : _min;
	}

	_avg = ((<span class="enscript-type">float</span>)_sum) / ((<span class="enscript-type">float</span>)count);
	
	_dev = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		_dev += powf((((<span class="enscript-type">float</span>)values[i]) - _avg), 2);
	}
	
	_dev /= count;
	_dev = sqrtf(_dev);

	*averagep = _avg;
	*maxp = _max;
	*minp = _min;
	*stddevp = _dev;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
	errno_t ret;
	kern_return_t kr;

	pthread_t	*threads;
	uint64_t	*worst_latencies_ns;
	uint64_t	*worst_latencies_from_first_ns;
	uint64_t	max, min;
	<span class="enscript-type">float</span>		avg, stddev;

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; argc; i++)
		<span class="enscript-keyword">if</span> (strcmp(argv[i], <span class="enscript-string">&quot;--switched_apptype&quot;</span>) == 0)
			g_seen_apptype = TRUE;

	<span class="enscript-keyword">if</span> (!g_seen_apptype)
		selfexec_with_apptype(argc, argv);

	parse_args(argc, argv);

	srand((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)time(NULL));

	mach_timebase_info(&amp;g_mti);

	size_t ncpu_size = <span class="enscript-keyword">sizeof</span>(g_numcpus);
	ret = sysctlbyname(<span class="enscript-string">&quot;hw.ncpu&quot;</span>, &amp;g_numcpus, &amp;ncpu_size, NULL, 0);
	<span class="enscript-keyword">if</span> (ret) err(EX_OSERR, <span class="enscript-string">&quot;Failed sysctlbyname(hw.ncpu)&quot;</span>);

	<span class="enscript-keyword">if</span> (g_do_each_spin)
		g_each_spin_duration_abs = nanos_to_abs(g_each_spin_duration_ns);

	<span class="enscript-comment">/* Configure the long-spin thread to take up half of its computation */</span>
	<span class="enscript-keyword">if</span> (g_do_one_long_spin) {
		g_one_long_spin_length_ns = COMPUTATION_NANOS / 2;
		g_one_long_spin_length_abs = nanos_to_abs(g_one_long_spin_length_ns);
	}

	<span class="enscript-comment">/* Estimate the amount of time the cleanup phase needs to back off */</span>
	g_iteration_sleeptime_us = g_numthreads * 20;

	uint32_t threads_per_core = (g_numthreads / g_numcpus) + 1;
	<span class="enscript-keyword">if</span> (g_do_each_spin)
		g_iteration_sleeptime_us += threads_per_core * (g_each_spin_duration_ns / NSEC_PER_USEC);
	<span class="enscript-keyword">if</span> (g_do_one_long_spin)
		g_iteration_sleeptime_us += g_one_long_spin_length_ns / NSEC_PER_USEC;

	<span class="enscript-comment">/* Arrays for threads and their wakeup times */</span>
	threads = (pthread_t*) valloc(<span class="enscript-keyword">sizeof</span>(pthread_t) * g_numthreads);
	assert(threads);

	size_t endtimes_size = <span class="enscript-keyword">sizeof</span>(uint64_t) * g_numthreads;

	g_thread_endtimes_abs = (uint64_t*) valloc(endtimes_size);
	assert(g_thread_endtimes_abs);

	<span class="enscript-comment">/* Ensure the allocation is pre-faulted */</span>
	ret = memset_s(g_thread_endtimes_abs, endtimes_size, 0, endtimes_size);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;memset_s endtimes&quot;</span>);

	size_t latencies_size = <span class="enscript-keyword">sizeof</span>(uint64_t) * g_iterations;

	worst_latencies_ns = (uint64_t*) valloc(latencies_size);
	assert(worst_latencies_ns);

	<span class="enscript-comment">/* Ensure the allocation is pre-faulted */</span>
	ret = memset_s(worst_latencies_ns, latencies_size, 0, latencies_size);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;memset_s latencies&quot;</span>);

	worst_latencies_from_first_ns = (uint64_t*) valloc(latencies_size);
	assert(worst_latencies_from_first_ns);

	<span class="enscript-comment">/* Ensure the allocation is pre-faulted */</span>
	ret = memset_s(worst_latencies_from_first_ns, latencies_size, 0, latencies_size);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;memset_s latencies_from_first&quot;</span>);

	kr = semaphore_create(mach_task_self(), &amp;g_main_sem, SYNC_POLICY_FIFO, 0);
	mach_assert_zero(kr);

	<span class="enscript-comment">/* Either one big semaphore or one per thread */</span>
	<span class="enscript-keyword">if</span> (g_waketype == WAKE_CHAIN ||
	    g_waketype == WAKE_BROADCAST_PERTHREAD ||
	    g_waketype == WAKE_HOP) {

		g_semarr = valloc(<span class="enscript-keyword">sizeof</span>(semaphore_t) * g_numthreads);
		assert(g_semarr);

		<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_numthreads; i++) {
			kr = semaphore_create(mach_task_self(), &amp;g_semarr[i], SYNC_POLICY_FIFO, 0);
			mach_assert_zero(kr);
		}

		g_leadersem = g_semarr[0];
	} <span class="enscript-keyword">else</span> {
		kr = semaphore_create(mach_task_self(), &amp;g_broadcastsem, SYNC_POLICY_FIFO, 0);
		mach_assert_zero(kr);
		kr = semaphore_create(mach_task_self(), &amp;g_leadersem, SYNC_POLICY_FIFO, 0);
		mach_assert_zero(kr);
	}

	<span class="enscript-keyword">if</span> (g_waketype == WAKE_HOP) {
		kr = semaphore_create(mach_task_self(), &amp;g_donesem, SYNC_POLICY_FIFO, 0);
		mach_assert_zero(kr);
	}

	kr = semaphore_create(mach_task_self(), &amp;g_readysem, SYNC_POLICY_FIFO, 0);
	mach_assert_zero(kr);

	<span class="enscript-comment">/* Create the threads */</span>
	g_done_threads = 0;
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_numthreads; i++) {
		ret = pthread_create(&amp;threads[i], NULL, worker_thread, (<span class="enscript-type">void</span>*)(uintptr_t)i);
		<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;pthread_create %d&quot;</span>, i);
	}

	ret = setpriority(PRIO_DARWIN_ROLE, 0, PRIO_DARWIN_ROLE_UI_FOCAL);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;setpriority&quot;</span>);

	thread_setup(0);

	<span class="enscript-comment">/* Let everyone get settled */</span>
	kr = semaphore_wait(g_main_sem);
	mach_assert_zero(kr);

	<span class="enscript-comment">/* Give the system a bit more time to settle */</span>
	<span class="enscript-keyword">if</span> (g_do_sleep)
		usleep(g_iteration_sleeptime_us);

	<span class="enscript-comment">/* Go! */</span>
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_iterations; i++) {
		uint32_t j;
		uint64_t worst_abs = 0, best_abs = UINT64_MAX;

		<span class="enscript-keyword">if</span> (g_do_one_long_spin)
			g_one_long_spin_id = (uint32_t)rand() % g_numthreads;

		debug_log(<span class="enscript-string">&quot;%d Main thread reset\n&quot;</span>, i);

		g_done_threads = 0;
		OSMemoryBarrier();

		g_starttime_abs = mach_absolute_time();

		<span class="enscript-comment">/* Fire them off and wait for worker threads to finish */</span>
		kr = semaphore_wait_signal(g_main_sem, g_leadersem);
		mach_assert_zero(kr);

		debug_log(<span class="enscript-string">&quot;%d Main thread return\n&quot;</span>, i);

		<span class="enscript-comment">/*
		 * We report the worst latencies relative to start time
		 * and relative to the lead worker thread.
		 */</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; g_numthreads; j++) {
			uint64_t latency_abs;

			latency_abs = g_thread_endtimes_abs[j] - g_starttime_abs;
			worst_abs = worst_abs &lt; latency_abs ? latency_abs : worst_abs;
		}
	
		worst_latencies_ns[i] = abs_to_nanos(worst_abs);

		worst_abs = 0;
		<span class="enscript-keyword">for</span> (j = 1; j &lt; g_numthreads; j++) {
			uint64_t latency_abs;
		
			latency_abs = g_thread_endtimes_abs[j] - g_thread_endtimes_abs[0];
			worst_abs = worst_abs &lt; latency_abs ? latency_abs : worst_abs;
			best_abs = best_abs &gt; latency_abs ? latency_abs : best_abs;
		}

		worst_latencies_from_first_ns[i] = abs_to_nanos(worst_abs);

		<span class="enscript-comment">/*
		 * In the event of a bad run, cut a trace point.
		 */</span>
		<span class="enscript-keyword">if</span> (worst_latencies_from_first_ns[i] &gt; g_traceworthy_latency_ns) {
			<span class="enscript-comment">/* Ariadne's ad-hoc test signpost */</span>
			kdebug_trace(ARIADNEDBG_CODE(0, 0), worst_latencies_from_first_ns[i], g_traceworthy_latency_ns, 0, 0);

			<span class="enscript-keyword">if</span> (g_verbose)
				printf(<span class="enscript-string">&quot;Worst on this round was %.2f us.\n&quot;</span>, ((<span class="enscript-type">float</span>)worst_latencies_from_first_ns[i]) / 1000.0);
		}

		<span class="enscript-comment">/* Give the system a bit more time to settle */</span>
		<span class="enscript-keyword">if</span> (g_do_sleep)
			usleep(g_iteration_sleeptime_us);
	}

	<span class="enscript-comment">/* Rejoin threads */</span>
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_numthreads; i++) {
		ret = pthread_join(threads[i], NULL);
		<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;pthread_join %d&quot;</span>, i);
	}

	compute_stats(worst_latencies_ns, g_iterations, &amp;avg, &amp;max, &amp;min, &amp;stddev);
	printf(<span class="enscript-string">&quot;Results (from a stop):\n&quot;</span>);
	printf(<span class="enscript-string">&quot;Max:\t\t%.2f us\n&quot;</span>, ((<span class="enscript-type">float</span>)max) / 1000.0);
	printf(<span class="enscript-string">&quot;Min:\t\t%.2f us\n&quot;</span>, ((<span class="enscript-type">float</span>)min) / 1000.0);
	printf(<span class="enscript-string">&quot;Avg:\t\t%.2f us\n&quot;</span>, avg / 1000.0);
	printf(<span class="enscript-string">&quot;Stddev:\t\t%.2f us\n&quot;</span>, stddev / 1000.0);

	putchar(<span class="enscript-string">'\n'</span>);

	compute_stats(worst_latencies_from_first_ns, g_iterations, &amp;avg, &amp;max, &amp;min, &amp;stddev);
	printf(<span class="enscript-string">&quot;Results (relative to first thread):\n&quot;</span>);
	printf(<span class="enscript-string">&quot;Max:\t\t%.2f us\n&quot;</span>, ((<span class="enscript-type">float</span>)max) / 1000.0);
	printf(<span class="enscript-string">&quot;Min:\t\t%.2f us\n&quot;</span>, ((<span class="enscript-type">float</span>)min) / 1000.0);
	printf(<span class="enscript-string">&quot;Avg:\t\t%.2f us\n&quot;</span>, avg / 1000.0);
	printf(<span class="enscript-string">&quot;Stddev:\t\t%.2f us\n&quot;</span>, stddev / 1000.0);

#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; g_iterations; i++) {
		printf(<span class="enscript-string">&quot;Iteration %d: %f us\n&quot;</span>, i, worst_latencies_ns[i] / 1000.0);
	}
#<span class="enscript-reference">endif</span>

	free(threads);
	free(g_thread_endtimes_abs);
	free(worst_latencies_ns);
	free(worst_latencies_from_first_ns);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * WARNING: This is SPI specifically intended for use by launchd to start UI
 * apps. We use it here for a test tool only to opt into QoS using the same
 * policies. Do not use this outside xnu or libxpc/launchd.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">selfexec_with_apptype</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[])
{
	<span class="enscript-type">int</span> ret;
	posix_spawnattr_t attr;
	<span class="enscript-type">extern</span> <span class="enscript-type">char</span> **environ;
	<span class="enscript-type">char</span> *new_argv[argc + 1 + 1 <span class="enscript-comment">/* NULL */</span>];
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">char</span> prog[PATH_MAX];
	uint32_t prog_size = PATH_MAX;

	ret = _NSGetExecutablePath(prog, &amp;prog_size);
	<span class="enscript-keyword">if</span> (ret) err(EX_OSERR, <span class="enscript-string">&quot;_NSGetExecutablePath&quot;</span>);

	<span class="enscript-keyword">for</span> (i=0; i &lt; argc; i++) {
		new_argv[i] = argv[i];
	}

	new_argv[i]   = <span class="enscript-string">&quot;--switched_apptype&quot;</span>;
	new_argv[i+1] = NULL;

	ret = posix_spawnattr_init(&amp;attr);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;posix_spawnattr_init&quot;</span>);

	ret = posix_spawnattr_setflags(&amp;attr, POSIX_SPAWN_SETEXEC);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;posix_spawnattr_setflags&quot;</span>);

	ret = posix_spawnattr_setprocesstype_np(&amp;attr, POSIX_SPAWN_PROC_TYPE_APP_DEFAULT);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;posix_spawnattr_setprocesstype_np&quot;</span>);

	ret = posix_spawn(NULL, prog, NULL, &amp;attr, new_argv, environ);
	<span class="enscript-keyword">if</span> (ret) errc(EX_OSERR, ret, <span class="enscript-string">&quot;posix_spawn&quot;</span>);
}

<span class="enscript-comment">/*
 * Admittedly not very attractive.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span>((noreturn))
<span class="enscript-function-name">usage</span>()
{
	errx(EX_USAGE, <span class="enscript-string">&quot;Usage: zn &lt;threads&gt; &lt;chain | hop | broadcast-single-sem | broadcast-per-thread&gt; &quot;</span>
	     <span class="enscript-string">&quot;&lt;realtime | timeshare | fixed&gt; &lt;iterations&gt; [--trace &lt;traceworthy latency in ns&gt;] &quot;</span>
	     <span class="enscript-string">&quot;[--spin-one] [--spin-all] [--spin-time &lt;nanos&gt;] [--affinity] [--no-sleep] [--verbose]&quot;</span>);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">parse_args</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[])
{
	<span class="enscript-type">int</span> ch, option_index = 0;
	<span class="enscript-type">char</span> *cp;

	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> option longopts[] = {
		{ <span class="enscript-string">&quot;spin-time&quot;</span>,          required_argument,      NULL,                           2 },
		{ <span class="enscript-string">&quot;trace&quot;</span>,              required_argument,      NULL,                           3 },
		{ <span class="enscript-string">&quot;switched_apptype&quot;</span>,   no_argument,            (<span class="enscript-type">int</span>*)&amp;g_seen_apptype,          TRUE },
		{ <span class="enscript-string">&quot;spin-one&quot;</span>,           no_argument,            (<span class="enscript-type">int</span>*)&amp;g_do_one_long_spin,      TRUE },
		{ <span class="enscript-string">&quot;spin-all&quot;</span>,           no_argument,            (<span class="enscript-type">int</span>*)&amp;g_do_all_spin,           TRUE },
		{ <span class="enscript-string">&quot;affinity&quot;</span>,           no_argument,            (<span class="enscript-type">int</span>*)&amp;g_do_affinity,           TRUE },
		{ <span class="enscript-string">&quot;no-sleep&quot;</span>,           no_argument,            (<span class="enscript-type">int</span>*)&amp;g_do_sleep,              FALSE },
		{ <span class="enscript-string">&quot;verbose&quot;</span>,            no_argument,            (<span class="enscript-type">int</span>*)&amp;g_verbose,               TRUE },
		{ <span class="enscript-string">&quot;help&quot;</span>,               no_argument,            NULL,                           <span class="enscript-string">'h'</span> },
		{ NULL,                 0,                      NULL,                           0 }
	};

	<span class="enscript-keyword">while</span> ((ch = getopt_long(argc, argv, <span class="enscript-string">&quot;h&quot;</span>, longopts, &amp;option_index)) != -1) {
		<span class="enscript-keyword">switch</span> (ch) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* getopt_long set a variable */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
			<span class="enscript-comment">/* spin-time */</span>
			g_do_each_spin = TRUE;
			g_each_spin_duration_ns = strtoull(optarg, &amp;cp, 10);

			<span class="enscript-keyword">if</span> (cp == optarg || *cp)
				errx(EX_USAGE, <span class="enscript-string">&quot;arg --%s requires a decimal number, found \&quot;%s\&quot;&quot;</span>,
				     longopts[option_index].name, optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			<span class="enscript-comment">/* trace */</span>
			g_traceworthy_latency_ns = strtoull(optarg, &amp;cp, 10);

			<span class="enscript-keyword">if</span> (cp == optarg || *cp)
				errx(EX_USAGE, <span class="enscript-string">&quot;arg --%s requires a decimal number, found \&quot;%s\&quot;&quot;</span>,
				     longopts[option_index].name, optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>:
		<span class="enscript-reference">default</span>:
			usage();
			<span class="enscript-comment">/* NORETURN */</span>
		}
	}

	<span class="enscript-comment">/*
	 * getopt_long reorders all the options to the beginning of the argv array.
	 * Jump past them to the non-option arguments.
	 */</span>

	argc -= optind;
	argv += optind;

	<span class="enscript-keyword">if</span> (argc &gt; 4) {
		warnx(<span class="enscript-string">&quot;Too many non-option arguments passed&quot;</span>);
		usage();
	}

	<span class="enscript-keyword">if</span> (argc != 4) {
		warnx(<span class="enscript-string">&quot;Missing required &lt;threads&gt; &lt;waketype&gt; &lt;policy&gt; &lt;iterations&gt; arguments&quot;</span>);
		usage();
	}

	<span class="enscript-comment">/* How many threads? */</span>
	g_numthreads = (uint32_t)strtoull(argv[0], &amp;cp, 10);

	<span class="enscript-keyword">if</span> (cp == argv[0] || *cp)
		errx(EX_USAGE, <span class="enscript-string">&quot;numthreads requires a decimal number, found \&quot;%s\&quot;&quot;</span>, argv[0]);

	<span class="enscript-keyword">if</span> (g_numthreads &lt; 1)
		errx(EX_USAGE, <span class="enscript-string">&quot;Must use at least one thread&quot;</span>);

	<span class="enscript-comment">/* What wakeup pattern? */</span>
	g_waketype = parse_wakeup_pattern(argv[1]);

	<span class="enscript-comment">/* Policy */</span>
	g_policy = parse_thread_policy(argv[2]);

	<span class="enscript-comment">/* Iterations */</span>
	g_iterations = (uint32_t)strtoull(argv[3], &amp;cp, 10);

	<span class="enscript-keyword">if</span> (cp == argv[3] || *cp)
		errx(EX_USAGE, <span class="enscript-string">&quot;numthreads requires a decimal number, found \&quot;%s\&quot;&quot;</span>, argv[3]);

	<span class="enscript-keyword">if</span> (g_iterations &lt; 1)
		errx(EX_USAGE, <span class="enscript-string">&quot;Must have at least one iteration&quot;</span>);

	<span class="enscript-keyword">if</span> (g_numthreads == 1 &amp;&amp; g_waketype == WAKE_CHAIN)
		errx(EX_USAGE, <span class="enscript-string">&quot;chain mode requires more than one thread&quot;</span>);

	<span class="enscript-keyword">if</span> (g_numthreads == 1 &amp;&amp; g_waketype == WAKE_HOP)
		errx(EX_USAGE, <span class="enscript-string">&quot;hop mode requires more than one thread&quot;</span>);
}


</pre>
<hr />
</body></html>