<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lmbench_select_tcp.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lmbench_select_tcp.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 *	Order of Execution
 *
 *	benchmark_init
 *
 *	benchmark_optswitch
 *
 *		benchmark_initrun
 *
 *			benchmark_initworker
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch, etc.
 *			benchmark_finiworker
 *
 *		benchmark_result
 *
 *		benchmark_finirun
 *
 *	benchmark_fini
 */</span>



#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__sun</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">ident</span>	<span class="enscript-string">&quot;@(#)socket.c	1.3	05/08/04 Apple Inc.&quot;</span>
#<span class="enscript-reference">endif</span>



#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netdb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;rpc/rpc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;rpc/pmap_clnt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../libmicro.h&quot;</span>

<span class="enscript-comment">/*
 * lmbench routines, etc. brought over for this benchmark
 */</span>
<span class="enscript-type">int</span>  	open_file(<span class="enscript-type">void</span>* tsd);
<span class="enscript-type">void</span> 	server(<span class="enscript-type">void</span>* tsd);
<span class="enscript-type">int</span>		tcp_accept(<span class="enscript-type">int</span> sock, <span class="enscript-type">int</span> rdwr);
<span class="enscript-type">void</span>	sock_optimize(<span class="enscript-type">int</span> sock, <span class="enscript-type">int</span> flags);
<span class="enscript-type">int</span>		sockport(<span class="enscript-type">int</span> s);
<span class="enscript-type">int</span>		tcp_server(<span class="enscript-type">int</span> prog, <span class="enscript-type">int</span> rdwr);
<span class="enscript-type">int</span>		tcp_connect(<span class="enscript-type">char</span> *host, <span class="enscript-type">int</span> prog, <span class="enscript-type">int</span> rdwr);
<span class="enscript-type">int</span>		open_socket(<span class="enscript-type">void</span> *tsd);


<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*open_f)(<span class="enscript-type">void</span>* tsd);
<span class="enscript-comment">/*
 * end of lmbench support routines
 */</span>

<span class="enscript-comment">/*
 *	Your state variables should live in the tsd_t struct below
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">char</span>	fname[L_tmpnam];
	open_f	fid_f;
	pid_t	pid;
	<span class="enscript-type">int</span>	sock;
	<span class="enscript-type">int</span>	fid;
	<span class="enscript-type">int</span>	num;
	<span class="enscript-type">int</span>	max;
	fd_set  set;
} tsd_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optt = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optn = -1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optp = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	optw = 0;

<span class="enscript-comment">/*
 * lmbench routines, etc. brought over for this benchmark
 */</span>
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">morefds</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">RLIMIT_NOFILE</span>
        <span class="enscript-type">struct</span>  rlimit r;

        getrlimit(RLIMIT_NOFILE, &amp;r);
        r.rlim_cur = r.rlim_max;
        setrlimit(RLIMIT_NOFILE, &amp;r);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">open_file</span>(<span class="enscript-type">void</span>* tsd)
{
	tsd_t* ts = (tsd_t*)tsd;
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) open(ts-&gt;fname, O_RDONLY);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">open_socket</span>(<span class="enscript-type">void</span>* tsd)
{
	<span class="enscript-keyword">return</span> tcp_connect(<span class="enscript-string">&quot;localhost&quot;</span>, TCP_SELECT, SOCKOPT_NONE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">server</span>(<span class="enscript-type">void</span>* tsd)
{
	<span class="enscript-type">int</span> pid;
	tsd_t		*ts = (tsd_t *)tsd;

	pid = getpid();
	ts-&gt;pid = 0;

	<span class="enscript-keyword">if</span> (ts-&gt;fid_f == open_file) {
		<span class="enscript-comment">/* Create a temporary file for clients to open */</span>
		sprintf(ts-&gt;fname, <span class="enscript-string">&quot;lat_selectXXXXXX&quot;</span>);
		ts-&gt;fid = mkstemp(ts-&gt;fname);
		<span class="enscript-keyword">if</span> (ts-&gt;fid &lt;= 0) {
			<span class="enscript-type">char</span> buf[L_tmpnam+128];
			sprintf(buf, <span class="enscript-string">&quot;lat_select: Could not create temp file %s&quot;</span>, ts-&gt;fname);
			perror(buf);
			exit(1);
		}
		close(ts-&gt;fid);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Create a socket for clients to connect to */</span>
	ts-&gt;sock = tcp_server(TCP_SELECT, SOCKOPT_REUSE);
	<span class="enscript-keyword">if</span> (ts-&gt;sock &lt;= 0) {
		perror(<span class="enscript-string">&quot;lat_select: Could not open tcp server socket&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* Start a server process to accept client connections */</span>
	<span class="enscript-keyword">switch</span>(ts-&gt;pid = fork()) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">/* child server process */</span>
		<span class="enscript-keyword">while</span> (pid == getppid()) {
			<span class="enscript-type">int</span> newsock = tcp_accept(ts-&gt;sock, SOCKOPT_NONE);
			read(newsock, &amp;ts-&gt;fid, 1);
			close(newsock);
		}
		exit(0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>:
		<span class="enscript-comment">/* error */</span>
		perror(<span class="enscript-string">&quot;lat_select::server(): fork() failed&quot;</span>);
		exit(1);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}


<span class="enscript-comment">/*
 * Accept a connection and return it
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_accept</span>(<span class="enscript-type">int</span> sock, <span class="enscript-type">int</span> rdwr)
{
    <span class="enscript-type">struct</span> sockaddr_in 	s;
    <span class="enscript-type">int</span> 				newsock;
    socklen_t			namelen;

    namelen = <span class="enscript-keyword">sizeof</span>(s);
    bzero((<span class="enscript-type">void</span>*)&amp;s, namelen);

<span class="enscript-reference">retry</span>:
    <span class="enscript-keyword">if</span> ((newsock = accept(sock, (<span class="enscript-type">struct</span> sockaddr*)&amp;s, &amp;namelen)) &lt; 0) {
        <span class="enscript-keyword">if</span> (errno == EINTR)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
        perror(<span class="enscript-string">&quot;accept&quot;</span>);
        exit(6);
    }
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">LIBTCP_VERBOSE</span>
    fprintf(stderr, <span class="enscript-string">&quot;Server newsock port %d\n&quot;</span>, sockport(newsock));
#<span class="enscript-reference">endif</span>
    sock_optimize(newsock, rdwr);
    <span class="enscript-keyword">return</span> (newsock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sock_optimize</span>(<span class="enscript-type">int</span> sock, <span class="enscript-type">int</span> flags)
{
    <span class="enscript-keyword">if</span> (flags &amp; SOCKOPT_READ) {
        <span class="enscript-type">int</span> sockbuf = SOCKBUF;

        <span class="enscript-keyword">while</span> (setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &amp;sockbuf,
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>))) {
            sockbuf &gt;&gt;= 1;
        }
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">LIBTCP_VERBOSE</span>
        fprintf(stderr, <span class="enscript-string">&quot;sockopt %d: RCV: %dK\n&quot;</span>, sock, sockbuf&gt;&gt;10);
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">if</span> (flags &amp; SOCKOPT_WRITE) {
        <span class="enscript-type">int</span> sockbuf = SOCKBUF;

        <span class="enscript-keyword">while</span> (setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &amp;sockbuf,
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>))) {
            sockbuf &gt;&gt;= 1;
        }
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">LIBTCP_VERBOSE</span>
        fprintf(stderr, <span class="enscript-string">&quot;sockopt %d: SND: %dK\n&quot;</span>, sock, sockbuf&gt;&gt;10);
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">if</span> (flags &amp; SOCKOPT_REUSE) {
        <span class="enscript-type">int</span> val = 1;
        <span class="enscript-keyword">if</span> (setsockopt(sock, SOL_SOCKET,
            SO_REUSEADDR, &amp;val, <span class="enscript-keyword">sizeof</span>(val)) == -1) {
            perror(<span class="enscript-string">&quot;SO_REUSEADDR&quot;</span>);
        }
    }
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sockport</span>(<span class="enscript-type">int</span> s)
{
	socklen_t	namelen;
	<span class="enscript-type">struct</span> sockaddr_in sin;

	namelen = <span class="enscript-keyword">sizeof</span>(sin);
	<span class="enscript-keyword">if</span> (getsockname(s, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin, &amp;namelen) &lt; 0) {
		perror(<span class="enscript-string">&quot;getsockname&quot;</span>);
		<span class="enscript-keyword">return</span>(-1);
	}
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">int</span>)ntohs(sin.sin_port));
}

<span class="enscript-comment">/*
 * Get a TCP socket, bind it, figure out the port,
 * and advertise the port as program &quot;prog&quot;.
 *
 * XXX - it would be nice if you could advertise ascii strings.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_server</span>(<span class="enscript-type">int</span> prog, <span class="enscript-type">int</span> rdwr)
{
	<span class="enscript-type">int</span>	sock;
	<span class="enscript-type">struct</span>	sockaddr_in s;

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">LIBTCP_VERBOSE</span>
	fprintf(stderr, <span class="enscript-string">&quot;tcp_server(%u, %u)\n&quot;</span>, prog, rdwr);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
		perror(<span class="enscript-string">&quot;socket&quot;</span>);
		exit(1);
	}
	sock_optimize(sock, rdwr);
	bzero((<span class="enscript-type">void</span>*)&amp;s, <span class="enscript-keyword">sizeof</span>(s));
	s.sin_family = AF_INET;
	<span class="enscript-keyword">if</span> (prog &lt; 0) {
		s.sin_port = htons(-prog);
	}
	<span class="enscript-keyword">if</span> (bind(sock, (<span class="enscript-type">struct</span> sockaddr*)&amp;s, <span class="enscript-keyword">sizeof</span>(s)) &lt; 0) {
		perror(<span class="enscript-string">&quot;bind&quot;</span>);
		exit(2);
	}
	<span class="enscript-keyword">if</span> (listen(sock, 100) &lt; 0) {
		perror(<span class="enscript-string">&quot;listen&quot;</span>);
		exit(4);
	}
	<span class="enscript-keyword">if</span> (prog &gt; 0) {
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">LIBTCP_VERBOSE</span>
		fprintf(stderr, <span class="enscript-string">&quot;Server port %d\n&quot;</span>, sockport(sock));
#<span class="enscript-reference">endif</span>
		(<span class="enscript-type">void</span>)pmap_unset((u_long)prog, (u_long)1);
		<span class="enscript-keyword">if</span> (!pmap_set((u_long)prog, (u_long)1, (u_long)IPPROTO_TCP,
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)sockport(sock))) {
			perror(<span class="enscript-string">&quot;pmap_set&quot;</span>);
			exit(5);
		}
	}
	<span class="enscript-keyword">return</span> (sock);
}


<span class="enscript-comment">/*
 * Connect to the TCP socket advertised as &quot;prog&quot; on &quot;host&quot; and
 * return the connected socket.
 *
 * Hacked Thu Oct 27 1994 to cache pmap_getport calls.  This saves
 * about 4000 usecs in loopback lat_connect calls.  I suppose we
 * should time gethostbyname() &amp; pmap_getprot(), huh?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_connect</span>(<span class="enscript-type">char</span> *host, <span class="enscript-type">int</span> prog, <span class="enscript-type">int</span> rdwr)
{
	<span class="enscript-type">static</span>	<span class="enscript-type">struct</span> hostent *h;
	<span class="enscript-type">static</span>	<span class="enscript-type">struct</span> sockaddr_in s;
	<span class="enscript-type">static</span>	u_short	save_port;
	<span class="enscript-type">static</span>	u_long save_prog;
	<span class="enscript-type">static</span>	<span class="enscript-type">char</span> *save_host;
	<span class="enscript-type">int</span>	sock;
	<span class="enscript-type">static</span>	<span class="enscript-type">int</span> tries = 0;

	<span class="enscript-keyword">if</span> ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
		perror(<span class="enscript-string">&quot;socket&quot;</span>);
		exit(1);
	}
	<span class="enscript-keyword">if</span> (rdwr &amp; SOCKOPT_PID) {
		<span class="enscript-type">static</span>	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> port;
		<span class="enscript-type">struct</span> sockaddr_in sin;

		<span class="enscript-keyword">if</span> (!port) {
			port = (<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)(getpid() &lt;&lt; 4);
			<span class="enscript-keyword">if</span> (port &lt; 1024) {
				port += 1024;
			}
		}
		<span class="enscript-keyword">do</span> {
			port++;
			bzero((<span class="enscript-type">void</span>*)&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
			sin.sin_family = AF_INET;
			sin.sin_port = htons(port);
		} <span class="enscript-keyword">while</span> (bind(sock, (<span class="enscript-type">struct</span> sockaddr*)&amp;sin, <span class="enscript-keyword">sizeof</span>(sin)) == -1);
	}
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">LIBTCP_VERBOSE</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockaddr_in sin;

		bzero((<span class="enscript-type">void</span>*)&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
		sin.sin_family = AF_INET;
		<span class="enscript-keyword">if</span> (bind(sock, (<span class="enscript-type">struct</span> sockaddr*)&amp;sin, <span class="enscript-keyword">sizeof</span>(sin)) &lt; 0) {
			perror(<span class="enscript-string">&quot;bind&quot;</span>);
			exit(2);
		}
	}
	fprintf(stderr, <span class="enscript-string">&quot;Client port %d\n&quot;</span>, sockport(sock));
#<span class="enscript-reference">endif</span>
	sock_optimize(sock, rdwr);
	<span class="enscript-keyword">if</span> (!h || host != save_host || prog != save_prog) {
		save_host = host;	<span class="enscript-comment">/* XXX - counting on them not
					 * changing it - benchmark only.
					 */</span>
		save_prog = prog;
		<span class="enscript-keyword">if</span> (!(h = gethostbyname(host))) {
			perror(host);
			exit(2);
		}
		bzero((<span class="enscript-type">void</span> *) &amp;s, <span class="enscript-keyword">sizeof</span>(s));
		s.sin_family = AF_INET;
		bcopy((<span class="enscript-type">void</span>*)h-&gt;h_addr, (<span class="enscript-type">void</span> *)&amp;s.sin_addr, h-&gt;h_length);
		<span class="enscript-keyword">if</span> (prog &gt; 0) {
			save_port = pmap_getport(&amp;s, prog,
			    (u_long)1, IPPROTO_TCP);
			<span class="enscript-keyword">if</span> (!save_port) {
				perror(<span class="enscript-string">&quot;lib TCP: No port found&quot;</span>);
				exit(3);
			}
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">LIBTCP_VERBOSE</span>
			fprintf(stderr, <span class="enscript-string">&quot;Server port %d\n&quot;</span>, save_port);
#<span class="enscript-reference">endif</span>
			s.sin_port = htons(save_port);
		} <span class="enscript-keyword">else</span> {
			s.sin_port = htons(-prog);
		}
	}
	<span class="enscript-keyword">if</span> (connect(sock, (<span class="enscript-type">struct</span> sockaddr*)&amp;s, <span class="enscript-keyword">sizeof</span>(s)) &lt; 0) {
		<span class="enscript-keyword">if</span> (errno == ECONNRESET 
		    || errno == ECONNREFUSED
		    || errno == EAGAIN) {
			close(sock);
			<span class="enscript-keyword">if</span> (++tries &gt; 10) <span class="enscript-keyword">return</span>(-1);
			<span class="enscript-keyword">return</span> (tcp_connect(host, prog, rdwr));
		}
		perror(<span class="enscript-string">&quot;connect&quot;</span>);
		exit(4);
	}
	tries = 0;
	<span class="enscript-keyword">return</span> (sock);
}


<span class="enscript-comment">/*
 * end of lmbench support routines
 */</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initbatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-comment">/*
	 * initialize your state variables here second
	 */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finirun</span>()
{
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_init</span>()
{
		<span class="enscript-comment">/* 
	 *	the lm_optstr must be defined here or no options for you
	 *
	 * 	...and the framework will throw an error
	 *
	 */</span>
	(<span class="enscript-type">void</span>) sprintf(lm_optstr, <span class="enscript-string">&quot;p:w:n:t:&quot;</span>);
	<span class="enscript-comment">/*
	 *	working hypothesis:
	 *	
	 * 	tsd_t is the struct that we can pass around our
	 *	state info in
	 *
	 *	lm_tsdsize will allocate the space we need for this
	 *	structure throughout the rest of the framework
	 */</span>
	lm_tsdsize = <span class="enscript-keyword">sizeof</span> (tsd_t);

	(<span class="enscript-type">void</span>) sprintf(lm_usage,
		<span class="enscript-string">&quot;       [-p parallelism (default 1)]\n&quot;</span>			
		<span class="enscript-string">&quot;       [-w warmup (default 0)]\n&quot;</span>
		<span class="enscript-string">&quot;       [-n number of descriptors (default 1)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-t int (default 1)]\n&quot;</span>
	    <span class="enscript-string">&quot;notes: measures lmbench_select_file\n&quot;</span>);
	lm_defB = 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_fini</span>()
{
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finibatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">benchmark_result</span>()
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span>		result = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">return</span> (&amp;result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finiworker</span>(<span class="enscript-type">void</span> *tsd)
{
	tsd_t			*ts = (tsd_t *)tsd;
	<span class="enscript-type">int</span> i;
	<span class="enscript-comment">// pulls in the lmbench cleanup code
</span>		<span class="enscript-keyword">for</span> (i = 0; i &lt;= ts-&gt;max; ++i) {
		<span class="enscript-keyword">if</span> (FD_ISSET(i, &amp;(ts-&gt;set)))
			close(i);
	}
	FD_ZERO(&amp;(ts-&gt;set));
	unlink(ts-&gt;fname);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_optswitch</span>(<span class="enscript-type">int</span> opt, <span class="enscript-type">char</span> *optarg)
{
		
	<span class="enscript-keyword">switch</span> (opt) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
		optt = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
		optn = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
		optp = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
		optw = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initworker</span>(<span class="enscript-type">void</span> *tsd)
{	
	<span class="enscript-comment">// pulls in code from lmbench main and initialize
</span>	<span class="enscript-type">int</span>		n = 0;
	<span class="enscript-comment">/*
	 *	initialize your state variables here first
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	<span class="enscript-type">int</span>	N, fid, fd;
	
	<span class="enscript-comment">/*
	 * default number of file descriptors
	 */</span>
		ts-&gt;num = 200;
	<span class="enscript-keyword">if</span> (optn &gt; 0) {
		ts-&gt;num = optn;
	}
	N = ts-&gt;num;
		
	<span class="enscript-comment">/*
	 *	grab more file descriptors
	 */</span>
	 
	morefds();
	
	ts-&gt;fid_f = open_socket;
	server(ts);
		<span class="enscript-comment">/* 
	 * Initialize function from lmbench
	 * for this test
	 */</span>
	fid = (*ts-&gt;fid_f)(ts);
		<span class="enscript-keyword">if</span> (fid &lt;= 0) {
		perror(<span class="enscript-string">&quot;Could not open device&quot;</span>);
		exit(1);
	}
	ts-&gt;max = 0;
	FD_ZERO(&amp;(ts-&gt;set));
			<span class="enscript-keyword">for</span> (n = 0; n &lt; N; n++) {
				fd = dup(fid);
				<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: errno result is %d - \&quot;%s\&quot;\n&quot;,errno, strerror(errno));
</span>
		<span class="enscript-keyword">if</span> (fd == -1) <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (fd &gt; ts-&gt;max)
			ts-&gt;max = fd;
		FD_SET(fd, &amp;(ts-&gt;set));
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;initworker FD_SET: ts-&gt;set result is %i\n&quot;,ts-&gt;set);
</span>
	}
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: after second macro/loop\n&quot;);
</span>
	ts-&gt;max++;
	close(fid);
		<span class="enscript-keyword">if</span> (n != N)
		exit(1);
	<span class="enscript-comment">/* end of initialize function */</span>
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initrun</span>()
{
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark</span>(<span class="enscript-type">void</span> *tsd, result_t *res)
{
	<span class="enscript-comment">/* 
	 *	initialize your state variables here last
	 * 
	 * 	and realize that you are paying for your initialization here
	 *	and it is really a bad idea
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	fd_set		nosave;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark\n&quot;);
</span>
	<span class="enscript-type">int</span>			i;
	<span class="enscript-comment">//int 		sel_res;
</span>	tv.tv_sec = 0;
	tv.tv_usec = 0;

	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optB; i++) {
		 nosave = ts-&gt;set;
		 <span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark: nosave is %i\n&quot;, nosave);
</span>
		 select(ts-&gt;num, 0, &amp;nosave, 0, &amp;tv);
		 
	}
	res-&gt;re_count = i;
	<span class="enscript-keyword">return</span> (0);
}

</pre>
<hr />
</body></html>