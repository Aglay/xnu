<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>od_query_create_with_node.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">od_query_create_with_node.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Inc.  All Rights Reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

<span class="enscript-comment">// add additional headers needed here.
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../libmicro.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFArray.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFString.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFDictionary.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;OpenDirectory/OpenDirectory.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;DirectoryService/DirectoryService.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">debug</span>(fmt, args...)    (void) fprintf(stderr, fmt , ##args)
<span class="enscript-comment">// # define debug(fmt, args...)    (void) fprintf(stderr, fmt &quot;\n&quot; , ##args)
</span>#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">debug</span>(fmt, args...)
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">// Correct use case
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//    od_query_create_with_node -E  -L -S -W -B 200 -C 10 -c 100 -r 300
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//      libMicro default benchmark run options are &quot;-E -C 200 -L -S -W&quot;
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// -B is batch size: loop iteration per each benchmark run. Needs to match # of
</span><span class="enscript-comment">//                   real lookups. This is total number of lookups to issue.
</span><span class="enscript-comment">// -C is min sample number: how many benchmark needs to run to get proper sample
</span><span class="enscript-comment">//                          1 is mimumum, but you get at least 3 benchmark run
</span><span class="enscript-comment">//                          samples. Do not set to zero. Default is 200 for most
</span><span class="enscript-comment">//                          runs in libMicro.
</span><span class="enscript-comment">// -r is the number of total records. 
</span><span class="enscript-comment">// -c is the cache hit rate for lookup. set to 10%, you need -c 10.
</span><span class="enscript-comment">//                ie. -B 100 -c 50 -r 1000 -C 200 (out of 1000 records, I want 50%
</span><span class="enscript-comment">//                     lookup, and batch size is 100. 
</span><span class="enscript-comment">//                     To get 50% cache hit rate, you need 500 record lookups.
</span><span class="enscript-comment">//                     Batch size will be adjusted to 500 to get 500 record
</span><span class="enscript-comment">//                     lookup in each benchmark. If -r size is smaller than -B,
</span><span class="enscript-comment">//                     then -B will not be adjusted. 
</span>
<span class="enscript-comment">// Defining prefix for user and group name
</span><span class="enscript-comment">// make sure that these match the ones in LDAP records
</span><span class="enscript-comment">// ie. local_test_1 , od_test_4525, od_test_group_43, od_test_host_63
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOCAL_U_PREFIX</span>     CFSTR(<span class="enscript-string">&quot;local_test_&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OD_U_PREFIX</span>        CFSTR(<span class="enscript-string">&quot;od_test_&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOCAL_G_PREFIX</span>     CFSTR(<span class="enscript-string">&quot;local_test_group_&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OD_G_PREFIX</span>        CFSTR(<span class="enscript-string">&quot;od_test_group_&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOCAL_H_PREFIX</span>     CFSTR(<span class="enscript-string">&quot;local_test_host_&quot;</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OD_H_PREFIX</span>        CFSTR(<span class="enscript-string">&quot;od_test_host_&quot;</span>)

<span class="enscript-comment">/*
 *    Your state variables should live in the tsd_t struct below
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    ODNodeRef    node;
} tsd_t;

<span class="enscript-comment">// dsRecTypeStandard type dictionary
</span><span class="enscript-type">enum</span> {rectype_users=0, rectype_groups, rectype_hosts};
CFStringRef rectype_dict[] = { CFSTR(kDSStdRecordTypeUsers),
                               CFSTR(kDSStdRecordTypeGroups), 
                               CFSTR(kDSStdRecordTypeHosts) };

<span class="enscript-comment">// the number of record lookup to issue is covered by standard option optB
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>  optRecords =    100;  <span class="enscript-comment">// the number of total records
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>  optCachehit =   100;  <span class="enscript-comment">// specify cache hit rate (% of record re-lookup)
</span><span class="enscript-type">static</span> bool optNodeLocal =  1;    <span class="enscript-comment">// which node to search. Local node is default
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>  optType =       rectype_users;    <span class="enscript-comment">// dsRecType to search for. &quot;Users&quot;&quot; is the default
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *nodename = <span class="enscript-string">&quot;/LDAPv3/127.0.0.1&quot;</span>;

<span class="enscript-type">static</span> CFStringRef *key;                <span class="enscript-comment">// username array
</span>
<span class="enscript-comment">// parse -t option and return enum type: user, group, and host
</span><span class="enscript-comment">// called by benchmark_optswitch()
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">ds_rec_type</span>(<span class="enscript-type">char</span> *name)
{
    <span class="enscript-keyword">if</span> (strcasecmp(<span class="enscript-string">&quot;u&quot;</span>, name) == 0) {
        <span class="enscript-keyword">return</span> (rectype_users);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcasecmp(<span class="enscript-string">&quot;g&quot;</span>, name) == 0) {
        <span class="enscript-keyword">return</span> (rectype_groups);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcasecmp(<span class="enscript-string">&quot;h&quot;</span>, name) == 0) {
        <span class="enscript-keyword">return</span> (rectype_hosts);
    }

    <span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_init</span>()
{
    debug(<span class="enscript-string">&quot;benchmark_init&quot;</span>);
    (<span class="enscript-type">void</span>) sprintf(lm_optstr,  <span class="enscript-string">&quot;c:n:r:t:&quot;</span>);

    lm_tsdsize = <span class="enscript-keyword">sizeof</span> (tsd_t);
    lm_defB = 1000;

    (<span class="enscript-type">void</span>) sprintf(lm_usage,
                <span class="enscript-string">&quot;\n       ------- od_query_create_with_node specific options (default: *)\n&quot;</span>
                <span class="enscript-string">&quot;       [-c hitrate%% (100%%*)]\n&quot;</span>
                <span class="enscript-string">&quot;       [-r total number of records (100*)]\n&quot;</span>
                <span class="enscript-string">&quot;       [-n nodename] node name to use for test\n&quot;</span>
                <span class="enscript-string">&quot;       [-t record type: 'u'sers, 'g'roups, 'h'osts]\n&quot;</span>
                <span class="enscript-string">&quot;       use -B option to specify total number of record lookups to issue&quot;</span>
                <span class="enscript-string">&quot;\n&quot;</span> );
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * This is where you parse your lower-case arguments.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_optswitch</span>(<span class="enscript-type">int</span> opt, <span class="enscript-type">char</span> *optarg)
{
    debug(<span class="enscript-string">&quot;benchmark_optswitch&quot;</span>);

    <span class="enscript-keyword">switch</span> (opt) {
    <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:    <span class="enscript-comment">// cache hit rate. 100% means lookup the same records over and over
</span>        optCachehit = atoi(optarg);
        debug(<span class="enscript-string">&quot;optCachehit = %d\n&quot;</span>, optCachehit);
        <span class="enscript-keyword">if</span> (optCachehit &gt; 100 || optCachehit &lt; 0) {
            printf(<span class="enscript-string">&quot;cache hit rate should be in between 0%% and 100%%&quot;</span>);
            <span class="enscript-keyword">return</span> (-1);
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:    <span class="enscript-comment">// total number of records. default is 100
</span>        optRecords = atoi(optarg);
        debug(<span class="enscript-string">&quot;optRecords = %d\n&quot;</span>, optRecords);
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:    <span class="enscript-comment">// node
</span>        nodename = optarg;
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:    <span class="enscript-comment">// dsRecType: user, group, hots
</span>        optType = ds_rec_type(optarg);
        debug(<span class="enscript-string">&quot;optType = %d\n&quot;</span>, optType);

        <span class="enscript-keyword">if</span> (optType == -1) {
            printf(<span class="enscript-string">&quot;wrong -t record type option\n&quot;</span>);
            <span class="enscript-keyword">return</span> (-1);
        }
        <span class="enscript-keyword">break</span>;

    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> (-1);
    }

    <span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initrun</span>()
{
    <span class="enscript-type">int</span> i;
    CFStringRef prefix;              <span class="enscript-comment">// local user is default
</span>    
    debug(<span class="enscript-string">&quot;benchmark_initrun\n&quot;</span>);

    <span class="enscript-comment">// Adjust # of record lookups to reflect cache hit rate
</span>    <span class="enscript-keyword">if</span> (optCachehit &lt; 100) {
        optRecords  = (<span class="enscript-type">int</span>) ((<span class="enscript-type">float</span>) optRecords * ((<span class="enscript-type">float</span>) optCachehit / 100));
        debug(<span class="enscript-string">&quot;# of records adjusted to %d for cache hit rate %d%%\n&quot;</span>, optRecords, optCachehit);
    }

    <span class="enscript-comment">// if batch size (one benchmark run) is less than the number records, adjust
</span>    <span class="enscript-comment">// it to match the number record lookups in one batch run
</span>    <span class="enscript-keyword">if</span> (lm_optB &lt; optRecords) {
        lm_optB = optRecords;
        debug(<span class="enscript-string">&quot;Adjusting batch size to %d to match the lookups required in benchmark run\n&quot;</span>, lm_optB);
    }

    <span class="enscript-keyword">switch</span> (optType) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_users</span>:
            prefix = (optNodeLocal) ? LOCAL_U_PREFIX : OD_U_PREFIX;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_groups</span>:
            prefix = (optNodeLocal) ? LOCAL_G_PREFIX : OD_G_PREFIX;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_hosts</span>:
            prefix = (optNodeLocal) ? LOCAL_H_PREFIX : OD_H_PREFIX;
            <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-comment">// create an array of usernames to use in benchmark before their use
</span>    <span class="enscript-comment">// realtime generation in benchmark effects performance measurements
</span>
    key = malloc(<span class="enscript-keyword">sizeof</span>(CFStringRef) * optRecords);

    <span class="enscript-comment">// user, group, hosts key to lookup
</span>    <span class="enscript-keyword">switch</span> (optType) {

    <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_users</span>:     <span class="enscript-comment">// users query
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_groups</span>:    <span class="enscript-comment">// groups query
</span>    <span class="enscript-keyword">case</span> <span class="enscript-reference">rectype_hosts</span>:     <span class="enscript-comment">// hosts query
</span>        <span class="enscript-keyword">for</span> (i = 0; i &lt; optRecords; i++) {
            key[i] = CFStringCreateWithFormat( kCFAllocatorDefault, 
                                               NULL, 
                                               CFSTR(<span class="enscript-string">&quot;%@%d&quot;</span>), 
                                               prefix, 
                                               i+1);
            <span class="enscript-comment">// CFShow(key[i]);  // print user name to check
</span>        }
        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">// Initialize all structures that will be used in benchmark()
</span><span class="enscript-comment">// 1. make local or network node for OD query
</span><span class="enscript-comment">// 2. create user key 
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initworker</span>(<span class="enscript-type">void</span> *tsd)
{
    CFErrorRef    error;
    tsd_t *ts = (tsd_t *)tsd;

    debug(<span class="enscript-string">&quot;benchmark_initworker: %s&quot;</span>, (optNodeLocal) ? <span class="enscript-string">&quot;local&quot;</span> : <span class="enscript-string">&quot;network&quot;</span>);


    <span class="enscript-comment">// create OD node for local or OD query
</span>    <span class="enscript-keyword">if</span> (optNodeLocal) {
        ts-&gt;node = ODNodeCreateWithNodeType(NULL, kODSessionDefault, kODNodeTypeLocalNodes, &amp;error);
    }
    <span class="enscript-keyword">else</span> {
        CFStringRef nodenameStr = CFStringCreateWithCString(kCFAllocatorDefault, nodename, kCFStringEncodingUTF8);
        ts-&gt;node = ODNodeCreateWithName(NULL, kODSessionDefault, nodenameStr, &amp;error);
        CFRelease(nodenameStr);
    }

    <span class="enscript-keyword">if</span> (!ts-&gt;node) {
        debug(<span class="enscript-string">&quot;error calling ODNodeCreateWithNodeType\n&quot;</span>);
        exit(1);
    }

    CFRetain (ts-&gt;node);

    debug(<span class="enscript-string">&quot;benchmark_initworker: ODNodeRef = 0x%lx\n&quot;</span>, ts-&gt;node);
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark</span>(<span class="enscript-type">void</span> *tsd, result_t *res)
{

    tsd_t        *ts = (tsd_t *)tsd;
    <span class="enscript-type">int</span>          i;
    ODNodeRef    node;
    CFErrorRef   error;
    CFArrayRef   results;
    ODQueryRef   query;

   res-&gt;re_errors = 0;
    node = ts-&gt;node;

    debug(<span class="enscript-string">&quot;in to benchmark - optB = %i, node = 0x%lx \n&quot;</span>, lm_optB, node);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optB; i++) {

        debug(<span class="enscript-string">&quot;loop %d: querying\n&quot;</span>, i);
        query = ODQueryCreateWithNode(NULL,
                        node,                        <span class="enscript-comment">// inNode
</span>                        rectype_dict[optType],       <span class="enscript-comment">// inRecordTypeOrList
</span>                        CFSTR(kDSNAttrRecordName),   <span class="enscript-comment">// inAttribute
</span>                        kODMatchInsensitiveEqualTo,  <span class="enscript-comment">// inMatchType
</span>                        key[i % optRecords],                      <span class="enscript-comment">// inQueryValueOrList
</span>                        NULL,                        <span class="enscript-comment">// inReturnAttributeOrList
</span>                        1,                           <span class="enscript-comment">// inMaxResults
</span>                        &amp;error);

        <span class="enscript-keyword">if</span> (query) {
            <span class="enscript-comment">// we do not want to factually fetch the result in benchmark run
</span>            <span class="enscript-comment">// debug(&quot;loop %d: calling ODQueryCopyResults\n&quot;, i);
</span>            results = ODQueryCopyResults(query, FALSE, &amp;error);
            CFRelease(query);
            <span class="enscript-keyword">if</span> (results) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
                <span class="enscript-type">int</span> c;
                c = CFArrayGetCount(results);
                <span class="enscript-keyword">if</span> (c &gt; 0) {
                    debug(<span class="enscript-string">&quot;Successful run: %d results, &quot;</span>, c);
                }
                <span class="enscript-keyword">else</span> {
                    debug(<span class="enscript-string">&quot;no result for &quot;</span>);
                }
                CFShow (key[i % optRecords]);
                debug(<span class="enscript-string">&quot;\n&quot;</span>);
#<span class="enscript-reference">endif</span>
                CFRelease(results);
            }
            <span class="enscript-keyword">else</span> {
                debug(<span class="enscript-string">&quot;loop %d: ODQueryCopyResults returned empty result for &quot;</span>, i);
                res-&gt;re_errors++;
                CFShow (key[i % optRecords]);
                debug(<span class="enscript-string">&quot;\n&quot;</span>);
            } <span class="enscript-comment">// if (results)
</span>
        } <span class="enscript-comment">// if (query)
</span>        <span class="enscript-keyword">else</span> {
            res-&gt;re_errors++;
        }
    }
    res-&gt;re_count = i;

    <span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">// We need to release all the structures we allocated in benchmark_initworker()
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finiworker</span>(<span class="enscript-type">void</span> *tsd)
{
    tsd_t    *ts = (tsd_t *)tsd;

    debug(<span class="enscript-string">&quot;benchmark_result: deallocating structures\n&quot;</span>);

    <span class="enscript-comment">// free the node
</span>    <span class="enscript-keyword">if</span> (ts-&gt;node)
        CFRelease (ts-&gt;node);
    ts-&gt;node = NULL;

    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finirun</span>()
{
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; optRecords; i++){
        CFRelease(key[i]);
    }

    free(key);

    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">benchmark_result</span>()
{
    <span class="enscript-type">static</span> <span class="enscript-type">char</span>    result = <span class="enscript-string">'\0'</span>;
    debug(<span class="enscript-string">&quot;\n\n# of records adjusted to %d for cache hit rate %d%%\n&quot;</span>, optRecords, optCachehit);
    debug(<span class="enscript-string">&quot;benchmark_result\n&quot;</span>);
    <span class="enscript-keyword">return</span> (&amp;result);
}

</pre>
<hr />
</body></html>