<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lmbench_bw_mem.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lmbench_bw_mem.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 *	Order of Execution
 *
 *	benchmark_init
 *
 *	benchmark_optswitch
 *
 *		benchmark_initrun
 *
 *			benchmark_initworker
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch, etc.
 *			benchmark_finiworker
 *
 *		benchmark_result
 *
 *		benchmark_finirun
 *
 *	benchmark_fini
 */</span>

<span class="enscript-comment">/*
 * To port to libmicro, I had to add options for
 * some items which were just arguments before.
 * -s is the size (more than 512)
 * -x is the command to execute (rd wr rdwr cp fwr frd fcp bzero bcopy)
 * see usage string for command options.
 */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__sun</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">ident</span>	<span class="enscript-string">&quot;@(#)lmbench_bw_mem.c	1.0 20060814 Apple Inc.&quot;</span>
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../libmicro.h&quot;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TRIES</span>		11	// value from bench.h in lmbench
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TYPE</span>    	int

<span class="enscript-comment">/* Added as part of the fix for &lt;rdar://problem/7508837&gt; */</span>
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> u_int64_t       use_result_dummy;
<span class="enscript-type">void</span> <span class="enscript-function-name">use_int</span>(<span class="enscript-type">int</span> result) { use_result_dummy += result; }

<span class="enscript-comment">/*
 * rd - 4 byte read, 32 byte stride
 * wr - 4 byte write, 32 byte stride
 * rdwr - 4 byte read followed by 4 byte write to same place, 32 byte stride
 * cp - 4 byte read then 4 byte write to different place, 32 byte stride
 * fwr - write every 4 byte word
 * frd - read every 4 byte word
 * fcp - copy every 4 byte word
 *
 * All tests do 512 byte chunks in a loop.
 *
 * XXX - do a 64bit version of this.
 */</span>
<span class="enscript-type">void</span>	rd(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	wr(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	rdwr(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	mcp(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	fwr(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	frd(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	fcp(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	loop_bzero(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	loop_bcopy(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	init_overhead(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	init_loop(iter_t iterations, <span class="enscript-type">void</span> *cookie);
<span class="enscript-type">void</span>	cleanup(iter_t iterations, <span class="enscript-type">void</span> *cookie);

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _state {
	<span class="enscript-type">double</span>	overhead;
	size_t	nbytes;
	<span class="enscript-type">int</span>	need_buf2;
	<span class="enscript-type">int</span>	aligned;
	TYPE	*buf;
	TYPE	*buf2;
	TYPE	*buf2_orig;
	TYPE	*lastone;
	size_t	N;
} state_t;


<span class="enscript-comment">/*
 *	Your state variables should live in the tsd_t struct below
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">double</span>	overhead;
	size_t	nbytes;
	<span class="enscript-type">int</span>	need_buf2;
	<span class="enscript-type">int</span>	aligned;
	TYPE	*buf;
	TYPE	*buf2;
	TYPE	*buf2_orig;
	TYPE	*lastone;
	size_t	N;
	<span class="enscript-type">int</span>	parallel;
	<span class="enscript-type">int</span>	warmup;
	<span class="enscript-type">int</span>	repetitions;
} tsd_t;


<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optp = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	optw = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	optn = TRIES;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	opt_size = 0;
<span class="enscript-type">static</span> <span class="enscript-type">char</span>	*opt_what;	<span class="enscript-comment">// maximum &quot;what&quot; command string size
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">init_overhead</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">init_loop</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{
	tsd_t			*ts = (tsd_t *)cookie;

	<span class="enscript-keyword">if</span> (iterations) <span class="enscript-keyword">return</span>;

    ts-&gt;buf = (TYPE *)valloc(ts-&gt;nbytes);
	ts-&gt;buf2_orig = NULL;
	ts-&gt;lastone = (TYPE*)ts-&gt;buf - 1;
	ts-&gt;lastone = (TYPE*)((<span class="enscript-type">char</span> *)ts-&gt;buf + ts-&gt;nbytes - 512);
	ts-&gt;N = ts-&gt;nbytes;

	<span class="enscript-keyword">if</span> (!ts-&gt;buf) {
		perror(<span class="enscript-string">&quot;malloc&quot;</span>);
		exit(1);
	}
	bzero((<span class="enscript-type">void</span>*)ts-&gt;buf, ts-&gt;nbytes);

	<span class="enscript-keyword">if</span> (ts-&gt;need_buf2 == 1) {
		ts-&gt;buf2_orig = ts-&gt;buf2 = (TYPE *)valloc(ts-&gt;nbytes + 2048);
		<span class="enscript-keyword">if</span> (!ts-&gt;buf2) {
			perror(<span class="enscript-string">&quot;malloc&quot;</span>);
			exit(1);
		}

		<span class="enscript-comment">/* default is to have stuff unaligned wrt each other */</span>
		<span class="enscript-comment">/* XXX - this is not well tested or thought out */</span>
		<span class="enscript-keyword">if</span> (ts-&gt;aligned) {
			<span class="enscript-type">char</span>	*tmp = (<span class="enscript-type">char</span> *)ts-&gt;buf2;

			tmp += 2048 - 128;
			ts-&gt;buf2 = (TYPE *)tmp;
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cleanup</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{
	tsd_t			*ts = (tsd_t *)cookie;

	<span class="enscript-keyword">if</span> (iterations) <span class="enscript-keyword">return</span>;

	free(ts-&gt;buf);
	<span class="enscript-keyword">if</span> (ts-&gt;buf2_orig) free(ts-&gt;buf2_orig);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">rd</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> sum = 0;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
		sum += 
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	p[i]+
		DOIT(0) DOIT(4) DOIT(8) DOIT(12) DOIT(16) DOIT(20) DOIT(24)
		DOIT(28) DOIT(32) DOIT(36) DOIT(40) DOIT(44) DOIT(48) DOIT(52)
		DOIT(56) DOIT(60) DOIT(64) DOIT(68) DOIT(72) DOIT(76)
		DOIT(80) DOIT(84) DOIT(88) DOIT(92) DOIT(96) DOIT(100)
		DOIT(104) DOIT(108) DOIT(112) DOIT(116) DOIT(120) 
		p[124];
		p +=  128;
	    }
	}
	use_int(sum);
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">wr</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	p[i] = 1;
		DOIT(0) DOIT(4) DOIT(8) DOIT(12) DOIT(16) DOIT(20) DOIT(24)
		DOIT(28) DOIT(32) DOIT(36) DOIT(40) DOIT(44) DOIT(48) DOIT(52)
		DOIT(56) DOIT(60) DOIT(64) DOIT(68) DOIT(72) DOIT(76)
		DOIT(80) DOIT(84) DOIT(88) DOIT(92) DOIT(96) DOIT(100)
		DOIT(104) DOIT(108) DOIT(112) DOIT(116) DOIT(120) DOIT(124);
		p +=  128;
	    }
	}
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">rdwr</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> sum = 0;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	sum += p[i]; p[i] = 1;
		DOIT(0) DOIT(4) DOIT(8) DOIT(12) DOIT(16) DOIT(20) DOIT(24)
		DOIT(28) DOIT(32) DOIT(36) DOIT(40) DOIT(44) DOIT(48) DOIT(52)
		DOIT(56) DOIT(60) DOIT(64) DOIT(68) DOIT(72) DOIT(76)
		DOIT(80) DOIT(84) DOIT(88) DOIT(92) DOIT(96) DOIT(100)
		DOIT(104) DOIT(108) DOIT(112) DOIT(116) DOIT(120) DOIT(124);
		p +=  128;
	    }
	}
	use_int(sum);
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">mcp</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;
	TYPE* p_save = NULL;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-type">register</span> TYPE *dst = ts-&gt;buf2;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	dst[i] = p[i];
		DOIT(0) DOIT(4) DOIT(8) DOIT(12) DOIT(16) DOIT(20) DOIT(24)
		DOIT(28) DOIT(32) DOIT(36) DOIT(40) DOIT(44) DOIT(48) DOIT(52)
		DOIT(56) DOIT(60) DOIT(64) DOIT(68) DOIT(72) DOIT(76)
		DOIT(80) DOIT(84) DOIT(88) DOIT(92) DOIT(96) DOIT(100)
		DOIT(104) DOIT(108) DOIT(112) DOIT(116) DOIT(120) DOIT(124);
		p += 128;
		dst += 128;
	    }
	    p_save = p;
	}
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fwr</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;
	TYPE* p_save = NULL;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	p[i]=
		DOIT(0) DOIT(1) DOIT(2) DOIT(3) DOIT(4) DOIT(5) DOIT(6)
		DOIT(7) DOIT(8) DOIT(9) DOIT(10) DOIT(11) DOIT(12)
		DOIT(13) DOIT(14) DOIT(15) DOIT(16) DOIT(17) DOIT(18)
		DOIT(19) DOIT(20) DOIT(21) DOIT(22) DOIT(23) DOIT(24)
		DOIT(25) DOIT(26) DOIT(27) DOIT(28) DOIT(29) DOIT(30)
		DOIT(31) DOIT(32) DOIT(33) DOIT(34) DOIT(35) DOIT(36)
		DOIT(37) DOIT(38) DOIT(39) DOIT(40) DOIT(41) DOIT(42)
		DOIT(43) DOIT(44) DOIT(45) DOIT(46) DOIT(47) DOIT(48)
		DOIT(49) DOIT(50) DOIT(51) DOIT(52) DOIT(53) DOIT(54)
		DOIT(55) DOIT(56) DOIT(57) DOIT(58) DOIT(59) DOIT(60)
		DOIT(61) DOIT(62) DOIT(63) DOIT(64) DOIT(65) DOIT(66)
		DOIT(67) DOIT(68) DOIT(69) DOIT(70) DOIT(71) DOIT(72)
		DOIT(73) DOIT(74) DOIT(75) DOIT(76) DOIT(77) DOIT(78)
		DOIT(79) DOIT(80) DOIT(81) DOIT(82) DOIT(83) DOIT(84)
		DOIT(85) DOIT(86) DOIT(87) DOIT(88) DOIT(89) DOIT(90)
		DOIT(91) DOIT(92) DOIT(93) DOIT(94) DOIT(95) DOIT(96)
		DOIT(97) DOIT(98) DOIT(99) DOIT(100) DOIT(101) DOIT(102)
		DOIT(103) DOIT(104) DOIT(105) DOIT(106) DOIT(107)
		DOIT(108) DOIT(109) DOIT(110) DOIT(111) DOIT(112)
		DOIT(113) DOIT(114) DOIT(115) DOIT(116) DOIT(117)
		DOIT(118) DOIT(119) DOIT(120) DOIT(121) DOIT(122)
		DOIT(123) DOIT(124) DOIT(125) DOIT(126) DOIT(127) 1;
		p += 128;
	    }
	    p_save = p;
	}
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">frd</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> sum = 0;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
		sum +=
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	p[i]+
		DOIT(0) DOIT(1) DOIT(2) DOIT(3) DOIT(4) DOIT(5) DOIT(6)
		DOIT(7) DOIT(8) DOIT(9) DOIT(10) DOIT(11) DOIT(12)
		DOIT(13) DOIT(14) DOIT(15) DOIT(16) DOIT(17) DOIT(18)
		DOIT(19) DOIT(20) DOIT(21) DOIT(22) DOIT(23) DOIT(24)
		DOIT(25) DOIT(26) DOIT(27) DOIT(28) DOIT(29) DOIT(30)
		DOIT(31) DOIT(32) DOIT(33) DOIT(34) DOIT(35) DOIT(36)
		DOIT(37) DOIT(38) DOIT(39) DOIT(40) DOIT(41) DOIT(42)
		DOIT(43) DOIT(44) DOIT(45) DOIT(46) DOIT(47) DOIT(48)
		DOIT(49) DOIT(50) DOIT(51) DOIT(52) DOIT(53) DOIT(54)
		DOIT(55) DOIT(56) DOIT(57) DOIT(58) DOIT(59) DOIT(60)
		DOIT(61) DOIT(62) DOIT(63) DOIT(64) DOIT(65) DOIT(66)
		DOIT(67) DOIT(68) DOIT(69) DOIT(70) DOIT(71) DOIT(72)
		DOIT(73) DOIT(74) DOIT(75) DOIT(76) DOIT(77) DOIT(78)
		DOIT(79) DOIT(80) DOIT(81) DOIT(82) DOIT(83) DOIT(84)
		DOIT(85) DOIT(86) DOIT(87) DOIT(88) DOIT(89) DOIT(90)
		DOIT(91) DOIT(92) DOIT(93) DOIT(94) DOIT(95) DOIT(96)
		DOIT(97) DOIT(98) DOIT(99) DOIT(100) DOIT(101) DOIT(102)
		DOIT(103) DOIT(104) DOIT(105) DOIT(106) DOIT(107)
		DOIT(108) DOIT(109) DOIT(110) DOIT(111) DOIT(112)
		DOIT(113) DOIT(114) DOIT(115) DOIT(116) DOIT(117)
		DOIT(118) DOIT(119) DOIT(120) DOIT(121) DOIT(122)
		DOIT(123) DOIT(124) DOIT(125) DOIT(126) p[127];
		p += 128;
	    }
	}
	use_int(sum);
}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">DOIT</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">fcp</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *lastone = ts-&gt;lastone;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
	    <span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	    <span class="enscript-type">register</span> TYPE *dst = ts-&gt;buf2;
	    <span class="enscript-keyword">while</span> (p &lt;= lastone) {
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DOIT</span>(i)	dst[i]=p[i];
		DOIT(0) DOIT(1) DOIT(2) DOIT(3) DOIT(4) DOIT(5) DOIT(6)
		DOIT(7) DOIT(8) DOIT(9) DOIT(10) DOIT(11) DOIT(12)
		DOIT(13) DOIT(14) DOIT(15) DOIT(16) DOIT(17) DOIT(18)
		DOIT(19) DOIT(20) DOIT(21) DOIT(22) DOIT(23) DOIT(24)
		DOIT(25) DOIT(26) DOIT(27) DOIT(28) DOIT(29) DOIT(30)
		DOIT(31) DOIT(32) DOIT(33) DOIT(34) DOIT(35) DOIT(36)
		DOIT(37) DOIT(38) DOIT(39) DOIT(40) DOIT(41) DOIT(42)
		DOIT(43) DOIT(44) DOIT(45) DOIT(46) DOIT(47) DOIT(48)
		DOIT(49) DOIT(50) DOIT(51) DOIT(52) DOIT(53) DOIT(54)
		DOIT(55) DOIT(56) DOIT(57) DOIT(58) DOIT(59) DOIT(60)
		DOIT(61) DOIT(62) DOIT(63) DOIT(64) DOIT(65) DOIT(66)
		DOIT(67) DOIT(68) DOIT(69) DOIT(70) DOIT(71) DOIT(72)
		DOIT(73) DOIT(74) DOIT(75) DOIT(76) DOIT(77) DOIT(78)
		DOIT(79) DOIT(80) DOIT(81) DOIT(82) DOIT(83) DOIT(84)
		DOIT(85) DOIT(86) DOIT(87) DOIT(88) DOIT(89) DOIT(90)
		DOIT(91) DOIT(92) DOIT(93) DOIT(94) DOIT(95) DOIT(96)
		DOIT(97) DOIT(98) DOIT(99) DOIT(100) DOIT(101) DOIT(102)
		DOIT(103) DOIT(104) DOIT(105) DOIT(106) DOIT(107)
		DOIT(108) DOIT(109) DOIT(110) DOIT(111) DOIT(112)
		DOIT(113) DOIT(114) DOIT(115) DOIT(116) DOIT(117)
		DOIT(118) DOIT(119) DOIT(120) DOIT(121) DOIT(122)
		DOIT(123) DOIT(124) DOIT(125) DOIT(126) DOIT(127)
		p += 128;
		dst += 128;
	    }
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">loop_bzero</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	<span class="enscript-type">register</span> size_t  N = ts-&gt;N;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
		bzero(p, N);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">loop_bcopy</span>(iter_t iterations, <span class="enscript-type">void</span> *cookie)
{	
	tsd_t			*ts = (tsd_t *)cookie;
	<span class="enscript-type">register</span> TYPE *p = ts-&gt;buf;
	<span class="enscript-type">register</span> TYPE *dst = ts-&gt;buf2;
	<span class="enscript-type">register</span> size_t  N = ts-&gt;N;

	<span class="enscript-keyword">while</span> (iterations-- &gt; 0) {
		bcopy(p,dst,N);
	}
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">libmicro</span> <span class="enscript-variable-name">routines</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initbatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-comment">/*
	 * initialize your state variables here second
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
    ts-&gt;buf = (TYPE *)valloc(ts-&gt;nbytes);
	ts-&gt;buf2_orig = NULL;
	ts-&gt;lastone = (TYPE*)ts-&gt;buf - 1;
	ts-&gt;lastone = (TYPE*)((<span class="enscript-type">char</span> *)ts-&gt;buf + ts-&gt;nbytes - 512);
	ts-&gt;N = ts-&gt;nbytes;

	<span class="enscript-keyword">if</span> (!ts-&gt;buf) {
		perror(<span class="enscript-string">&quot;malloc&quot;</span>);
		exit(1);
	}
	bzero((<span class="enscript-type">void</span>*)ts-&gt;buf, ts-&gt;nbytes);

	<span class="enscript-keyword">if</span> (ts-&gt;need_buf2 == 1) {
		ts-&gt;buf2_orig = ts-&gt;buf2 = (TYPE *)valloc(ts-&gt;nbytes + 2048);
		<span class="enscript-keyword">if</span> (!ts-&gt;buf2) {
			perror(<span class="enscript-string">&quot;malloc&quot;</span>);
			exit(1);
		}

		<span class="enscript-comment">/* default is to have stuff unaligned wrt each other */</span>
		<span class="enscript-comment">/* XXX - this is not well tested or thought out */</span>
		<span class="enscript-keyword">if</span> (ts-&gt;aligned) {
			<span class="enscript-type">char</span>	*tmp = (<span class="enscript-type">char</span> *)ts-&gt;buf2;

			tmp += 2048 - 128;
			ts-&gt;buf2 = (TYPE *)tmp;
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finirun</span>()
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_init</span>()
{
	<span class="enscript-comment">/* 
	 *	the lm_optstr must be defined here or no options for you
	 *
	 * 	...and the framework will throw an error
	 *
	 */</span>
	(<span class="enscript-type">void</span>) sprintf(lm_optstr, <span class="enscript-string">&quot;p:w:n:s:x:&quot;</span>);
	<span class="enscript-comment">/*
	 *	working hypothesis:
	 *	
	 * 	tsd_t is the struct that we can pass around our
	 *	state info in
	 *
	 *	lm_tsdsize will allocate the space we need for this
	 *	structure throughout the rest of the framework
	 */</span>
	lm_tsdsize = <span class="enscript-keyword">sizeof</span> (tsd_t);
	opt_what = (<span class="enscript-type">char</span> *)malloc(30);

	(<span class="enscript-type">void</span>) sprintf(lm_usage,
	    <span class="enscript-string">&quot;	[-p &lt;parallelism&gt;]\n&quot;</span>
	    <span class="enscript-string">&quot;	[-w &lt;warmup&gt;]\n&quot;</span>
	    <span class="enscript-string">&quot;	[-n &lt;repetitions&gt;]\n&quot;</span>
	    <span class="enscript-string">&quot;	-s &lt;size&gt;\n&quot;</span>
	    <span class="enscript-string">&quot;		&lt;size&gt; must be larger than 512&quot;</span>
	    <span class="enscript-string">&quot;	-x what\n&quot;</span>
	    <span class="enscript-string">&quot; 		what: rd wr rdwr cp fwr frd fcp bzero bcopy\n&quot;</span>
	    <span class="enscript-string">&quot;	  [conflict] -- unknown option?\n&quot;</span>
	);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_fini</span>()
{
	free(opt_what);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finibatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">benchmark_result</span>()
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span>		result = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> (&amp;result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finiworker</span>(<span class="enscript-type">void</span> *tsd)
{
	tsd_t			*ts = (tsd_t *)tsd;
	free(ts-&gt;buf);
	<span class="enscript-keyword">if</span> (ts-&gt;buf2_orig) free(ts-&gt;buf2_orig);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* return -1 to display usage (i.e. if can't parse arguments */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_optswitch</span>(<span class="enscript-type">int</span> opt, <span class="enscript-type">char</span> *optarg)
{
	
	<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
			optp = sizetoint(optarg);
			<span class="enscript-keyword">if</span> (optp &lt;= 0) 
				<span class="enscript-keyword">return</span> (-1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
			optw = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
			optn = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
			opt_size = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>:
			strcpy(opt_what, optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span>(-1);
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-comment">//	(void) fprintf(stderr, &quot;optp = %i optw = %i optn = %i opt_size = %i\n&quot;,
</span><span class="enscript-comment">//						optp, optw, optn, opt_size);
</span><span class="enscript-comment">//	(void) fprintf(stderr, &quot;opt_what = %s\n&quot;, opt_what);						
</span>	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initworker</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-comment">/*
	 *	initialize your state variables here first
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	ts-&gt;parallel = optp;
	ts-&gt;warmup = optw;
	ts-&gt;repetitions = optn;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initrun</span>()
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark</span>(<span class="enscript-type">void</span> *tsd, result_t *res)
{
	<span class="enscript-comment">/* 
	 *	initialize your state variables here last
	 * 
	 * 	and realize that you are paying for your initialization here
	 *	and it is really a bad idea
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	size_t	nbytes;
	<span class="enscript-type">int</span>	i;

	ts-&gt;overhead = 0;


	<span class="enscript-comment">/* should have two, possibly three [indicates align] arguments left */</span>
	ts-&gt;aligned = ts-&gt;need_buf2 = 0;

	nbytes = ts-&gt;nbytes = opt_size;
	<span class="enscript-keyword">if</span> (ts-&gt;nbytes &lt; 512) { <span class="enscript-comment">/* this is the number of bytes in the loop */</span>
		<span class="enscript-keyword">return</span>(-1);
	}

	<span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;cp&quot;</span>) ||
	    STREQ(opt_what, <span class="enscript-string">&quot;fcp&quot;</span>) || STREQ(opt_what, <span class="enscript-string">&quot;bcopy&quot;</span>)) {
		ts-&gt;need_buf2 = 1;
	}
	
	<span class="enscript-keyword">for</span> (i = 0 ; i &lt; lm_optB ; i++)
	{
		<span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;rd&quot;</span>)) {
			rd( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;wr&quot;</span>)) {
			wr( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;rdwr&quot;</span>)) {
			rdwr( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;cp&quot;</span>)) {
			mcp( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;frd&quot;</span>)) {
			frd( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;fwr&quot;</span>)) {
			fwr( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;fcp&quot;</span>)) {
			fcp( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;bzero&quot;</span>)) {
			loop_bzero( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (STREQ(opt_what, <span class="enscript-string">&quot;bcopy&quot;</span>)) {
			loop_bcopy( ts-&gt;repetitions, tsd ); 
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span>(-1);
		}
	}
	res-&gt;re_count = i;

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>