<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lmbench_bw_mmap_rd.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lmbench_bw_mmap_rd.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 *	Order of Execution
 *
 *	benchmark_init
 *
 *	benchmark_optswitch
 *
 *		benchmark_initrun
 *
 *			benchmark_initworker
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch, etc.
 *			benchmark_finiworker
 *
 *		benchmark_result
 *
 *		benchmark_finirun
 *
 *	benchmark_fini
 */</span>



#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__sun</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">ident</span>	<span class="enscript-string">&quot;@(#)lmbench_bw_mmap_rd.c	1.0	08/17/06 Apple Inc.&quot;</span>
#<span class="enscript-reference">endif</span>



#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
<span class="enscript-comment">// add additional headers needed here.
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../libmicro.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">debug</span>(fmt, args...)	(void) fprintf(stderr, fmt <span class="enscript-string">&quot;\n&quot;</span> , ##args)
#<span class="enscript-reference">else</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">debug</span>(fmt, args...)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Your state variables should live in the tsd_t struct below
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	size_t	nbytes;
	<span class="enscript-type">char</span> 	filename[_POSIX_PATH_MAX];
	<span class="enscript-type">int</span> 	fd;
	<span class="enscript-type">int</span> 	clone;
	<span class="enscript-type">void</span>	*buf;
	bool open_read_close;
} tsd_t;

<span class="enscript-comment">/*
 * You can have any lower-case option you want to define.
 * options are specified in the lm_optstr as either a 
 * single lower-case letter, or a single lower case letter 
 * with a colon after it.  In this example, you can optionally
 * specify -c {str} -e or -t {number}  
 *    -c takes a string (quote the string if blanks)
 *    -e is a boolean 
 *    -t takes a numeric
 * argument.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> 	optf[_POSIX_PATH_MAX]; 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		opts = 1024;
<span class="enscript-type">static</span> bool 	opti = false;	<span class="enscript-comment">// io_only or read and i/o (default read and i/o)
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MAP_FILE</span>
#	<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MMAP_FLAGS</span>	MAP_FILE|MAP_SHARED
#<span class="enscript-reference">else</span>
#	<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MMAP_FLAGS</span>	MAP_SHARED
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CHK</span>(x)		if ((int)(x) == -1) { perror(#x); exit(1); }
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">MIN</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MIN</span>(a, b)	((a) &lt; (b) ? (a) : (b))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TYPE</span>	int
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MINSZ</span>	(sizeof(TYPE) * 128)

<span class="enscript-type">void</span>	*buf;		<span class="enscript-comment">/* do the I/O here */</span>
size_t	xfersize;	<span class="enscript-comment">/* do it in units of this */</span>
size_t	count;		<span class="enscript-comment">/* bytes to move (can't be modified) */</span>

<span class="enscript-comment">/* analogous to bzero, bcopy, etc., except that it just reads
 * data into the processor
 */</span>
<span class="enscript-type">long</span>
<span class="enscript-function-name">bread</span>(<span class="enscript-type">void</span>* buf, <span class="enscript-type">long</span> nbytes)
{
	<span class="enscript-type">long</span> sum = 0;
	<span class="enscript-type">register</span> <span class="enscript-type">long</span> *p, *next;
	<span class="enscript-type">register</span> <span class="enscript-type">char</span> *end;

	p = (<span class="enscript-type">long</span>*)buf;
	end = (<span class="enscript-type">char</span>*)buf + nbytes;
	<span class="enscript-keyword">for</span> (next = p + 128; (<span class="enscript-type">void</span>*)next &lt;= (<span class="enscript-type">void</span>*)end; p = next, next += 128) {
		sum +=
			p[0]+p[1]+p[2]+p[3]+p[4]+p[5]+p[6]+p[7]+
			p[8]+p[9]+p[10]+p[11]+p[12]+p[13]+p[14]+
			p[15]+p[16]+p[17]+p[18]+p[19]+p[20]+p[21]+
			p[22]+p[23]+p[24]+p[25]+p[26]+p[27]+p[28]+
			p[29]+p[30]+p[31]+p[32]+p[33]+p[34]+p[35]+
			p[36]+p[37]+p[38]+p[39]+p[40]+p[41]+p[42]+
			p[43]+p[44]+p[45]+p[46]+p[47]+p[48]+p[49]+
			p[50]+p[51]+p[52]+p[53]+p[54]+p[55]+p[56]+
			p[57]+p[58]+p[59]+p[60]+p[61]+p[62]+p[63]+
			p[64]+p[65]+p[66]+p[67]+p[68]+p[69]+p[70]+
			p[71]+p[72]+p[73]+p[74]+p[75]+p[76]+p[77]+
			p[78]+p[79]+p[80]+p[81]+p[82]+p[83]+p[84]+
			p[85]+p[86]+p[87]+p[88]+p[89]+p[90]+p[91]+
			p[92]+p[93]+p[94]+p[95]+p[96]+p[97]+p[98]+
			p[99]+p[100]+p[101]+p[102]+p[103]+p[104]+
			p[105]+p[106]+p[107]+p[108]+p[109]+p[110]+
			p[111]+p[112]+p[113]+p[114]+p[115]+p[116]+
			p[117]+p[118]+p[119]+p[120]+p[121]+p[122]+
			p[123]+p[124]+p[125]+p[126]+p[127];
	}
	<span class="enscript-keyword">for</span> (next = p + 16; (<span class="enscript-type">void</span>*)next &lt;= (<span class="enscript-type">void</span>*)end; p = next, next += 16) {
		sum +=
			p[0]+p[1]+p[2]+p[3]+p[4]+p[5]+p[6]+p[7]+
			p[8]+p[9]+p[10]+p[11]+p[12]+p[13]+p[14]+
			p[15];
	}
	<span class="enscript-keyword">for</span> (next = p + 1; (<span class="enscript-type">void</span>*)next &lt;= (<span class="enscript-type">void</span>*)end; p = next, next++) {
		sum += *p;
	}
	<span class="enscript-keyword">return</span> sum;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cp</span>(<span class="enscript-type">char</span>* src, <span class="enscript-type">char</span>* dst, mode_t mode)
{
    <span class="enscript-type">int</span> sfd, dfd;
    <span class="enscript-type">char</span> buf[8192];
    ssize_t size;

    <span class="enscript-keyword">if</span> ((sfd = open(src, O_RDONLY)) &lt; 0) {
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">if</span> ((dfd = open(dst, O_CREAT|O_TRUNC|O_RDWR, mode)) &lt; 0) {
        <span class="enscript-keyword">return</span> -1;
    }
    <span class="enscript-keyword">while</span> ((size = read(sfd, buf, 8192)) &gt; 0) {
        <span class="enscript-keyword">if</span> (write(dfd, buf, size) &lt; size) <span class="enscript-keyword">return</span> -1;
    }
    fsync(dfd);
    close(sfd);
    close(dfd);
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_init</span>()
{
	debug(<span class="enscript-string">&quot;benchmark_init&quot;</span>);
	<span class="enscript-comment">/* 
	 *	the lm_optstr must be defined here or no options for you
	 *
	 * 	...and the framework will throw an error
	 *
	 */</span>
	(<span class="enscript-type">void</span>) sprintf(lm_optstr, <span class="enscript-string">&quot;f:is:&quot;</span>);
	<span class="enscript-comment">/*
	 * 	tsd_t is the state info struct that we pass around 
	 *
	 *	lm_tsdsize will allocate the space we need for this
	 *	structure throughout the rest of the framework
	 */</span>
	lm_tsdsize = <span class="enscript-keyword">sizeof</span> (tsd_t);

	(<span class="enscript-type">void</span>) sprintf(lm_usage,
		<span class="enscript-string">&quot;		-f filename\n&quot;</span>
		<span class="enscript-string">&quot;		-s size\n&quot;</span>
		<span class="enscript-string">&quot;		[-i] io_only (no open/close)\n&quot;</span>
	    <span class="enscript-string">&quot;notes: read and sum file via memory mapping mmap(2) interface&quot;</span>);
	sprintf(optf, <span class="enscript-string">&quot;/tmp/%d&quot;</span>, (<span class="enscript-type">int</span>)getpid());
	opts = 1024;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * This is where you parse your lower-case arguments.
 * the format was defined in the lm_optstr assignment
 * in benchmark_init
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_optswitch</span>(<span class="enscript-type">int</span> opt, <span class="enscript-type">char</span> *optarg)
{
	debug(<span class="enscript-string">&quot;benchmark_optswitch&quot;</span>);
	
	<span class="enscript-keyword">switch</span> (opt) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'f'</span>:
		strncpy(optf, optarg, 255);
		debug(<span class="enscript-string">&quot;optf = %s\n&quot;</span>, optf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'i'</span>:
		opti = true;
		debug(<span class="enscript-string">&quot;opti = %s\n&quot;</span>, opti? <span class="enscript-string">&quot;true&quot;</span>: <span class="enscript-string">&quot;false&quot;</span>);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
		opts = sizetoint(optarg);
		debug(<span class="enscript-string">&quot;opts = %d\n&quot;</span>, opts);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initrun</span>()
{
	debug(<span class="enscript-string">&quot;benchmark_initrun&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initworker</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-comment">/*
	 *	initialize your state variables here first
	 */</span>
	tsd_t	*state = (tsd_t *)tsd;
	
	strncpy(state-&gt;filename, optf, 255);
	state-&gt;nbytes = opts;
	state-&gt;open_read_close = opti;

	debug(<span class="enscript-string">&quot;benchmark_initworker\n&quot;</span>);	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initbatch</span>(<span class="enscript-type">void</span> *tsd)
{
	tsd_t	*state = (tsd_t *)tsd;
	state-&gt;fd = -1;
	state-&gt;buf = NULL;

	<span class="enscript-keyword">if</span> (state-&gt;clone) {
		<span class="enscript-type">char</span> buf[8192];
		<span class="enscript-type">char</span>* s;

		<span class="enscript-comment">/* copy original file into a process-specific one */</span>
		sprintf(buf, <span class="enscript-string">&quot;/tmp/%d&quot;</span>, (<span class="enscript-type">int</span>)getpid());
		s = (<span class="enscript-type">char</span>*)malloc(strlen(state-&gt;filename) + strlen(buf) + 1);
		sprintf(s, <span class="enscript-string">&quot;/tmp/%s%d&quot;</span>, state-&gt;filename, (<span class="enscript-type">int</span>)getpid());
		<span class="enscript-keyword">if</span> (cp(state-&gt;filename, s, S_IREAD|S_IWRITE) &lt; 0) {
			perror(<span class="enscript-string">&quot;creating private tempfile&quot;</span>);
			unlink(s);
			exit(1);
		}
		strcpy(state-&gt;filename, s);
	}

	CHK(state-&gt;fd = open(state-&gt;filename, 0));
	CHK(state-&gt;buf = mmap(0, state-&gt;nbytes, PROT_READ,
				     MMAP_FLAGS, state-&gt;fd, 0));
	debug(<span class="enscript-string">&quot;benchmark_initbatch&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark</span>(<span class="enscript-type">void</span> *tsd, result_t *res)
{
	<span class="enscript-comment">/* 
	 *	try not to initialize things here.  This is the main
	 *  loop of things to get timed.  Start a server in 
	 *  benchmark_initbatch
	 */</span>
	tsd_t	*state = (tsd_t *)tsd;
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">int</span>		fd;
	<span class="enscript-type">void</span>	*p;
	
	debug(<span class="enscript-string">&quot;in to benchmark - optB = %i&quot;</span>, lm_optB);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optB; i++) {
		<span class="enscript-keyword">if</span> (state-&gt;open_read_close) {
			CHK(fd = open(state-&gt;filename, 0));
			CHK(p = mmap(0, state-&gt;nbytes, PROT_READ, MMAP_FLAGS, fd, 0));
			bread(p, state-&gt;nbytes);
			close(fd);
			munmap(p, state-&gt;nbytes);
		} <span class="enscript-keyword">else</span> {
			bread(state-&gt;buf, state-&gt;nbytes);
		}
	}
	res-&gt;re_count = i;
	debug(<span class="enscript-string">&quot;out of benchmark - optB = %i&quot;</span>, lm_optB);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finibatch</span>(<span class="enscript-type">void</span> *tsd)
{
	tsd_t	*state = (tsd_t *)tsd;
	<span class="enscript-keyword">if</span> (state-&gt;buf) munmap(state-&gt;buf, state-&gt;nbytes);
	<span class="enscript-keyword">if</span> (state-&gt;fd &gt;= 0) close(state-&gt;fd);
	<span class="enscript-keyword">if</span> (state-&gt;clone) unlink(state-&gt;filename);
	debug(<span class="enscript-string">&quot;benchmark_finibatch&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finiworker</span>(<span class="enscript-type">void</span> *tsd)
{
	debug(<span class="enscript-string">&quot;benchmark_finiworker&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">benchmark_result</span>()
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span>		result = <span class="enscript-string">'\0'</span>;
	debug(<span class="enscript-string">&quot;benchmark_result&quot;</span>);
	<span class="enscript-keyword">return</span> (&amp;result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finirun</span>()
{
	debug(<span class="enscript-string">&quot;benchmark_finirun&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_fini</span>()
{
	debug(<span class="enscript-string">&quot;benchmark_fini&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

</pre>
<hr />
</body></html>