<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lmbench_select_file.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lmbench_select_file.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Inc.  All Rights Reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 *	Order of Execution
 *
 *	benchmark_init
 *
 *	benchmark_optswitch
 *
 *		benchmark_initrun
 *
 *			benchmark_initworker
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch
 *				benchmark_initbatch
 *					benchmark
 *				benchmark_finibatch, etc.
 *			benchmark_finiworker
 *
 *		benchmark_result
 *
 *		benchmark_finirun
 *
 *	benchmark_fini
 */</span>



#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__sun</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">ident</span>	<span class="enscript-string">&quot;@(#)socket.c	1.3	05/08/04 Apple Inc.&quot;</span>
#<span class="enscript-reference">endif</span>



#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../libmicro.h&quot;</span>

<span class="enscript-comment">/*
 * lmbench routines, etc. brought over for this benchmark
 */</span>
<span class="enscript-type">int</span>  <span class="enscript-function-name">open_file</span>(<span class="enscript-type">void</span>* tsd);
<span class="enscript-type">void</span> <span class="enscript-function-name">server</span>(<span class="enscript-type">void</span>* tsd);


<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*open_f)(<span class="enscript-type">void</span>* tsd);
<span class="enscript-comment">/*
 * end of lmbench support routines
 */</span>

<span class="enscript-comment">/*
 *	Your state variables should live in the tsd_t struct below
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">char</span>	fname[L_tmpnam];
	open_f	fid_f;
	pid_t	pid;
	<span class="enscript-type">int</span>	sock;
	<span class="enscript-type">int</span>	fid;
	<span class="enscript-type">int</span>	num;
	<span class="enscript-type">int</span>	max;
	fd_set  set;
} tsd_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optt = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optn = -1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	optp = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	optw = 0;

<span class="enscript-comment">/*
 * lmbench routines, etc. brought over for this benchmark
 */</span>
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">morefds</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">RLIMIT_NOFILE</span>
        <span class="enscript-type">struct</span>  rlimit r;

        getrlimit(RLIMIT_NOFILE, &amp;r);
        r.rlim_cur = r.rlim_max;
        setrlimit(RLIMIT_NOFILE, &amp;r);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">open_file</span>(<span class="enscript-type">void</span>* tsd)
{
	tsd_t* ts = (tsd_t*)tsd;
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;open_file: ts-&gt;fname = %s\n&quot;,ts-&gt;fname);
</span>	<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>) open(ts-&gt;fname, O_RDONLY);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">server</span>(<span class="enscript-type">void</span>* tsd)
{
	<span class="enscript-type">int</span> pid;
	tsd_t* ts = (tsd_t*)tsd;

	pid = getpid();
	ts-&gt;pid = 0;
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;server: state-&gt;fid_f = %i\n&quot;,ts-&gt;fid_f);
</span>	
	<span class="enscript-keyword">if</span> (ts-&gt;fid_f == open_file) {
		<span class="enscript-comment">/* Create a temporary file for clients to open */</span>
		sprintf(ts-&gt;fname, <span class="enscript-string">&quot;/tmp/lat_selectXXXXXX&quot;</span>);
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;server: ts-&gt;fname = %s\n&quot;,ts-&gt;fname);
</span>		ts-&gt;fid = mkstemp(ts-&gt;fname);
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;server: ts-&gt;fname = %s: ts-&gt;fid = %d\n&quot;,ts-&gt;fname, ts-&gt;fid);
</span>
		<span class="enscript-keyword">if</span> (ts-&gt;fid &lt;= 0) {
			<span class="enscript-type">char</span> buf[L_tmpnam+128];
			sprintf(buf, <span class="enscript-string">&quot;lat_select: Could not create temp file %s&quot;</span>, ts-&gt;fname);
			perror(buf);
			exit(1);
		}
		close(ts-&gt;fid);
		<span class="enscript-keyword">return</span>;
	}
<span class="enscript-comment">//
</span><span class="enscript-comment">//	this is all for the tcp version of this test only
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// 	/* Create a socket for clients to connect to */
</span><span class="enscript-comment">// 	state-&gt;sock = tcp_server(TCP_SELECT, SOCKOPT_REUSE);
</span><span class="enscript-comment">// 	if (state-&gt;sock &lt;= 0) {
</span><span class="enscript-comment">// 		perror(&quot;lat_select: Could not open tcp server socket&quot;);
</span><span class="enscript-comment">// 		exit(1);
</span><span class="enscript-comment">// 	}
</span>
	<span class="enscript-comment">/* Start a server process to accept client connections */</span>
<span class="enscript-comment">// 	switch(state-&gt;pid = fork()) {
</span><span class="enscript-comment">// 	case 0:
</span><span class="enscript-comment">// 		/* child server process */
</span><span class="enscript-comment">// 		while (pid == getppid()) {
</span><span class="enscript-comment">// 			int newsock = tcp_accept(state-&gt;sock, SOCKOPT_NONE);
</span><span class="enscript-comment">// 			read(newsock, &amp;state-&gt;fid, 1);
</span><span class="enscript-comment">// 			close(newsock);
</span><span class="enscript-comment">// 		}
</span><span class="enscript-comment">// 		exit(0);
</span><span class="enscript-comment">// 	case -1:
</span><span class="enscript-comment">// 		/* error */
</span><span class="enscript-comment">// 		perror(&quot;lat_select::server(): fork() failed&quot;);
</span><span class="enscript-comment">// 		exit(1);
</span><span class="enscript-comment">// 	default:
</span><span class="enscript-comment">// 		break;
</span><span class="enscript-comment">// 	}
</span>}


<span class="enscript-comment">/*
 * end of lmbench support routines
 */</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initbatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-comment">/*
	 * initialize your state variables here second
	 */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finirun</span>()
{
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_finirun\n&quot;);
</span>	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_init</span>()
{
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_init\n&quot;);
</span>	<span class="enscript-comment">/* 
	 *	the lm_optstr must be defined here or no options for you
	 *
	 * 	...and the framework will throw an error
	 *
	 */</span>
	(<span class="enscript-type">void</span>) sprintf(lm_optstr, <span class="enscript-string">&quot;p:w:n:t:&quot;</span>);
	<span class="enscript-comment">/*
	 *	working hypothesis:
	 *	
	 * 	tsd_t is the struct that we can pass around our
	 *	state info in
	 *
	 *	lm_tsdsize will allocate the space we need for this
	 *	structure throughout the rest of the framework
	 */</span>
	lm_tsdsize = <span class="enscript-keyword">sizeof</span> (tsd_t);

	(<span class="enscript-type">void</span>) sprintf(lm_usage,
		<span class="enscript-string">&quot;       [-p parallelism (default 1)]\n&quot;</span>			
		<span class="enscript-string">&quot;       [-w warmup (default 0)]\n&quot;</span>
		<span class="enscript-string">&quot;       [-n number of descriptors (default 1)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-t int (default 1)]\n&quot;</span>
	    <span class="enscript-string">&quot;notes: measures lmbench_select_file\n&quot;</span>);
	lm_defB = 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_fini</span>()
{
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_fini\n&quot;);
</span>	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finibatch</span>(<span class="enscript-type">void</span> *tsd)
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">char</span> *
<span class="enscript-function-name">benchmark_result</span>()
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span>		result = <span class="enscript-string">'\0'</span>;
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_result\n&quot;);
</span>	<span class="enscript-keyword">return</span> (&amp;result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_finiworker</span>(<span class="enscript-type">void</span> *tsd)
{
	tsd_t			*ts = (tsd_t *)tsd;
	<span class="enscript-type">int</span> i;
	<span class="enscript-comment">// pulls in the lmbench cleanup code
</span>	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_finiworker\n&quot;);
</span>	<span class="enscript-keyword">for</span> (i = 0; i &lt;= ts-&gt;max; ++i) {
		<span class="enscript-keyword">if</span> (FD_ISSET(i, &amp;(ts-&gt;set)))
			close(i);
	}
	FD_ZERO(&amp;(ts-&gt;set));
	unlink(ts-&gt;fname);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_optswitch</span>(<span class="enscript-type">int</span> opt, <span class="enscript-type">char</span> *optarg)
{
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_optswitch\n&quot;);
</span>	
	<span class="enscript-keyword">switch</span> (opt) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
		optt = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
		optn = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
		optp = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
		optw = sizetoint(optarg);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initworker</span>(<span class="enscript-type">void</span> *tsd)
{	
	<span class="enscript-comment">// pulls in code from lmbench main and initialize
</span>	<span class="enscript-type">int</span>		n = 0;
	<span class="enscript-comment">/*
	 *	initialize your state variables here first
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	<span class="enscript-type">int</span>	N, fid, fd;
	
	<span class="enscript-comment">/*
	 * default number of file descriptors
	 */</span>
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker\n&quot;);
</span>	ts-&gt;num = 200;
	<span class="enscript-keyword">if</span> (optn &gt; 0) {
		ts-&gt;num = optn;
	}
	N = ts-&gt;num;
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker ts-&gt;num is %i\n&quot;,ts-&gt;num);
</span>	
	<span class="enscript-comment">/*
	 *	grab more file descriptors
	 */</span>
	 
	morefds();
	
	ts-&gt;fid_f = open_file;
	server(ts);
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: returned from server call\n&quot;);
</span>	<span class="enscript-comment">/* 
	 * Initialize function from lmbench
	 * for this test
	 */</span>
	fid = (*ts-&gt;fid_f)(ts);
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;initworker: fid is %i\n&quot;,fid);
</span>	<span class="enscript-keyword">if</span> (fid &lt;= 0) {
		perror(<span class="enscript-string">&quot;Could not open device&quot;</span>);
		exit(1);
	}
	ts-&gt;max = 0;
	FD_ZERO(&amp;(ts-&gt;set));
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;initworker FD_ZERO: ts-&gt;set result is %i\n&quot;,ts-&gt;set);
</span>	<span class="enscript-comment">//(void) fprintf(stderr, &quot;initworker: N is %i\n&quot;,N);
</span>	<span class="enscript-keyword">for</span> (n = 0; n &lt; N; n++) {
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: in the loop - N is %i: n is %i\n&quot;,N, n);
</span>		fd = dup(fid);
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: dup result is %i\n&quot;,fd);
</span>		<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: errno result is %d - \&quot;%s\&quot;\n&quot;,errno, strerror(errno));
</span>
		<span class="enscript-keyword">if</span> (fd == -1) <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (fd &gt; ts-&gt;max)
			ts-&gt;max = fd;
		FD_SET(fd, &amp;(ts-&gt;set));
		<span class="enscript-comment">//(void) fprintf(stderr, &quot;initworker FD_SET: ts-&gt;set result is %i\n&quot;,ts-&gt;set);
</span>
	}
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: after second macro/loop\n&quot;);
</span>
	ts-&gt;max++;
	close(fid);
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: N is %i: n is %i\n&quot;,N, n);
</span>	<span class="enscript-keyword">if</span> (n != N)
		exit(1);
	<span class="enscript-comment">/* end of initialize function */</span>
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initworker: about to exit\n&quot;);
</span>	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark_initrun</span>()
{
	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark_initrun\n&quot;);
</span>	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">benchmark</span>(<span class="enscript-type">void</span> *tsd, result_t *res)
{
	<span class="enscript-comment">/* 
	 *	initialize your state variables here last
	 * 
	 * 	and realize that you are paying for your initialization here
	 *	and it is really a bad idea
	 */</span>
	tsd_t			*ts = (tsd_t *)tsd;
	fd_set		nosave;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark\n&quot;);
</span>
	<span class="enscript-type">int</span>			i;
	<span class="enscript-comment">//int 		sel_res;
</span>	tv.tv_sec = 0;
	tv.tv_usec = 0;

	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optB; i++) {
		 nosave = ts-&gt;set;
		 <span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark: nosave is %i\n&quot;, nosave);
</span>
		 select(ts-&gt;num, 0, &amp;nosave, 0, &amp;tv);
		 <span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark: select result is %i\n&quot;,sel_res);
</span>		 <span class="enscript-comment">//(void) fprintf(stderr, &quot;benchmark: errno result is %d - \&quot;%s\&quot;\n&quot;,errno, strerror(errno));
</span>
		 
	}
	res-&gt;re_count = i;
	<span class="enscript-keyword">return</span> (0);
}

</pre>
<hr />
</body></html>