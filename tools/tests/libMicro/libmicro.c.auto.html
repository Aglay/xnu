<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>libmicro.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">libmicro.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms
 * of the Common Development and Distribution License
 * (the &quot;License&quot;).  You may not use this file except
 * in compliance with the License.
 *
 * You can obtain a copy of the license at
 * src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing
 * permissions and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL
 * HEADER in each file and include the License file at
 * usr/src/OPENSOLARIS.LICENSE.  If applicable,
 * add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your
 * own identifying information: Portions Copyright [yyyy]
 * [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>

<span class="enscript-comment">/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</span>

<span class="enscript-comment">/*
 * benchmarking routines
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ipc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sem.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/wait.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ctype.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;strings.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;poll.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dlfcn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;math.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">__sun</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/elf.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;libmicro.h&quot;</span>


#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">gethrtime</span>(<span class="enscript-type">void</span>)
{
   <span class="enscript-type">long</span> <span class="enscript-type">long</span>        elapsed;
   <span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>        start;
   <span class="enscript-type">static</span> mach_timebase_info_data_t    sTimebaseInfo = { 0, 0 };

   <span class="enscript-comment">// If this is the first time we've run, get the timebase.
</span>   <span class="enscript-comment">// We can use denom == 0 to indicate that sTimebaseInfo is
</span>   <span class="enscript-comment">// uninitialised because it makes no sense to have a zero
</span>   <span class="enscript-comment">// denominator in a fraction.
</span>
   <span class="enscript-keyword">if</span> ( sTimebaseInfo.denom == 0 ) {
       (<span class="enscript-type">void</span>) mach_timebase_info(&amp;sTimebaseInfo);
		start = mach_absolute_time();
   }

   elapsed = mach_absolute_time() - start;

   <span class="enscript-comment">// Convert to nanoseconds.
</span>	<span class="enscript-comment">// return (elapsed * (long long)sTimebaseInfo.numer)/(long long)sTimebaseInfo.denom;
</span>	
	<span class="enscript-comment">// Provided the final result is representable in 64 bits the following maneuver will
</span>	<span class="enscript-comment">// deliver that result without intermediate overflow.
</span>	<span class="enscript-keyword">if</span> (sTimebaseInfo.denom == sTimebaseInfo.numer)
		<span class="enscript-keyword">return</span> elapsed;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sTimebaseInfo.denom == 1)
		<span class="enscript-keyword">return</span> elapsed * (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)sTimebaseInfo.numer;
	<span class="enscript-keyword">else</span> {
       <span class="enscript-comment">// Decompose elapsed = eta32 * 2^32 + eps32:
</span>       <span class="enscript-type">long</span> <span class="enscript-type">long</span> eta32 = elapsed &gt;&gt; 32;
       <span class="enscript-type">long</span> <span class="enscript-type">long</span> eps32 = elapsed &amp; 0x00000000ffffffffLL;

       <span class="enscript-type">long</span> <span class="enscript-type">long</span> numer = sTimebaseInfo.numer, denom = sTimebaseInfo.denom;

       <span class="enscript-comment">// Form product of elapsed64 (decomposed) and numer:
</span>       <span class="enscript-type">long</span> <span class="enscript-type">long</span> mu64 = numer * eta32;
       <span class="enscript-type">long</span> <span class="enscript-type">long</span> lambda64 = numer * eps32;

       <span class="enscript-comment">// Divide the constituents by denom:
</span>       <span class="enscript-type">long</span> <span class="enscript-type">long</span> q32 = mu64/denom;
       <span class="enscript-type">long</span> <span class="enscript-type">long</span> r32 = mu64 - (q32 * denom); <span class="enscript-comment">// mu64 % denom
</span>
       <span class="enscript-keyword">return</span> (q32 &lt;&lt; 32) + ((r32 &lt;&lt; 32) + lambda64)/denom;
	}
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * user visible globals
 */</span>

<span class="enscript-type">int</span>				lm_argc = 0;
<span class="enscript-type">char</span> **				lm_argv = NULL;

<span class="enscript-type">int</span>				lm_opt1;
<span class="enscript-type">int</span>				lm_optA;
<span class="enscript-type">int</span>				lm_optB;
<span class="enscript-type">int</span>				lm_optC = 100;
<span class="enscript-type">int</span>				lm_optD;
<span class="enscript-type">int</span>				lm_optE;
<span class="enscript-type">int</span>				lm_optH;
<span class="enscript-type">int</span>				lm_optI;
<span class="enscript-type">int</span>				lm_optL = 0;
<span class="enscript-type">int</span>				lm_optM = 0;
<span class="enscript-type">char</span>				*lm_optN;
<span class="enscript-type">int</span>				lm_optP;
<span class="enscript-type">int</span>				lm_optS;
<span class="enscript-type">int</span>				lm_optT;
<span class="enscript-type">int</span>				lm_optW;

<span class="enscript-type">int</span>				lm_def1 = 0;
<span class="enscript-type">int</span>				lm_defB = 0; <span class="enscript-comment">/* use lm_nsecs_per_op */</span>
<span class="enscript-type">int</span>				lm_defD = 10;
<span class="enscript-type">int</span>				lm_defH = 0;
<span class="enscript-type">char</span>				*lm_defN = NULL;
<span class="enscript-type">int</span>				lm_defP = 1;

<span class="enscript-type">int</span>				lm_defS = 0;
<span class="enscript-type">int</span>				lm_defT = 1;

<span class="enscript-comment">/*
 * default on fast platform, should be overridden by individual
 * benchmarks if significantly wrong in either direction.
 */</span>

<span class="enscript-type">int</span>				lm_nsecs_per_op = 5;

<span class="enscript-type">char</span>				*lm_procpath;
<span class="enscript-type">char</span>				lm_procname[STRSIZE];
<span class="enscript-type">char</span>				lm_usage[STRSIZE];
<span class="enscript-type">char</span>				lm_optstr[STRSIZE];
<span class="enscript-type">char</span>				lm_header[STRSIZE];
size_t				lm_tsdsize = 0;


<span class="enscript-comment">/*
 *  Globals we do not export to the user
 */</span>

<span class="enscript-type">static</span> barrier_t		*lm_barrier;
<span class="enscript-type">static</span> pid_t			*pids = NULL;
<span class="enscript-type">static</span> pthread_t		*tids = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			pindex = -1;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>			*tsdseg = NULL;
<span class="enscript-type">static</span> size_t			tsdsize = 0;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_RDTSC</span>
<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>		lm_hz = 0;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Forward references
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		worker_process();
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		usage();
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		print_stats(barrier_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		print_histo(barrier_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 		remove_outliers(<span class="enscript-type">double</span> *, <span class="enscript-type">int</span>, stats_t *);
<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>	nsecs_overhead;
<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>	nsecs_resolution;
<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>	get_nsecs_overhead();
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		crunch_stats(<span class="enscript-type">double</span> *, <span class="enscript-type">int</span>, stats_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 		compute_stats(barrier_t *);
<span class="enscript-comment">/*
 * main routine; renamed in this file to allow linking with other
 * files
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">actual_main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> *argv[])
{
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			opt;
	<span class="enscript-type">extern</span> <span class="enscript-type">char</span>		*optarg;
	<span class="enscript-type">char</span>			*tmp;
	<span class="enscript-type">char</span>			optstr[256];
	barrier_t		*b;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		startnsecs = getnsecs();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_RDTSC</span>
	<span class="enscript-keyword">if</span> (getenv(<span class="enscript-string">&quot;LIBMICRO_HZ&quot;</span>) == NULL) {
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;LIBMICRO_HZ needed but not set\n&quot;</span>);
		exit(1);
	}
	lm_hz = strtoll(getenv(<span class="enscript-string">&quot;LIBMICRO_HZ&quot;</span>), NULL, 10);
#<span class="enscript-reference">endif</span>

	lm_argc = argc;
	lm_argv = argv;

	<span class="enscript-comment">/* before we do anything */</span>
	(<span class="enscript-type">void</span>) benchmark_init();


	nsecs_overhead = get_nsecs_overhead();
	nsecs_resolution = get_nsecs_resolution();

	<span class="enscript-comment">/*
	 * Set defaults
	 */</span>

	lm_opt1	= lm_def1;
	lm_optB	= lm_defB;
	lm_optD	= lm_defD;
	lm_optH	= lm_defH;
	lm_optN	= lm_defN;
	lm_optP	= lm_defP;

	lm_optS	= lm_defS;
	lm_optT	= lm_defT;

	<span class="enscript-comment">/*
	 * squirrel away the path to the current
	 * binary in a way that works on both
	 * Linux and Solaris
	 */</span>

	<span class="enscript-keyword">if</span> (*argv[0] == <span class="enscript-string">'/'</span>) {
		lm_procpath = strdup(argv[0]);
		*strrchr(lm_procpath, <span class="enscript-string">'/'</span>) = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">char</span> path[1024];
		(<span class="enscript-type">void</span>) getcwd(path, 1024);
		(<span class="enscript-type">void</span>) strcat(path, <span class="enscript-string">&quot;/&quot;</span>);
		(<span class="enscript-type">void</span>) strcat(path, argv[0]);
		*strrchr(path, <span class="enscript-string">'/'</span>) = 0;
		lm_procpath = strdup(path);
	}

	<span class="enscript-comment">/*
	 * name of binary
	 */</span>

	<span class="enscript-keyword">if</span> ((tmp = strrchr(argv[0], <span class="enscript-string">'/'</span>)) == NULL)
		(<span class="enscript-type">void</span>) strcpy(lm_procname, argv[0]);
	<span class="enscript-keyword">else</span>
		(<span class="enscript-type">void</span>) strcpy(lm_procname, tmp + 1);

	<span class="enscript-keyword">if</span> (lm_optN == NULL) {
		lm_optN = lm_procname;
	}

	<span class="enscript-comment">/*
	 * Parse command line arguments
	 */</span>

	(<span class="enscript-type">void</span>) sprintf(optstr, <span class="enscript-string">&quot;1AB:C:D:EHI:LMN:P:RST:VW?%s&quot;</span>, lm_optstr);
	<span class="enscript-keyword">while</span> ((opt = getopt(argc, argv, optstr)) != -1) {
		<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-string">'1'</span>:
			lm_opt1 = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'A'</span>:
			lm_optA = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'B'</span>:
			lm_optB = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'C'</span>:
			lm_optC = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:
			lm_optD = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'E'</span>:
			lm_optE = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'H'</span>:
			lm_optH = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'I'</span>:
			lm_optI = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'L'</span>:
			lm_optL = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'M'</span>:
			lm_optM = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'N'</span>:
			lm_optN = optarg;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'P'</span>:
			lm_optP = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'S'</span>:
			lm_optS = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'T'</span>:
			lm_optT = sizetoint(optarg);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'V'</span>:
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%s\n&quot;</span>, LIBMICRO_VERSION);
			exit(0);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'W'</span>:
			lm_optW = 1;
			lm_optS = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
			usage();
			exit(0);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (benchmark_optswitch(opt, optarg) == -1) {
				usage();
				exit(0);
			}
		}
	}

	<span class="enscript-comment">/* deal with implicit and overriding options */</span>
	<span class="enscript-keyword">if</span> (lm_opt1 &amp;&amp; lm_optP &gt; 1) {
		lm_optP = 1;
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;warning: -1 overrides -P\n&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (lm_optE) {
		(<span class="enscript-type">void</span>) fprintf(stderr, <span class="enscript-string">&quot;Running:%20s&quot;</span>, lm_optN);
		(<span class="enscript-type">void</span>) fflush(stderr);
	}

	<span class="enscript-keyword">if</span> (lm_optB == 0) {
		<span class="enscript-comment">/*
		 * neither benchmark or user has specified the number
		 * of cnts/sample, so use computed value
		 */</span>
		<span class="enscript-keyword">if</span> (lm_optI)
			lm_nsecs_per_op = lm_optI;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BLOCK_TOCK_DURATION</span> 10000 <span class="enscript-comment">/* number of raw timer &quot;tocks&quot; ideally comprising a block of work */</span>
		lm_optB = nsecs_resolution * BLOCK_TOCK_DURATION / lm_nsecs_per_op;
		<span class="enscript-keyword">if</span> (lm_optB == 0)
			lm_optB = 1;
	}

	<span class="enscript-comment">/*
	 * now that the options are set
	 */</span>

	<span class="enscript-keyword">if</span> (benchmark_initrun() == -1) {
		exit(1);
	}

	<span class="enscript-comment">/* allocate dynamic data */</span>
	pids = (pid_t *)malloc(lm_optP * <span class="enscript-keyword">sizeof</span> (pid_t));
	<span class="enscript-keyword">if</span> (pids == NULL) {
		perror(<span class="enscript-string">&quot;malloc(pids)&quot;</span>);
		exit(1);
	}
	tids = (pthread_t *)malloc(lm_optT * <span class="enscript-keyword">sizeof</span> (pthread_t));
	<span class="enscript-keyword">if</span> (tids == NULL) {
		perror(<span class="enscript-string">&quot;malloc(tids)&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* check that the case defines lm_tsdsize before proceeding */</span>
	<span class="enscript-keyword">if</span> (lm_tsdsize == (size_t)-1) {
		(<span class="enscript-type">void</span>) fprintf(stderr, <span class="enscript-string">&quot;error in benchmark_init: &quot;</span>
		    <span class="enscript-string">&quot;lm_tsdsize not set\n&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* round up tsdsize to nearest 128 to eliminate false sharing */</span>
	tsdsize = ((lm_tsdsize + 127) / 128) * 128;

	<span class="enscript-comment">/* allocate sufficient TSD for each thread in each process */</span>
	tsdseg = (<span class="enscript-type">void</span> *)mmap(NULL, lm_optT * lm_optP * tsdsize + 8192,
	    PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANON, -1, 0L);
	<span class="enscript-keyword">if</span> (tsdseg == NULL) {
		perror(<span class="enscript-string">&quot;mmap(tsd)&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* initialise worker synchronisation */</span>
	b = barrier_create(lm_optT * lm_optP, DATASIZE);
	<span class="enscript-keyword">if</span> (b == NULL) {
		perror(<span class="enscript-string">&quot;barrier_create()&quot;</span>);
		exit(1);
	}
	lm_barrier = b;
	b-&gt;ba_flag = 1;

	<span class="enscript-comment">/* need this here so that parent and children can call exit() */</span>
	(<span class="enscript-type">void</span>) fflush(stdout);
	(<span class="enscript-type">void</span>) fflush(stderr);

	<span class="enscript-comment">/* when we started and when to stop */</span>

	b-&gt;ba_starttime = getnsecs();
	b-&gt;ba_deadline = (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) (b-&gt;ba_starttime + (lm_optD * 1000000LL));

	<span class="enscript-comment">/* do the work */</span>
	<span class="enscript-keyword">if</span> (lm_opt1) {
		<span class="enscript-comment">/* single process, non-fork mode */</span>
		pindex = 0;
		worker_process();
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* create worker processes */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optP; i++) {
			pids[i] = fork();

			<span class="enscript-keyword">switch</span> (pids[i]) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
				pindex = i;
				worker_process();
				exit(0);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>:
				perror(<span class="enscript-string">&quot;fork&quot;</span>);
				exit(1);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-comment">/* wait for worker processes */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; lm_optP; i++) {
			<span class="enscript-keyword">if</span> (pids[i] &gt; 0) {
				(<span class="enscript-type">void</span>) waitpid(pids[i], NULL, 0);
			}
		}
	}

	b-&gt;ba_endtime = getnsecs();

	<span class="enscript-comment">/* compute results */</span>

	compute_stats(b);

	<span class="enscript-comment">/* print arguments benchmark was invoked with ? */</span>
	<span class="enscript-keyword">if</span> (lm_optL) {
		<span class="enscript-type">int</span> l;
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;# %s &quot;</span>, argv[0]);
		<span class="enscript-keyword">for</span> (l = 1; l &lt; argc; l++) {
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%s &quot;</span>, argv[l]);
		}
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}

	<span class="enscript-comment">/* print result header (unless suppressed) */</span>
	<span class="enscript-keyword">if</span> (!lm_optH) {
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%12s %3s %3s %12s %12s %8s %8s %s\n&quot;</span>,
		    <span class="enscript-string">&quot;&quot;</span>, <span class="enscript-string">&quot;prc&quot;</span>, <span class="enscript-string">&quot;thr&quot;</span>,
		    <span class="enscript-string">&quot;usecs/call&quot;</span>,
		    <span class="enscript-string">&quot;samples&quot;</span>, <span class="enscript-string">&quot;errors&quot;</span>, <span class="enscript-string">&quot;cnt/samp&quot;</span>, lm_header);
	}

	<span class="enscript-comment">/* print result */</span>

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%-12s %3d %3d %12.5f %12d %8lld %8d %s\n&quot;</span>,
	    lm_optN, lm_optP, lm_optT,
	    (lm_optM?b-&gt;ba_corrected.st_mean:b-&gt;ba_corrected.st_median),
	    b-&gt;ba_batches, b-&gt;ba_errors, lm_optB,
	    benchmark_result());

	<span class="enscript-keyword">if</span> (lm_optS) {
		print_stats(b);
	}

	<span class="enscript-comment">/* just incase something goes awry */</span>
	(<span class="enscript-type">void</span>) fflush(stdout);
	(<span class="enscript-type">void</span>) fflush(stderr);

	<span class="enscript-comment">/* cleanup by stages */</span>
	(<span class="enscript-type">void</span>) benchmark_finirun();
	(<span class="enscript-type">void</span>) barrier_destroy(b);
	(<span class="enscript-type">void</span>) benchmark_fini();

	<span class="enscript-keyword">if</span> (lm_optE) {
		(<span class="enscript-type">void</span>) fprintf(stderr, <span class="enscript-string">&quot; for %12.5f seconds\n&quot;</span>,
		    (<span class="enscript-type">double</span>)(getnsecs() - startnsecs) /
		    1.e9);
		(<span class="enscript-type">void</span>) fflush(stderr);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">worker_thread</span>(<span class="enscript-type">void</span> *arg)
{
	result_t		r;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span> 		last_sleep = 0;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		t;

	r.re_errors = benchmark_initworker(arg);

	<span class="enscript-keyword">while</span> (lm_barrier-&gt;ba_flag) {
		r.re_count = 0;
		r.re_errors += benchmark_initbatch(arg);

		<span class="enscript-comment">/* sync to clock */</span>

		<span class="enscript-keyword">if</span> (lm_optA &amp;&amp; ((t = getnsecs()) - last_sleep) &gt; 75000000LL) {
			(<span class="enscript-type">void</span>) poll(0, 0, 10);
			last_sleep = t;
		}
		<span class="enscript-comment">/* wait for it ... */</span>
		(<span class="enscript-type">void</span>) barrier_queue(lm_barrier, NULL);

		<span class="enscript-comment">/* time the test */</span>
		r.re_t0 = getnsecs();
		(<span class="enscript-type">void</span>) benchmark(arg, &amp;r);
		r.re_t1 = getnsecs();

		<span class="enscript-comment">/* time to stop? */</span>
		<span class="enscript-keyword">if</span> (r.re_t1 &gt; lm_barrier-&gt;ba_deadline &amp;&amp;
		    (!lm_optC || lm_optC &lt; lm_barrier-&gt;ba_batches)) {
			lm_barrier-&gt;ba_flag = 0;
		}

		<span class="enscript-comment">/* record results and sync */</span>
		(<span class="enscript-type">void</span>) barrier_queue(lm_barrier, &amp;r);

		(<span class="enscript-type">void</span>) benchmark_finibatch(arg);

		r.re_errors = 0;
	}

	(<span class="enscript-type">void</span>) benchmark_finiworker(arg);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">worker_process</span>()
{
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">void</span>			*tsd;

	<span class="enscript-keyword">for</span> (i = 1; i &lt; lm_optT; i++) {
		tsd = gettsd(pindex, i);
		<span class="enscript-keyword">if</span> (pthread_create(&amp;tids[i], NULL, worker_thread, tsd) != 0) {
			perror(<span class="enscript-string">&quot;pthread_create&quot;</span>);
			exit(1);
		}
	}

	tsd = gettsd(pindex, 0);
	(<span class="enscript-type">void</span>) worker_thread(tsd);

	<span class="enscript-keyword">for</span> (i = 1; i &lt; lm_optT; i++) {
		(<span class="enscript-type">void</span>) pthread_join(tids[i], NULL);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">usage</span>()
{
	(<span class="enscript-type">void</span>) printf(
	    <span class="enscript-string">&quot;usage: %s\n&quot;</span>
	    <span class="enscript-string">&quot;       [-1] (single process; overrides -P &gt; 1)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-A] (align with clock)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-B batch-size (default %d)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-C minimum number of samples (default 0)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-D duration in msecs (default %ds)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-E (echo name to stderr)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-H] (suppress headers)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-I] nsecs per op (used to compute batch size)&quot;</span>
	    <span class="enscript-string">&quot;       [-L] (print argument line)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-M] (reports mean rather than median)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-N test-name (default '%s')]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-P processes (default %d)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-S] (print detailed stats)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-T threads (default %d)]\n&quot;</span>
	    <span class="enscript-string">&quot;       [-V] (print the libMicro version and exit)\n&quot;</span>
	    <span class="enscript-string">&quot;       [-W] (flag possible benchmark problems)\n&quot;</span>
	    <span class="enscript-string">&quot;%s\n&quot;</span>,
	    lm_procname,
	    lm_defB, lm_defD, lm_procname, lm_defP, lm_defT,
	    lm_usage);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_warnings</span>(barrier_t *b)
{
	<span class="enscript-type">int</span> head = 0;
	<span class="enscript-type">int</span> increase;

	<span class="enscript-keyword">if</span> (b-&gt;ba_quant) {
		<span class="enscript-keyword">if</span> (!head++) {
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n# WARNINGS\n&quot;</span>);
		}
		increase = (<span class="enscript-type">int</span>)(floor((nsecs_resolution * 100.0) /
		    ((<span class="enscript-type">double</span>)lm_optB * b-&gt;ba_corrected.st_median * 1000.0)) +
		    1.0);
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#     Quantization error likely;&quot;</span>
		    <span class="enscript-string">&quot;increase batch size (-B option) %dX to avoid.\n&quot;</span>,
		    increase);
	}

	<span class="enscript-comment">/*
	 * XXX should warn on median != mean by a lot
	 */</span>

	<span class="enscript-keyword">if</span> (b-&gt;ba_errors) {
		<span class="enscript-keyword">if</span> (!head++) {
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n# WARNINGS\n&quot;</span>);
		}
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#     Errors occured during benchmark.\n&quot;</span>);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_stats</span>(barrier_t *b)
{
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n&quot;</span>);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;# STATISTICS         %12s          %12s\n&quot;</span>,
	    <span class="enscript-string">&quot;usecs/call (raw)&quot;</span>,
	    <span class="enscript-string">&quot;usecs/call (outliers removed)&quot;</span>);

	<span class="enscript-keyword">if</span> (b-&gt;ba_count == 0) {
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;zero samples\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                    min %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_min,
	    b-&gt;ba_corrected.st_min);

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                    max %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_max,
	    b-&gt;ba_corrected.st_max);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                   mean %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_mean,
	    b-&gt;ba_corrected.st_mean);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                 median %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_median,
	    b-&gt;ba_corrected.st_median);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                 stddev %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_stddev,
	    b-&gt;ba_corrected.st_stddev);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#         standard error %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_stderr,
	    b-&gt;ba_corrected.st_stderr);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#   99%% confidence level %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_99confidence,
	    b-&gt;ba_corrected.st_99confidence);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#                   skew %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_skew,
	    b-&gt;ba_corrected.st_skew);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#               kurtosis %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_kurtosis,
	    b-&gt;ba_corrected.st_kurtosis);

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       time correlation %12.5f            %12.5f\n&quot;</span>,
	    b-&gt;ba_raw.st_timecorr,
	    b-&gt;ba_corrected.st_timecorr);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n&quot;</span>);

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#           elasped time %12.5f\n&quot;</span>, (b-&gt;ba_endtime -
	    b-&gt;ba_starttime) / 1.0e9);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#      number of samples %12d\n&quot;</span>,   b-&gt;ba_batches);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#     number of outliers %12d\n&quot;</span>, b-&gt;ba_outliers);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#      getnsecs overhead %12d\n&quot;</span>, (<span class="enscript-type">int</span>)nsecs_overhead);

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n&quot;</span>);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;# DISTRIBUTION\n&quot;</span>);

	print_histo(b);

	<span class="enscript-keyword">if</span> (lm_optW) {
		print_warnings(b);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">update_stats</span>(barrier_t *b, result_t *r)
{
	<span class="enscript-type">double</span>			time;
	<span class="enscript-type">double</span>			nsecs_per_call;

	<span class="enscript-keyword">if</span> (b-&gt;ba_waiters == 0) {
		<span class="enscript-comment">/* first thread only */</span>
		b-&gt;ba_t0 = r-&gt;re_t0;
		b-&gt;ba_t1 = r-&gt;re_t1;
		b-&gt;ba_count0 = 0;
		b-&gt;ba_errors0 = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* all but first thread */</span>
		<span class="enscript-keyword">if</span> (r-&gt;re_t0 &lt; b-&gt;ba_t0) {
			b-&gt;ba_t0 = r-&gt;re_t0;
		}
		<span class="enscript-keyword">if</span> (r-&gt;re_t1 &gt; b-&gt;ba_t1) {
			b-&gt;ba_t1 = r-&gt;re_t1;
		}
	}

	b-&gt;ba_count0  += r-&gt;re_count;
	b-&gt;ba_errors0 += r-&gt;re_errors;

	<span class="enscript-keyword">if</span> (b-&gt;ba_waiters == b-&gt;ba_hwm - 1) {
		<span class="enscript-comment">/* last thread only */</span>


		time = (<span class="enscript-type">double</span>)b-&gt;ba_t1 - (<span class="enscript-type">double</span>)b-&gt;ba_t0 -
		    (<span class="enscript-type">double</span>)nsecs_overhead;

		<span class="enscript-keyword">if</span> (time &lt; 100 * nsecs_resolution)
			b-&gt;ba_quant++;

		<span class="enscript-comment">/*
		 * normalize by procs * threads if not -U
		 */</span>

		nsecs_per_call = time / (<span class="enscript-type">double</span>)b-&gt;ba_count0 *
		    (<span class="enscript-type">double</span>)(lm_optT * lm_optP);

		b-&gt;ba_count  += b-&gt;ba_count0;
		b-&gt;ba_errors += b-&gt;ba_errors0;

		b-&gt;ba_data[b-&gt;ba_batches % b-&gt;ba_datasize] =
		    nsecs_per_call;

		b-&gt;ba_batches++;
	}
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_SEMOP</span>
barrier_t *
<span class="enscript-function-name">barrier_create</span>(<span class="enscript-type">int</span> hwm, <span class="enscript-type">int</span> datasize)
{
	<span class="enscript-type">struct</span> sembuf		s[1];
	barrier_t		*b;

	<span class="enscript-comment">/*LINTED*/</span>
	b = (barrier_t *)mmap(NULL,
	    <span class="enscript-keyword">sizeof</span> (barrier_t) + (datasize - 1) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">double</span>),
	    PROT_READ | PROT_WRITE,
	    MAP_SHARED | MAP_ANON, -1, 0L);
	<span class="enscript-keyword">if</span> (b == (barrier_t *)MAP_FAILED) {
		<span class="enscript-keyword">return</span> (NULL);
	}
	b-&gt;ba_datasize = datasize;

	b-&gt;ba_flag  = 0;
	b-&gt;ba_hwm   = hwm;
	b-&gt;ba_semid = semget(IPC_PRIVATE, 3, 0600);
	<span class="enscript-keyword">if</span> (b-&gt;ba_semid == -1) {
		(<span class="enscript-type">void</span>) munmap((<span class="enscript-type">void</span> *)b, <span class="enscript-keyword">sizeof</span> (barrier_t));
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/* [hwm - 1, 0, 0] */</span>
	s[0].sem_num = 0;
	s[0].sem_op  = hwm - 1;
	s[0].sem_flg = 0;
	<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 1) == -1) {
		perror(<span class="enscript-string">&quot;semop(1)&quot;</span>);
		(<span class="enscript-type">void</span>) semctl(b-&gt;ba_semid, 0, IPC_RMID);
		(<span class="enscript-type">void</span>) munmap((<span class="enscript-type">void</span> *)b, <span class="enscript-keyword">sizeof</span> (barrier_t));
		<span class="enscript-keyword">return</span> (NULL);
	}

	b-&gt;ba_waiters = 0;
	b-&gt;ba_phase = 0;

	b-&gt;ba_count = 0;
	b-&gt;ba_errors = 0;

	<span class="enscript-keyword">return</span> (b);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">barrier_destroy</span>(barrier_t *b)
{
	(<span class="enscript-type">void</span>) semctl(b-&gt;ba_semid, 0, IPC_RMID);
	(<span class="enscript-type">void</span>) munmap((<span class="enscript-type">void</span> *)b, <span class="enscript-keyword">sizeof</span> (barrier_t));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">barrier_queue</span>(barrier_t *b, result_t *r)
{
	<span class="enscript-type">struct</span> sembuf		s[2];

	<span class="enscript-comment">/*
	 * {s0(-(hwm-1))}
	 * if ! nowait {s1(-(hwm-1))}
	 *   (all other threads)
	 *   update shared stats
	 *   {s0(hwm-1), s1(1)}
	 *   {s0(1), s2(-1)}
	 * else
	 *   (last thread)
	 *   update shared stats
	 *   {s2(hwm-1)}
	 */</span>

	s[0].sem_num = 0;
	s[0].sem_op  = -(b-&gt;ba_hwm - 1);
	s[0].sem_flg = 0;
	<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 1) == -1) {
		perror(<span class="enscript-string">&quot;semop(2)&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	s[0].sem_num = 1;
	s[0].sem_op  = -(b-&gt;ba_hwm - 1);
	s[0].sem_flg = IPC_NOWAIT;
	<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 1) == -1) {
		<span class="enscript-keyword">if</span> (errno != EAGAIN) {
			perror(<span class="enscript-string">&quot;semop(3)&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-comment">/* all but the last thread */</span>

		<span class="enscript-keyword">if</span> (r != NULL) {
			update_stats(b, r);
		}

		b-&gt;ba_waiters++;

		s[0].sem_num = 0;
		s[0].sem_op  = b-&gt;ba_hwm - 1;
		s[0].sem_flg = 0;
		s[1].sem_num = 1;
		s[1].sem_op  = 1;
		s[1].sem_flg = 0;
		<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 2) == -1) {
			perror(<span class="enscript-string">&quot;semop(4)&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		s[0].sem_num = 0;
		s[0].sem_op  = 1;
		s[0].sem_flg = 0;
		s[1].sem_num = 2;
		s[1].sem_op  = -1;
		s[1].sem_flg = 0;
		<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 2) == -1) {
			perror(<span class="enscript-string">&quot;semop(5)&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* the last thread */</span>

		<span class="enscript-keyword">if</span> (r != NULL) {
			update_stats(b, r);
		}

		b-&gt;ba_waiters = 0;
		b-&gt;ba_phase++;

		s[0].sem_num = 2;
		s[0].sem_op  = b-&gt;ba_hwm - 1;
		s[0].sem_flg = 0;
		<span class="enscript-keyword">if</span> (semop(b-&gt;ba_semid, s, 1) == -1) {
			perror(<span class="enscript-string">&quot;semop(6)&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* USE_SEMOP */</span>

barrier_t *
<span class="enscript-function-name">barrier_create</span>(<span class="enscript-type">int</span> hwm, <span class="enscript-type">int</span> datasize)
{
	pthread_mutexattr_t	attr;
	pthread_condattr_t	cattr;
	barrier_t		*b;

	<span class="enscript-comment">/*LINTED*/</span>
	b = (barrier_t *)mmap(NULL,
	    <span class="enscript-keyword">sizeof</span> (barrier_t) + (datasize - 1) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">double</span>),
	    PROT_READ | PROT_WRITE,
	    MAP_SHARED | MAP_ANON, -1, 0L);
	<span class="enscript-keyword">if</span> (b == (barrier_t *)MAP_FAILED) {
		<span class="enscript-keyword">return</span> (NULL);
	}
	b-&gt;ba_datasize = datasize;

	b-&gt;ba_hwm = hwm;
	b-&gt;ba_flag  = 0;

	(<span class="enscript-type">void</span>) pthread_mutexattr_init(&amp;attr);
	(<span class="enscript-type">void</span>) pthread_mutexattr_setpshared(&amp;attr, PTHREAD_PROCESS_SHARED);

	(<span class="enscript-type">void</span>) pthread_condattr_init(&amp;cattr);
	(<span class="enscript-type">void</span>) pthread_condattr_setpshared(&amp;cattr, PTHREAD_PROCESS_SHARED);

	(<span class="enscript-type">void</span>) pthread_mutex_init(&amp;b-&gt;ba_lock, &amp;attr);
	(<span class="enscript-type">void</span>) pthread_cond_init(&amp;b-&gt;ba_cv, &amp;cattr);

	b-&gt;ba_waiters = 0;
	b-&gt;ba_phase = 0;

	b-&gt;ba_count = 0;
	b-&gt;ba_errors = 0;

	<span class="enscript-keyword">return</span> (b);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">barrier_destroy</span>(barrier_t *b)
{
	(<span class="enscript-type">void</span>) munmap((<span class="enscript-type">void</span> *)b, <span class="enscript-keyword">sizeof</span> (barrier_t));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">barrier_queue</span>(barrier_t *b, result_t *r)
{
	<span class="enscript-type">int</span>			phase;

	(<span class="enscript-type">void</span>) pthread_mutex_lock(&amp;b-&gt;ba_lock);

	<span class="enscript-keyword">if</span> (r != NULL) {
		update_stats(b, r);
	}

	phase = b-&gt;ba_phase;

	b-&gt;ba_waiters++;
	<span class="enscript-keyword">if</span> (b-&gt;ba_hwm == b-&gt;ba_waiters) {
		b-&gt;ba_waiters = 0;
		b-&gt;ba_phase++;
		(<span class="enscript-type">void</span>) pthread_cond_broadcast(&amp;b-&gt;ba_cv);
	}

	<span class="enscript-keyword">while</span> (b-&gt;ba_phase == phase) {
		(<span class="enscript-type">void</span>) pthread_cond_wait(&amp;b-&gt;ba_cv, &amp;b-&gt;ba_lock);
	}

	(<span class="enscript-type">void</span>) pthread_mutex_unlock(&amp;b-&gt;ba_lock);
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* USE_SEMOP */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">gettindex</span>()
{
	<span class="enscript-type">int</span>			i;

	<span class="enscript-keyword">if</span> (tids == NULL) {
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">for</span> (i = 1; i &lt; lm_optT; i++) {
		<span class="enscript-keyword">if</span> (pthread_self() == tids[i]) {
			<span class="enscript-keyword">return</span> (i);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getpindex</span>()
{
	<span class="enscript-keyword">return</span> (pindex);
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">gettsd</span>(<span class="enscript-type">int</span> p, <span class="enscript-type">int</span> t)
{
	<span class="enscript-keyword">if</span> ((p &lt; 0) || (p &gt;= lm_optP) || (t &lt; 0) || (t &gt;= lm_optT))
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">void</span> *)((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)tsdseg +
	    (((p * lm_optT) + t) * tsdsize)));
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">int</span>
<span class="enscript-function-name">gettsdindex</span>(<span class="enscript-type">void</span> *arg){
        <span class="enscript-comment">/*
         * gettindex() can race with pthread_create() filling in tids[].
         * This is an alternative approach to finding the calling thread's tsd in t
sdseg
         */</span>
        <span class="enscript-keyword">return</span> tsdsize ? ((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)arg - (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)tsdseg)/tsdsize : 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">USE_GETHRTIME</span>
<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getnsecs</span>()
{
	<span class="enscript-keyword">return</span> (gethrtime());
}

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getusecs</span>()
{
	<span class="enscript-keyword">return</span> (gethrtime() / 1000);
}

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">USE_RDTSC</span> <span class="enscript-comment">/* USE_GETHRTIME */</span>

__inline__ <span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">rdtsc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span> x;
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;.byte 0x0f, 0x31&quot;</span> : <span class="enscript-string">&quot;=A&quot;</span> (x));
	<span class="enscript-keyword">return</span> (x);
}

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getusecs</span>()
{
	<span class="enscript-keyword">return</span> (rdtsc() * 1000000 / lm_hz);
}

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getnsecs</span>()
{
	<span class="enscript-keyword">return</span> (rdtsc() * 1000000000 / lm_hz);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* USE_GETHRTIME */</span>

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getusecs</span>()
{
	<span class="enscript-type">struct</span> timeval		tv;

	(<span class="enscript-type">void</span>) gettimeofday(&amp;tv, NULL);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)tv.tv_sec * 1000000LL + (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) tv.tv_usec);
}

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">getnsecs</span>()
{
	<span class="enscript-type">struct</span> timeval		tv;

	(<span class="enscript-type">void</span>) gettimeofday(&amp;tv, NULL);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)tv.tv_sec * 1000000000LL +
	    (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) tv.tv_usec * 1000LL);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* USE_GETHRTIME */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">setfdlimit</span>(<span class="enscript-type">int</span> limit)
{
	<span class="enscript-type">struct</span> rlimit rlimit;

	<span class="enscript-keyword">if</span> (getrlimit(RLIMIT_NOFILE, &amp;rlimit) &lt; 0) {
		perror(<span class="enscript-string">&quot;getrlimit&quot;</span>);
		exit(1);
	}

	<span class="enscript-keyword">if</span> (rlimit.rlim_cur &gt; limit)
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* no worries */</span>

	rlimit.rlim_cur = limit;

	<span class="enscript-keyword">if</span> (rlimit.rlim_max &lt; limit)
		rlimit.rlim_max = limit;

	<span class="enscript-keyword">if</span> (setrlimit(RLIMIT_NOFILE, &amp;rlimit) &lt; 0) {
		perror(<span class="enscript-string">&quot;setrlimit&quot;</span>);
		exit(3);
	}

	<span class="enscript-keyword">return</span> (0);
}


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KILOBYTE</span>		1024
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MEGABYTE</span>		(KILOBYTE * KILOBYTE)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GIGABYTE</span>		(KILOBYTE * MEGABYTE)

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">sizetoll</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *arg)
{
	<span class="enscript-type">int</span>			len = strlen(arg);
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		mult = 1;

	<span class="enscript-keyword">if</span> (len &amp;&amp; isalpha(arg[len - 1])) {
		<span class="enscript-keyword">switch</span> (arg[len - 1]) {

		<span class="enscript-keyword">case</span> <span class="enscript-string">'k'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'K'</span>:
			mult = KILOBYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'m'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'M'</span>:
			mult = MEGABYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'g'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'G'</span>:
			mult = GIGABYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; len - 1; i++)
			<span class="enscript-keyword">if</span> (!isdigit(arg[i]))
				<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (mult * strtoll(arg, NULL, 10));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sizetoint</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *arg)
{
	<span class="enscript-type">int</span>			len = strlen(arg);
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		mult = 1;

	<span class="enscript-keyword">if</span> (len &amp;&amp; isalpha(arg[len - 1])) {
		<span class="enscript-keyword">switch</span> (arg[len - 1]) {

		<span class="enscript-keyword">case</span> <span class="enscript-string">'k'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'K'</span>:
			mult = KILOBYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'m'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'M'</span>:
			mult = MEGABYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'g'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'G'</span>:
			mult = GIGABYTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; len - 1; i++)
			<span class="enscript-keyword">if</span> (!isdigit(arg[i]))
				<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (mult * atoi(arg));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_bar</span>(<span class="enscript-type">long</span> count, <span class="enscript-type">long</span> total)
{
	<span class="enscript-type">int</span>			i;

	(<span class="enscript-type">void</span>) putchar_unlocked(count ? <span class="enscript-string">'*'</span> : <span class="enscript-string">' '</span>);
	<span class="enscript-keyword">for</span> (i = 1; i &lt; (32 * count) / total; i++)
		(<span class="enscript-type">void</span>) putchar_unlocked(<span class="enscript-string">'*'</span>);
	<span class="enscript-keyword">for</span> (; i &lt; 32; i++)
		(<span class="enscript-type">void</span>) putchar_unlocked(<span class="enscript-string">' '</span>);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">doublecmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *p1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *p2)
{
	<span class="enscript-type">double</span> a = *((<span class="enscript-type">double</span> *)p1);
	<span class="enscript-type">double</span> b = *((<span class="enscript-type">double</span> *)p2);

	<span class="enscript-keyword">if</span> (a &gt; b)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (a &lt; b)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_histo</span>(barrier_t *b)
{
	<span class="enscript-type">int</span>			n;
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			j;
	<span class="enscript-type">int</span>			last;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		maxcount;
	<span class="enscript-type">double</span>			sum;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		min;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		scale;
	<span class="enscript-type">double</span>			x;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		y;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span>		count;
	<span class="enscript-type">int</span>			i95;
	<span class="enscript-type">double</span>			p95;
	<span class="enscript-type">double</span>			r95;
	<span class="enscript-type">double</span>			m95;
	histo_t			*histo;

	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#	%12s %12s %32s %12s\n&quot;</span>, <span class="enscript-string">&quot;counts&quot;</span>, <span class="enscript-string">&quot;usecs/call&quot;</span>,
	    <span class="enscript-string">&quot;&quot;</span>, <span class="enscript-string">&quot;means&quot;</span>);

	<span class="enscript-comment">/* calculate how much data we've captured */</span>
	n = b-&gt;ba_batches &gt; b-&gt;ba_datasize ? b-&gt;ba_datasize : b-&gt;ba_batches;

	<span class="enscript-comment">/* find the 95th percentile - index, value and range */</span>
	qsort((<span class="enscript-type">void</span> *)b-&gt;ba_data, n, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">double</span>), doublecmp);
	min = b-&gt;ba_data[0] + 0.000001;
	i95 = n * 95 / 100;
	p95 = b-&gt;ba_data[i95];
	r95 = p95 - min + 1;

	<span class="enscript-comment">/* find a suitable min and scale */</span>
	i = 0;
	x = r95 / (HISTOSIZE - 1);
	<span class="enscript-keyword">while</span> (x &gt;= 10.0) {
		x /= 10.0;
		i++;
	}
	y = x + 0.9999999999;
	<span class="enscript-keyword">while</span> (i &gt; 0) {
		y *= 10;
		i--;
	}
	min /= y;
	min *= y;
	scale = y * (HISTOSIZE - 1);
	<span class="enscript-keyword">if</span> (scale &lt; (HISTOSIZE - 1)) {
		scale = (HISTOSIZE - 1);
	}

	<span class="enscript-comment">/* create and initialise the histogram */</span>
	histo = malloc(HISTOSIZE * <span class="enscript-keyword">sizeof</span> (histo_t));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; HISTOSIZE; i++) {
		histo[i].sum = 0.0;
		histo[i].count = 0;
	}

	<span class="enscript-comment">/* populate the histogram */</span>
	last = 0;
	sum = 0.0;
	count = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; i95; i++) {
		j = (HISTOSIZE - 1) * (b-&gt;ba_data[i] - min) / scale;

		<span class="enscript-keyword">if</span> (j &gt;= HISTOSIZE) {
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;panic!\n&quot;</span>);
			j = HISTOSIZE - 1;
		}

		histo[j].sum += b-&gt;ba_data[i];
		histo[j].count++;

		sum += b-&gt;ba_data[i];
		count++;
	}
	m95 = sum / count;

	<span class="enscript-comment">/* find the larges bucket */</span>
	maxcount = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; HISTOSIZE; i++)
		<span class="enscript-keyword">if</span> (histo[i].count &gt; 0) {
			last = i;
			<span class="enscript-keyword">if</span> (histo[i].count &gt; maxcount)
				maxcount = histo[i].count;
		}

	<span class="enscript-comment">/* print the buckets */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= last; i++) {
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       %12lld %12.5f |&quot;</span>, histo[i].count,
		    (min + scale * (<span class="enscript-type">double</span>)i / (HISTOSIZE - 1)));

		print_bar(histo[i].count, maxcount);

		<span class="enscript-keyword">if</span> (histo[i].count &gt; 0)
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%12.5f\n&quot;</span>,
			    histo[i].sum / histo[i].count);
		<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%12s\n&quot;</span>, <span class="enscript-string">&quot;-&quot;</span>);
	}

	<span class="enscript-comment">/* find the mean of values beyond the 95th percentile */</span>
	sum = 0.0;
	count = 0;
	<span class="enscript-keyword">for</span> (i = i95; i &lt; n; i++) {
		sum += b-&gt;ba_data[i];
		count++;
	}

	<span class="enscript-comment">/* print the &gt;95% bucket summary */</span>
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n&quot;</span>);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       %12lld %12s |&quot;</span>, count, <span class="enscript-string">&quot;&gt; 95%&quot;</span>);
	print_bar(count, maxcount);
	<span class="enscript-keyword">if</span> (count &gt; 0)
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%12.5f\n&quot;</span>, sum / count);
	<span class="enscript-keyword">else</span>
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;%12s\n&quot;</span>, <span class="enscript-string">&quot;-&quot;</span>);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#\n&quot;</span>);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       %12s %12.5f\n&quot;</span>, <span class="enscript-string">&quot;mean of 95%&quot;</span>, m95);
	(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       %12s %12.5f\n&quot;</span>, <span class="enscript-string">&quot;95th %ile&quot;</span>, p95);

	<span class="enscript-comment">/* quantify any buffer overflow */</span>
	<span class="enscript-keyword">if</span> (b-&gt;ba_batches &gt; b-&gt;ba_datasize)
		(<span class="enscript-type">void</span>) printf(<span class="enscript-string">&quot;#       %12s %12d\n&quot;</span>, <span class="enscript-string">&quot;data dropped&quot;</span>,
		    b-&gt;ba_batches - b-&gt;ba_datasize);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">compute_stats</span>(barrier_t *b)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (b-&gt;ba_batches &gt; b-&gt;ba_datasize)
		b-&gt;ba_batches = b-&gt;ba_datasize;

	<span class="enscript-comment">/*
	 * convert to usecs/call
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; b-&gt;ba_batches; i++)
		b-&gt;ba_data[i] /= 1000.0;

	<span class="enscript-comment">/*
	 * do raw stats
	 */</span>

	(<span class="enscript-type">void</span>) crunch_stats(b-&gt;ba_data, b-&gt;ba_batches, &amp;b-&gt;ba_raw);

	<span class="enscript-comment">/*
	 * recursively apply 3 sigma rule to remove outliers
	 */</span>

	b-&gt;ba_corrected = b-&gt;ba_raw;
	b-&gt;ba_outliers = 0;

	<span class="enscript-keyword">if</span> (b-&gt;ba_batches &gt; 40) { <span class="enscript-comment">/* remove outliers */</span>
		<span class="enscript-type">int</span> removed;

		<span class="enscript-keyword">do</span> {
			removed = remove_outliers(b-&gt;ba_data, b-&gt;ba_batches,
			    &amp;b-&gt;ba_corrected);
			b-&gt;ba_outliers += removed;
			b-&gt;ba_batches -= removed;
			(<span class="enscript-type">void</span>) crunch_stats(b-&gt;ba_data, b-&gt;ba_batches,
			    &amp;b-&gt;ba_corrected);
			} <span class="enscript-keyword">while</span> (removed != 0 &amp;&amp; b-&gt;ba_batches &gt; 40);
	}

}

<span class="enscript-comment">/*
 * routine to compute various statistics on array of doubles.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">crunch_stats</span>(<span class="enscript-type">double</span> *data, <span class="enscript-type">int</span> count, stats_t *stats)
{
	<span class="enscript-type">double</span> a;
	<span class="enscript-type">double</span> std;
	<span class="enscript-type">double</span> diff;
	<span class="enscript-type">double</span> sk;
	<span class="enscript-type">double</span> ku;
	<span class="enscript-type">double</span> mean;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> bytes;
	<span class="enscript-type">double</span> *dupdata;

	<span class="enscript-comment">/*
	 * first we need the mean
	 */</span>

	mean = 0.0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		mean += data[i];
	}

	mean /= count;

	stats-&gt;st_mean = mean;

	<span class="enscript-comment">/*
	 * malloc and sort so we can do median
	 */</span>

	dupdata = malloc(bytes = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">double</span>) * count);
	(<span class="enscript-type">void</span>) memcpy(dupdata, data, bytes);
	qsort((<span class="enscript-type">void</span> *)dupdata, count, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">double</span>), doublecmp);
	stats-&gt;st_median   = dupdata[count/2];

	<span class="enscript-comment">/*
	 * reuse dupdata to compute time correlation of data to
	 * detect interesting time-based trends
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++)
		dupdata[i] = (<span class="enscript-type">double</span>)i;

	(<span class="enscript-type">void</span>) fit_line(dupdata, data, count, &amp;a, &amp;stats-&gt;st_timecorr);
	free(dupdata);

	std = 0.0;
	sk  = 0.0;
	ku  = 0.0;

	stats-&gt;st_max = -1;
	stats-&gt;st_min = 1.0e99; <span class="enscript-comment">/* hard to find portable values */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		<span class="enscript-keyword">if</span> (data[i] &gt; stats-&gt;st_max)
			stats-&gt;st_max = data[i];
		<span class="enscript-keyword">if</span> (data[i] &lt; stats-&gt;st_min)
			stats-&gt;st_min = data[i];

		diff = data[i] - mean;
		std += diff * diff;
		sk  += diff * diff * diff;
		ku  += diff * diff * diff * diff;
	}

	stats-&gt;st_stddev   = std = sqrt(std/(<span class="enscript-type">double</span>)(count - 1));
	stats-&gt;st_stderr   = std / sqrt(count);
	stats-&gt;st_99confidence = stats-&gt;st_stderr * 2.326;
	stats-&gt;st_skew	   = sk / (std * std * std) / (<span class="enscript-type">double</span>)(count);
	stats-&gt;st_kurtosis = ku / (std * std * std * std) /
	    (<span class="enscript-type">double</span>)(count) - 3;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * does a least squares fit to the set of points x, y and
 * fits a line y = a + bx.  Returns a, b
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">fit_line</span>(<span class="enscript-type">double</span> *x, <span class="enscript-type">double</span> *y, <span class="enscript-type">int</span> count, <span class="enscript-type">double</span> *a, <span class="enscript-type">double</span> *b)
{
	<span class="enscript-type">double</span> sumx, sumy, sumxy, sumx2;
	<span class="enscript-type">double</span> denom;
	<span class="enscript-type">int</span> i;

	sumx = sumy = sumxy = sumx2 = 0.0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		sumx	+= x[i];
		sumx2	+= x[i] * x[i];
		sumy	+= y[i];
		sumxy	+= x[i] * y[i];
	}

	denom = count * sumx2 - sumx * sumx;

	<span class="enscript-keyword">if</span> (denom == 0.0)
		<span class="enscript-keyword">return</span> (-1);

	*a = (sumy * sumx2 - sumx * sumxy) / denom;

	*b = (count * sumxy - sumx * sumy) / denom;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * empty function for measurement purposes
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nop</span>()
{
	<span class="enscript-keyword">return</span> (1);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NSECITER</span> 1000

<span class="enscript-type">static</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">get_nsecs_overhead</span>()
{
	<span class="enscript-type">long</span> <span class="enscript-type">long</span> s;

	<span class="enscript-type">double</span> data[NSECITER];
	stats_t stats;

	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> outliers;

	(<span class="enscript-type">void</span>) getnsecs(); <span class="enscript-comment">/* warmup */</span>
	(<span class="enscript-type">void</span>) getnsecs(); <span class="enscript-comment">/* warmup */</span>
	(<span class="enscript-type">void</span>) getnsecs(); <span class="enscript-comment">/* warmup */</span>

	i = 0;

	count = NSECITER;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		s = getnsecs();
		data[i] = getnsecs() - s;
	}

	(<span class="enscript-type">void</span>) crunch_stats(data, count, &amp;stats);

	<span class="enscript-keyword">while</span> ((outliers = remove_outliers(data, count, &amp;stats)) != 0) {
		count -= outliers;
		(<span class="enscript-type">void</span>) crunch_stats(data, count, &amp;stats);
	}

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)stats.st_mean);

}

<span class="enscript-type">long</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">get_nsecs_resolution</span>()
{
	<span class="enscript-type">long</span> <span class="enscript-type">long</span> y[1000];

	<span class="enscript-type">int</span> i, j, nops, res;
	<span class="enscript-type">long</span> <span class="enscript-type">long</span> start, stop;

	<span class="enscript-comment">/*
	 * first, figure out how many nops to use
	 * to get any delta between time measurements.
	 * use a minimum of one.
	 */</span>

	<span class="enscript-comment">/*
	 * warm cache
	 */</span>

	stop = start = getnsecs();

	<span class="enscript-keyword">for</span> (i = 1; i &lt; 10000000; i++) {
		start = getnsecs();
		<span class="enscript-keyword">for</span> (j = i; j; j--)
			;
		stop = getnsecs();
		<span class="enscript-keyword">if</span> (stop &gt; start)
			<span class="enscript-keyword">break</span>;
	}

	nops = i;

	<span class="enscript-comment">/*
	 * now collect data at linearly varying intervals
	 */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 1000; i++) {
		start = getnsecs();
		<span class="enscript-keyword">for</span> (j = nops * i; j; j--)
			;
		stop = getnsecs();
		y[i] = stop - start;
	}

	<span class="enscript-comment">/*
	 * find smallest positive difference between samples;
	 * this is the timer resolution
	 */</span>

	res = 1&lt;&lt;30;

	<span class="enscript-keyword">for</span> (i = 1; i &lt; 1000; i++) {
		<span class="enscript-type">int</span> diff = y[i] - y[i-1];

		<span class="enscript-keyword">if</span> (diff &gt; 0 &amp;&amp; res &gt; diff)
			res = diff;

	}

	<span class="enscript-keyword">return</span> (res);
}

<span class="enscript-comment">/*
 * remove any data points from the array more than 3 sigma out
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">remove_outliers</span>(<span class="enscript-type">double</span> *data, <span class="enscript-type">int</span> count, stats_t *stats)
{
	<span class="enscript-type">double</span> outmin = stats-&gt;st_mean - 3 * stats-&gt;st_stddev;
	<span class="enscript-type">double</span> outmax = stats-&gt;st_mean + 3 * stats-&gt;st_stddev;

	<span class="enscript-type">int</span> i, j, outliers;

	<span class="enscript-keyword">for</span> (outliers = i = j = 0; i &lt; count; i++)
		<span class="enscript-keyword">if</span> (data[i] &gt; outmax || data[i] &lt; outmin)
			outliers++;
		<span class="enscript-keyword">else</span>
			data[j++] = data[i];

	<span class="enscript-keyword">return</span> (outliers);
}
</pre>
<hr />
</body></html>