<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>testsp.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">testsp.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * This tests the Mac OS X Superpage API introduced in 10.7
 *
 * Note that most of these calls go through the mach_vm_allocate() interface,
 * but the actually supported and documented interface is the mmap() one
 * (see mmap(2)).
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;setjmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_SIZE</span> (2*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPERPAGE_MASK</span> (-SUPERPAGE_SIZE)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FIXED_ADDRESS1</span> (0x100000000ULL+500*1024*1024) <span class="enscript-comment">/* at 4 GB + 500 MB virtual */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FIXED_ADDRESS2</span> (0x100000000ULL+502*1024*1024 + 4*1024) <span class="enscript-comment">/* at 4 GB + 502 MB + 4 KB virtual */</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FIXED_ADDRESS1</span> (500*1024*1024) <span class="enscript-comment">/* at 500 MB virtual */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FIXED_ADDRESS2</span> (502*1024*1024 + 4*1024) <span class="enscript-comment">/* at 502 MB + 4 KB virtual */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">char</span> error[100];

jmp_buf resume;
<span class="enscript-type">void</span> <span class="enscript-function-name">test_signal_handler</span>(<span class="enscript-type">int</span> signo)
{       
	longjmp(resume, signo);
}

<span class="enscript-type">char</span> *signame[32] = {
	[SIGBUS] <span class="enscript-string">&quot;SIGBUS&quot;</span>,
	[SIGSEGV] <span class="enscript-string">&quot;SIGSEGV&quot;</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">char</span> *description;
	boolean_t (*fn)();
} test_t;

boolean_t
<span class="enscript-function-name">check_kr</span>(<span class="enscript-type">int</span> kr, <span class="enscript-type">char</span> *fn) {
	<span class="enscript-keyword">if</span> (kr) {
		sprintf(error, <span class="enscript-string">&quot;%s() returned %d&quot;</span>, fn, kr);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_addr0</span>(mach_vm_address_t addr, <span class="enscript-type">char</span> *fn) {
	<span class="enscript-keyword">if</span> (!addr) {
		sprintf(error, <span class="enscript-string">&quot;%s() returned address 0&quot;</span>, fn);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_addr</span>(mach_vm_address_t addr1, mach_vm_address_t addr2, <span class="enscript-type">char</span> *fn) {
	<span class="enscript-keyword">if</span> (addr1 != addr2) {
		sprintf(error, <span class="enscript-string">&quot;%s() returned address %llx instead of %llx&quot;</span>, fn, addr1, addr2);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_align</span>(mach_vm_address_t addr) {
	<span class="enscript-keyword">if</span> (addr &amp; !SUPERPAGE_MASK) {
		sprintf(error, <span class="enscript-string">&quot;address not aligned properly: 0x%llx&quot;</span>, addr);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_r</span>(mach_vm_address_t addr, mach_vm_size_t size, <span class="enscript-type">int</span> *res) {
	<span class="enscript-type">volatile</span> <span class="enscript-type">char</span> *data = (<span class="enscript-type">char</span>*)(uintptr_t)addr;
	<span class="enscript-type">int</span> i, sig, test;
	
	<span class="enscript-keyword">if</span> ((sig = setjmp(resume)) != 0) {
		sprintf(error, <span class="enscript-string">&quot;%s when reading&quot;</span>, signame[sig]);
		<span class="enscript-keyword">return</span> FALSE;
	}
	test = 0;
	<span class="enscript-keyword">for</span> (i=0; i&lt;size; i++)
		test += (data)[i];

	<span class="enscript-keyword">if</span> (res)
		*res = test;
	
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/* check that no subpage of the superpage is readable */</span>
boolean_t
<span class="enscript-function-name">check_nr</span>(mach_vm_address_t addr, mach_vm_size_t size, <span class="enscript-type">int</span> *res) {
	<span class="enscript-type">int</span> i;
	boolean_t ret;
	<span class="enscript-keyword">for</span> (i=0; i&lt;size/PAGE_SIZE; i++) {
		<span class="enscript-keyword">if</span> ((ret = check_r(addr+i*PAGE_SIZE, PAGE_SIZE, res))) {
			sprintf(error, <span class="enscript-string">&quot;page still readable&quot;</span>);
			<span class="enscript-keyword">return</span> FALSE;
		}
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_w</span>(mach_vm_address_t addr, mach_vm_size_t size) {
	<span class="enscript-type">char</span> *data = (<span class="enscript-type">char</span>*)(uintptr_t)addr;
	<span class="enscript-type">int</span> i, sig;

	<span class="enscript-keyword">if</span> ((sig = setjmp(resume)) != 0) {
		sprintf(error, <span class="enscript-string">&quot;%s when writing&quot;</span>, signame[sig]);
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">for</span> (i=0; i&lt;size; i++)
		(data)[i] = i &amp; 0xFF;

	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_nw</span>(mach_vm_address_t addr, mach_vm_size_t size) {
	<span class="enscript-type">int</span> i;
	boolean_t ret;

	<span class="enscript-keyword">for</span> (i=0; i&lt;size/PAGE_SIZE; i++) {
		<span class="enscript-keyword">if</span> ((ret = check_w(addr+i*PAGE_SIZE, PAGE_SIZE))) {
			sprintf(error, <span class="enscript-string">&quot;page still writable&quot;</span>);
			<span class="enscript-keyword">return</span> FALSE;
		}
	}
	<span class="enscript-keyword">return</span> TRUE;
}

boolean_t
<span class="enscript-function-name">check_rw</span>(mach_vm_address_t addr, mach_vm_size_t size) {
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">int</span> res;
	<span class="enscript-keyword">if</span> (!(ret = check_w(addr, size))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_r(addr, size, &amp;res))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> ((size==SUPERPAGE_SIZE) &amp;&amp; (res!=0xfff00000)) {
		sprintf(error, <span class="enscript-string">&quot;checksum error&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">return</span> TRUE;
}

mach_vm_address_t global_addr = 0;
mach_vm_size_t	global_size = 0;

<span class="enscript-comment">/*
 * If we allocate a 2 MB superpage read-write without specifying an address,
 * - the call should succeed
 * - not return 0
 * - return a 2 MB aligned address
 * - the memory should be readable and writable
 */</span>
boolean_t
<span class="enscript-function-name">test_allocate</span>() {
	<span class="enscript-type">int</span> kr, ret;

	global_addr = 0;
	global_size = SUPERPAGE_SIZE;
	
	kr = mach_vm_allocate(mach_task_self(), &amp;global_addr, global_size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_addr0(global_addr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_align(global_addr))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_rw(global_addr, global_size))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we deallocate a superpage,
 * - the call should succeed
 * - make the memory inaccessible
 */</span>
boolean_t
<span class="enscript-function-name">test_deallocate</span>() {
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	<span class="enscript-type">int</span> kr, ret;

	<span class="enscript-keyword">if</span> (!global_addr) {
		sprintf(error, <span class="enscript-string">&quot;skipped deallocation&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	kr = mach_vm_deallocate(mach_task_self(), global_addr, global_size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nr(global_addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we allocate a superpage of any size read-write without specifying an address
 * - the call should succeed
 * - not return 0
 * - the memory should be readable and writable
 * If we deallocate it,
 * - the call should succeed
 * - make the memory inaccessible
 */</span>
boolean_t
<span class="enscript-function-name">test_allocate_size_any</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = 2*PAGE_SIZE; <span class="enscript-comment">/* will be rounded up to some superpage size */</span>

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_ANY);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_addr0(addr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;
	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nr(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we allocate a 2 MB superpage read-write at a 2 MB aligned address,
 * - the call should succeed
 * - return the address we wished for
 * - the memory should be readable and writable
 * If we deallocate it,
 * - the call should succeed
 * - make the memory inaccessible
 */</span>
boolean_t
<span class="enscript-function-name">test_allocatefixed</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = FIXED_ADDRESS1;
	mach_vm_size_t	size = SUPERPAGE_SIZE;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_addr(addr, FIXED_ADDRESS1, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;
	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nr(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we allocate a 2 MB superpage read-write at an unaligned address,
 * - the call should fail
 */</span>
boolean_t
<span class="enscript-function-name">test_allocateunalignedfixed</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = FIXED_ADDRESS2;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	
	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-comment">/* is supposed to fail */</span>
	<span class="enscript-keyword">if</span> ((ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) {
		sprintf(error, <span class="enscript-string">&quot;mach_vm_allocate() should have failed&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we allocate an amount of memory not divisible by 2 MB as a 2 MB superpage
 * - the call should fail
 */</span>
boolean_t
<span class="enscript-function-name">test_allocateoddsize</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = FIXED_ADDRESS1;
	mach_vm_size_t	size = PAGE_SIZE; <span class="enscript-comment">/* != 2 MB */</span>

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-comment">/* is supposed to fail */</span>
	<span class="enscript-keyword">if</span> ((ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) {
		sprintf(error, <span class="enscript-string">&quot;mach_vm_allocate() should have failed&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we deallocate a sub-page of a superpage,
 * - the call should succeed
 * - make the complete memory inaccessible
 */</span>
boolean_t
<span class="enscript-function-name">test_deallocatesubpage</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	
	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	kr = mach_vm_deallocate(mach_task_self(), addr + PAGE_SIZE, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nr(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we try to allocate memory occupied by superpages as normal pages
 * - the call should fail
 */</span>
boolean_t
<span class="enscript-function-name">test_reallocate</span>() {
	mach_vm_address_t addr = 0, addr2;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	<span class="enscript-type">int</span> kr, ret;
	<span class="enscript-type">int</span> i;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-comment">/* attempt to allocate every sub-page of superpage */</span>
	<span class="enscript-keyword">for</span> (i=0; i&lt;SUPERPAGE_SIZE/PAGE_SIZE; i++) {
		addr2 = addr + i*PAGE_SIZE;
		size = PAGE_SIZE;
		kr = mach_vm_allocate(mach_task_self(), &amp;addr2, size, 0);
		<span class="enscript-keyword">if</span> ((ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) {
			sprintf(error, <span class="enscript-string">&quot;could allocate already allocated space, page %d&quot;</span>, i);
			mach_vm_deallocate(mach_task_self(), addr, size);
			<span class="enscript-keyword">return</span> FALSE;
		}
	}
	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we try to wire superpages
 * - the call should succeed
 * - the memory should remain readable and writable
 */</span>
boolean_t
<span class="enscript-function-name">test_wire</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_wire(mach_host_self(), mach_task_self(), addr, size, VM_PROT_WRITE | VM_PROT_READ);

	<span class="enscript-keyword">if</span> (!geteuid()) <span class="enscript-comment">/* may fail as user */</span>
		<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_wire&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we try to wire superpages
 * - the call should fail
 * - the memory should remain readable and writable
 * Currently, superpages are always wired.
 */</span>
boolean_t
<span class="enscript-function-name">test_unwire</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_wire(mach_host_self(), mach_task_self(), addr, size, VM_PROT_NONE);
	<span class="enscript-keyword">if</span> ((ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_wire&quot;</span>))) {
		sprintf(error, <span class="enscript-string">&quot;could unwire&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we try to write-protect superpages
 * - the call should succeed
 * - the memory should remain readable
 * - the memory should not be writable
 */</span>
boolean_t
<span class="enscript-function-name">test_readonly</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	mach_vm_protect(mach_task_self(), addr, size, 0, VM_PROT_READ);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_protect&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">if</span> (!(ret = check_r(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nw(addr, size))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we try to write-protect a sub-page of a superpage
 * - the call should succeed
 * - the complete memory should remain readable
 * - the complete memory should not be writable
 */</span>
boolean_t
<span class="enscript-function-name">test_readonlysubpage</span>() {
	<span class="enscript-type">int</span> kr;
	<span class="enscript-type">int</span> ret;
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;

	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	mach_vm_protect(mach_task_self(), addr+PAGE_SIZE, PAGE_SIZE, 0, VM_PROT_READ);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_protect&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">if</span> (!(ret = check_r(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nw(addr, size))) <span class="enscript-keyword">return</span> ret;

	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * If we fork with active superpages
 * - the parent should still be able to access the superpages
 * - the child should not be able to access the superpages
 */</span>
boolean_t
<span class="enscript-function-name">test_fork</span>() {
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	<span class="enscript-type">int</span> kr, ret;
	pid_t pid;
	
	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	fflush(stdout);
	<span class="enscript-keyword">if</span> ((pid=fork())) { <span class="enscript-comment">/* parent */</span>
		<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;
		waitpid(pid, &amp;ret, 0);
		<span class="enscript-keyword">if</span> (!ret) {
			sprintf(error, <span class="enscript-string">&quot;child could access superpage&quot;</span>);
			<span class="enscript-keyword">return</span> ret;
		}
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* child */</span>
		<span class="enscript-keyword">if</span> (!(ret = check_nr(addr, size, NULL))) exit(ret);
		exit(TRUE);
	}
	
	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * Doing file I/O with superpages
 * - should succeed
 * - should behave the same as with base pages (i.e. no bad data)
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FILENAME</span> <span class="enscript-string">&quot;/System/Library/Kernels/kernel&quot;</span>
boolean_t
<span class="enscript-function-name">test_fileio</span>() {
	mach_vm_address_t addr1 = 0;
	mach_vm_address_t addr2 = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	<span class="enscript-type">int</span> kr, ret;
	<span class="enscript-type">int</span> fd;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bytes;
	
	<span class="enscript-comment">/* allocate one superpage */</span>
	kr = mach_vm_allocate(mach_task_self(), &amp;addr1, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate (1)&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-comment">/* allocate base pages (superpage-sized) */</span>
	kr = mach_vm_allocate(mach_task_self(), &amp;addr2, size, VM_FLAGS_ANYWHERE);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate (2)&quot;</span>))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">if</span> ((fd = open(FILENAME, O_RDONLY))&lt;0) {
		sprintf(error, <span class="enscript-string">&quot;couldn't open %s&quot;</span>, FILENAME);
		<span class="enscript-keyword">return</span> FALSE;
	}
	fcntl(fd, F_NOCACHE, 1);
	<span class="enscript-comment">/* read kernel into superpage */</span>
	<span class="enscript-keyword">if</span> ((bytes = read(fd, (<span class="enscript-type">void</span>*)(uintptr_t)addr1, SUPERPAGE_SIZE)) &lt; SUPERPAGE_SIZE) {
		sprintf(error, <span class="enscript-string">&quot;short read (1)&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	lseek(fd, 0, SEEK_SET);
	<span class="enscript-comment">/* read kernel into base pages */</span>
	<span class="enscript-keyword">if</span> ((bytes = read(fd, (<span class="enscript-type">void</span>*)(uintptr_t)addr2, SUPERPAGE_SIZE)) &lt; SUPERPAGE_SIZE) {
		sprintf(error, <span class="enscript-string">&quot;short read (2)&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	close(fd);
	
	<span class="enscript-comment">/* compare */</span>
	<span class="enscript-keyword">if</span> (memcmp((<span class="enscript-type">void</span>*)(uintptr_t)addr1, (<span class="enscript-type">void</span>*)(uintptr_t)addr2, bytes)) {
		sprintf(error, <span class="enscript-string">&quot;read data corrupt&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}

	kr = mach_vm_deallocate(mach_task_self(), addr1, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate (1)&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	kr = mach_vm_deallocate(mach_task_self(), addr2, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate (2)&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * The mmap() interface should work just as well!
 */</span>
boolean_t
<span class="enscript-function-name">test_mmap</span>() {
	<span class="enscript-type">int</span> kr, ret;
	uintptr_t addr = 0;
	<span class="enscript-type">int</span> size = SUPERPAGE_SIZE;
	
	addr = (uintptr_t)mmap((<span class="enscript-type">void</span>*)addr, size, PROT_READ, MAP_ANON | MAP_PRIVATE, VM_FLAGS_SUPERPAGE_SIZE_2MB, 0);
	<span class="enscript-keyword">if</span> (addr == (uintptr_t)MAP_FAILED) {
		sprintf(error, <span class="enscript-string">&quot;mmap()&quot;</span>);
		<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">if</span> (!(ret = check_addr0(addr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_align(addr))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_r(addr, SUPERPAGE_SIZE, NULL))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nw(addr, SUPERPAGE_SIZE))) <span class="enscript-keyword">return</span> ret;
	kr = munmap((<span class="enscript-type">void</span>*)addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;munmap&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_nr(addr, size, NULL))) <span class="enscript-keyword">return</span> ret;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * Tests one allocation/deallocaton cycle; used in a loop this tests for leaks
 */</span>
boolean_t
<span class="enscript-function-name">test_alloc_dealloc</span>() {
	mach_vm_address_t addr = 0;
	mach_vm_size_t	size = SUPERPAGE_SIZE;
	<span class="enscript-type">int</span> kr, ret;
	
	kr = mach_vm_allocate(mach_task_self(), &amp;addr, size, VM_FLAGS_ANYWHERE | VM_FLAGS_SUPERPAGE_SIZE_2MB);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_addr0(addr, <span class="enscript-string">&quot;mach_vm_allocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_align(addr))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">if</span> (!(ret = check_rw(addr, size))) <span class="enscript-keyword">return</span> ret;
	kr = mach_vm_deallocate(mach_task_self(), addr, size);
	<span class="enscript-keyword">if</span> (!(ret = check_kr(kr, <span class="enscript-string">&quot;mach_vm_deallocate&quot;</span>))) <span class="enscript-keyword">return</span> ret;
	<span class="enscript-keyword">return</span> TRUE;
}

test_t test[] = {
	{ <span class="enscript-string">&quot;allocate one page anywhere&quot;</span>, test_allocate },
	{ <span class="enscript-string">&quot;deallocate a page&quot;</span>, test_deallocate },
	{ <span class="enscript-string">&quot;allocate a SIZE_ANY page anywhere&quot;</span>, test_allocate_size_any },
	{ <span class="enscript-string">&quot;allocate one page at a fixed address&quot;</span>, test_allocatefixed },
	{ <span class="enscript-string">&quot;allocate one page at an unaligned fixed address&quot;</span>, test_allocateunalignedfixed },
	{ <span class="enscript-string">&quot;deallocate sub-page&quot;</span>, test_deallocatesubpage },
	{ <span class="enscript-string">&quot;allocate already allocated subpage&quot;</span>, test_reallocate },
	{ <span class="enscript-string">&quot;wire a page&quot;</span>, test_wire },
	{ <span class="enscript-string">&quot;unwire a page&quot;</span>, test_unwire },
	{ <span class="enscript-string">&quot;make page readonly&quot;</span>, test_readonly },
	{ <span class="enscript-string">&quot;make sub-page readonly&quot;</span>, test_readonlysubpage },
	{ <span class="enscript-string">&quot;file I/O&quot;</span>, test_fileio },
	{ <span class="enscript-string">&quot;mmap()&quot;</span>, test_mmap },
	{ <span class="enscript-string">&quot;fork&quot;</span>, test_fork },
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TESTS</span> ((int)(sizeof(test)/sizeof(*test)))

boolean_t
<span class="enscript-function-name">testit</span>(<span class="enscript-type">int</span> i) {
	boolean_t ret;

	error[0] = 0;
	printf (<span class="enscript-string">&quot;Test #%d \&quot;%s\&quot;...&quot;</span>, i+1, test[i].description);
	ret = test[i].fn();
	<span class="enscript-keyword">if</span> (ret)
		printf (<span class="enscript-string">&quot;OK\n&quot;</span>);
	<span class="enscript-keyword">else</span> {
		printf (<span class="enscript-string">&quot;FAILED!&quot;</span>);
		<span class="enscript-keyword">if</span> (error[0])
			printf (<span class="enscript-string">&quot; (%s)\n&quot;</span>, error);
		<span class="enscript-keyword">else</span>
			printf (<span class="enscript-string">&quot;\n&quot;</span>);
	}
}

<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv) {
	<span class="enscript-type">int</span> i;
	uint64_t time1, time2;

	<span class="enscript-type">int</span> mode = 0;
	<span class="enscript-keyword">if</span> (argc&gt;1) {
		<span class="enscript-keyword">if</span> (!strcmp(argv[1], <span class="enscript-string">&quot;-h&quot;</span>)) {
			printf(<span class="enscript-string">&quot;Usage: %s &lt;mode&gt;\n&quot;</span>, argv[0]);
			printf(<span class="enscript-string">&quot;\tmode = 0:  test all cases\n&quot;</span>);
			printf(<span class="enscript-string">&quot;\tmode = -1: allocate/deallocate until failure\n&quot;</span>);
			printf(<span class="enscript-string">&quot;\tmode &gt; 0:  run test &lt;tmode&gt;\n&quot;</span>);
			exit(0);
		}
		mode=atoi(argv[1]);
	}
	
	<span class="enscript-comment">/* install SIGBUS handler */</span>
	<span class="enscript-type">struct</span> sigaction my_sigaction;
	my_sigaction.sa_handler = test_signal_handler;
	my_sigaction.sa_flags = SA_RESTART;
	my_sigaction.sa_mask = 0;
	sigaction( SIGBUS, &amp;my_sigaction, NULL );
	sigaction( SIGSEGV, &amp;my_sigaction, NULL );
	
	<span class="enscript-keyword">if</span> (mode&gt;0)		<span class="enscript-comment">/* one specific test */</span>
		testit(mode-1);

	<span class="enscript-keyword">if</span> (mode==0) {	<span class="enscript-comment">/* test all cases */</span>
		printf(<span class="enscript-string">&quot;Running %d tests:\n&quot;</span>, TESTS);
		<span class="enscript-keyword">for</span> (i=0; i&lt;TESTS; i++) {
			testit(i);
		}
	}
	<span class="enscript-keyword">if</span> (mode==-1) {	<span class="enscript-comment">/* alloc/dealloc */</span>
			boolean_t ret;
		<span class="enscript-keyword">do</span> {
			ret = test_alloc_dealloc(TRUE);
			printf(<span class="enscript-string">&quot;.&quot;</span>);
			fflush(stdout);
		} <span class="enscript-keyword">while</span> (ret);
		<span class="enscript-keyword">if</span> (error[0])
			printf (<span class="enscript-string">&quot; (%s)\n&quot;</span>, error);
	}
	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>