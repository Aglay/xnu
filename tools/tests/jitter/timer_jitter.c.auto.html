<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>timer_jitter.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">timer_jitter.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;math.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/wait.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ptrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;err.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> my_policy_type { MY_POLICY_REALTIME, MY_POLICY_TIMESHARE, MY_POLICY_FIXEDPRI } my_policy_type_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_MAX_SLEEP_NS</span>	2000000000ll <span class="enscript-comment">/* Two seconds */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONSTRAINT_NANOS</span>	(20000000ll)	<span class="enscript-comment">/* 20 ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPUTATION_NANOS</span>	(10000000ll)	<span class="enscript-comment">/* 10 ms */</span>

<span class="enscript-type">struct</span> mach_timebase_info g_mti;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">assert</span>(truth, label) do { if(!(truth)) { printf(<span class="enscript-string">&quot;Thread %p: failure on line %d\n&quot;</span>, pthread_self(), __LINE__); goto label; } } while (0)

<span class="enscript-type">struct</span> second_thread_args {
	semaphore_t wakeup_semaphore;
	semaphore_t return_semaphore;
	uint64_t iterations;
	my_policy_type_t pol;
	<span class="enscript-type">double</span> *wakeup_second_jitter_arr;
	uint64_t woke_on_same_cpu;
	uint64_t too_much;
	<span class="enscript-type">volatile</span> uint64_t last_poke_time;
	<span class="enscript-type">volatile</span> <span class="enscript-type">int</span> cpuno;
};

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cpu_number</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> *
<span class="enscript-function-name">second_thread</span>(<span class="enscript-type">void</span> *args);

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_usage</span>()
{
	printf(<span class="enscript-string">&quot;Usage: jitter [-w] [-s &lt;random seed&gt;] [-n &lt;min sleep, ns&gt;] [-m &lt;max sleep, ns&gt;] &lt;realtime | timeshare | fixed&gt; &lt;num iterations&gt; &lt;traceworthy jitter, ns&gt;\n&quot;</span>);
}

my_policy_type_t
<span class="enscript-function-name">parse_thread_policy</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
	<span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;timeshare&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_TIMESHARE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;realtime&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_REALTIME;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(str, <span class="enscript-string">&quot;fixed&quot;</span>) == 0) {
		<span class="enscript-keyword">return</span> MY_POLICY_FIXEDPRI;
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;Invalid thread policy %s\n&quot;</span>, str);
		exit(1);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">thread_setup</span>(my_policy_type_t pol)
{
	<span class="enscript-type">int</span> res;

	<span class="enscript-keyword">switch</span> (pol) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_TIMESHARE</span>:
		{
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_REALTIME</span>: 
		{
			thread_time_constraint_policy_data_t pol;

			<span class="enscript-comment">/* Hard-coded realtime parameters (similar to what Digi uses) */</span>
			pol.period = 100000;
			pol.constraint =  CONSTRAINT_NANOS * g_mti.denom / g_mti.numer;
			pol.computation = COMPUTATION_NANOS * g_mti.denom / g_mti.numer;
			pol.preemptible = 0; <span class="enscript-comment">/* Ignored by OS */</span>

			res = thread_policy_set(mach_thread_self(), THREAD_TIME_CONSTRAINT_POLICY, (thread_policy_t) &amp;pol, THREAD_TIME_CONSTRAINT_POLICY_COUNT);
			assert(res == 0, fail);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MY_POLICY_FIXEDPRI</span>: 
		{
			thread_extended_policy_data_t pol;
			pol.timeshare = 0;

			res = thread_policy_set(mach_thread_self(), THREAD_EXTENDED_POLICY, (thread_policy_t) &amp;pol, THREAD_EXTENDED_POLICY_COUNT);
			assert(res == 0, fail);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
		{
			printf(<span class="enscript-string">&quot;invalid policy type\n&quot;</span>);
			<span class="enscript-keyword">return</span> 1;
		}
	}

	<span class="enscript-keyword">return</span> 0;
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> 1;
}

uint64_t 
<span class="enscript-function-name">get_random_sleep_length_abs_ns</span>(uint64_t min_sleep_ns, uint64_t max_sleep_ns)
{
	uint64_t tmp;

	tmp = (uint32_t)random();
	tmp &lt;&lt;= 32;
	tmp |= (uint32_t)random();

	<span class="enscript-comment">/* Now use the random number to sleep amount within the window */</span>
	tmp %= (max_sleep_ns - min_sleep_ns);

	<span class="enscript-keyword">return</span> min_sleep_ns + tmp;
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">compute_stats</span>(<span class="enscript-type">double</span> *values, uint64_t count, <span class="enscript-type">double</span> *average_magnitudep, <span class="enscript-type">double</span> *maxp, <span class="enscript-type">double</span> *minp, <span class="enscript-type">double</span> *stddevp)
{
	uint64_t i;
	<span class="enscript-type">double</span> _sum = 0;
	<span class="enscript-type">double</span> _max = 0;
	<span class="enscript-type">double</span> _min = (<span class="enscript-type">double</span>)INT64_MAX;
	<span class="enscript-type">double</span> _avg = 0;
	<span class="enscript-type">double</span> _dev = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		_sum += fabs(values[i]);
		_max = values[i] &gt; _max ? values[i] : _max;
		_min = values[i] &lt; _min ? values[i] : _min;
	}

	_avg = _sum / (<span class="enscript-type">double</span>)count;
	
	_dev = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		_dev += pow((values[i] - _avg), 2);
	}
	
	_dev /= count;
	_dev = sqrt(_dev);

	*average_magnitudep = _avg;
	*maxp = _max;
	*minp = _min;
	*stddevp = _dev;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_stats_us</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *label, <span class="enscript-type">double</span> avg, <span class="enscript-type">double</span> max, <span class="enscript-type">double</span> min, <span class="enscript-type">double</span> stddev)
{
	printf(<span class="enscript-string">&quot;Max %s: %.1lfus\n&quot;</span>, label, max / 1000.0 * (((<span class="enscript-type">double</span>)g_mti.numer) / ((<span class="enscript-type">double</span>)g_mti.denom)));
	printf(<span class="enscript-string">&quot;Min %s: %.1lfus\n&quot;</span>, label, min / 1000.0 * (((<span class="enscript-type">double</span>)g_mti.numer) / ((<span class="enscript-type">double</span>)g_mti.denom)));
	printf(<span class="enscript-string">&quot;Avg magnitude of %s: %.1lfus\n&quot;</span>, label, avg / 1000.0 * (((<span class="enscript-type">double</span>)g_mti.numer) / ((<span class="enscript-type">double</span>)g_mti.denom)));
	printf(<span class="enscript-string">&quot;Stddev: %.1lfus\n&quot;</span>, stddev / 1000.0 * (((<span class="enscript-type">double</span>)g_mti.numer) / ((<span class="enscript-type">double</span>)g_mti.denom)));
	putchar(<span class="enscript-string">'\n'</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_stats_fract</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *label, <span class="enscript-type">double</span> avg, <span class="enscript-type">double</span> max, <span class="enscript-type">double</span> min, <span class="enscript-type">double</span> stddev)
{
	printf(<span class="enscript-string">&quot;Max %s jitter: %.1lf%%\n&quot;</span>, label, max * 100);
	printf(<span class="enscript-string">&quot;Min %s jitter: %.1lf%%\n&quot;</span>, label, min * 100);
	printf(<span class="enscript-string">&quot;Avg %s jitter: %.1lf%%\n&quot;</span>, label, avg * 100);
	printf(<span class="enscript-string">&quot;Stddev: %.1lf%%\n&quot;</span>, stddev * 100);
	putchar(<span class="enscript-string">'\n'</span>);	
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
	uint64_t iterations, i;
	<span class="enscript-type">double</span> *jitter_arr, *fraction_arr;
	<span class="enscript-type">double</span> *wakeup_second_jitter_arr;
	uint64_t target_time;
	uint64_t sleep_length_abs;
	uint64_t min_sleep_ns = 0;
	uint64_t max_sleep_ns = DEFAULT_MAX_SLEEP_NS;
	uint64_t wake_time;
	<span class="enscript-type">unsigned</span> random_seed;
	boolean_t need_seed = TRUE;
	<span class="enscript-type">char</span> ch;
	<span class="enscript-type">int</span> res;
	kern_return_t kret;
	my_policy_type_t pol;
	boolean_t wakeup_second_thread = FALSE;
	semaphore_t wakeup_semaphore, return_semaphore;

	<span class="enscript-type">double</span> avg, stddev, max, min;
	<span class="enscript-type">double</span> avg_fract, stddev_fract, max_fract, min_fract;
	uint64_t too_much;

	<span class="enscript-type">struct</span> second_thread_args secargs;
	pthread_t secthread;

	mach_timebase_info(&amp;g_mti);

	<span class="enscript-comment">/* Seed random */</span>
	opterr = 0;
	<span class="enscript-keyword">while</span> ((ch = getopt(argc, argv, <span class="enscript-string">&quot;m:n:hs:w&quot;</span>)) != -1 &amp;&amp; ch != <span class="enscript-string">'?'</span>) {
		<span class="enscript-keyword">switch</span> (ch) {
			<span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
				<span class="enscript-comment">/* Specified seed for random)() */</span>
				random_seed = (<span class="enscript-type">unsigned</span>)atoi(optarg);
				srandom(random_seed);
				need_seed = FALSE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-string">'m'</span>:
				<span class="enscript-comment">/* How long per timer? */</span>
				max_sleep_ns = strtoull(optarg, NULL, 10);	
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
				<span class="enscript-comment">/* How long per timer? */</span>
				min_sleep_ns = strtoull(optarg, NULL, 10);	
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-string">'w'</span>:
				<span class="enscript-comment">/* After each timed wait, wakeup another thread */</span>
				wakeup_second_thread = TRUE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>:
				print_usage();
				exit(0);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				fprintf(stderr, <span class="enscript-string">&quot;Got unexpected result from getopt().\n&quot;</span>);
				exit(1);
				<span class="enscript-keyword">break</span>;
		}
	}

	argc -= optind;
	argv += optind;

	<span class="enscript-keyword">if</span> (argc != 3) {
		print_usage();
		exit(1);
	}

	<span class="enscript-keyword">if</span> (min_sleep_ns &gt;= max_sleep_ns) {
		print_usage();
		exit(1);
	}

	<span class="enscript-keyword">if</span> (need_seed) {
		srandom(time(NULL));
	}

	<span class="enscript-comment">/* What scheduling policy? */</span>
	pol = parse_thread_policy(argv[0]);

	<span class="enscript-comment">/* How many timers? */</span>
	iterations = strtoull(argv[1], NULL, 10);

	<span class="enscript-comment">/* How much jitter is so extreme that we should cut a trace point */</span>
	too_much = strtoull(argv[2], NULL, 10);
	
	<span class="enscript-comment">/* Array for data */</span>
	jitter_arr = (<span class="enscript-type">double</span>*)malloc(<span class="enscript-keyword">sizeof</span>(*jitter_arr) * iterations);
	<span class="enscript-keyword">if</span> (jitter_arr == NULL) {
		printf(<span class="enscript-string">&quot;Couldn't allocate array to store results.\n&quot;</span>);
		exit(1);
	}

	fraction_arr = (<span class="enscript-type">double</span>*)malloc(<span class="enscript-keyword">sizeof</span>(*fraction_arr) * iterations);
	<span class="enscript-keyword">if</span> (fraction_arr == NULL) {
		printf(<span class="enscript-string">&quot;Couldn't allocate array to store results.\n&quot;</span>);
		exit(1);
	}

	<span class="enscript-keyword">if</span> (wakeup_second_thread) {
		<span class="enscript-comment">/* Array for data */</span>
		wakeup_second_jitter_arr = (<span class="enscript-type">double</span>*)malloc(<span class="enscript-keyword">sizeof</span>(*jitter_arr) * iterations);
		<span class="enscript-keyword">if</span> (wakeup_second_jitter_arr == NULL) {
			printf(<span class="enscript-string">&quot;Couldn't allocate array to store results.\n&quot;</span>);
			exit(1);
		}

		kret = semaphore_create(mach_task_self(), &amp;wakeup_semaphore, SYNC_POLICY_FIFO, 0);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			printf(<span class="enscript-string">&quot;Couldn't allocate semaphore %d\n&quot;</span>, kret);
			exit(1);
		}

		kret = semaphore_create(mach_task_self(), &amp;return_semaphore, SYNC_POLICY_FIFO, 0);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			printf(<span class="enscript-string">&quot;Couldn't allocate semaphore %d\n&quot;</span>, kret);
			exit(1);
		}


		secargs.wakeup_semaphore = wakeup_semaphore;
		secargs.return_semaphore = return_semaphore;
		secargs.iterations = iterations;
		secargs.pol = pol;
		secargs.wakeup_second_jitter_arr = wakeup_second_jitter_arr;
		secargs.woke_on_same_cpu = 0;
		secargs.too_much = too_much;
		secargs.last_poke_time = 0ULL;
		secargs.cpuno = 0;

		res = pthread_create(&amp;secthread, NULL, second_thread, &amp;secargs);
		<span class="enscript-keyword">if</span> (res) {
			err(1, <span class="enscript-string">&quot;pthread_create&quot;</span>);
		}

		sleep(1); <span class="enscript-comment">/* Time for other thread to start up */</span>
	}

	<span class="enscript-comment">/* Set scheduling policy */</span>
	res = thread_setup(pol);
	<span class="enscript-keyword">if</span> (res != 0) {
		printf(<span class="enscript-string">&quot;Couldn't set thread policy.\n&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* 
	 * Repeatedly pick a random timer length and 
	 * try to sleep exactly that long 
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; iterations; i++) {
		sleep_length_abs = (uint64_t) (get_random_sleep_length_abs_ns(min_sleep_ns, max_sleep_ns) * (((<span class="enscript-type">double</span>)g_mti.denom) / ((<span class="enscript-type">double</span>)g_mti.numer)));
		target_time = mach_absolute_time() + sleep_length_abs;
		
		<span class="enscript-comment">/* Sleep */</span>
		kret = mach_wait_until(target_time);
		wake_time = mach_absolute_time();
	
		jitter_arr[i] = (<span class="enscript-type">double</span>)(wake_time - target_time);
		fraction_arr[i] = jitter_arr[i] / ((<span class="enscript-type">double</span>)sleep_length_abs);
		
		<span class="enscript-comment">/* Too much: cut a tracepoint for a debugger */</span>
		<span class="enscript-keyword">if</span> (jitter_arr[i] &gt;= too_much) {
			kdebug_trace(0xeeeee0 | DBG_FUNC_NONE, 0, 0, 0, 0);
		}

		<span class="enscript-keyword">if</span> (wakeup_second_thread) {
			secargs.last_poke_time = mach_absolute_time();
			secargs.cpuno = cpu_number();
			OSMemoryBarrier();
			kret = semaphore_signal(wakeup_semaphore);
			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
				errx(1, <span class="enscript-string">&quot;semaphore_signal&quot;</span>);
			}

			kret = semaphore_wait(return_semaphore);
			<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
				errx(1, <span class="enscript-string">&quot;semaphore_wait&quot;</span>);
			}

		}
	}

	<span class="enscript-comment">/*
	 * Compute statistics and output results. 
	 */</span>
	compute_stats(jitter_arr, iterations, &amp;avg, &amp;max, &amp;min, &amp;stddev);
	compute_stats(fraction_arr, iterations, &amp;avg_fract, &amp;max_fract, &amp;min_fract, &amp;stddev_fract);

	putchar(<span class="enscript-string">'\n'</span>);
	print_stats_us(<span class="enscript-string">&quot;jitter&quot;</span>, avg, max, min, stddev);
	print_stats_fract(<span class="enscript-string">&quot;%&quot;</span>, avg_fract, max_fract, min_fract, stddev_fract);

	<span class="enscript-keyword">if</span> (wakeup_second_thread) {

		res = pthread_join(secthread, NULL);
		<span class="enscript-keyword">if</span> (res) {
			err(1, <span class="enscript-string">&quot;pthread_join&quot;</span>);
		}

		compute_stats(wakeup_second_jitter_arr, iterations, &amp;avg, &amp;max, &amp;min, &amp;stddev);
		
		putchar(<span class="enscript-string">'\n'</span>);
		print_stats_us(<span class="enscript-string">&quot;second jitter&quot;</span>, avg, max, min, stddev);

		putchar(<span class="enscript-string">'\n'</span>);
		printf(<span class="enscript-string">&quot;%llu/%llu (%.1f%%) wakeups on same CPU\n&quot;</span>, secargs.woke_on_same_cpu, iterations,
			   100.0*((<span class="enscript-type">double</span>)secargs.woke_on_same_cpu)/iterations);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">second_thread</span>(<span class="enscript-type">void</span> *args)
{
	<span class="enscript-type">struct</span> second_thread_args *secargs = (<span class="enscript-type">struct</span> second_thread_args *)args;
	<span class="enscript-type">int</span> res;
	uint64_t i;
	kern_return_t kret;
	uint64_t wake_time;
	<span class="enscript-type">int</span> cpuno;

	<span class="enscript-comment">/* Set scheduling policy */</span>
	res = thread_setup(secargs-&gt;pol);
	<span class="enscript-keyword">if</span> (res != 0) {
		printf(<span class="enscript-string">&quot;Couldn't set thread policy.\n&quot;</span>);
		exit(1);
	}

	<span class="enscript-comment">/* 
	 * Repeatedly pick a random timer length and 
	 * try to sleep exactly that long 
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; secargs-&gt;iterations; i++) {

		<span class="enscript-comment">/* Wake up when poked by main thread */</span>
		kret = semaphore_wait(secargs-&gt;wakeup_semaphore);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			errx(1, <span class="enscript-string">&quot;semaphore_wait %d&quot;</span>, kret);
		}

		wake_time = mach_absolute_time();
		cpuno = cpu_number();
		<span class="enscript-keyword">if</span> (wake_time &lt; secargs-&gt;last_poke_time) {
			<span class="enscript-comment">/* Woke in past, unsynchronized mach_absolute_time()? */</span>
			
			errx(1, <span class="enscript-string">&quot;woke in past %llu (%d) &lt; %llu (%d)&quot;</span>, wake_time, cpuno, secargs-&gt;last_poke_time, secargs-&gt;cpuno);
		}

		<span class="enscript-keyword">if</span> (cpuno == secargs-&gt;cpuno) {
			secargs-&gt;woke_on_same_cpu++;
		}

		secargs-&gt;wakeup_second_jitter_arr[i] = (<span class="enscript-type">double</span>)(wake_time - secargs-&gt;last_poke_time);
		
		<span class="enscript-comment">/* Too much: cut a tracepoint for a debugger */</span>
		<span class="enscript-keyword">if</span> (secargs-&gt;wakeup_second_jitter_arr[i] &gt;= secargs-&gt;too_much) {
			kdebug_trace(0xeeeee4 | DBG_FUNC_NONE, 0, 0, 0, 0);
		}

		kret = semaphore_signal(secargs-&gt;return_semaphore);
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			errx(1, <span class="enscript-string">&quot;semaphore_signal %d&quot;</span>, kret);
		}

	}

	<span class="enscript-keyword">return</span> NULL;
}
</pre>
<hr />
</body></html>