<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ioreg.py</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ioreg.py&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-keyword">from</span> xnu <span class="enscript-keyword">import</span> *
<span class="enscript-keyword">from</span> utils <span class="enscript-keyword">import</span> *
<span class="enscript-keyword">import</span> sys

<span class="enscript-comment">######################################
</span><span class="enscript-comment"># Globals
</span><span class="enscript-comment">######################################
</span>plane = None

<span class="enscript-comment">#####################################
</span><span class="enscript-comment"># Utility functions.
</span><span class="enscript-comment">#####################################
</span><span class="enscript-keyword">def</span> <span class="enscript-function-name">CastIOKitClass</span>(obj, target_type):
    <span class="enscript-string">&quot;&quot;&quot; Type cast an object to another IOKIT CPP class.
        params:
            obj - core.value  object representing some C construct in lldb
            target_type - str : ex 'OSString *'
                        - lldb.SBType :
    &quot;&quot;&quot;</span>
    v = Cast(obj, target_type)
    v.GetSBValue().SetPreferDynamicValue(lldb.eNoDynamicValues)
    <span class="enscript-keyword">return</span> v

<span class="enscript-comment">######################################
</span><span class="enscript-comment"># Type Summaries
</span><span class="enscript-comment">######################################
</span>@lldb_type_summary([<span class="enscript-string">'OSObject *'</span>])
@header(<span class="enscript-string">&quot;&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetObjectSummary</span>(obj):
    <span class="enscript-string">&quot;&quot;&quot; Show info about an OSObject - its vtable ptr and retain count, &amp; more info for simple container classes.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> obj <span class="enscript-keyword">is</span> None:
        <span class="enscript-keyword">return</span>

    vt = dereference(Cast(obj, <span class="enscript-string">'uintptr_t *'</span>)) - 2 * sizeof(<span class="enscript-string">'uintptr_t'</span>)
    vtype = kern.SymbolicateFromAddress(vt)
    <span class="enscript-keyword">if</span> hasattr(obj, <span class="enscript-string">'retainCount'</span>):
        retCount = (obj.retainCount &amp; 0xffff)
        cntnrRetCount = (retCount &gt;&gt; 16)
        out_string = <span class="enscript-string">&quot;`object 0x{0: &lt;16x}, vt 0x{1: &lt;16x} &lt;{2:s}&gt;, retain count {3:d}, container retain {4:d}` &quot;</span>.format(obj, vt, vtype[0].GetName(), retCount, cntnrRetCount)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">if</span> len(vtype):
            out_string = <span class="enscript-string">&quot;`object 0x{0: &lt;16x}, vt 0x{1: &lt;16x} &lt;{2:s}&gt;` &quot;</span>.format(obj, vt, vtype[0].GetName())
        <span class="enscript-keyword">else</span>:
            out_string = <span class="enscript-string">&quot;`object 0x{0: &lt;16x}, vt 0x{1: &lt;16x}` &quot;</span>.format(obj, vt)
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV8OSString'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetString(obj)
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV8OSSymbol'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetString(obj)
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV8OSNumber'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetNumber(obj)
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV9OSBoolean'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetBoolean(obj)
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV7OSArray'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += <span class="enscript-string">&quot;(&quot;</span> + GetArray(CastIOKitClass(obj, <span class="enscript-string">'OSArray *'</span>)) + <span class="enscript-string">&quot;)&quot;</span>
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV5OSSet'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetSet(CastIOKitClass(obj, <span class="enscript-string">'OSSet *'</span>))
        <span class="enscript-keyword">return</span> out_string
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV12OSDictionary'</span>)
    <span class="enscript-keyword">if</span> vt == ztvAddr:
        out_string += GetDictionary(CastIOKitClass(obj, <span class="enscript-string">'OSDictionary *'</span>))
        <span class="enscript-keyword">return</span> out_string
    
    <span class="enscript-keyword">return</span> out_string

@lldb_type_summary([<span class="enscript-string">'IORegistryEntry *'</span>])
@header(<span class="enscript-string">&quot;&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetRegistryEntrySummary</span>(entry):
    <span class="enscript-string">&quot;&quot;&quot; returns a string containing summary information about an IORegistry
        object including it's registry id , vtable ptr and retain count
    &quot;&quot;&quot;</span>
    name = None
    out_string = <span class="enscript-string">&quot;&quot;</span>
    registryTable = entry.fRegistryTable
    propertyTable = entry.fPropertyTable
    
    name = LookupKeyInOSDict(registryTable, kern.globals.gIOServicePlane.nameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(registryTable, kern.globals.gIONameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(propertyTable, kern.globals.gIOClassKey)
    
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        out_string += <span class="enscript-string">&quot;+-o {0:s}  &quot;</span>.format(GetString(CastIOKitClass(name, <span class="enscript-string">'OSString *'</span>)))
    <span class="enscript-keyword">elif</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt <span class="enscript-keyword">and</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name:
        out_string += <span class="enscript-string">&quot;+-o {0:s}  &quot;</span>.format(CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name)
    <span class="enscript-keyword">else</span>:
        out_string += <span class="enscript-string">&quot;+-o ??  &quot;</span>
    
    <span class="enscript-comment"># I'm using uintptr_t for now to work around &lt;rdar://problem/12749733&gt; FindFirstType &amp; Co. should allow you to make pointer types directly
</span>    vtableAddr = dereference(Cast(entry, <span class="enscript-string">'uintptr_t *'</span>)) - 2 * sizeof(<span class="enscript-string">'uintptr_t *'</span>)
    vtype = kern.SymbolicateFromAddress(vtableAddr)
    <span class="enscript-keyword">if</span> vtype <span class="enscript-keyword">is</span> None <span class="enscript-keyword">or</span> len(vtype) &lt; 1:
        out_string += <span class="enscript-string">&quot;&lt;object 0x{0: &lt;16x}, id 0x{1:x}, vtable 0x{2: &lt;16x}&quot;</span>.format(entry, entry.reserved.fRegistryEntryID, vtableAddr)
    <span class="enscript-keyword">else</span>:
        out_string += <span class="enscript-string">&quot;&lt;object 0x{0: &lt;16x}, id 0x{1:x}, vtable 0x{2: &lt;16x} &lt;{3:s}&gt;&quot;</span>.format(entry, entry.reserved.fRegistryEntryID, vtableAddr, vtype[0].GetName())
    
    ztvAddr = kern.GetLoadAddressForSymbol(<span class="enscript-string">'_ZTV15IORegistryEntry'</span>)
    <span class="enscript-keyword">if</span> vtableAddr != ztvAddr:
        out_string += <span class="enscript-string">&quot;, &quot;</span>
        state = CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).__state[0]
        <span class="enscript-comment"># kIOServiceRegisteredState
</span>        <span class="enscript-keyword">if</span> 0 == state &amp; 2:
            out_string += <span class="enscript-string">&quot;!&quot;</span>
        out_string += <span class="enscript-string">&quot;registered, &quot;</span>
        <span class="enscript-comment"># kIOServiceMatchedState
</span>        <span class="enscript-keyword">if</span> 0 == state &amp; 4:
            out_string += <span class="enscript-string">&quot;!&quot;</span>
        out_string += <span class="enscript-string">&quot;matched, &quot;</span>
        <span class="enscript-comment">#kIOServiceInactiveState
</span>        <span class="enscript-keyword">if</span> 0 != state &amp; 1:
            out_string += <span class="enscript-string">&quot;in&quot;</span>
        busyCount = (CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).__state[1] &amp; 0xff)
        retCount = (CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).retainCount &amp; 0xffff)
        out_string += <span class="enscript-string">&quot;active, busy {0}, retain count {1}&gt;&quot;</span>.format(busyCount, retCount)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-comment">######################################
</span><span class="enscript-comment"># Commands
</span><span class="enscript-comment">######################################
</span>@lldb_command(<span class="enscript-string">'showallclasses'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllClasses</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show the instance counts and ivar size of all OSObject subclasses.
        See ioclasscount man page for details
    &quot;&quot;&quot;</span>
    idx = 0
    count = unsigned(kern.globals.sAllClassesDict.count)
    
    <span class="enscript-keyword">while</span> idx &lt; count:
        meta = CastIOKitClass(kern.globals.sAllClassesDict.dictionary[idx].value, <span class="enscript-string">'OSMetaClass *'</span>)
        idx += 1
        <span class="enscript-keyword">print</span> GetMetaClass(meta)

@lldb_command(<span class="enscript-string">'showobject'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowObject</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show info about an OSObject - its vtable ptr and retain count, &amp; more info for simple container classes.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the address of the OSObject whose info you want to view. Type help showobject for help&quot;</span>
        <span class="enscript-keyword">return</span>
    
    obj = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'OSObject *'</span>)
    <span class="enscript-keyword">print</span> GetObjectSummary(obj)

@lldb_command(<span class="enscript-string">'setregistryplane'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">SetRegistryPlane</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Set the plane to be used for the IOKit registry macros
        syntax: (lldb) setregistryplane 0  - will display all known planes
        syntax: (lldb) setregistryplane 0xaddr      - will set the registry plane to 0xaddr
        syntax: (lldb) setregistryplane gIODTPlane  - will set the registry plane to gIODTPlane
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the name of the plane you want to use with the IOKit registry macros.&quot;</span>
        <span class="enscript-keyword">print</span> SetRegistryPlane.__doc__
    
    <span class="enscript-keyword">if</span> cmd_args[0] == <span class="enscript-string">&quot;0&quot;</span>:
        <span class="enscript-keyword">print</span> GetObjectSummary(kern.globals.gIORegistryPlanes)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">global</span> plane
        plane = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'IORegistryPlane *'</span>)
    <span class="enscript-keyword">return</span>

@lldb_command(<span class="enscript-string">'showregistryentry'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowRegistryEntry</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show info about a registry entry; its properties and descendants in the current plane
        syntax: (lldb) showregistryentry 0xaddr
        syntax: (lldb) showregistryentry gIOPMRootDomain
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the address of the registry entry whose info you want to view.&quot;</span>
        <span class="enscript-keyword">print</span> ShowRegistryEntry.__doc__
        <span class="enscript-keyword">return</span>
    
    entry = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'IORegistryEntry *'</span>)
    ShowRegistryEntryRecurse(entry, <span class="enscript-string">&quot;&quot;</span>, True)

@lldb_command(<span class="enscript-string">'showregistry'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowRegistry</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show info about all registry entries in the current plane
        If prior to invoking this command no registry plane is specified
        using 'setregistryplane', the command defaults to the IOService plane
    &quot;&quot;&quot;</span>
    ShowRegistryEntryRecurse(kern.globals.gRegistryRoot, <span class="enscript-string">&quot;&quot;</span>, False)

@lldb_command(<span class="enscript-string">'showregistryprops'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowRegistryProps</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show info about all registry entries in the current plane, and their properties
        If prior to invoking this command no registry plane is specified
        using 'setregistryplane', the command defaults to the IOService plane
    &quot;&quot;&quot;</span>
    ShowRegistryEntryRecurse(kern.globals.gRegistryRoot, <span class="enscript-string">&quot;&quot;</span>, True)

@lldb_command(<span class="enscript-string">'findregistryentry'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindRegistryEntry</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Search for registry entry that matches the given string
        If prior to invoking this command no registry plane is specified
        using 'setregistryplane', the command defaults to searching entries from the IOService plane
        syntax: (lldb) findregistryentries AppleACPICPU - will find the first registry entry that matches AppleACPICPU
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the name of the registry entry you want to find&quot;</span>
        <span class="enscript-keyword">print</span> FindRegistryEntry.__doc__
        <span class="enscript-keyword">return</span>
    
    FindRegistryEntryRecurse(kern.globals.gRegistryRoot, cmd_args[0], True)

@lldb_command(<span class="enscript-string">'findregistryentries'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindRegistryEntries</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Search for all registry entries that match the given string
        If prior to invoking this command no registry plane is specified
        using 'setregistryplane', the command defaults to searching entries from the IOService plane
        syntax: (lldb) findregistryentries AppleACPICPU - will find all registry entries that match AppleACPICPU
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the name of the registry entry/entries you want to find&quot;</span>
        <span class="enscript-keyword">print</span> FindRegistryEntries.__doc__
        <span class="enscript-keyword">return</span>
    
    FindRegistryEntryRecurse(kern.globals.gRegistryRoot, cmd_args[0], False)

@lldb_command(<span class="enscript-string">'findregistryprop'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindRegistryProp</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Given a registry entry, print out the contents for the property that matches
        a specific string
        syntax: (lldb) findregistryprop 0xaddr IOSleepSupported
        syntax: (lldb) findregistryprop gIOPMRootDomain IOSleepSupported
        syntax: (lldb) findregistryprop gIOPMRootDomain &quot;Supported Features&quot;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify the address of a IORegistry entry and the property you're looking for&quot;</span>
        <span class="enscript-keyword">print</span> FindRegistryProp.__doc__
        <span class="enscript-keyword">return</span>
    
    entry = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'IOService *'</span>)
    propertyTable = entry.fPropertyTable
    <span class="enscript-keyword">print</span> GetObjectSummary(LookupKeyInPropTable(propertyTable, cmd_args[1]))

@lldb_command(<span class="enscript-string">'readioport8'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ReadIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Read value stored in the specified IO port. The CPU can be optionally
        specified as well.
        Prints 0xBAD10AD in case of a bad read
        Syntax: (lldb) readioport8 &lt;port&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to read out of&quot;</span>
        <span class="enscript-keyword">print</span> ReadIOPort8.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        lcpu = ArgumentStringToInt(cmd_args[1])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
            
    ReadIOPortInt(portAddr, 1, lcpu)

@lldb_command(<span class="enscript-string">'readioport16'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ReadIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Read value stored in the specified IO port. The CPU can be optionally
        specified as well.
        Prints 0xBAD10AD in case of a bad read
        Syntax: (lldb) readioport16 &lt;port&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to read out of&quot;</span>
        <span class="enscript-keyword">print</span> ReadIOPort16.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        lcpu = ArgumentStringToInt(cmd_args[1])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
    
    ReadIOPortInt(portAddr, 2, lcpu)

@lldb_command(<span class="enscript-string">'readioport32'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ReadIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Read value stored in the specified IO port. The CPU can be optionally
        specified as well.
        Prints 0xBAD10AD in case of a bad read
        Syntax: (lldb) readioport32 &lt;port&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to read out of&quot;</span>
        <span class="enscript-keyword">print</span> ReadIOPort32.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        lcpu = ArgumentStringToInt(cmd_args[1])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
    
    ReadIOPortInt(portAddr, 4, lcpu)

@lldb_command(<span class="enscript-string">'writeioport8'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">WriteIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Write the value to the specified IO port. The size of the value is
        determined by the name of the command. The CPU used can be optionally
        specified as well.
        Syntax: (lldb) writeioport8 &lt;port&gt; &lt;value&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to write to, followed by the value you want to write&quot;</span>
        <span class="enscript-keyword">print</span> WriteIOPort8.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    value = ArgumentStringToInt(cmd_args[1])
    
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 3:
        lcpu = ArgumentStringToInt(cmd_args[2])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
    
    WriteIOPortInt(portAddr, 1, value, lcpu)

@lldb_command(<span class="enscript-string">'writeioport16'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">WriteIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Write the value to the specified IO port. The size of the value is
        determined by the name of the command. The CPU used can be optionally
        specified as well.
        Syntax: (lldb) writeioport16 &lt;port&gt; &lt;value&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to write to, followed by the value you want to write&quot;</span>
        <span class="enscript-keyword">print</span> WriteIOPort16.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    value = ArgumentStringToInt(cmd_args[1])
    
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 3:
        lcpu = ArgumentStringToInt(cmd_args[2])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
    
    WriteIOPortInt(portAddr, 2, value, lcpu)

@lldb_command(<span class="enscript-string">'writeioport32'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">WriteIOPort8</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Write the value to the specified IO port. The size of the value is
        determined by the name of the command. The CPU used can be optionally
        specified as well.
        Syntax: (lldb) writeioport32 &lt;port&gt; &lt;value&gt; [lcpu (kernel's numbering convention)]
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please specify a port to write to, followed by the value you want to write&quot;</span>
        <span class="enscript-keyword">print</span> WriteIOPort32.__doc__
        <span class="enscript-keyword">return</span>
    
    portAddr = ArgumentStringToInt(cmd_args[0])
    value = ArgumentStringToInt(cmd_args[1])
    
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 3:
        lcpu = ArgumentStringToInt(cmd_args[2])
    <span class="enscript-keyword">else</span>:
        lcpu = xnudefines.lcpu_self
    
    WriteIOPortInt(portAddr, 4, value, lcpu)

@lldb_command(<span class="enscript-string">'showioservicepm'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowIOServicePM</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to dump the IOServicePM object
        Syntax: (lldb) showioservicepm &lt;IOServicePM pointer&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please enter the pointer to the IOServicePM object you'd like to introspect&quot;</span>
        <span class="enscript-keyword">print</span> ShowIOServicePM.__doc__
        <span class="enscript-keyword">return</span>
    
    iopmpriv = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'IOServicePM *'</span>)
    out_string = <span class="enscript-string">&quot;MachineState {0: &lt;6d} (&quot;</span>.format(iopmpriv.MachineState)
    
    <span class="enscript-comment"># Power state map
</span>    pstate_map = {
            0:  <span class="enscript-string">'kIOPM_Finished'</span>,
            1:  <span class="enscript-string">'kIOPM_OurChangeTellClientsPowerDown'</span>,
            2:  <span class="enscript-string">'kIOPM_OurChangeTellClientsPowerDown'</span>,
            3:  <span class="enscript-string">'kIOPM_OurChangeNotifyInterestedDriversWillChange'</span>,
            4:  <span class="enscript-string">'kIOPM_OurChangeSetPowerState'</span>,
            5:  <span class="enscript-string">'kIOPM_OurChangeWaitForPowerSettle'</span>,
            6:  <span class="enscript-string">'kIOPM_OurChangeNotifyInterestedDriversDidChange'</span>,
            7:  <span class="enscript-string">'kIOPM_OurChangeTellCapabilityDidChange'</span>,
            8:  <span class="enscript-string">'kIOPM_OurChangeFinish'</span>,
            9:  <span class="enscript-string">'Unused_MachineState_9'</span>,
            10: <span class="enscript-string">'kIOPM_ParentChangeTellPriorityClientsPowerDown'</span>,
            11: <span class="enscript-string">'kIOPM_ParentChangeNotifyInterestedDriversWillChange'</span>,
            12: <span class="enscript-string">'kIOPM_ParentChangeSetPowerState'</span>,
            13: <span class="enscript-string">'kIOPM_ParentChangeWaitForPowerSettle'</span>,
            14: <span class="enscript-string">'kIOPM_ParentChangeNotifyInterestedDriversDidChange'</span>,
            15: <span class="enscript-string">'kIOPM_ParentChangeTellCapabilityDidChange'</span>,
            16: <span class="enscript-string">'kIOPM_ParentChangeAcknowledgePowerChange'</span>,
            17: <span class="enscript-string">'kIOPM_NotifyChildrenStart'</span>,
            18: <span class="enscript-string">'kIOPM_NotifyChildrenOrdered'</span>,
            19: <span class="enscript-string">'kIOPM_NotifyChildrenDelayed'</span>,
            20: <span class="enscript-string">'kIOPM_SyncTellClientsPowerDown'</span>,
            21: <span class="enscript-string">'kIOPM_SyncTellPriorityClientsPowerDown'</span>,
            22: <span class="enscript-string">'kIOPM_SyncNotifyWillChange'</span>,
            23: <span class="enscript-string">'kIOPM_SyncNotifyDidChange'</span>,
            24: <span class="enscript-string">'kIOPM_SyncTellCapabilityDidChange'</span>,
            25: <span class="enscript-string">'kIOPM_SyncFinish'</span>,
            26: <span class="enscript-string">'kIOPM_TellCapabilityChangeDone'</span>,
            27: <span class="enscript-string">'kIOPM_DriverThreadCallDone'</span>
        }
    powerstate = unsigned(iopmpriv.MachineState)
    <span class="enscript-keyword">if</span> powerstate <span class="enscript-keyword">in</span> pstate_map:
        out_string += <span class="enscript-string">&quot;{0:s}&quot;</span>.format(pstate_map[powerstate])
    <span class="enscript-keyword">else</span>:
        out_string += <span class="enscript-string">&quot;Unknown_MachineState&quot;</span>
    out_string += <span class="enscript-string">&quot;), &quot;</span>
    
    <span class="enscript-keyword">if</span> iopmpriv.MachineState != 20:
        out_string += <span class="enscript-string">&quot;DriverTimer = {0: &lt;6d}, SettleTime = {1: &lt; 6d}, HeadNoteFlags = {2: #12x}, HeadNotePendingAcks = {3: #012x}, &quot;</span>.format(
                unsigned(iopmpriv.DriverTimer),
                unsigned(iopmpriv.SettleTimeUS),
                unsigned(iopmpriv.HeadNoteChangeFlags),
                unsigned(iopmpriv.HeadNotePendingAcks))
    
    <span class="enscript-keyword">if</span> iopmpriv.DeviceOverrideEnabled != 0:
        out_string += <span class="enscript-string">&quot;DeviceOverrides, &quot;</span>
    
    out_string += <span class="enscript-string">&quot;DeviceDesire = {0: &lt;6d}, DesiredPowerState = {1: &lt;6d}, PreviousRequest = {2: &lt;6d}\n&quot;</span>.format(
            unsigned(iopmpriv.DeviceDesire),
            unsigned(iopmpriv.DesiredPowerState),
            unsigned(iopmpriv.PreviousRequestPowerFlags))
    
    <span class="enscript-keyword">print</span> out_string

<span class="enscript-comment">######################################
</span><span class="enscript-comment">#  Helper routines
</span><span class="enscript-comment">######################################
</span><span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowRegistryEntryRecurse</span>(entry, prefix, printProps):
    <span class="enscript-string">&quot;&quot;&quot; prints registry entry summary and recurses through all its children.
    &quot;&quot;&quot;</span>
    <span class="enscript-comment"># Setup
</span>    <span class="enscript-keyword">global</span> plane
    out_string = <span class="enscript-string">&quot;&quot;</span>
    plen = (len(prefix)//2)
    registryTable = entry.fRegistryTable
    propertyTable = entry.fPropertyTable
    
    <span class="enscript-comment"># Print entry details
</span>    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{0:s}{1:s}&quot;</span>.format(prefix, GetRegistryEntrySummary(entry))
    <span class="enscript-comment"># Printing large property tables make it look like lldb is 'stuck'
</span>    <span class="enscript-keyword">if</span> printProps:
        <span class="enscript-keyword">print</span> GetRegDictionary(propertyTable, prefix + <span class="enscript-string">&quot;  | &quot;</span>)
    
    <span class="enscript-comment"># Recurse
</span>    <span class="enscript-keyword">if</span> plane <span class="enscript-keyword">is</span> None:
        childKey = kern.globals.gIOServicePlane.keys[1]
    <span class="enscript-keyword">else</span>:
        childKey = plane.keys[1]
    childArray = LookupKeyInOSDict(registryTable, childKey)
    <span class="enscript-keyword">if</span> childArray <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        idx = 0
        ca = CastIOKitClass(childArray, <span class="enscript-string">'OSArray *'</span>)
        count = unsigned(ca.count)
        <span class="enscript-keyword">while</span> idx &lt; count:
            <span class="enscript-keyword">if</span> plen != 0 <span class="enscript-keyword">and</span> plen != 1 <span class="enscript-keyword">and</span> (plen &amp; (plen - 1)) == 0:
                ShowRegistryEntryRecurse(CastIOKitClass(ca.array[idx], <span class="enscript-string">'IORegistryEntry *'</span>), prefix + <span class="enscript-string">&quot;| &quot;</span>, printProps)
            <span class="enscript-keyword">else</span>:
                ShowRegistryEntryRecurse(CastIOKitClass(ca.array[idx], <span class="enscript-string">'IORegistryEntry *'</span>), prefix + <span class="enscript-string">&quot;  &quot;</span>, printProps)
            idx += 1

<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindRegistryEntryRecurse</span>(entry, search_name, stopAfterFirst):
    <span class="enscript-string">&quot;&quot;&quot; Checks if given registry entry's name matches the search_name we're looking for
        If yes, it prints the entry's summary and then recurses through its children
        If no, it does nothing and recurses through its children
    &quot;&quot;&quot;</span>
    <span class="enscript-comment"># Setup
</span>    <span class="enscript-keyword">global</span> plane
    registryTable = entry.fRegistryTable
    propertyTable = entry.fPropertyTable
    
    <span class="enscript-comment"># Compare
</span>    name = None
    name = LookupKeyInOSDict(registryTable, kern.globals.gIOServicePlane.nameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(registryTable, kern.globals.gIONameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(propertyTable, kern.globals.gIOClassKey)
    
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        <span class="enscript-keyword">if</span> str(CastIOKitClass(name, <span class="enscript-string">'OSString *'</span>).string) == search_name:
            <span class="enscript-keyword">print</span> GetRegistryEntrySummary(entry)
            <span class="enscript-keyword">if</span> stopAfterFirst <span class="enscript-keyword">is</span> True:
                <span class="enscript-keyword">return</span> True
    <span class="enscript-keyword">elif</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt <span class="enscript-keyword">and</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name:
        name = CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name
        <span class="enscript-keyword">if</span> str(name) == search_name:
            <span class="enscript-keyword">print</span> GetRegistryEntrySummary(entry)
            <span class="enscript-keyword">if</span> stopAfterFirst <span class="enscript-keyword">is</span> True:
                <span class="enscript-keyword">return</span> True
    
    <span class="enscript-comment"># Recurse
</span>    <span class="enscript-keyword">if</span> plane <span class="enscript-keyword">is</span> None:
        childKey = kern.globals.gIOServicePlane.keys[1]
    <span class="enscript-keyword">else</span>:
        childKey = plane.keys[1]
    childArray = LookupKeyInOSDict(registryTable, childKey)
    <span class="enscript-keyword">if</span> childArray <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        idx = 0
        ca = CastIOKitClass(childArray, <span class="enscript-string">'OSArray *'</span>)
        count = unsigned(ca.count)
        <span class="enscript-keyword">while</span> idx &lt; count:
            <span class="enscript-keyword">if</span> FindRegistryEntryRecurse(CastIOKitClass(ca.array[idx], <span class="enscript-string">'IORegistryEntry *'</span>), search_name, stopAfterFirst) <span class="enscript-keyword">is</span> True:
                <span class="enscript-keyword">return</span> True
            idx += 1
    <span class="enscript-keyword">return</span> False

<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindRegistryObjectRecurse</span>(entry, search_name):
    <span class="enscript-string">&quot;&quot;&quot; Checks if given registry entry's name matches the search_name we're looking for
        If yes, return the entry
        If no, it does nothing and recurses through its children
        Implicitly stops after finding the first entry
    &quot;&quot;&quot;</span>
    <span class="enscript-comment"># Setup
</span>    <span class="enscript-keyword">global</span> plane
    registryTable = entry.fRegistryTable
    propertyTable = entry.fPropertyTable

    <span class="enscript-comment"># Compare
</span>    name = None
    name = LookupKeyInOSDict(registryTable, kern.globals.gIOServicePlane.nameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(registryTable, kern.globals.gIONameKey)
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
        name = LookupKeyInOSDict(propertyTable, kern.globals.gIOClassKey)
    
    <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        <span class="enscript-keyword">if</span> str(CastIOKitClass(name, <span class="enscript-string">'OSString *'</span>).string) == search_name:
            <span class="enscript-keyword">return</span> entry
    <span class="enscript-keyword">elif</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt <span class="enscript-keyword">and</span> CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name:
        name = CastIOKitClass(entry, <span class="enscript-string">'IOService *'</span>).pwrMgt.Name
        <span class="enscript-keyword">if</span> str(name) == search_name:
            <span class="enscript-keyword">return</span> entry
    
    <span class="enscript-comment"># Recurse
</span>    <span class="enscript-keyword">if</span> plane <span class="enscript-keyword">is</span> None:
        childKey = kern.globals.gIOServicePlane.keys[1]
    <span class="enscript-keyword">else</span>:
        childKey = plane.keys[1]
    childArray = LookupKeyInOSDict(registryTable, childKey)
    <span class="enscript-keyword">if</span> childArray <span class="enscript-keyword">is</span> <span class="enscript-keyword">not</span> None:
        ca = CastIOKitClass(childArray, <span class="enscript-string">'OSArray *'</span>)
        <span class="enscript-keyword">for</span> idx <span class="enscript-keyword">in</span> range(ca.count):
            registry_object = FindRegistryObjectRecurse(CastIOKitClass(ca.array[idx], <span class="enscript-string">'IORegistryEntry *'</span>), search_name)
            <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> registry_object <span class="enscript-keyword">or</span> int(registry_object) == int(0):
                <span class="enscript-keyword">continue</span>
            <span class="enscript-keyword">else</span>:
                <span class="enscript-keyword">return</span> registry_object
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">LookupKeyInOSDict</span>(osdict, key):
    <span class="enscript-string">&quot;&quot;&quot; Returns the value corresponding to a given key in a OSDictionary
        Returns None if the key was not found
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> osdict:
        <span class="enscript-keyword">return</span>
    count = unsigned(osdict.count)
    result = None
    idx = 0
    <span class="enscript-keyword">while</span> idx &lt; count <span class="enscript-keyword">and</span> result <span class="enscript-keyword">is</span> None:
        <span class="enscript-keyword">if</span> key == osdict.dictionary[idx].key:
            result = osdict.dictionary[idx].value
        idx += 1
    <span class="enscript-keyword">return</span> result

<span class="enscript-keyword">def</span> <span class="enscript-function-name">LookupKeyInPropTable</span>(propertyTable, key_str):
    <span class="enscript-string">&quot;&quot;&quot; Returns the value corresponding to a given key from a registry entry's property table
        Returns None if the key was not found
        The property that is being searched for is specified as a string in key_str
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> propertyTable:
        <span class="enscript-keyword">return</span>
    count = unsigned(propertyTable.count)
    result = None
    idx = 0
    <span class="enscript-keyword">while</span> idx &lt; count <span class="enscript-keyword">and</span> result <span class="enscript-keyword">is</span> None:
        <span class="enscript-keyword">if</span> key_str == str(propertyTable.dictionary[idx].key.string):
            result = propertyTable.dictionary[idx].value
        idx += 1
    <span class="enscript-keyword">return</span> result

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetRegDictionary</span>(osdict, prefix):
    <span class="enscript-string">&quot;&quot;&quot; Returns a specially formatted string summary of the given OSDictionary
        This is done in order to pretty-print registry property tables in showregistry
        and other macros
    &quot;&quot;&quot;</span>
    out_string = prefix + <span class="enscript-string">&quot;{\n&quot;</span>
    idx = 0
    count = unsigned(osdict.count)
    
    <span class="enscript-keyword">while</span> idx &lt; count:
        out_string += prefix + <span class="enscript-string">&quot;  &quot;</span> + GetObjectSummary(osdict.dictionary[idx].key) + <span class="enscript-string">&quot; = &quot;</span> + GetObjectSummary(osdict.dictionary[idx].value) + <span class="enscript-string">&quot;\n&quot;</span>
        idx += 1
    out_string += prefix + <span class="enscript-string">&quot;}\n&quot;</span>
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetString</span>(string):
    <span class="enscript-string">&quot;&quot;&quot; Returns the python string representation of a given OSString
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;\&quot;{0:s}\&quot;&quot;</span>.format(CastIOKitClass(string, <span class="enscript-string">'OSString *'</span>).string)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetNumber</span>(num):
    out_string = <span class="enscript-string">&quot;{0:d}&quot;</span>.format(CastIOKitClass(num, <span class="enscript-string">'OSNumber *'</span>).value)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetBoolean</span>(b):
    <span class="enscript-string">&quot;&quot;&quot; Shows info about a given OSBoolean
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>
    <span class="enscript-keyword">if</span> b == kern.globals.gOSBooleanFalse:
        out_string += <span class="enscript-string">&quot;No&quot;</span>
    <span class="enscript-keyword">else</span>:
        out_string += <span class="enscript-string">&quot;Yes&quot;</span>
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetMetaClass</span>(mc):
    <span class="enscript-string">&quot;&quot;&quot; Shows info about a given OSSymbol
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;{0: &lt;5d}x {1: &gt;5d} bytes {2:s}\n&quot;</span>.format(mc.instanceCount, mc.classSize, mc.className.string)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetArray</span>(arr):
    <span class="enscript-string">&quot;&quot;&quot; Returns a string containing info about a given OSArray
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>
    idx = 0
    count = unsigned(arr.count)
    
    <span class="enscript-keyword">while</span> idx &lt; count:
        obj = arr.array[idx]
        idx += 1
        out_string += GetObjectSummary(obj)
        <span class="enscript-keyword">if</span> idx &lt; unsigned(arr.count):
            out_string += <span class="enscript-string">&quot;,&quot;</span>
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetDictionary</span>(d):
    <span class="enscript-string">&quot;&quot;&quot; Returns a string containing info about a given OSDictionary
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;{&quot;</span>
    idx = 0
    count = unsigned(d.count)

    <span class="enscript-keyword">while</span> idx &lt; count:
        obj = d.dictionary[idx].key
        out_string += GetObjectSummary(obj) + <span class="enscript-string">&quot;=&quot;</span>
        obj = d.dictionary[idx].value
        idx += 1
        out_string += GetObjectSummary(obj)
        <span class="enscript-keyword">if</span> idx &lt; count:
            out_string += <span class="enscript-string">&quot;,&quot;</span>
    out_string += <span class="enscript-string">&quot;}&quot;</span>
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetSet</span>(se):
    <span class="enscript-string">&quot;&quot;&quot; Returns a string containing info about a given OSSet
    &quot;&quot;&quot;</span>
    out_string += <span class="enscript-string">&quot;[&quot;</span> + GetArray(se.members) + <span class="enscript-string">&quot;]&quot;</span>
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ReadIOPortInt</span>(addr, numbytes, lcpu):
    <span class="enscript-string">&quot;&quot;&quot; Prints results after reading a given ioport
    &quot;&quot;&quot;</span>
    result = 0xBAD10AD
    
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;kdp&quot;</span> != GetConnectionProtocol():
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Target is not connected over kdp. Nothing to do here.&quot;</span>
        <span class="enscript-keyword">return</span>
    
    <span class="enscript-comment"># Set up the manual KDP packet
</span>    input_address = unsigned(addressof(kern.globals.manual_pkt.input))
    len_address = unsigned(addressof(kern.globals.manual_pkt.len))
    data_address = unsigned(addressof(kern.globals.manual_pkt.data))
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> WriteInt32ToMemoryAddress(0, input_address):
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;0x{0: &lt;4x}: 0x{1: &lt;1x}&quot;</span>.format(addr, result)
        <span class="enscript-keyword">return</span>
    
    kdp_pkt_size = GetType(<span class="enscript-string">'kdp_readioport_req_t'</span>).GetByteSize()
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> WriteInt32ToMemoryAddress(kdp_pkt_size, len_address):
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;0x{0: &lt;4x}: 0x{1: &lt;1x}&quot;</span>.format(addr, result)
        <span class="enscript-keyword">return</span>
    
    kgm_pkt = kern.GetValueFromAddress(data_address, <span class="enscript-string">'kdp_readioport_req_t *'</span>)
    
    header_value = GetKDPPacketHeaderInt(request=GetEnumValue(<span class="enscript-string">'kdp_req_t::KDP_READIOPORT'</span>), length = kdp_pkt_size)
    
    <span class="enscript-keyword">if</span>( WriteInt64ToMemoryAddress((header_value), int(addressof(kgm_pkt.hdr))) <span class="enscript-keyword">and</span>
        WriteInt16ToMemoryAddress(addr, int(addressof(kgm_pkt.address))) <span class="enscript-keyword">and</span>
        WriteInt32ToMemoryAddress(numbytes, int(addressof(kgm_pkt.nbytes))) <span class="enscript-keyword">and</span>
        WriteInt16ToMemoryAddress(lcpu, int(addressof(kgm_pkt.lcpu))) <span class="enscript-keyword">and</span>
        WriteInt32ToMemoryAddress(1, input_address)
        ):
        
        result_pkt = Cast(addressof(kern.globals.manual_pkt.data), <span class="enscript-string">'kdp_readioport_reply_t *'</span>)
        
        <span class="enscript-keyword">if</span>(result_pkt.error == 0):
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;This macro is incomplete till &lt;rdar://problem/12868059&gt; is fixed&quot;</span>
            <span class="enscript-comment"># FIXME: Uncomment me when &lt;rdar://problem/12868059&gt; is fixed
</span>            <span class="enscript-comment">#if numbytes == 1:
</span>            <span class="enscript-comment">#    result = dereference(Cast(result_pkt.data, 'uint8_t *'))
</span>            <span class="enscript-comment">#elif numbytes == 2:
</span>            <span class="enscript-comment">#    result = dereference(Cast(result_pkt.data, 'uint16_t *'))
</span>            <span class="enscript-comment">#elif numbytes == 4:
</span>            <span class="enscript-comment">#    result = dereference(cast(result_pkt.data, 'uint32_t *'))
</span>    
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;0x{0: &lt;4x}: 0x{1: &lt;1x}&quot;</span>.format(addr, result)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">WriteIOPortInt</span>(addr, numbytes, value, lcpu):
    <span class="enscript-string">&quot;&quot;&quot; Writes 'value' into ioport specified by 'addr'. Prints errors if it encounters any
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;kdp&quot;</span> != GetConnectionProtocol():
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Target is not connected over kdp. Nothing to do here.&quot;</span>
        <span class="enscript-keyword">return</span>
    
    <span class="enscript-comment"># Set up the manual KDP packet
</span>    input_address = unsigned(addressof(kern.globals.manual_pkt.input))
    len_address = unsigned(addressof(kern.globals.manual_pkt.len))
    data_address = unsigned(addressof(kern.globals.manual_pkt.data))
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> WriteInt32ToMemoryAddress(0, input_address):
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;</span>.format(value, addr)
        <span class="enscript-keyword">return</span>
    
    kdp_pkt_size = GetType(<span class="enscript-string">'kdp_writeioport_req_t'</span>).GetByteSize()
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> WriteInt32ToMemoryAddress(kdp_pkt_size, len_address):
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;</span>.format(value, addr)
        <span class="enscript-keyword">return</span>
    
    kgm_pkt = kern.GetValueFromAddress(data_address, <span class="enscript-string">'kdp_writeioport_req_t *'</span>)
    
    header_value = GetKDPPacketHeaderInt(request=GetEnumValue(<span class="enscript-string">'kdp_req_t::KDP_WRITEIOPORT'</span>), length = kdp_pkt_size)
    
    <span class="enscript-keyword">if</span>( WriteInt64ToMemoryAddress((header_value), int(addressof(kgm_pkt.hdr))) <span class="enscript-keyword">and</span>
        WriteInt16ToMemoryAddress(addr, int(addressof(kgm_pkt.address))) <span class="enscript-keyword">and</span>
        WriteInt32ToMemoryAddress(numbytes, int(addressof(kgm_pkt.nbytes))) <span class="enscript-keyword">and</span>
        WriteInt16ToMemoryAddress(lcpu, int(addressof(kgm_pkt.lcpu)))
        ):
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;This macro is incomplete till &lt;rdar://problem/12868059&gt; is fixed&quot;</span>
        <span class="enscript-comment"># FIXME: Uncomment me when &lt;rdar://problem/12868059&gt; is fixed
</span>        <span class="enscript-comment">#if numbytes == 1:
</span>        <span class="enscript-comment">#    if not WriteInt8ToMemoryAddress(value, int(addressof(kgm_pkt.data))):
</span>        <span class="enscript-comment">#        print &quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;.format(value, addr)
</span>        <span class="enscript-comment">#elif numbytes == 2:
</span>        <span class="enscript-comment">#    if not WriteInt16ToMemoryAddress(value, int(addressof(kgm_pkt.data))):
</span>        <span class="enscript-comment">#        print &quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;.format(value, addr)
</span>        <span class="enscript-comment">#elif numbytes == 4:
</span>        <span class="enscript-comment">#    if not WriteInt32ToMemoryAddress(value, int(addressof(kgm_pkt.data))):
</span>        <span class="enscript-comment">#        print &quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;.format(value, addr)
</span>        
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> WriteInt32ToMemoryAddress(1, input_address):
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;</span>.format(value, addr)
            <span class="enscript-keyword">return</span>

        result_pkt = Cast(addressof(kern.globals.manual_pkt.data), <span class="enscript-string">'kdp_writeioport_reply_t *'</span>)
        
        <span class="enscript-comment"># Done with the write
</span>        <span class="enscript-keyword">if</span>(result_pkt.error == 0):
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Writing 0x {0: x} to port {1: &lt;4x} was successful&quot;</span>.format(value, addr)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;error writing 0x{0: x} to port 0x{1: &lt;4x}&quot;</span>.format(value, addr)

@lldb_command(<span class="enscript-string">'showinterruptcounts'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">showinterruptcounts</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Shows event source based interrupt counts by nub name and interrupt index.
        Does not cover interrupts that are not event source based.  Will report 0
        if interrupt accounting is disabled.
    &quot;&quot;&quot;</span>

    header_format = <span class="enscript-string">&quot;{0: &lt;20s} {1: &gt;5s} {2: &gt;20s}&quot;</span>
    content_format = <span class="enscript-string">&quot;{0: &lt;20s} {1: &gt;5d} {2: &gt;20d}&quot;</span>

    <span class="enscript-keyword">print</span> header_format.format(<span class="enscript-string">&quot;Name&quot;</span>, <span class="enscript-string">&quot;Index&quot;</span>, <span class="enscript-string">&quot;Count&quot;</span>)
    
    <span class="enscript-keyword">for</span> i <span class="enscript-keyword">in</span> kern.interrupt_stats:
        owner = CastIOKitClass(i.owner, <span class="enscript-string">'IOInterruptEventSource *'</span>)
        nub = CastIOKitClass(owner.provider, <span class="enscript-string">'IORegistryEntry *'</span>) 
        name = None

        <span class="enscript-comment"># To uniquely identify an interrupt, we need the nub name and the index.  The index
</span>        <span class="enscript-comment"># is stored with the stats object, but we need to retrieve the name.
</span>
        registryTable = nub.fRegistryTable
        propertyTable = nub.fPropertyTable
    
        name = LookupKeyInOSDict(registryTable, kern.globals.gIOServicePlane.nameKey)
        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            name = LookupKeyInOSDict(registryTable, kern.globals.gIONameKey)
        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            name = LookupKeyInOSDict(propertyTable, kern.globals.gIOClassKey)

        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            nub_name = <span class="enscript-string">&quot;Unknown&quot;</span>
        <span class="enscript-keyword">else</span>:
            nub_name = GetString(CastIOKitClass(name, <span class="enscript-string">'OSString *'</span>))

        <span class="enscript-comment"># We now have everything we need; spew the requested data.
</span>
        interrupt_index = i.interruptIndex
        first_level_count = i.interruptStatistics[0]

        <span class="enscript-keyword">print</span> content_format.format(nub_name, interrupt_index, first_level_count)
    
    <span class="enscript-keyword">return</span> True

@lldb_command(<span class="enscript-string">'showinterruptstats'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">showinterruptstats</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Shows event source based interrupt statistics by nub name and interrupt index.
        Does not cover interrupts that are not event source based.  Will report 0
        if interrupt accounting is disabled, or if specific statistics are disabled.
        Time is reported in ticks of mach_absolute_time.  Statistics are:
        
        Interrupt Count: Number of times the interrupt context handler was run
        Interrupt Time: Total time spent in the interrupt context handler (if any)
        Workloop Count: Number of times the kernel context handler was run
        Workloop CPU Time: Total CPU time spent running the kernel context handler
        Workloop Time: Total time spent running the kernel context handler
    &quot;&quot;&quot;</span>

    header_format = <span class="enscript-string">&quot;{0: &lt;20s} {1: &gt;5s} {2: &gt;20s} {3: &gt;20s} {4: &gt;20s} {5: &gt;20s} {6: &gt;20s}&quot;</span>
    content_format = <span class="enscript-string">&quot;{0: &lt;20s} {1: &gt;5d} {2: &gt;20d} {3: &gt;20d} {4: &gt;20d} {5: &gt;20d} {6: &gt;20d}&quot;</span>

    <span class="enscript-keyword">print</span> header_format.format(<span class="enscript-string">&quot;Name&quot;</span>, <span class="enscript-string">&quot;Index&quot;</span>, <span class="enscript-string">&quot;Interrupt Count&quot;</span>, <span class="enscript-string">&quot;Interrupt Time&quot;</span>, <span class="enscript-string">&quot;Workloop Count&quot;</span>, <span class="enscript-string">&quot;Workloop CPU Time&quot;</span>, <span class="enscript-string">&quot;Workloop Time&quot;</span>)
    
    <span class="enscript-keyword">for</span> i <span class="enscript-keyword">in</span> kern.interrupt_stats:
        owner = CastIOKitClass(i.owner, <span class="enscript-string">'IOInterruptEventSource *'</span>)
        nub = CastIOKitClass(owner.provider, <span class="enscript-string">'IORegistryEntry *'</span>) 
        name = None

        <span class="enscript-comment"># To uniquely identify an interrupt, we need the nub name and the index.  The index
</span>        <span class="enscript-comment"># is stored with the stats object, but we need to retrieve the name.
</span>
        registryTable = nub.fRegistryTable
        propertyTable = nub.fPropertyTable
    
        name = LookupKeyInOSDict(registryTable, kern.globals.gIOServicePlane.nameKey)
        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            name = LookupKeyInOSDict(registryTable, kern.globals.gIONameKey)
        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            name = LookupKeyInOSDict(propertyTable, kern.globals.gIOClassKey)

        <span class="enscript-keyword">if</span> name <span class="enscript-keyword">is</span> None:
            nub_name = <span class="enscript-string">&quot;Unknown&quot;</span>
        <span class="enscript-keyword">else</span>:
            nub_name = GetString(CastIOKitClass(name, <span class="enscript-string">'OSString *'</span>))

        <span class="enscript-comment"># We now have everything we need; spew the requested data.
</span>
        interrupt_index = i.interruptIndex
        first_level_count = i.interruptStatistics[0]
        second_level_count = i.interruptStatistics[1]
        first_level_time = i.interruptStatistics[2]
        second_level_cpu_time = i.interruptStatistics[3]
        second_level_system_time = i.interruptStatistics[4]

        <span class="enscript-keyword">print</span> content_format.format(nub_name, interrupt_index, first_level_count, first_level_time, second_level_count, second_level_cpu_time, second_level_system_time)
    
    <span class="enscript-keyword">return</span> True

</pre>
<hr />
</body></html>