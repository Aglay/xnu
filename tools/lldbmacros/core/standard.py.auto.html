<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>standard.py</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">standard.py&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-keyword">import</span> getopt
<span class="enscript-keyword">import</span> os
<span class="enscript-keyword">import</span> sys
<span class="enscript-keyword">import</span> re

<span class="enscript-keyword">class</span> ArgumentError(Exception):
    <span class="enscript-string">&quot;&quot;&quot; Exception class for raising errors in command arguments. The lldb_command framework will catch this 
        class of exceptions and print suitable error message to user.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__init__</span>(self, msg):
        self.error_message = msg
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__str__</span>(self):
        <span class="enscript-keyword">return</span> str(self.error_message)


<span class="enscript-keyword">class</span> RedirectStdStreams(object):
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__init__</span>(self, stdout=None, stderr=None):
        self._stdout = stdout <span class="enscript-keyword">or</span> sys.stdout
        self._stderr = stderr <span class="enscript-keyword">or</span> sys.stderr

    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__enter__</span>(self):
        self.old_stdout, self.old_stderr = sys.stdout, sys.stderr
        self.old_stdout.flush(); self.old_stderr.flush()
        sys.stdout, sys.stderr = self._stdout, self._stderr

    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__exit__</span>(self, exc_type, exc_value, traceback):
        self._stdout.flush(); self._stderr.flush()
        sys.stdout = self.old_stdout
        sys.stderr = self.old_stderr

<span class="enscript-keyword">class</span> CommandOutput(object):
    <span class="enscript-string">&quot;&quot;&quot;
    An output handler for all commands. Use Output.print to direct all output of macro via the handler. 
    These arguments are passed after a &quot;--&quot;. eg
    (lldb) zprint -- -o /tmp/zprint.out.txt
    
    Currently this provide capabilities 
    -o path/to/filename
       The output of this command execution will be saved to file. Parser information or errors will 
       not be sent to file though. eg /tmp/output.txt
    -s filter_string
       the &quot;filter_string&quot; param is parsed to python regex expression and each line of output 
       will be printed/saved only if it matches the expression. 
       The command header will not be filtered in any case.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__init__</span>(self, CommandResult):
        <span class="enscript-string">&quot;&quot;&quot; Create a new instance to handle command output.
        params:
                CommandResult : SBCommandReturnObject result param from lldb's command invocation. 
        &quot;&quot;&quot;</span>
        self.fname=None
        self.fhandle=None
        self.FILTER=False
        self.pluginRequired = False
        self.pluginName = None
        self.resultObj = CommandResult
        self.immediateOutput = False
        self.verbose_level = 0
        self.target_cmd_args = []
        self.target_cmd_options = {}

    <span class="enscript-keyword">def</span> <span class="enscript-function-name">write</span>(self, s):
        <span class="enscript-string">&quot;&quot;&quot; Handler for all commands output. By default just print to stdout &quot;&quot;&quot;</span>
        <span class="enscript-keyword">if</span> self.FILTER <span class="enscript-keyword">and</span> <span class="enscript-keyword">not</span> self.reg.search(s): <span class="enscript-keyword">return</span>
        <span class="enscript-keyword">if</span> self.FILTER : s+=<span class="enscript-string">&quot;\n&quot;</span>
        <span class="enscript-keyword">if</span> self.fhandle != None: self.fhandle.write(s)
        <span class="enscript-keyword">else</span>:
            <span class="enscript-keyword">if</span> self.immediateOutput:
                sys.__stdout__.write(s)
            <span class="enscript-keyword">else</span>:
                res_str = s
                <span class="enscript-keyword">if</span> s.endswith(<span class="enscript-string">&quot;\n&quot;</span>):
                    res_str = s[:-1]
                <span class="enscript-keyword">if</span> self.resultObj <span class="enscript-keyword">and</span> len(res_str) &gt; 0: self.resultObj.AppendMessage(res_str)

    <span class="enscript-keyword">def</span> <span class="enscript-function-name">flush</span>(self):
        <span class="enscript-keyword">if</span> self.fhandle != None:
            self.fhandle.flush()
        
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">__del__</span>(self):
        <span class="enscript-string">&quot;&quot;&quot; closes any open files. report on any errors &quot;&quot;&quot;</span>
        <span class="enscript-keyword">if</span> self.fhandle != None :
            self.fhandle.close()
    
    <span class="enscript-keyword">def</span> <span class="enscript-function-name">setOptions</span>(self,cmdargs, cmdoptions =<span class="enscript-string">''</span>):
        <span class="enscript-string">&quot;&quot;&quot; parse the arguments passed to the command 
            param : 
                cmdargs =&gt; [] of &lt;str&gt; (typically args.split())
                cmdoptions : str - string of command level options. 
                             These should be CAPITAL LETTER options only.
        &quot;&quot;&quot;</span>
        opts=()
        args = cmdargs
        cmdoptions = cmdoptions.upper()
        <span class="enscript-keyword">try</span>:
            opts,args = getopt.gnu_getopt(args,<span class="enscript-string">'hvo:s:p:'</span>+ cmdoptions,[])
            self.target_cmd_args = args
        <span class="enscript-keyword">except</span> getopt.GetoptError,err:
            <span class="enscript-keyword">raise</span> ArgumentError(str(err))
        <span class="enscript-comment">#continue with processing
</span>        <span class="enscript-keyword">for</span> o,a <span class="enscript-keyword">in</span> opts :
            <span class="enscript-keyword">if</span> o == <span class="enscript-string">&quot;-h&quot;</span>:
                <span class="enscript-comment"># This is misuse of exception but 'self' has no info on doc string.
</span>                <span class="enscript-comment"># The caller may handle exception and display appropriate info
</span>                <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;HELP&quot;</span>)
            <span class="enscript-keyword">if</span> o == <span class="enscript-string">&quot;-o&quot;</span> <span class="enscript-keyword">and</span> len(a) &gt; 0:
                self.fname=os.path.normpath(os.path.expanduser(a.strip()))
                self.fhandle=open(self.fname,<span class="enscript-string">&quot;w&quot;</span>)
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;saving results in file &quot;</span>,str(a)
                self.fhandle.write(<span class="enscript-string">&quot;(lldb)%s \n&quot;</span> % <span class="enscript-string">&quot; &quot;</span>.join(cmdargs))
            <span class="enscript-keyword">elif</span> o == <span class="enscript-string">&quot;-s&quot;</span> <span class="enscript-keyword">and</span> len(a) &gt; 0:
                self.reg = re.compile(a.strip(),re.MULTILINE|re.DOTALL)
                self.FILTER=True
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;showing results for regex:&quot;</span>,a.strip()
            <span class="enscript-keyword">elif</span> o == <span class="enscript-string">&quot;-p&quot;</span> <span class="enscript-keyword">and</span> len(a) &gt; 0:
                self.pluginRequired = True
                self.pluginName = a.strip()
                <span class="enscript-comment">#print &quot;passing output to &quot; + a.strip()
</span>            <span class="enscript-keyword">elif</span> o == <span class="enscript-string">&quot;-v&quot;</span> :
                self.verbose_level += 1
            <span class="enscript-keyword">else</span>:
                o = o.strip()
                self.target_cmd_options[o] = a

            
        

</pre>
<hr />
</body></html>