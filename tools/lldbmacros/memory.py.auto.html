<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>memory.py</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">memory.py&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>

<span class="enscript-string">&quot;&quot;&quot; Please make sure you read the README file COMPLETELY BEFORE reading anything below.
    It is very critical that you read coding guidelines in Section E in README file.
&quot;&quot;&quot;</span>
<span class="enscript-keyword">from</span> xnu <span class="enscript-keyword">import</span> *
<span class="enscript-keyword">import</span> sys
<span class="enscript-keyword">import</span> shlex
<span class="enscript-keyword">from</span> utils <span class="enscript-keyword">import</span> *
<span class="enscript-keyword">import</span> xnudefines
<span class="enscript-keyword">from</span> process <span class="enscript-keyword">import</span> *

<span class="enscript-comment"># Macro: memstats
</span>@lldb_command(<span class="enscript-string">'memstats'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">Memstats</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints out a summary of various memory statistics. In particular vm_page_wire_count should be greater than 2K or you are under memory pressure.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">try</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;memorystatus_level: {: &gt;10d}&quot;</span>.format(kern.globals.memorystatus_level)
    <span class="enscript-keyword">except</span> ValueError:
        <span class="enscript-keyword">pass</span>
    <span class="enscript-keyword">try</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;memorystatus_available_pages: {: &gt;10d}&quot;</span>.format(kern.globals.memorystatus_available_pages)
    <span class="enscript-keyword">except</span> ValueError:
        <span class="enscript-keyword">pass</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_throttled_count: {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_throttled_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_active_count:    {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_active_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_inactive_count:  {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_inactive_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_wire_count:      {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_wire_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_free_count:      {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_free_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_purgeable_count: {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_purgeable_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_inactive_target: {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_inactive_target)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_free_target:     {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_free_target)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;inuse_ptepages_count:    {: &gt;10d}&quot;</span>.format(kern.globals.inuse_ptepages_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_free_reserved:   {: &gt;10d}&quot;</span>.format(kern.globals.vm_page_free_reserved)

@xnudebug_test(<span class="enscript-string">'test_memstats'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">TestMemstats</span>(kernel_target, config, lldb_obj, isConnected ):
    <span class="enscript-string">&quot;&quot;&quot; Test the functionality of memstats command
        returns 
         - False on failure
         - True on success 
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> isConnected:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Target is not connected. Cannot test memstats&quot;</span>
        <span class="enscript-keyword">return</span> False
    res = lldb.SBCommandReturnObject()
    lldb_obj.debugger.GetCommandInterpreter().HandleCommand(<span class="enscript-string">&quot;memstats&quot;</span>, res)
    result = res.GetOutput()
    <span class="enscript-keyword">if</span> result.split(<span class="enscript-string">&quot;:&quot;</span>)[1].strip().find(<span class="enscript-string">'None'</span>) == -1 : 
        <span class="enscript-keyword">return</span> True
    <span class="enscript-keyword">else</span>: 
        <span class="enscript-keyword">return</span> False

<span class="enscript-comment"># EndMacro: memstats
</span>
<span class="enscript-comment"># Macro: showmemorystatus
</span><span class="enscript-keyword">def</span> <span class="enscript-function-name">CalculateLedgerPeak</span>(phys_footprint_entry):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to calculate ledger peak value for the given phys footprint entry
        params: phys_footprint_entry - value representing struct ledger_entry * 
        return: value - representing the ledger peak for the given phys footprint entry
    &quot;&quot;&quot;</span>
    now = kern.globals.sched_tick / 20
    ledger_peak = phys_footprint_entry.le_credit - phys_footprint_entry.le_debit
    <span class="enscript-keyword">if</span> (now - phys_footprint_entry._le.le_peaks[0].le_time &lt;= 1) <span class="enscript-keyword">and</span> (phys_footprint_entry._le.le_peaks[0].le_max &gt; ledger_peak):
        ledger_peak = phys_footprint_entry._le.le_peaks[0].le_max
    <span class="enscript-keyword">if</span> (now - phys_footprint_entry._le.le_peaks[1].le_time &lt;= 1) <span class="enscript-keyword">and</span> (phys_footprint_entry._le.le_peaks[1].le_max &gt; ledger_peak):
        ledger_peak = phys_footprint_entry._le.le_peaks[1].le_max
    <span class="enscript-keyword">return</span> ledger_peak

@header(<span class="enscript-string">&quot;{: &gt;8s} {: &gt;22s} {: &gt;22s} {: &gt;11s} {: &gt;11s} {: &gt;12s} {: &gt;10s} {: &gt;13s} {: ^10s} {: &gt;8s}  {: &lt;20s}\n&quot;</span>.format(
<span class="enscript-string">'pid'</span>, <span class="enscript-string">'effective priority'</span>, <span class="enscript-string">'requested priority'</span>, <span class="enscript-string">'state'</span>, <span class="enscript-string">'user_data'</span>, <span class="enscript-string">'physical'</span>, <span class="enscript-string">'iokit'</span>, <span class="enscript-string">'footprint'</span>,
<span class="enscript-string">'spike'</span>, <span class="enscript-string">'limit'</span>, <span class="enscript-string">'command'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetMemoryStatusNode</span>(proc_val):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to get memorystatus information from the given proc
        params: proc - value representing struct proc *
        return: str - formatted output information for proc object
    &quot;&quot;&quot;</span>
    out_str = <span class="enscript-string">''</span>
    task_val = Cast(proc_val.task, <span class="enscript-string">'task *'</span>)
    task_ledgerp = task_val.ledger

    task_physmem_footprint_ledger_entry = task_ledgerp.l_entries[kern.globals.task_ledgers.phys_mem]
    task_iokit_footprint_ledger_entry = task_ledgerp.l_entries[kern.globals.task_ledgers.iokit_mapped]
    task_phys_footprint_ledger_entry = task_ledgerp.l_entries[kern.globals.task_ledgers.phys_footprint]
    page_size = kern.globals.page_size
    
    phys_mem_footprint = (task_physmem_footprint_ledger_entry.le_credit - task_physmem_footprint_ledger_entry.le_debit) / page_size
    iokit_footprint = (task_iokit_footprint_ledger_entry.le_credit - task_iokit_footprint_ledger_entry.le_debit) / page_size
    phys_footprint = (task_phys_footprint_ledger_entry.le_credit - task_phys_footprint_ledger_entry.le_debit) / page_size
    phys_footprint_limit = task_phys_footprint_ledger_entry.le_limit / page_size
    ledger_peak = CalculateLedgerPeak(task_phys_footprint_ledger_entry)
    phys_footprint_spike = ledger_peak / page_size

    format_string = <span class="enscript-string">'{0: &gt;8d} {1: &gt;22d} {2: &gt;22d} {3: #011x} {4: #011x} {5: &gt;12d} {6: &gt;10d} {7: &gt;13d}'</span>
    out_str += format_string.format(proc_val.p_pid, proc_val.p_memstat_effectivepriority,
        proc_val.p_memstat_requestedpriority, proc_val.p_memstat_state, proc_val.p_memstat_userdata,
        phys_mem_footprint, iokit_footprint, phys_footprint)
    <span class="enscript-keyword">if</span> phys_footprint != phys_footprint_spike:
        out_str += <span class="enscript-string">&quot;{: ^12d}&quot;</span>.format(phys_footprint_spike)
    <span class="enscript-keyword">else</span>:
        out_str += <span class="enscript-string">&quot;{: ^12s}&quot;</span>.format(<span class="enscript-string">'-'</span>)
    out_str += <span class="enscript-string">&quot;{: 8d}  {: &lt;20s}\n&quot;</span>.format(phys_footprint_limit, proc_val.p_comm)
    <span class="enscript-keyword">return</span> out_str        

@lldb_command(<span class="enscript-string">'showmemorystatus'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowMemoryStatus</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to display each entry in jetsam list with a summary of pressure statistics
         Usage: showmemorystatus
    &quot;&quot;&quot;</span>
    bucket_index = 0
    bucket_count = 20
    <span class="enscript-keyword">print</span> GetMemoryStatusNode.header
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{: &gt;91s} {: &gt;10s} {: &gt;13s} {: ^10s} {: &gt;8s}\n&quot;</span>.format(<span class="enscript-string">&quot;(pages)&quot;</span>, <span class="enscript-string">&quot;(pages)&quot;</span>, <span class="enscript-string">&quot;(pages)&quot;</span>,
        <span class="enscript-string">&quot;(pages)&quot;</span>, <span class="enscript-string">&quot;(pages)&quot;</span>)
    <span class="enscript-keyword">while</span> bucket_index &lt; bucket_count:
        current_bucket = kern.globals.memstat_bucket[bucket_index]
        current_list = current_bucket.list
        current_proc = Cast(current_list.tqh_first, <span class="enscript-string">'proc *'</span>)
        <span class="enscript-keyword">while</span> unsigned(current_proc) != 0:
            <span class="enscript-keyword">print</span> GetMemoryStatusNode(current_proc)
            current_proc = current_proc.p_memstat_list.tqe_next
        bucket_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n\n&quot;</span>
    Memstats()
    
<span class="enscript-comment"># EndMacro: showmemorystatus
</span>
<span class="enscript-comment"># Macro: zprint
</span>
@lldb_type_summary([<span class="enscript-string">'zone'</span>,<span class="enscript-string">'zone_t'</span>])
@header(<span class="enscript-string">&quot;{:^18s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s}({:&gt;6s} {:&gt;6s} {:&gt;6s}) {:^15s} {:&lt;20s}&quot;</span>.format(
<span class="enscript-string">'ZONE'</span>, <span class="enscript-string">'TOT_SZ'</span>, <span class="enscript-string">'PAGE_COUNT'</span>, <span class="enscript-string">'ALLOC_ELTS'</span>, <span class="enscript-string">'FREE_ELTS'</span>, <span class="enscript-string">'FREE_SZ'</span>, <span class="enscript-string">'ELT_SZ'</span>, <span class="enscript-string">'ALLOC'</span>, <span class="enscript-string">'ELTS'</span>, <span class="enscript-string">'PGS'</span>, <span class="enscript-string">'WASTE'</span>, <span class="enscript-string">'FLAGS'</span>, <span class="enscript-string">'NAME'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetZoneSummary</span>(zone):
    <span class="enscript-string">&quot;&quot;&quot; Summarize a zone with important information. See help zprint for description of each field
        params: 
          zone: value - obj representing a zone in kernel
        returns: 
          str - summary of the zone
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>
    format_string = <span class="enscript-string">'{:#018x} {:10d} {:10d} {:10d} {:10d} {:10d} {:10d} {:10d} {:6d} {:6d} {:6d}  {markings} {name:s} '</span>
    pagesize = kern.globals.page_size
    
    free_elements = zone.countfree
    free_size = free_elements * zone.elem_size
    
    alloc_pages = zone.alloc_size / pagesize
    <span class="enscript-keyword">if</span> zone.use_page_list :
        metadata_size = sizeof(<span class="enscript-string">'struct zone_page_metadata'</span>)
        metadata_offset = metadata_size
        <span class="enscript-keyword">if</span> ((metadata_size % zone.elem_size) != 0) :
            metadata_offset += zone.elem_size - (metadata_size % zone.elem_size)
        alloc_count = ((pagesize - metadata_offset) / zone.elem_size) * alloc_pages
        alloc_waste = metadata_offset * alloc_pages
    <span class="enscript-keyword">else</span> :
        alloc_count = zone.alloc_size / zone.elem_size
        alloc_waste = zone.alloc_size  % zone.elem_size

    marks = [
            [<span class="enscript-string">&quot;collectable&quot;</span>,                 <span class="enscript-string">&quot;C&quot;</span>],
            [<span class="enscript-string">&quot;expandable&quot;</span>,                  <span class="enscript-string">&quot;X&quot;</span>],
            [<span class="enscript-string">&quot;noencrypt&quot;</span>,                   <span class="enscript-string">&quot;$&quot;</span>],
            [<span class="enscript-string">&quot;caller_acct&quot;</span>,                 <span class="enscript-string">&quot;@&quot;</span>],
            [<span class="enscript-string">&quot;exhaustible&quot;</span>,                 <span class="enscript-string">&quot;H&quot;</span>],
            [<span class="enscript-string">&quot;allows_foreign&quot;</span>,              <span class="enscript-string">&quot;F&quot;</span>],
            [<span class="enscript-string">&quot;async_prio_refill&quot;</span>,           <span class="enscript-string">&quot;R&quot;</span>],
            [<span class="enscript-string">&quot;no_callout&quot;</span>,                  <span class="enscript-string">&quot;O&quot;</span>],
            [<span class="enscript-string">&quot;zleak_on&quot;</span>,                    <span class="enscript-string">&quot;L&quot;</span>],
            [<span class="enscript-string">&quot;doing_alloc_without_vm_priv&quot;</span>, <span class="enscript-string">&quot;A&quot;</span>],
            [<span class="enscript-string">&quot;doing_alloc_with_vm_priv&quot;</span>,    <span class="enscript-string">&quot;S&quot;</span>],
            [<span class="enscript-string">&quot;waiting&quot;</span>,                     <span class="enscript-string">&quot;W&quot;</span>],
            [<span class="enscript-string">&quot;doing_gc&quot;</span>,                    <span class="enscript-string">&quot;G&quot;</span>],
            [<span class="enscript-string">&quot;use_page_list&quot;</span>,               <span class="enscript-string">&quot;P&quot;</span>]
            ]
    <span class="enscript-keyword">if</span> kern.arch == <span class="enscript-string">'x86_64'</span>:
        marks.append([<span class="enscript-string">&quot;gzalloc_exempt&quot;</span>,     <span class="enscript-string">&quot;M&quot;</span>])
        marks.append([<span class="enscript-string">&quot;alignment_required&quot;</span>, <span class="enscript-string">&quot;N&quot;</span>])
        
    markings=<span class="enscript-string">&quot;&quot;</span>
    <span class="enscript-keyword">for</span> mark <span class="enscript-keyword">in</span> marks:
        <span class="enscript-keyword">if</span> zone.__getattr__(mark[0]) :
            markings+=mark[1]
        <span class="enscript-keyword">else</span>:
            markings+=<span class="enscript-string">&quot; &quot;</span>
    out_string += format_string.format(zone, zone.cur_size, zone.page_count,
                    zone.count, free_elements, free_size,
                    zone.elem_size, zone.alloc_size, alloc_count,
                    alloc_pages, alloc_waste, name = zone.zone_name, markings=markings)
    
    <span class="enscript-keyword">if</span> zone.exhaustible :
            out_string += <span class="enscript-string">&quot;(max: {:d})&quot;</span>.format(zone.max_size)
            
    <span class="enscript-keyword">return</span> out_string

@lldb_command(<span class="enscript-string">'zprint'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">Zprint</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the kernel zones
    All columns are printed in decimal
    Legend:
        C - collectable
        X - expandable
        $ - not encrypted during hibernation
        @ - allocs and frees are accounted to caller process for KPRVT
        H - exhaustible
        F - allows foreign memory (memory not allocated from zone_map)
        M - gzalloc will avoid monitoring this zone
        R - will be refilled when below low water mark
        O - does not allow refill callout to fill zone on noblock allocation
        N - zone requires alignment (avoids padding this zone for debugging)
        A - currently trying to allocate more backing memory from kernel_memory_allocate without VM priv
        S - currently trying to allocate more backing memory from kernel_memory_allocate with VM priv
        W - another thread is waiting for more memory
        L - zone is being monitored by zleaks
        G - currently running GC
        P - uses zone_page_metadata
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">global</span> kern
    <span class="enscript-keyword">print</span> GetZoneSummary.header
    <span class="enscript-keyword">for</span> zval <span class="enscript-keyword">in</span> kern.zones:
        <span class="enscript-keyword">print</span> GetZoneSummary(zval)

@xnudebug_test(<span class="enscript-string">'test_zprint'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">TestZprint</span>(kernel_target, config, lldb_obj, isConnected ):
    <span class="enscript-string">&quot;&quot;&quot; Test the functionality of zprint command
        returns 
         - False on failure
         - True on success 
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> isConnected:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Target is not connected. Cannot test memstats&quot;</span>
        <span class="enscript-keyword">return</span> False
    res = lldb.SBCommandReturnObject()
    lldb_obj.debugger.GetCommandInterpreter().HandleCommand(<span class="enscript-string">&quot;zprint&quot;</span>, res)
    result = res.GetOutput()
    <span class="enscript-keyword">if</span> len(result.split(<span class="enscript-string">&quot;\n&quot;</span>)) &gt; 2:
        <span class="enscript-keyword">return</span> True
    <span class="enscript-keyword">else</span>: 
        <span class="enscript-keyword">return</span> False


<span class="enscript-comment"># EndMacro: zprint
</span>
<span class="enscript-comment"># Macro: showzfreelist
</span>
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZfreeListHeader</span>(zone):
    <span class="enscript-string">&quot;&quot;&quot; Helper routine to print a header for zone freelist.
        (Since the freelist does not have a custom type, this is not defined as a Type Summary).
        params:
            zone:zone_t - Zone object to print header info
        returns:
            None
    &quot;&quot;&quot;</span>
    
    scaled_factor = (unsigned(kern.globals.zp_factor) +
            (unsigned(zone.elem_size) &gt;&gt; unsigned(kern.globals.zp_scale)))

    out_str = <span class="enscript-string">&quot;&quot;</span>
    out_str += <span class="enscript-string">&quot;{0: &lt;9s} {1: &lt;12s} {2: &lt;18s} {3: &lt;18s} {4: &lt;6s}\n&quot;</span>.format(<span class="enscript-string">'ELEM_SIZE'</span>, <span class="enscript-string">'COUNT'</span>, <span class="enscript-string">'NCOOKIE'</span>, <span class="enscript-string">'PCOOKIE'</span>, <span class="enscript-string">'FACTOR'</span>)
    out_str += <span class="enscript-string">&quot;{0: &lt;9d} {1: &lt;12d} 0x{2:0&gt;16x} 0x{3:0&gt;16x} {4: &lt;2d}/{5: &lt;2d}\n\n&quot;</span>.format(
                zone.elem_size, zone.count, kern.globals.zp_nopoison_cookie, kern.globals.zp_poisoned_cookie, zone.zp_count, scaled_factor)
    out_str += <span class="enscript-string">&quot;{0: &lt;7s} {1: &lt;18s} {2: &lt;18s} {3: &lt;18s} {4: &lt;18s} {5: &lt;18s} {6: &lt;14s}\n&quot;</span>.format(
                <span class="enscript-string">'NUM'</span>, <span class="enscript-string">'ELEM'</span>, <span class="enscript-string">'NEXT'</span>, <span class="enscript-string">'BACKUP'</span>, <span class="enscript-string">'^ NCOOKIE'</span>, <span class="enscript-string">'^ PCOOKIE'</span>, <span class="enscript-string">'POISON (PREV)'</span>)
    <span class="enscript-keyword">print</span> out_str

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZfreeListChain</span>(zone, zfirst, zlimit):
    <span class="enscript-string">&quot;&quot;&quot; Helper routine to print a zone free list chain
        params:
            zone: zone_t - Zone object
            zfirst: void * - A pointer to the first element of the free list chain
            zlimit: int - Limit for the number of elements to be printed by showzfreelist
        returns:
            None
    &quot;&quot;&quot;</span>
    current = Cast(zfirst, <span class="enscript-string">'void *'</span>)
    <span class="enscript-keyword">while</span> ShowZfreeList.elts_found &lt; zlimit:
        ShowZfreeList.elts_found += 1
        znext = dereference(Cast(current, <span class="enscript-string">'vm_offset_t *'</span>))
        backup_ptr = kern.GetValueFromAddress((unsigned(Cast(current, <span class="enscript-string">'vm_offset_t'</span>)) + unsigned(zone.elem_size) - sizeof(<span class="enscript-string">'vm_offset_t'</span>)), <span class="enscript-string">'vm_offset_t *'</span>)
        backup_val = dereference(backup_ptr)
        n_unobfuscated = (unsigned(backup_val) ^ unsigned(kern.globals.zp_nopoison_cookie))
        p_unobfuscated = (unsigned(backup_val) ^ unsigned(kern.globals.zp_poisoned_cookie))
        poison_str = <span class="enscript-string">''</span>
        <span class="enscript-keyword">if</span> p_unobfuscated == unsigned(znext):
            poison_str = <span class="enscript-string">&quot;P ({0: &lt;d})&quot;</span>.format(ShowZfreeList.elts_found - ShowZfreeList.last_poisoned)
            ShowZfreeList.last_poisoned = ShowZfreeList.elts_found
        <span class="enscript-keyword">else</span>:
            <span class="enscript-keyword">if</span> n_unobfuscated != unsigned(znext):
                poison_str = <span class="enscript-string">&quot;INVALID&quot;</span>
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{0: &lt;7d} 0x{1:0&gt;16x} 0x{2:0&gt;16x} 0x{3:0&gt;16x} 0x{4:0&gt;16x} 0x{5:0&gt;16x} {6: &lt;14s}\n&quot;</span>.format(
              ShowZfreeList.elts_found, unsigned(current), unsigned(znext), unsigned(backup_val), n_unobfuscated, p_unobfuscated, poison_str)
        <span class="enscript-keyword">if</span> unsigned(znext) == 0:
            <span class="enscript-keyword">break</span>
        current = Cast(znext, <span class="enscript-string">'void *'</span>)

@static_var(<span class="enscript-string">'elts_found'</span>,0)
@static_var(<span class="enscript-string">'last_poisoned'</span>,0)
@lldb_command(<span class="enscript-string">'showzfreelist'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZfreeList</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Walk the freelist for a zone, printing out the primary and backup next pointers, the poisoning cookies, and the poisoning status of each element.
    Usage: showzfreelist &lt;zone&gt; [iterations]

        Will walk up to 50 elements by default, pass a limit in 'iterations' to override.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZfreeList.__doc__
        <span class="enscript-keyword">return</span>
    ShowZfreeList.elts_found = 0
    ShowZfreeList.last_poisoned = 0

    zone = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'struct zone *'</span>)
    zlimit = 50
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        zlimit = ArgumentStringToInt(cmd_args[1])
    ShowZfreeListHeader(zone)

    <span class="enscript-keyword">if</span> unsigned(zone.use_page_list) == 1:
        <span class="enscript-keyword">if</span> unsigned(zone.allows_foreign) == 1:
            <span class="enscript-keyword">for</span> free_page_meta <span class="enscript-keyword">in</span> IterateQueue(zone.pages.any_free_foreign, <span class="enscript-string">'struct zone_page_metadata *'</span>, <span class="enscript-string">'pages'</span>):
                <span class="enscript-keyword">if</span> ShowZfreeList.elts_found == zlimit:
                    <span class="enscript-keyword">break</span>
                zfirst = Cast(free_page_meta.elements, <span class="enscript-string">'void *'</span>)
                <span class="enscript-keyword">if</span> unsigned(zfirst) != 0:
                    ShowZfreeListChain(zone, zfirst, zlimit)
        <span class="enscript-keyword">for</span> free_page_meta <span class="enscript-keyword">in</span> IterateQueue(zone.pages.intermediate, <span class="enscript-string">'struct zone_page_metadata *'</span>, <span class="enscript-string">'pages'</span>):
            <span class="enscript-keyword">if</span> ShowZfreeList.elts_found == zlimit:
                <span class="enscript-keyword">break</span>
            zfirst = Cast(free_page_meta.elements, <span class="enscript-string">'void *'</span>)
            <span class="enscript-keyword">if</span> unsigned(zfirst) != 0:
                ShowZfreeListChain(zone, zfirst, zlimit)
        <span class="enscript-keyword">for</span> free_page_meta <span class="enscript-keyword">in</span> IterateQueue(zone.pages.all_free, <span class="enscript-string">'struct zone_page_metadata *'</span>, <span class="enscript-string">'pages'</span>):
            <span class="enscript-keyword">if</span> ShowZfreeList.elts_found == zlimit:
                <span class="enscript-keyword">break</span>
            zfirst = Cast(free_page_meta.elements, <span class="enscript-string">'void *'</span>)
            <span class="enscript-keyword">if</span> unsigned(zfirst) != 0:
                ShowZfreeListChain(zone, zfirst, zlimit)
    <span class="enscript-keyword">else</span>:
        zfirst = Cast(zone.free_elements, <span class="enscript-string">'void *'</span>)
        <span class="enscript-keyword">if</span> unsigned(zfirst) != 0:
            ShowZfreeListChain(zone, zfirst, zlimit)
    
    <span class="enscript-keyword">if</span> ShowZfreeList.elts_found == zlimit:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Stopped at {0: &lt;d} elements!&quot;</span>.format(zlimit)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Found {0: &lt;d} elements!&quot;</span>.format(ShowZfreeList.elts_found)

<span class="enscript-comment"># EndMacro: showzfreelist
</span>
<span class="enscript-comment"># Macro: zstack
</span>
@lldb_command(<span class="enscript-string">'zstack'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">Zstack</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Zone leak debugging: Print the stack trace of log element at &lt;index&gt;. If a &lt;count&gt; is supplied, it prints &lt;count&gt; log elements starting at &lt;index&gt;.
        Usage: zstack &lt;index&gt; [&lt;count&gt;]

        The suggested usage is to look at indexes below zcurrent and look for common stack traces.
        The stack trace that occurs the most is probably the cause of the leak.  Find the pc of the
        function calling into zalloc and use the countpcs command to find out how often that pc occurs in the log.
        The pc occuring in a high percentage of records is most likely the source of the leak.
        
        The findoldest command is also useful for leak debugging since it identifies the oldest record
        in the log, which may indicate the leaker.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> Zstack.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.log_records) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging not enabled. Add 'zlog=&lt;zone name&gt;' to boot-args.&quot;</span>
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.zlog_btlog) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging enabled, but zone has not been initialized yet.&quot;</span>
        <span class="enscript-keyword">return</span>

    count = 1
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        count = ArgumentStringToInt(cmd_args[1])
    zstack_index = unsigned(cmd_args[0])
    <span class="enscript-keyword">while</span> count <span class="enscript-keyword">and</span> (zstack_index != 0xffffff):
        zstack_record_offset = zstack_index * unsigned(kern.globals.zlog_btlog.btrecord_size)
        zstack_record = kern.GetValueFromAddress(unsigned(kern.globals.zlog_btlog.btrecords) + zstack_record_offset, <span class="enscript-string">'btlog_record_t *'</span>)
        ShowZStackRecord(zstack_record, zstack_index)
        zstack_index = zstack_record.next
        count -= 1

<span class="enscript-comment"># EndMacro : zstack
</span>
<span class="enscript-comment"># Macro: findoldest
</span>
@lldb_command(<span class="enscript-string">'findoldest'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindOldest</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Zone leak debugging: find and print the oldest record in the log.
        
        Once it prints a stack trace, find the pc of the caller above all the zalloc, kalloc and
        IOKit layers.  Then use the countpcs command to see how often this caller has allocated
        memory.  A caller with a high percentage of records in the log is probably the leaker.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> int(kern.globals.log_records) == 0:
        <span class="enscript-keyword">print</span> FindOldest.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.zlog_btlog) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging enabled, but zone has not been initialized yet.&quot;</span>
        <span class="enscript-keyword">return</span>
    index = kern.globals.zlog_btlog.head
    <span class="enscript-keyword">if</span> unsigned(index) != 0xffffff:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Oldest record is at log index: {0: &lt;d}&quot;</span>.format(index)
        Zstack([index])
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;No Records Present&quot;</span>

<span class="enscript-comment"># EndMacro : findoldest
</span>
<span class="enscript-comment"># Macro: countpcs
</span>
@lldb_command(<span class="enscript-string">'countpcs'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">Countpcs</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Zone leak debugging: search the log and print a count of all log entries that contain the given &lt;pc&gt;
        in the stack trace.
        Usage: countpcs &lt;pc&gt;

        This is useful for verifying a suspected &lt;pc&gt; as being the source of
        the leak.  If a high percentage of the log entries contain the given &lt;pc&gt;, then it's most
        likely the source of the leak.  Note that this command can take several minutes to run.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> Countpcs.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.log_records) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging not enabled. Add 'zlog=&lt;zone name&gt;' to boot-args.&quot;</span>
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.zlog_btlog) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging enabled, but zone has not been initialized yet.&quot;</span>
        <span class="enscript-keyword">return</span>
    
    cpcs_index = unsigned(kern.globals.zlog_btlog.head)
    target_pc = unsigned(kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'void *'</span>))
    found = 0
    depth = unsigned(kern.globals.zlog_btlog.btrecord_btdepth)

    <span class="enscript-keyword">while</span> cpcs_index != 0xffffff:
        cpcs_record_offset = cpcs_index * unsigned(kern.globals.zlog_btlog.btrecord_size)
        cpcs_record = kern.GetValueFromAddress(unsigned(kern.globals.zlog_btlog.btrecords) + cpcs_record_offset, <span class="enscript-string">'btlog_record_t *'</span>)
        frame = 0
        <span class="enscript-keyword">while</span> frame &lt; depth:
            frame_pc = unsigned(cpcs_record.bt[frame])
            <span class="enscript-keyword">if</span> frame_pc == target_pc:
                found += 1
                <span class="enscript-keyword">break</span>
            frame += 1
        cpcs_index = cpcs_record.next
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Occured {0: &lt;d} times in log ({1: &lt;d}{2: &lt;s} of records)&quot;</span>.format(found, (found * 100)/unsigned(kern.globals.zlog_btlog.activecount), <span class="enscript-string">'%'</span>)

<span class="enscript-comment"># EndMacro: countpcs
</span>
<span class="enscript-comment"># Macro: findelem
</span>
@lldb_command(<span class="enscript-string">'findelem'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindElem</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Zone corruption debugging: search the log and print out the stack traces for all log entries that
        refer to the given zone element.  
        Usage: findelem &lt;elem addr&gt;

        When the kernel panics due to a corrupted zone element, get the
        element address and use this command.  This will show you the stack traces of all logged zalloc and
        zfree operations which tells you who touched the element in the recent past.  This also makes
        double-frees readily apparent.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> FindElem.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.log_records) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging not enabled. Add 'zlog=&lt;zone name&gt;' to boot-args.&quot;</span>
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(kern.globals.zlog_btlog) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Zone logging enabled, but zone has not been initialized yet.&quot;</span>
        <span class="enscript-keyword">return</span>
  
    target_element = unsigned(kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'void *'</span>))
    index = unsigned(kern.globals.zlog_btlog.head)
    prev_op = -1

    <span class="enscript-keyword">while</span> index != 0xffffff:
        findelem_record_offset = index * unsigned(kern.globals.zlog_btlog.btrecord_size)
        findelem_record = kern.GetValueFromAddress(unsigned(kern.globals.zlog_btlog.btrecords) + findelem_record_offset, <span class="enscript-string">'btlog_record_t *'</span>)
        <span class="enscript-keyword">if</span> unsigned(findelem_record.element) == target_element:
            Zstack([index])
            <span class="enscript-keyword">if</span> int(findelem_record.operation) == prev_op:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{0: &lt;s} DOUBLE OP! {1: &lt;s}&quot;</span>.format((<span class="enscript-string">'*'</span> * 8), (<span class="enscript-string">'*'</span> * 8))
                prev_op = int(findelem_record.operation)
        index = findelem_record.next

<span class="enscript-comment"># EndMacro: findelem
</span>
<span class="enscript-comment"># Macro: btlog_find
</span>
@lldb_command(<span class="enscript-string">'btlog_find'</span>, <span class="enscript-string">&quot;AS&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">BtlogFind</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Search the btlog_t for entries corresponding to the given element.
        Use -A flag to print all entries.
        Use -S flag to summarize the count of records
        Usage: btlog_find &lt;btlog_t&gt; &lt;element&gt;
        Usage: btlog_find &lt;btlog_t&gt; -A 
        Note: Backtraces will be in chronological order, with oldest entries aged out in FIFO order as needed.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Need a btlog_t parameter&quot;</span>)
    btlog = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'btlog_t *'</span>)
    printall = False
    summarize = False
    summary_cache = {}
    target_elem = 0xffffffff

    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-A&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        printall = True
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> printall <span class="enscript-keyword">and</span> len(cmd_args) &lt; 2:
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;&lt;element&gt; is missing in args. Need a search pointer.&quot;</span>)
        target_elem = unsigned(kern.GetValueFromAddress(cmd_args[1], <span class="enscript-string">'void *'</span>))
    
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        summarize = True

    index = unsigned(btlog.head)
    progress = 0
    record_size = unsigned(btlog.btrecord_size)
    <span class="enscript-keyword">try</span>:
        <span class="enscript-keyword">while</span> index != 0xffffff:
            record_offset = index * record_size
            record = kern.GetValueFromAddress(unsigned(btlog.btrecords) + record_offset, <span class="enscript-string">'btlog_record_t *'</span>)
            <span class="enscript-keyword">if</span> printall <span class="enscript-keyword">or</span> unsigned(record.element) == target_elem:
                _s = <span class="enscript-string">'{0: &lt;s} {2: &lt;#0x} OP {1: &lt;d} {3: &lt;s}'</span>.format((<span class="enscript-string">'-'</span> * 8), record.operation, unsigned(record.element), (<span class="enscript-string">'-'</span> * 8))
                _s += GetBtlogBacktrace(btlog.btrecord_btdepth, record)
                <span class="enscript-keyword">if</span> summarize:
                    <span class="enscript-keyword">if</span> _s <span class="enscript-keyword">not</span> <span class="enscript-keyword">in</span> summary_cache:
                        summary_cache[_s] = 1
                    <span class="enscript-keyword">else</span>:
                        summary_cache[_s] += 1
                <span class="enscript-keyword">else</span> :
                    <span class="enscript-keyword">print</span> _s
            index = record.next
            progress += 1
            <span class="enscript-keyword">if</span> (progress % 1000) == 0: <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;d} entries searched!\n'</span>.format(progress)
    <span class="enscript-keyword">except</span> ValueError, e:
        <span class="enscript-keyword">pass</span>
    
    <span class="enscript-keyword">if</span> summarize:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;=================== SUMMARY ==================&quot;</span>
        <span class="enscript-keyword">for</span> (k,v) <span class="enscript-keyword">in</span> summary_cache.iteritems():
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Count: %d %s \n &quot;</span> % (v, k)
    <span class="enscript-keyword">return</span>

<span class="enscript-comment">#EndMacro: btlog_find
</span>
<span class="enscript-comment">#Macro: showzalloc
</span>
@lldb_command(<span class="enscript-string">'showzalloc'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZalloc</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints a zallocation from the zallocations array based off its index and prints the associated symbolicated backtrace.
        Usage: showzalloc &lt;index&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZalloc.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> unsigned(kern.globals.zallocations) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;zallocations array not initialized!&quot;</span>
        <span class="enscript-keyword">return</span>
    zallocation = kern.globals.zallocations[ArgumentStringToInt(cmd_args[0])]
    <span class="enscript-keyword">print</span> zallocation
    ShowZTrace([str(int(zallocation.za_trace_index))])

<span class="enscript-comment">#EndMacro: showzalloc
</span>
<span class="enscript-comment">#Macro: showztrace
</span>
@lldb_command(<span class="enscript-string">'showztrace'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZTrace</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the backtrace from the ztraces array at index
        Usage: showztrace &lt;trace index&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZTrace.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> unsigned(kern.globals.ztraces) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;ztraces array not initialized!&quot;</span>
        <span class="enscript-keyword">return</span>
    ztrace_addr = kern.globals.ztraces[ArgumentStringToInt(cmd_args[0])]
    <span class="enscript-keyword">print</span> ztrace_addr
    ShowZstackTraceHelper(ztrace_addr.zt_stack, ztrace_addr.zt_depth)

<span class="enscript-comment">#EndMacro: showztrace
</span>
<span class="enscript-comment">#Macro: showztraceaddr
</span>
@lldb_command(<span class="enscript-string">'showztraceaddr'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZTraceAddr</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the struct ztrace passed in.
        Usage: showztraceaddr &lt;trace address&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZTraceAddr.__doc__
        <span class="enscript-keyword">return</span>
    ztrace_ptr = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'struct ztrace *'</span>)
    <span class="enscript-keyword">print</span> dereference(ztrace_ptr)
    ShowZstackTraceHelper(ztrace_ptr.zt_stack, ztrace_ptr.zt_depth)

<span class="enscript-comment">#EndMacro: showztraceaddr
</span>
<span class="enscript-comment">#Macro: showzstacktrace
</span>
@lldb_command(<span class="enscript-string">'showzstacktrace'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZstackTrace</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a stacktrace stored by OSBacktrace.
        Usage: showzstacktrace &lt;saved stacktrace&gt; [size]

        size is optional, defaults to 15.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZstackTrace.__doc__
        <span class="enscript-keyword">return</span>
    void_ptr_type = gettype(<span class="enscript-string">'void *'</span>)
    void_double_ptr_type = void_ptr_type.GetPointerType()
    trace = kern.GetValueFromAddress(cmd_args[0], void_double_ptr_type)
    trace_size = 15
    <span class="enscript-keyword">if</span> len(cmd_args) &gt;= 2:
        trace_size = ArgumentStringToInt(cmd_args[1])
    ShowZstackTraceHelper(trace, trace_size)
    
<span class="enscript-comment">#EndMacro: showzstacktrace
</span>
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZstackTraceHelper</span>(stack, depth):
    <span class="enscript-string">&quot;&quot;&quot; Helper routine for printing a zstack.
        params:
            stack: void *[] - An array of pointers representing the Zstack
            depth: int - The depth of the ztrace stack 
        returns:
            None
    &quot;&quot;&quot;</span>
    trace_current = 0
    <span class="enscript-keyword">while</span> trace_current &lt; depth:
        trace_addr = stack[trace_current]
        symbol_arr = kern.SymbolicateFromAddress(unsigned(trace_addr))
        <span class="enscript-keyword">if</span> symbol_arr:
            symbol_str = str(symbol_arr[0].addr)
        <span class="enscript-keyword">else</span>:
            symbol_str = <span class="enscript-string">''</span>
        <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;#x} {1: &lt;s}'</span>.format(trace_addr, symbol_str)
        trace_current += 1

<span class="enscript-comment">#Macro: showtopztrace
</span>
@lldb_command(<span class="enscript-string">'showtopztrace'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTopZtrace</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Shows the ztrace with the biggest size. 
        (According to top_ztrace, not by iterating through the hash table)
    &quot;&quot;&quot;</span>
    top_trace = kern.globals.top_ztrace
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Index: {0: &lt;d}'</span>.format((unsigned(top_trace) - unsigned(kern.globals.ztraces)) / sizeof(<span class="enscript-string">'struct ztrace'</span>))
    <span class="enscript-keyword">print</span> dereference(top_trace)
    ShowZstackTraceHelper(top_trace.zt_stack, top_trace.zt_depth)

<span class="enscript-comment">#EndMacro: showtopztrace
</span>
<span class="enscript-comment">#Macro: showzallocs
</span>
@lldb_command(<span class="enscript-string">'showzallocs'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZallocs</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints all allocations in the zallocations table
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> unsigned(kern.globals.zallocations) == 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;zallocations array not initialized!&quot;</span>
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5s} {1: &lt;18s} {2: &lt;5s} {3: &lt;15s}'</span>.format(<span class="enscript-string">'INDEX'</span>,<span class="enscript-string">'ADDRESS'</span>,<span class="enscript-string">'TRACE'</span>,<span class="enscript-string">'SIZE'</span>) 
    current_index = 0
    max_zallocation = unsigned(kern.globals.zleak_alloc_buckets)
    allocation_count = 0
    <span class="enscript-keyword">while</span> current_index &lt; max_zallocation:
        current_zalloc = kern.globals.zallocations[current_index]
        <span class="enscript-keyword">if</span> int(current_zalloc.za_element) != 0:
            <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;#018x} {2: &lt;5d} {3: &lt;15d}'</span>.format(current_index, current_zalloc.za_element, current_zalloc.za_trace_index, unsigned(current_zalloc.za_size))
            allocation_count += 1
        current_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Total Allocations: {0: &lt;d}'</span>.format(allocation_count)

<span class="enscript-comment">#EndMacro: showzallocs
</span>
<span class="enscript-comment">#Macro: showzallocsfortrace
</span>
@lldb_command(<span class="enscript-string">'showzallocsfortrace'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZallocsForTrace</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints all allocations pointing to the passed in trace's index into ztraces by looking through zallocations table
        Usage:  showzallocsfortrace &lt;trace index&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZallocsForTrace.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5s} {1: &lt;18s} {2: &lt;15s}'</span>.format(<span class="enscript-string">'INDEX'</span>,<span class="enscript-string">'ADDRESS'</span>,<span class="enscript-string">'SIZE'</span>) 
    target_index = ArgumentStringToInt(cmd_args[0])
    current_index = 0
    max_zallocation = unsigned(kern.globals.zleak_alloc_buckets)
    allocation_count = 0
    <span class="enscript-keyword">while</span> current_index &lt; max_zallocation:
        current_zalloc = kern.globals.zallocations[current_index]
        <span class="enscript-keyword">if</span> unsigned(current_zalloc.za_element) != 0 <span class="enscript-keyword">and</span> (unsigned(current_zalloc.za_trace_index) == unsigned(target_index)):
            <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;#018x} {2: &lt;6d}'</span>.format(current_index, current_zalloc.za_element, current_zalloc.za_size)
            allocation_count += 1
        current_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Total Allocations: {0: &lt;d}'</span>.format(allocation_count)

<span class="enscript-comment">#EndMacro: showzallocsfortrace
</span>
<span class="enscript-comment">#Macro: showztraces
</span>
@lldb_command(<span class="enscript-string">'showztraces'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZTraces</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints all traces with size &gt; 0
    &quot;&quot;&quot;</span>
    ShowZTracesAbove([0])

<span class="enscript-comment">#EndMacro: showztraces
</span>
<span class="enscript-comment">#Macro: showztracesabove
</span>
@lldb_command(<span class="enscript-string">'showztracesabove'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZTracesAbove</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints all traces with size greater than X
        Usage: showztracesabove &lt;size&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowZTracesAbove.__doc__
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5s} {1: &lt;6s}'</span>.format(<span class="enscript-string">'INDEX'</span>,<span class="enscript-string">'SIZE'</span>)
    current_index = 0
    ztrace_count = 0
    max_ztrace = unsigned(kern.globals.zleak_trace_buckets)
    <span class="enscript-keyword">while</span> current_index &lt; max_ztrace:
        ztrace_current = kern.globals.ztraces[current_index]
        <span class="enscript-keyword">if</span> ztrace_current.zt_size &gt; unsigned(cmd_args[0]):
            <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;6d}'</span>.format(current_index, int(ztrace_current.zt_size))
            ztrace_count += 1
        current_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Total traces: {0: &lt;d}'</span>.format(ztrace_count)

<span class="enscript-comment">#EndMacro: showztracesabove
</span>
<span class="enscript-comment">#Macro: showztracehistogram
</span>
@lldb_command(<span class="enscript-string">'showztracehistogram'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZtraceHistogram</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the histogram of the ztrace table
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5s} {1: &lt;9s} {2: &lt;10s}'</span>.format(<span class="enscript-string">'INDEX'</span>,<span class="enscript-string">'HIT_COUNT'</span>,<span class="enscript-string">'COLLISIONS'</span>)
    current_index = 0
    ztrace_count = 0
    max_ztrace = unsigned(kern.globals.zleak_trace_buckets)
    <span class="enscript-keyword">while</span> current_index &lt; max_ztrace:
        ztrace_current = kern.globals.ztraces[current_index]
        <span class="enscript-keyword">if</span> ztrace_current.zt_hit_count != 0:
            <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;9d} {2: &lt;10d}'</span>.format(current_index, ztrace_current.zt_hit_count, ztrace_current.zt_collisions)
            ztrace_count += 1
        current_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Total traces: {0: &lt;d}'</span>.format(ztrace_count)
    
<span class="enscript-comment">#EndMacro: showztracehistogram
</span>
<span class="enscript-comment">#Macro: showzallochistogram
</span>
@lldb_command(<span class="enscript-string">'showzallochistogram'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZallocHistogram</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the histogram for the zalloc table
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5s} {1: &lt;9s}'</span>.format(<span class="enscript-string">'INDEX'</span>,<span class="enscript-string">'HIT_COUNT'</span>)
    current_index = 0
    zallocation_count = 0
    max_ztrace = unsigned(kern.globals.zleak_alloc_buckets)
    <span class="enscript-keyword">while</span> current_index &lt; max_ztrace:
        zallocation_current = kern.globals.zallocations[current_index]
        <span class="enscript-keyword">if</span> zallocation_current.za_hit_count != 0:
            <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;9d}'</span>.format(current_index, zallocation_current.za_hit_count)
            zallocation_count += 1
        current_index += 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">'Total Allocations: {0: &lt;d}'</span>.format(zallocation_count)

<span class="enscript-comment">#EndMacro: showzallochistogram
</span>
<span class="enscript-comment">#Macro: showzstats
</span>
@lldb_command(<span class="enscript-string">'showzstats'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZstats</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the zone leak detection stats
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">'z_alloc_collisions: {0: &lt;d}, z_trace_collisions: {1: &lt;d}'</span>.format(unsigned(kern.globals.z_alloc_collisions), unsigned(kern.globals.z_trace_collisions))
    <span class="enscript-keyword">print</span> <span class="enscript-string">'z_alloc_overwrites: {0: &lt;d}, z_trace_overwrites: {1: &lt;d}'</span>.format(unsigned(kern.globals.z_alloc_overwrites), unsigned(kern.globals.z_trace_overwrites))
    <span class="enscript-keyword">print</span> <span class="enscript-string">'z_alloc_recorded: {0: &lt;d}, z_trace_recorded: {1: &lt;d}'</span>.format(unsigned(kern.globals.z_alloc_recorded), unsigned(kern.globals.z_trace_recorded))

<span class="enscript-comment">#EndMacro: showzstats
</span>
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetBtlogBacktrace</span>(depth, zstack_record):
    <span class="enscript-string">&quot;&quot;&quot; Helper routine for getting a BT Log record backtrace stack.
        params:
            depth:int - The depth of the zstack record
            zstack_record:btlog_record_t * - A BTLog record
        returns:
            str - string with backtrace in it.
    &quot;&quot;&quot;</span>
    out_str = <span class="enscript-string">''</span>
    frame = 0
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> zstack_record:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Zstack record none!&quot;</span>
        
    depth_val = unsigned(depth)
    <span class="enscript-keyword">while</span> frame &lt; depth_val:
        frame_pc = zstack_record.bt[frame]
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> frame_pc <span class="enscript-keyword">or</span> int(frame_pc) == 0:
            <span class="enscript-keyword">break</span>
        symbol_arr = kern.SymbolicateFromAddress(frame_pc)
        <span class="enscript-keyword">if</span> symbol_arr:
            symbol_str = str(symbol_arr[0].addr)
        <span class="enscript-keyword">else</span>:
            symbol_str = <span class="enscript-string">''</span>
        out_str += <span class="enscript-string">&quot;{0: &lt;#0x} &lt;{1: &lt;s}&gt;\n&quot;</span>.format(frame_pc, symbol_str)
        frame += 1
    <span class="enscript-keyword">return</span> out_str

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowZStackRecord</span>(zstack_record, zstack_index):
    <span class="enscript-string">&quot;&quot;&quot; Helper routine for printing a single zstack record
        params:
            zstack_record:btlog_record_t * -  A BTLog record
            zstack_index:int - Index for the record in the BTLog table
        returns:
            None
    &quot;&quot;&quot;</span>
    out_str = (<span class="enscript-string">'-'</span> * 8)
    <span class="enscript-keyword">if</span> zstack_record.operation == 1:
        out_str += <span class="enscript-string">&quot;ALLOC  &quot;</span>
    <span class="enscript-keyword">else</span>:
        out_str += <span class="enscript-string">&quot;FREE   &quot;</span>
    out_str += <span class="enscript-string">&quot;{0: &lt;#0x} : Index {1: &lt;d} {2: &lt;s}\n&quot;</span>.format(zstack_record.element, zstack_index, (<span class="enscript-string">'-'</span> * 8))
    <span class="enscript-keyword">print</span> out_str
    <span class="enscript-keyword">print</span> GetBtlogBacktrace(kern.globals.zlog_btlog.btrecord_btdepth, zstack_record)

<span class="enscript-comment"># Macro: showioalloc
</span>
@lldb_command(<span class="enscript-string">'showioalloc'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowIOAllocations</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Show some accounting of memory allocated by IOKit allocators. See ioalloccount man page for details.
        Routine to display a summary of memory accounting allocated by IOKit allocators.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Instance allocation  = {0: &lt;#0x} = {1: d}K&quot;</span>.format(kern.globals.debug_ivars_size, (kern.globals.debug_ivars_size / 1024))
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Container allocation = {0: &lt;#0x} = {1: d}K&quot;</span>.format(kern.globals.debug_container_malloc_size, (kern.globals.debug_container_malloc_size / 1024))
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;IOMalloc allocation  = {0: &lt;#0x} = {1: d}K&quot;</span>.format(kern.globals.debug_iomalloc_size, (kern.globals.debug_iomalloc_size / 1024))
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Container allocation = {0: &lt;#0x} = {1: d}K&quot;</span>.format(kern.globals.debug_iomallocpageable_size, (kern.globals.debug_iomallocpageable_size / 1024))
    
    
<span class="enscript-comment"># EndMacro: showioalloc    
</span>

<span class="enscript-comment"># Macro: showselectmem
</span>@lldb_command(<span class="enscript-string">'showselectmem'</span>, <span class="enscript-string">&quot;S:&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowSelectMem</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Show memory cached by threads on calls to select.

        usage: showselectmem [-v]
            -v        : print each thread's memory
                        (one line per thread with non-zero select memory)
            -S {addr} : Find the thread whose thread-local select set
                        matches the given address
    &quot;&quot;&quot;</span>
    verbose = False
    opt_wqs = 0
    <span class="enscript-keyword">if</span> config[<span class="enscript-string">'verbosity'</span>] &gt; vHUMAN:
        verbose = True
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        opt_wqs = unsigned(kern.GetValueFromAddress(cmd_options[<span class="enscript-string">&quot;-S&quot;</span>], <span class="enscript-string">'uint64_t *'</span>))
        <span class="enscript-keyword">if</span> opt_wqs == 0:
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Invalid waitq set address: {:s}&quot;</span>.format(cmd_options[<span class="enscript-string">&quot;-S&quot;</span>]))
    selmem = 0
    <span class="enscript-keyword">if</span> verbose:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:18s} {:10s} {:s}&quot;</span>.format(<span class="enscript-string">'Task'</span>, <span class="enscript-string">'Thread ID'</span>, <span class="enscript-string">'Select Mem (bytes)'</span>)
    <span class="enscript-keyword">for</span> t <span class="enscript-keyword">in</span> kern.tasks:
        <span class="enscript-keyword">for</span> th <span class="enscript-keyword">in</span> IterateQueue(t.threads, <span class="enscript-string">'thread *'</span>, <span class="enscript-string">'task_threads'</span>):
            uth = Cast(th.uthread, <span class="enscript-string">'uthread *'</span>);
            wqs = 0
            <span class="enscript-keyword">if</span> hasattr(uth, <span class="enscript-string">'uu_allocsize'</span>): <span class="enscript-comment"># old style
</span>                thmem = uth.uu_allocsize
                wqs = uth.uu_wqset
            <span class="enscript-keyword">elif</span> hasattr(uth, <span class="enscript-string">'uu_wqstate_sz'</span>): <span class="enscript-comment"># new style
</span>                thmem = uth.uu_wqstate_sz
                wqs = uth.uu_wqset
            <span class="enscript-keyword">else</span>:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;What kind of uthread is this?!&quot;</span>
                <span class="enscript-keyword">return</span>
            <span class="enscript-keyword">if</span> opt_wqs <span class="enscript-keyword">and</span> opt_wqs == unsigned(wqs):
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;FOUND: {:#x} in thread: {:#x} ({:#x})&quot;</span>.format(opt_wqs, unsigned(th), unsigned(th.thread_id))
            <span class="enscript-keyword">if</span> verbose <span class="enscript-keyword">and</span> thmem &gt; 0:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&lt;#18x} {:&lt;#10x} {:d}&quot;</span>.format(unsigned(t), unsigned(th.thread_id), thmem)
            selmem += thmem
    <span class="enscript-keyword">print</span> <span class="enscript-string">'-'</span>*40
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Total: {:d} bytes ({:d} kbytes)&quot;</span>.format(selmem, selmem/1024)
<span class="enscript-comment"># Endmacro: showselectmem
</span> 
 
<span class="enscript-comment"># Macro: showtaskvme
</span>@lldb_command(<span class="enscript-string">'showtaskvme'</span>, <span class="enscript-string">&quot;PS&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTaskVmeHelper</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Display a summary list of the specified vm_map's entries
        Usage: showtaskvme &lt;task address&gt;  (ex. showtaskvme 0x00ataskptr00 )
        Use -S flag to show VM object shadow chains
        Use -P flag to show pager info (mapped file, compressed pages, ...)
    &quot;&quot;&quot;</span>
    show_pager_info = False
    show_all_shadows = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-P&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_pager_info = True
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_all_shadows = True
    task = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'task *'</span>)
    ShowTaskVMEntries(task, show_pager_info, show_all_shadows)

@lldb_command(<span class="enscript-string">'showallvme'</span>, <span class="enscript-string">&quot;PS&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllVME</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the vm map entries
        Go Through each task in system and show the vm memory regions
        Use -S flag to show VM object shadow chains
        Use -P flag to show pager info (mapped file, compressed pages, ...)
    &quot;&quot;&quot;</span>
    show_pager_info = False
    show_all_shadows = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-P&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_pager_info = True
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_all_shadows = True
    <span class="enscript-keyword">for</span> task <span class="enscript-keyword">in</span> kern.tasks:
        ShowTaskVMEntries(task, show_pager_info, show_all_shadows)

@lldb_command(<span class="enscript-string">'showallvm'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllVM</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the vm maps
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">for</span> task <span class="enscript-keyword">in</span> kern.tasks:
        <span class="enscript-keyword">print</span> GetTaskSummary.header + <span class="enscript-string">' '</span> + GetProcSummary.header
        <span class="enscript-keyword">print</span> GetTaskSummary(task) + <span class="enscript-string">' '</span> + GetProcSummary(Cast(task.bsd_info, <span class="enscript-string">'proc *'</span>))
        <span class="enscript-keyword">print</span> GetVMMapSummary.header
        <span class="enscript-keyword">print</span> GetVMMapSummary(task.map)

@lldb_command(<span class="enscript-string">&quot;showtaskvm&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTaskVM</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about the specified task's vm_map
        syntax: (lldb) showtaskvm &lt;task_ptr&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> ShowTaskVM.__doc__
        <span class="enscript-keyword">return</span> False
    task = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'task *'</span>)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> task:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Unknown arguments.&quot;</span>
        <span class="enscript-keyword">return</span> False
    <span class="enscript-keyword">print</span> GetTaskSummary.header + <span class="enscript-string">' '</span> + GetProcSummary.header
    <span class="enscript-keyword">print</span> GetTaskSummary(task) + <span class="enscript-string">' '</span> + GetProcSummary(Cast(task.bsd_info, <span class="enscript-string">'proc *'</span>))
    <span class="enscript-keyword">print</span> GetVMMapSummary.header
    <span class="enscript-keyword">print</span> GetVMMapSummary(task.map)
    <span class="enscript-keyword">return</span> True

@lldb_command(<span class="enscript-string">'showallvmstats'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllVMStats</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Print a summary of vm statistics in a table format
    &quot;&quot;&quot;</span>
    page_size = kern.globals.page_size
    vmstats = <span class="enscript-keyword">lambda</span>:None
    vmstats.wired_count = 0
    vmstats.resident_count = 0
    vmstats.resident_max = 0
    vmstats.internal = 0
    vmstats.external = 0
    vmstats.reusable = 0
    vmstats.compressed = 0
    vmstats.compressed_peak = 0
    vmstats.compressed_lifetime = 0
    vmstats.error = <span class="enscript-string">''</span>

    hdr_format = <span class="enscript-string">&quot;{0: &gt;10s} {1: &lt;20s} {2: &gt;6s} {3: &gt;10s} {4: &gt;10s} {5: &gt;10s} {6: &gt;10s} {7: &gt;10s} {8: &gt;10s} {9: &gt;10s} {10: &gt;10s} {11: &gt;10s} {12: &gt;10s} {13: &gt;10s} {14:}&quot;</span>
    <span class="enscript-keyword">print</span> hdr_format.format(<span class="enscript-string">'pid'</span>, <span class="enscript-string">'command'</span>, <span class="enscript-string">'#ents'</span>, <span class="enscript-string">'wired'</span>, <span class="enscript-string">'vsize'</span>, <span class="enscript-string">'rsize'</span>, <span class="enscript-string">'NEW RSIZE'</span>, <span class="enscript-string">'max rsize'</span>, <span class="enscript-string">'internal'</span>, <span class="enscript-string">'external'</span>, <span class="enscript-string">'reusable'</span>, <span class="enscript-string">'compressed'</span>, <span class="enscript-string">'compressed'</span>, <span class="enscript-string">'compressed'</span>, <span class="enscript-string">''</span>)
    <span class="enscript-keyword">print</span> hdr_format.format(<span class="enscript-string">''</span>, <span class="enscript-string">''</span>, <span class="enscript-string">''</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(pages)'</span>, <span class="enscript-string">'(current)'</span>, <span class="enscript-string">'(peak)'</span>, <span class="enscript-string">'(lifetime)'</span>, <span class="enscript-string">''</span>)
    entry_format = <span class="enscript-string">&quot;{p.p_pid: &gt;10d} {p.p_comm: &lt;20s} {m.hdr.nentries: &gt;6d} {s.wired_count: &gt;10d} {vsize: &gt;10d} {s.resident_count: &gt;10d} {s.new_resident_count: &gt;10d} {s.resident_max: &gt;10d} {s.internal: &gt;10d} {s.external: &gt;10d} {s.reusable: &gt;10d} {s.compressed: &gt;10d} {s.compressed_peak: &gt;10d} {s.compressed_lifetime: &gt;10d} {s.error}&quot;</span>

    <span class="enscript-keyword">for</span> task <span class="enscript-keyword">in</span> kern.tasks:
        proc = Cast(task.bsd_info, <span class="enscript-string">'proc *'</span>)
        vmmap = Cast(task.map, <span class="enscript-string">'_vm_map *'</span>)
        vmstats.error = <span class="enscript-string">''</span>
        vmstats.wired_count = vmmap.pmap.stats.wired_count;
        vmstats.resident_count = unsigned(vmmap.pmap.stats.resident_count);
        vmstats.resident_max = vmmap.pmap.stats.resident_max;
        vmstats.internal = unsigned(vmmap.pmap.stats.internal);
        vmstats.external = unsigned(vmmap.pmap.stats.external);
        vmstats.reusable = unsigned(vmmap.pmap.stats.reusable);
        vmstats.compressed = unsigned(vmmap.pmap.stats.compressed);
        vmstats.compressed_peak = unsigned(vmmap.pmap.stats.compressed_peak);
        vmstats.compressed_lifetime = unsigned(vmmap.pmap.stats.compressed_lifetime);
        vmstats.new_resident_count = vmstats.internal + vmstats.external

        <span class="enscript-keyword">if</span> vmstats.internal &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.external &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.reusable &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.compressed &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.compressed_peak &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.compressed_lifetime &lt; 0:
            vmstats.error += <span class="enscript-string">'*'</span>
        <span class="enscript-keyword">if</span> vmstats.new_resident_count +vmstats.reusable != vmstats.resident_count:
            vmstats.error += <span class="enscript-string">'*'</span>

        <span class="enscript-keyword">print</span> entry_format.format(p=proc, m=vmmap, vsize=(unsigned(vmmap.size) / page_size), t=task, s=vmstats)
        

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTaskVMEntries</span>(task, show_pager_info, show_all_shadows):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to print out a summary listing of all the entries in a vm_map
        params: 
            task - core.value : a object of type 'task *'
        returns:
            None
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_map entries for task &quot;</span> + hex(task)
    <span class="enscript-keyword">print</span> GetTaskSummary.header
    <span class="enscript-keyword">print</span> GetTaskSummary(task)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> task.map:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Task {0: &lt;#020x} has map = 0x0&quot;</span>
        <span class="enscript-keyword">return</span> None
    <span class="enscript-keyword">print</span> GetVMMapSummary.header
    <span class="enscript-keyword">print</span> GetVMMapSummary(task.map)
    vme_list_head = task.map.hdr.links
    vme_ptr_type = GetType(<span class="enscript-string">'vm_map_entry *'</span>)
    <span class="enscript-keyword">print</span> GetVMEntrySummary.header
    <span class="enscript-keyword">for</span> vme <span class="enscript-keyword">in</span> IterateQueue(vme_list_head, vme_ptr_type, <span class="enscript-string">&quot;links&quot;</span>):
        <span class="enscript-keyword">print</span> GetVMEntrySummary(vme, show_pager_info, show_all_shadows)
    <span class="enscript-keyword">return</span> None

@lldb_command(<span class="enscript-string">&quot;showmap&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowMap</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print out info about the specified vm_map
        usage: showmap &lt;vm_map&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Invalid argument.&quot;</span>, ShowMap.__doc__
        <span class="enscript-keyword">return</span>
    map_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vm_map_t'</span>)
    <span class="enscript-keyword">print</span> GetVMMapSummary.header
    <span class="enscript-keyword">print</span> GetVMMapSummary(map_val)

@lldb_command(<span class="enscript-string">&quot;showmapvme&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowMapVME</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;Routine to print out info about the specified vm_map and its vm entries
        usage: showmapvme &lt;vm_map&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Invalid argument.&quot;</span>, ShowMap.__doc__
        <span class="enscript-keyword">return</span>
    map_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vm_map_t'</span>)
    <span class="enscript-keyword">print</span> GetVMMapSummary.header
    <span class="enscript-keyword">print</span> GetVMMapSummary(map_val)
    vme_list_head = map_val.hdr.links
    vme_ptr_type = GetType(<span class="enscript-string">'vm_map_entry *'</span>)
    <span class="enscript-keyword">print</span> GetVMEntrySummary.header
    <span class="enscript-keyword">for</span> vme <span class="enscript-keyword">in</span> IterateQueue(vme_list_head, vme_ptr_type, <span class="enscript-string">&quot;links&quot;</span>):
        <span class="enscript-keyword">print</span> GetVMEntrySummary(vme)
    <span class="enscript-keyword">return</span> None

@lldb_type_summary([<span class="enscript-string">'_vm_map *'</span>, <span class="enscript-string">'vm_map_t'</span>])
@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &lt;20s} {3: &gt;5s} {4: &gt;5s} {5: &lt;20s} {6: &lt;20s}&quot;</span>.format(<span class="enscript-string">&quot;vm_map&quot;</span>, <span class="enscript-string">&quot;pmap&quot;</span>, <span class="enscript-string">&quot;vm_size&quot;</span>, <span class="enscript-string">&quot;#ents&quot;</span>, <span class="enscript-string">&quot;rpage&quot;</span>, <span class="enscript-string">&quot;hint&quot;</span>, <span class="enscript-string">&quot;first_free&quot;</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVMMapSummary</span>(vmmap):
    <span class="enscript-string">&quot;&quot;&quot; Display interesting bits from vm_map struct &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &lt;#020x} {2: &lt;#020x} {3: &gt;5d} {4: &gt;5d} {5: &lt;#020x} {6: &lt;#020x}&quot;</span>
    vm_size = uint64_t(vmmap.size).value
    resident_pages = 0
    <span class="enscript-keyword">if</span> vmmap.pmap != 0: resident_pages = int(vmmap.pmap.stats.resident_count)
    out_string += format_string.format(vmmap, vmmap.pmap, vm_size, vmmap.hdr.nentries, resident_pages, vmmap.hint, vmmap.first_free)
    <span class="enscript-keyword">return</span> out_string

@lldb_type_summary([<span class="enscript-string">'vm_map_entry'</span>])
@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &lt;5s} {3: &gt;7s} {4: &lt;20s} {5: &lt;20s}&quot;</span>.format(<span class="enscript-string">&quot;entry&quot;</span>, <span class="enscript-string">&quot;start&quot;</span>, <span class="enscript-string">&quot;prot&quot;</span>, <span class="enscript-string">&quot;#page&quot;</span>, <span class="enscript-string">&quot;object&quot;</span>, <span class="enscript-string">&quot;offset&quot;</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVMEntrySummary</span>(vme):
    <span class="enscript-string">&quot;&quot;&quot; Display vm entry specific information. &quot;&quot;&quot;</span>
    page_size = kern.globals.page_size
    out_string = <span class="enscript-string">&quot;&quot;</span>
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &lt;#20x} {2: &lt;1x}{3: &lt;1x}{4: &lt;3s} {5: &gt;7d} {6: &lt;#020x} {7: &lt;#020x}&quot;</span>
    vme_protection = int(vme.protection)
    vme_max_protection = int(vme.max_protection)
    vme_extra_info_str =<span class="enscript-string">&quot;SC-Ds&quot;</span>[int(vme.inheritance)]
    <span class="enscript-keyword">if</span> int(vme.is_sub_map) != 0 : 
        vme_extra_info_str +=<span class="enscript-string">&quot;s&quot;</span>
    <span class="enscript-keyword">elif</span> int(vme.needs_copy) != 0 :
        vme_extra_info_str +=<span class="enscript-string">&quot;n&quot;</span>
    num_pages = (unsigned(vme.links.end) - unsigned(vme.links.start)) / page_size
    out_string += format_string.format(vme, vme.links.start, vme_protection, vme_max_protection, vme_extra_info_str, num_pages, vme.vme_object.vmo_object, vme.vme_offset)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-comment"># EndMacro: showtaskvme
</span>@lldb_command(<span class="enscript-string">'showmapwired'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowMapWired</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print out a summary listing of all the entries with wired pages in a vm_map
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Invalid argument&quot;</span>, ShowMapWired.__doc__
        <span class="enscript-keyword">return</span>
    map_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vm_map_t'</span>)
    

@lldb_type_summary([<span class="enscript-string">'kmod_info_t *'</span>])
@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &lt;20s} {3: &gt;3s} {4: &gt;5s} {5: &gt;20s} {6: &lt;30s}&quot;</span>.format(<span class="enscript-string">'kmod_info'</span>, <span class="enscript-string">'address'</span>, <span class="enscript-string">'size'</span>, <span class="enscript-string">'id'</span>, <span class="enscript-string">'refs'</span>, <span class="enscript-string">'version'</span>, <span class="enscript-string">'name'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetKextSummary</span>(kmod):
    <span class="enscript-string">&quot;&quot;&quot; returns a string representation of kext information 
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &lt;#020x} {2: &lt;#020x} {3: &gt;3d} {4: &gt;5d} {5: &gt;20s} {6: &lt;30s}&quot;</span>
    out_string += format_string.format(kmod, kmod.address, kmod.size, kmod.id, kmod.reference_count, kmod.version, kmod.name)
    <span class="enscript-keyword">return</span> out_string

@lldb_type_summary([<span class="enscript-string">'uuid_t'</span>])
@header(<span class="enscript-string">&quot;&quot;</span>)    
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetUUIDSummary</span>(uuid):
    <span class="enscript-string">&quot;&quot;&quot; returns a string representation like CA50DA4C-CA10-3246-B8DC-93542489AA26
    &quot;&quot;&quot;</span>
    arr = Cast(addressof(uuid), <span class="enscript-string">'uint8_t *'</span>)
    data = []
    <span class="enscript-keyword">for</span> i <span class="enscript-keyword">in</span> range(16):
        data.append(int(arr[i]))
    <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;{a[0]:02X}{a[1]:02X}{a[2]:02X}{a[3]:02X}-{a[4]:02X}{a[5]:02X}-{a[6]:02X}{a[7]:02X}-{a[8]:02X}{a[9]:02X}-{a[10]:02X}{a[11]:02X}{a[12]:02X}{a[13]:02X}{a[14]:02X}{a[15]:02X}&quot;</span>.format(a=data)

@lldb_command(<span class="enscript-string">'showallkmods'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllKexts</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;Display a summary listing of all loaded kexts (alias: showallkmods)
    &quot;&quot;&quot;</span>
    kmod_val = kern.globals.kmod
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{: &lt;36s} &quot;</span>.format(<span class="enscript-string">&quot;UUID&quot;</span>) + GetKextSummary.header
    kextuuidinfo = GetKextLoadInformation()
    <span class="enscript-keyword">for</span> kval <span class="enscript-keyword">in</span> IterateLinkedList(kmod_val, <span class="enscript-string">'next'</span>):
        uuid = <span class="enscript-string">&quot;........-....-....-....-............&quot;</span>
        kaddr = unsigned(kval.address)
        <span class="enscript-keyword">for</span> l <span class="enscript-keyword">in</span> kextuuidinfo :
            <span class="enscript-keyword">if</span> kaddr == int(l[1],16):
                uuid = l[0]
                <span class="enscript-keyword">break</span>
        <span class="enscript-keyword">print</span> uuid + <span class="enscript-string">&quot; &quot;</span> + GetKextSummary(kval) 

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetKextLoadInformation</span>(addr=0):
    <span class="enscript-string">&quot;&quot;&quot; Extract the kext uuid and load address information from the kernel data structure.
        params:
            addr - int - optional integer that is the address to search for.
        returns: 
            [] - array with each entry of format ( 'UUID', 'Hex Load Address')
    &quot;&quot;&quot;</span>
    <span class="enscript-comment"># because of &lt;rdar://problem/12683084&gt;, we can't find summaries directly 
</span>    <span class="enscript-comment">#addr = hex(addressof(kern.globals.gLoadedKextSummaries.summaries))
</span>    baseaddr = unsigned(kern.globals.gLoadedKextSummaries) + 0x10
    summaries_begin = kern.GetValueFromAddress(baseaddr, <span class="enscript-string">'OSKextLoadedKextSummary *'</span>)
    total_summaries = int(kern.globals.gLoadedKextSummaries.numSummaries)
    kext_version = int(kern.globals.gLoadedKextSummaries.version)
    entry_size = 64 + 16 + 8 + 8 + 8 + 4 + 4
    <span class="enscript-keyword">if</span> kext_version &gt;= 2 :
        entry_size = int(kern.globals.gLoadedKextSummaries.entry_size)
    retval = []
    <span class="enscript-keyword">for</span> i <span class="enscript-keyword">in</span> range(total_summaries):
        tmpaddress = unsigned(summaries_begin) + (i * entry_size)
        current_kext = kern.GetValueFromAddress(tmpaddress, <span class="enscript-string">'OSKextLoadedKextSummary *'</span>)
        <span class="enscript-keyword">if</span> addr != 0 :
            <span class="enscript-keyword">if</span> addr == unsigned(current_kext.address):
                retval.append((GetUUIDSummary(current_kext.uuid) , hex(current_kext.address), str(current_kext.name) ))
        <span class="enscript-keyword">else</span>:
            retval.append((GetUUIDSummary(current_kext.uuid) , hex(current_kext.address), str(current_kext.name) )) 
        
    <span class="enscript-keyword">return</span> retval

lldb_alias(<span class="enscript-string">'showallkexts'</span>, <span class="enscript-string">'showallkmods'</span>)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetOSKextVersion</span>(version_num):
    <span class="enscript-string">&quot;&quot;&quot; returns a string of format 1.2.3x from the version_num
        params: version_num - int
        return: str 
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> version_num == -1 :
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;invalid&quot;</span>
    (MAJ_MULT, MIN_MULT, REV_MULT,STAGE_MULT) = (100000000, 1000000, 10000, 1000)
    version = version_num
    
    vers_major = version / MAJ_MULT
    version = version - (vers_major * MAJ_MULT)
    
    vers_minor = version / MIN_MULT
    version = version - (vers_minor * MIN_MULT)
    
    vers_revision = version / REV_MULT
    version = version - (vers_revision * REV_MULT)
    
    vers_stage = version / STAGE_MULT
    version = version - (vers_stage * STAGE_MULT)
    
    vers_stage_level = version 
    
    out_str = <span class="enscript-string">&quot;%d.%d&quot;</span> % (vers_major, vers_minor)
    <span class="enscript-keyword">if</span> vers_revision &gt; 0: out_str += <span class="enscript-string">&quot;.%d&quot;</span> % vers_revision
    <span class="enscript-keyword">if</span> vers_stage == 1 : out_str += <span class="enscript-string">&quot;d%d&quot;</span> % vers_stage_level
    <span class="enscript-keyword">if</span> vers_stage == 3 : out_str += <span class="enscript-string">&quot;a%d&quot;</span> % vers_stage_level
    <span class="enscript-keyword">if</span> vers_stage == 5 : out_str += <span class="enscript-string">&quot;b%d&quot;</span> % vers_stage_level
    <span class="enscript-keyword">if</span> vers_stage == 6 : out_str += <span class="enscript-string">&quot;fc%d&quot;</span> % vers_stage_level
    
    <span class="enscript-keyword">return</span> out_str

@lldb_command(<span class="enscript-string">'showallknownkmods'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllKnownKexts</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display a summary listing of all kexts known in the system.
        This is particularly useful to find if some kext was unloaded before this crash'ed state.
    &quot;&quot;&quot;</span>
    kext_count = int(kern.globals.sKextsByID.count)
    index = 0
    kext_dictionary = kern.globals.sKextsByID.dictionary
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;%d kexts in sKextsByID:&quot;</span> % kext_count
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &gt;5s} {3: &gt;20s} {4: &lt;30s}&quot;</span>.format(<span class="enscript-string">'OSKEXT *'</span>, <span class="enscript-string">'load_addr'</span>, <span class="enscript-string">'id'</span>, <span class="enscript-string">'version'</span>, <span class="enscript-string">'name'</span>)
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &lt;20s} {2: &gt;5s} {3: &gt;20s} {4: &lt;30s}&quot;</span>
    
    <span class="enscript-keyword">while</span> index &lt; kext_count:
        kext_dict = GetObjectAtIndexFromArray(kext_dictionary, index)
        kext_name = str(kext_dict.key.string)
        osk = Cast(kext_dict.value, <span class="enscript-string">'OSKext *'</span>)
        <span class="enscript-keyword">if</span> int(osk.flags.loaded) :
            load_addr = <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(osk.kmod_info)
            id = <span class="enscript-string">&quot;{0: &gt;5d}&quot;</span>.format(osk.loadTag)
        <span class="enscript-keyword">else</span>:
            load_addr = <span class="enscript-string">&quot;------&quot;</span>
            id = <span class="enscript-string">&quot;--&quot;</span>
        version_num = unsigned(osk.version)
        version = GetOSKextVersion(version_num)
        <span class="enscript-keyword">print</span> format_string.format(osk, load_addr, id, version, kext_name)
        index += 1
    
    <span class="enscript-keyword">return</span>

@lldb_command(<span class="enscript-string">'showkmodaddr'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowKmodAddr</span>(cmd_args=[]):
    <span class="enscript-string">&quot;&quot;&quot; Given an address, print the offset and name for the kmod containing it 
        Syntax: (lldb) showkmodaddr &lt;addr&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Insufficient arguments&quot;</span>)

    addr = ArgumentStringToInt(cmd_args[0])
    kmod_val = kern.globals.kmod
    <span class="enscript-keyword">for</span> kval <span class="enscript-keyword">in</span> IterateLinkedList(kmod_val, <span class="enscript-string">'next'</span>):
        <span class="enscript-keyword">if</span> addr &gt;= unsigned(kval.address) <span class="enscript-keyword">and</span> addr &lt;= (unsigned(kval.address) + unsigned(kval.size)):
            <span class="enscript-keyword">print</span> GetKextSummary.header
            <span class="enscript-keyword">print</span> GetKextSummary(kval) + <span class="enscript-string">&quot; offset = {0: #0x}&quot;</span>.format((addr - unsigned(kval.address)))
            <span class="enscript-keyword">return</span> True
    <span class="enscript-keyword">return</span> False

@lldb_command(<span class="enscript-string">'addkext'</span>,<span class="enscript-string">'AF:N:'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">AddKextSyms</span>(cmd_args=[], cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Add kext symbols into lldb.
        This command finds symbols for a uuid and load the required executable
        Usage: 
            addkext &lt;uuid&gt; : Load one kext based on uuid. eg. (lldb)addkext 4DD2344C0-4A81-3EAB-BDCF-FEAFED9EB73E
            addkext -F &lt;abs/path/to/executable&gt; &lt;load_address&gt; : Load kext executable at specified load address
            addkext -N &lt;name&gt; : Load one kext that matches the name provided. eg. (lldb) addkext -N corecrypto
            addkext -N &lt;name&gt; -A: Load all kext that matches the name provided. eg. to load all kext with Apple in name do (lldb) addkext -N Apple -A
            addkext all    : Will load all the kext symbols - SLOW 
    &quot;&quot;&quot;</span>
    

    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-F&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        exec_path = cmd_options[<span class="enscript-string">&quot;-F&quot;</span>]
        exec_full_path = ResolveFSPath(exec_path)
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> os.path.exists(exec_full_path):
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Unable to resolve {:s}&quot;</span>.format(exec_path))
        
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> os.path.isfile(exec_full_path):
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Path is {:s} not a filepath. \nPlease check that path points to executable.\
\nFor ex. path/to/Symbols/IOUSBFamily.kext/Contents/PlugIns/AppleUSBHub.kext/Contents/MacOS/AppleUSBHub.\
\nNote: LLDB does not support adding kext based on directory paths like gdb used to.&quot;</span>.format(exec_path))
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> os.access(exec_full_path, os.X_OK):
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Path is {:s} not an executable file&quot;</span>.format(exec_path))

        slide_value = None
        <span class="enscript-keyword">if</span> cmd_args:
            slide_value = cmd_args[0]
            debuglog(<span class="enscript-string">&quot;loading slide value from user input %s&quot;</span> % cmd_args[0])

        filespec = lldb.SBFileSpec(exec_full_path, False)
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;target modules add %s&quot;</span> % exec_full_path
        <span class="enscript-keyword">print</span> lldb_run_command(<span class="enscript-string">&quot;target modules add %s&quot;</span> % exec_full_path)
        loaded_module = LazyTarget.GetTarget().FindModule(filespec)
        <span class="enscript-keyword">if</span> loaded_module.IsValid():
            uuid_str = loaded_module.GetUUIDString()
            debuglog(<span class="enscript-string">&quot;added module %s with uuid %s&quot;</span> % (exec_full_path, uuid_str))
            <span class="enscript-keyword">if</span> slide_value <span class="enscript-keyword">is</span> None:
                all_kexts_info = GetKextLoadInformation()
                <span class="enscript-keyword">for</span> k <span class="enscript-keyword">in</span> all_kexts_info:
                    debuglog(k[0])
                    <span class="enscript-keyword">if</span> k[0].lower() == uuid_str.lower():
                        slide_value = k[1]
                        debuglog(<span class="enscript-string">&quot;found the slide %s for uuid %s&quot;</span> % (k[1], k[0]))
        
        <span class="enscript-keyword">if</span> slide_value <span class="enscript-keyword">is</span> None:
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Unable to find load address for module described at %s &quot;</span> % exec_full_path)
        load_cmd = <span class="enscript-string">&quot;target modules load --file %s --slide %s&quot;</span> % (exec_full_path, str(slide_value))
        <span class="enscript-keyword">print</span> load_cmd
        <span class="enscript-keyword">print</span> lldb_run_command(load_cmd)  
        kern.symbolicator = None
        <span class="enscript-keyword">return</span> True

    all_kexts_info = GetKextLoadInformation()
    
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-N&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        kext_name = cmd_options[<span class="enscript-string">&quot;-N&quot;</span>]
        kext_name_matches = GetLongestMatchOption(kext_name, [str(x[2]) <span class="enscript-keyword">for</span> x <span class="enscript-keyword">in</span> all_kexts_info], True)
        <span class="enscript-keyword">if</span> len(kext_name_matches) != 1 <span class="enscript-keyword">and</span> <span class="enscript-string">&quot;-A&quot;</span> <span class="enscript-keyword">not</span> <span class="enscript-keyword">in</span> cmd_options:
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Ambiguous match for name: {:s}&quot;</span>.format(kext_name)
            <span class="enscript-keyword">if</span> len(kext_name_matches) &gt; 0:
                <span class="enscript-keyword">print</span>  <span class="enscript-string">&quot;Options are:\n\t&quot;</span> + <span class="enscript-string">&quot;\n\t&quot;</span>.join(kext_name_matches)
            <span class="enscript-keyword">return</span>
        debuglog(<span class="enscript-string">&quot;matched the kext to name %s and uuid %s&quot;</span> % (kext_name_matches[0], kext_name))
        <span class="enscript-keyword">for</span> cur_knm <span class="enscript-keyword">in</span> kext_name_matches:
            <span class="enscript-keyword">for</span> x <span class="enscript-keyword">in</span> all_kexts_info:
                <span class="enscript-keyword">if</span> cur_knm == x[2]:
                    cur_uuid = x[0].lower()
                    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Fetching dSYM for {:s}&quot;</span>.format(cur_uuid)
                    info = dsymForUUID(cur_uuid)
                    <span class="enscript-keyword">if</span> info <span class="enscript-keyword">and</span> <span class="enscript-string">'DBGSymbolRichExecutable'</span> <span class="enscript-keyword">in</span> info:
                        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Adding dSYM ({0:s}) for {1:s}&quot;</span>.format(cur_uuid, info[<span class="enscript-string">'DBGSymbolRichExecutable'</span>])
                        addDSYM(cur_uuid, info)
                        loadDSYM(cur_uuid, int(x[1],16))
                    <span class="enscript-keyword">else</span>:
                        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Failed to get symbol info for {:s}&quot;</span>.format(cur_uuid)
                    <span class="enscript-keyword">break</span>
        kern.symbolicator = None
        <span class="enscript-keyword">return</span>

    <span class="enscript-keyword">if</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;No arguments specified.&quot;</span>)

    uuid = cmd_args[0].lower()

    load_all_kexts = False
    <span class="enscript-keyword">if</span> uuid == <span class="enscript-string">&quot;all&quot;</span>:
        load_all_kexts = True
    
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> load_all_kexts <span class="enscript-keyword">and</span> len(uuid_regex.findall(uuid)) == 0:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Unknown argument {:s}&quot;</span>.format(uuid))

    <span class="enscript-keyword">for</span> k_info <span class="enscript-keyword">in</span> all_kexts_info:
        cur_uuid = k_info[0].lower()
        <span class="enscript-keyword">if</span> load_all_kexts <span class="enscript-keyword">or</span> (uuid == cur_uuid):
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Fetching dSYM for %s&quot;</span> % cur_uuid
            info = dsymForUUID(cur_uuid)
            <span class="enscript-keyword">if</span> info <span class="enscript-keyword">and</span> <span class="enscript-string">'DBGSymbolRichExecutable'</span> <span class="enscript-keyword">in</span> info:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Adding dSYM (%s) for %s&quot;</span> % (cur_uuid, info[<span class="enscript-string">'DBGSymbolRichExecutable'</span>])
                addDSYM(cur_uuid, info)
                loadDSYM(cur_uuid, int(k_info[1],16))
            <span class="enscript-keyword">else</span>:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Failed to get symbol info for %s&quot;</span> % cur_uuid
        <span class="enscript-comment">#end of for loop
</span>    kern.symbolicator = None
    <span class="enscript-keyword">return</span> True

    

lldb_alias(<span class="enscript-string">'showkmod'</span>, <span class="enscript-string">'showkmodaddr'</span>)
lldb_alias(<span class="enscript-string">'showkext'</span>, <span class="enscript-string">'showkmodaddr'</span>)
lldb_alias(<span class="enscript-string">'showkextaddr'</span>, <span class="enscript-string">'showkmodaddr'</span>)

@lldb_type_summary([<span class="enscript-string">'mount *'</span>])
@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &lt;20s} {3: &lt;12s} {4: &lt;12s} {5: &lt;12s} {6: &gt;6s} {7: &lt;30s} {8: &lt;35s} {9: &lt;30s}&quot;</span>.format(<span class="enscript-string">'volume(mp)'</span>, <span class="enscript-string">'mnt_data'</span>, <span class="enscript-string">'mnt_devvp'</span>, <span class="enscript-string">'flag'</span>, <span class="enscript-string">'kern_flag'</span>, <span class="enscript-string">'lflag'</span>, <span class="enscript-string">'type'</span>, <span class="enscript-string">'mnton'</span>, <span class="enscript-string">'mntfrom'</span>, <span class="enscript-string">'iosched supported'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetMountSummary</span>(mount):
    <span class="enscript-string">&quot;&quot;&quot; Display a summary of mount on the system 
    &quot;&quot;&quot;</span>
    out_string = (<span class="enscript-string">&quot;{mnt: &lt;#020x} {mnt.mnt_data: &lt;#020x} {mnt.mnt_devvp: &lt;#020x} {mnt.mnt_flag: &lt;#012x} &quot;</span> +
                  <span class="enscript-string">&quot;{mnt.mnt_kern_flag: &lt;#012x} {mnt.mnt_lflag: &lt;#012x} {vfs.f_fstypename: &gt;6s} &quot;</span> +
                  <span class="enscript-string">&quot;{vfs.f_mntonname: &lt;30s} {vfs.f_mntfromname: &lt;35s} {iomode: &lt;30s}&quot;</span>).format(mnt=mount, vfs=mount.mnt_vfsstat, iomode=(<span class="enscript-string">'Yes'</span> <span class="enscript-keyword">if</span> (mount.mnt_ioflags &amp; 0x4) <span class="enscript-keyword">else</span> <span class="enscript-string">'No'</span>))
    <span class="enscript-keyword">return</span> out_string

@lldb_command(<span class="enscript-string">'showallmounts'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllMounts</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Print all mount points
    &quot;&quot;&quot;</span>
    mntlist = kern.globals.mountlist
    <span class="enscript-keyword">print</span> GetMountSummary.header
    <span class="enscript-keyword">for</span> mnt <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntlist, <span class="enscript-string">'mnt_list'</span>):
        <span class="enscript-keyword">print</span> GetMountSummary(mnt)
    <span class="enscript-keyword">return</span>

lldb_alias(<span class="enscript-string">'ShowAllVols'</span>, <span class="enscript-string">'showallmounts'</span>)

@lldb_command(<span class="enscript-string">'systemlog'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowSystemLog</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display the kernel's printf ring buffer &quot;&quot;&quot;</span>
    msgbufp = kern.globals.msgbufp
    msg_size = int(msgbufp.msg_size)
    msg_bufx = int(msgbufp.msg_bufx)
    msg_bufr = int(msgbufp.msg_bufr)
    msg_bufc = msgbufp.msg_bufc
    msg_bufc_data = msg_bufc.GetSBValue().GetPointeeData(0, msg_size)

    <span class="enscript-comment"># the buffer is circular; start at the write pointer to end,
</span>    <span class="enscript-comment"># then from beginning to write pointer
</span>    line = <span class="enscript-string">''</span>
    err = lldb.SBError()
    <span class="enscript-keyword">for</span> i <span class="enscript-keyword">in</span> range(msg_bufx, msg_size) + range(0, msg_bufx) :
        err.Clear()
        cbyte = msg_bufc_data.GetUnsignedInt8(err, i)
        <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> err.Success() :
            <span class="enscript-keyword">raise</span> ValueError(<span class="enscript-string">&quot;Failed to read character at offset &quot;</span> + str(i) + <span class="enscript-string">&quot;: &quot;</span> + err.GetCString())
        c = chr(cbyte)
        <span class="enscript-keyword">if</span> c == <span class="enscript-string">'\0'</span> :  
            <span class="enscript-keyword">continue</span>
        <span class="enscript-keyword">elif</span> c == <span class="enscript-string">'\n'</span> :
            <span class="enscript-keyword">print</span> line
            line = <span class="enscript-string">''</span>
        <span class="enscript-keyword">else</span> :
            line += c

    <span class="enscript-keyword">if</span> len(line) &gt; 0 :
        <span class="enscript-keyword">print</span> line

    <span class="enscript-keyword">return</span>

@static_var(<span class="enscript-string">'output'</span>,<span class="enscript-string">''</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">_GetVnodePathName</span>(vnode, vnodename):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to get vnode path string from vnode structure.
        params:
            vnode - core.value
            vnodename - str
        returns Nothing. The output will be stored in the static variable.
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> vnode:
        <span class="enscript-keyword">return</span>
    <span class="enscript-keyword">if</span> int(vnode.v_flag) &amp; 0x1 <span class="enscript-keyword">and</span> int(hex(vnode.v_mount), 16) !=0:
        <span class="enscript-keyword">if</span> int(vnode.v_mount.mnt_vnodecovered):
            _GetVnodePathName(vnode.v_mount.mnt_vnodecovered, str(vnode.v_mount.mnt_vnodecovered.v_name) )
    <span class="enscript-keyword">else</span>:
        _GetVnodePathName(vnode.v_parent, str(vnode.v_parent.v_name))
        _GetVnodePathName.output += <span class="enscript-string">&quot;/%s&quot;</span> % vnodename 

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVnodePath</span>(vnode):
    <span class="enscript-string">&quot;&quot;&quot; Get string representation of the vnode
        params: vnodeval - value representing vnode * in the kernel
        return: str - of format /path/to/something
    &quot;&quot;&quot;</span>
    out_str = <span class="enscript-string">''</span>
    <span class="enscript-keyword">if</span> vnode:
            <span class="enscript-keyword">if</span> (int(vnode.v_flag) &amp; 0x000001) <span class="enscript-keyword">and</span> int(hex(vnode.v_mount), 16) != 0 <span class="enscript-keyword">and</span> (int(vnode.v_mount.mnt_flag) &amp; 0x00004000) :
                out_str += <span class="enscript-string">&quot;/&quot;</span>
            <span class="enscript-keyword">else</span>:
                _GetVnodePathName.output = <span class="enscript-string">''</span>
                <span class="enscript-keyword">if</span> abs(vnode.v_name) != 0:
                    _GetVnodePathName(vnode, str(vnode.v_name))
                    out_str += _GetVnodePathName.output
                <span class="enscript-keyword">else</span>:
                    out_str += <span class="enscript-string">'v_name = NULL'</span>
                _GetVnodePathName.output = <span class="enscript-string">''</span>
    <span class="enscript-keyword">return</span> out_str


@lldb_command(<span class="enscript-string">'showvnodepath'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVnodePath</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints the path for a vnode
        usage: showvnodepath &lt;vnode&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args != None <span class="enscript-keyword">and</span> len(cmd_args) &gt; 0 :
        vnode_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vnode *'</span>)
        <span class="enscript-keyword">if</span> vnode_val:
            <span class="enscript-keyword">print</span> GetVnodePath(vnode_val)
    <span class="enscript-keyword">return</span>

<span class="enscript-comment"># Macro: showvnodedev
</span><span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVnodeDevInfo</span>(vnode):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to get information from the device type vnodes
        params: vnode - value representing struct vnode *
        return: str - formatted output information for block and char vnode types passed as param
    &quot;&quot;&quot;</span>
    vnodedev_output = <span class="enscript-string">&quot;&quot;</span>
    vblk_type = GetEnumValue(<span class="enscript-string">'vtype::VBLK'</span>)
    vchr_type = GetEnumValue(<span class="enscript-string">'vtype::VCHR'</span>)
    <span class="enscript-keyword">if</span> (vnode.v_type == vblk_type) <span class="enscript-keyword">or</span> (vnode.v_type == vchr_type):
        devnode = Cast(vnode.v_data, <span class="enscript-string">'devnode_t *'</span>)
        devnode_dev = devnode.dn_typeinfo.dev
        devnode_major = (devnode_dev &gt;&gt; 24) &amp; 0xff
        devnode_minor = devnode_dev &amp; 0x00ffffff

        <span class="enscript-comment"># boilerplate device information for a vnode 
</span>        vnodedev_output += <span class="enscript-string">&quot;Device Info:\n\t vnode:\t\t{:#x}&quot;</span>.format(vnode)
        vnodedev_output += <span class="enscript-string">&quot;\n\t type:\t\t&quot;</span>
        <span class="enscript-keyword">if</span> (vnode.v_type == vblk_type):
            vnodedev_output += <span class="enscript-string">&quot;VBLK&quot;</span>
        <span class="enscript-keyword">if</span> (vnode.v_type == vchr_type):
            vnodedev_output += <span class="enscript-string">&quot;VCHR&quot;</span>
        vnodedev_output += <span class="enscript-string">&quot;\n\t name:\t\t{:&lt;s}&quot;</span>.format(vnode.v_name)
        vnodedev_output += <span class="enscript-string">&quot;\n\t major, minor:\t{:d},{:d}&quot;</span>.format(devnode_major, devnode_minor)
        vnodedev_output += <span class="enscript-string">&quot;\n\t mode\t\t0{:o}&quot;</span>.format(unsigned(devnode.dn_mode))
        vnodedev_output += <span class="enscript-string">&quot;\n\t owner (u,g):\t{:d} {:d}&quot;</span>.format(devnode.dn_uid, devnode.dn_gid)

        <span class="enscript-comment"># decode device specific data
</span>        vnodedev_output += <span class="enscript-string">&quot;\nDevice Specific Information:\t&quot;</span>
        <span class="enscript-keyword">if</span> (vnode.v_type == vblk_type):
            vnodedev_output += <span class="enscript-string">&quot;Sorry, I do not know how to decode block devices yet!&quot;</span>
            vnodedev_output += <span class="enscript-string">&quot;\nMaybe you can write me!&quot;</span>

        <span class="enscript-keyword">if</span> (vnode.v_type == vchr_type):
            <span class="enscript-comment"># Device information; this is scanty
</span>            <span class="enscript-comment"># range check
</span>            <span class="enscript-keyword">if</span> (devnode_major &gt; 42) <span class="enscript-keyword">or</span> (devnode_major &lt; 0):
                vnodedev_output +=  <span class="enscript-string">&quot;Invalid major #\n&quot;</span>
            <span class="enscript-comment"># static assignments in conf
</span>            <span class="enscript-keyword">elif</span> (devnode_major == 0):
                vnodedev_output += <span class="enscript-string">&quot;Console mux device\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 2):
                vnodedev_output += <span class="enscript-string">&quot;Current tty alias\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 3):
                vnodedev_output += <span class="enscript-string">&quot;NULL device\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 4):
                vnodedev_output += <span class="enscript-string">&quot;Old pty slave\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 5):
                vnodedev_output += <span class="enscript-string">&quot;Old pty master\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 6):
                vnodedev_output += <span class="enscript-string">&quot;Kernel log\n&quot;</span>
            <span class="enscript-keyword">elif</span> (devnode_major == 12):
                vnodedev_output += <span class="enscript-string">&quot;Memory devices\n&quot;</span>
            <span class="enscript-comment"># Statically linked dynamic assignments
</span>            <span class="enscript-keyword">elif</span> unsigned(kern.globals.cdevsw[devnode_major].d_open) == unsigned(kern.GetLoadAddressForSymbol(<span class="enscript-string">'ptmx_open'</span>)):
                vnodedev_output += <span class="enscript-string">&quot;Cloning pty master not done\n&quot;</span>
                <span class="enscript-comment">#GetVnodeDevCpty(devnode_major, devnode_minor)
</span>            <span class="enscript-keyword">elif</span> unsigned(kern.globals.cdevsw[devnode_major].d_open) == unsigned(kern.GetLoadAddressForSymbol(<span class="enscript-string">'ptsd_open'</span>)):
                vnodedev_output += <span class="enscript-string">&quot;Cloning pty slave not done\n&quot;</span>
                <span class="enscript-comment">#GetVnodeDevCpty(devnode_major, devnode_minor)
</span>            <span class="enscript-keyword">else</span>:
                vnodedev_output += <span class="enscript-string">&quot;RESERVED SLOT\n&quot;</span>
    <span class="enscript-keyword">else</span>:
        vnodedev_output += <span class="enscript-string">&quot;{:#x} is not a device&quot;</span>.format(vnode)
    <span class="enscript-keyword">return</span> vnodedev_output

@lldb_command(<span class="enscript-string">'showvnodedev'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVnodeDev</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to display details of all vnodes of block and character device types
         Usage: showvnodedev &lt;address of vnode&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;No arguments passed&quot;</span>
        <span class="enscript-keyword">print</span> ShowVnodeDev.__doc__
        <span class="enscript-keyword">return</span> False
    vnode_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vnode *'</span>)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> vnode_val:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;unknown arguments:&quot;</span>, str(cmd_args)
        <span class="enscript-keyword">return</span> False
    <span class="enscript-keyword">print</span> GetVnodeDevInfo(vnode_val)

<span class="enscript-comment"># EndMacro: showvnodedev
</span>
<span class="enscript-comment"># Macro: showvnodelocks
</span><span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVnodeLock</span>(lockf):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to get information from the given advisory lock
        params: lockf - value representing v_lockf member in struct vnode *
        return: str - formatted output information for the advisory lock
    &quot;&quot;&quot;</span>
    vnode_lock_output = <span class="enscript-string">''</span>
    lockf_flags = lockf.lf_flags
    lockf_type = lockf.lf_type
    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x20:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;8s}&quot;</span>).format(<span class="enscript-string">'flock'</span>)
    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x40:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;8s}&quot;</span>).format(<span class="enscript-string">'posix'</span>)
    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x80:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;8s}&quot;</span>).format(<span class="enscript-string">'prov'</span>)
    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x10:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;4s}&quot;</span>).format(<span class="enscript-string">'W'</span>)
    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x400:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;8s}&quot;</span>).format(<span class="enscript-string">'ofd'</span>)
    <span class="enscript-keyword">else</span>:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;4s}&quot;</span>).format(<span class="enscript-string">'.'</span>)

    <span class="enscript-comment"># POSIX file vs advisory range locks
</span>    <span class="enscript-keyword">if</span> lockf_flags &amp; 0x40:
        lockf_proc = Cast(lockf.lf_id, <span class="enscript-string">'proc *'</span>)
        vnode_lock_output += (<span class="enscript-string">&quot;PID {: &lt;18d}&quot;</span>).format(lockf_proc.p_pid)
    <span class="enscript-keyword">else</span>:
        vnode_lock_output += (<span class="enscript-string">&quot;ID {: &lt;#019x}&quot;</span>).format(int(lockf.lf_id))
        
    <span class="enscript-comment"># lock type
</span>    <span class="enscript-keyword">if</span> lockf_type == 1:
        vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;12s}&quot;</span>).format(<span class="enscript-string">'shared'</span>)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">if</span> lockf_type == 3:
            vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;12s}&quot;</span>).format(<span class="enscript-string">'exclusive'</span>)
        <span class="enscript-keyword">else</span>:
            <span class="enscript-keyword">if</span> lockf_type == 2:
                vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;12s}&quot;</span>).format(<span class="enscript-string">'unlock'</span>)
            <span class="enscript-keyword">else</span>:
                vnode_lock_output += (<span class="enscript-string">&quot;{: &lt;12s}&quot;</span>).format(<span class="enscript-string">'unknown'</span>)
    
    <span class="enscript-comment"># start and stop values
</span>    vnode_lock_output += (<span class="enscript-string">&quot;{: #018x} ..&quot;</span>).format(lockf.lf_start)
    vnode_lock_output += (<span class="enscript-string">&quot;{: #018x}\n&quot;</span>).format(lockf.lf_end)
    <span class="enscript-keyword">return</span> vnode_lock_output

@header(<span class="enscript-string">&quot;{0: &lt;3s} {1: &lt;7s} {2: &lt;3s} {3: &lt;21s} {4: &lt;11s} {5: ^19s} {6: ^17s}&quot;</span>.format(<span class="enscript-string">'*'</span>, <span class="enscript-string">'type'</span>, <span class="enscript-string">'W'</span>, <span class="enscript-string">'held by'</span>, <span class="enscript-string">'lock type'</span>, <span class="enscript-string">'start'</span>, <span class="enscript-string">'end'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVnodeLocksSummary</span>(vnode):
    <span class="enscript-string">&quot;&quot;&quot; Internal function to get summary of advisory locks for the given vnode
        params: vnode - value representing the vnode object
        return: str - formatted output information for the summary of advisory locks
    &quot;&quot;&quot;</span>
    out_str = <span class="enscript-string">''</span>
    <span class="enscript-keyword">if</span> vnode:
            lockf_list = vnode.v_lockf
            <span class="enscript-keyword">for</span> lockf_itr <span class="enscript-keyword">in</span> IterateLinkedList(lockf_list, <span class="enscript-string">'lf_next'</span>):
                out_str += (<span class="enscript-string">&quot;{: &lt;4s}&quot;</span>).format(<span class="enscript-string">'H'</span>)
                out_str += GetVnodeLock(lockf_itr)
                lockf_blocker = lockf_itr.lf_blkhd.tqh_first
                <span class="enscript-keyword">while</span> lockf_blocker:
                    out_str += (<span class="enscript-string">&quot;{: &lt;4s}&quot;</span>).format(<span class="enscript-string">'&gt;'</span>)
                    out_str += GetVnodeLock(lockf_blocker)
                    lockf_blocker = lockf_blocker.lf_block.tqe_next    
    <span class="enscript-keyword">return</span> out_str

@lldb_command(<span class="enscript-string">'showvnodelocks'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVnodeLocks</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to display list of advisory record locks for the given vnode address
         Usage: showvnodelocks &lt;address of vnode&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;No arguments passed&quot;</span>
        <span class="enscript-keyword">print</span> ShowVnodeLocks.__doc__
        <span class="enscript-keyword">return</span> False
    vnode_val = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vnode *'</span>)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> vnode_val:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;unknown arguments:&quot;</span>, str(cmd_args)
        <span class="enscript-keyword">return</span> False
    <span class="enscript-keyword">print</span> GetVnodeLocksSummary.header
    <span class="enscript-keyword">print</span> GetVnodeLocksSummary(vnode_val)

<span class="enscript-comment"># EndMacro: showvnodelocks
</span>
<span class="enscript-comment"># Macro: showproclocks
</span>            
@lldb_command(<span class="enscript-string">'showproclocks'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowProcLocks</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to display list of advisory record locks for the given process
         Usage: showproclocks &lt;address of proc&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;No arguments passed&quot;</span>
        <span class="enscript-keyword">print</span> ShowProcLocks.__doc__
        <span class="enscript-keyword">return</span> False
    proc = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'proc *'</span>)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> proc:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;unknown arguments:&quot;</span>, str(cmd_args)
        <span class="enscript-keyword">return</span> False
    out_str = <span class="enscript-string">''</span>
    proc_filedesc = proc.p_fd
    fd_lastfile = proc_filedesc.fd_lastfile
    fd_ofiles = proc_filedesc.fd_ofiles
    count = 0
    seen = 0
    <span class="enscript-keyword">while</span> count &lt;= fd_lastfile:
        <span class="enscript-keyword">if</span> fd_ofiles[count]:
            fglob = fd_ofiles[count].f_fglob
            fo_type = fglob.fg_ops.fo_type
            <span class="enscript-keyword">if</span> fo_type == 1:
                fg_data = fglob.fg_data
                fg_vnode = Cast(fg_data, <span class="enscript-string">'vnode *'</span>)
                name = fg_vnode.v_name
                lockf_itr = fg_vnode.v_lockf
                <span class="enscript-keyword">if</span> lockf_itr:
                    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> seen:
                        <span class="enscript-keyword">print</span> GetVnodeLocksSummary.header
                    seen = seen + 1
                    out_str += (<span class="enscript-string">&quot;\n( fd {:d}, name &quot;</span>).format(count)
                    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> name:
                        out_str += <span class="enscript-string">&quot;(null) )\n&quot;</span>
                    <span class="enscript-keyword">else</span>:
                        out_str += <span class="enscript-string">&quot;{:s} )\n&quot;</span>.format(name)
                    <span class="enscript-keyword">print</span> out_str  
                    <span class="enscript-keyword">print</span> GetVnodeLocksSummary(fg_vnode)
        count = count + 1
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n{0: d} total locks for {1: #018x}&quot;</span>.format(seen, proc)

<span class="enscript-comment"># EndMacro: showproclocks
</span>
@lldb_type_summary([<span class="enscript-string">'vnode_t'</span>, <span class="enscript-string">'vnode *'</span>])
@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &gt;8s} {2: &gt;8s} {3: &lt;20s} {4: &lt;6s} {5: &lt;20s} {6: &lt;6s} {7: &lt;6s} {8: &lt;35s}&quot;</span>.format(<span class="enscript-string">'vnode'</span>, <span class="enscript-string">'usecount'</span>, <span class="enscript-string">'iocount'</span>, <span class="enscript-string">'v_data'</span>, <span class="enscript-string">'vtype'</span>, <span class="enscript-string">'parent'</span>, <span class="enscript-string">'mapped'</span>, <span class="enscript-string">'cs_version'</span>, <span class="enscript-string">'name'</span>))
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVnodeSummary</span>(vnode):
    <span class="enscript-string">&quot;&quot;&quot; Get a summary of important information out of vnode
    &quot;&quot;&quot;</span>
    out_str = <span class="enscript-string">''</span>
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &gt;8d} {2: &gt;8d} {3: &lt;#020x} {4: &lt;6s} {5: &lt;#020x} {6: &lt;6s} {7: &lt;6s} {8: &lt;35s}&quot;</span>
    usecount = int(vnode.v_usecount)
    iocount = int(vnode.v_iocount)
    v_data_ptr = int(hex(vnode.v_data), 16)
    vtype = int(vnode.v_type)
    vtype_str = <span class="enscript-string">&quot;%d&quot;</span> % vtype
    vnode_types = [<span class="enscript-string">'VNON'</span>, <span class="enscript-string">'VREG'</span>, <span class="enscript-string">'VDIR'</span>, <span class="enscript-string">'VBLK'</span>, <span class="enscript-string">'VCHR'</span>, <span class="enscript-string">'VLNK'</span>, <span class="enscript-string">'VSOCK'</span>, <span class="enscript-string">'VFIFO'</span>, <span class="enscript-string">'VBAD'</span>, <span class="enscript-string">'VSTR'</span>, <span class="enscript-string">'VCPLX'</span>]  <span class="enscript-comment"># see vnode.h for enum type definition
</span>    <span class="enscript-keyword">if</span> vtype &gt;= 0 <span class="enscript-keyword">and</span> vtype &lt; len(vnode_types):
        vtype_str = vnode_types[vtype]
    parent_ptr = int(hex(vnode.v_parent), 16)
    name_ptr = int(hex(vnode.v_name), 16)
    name =<span class="enscript-string">&quot;&quot;</span>
    <span class="enscript-keyword">if</span> name_ptr != 0:
        name = str(vnode.v_name)
    <span class="enscript-keyword">elif</span> int(vnode.v_tag) == 16 :
        cnode = Cast(vnode.v_data, <span class="enscript-string">'cnode *'</span>)
        name = <span class="enscript-string">&quot;hfs: %s&quot;</span> % str( Cast(cnode.c_desc.cd_nameptr, <span class="enscript-string">'char *'</span>))
    mapped = <span class="enscript-string">'-'</span>
    csblob_version = <span class="enscript-string">'-'</span>
    <span class="enscript-keyword">if</span> (vtype == 1) <span class="enscript-keyword">and</span> (vnode.v_un.vu_ubcinfo != 0):
        csblob_version = <span class="enscript-string">'{: &lt;6d}'</span>.format(vnode.v_un.vu_ubcinfo.cs_add_gen)
        <span class="enscript-comment"># Check to see if vnode is mapped/unmapped 
</span>        <span class="enscript-keyword">if</span> (vnode.v_un.vu_ubcinfo.ui_flags &amp; 0x8) != 0:
            mapped = <span class="enscript-string">'1'</span>
        <span class="enscript-keyword">else</span>:
            mapped = <span class="enscript-string">'0'</span>
    out_str += format_string.format(vnode, usecount, iocount, v_data_ptr, vtype_str, parent_ptr, mapped, csblob_version, name)
    <span class="enscript-keyword">return</span> out_str

@lldb_command(<span class="enscript-string">'showallvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about all vnodes
    &quot;&quot;&quot;</span>
    mntlist = kern.globals.mountlist
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">for</span> mntval <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntlist, <span class="enscript-string">'mnt_list'</span>):
        <span class="enscript-keyword">for</span> vnodeval <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntval.mnt_vnodelist, <span class="enscript-string">'v_mntvnodes'</span>):
            <span class="enscript-keyword">print</span> GetVnodeSummary(vnodeval)
    <span class="enscript-keyword">return</span>

@lldb_command(<span class="enscript-string">'showvnode'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVnode</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about one vnode
        usage: showvnode &lt;vnode&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span>  <span class="enscript-string">&quot;Please provide valid vnode argument. Type help showvnode for help.&quot;</span>
        <span class="enscript-keyword">return</span>
    vnodeval = kern.GetValueFromAddress(cmd_args[0],<span class="enscript-string">'vnode *'</span>)
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">print</span> GetVnodeSummary(vnodeval)
   
@lldb_command(<span class="enscript-string">'showvolvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVolVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about all vnodes of a given mount_t
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please provide a valide mount_t argument. Try 'help showvolvnodes' for help&quot;</span>
        <span class="enscript-keyword">return</span>
    mntval = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'mount_t'</span>)
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">for</span> vnodeval <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntval.mnt_vnodelist, <span class="enscript-string">'v_mntvnodes'</span>):
        <span class="enscript-keyword">print</span> GetVnodeSummary(vnodeval)
    <span class="enscript-keyword">return</span>

@lldb_command(<span class="enscript-string">'showvolbusyvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowVolBusyVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about busy (iocount!=0) vnodes of a given mount_t
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please provide a valide mount_t argument. Try 'help showvolbusyvnodes' for help&quot;</span>
        <span class="enscript-keyword">return</span>
    mntval = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'mount_t'</span>)
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">for</span> vnodeval <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntval.mnt_vnodelist, <span class="enscript-string">'v_mntvnodes'</span>):
        <span class="enscript-keyword">if</span> int(vnodeval.v_iocount) != 0:
            <span class="enscript-keyword">print</span> GetVnodeSummary(vnodeval)

@lldb_command(<span class="enscript-string">'showallbusyvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllBusyVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Display info about all busy (iocount!=0) vnodes
    &quot;&quot;&quot;</span>
    mntlistval = kern.globals.mountlist
    <span class="enscript-keyword">for</span> mntval <span class="enscript-keyword">in</span> IterateTAILQ_HEAD(mntlistval, <span class="enscript-string">'mnt_list'</span>):
        ShowVolBusyVnodes([hex(mntval)])

@lldb_command(<span class="enscript-string">'print_vnode'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">PrintVnode</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints out the fields of a vnode struct
        Usage: print_vnode &lt;vnode&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span>  <span class="enscript-string">&quot;Please provide valid vnode argument. Type help print_vnode for help.&quot;</span>
        <span class="enscript-keyword">return</span>
    ShowVnode(cmd_args)

@lldb_command(<span class="enscript-string">'showworkqvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowWorkqVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Print the vnode worker list
        Usage: showworkqvnodes &lt;struct mount *&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please provide valid mount argument. Type help showworkqvnodes for help.&quot;</span>
        <span class="enscript-keyword">return</span>

    mp = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'mount *'</span>)
    vp = Cast(mp.mnt_workerqueue.tqh_first, <span class="enscript-string">'vnode *'</span>)
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">while</span> int(vp) != 0:
        <span class="enscript-keyword">print</span> GetVnodeSummary(vp)
        vp = vp.v_mntvnodes.tqe_next

@lldb_command(<span class="enscript-string">'shownewvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowNewVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Print the new vnode list
        Usage: shownewvnodes &lt;struct mount *&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please provide valid mount argument. Type help shownewvnodes for help.&quot;</span>
        <span class="enscript-keyword">return</span>
    mp = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'mount *'</span>)
    vp = Cast(mp.mnt_newvnodes.tqh_first, <span class="enscript-string">'vnode *'</span>)
    <span class="enscript-keyword">print</span> GetVnodeSummary.header
    <span class="enscript-keyword">while</span> int(vp) != 0:
        <span class="enscript-keyword">print</span> GetVnodeSummary(vp)
        vp = vp.v_mntvnodes.tqe_next


@lldb_command(<span class="enscript-string">'showprocvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowProcVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print out all the open fds which are vnodes in a process
        Usage: showprocvnodes &lt;proc *&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Please provide valid proc argument. Type help showprocvnodes for help.&quot;</span>
        <span class="enscript-keyword">return</span>
    procptr = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'proc *'</span>)
    fdptr = Cast(procptr.p_fd, <span class="enscript-string">'filedesc *'</span>)
    <span class="enscript-keyword">if</span> int(fdptr.fd_cdir) != 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;25s}\n{1: &lt;s}\n{2: &lt;s}'</span>.format(<span class="enscript-string">'Current Working Directory:'</span>, GetVnodeSummary.header, GetVnodeSummary(fdptr.fd_cdir))
    <span class="enscript-keyword">if</span> int(fdptr.fd_rdir) != 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;25s}\n{1: &lt;s}\n{2: &lt;s}'</span>.format(<span class="enscript-string">'Current Root Directory:'</span>, GetVnodeSummary.header, GetVnodeSummary(fdptr.fd_rdir))
    count = 0
    <span class="enscript-keyword">print</span> <span class="enscript-string">'\n'</span> + <span class="enscript-string">'{0: &lt;5s} {1: &lt;7s}'</span>.format(<span class="enscript-string">'fd'</span>, <span class="enscript-string">'flags'</span>) + GetVnodeSummary.header 
    <span class="enscript-comment"># Hack to get around &lt;rdar://problem/12879494&gt; llb fails to cast addresses to double pointers
</span>    fpptr = Cast(fdptr.fd_ofiles, <span class="enscript-string">'fileproc *'</span>)
    <span class="enscript-keyword">while</span> count &lt; fdptr.fd_nfiles:
        fpp = dereference(fpptr)
        fproc = Cast(fpp, <span class="enscript-string">'fileproc *'</span>)
        <span class="enscript-keyword">if</span> int(fproc) != 0:
            fglob = dereference(fproc).f_fglob
            flags = <span class="enscript-string">&quot;&quot;</span>
            <span class="enscript-keyword">if</span> (int(fglob) != 0) <span class="enscript-keyword">and</span> (int(fglob.fg_ops.fo_type) == 1):
                <span class="enscript-keyword">if</span> (fdptr.fd_ofileflags[count] &amp; 1):    flags += <span class="enscript-string">'E'</span>
                <span class="enscript-keyword">if</span> (fdptr.fd_ofileflags[count] &amp; 2):    flags += <span class="enscript-string">'F'</span>
                <span class="enscript-keyword">if</span> (fdptr.fd_ofileflags[count] &amp; 4):    flags += <span class="enscript-string">'R'</span>
                <span class="enscript-keyword">if</span> (fdptr.fd_ofileflags[count] &amp; 8):    flags += <span class="enscript-string">'C'</span>
                <span class="enscript-keyword">print</span> <span class="enscript-string">'{0: &lt;5d} {1: &lt;7s}'</span>.format(count, flags) + GetVnodeSummary(Cast(fglob.fg_data, <span class="enscript-string">'vnode *'</span>))
        count += 1
        fpptr = kern.GetValueFromAddress(int(fpptr) + kern.ptrsize,<span class="enscript-string">'fileproc *'</span>)

@lldb_command(<span class="enscript-string">'showallprocvnodes'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllProcVnodes</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print out all the open fds which are vnodes
    &quot;&quot;&quot;</span>

    procptr = Cast(kern.globals.allproc.lh_first, <span class="enscript-string">'proc *'</span>)
    <span class="enscript-keyword">while</span> procptr <span class="enscript-keyword">and</span> int(procptr) != 0:
        <span class="enscript-keyword">print</span> <span class="enscript-string">'{:&lt;s}'</span>.format(<span class="enscript-string">&quot;=&quot;</span> * 106)
        <span class="enscript-keyword">print</span> GetProcInfo(procptr)
        ShowProcVnodes([int(procptr)])
        procptr = procptr.p_list.le_next

@xnudebug_test(<span class="enscript-string">'test_vnode'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">TestShowAllVnodes</span>(kernel_target, config, lldb_obj, isConnected ):
    <span class="enscript-string">&quot;&quot;&quot; Test the functionality of vnode related commands
        returns 
         - False on failure
         - True on success 
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> isConnected:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Target is not connected. Cannot test memstats&quot;</span>
        <span class="enscript-keyword">return</span> False
    res = lldb.SBCommandReturnObject()
    lldb_obj.debugger.GetCommandInterpreter().HandleCommand(<span class="enscript-string">&quot;showallvnodes&quot;</span>, res)
    result = res.GetOutput()
    <span class="enscript-keyword">if</span> len(result.split(<span class="enscript-string">&quot;\n&quot;</span>)) &gt; 2 <span class="enscript-keyword">and</span> result.find(<span class="enscript-string">'VREG'</span>) != -1 <span class="enscript-keyword">and</span> len(result.splitlines()[2].split()) &gt; 5:
        <span class="enscript-keyword">return</span> True
    <span class="enscript-keyword">else</span>: 
        <span class="enscript-keyword">return</span> False

<span class="enscript-comment"># Macro: showallmtx
</span>@lldb_type_summary([<span class="enscript-string">'_lck_grp_ *'</span>])
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetMutexEntry</span>(mtxg):
    <span class="enscript-string">&quot;&quot;&quot; Summarize a mutex group entry  with important information.
        params:
        mtxg: value - obj representing a mutex group in kernel
        returns:
        out_string - summary of the mutex group
        &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>

    <span class="enscript-keyword">if</span> kern.ptrsize == 8:
        format_string = <span class="enscript-string">'{0:#018x} {1:10d} {2:10d} {3:10d} {4:10d} {5: &lt;30s} '</span>
    <span class="enscript-keyword">else</span>:
        format_string = <span class="enscript-string">'{0:#010x} {1:10d} {2:10d} {3:10d} {4:10d} {5: &lt;30s} '</span>

    <span class="enscript-keyword">if</span> mtxg.lck_grp_mtxcnt:
        out_string += format_string.format(mtxg, mtxg.lck_grp_mtxcnt,mtxg.lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_util_cnt,
                                           mtxg.lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_miss_cnt,
                                           mtxg.lck_grp_stat.lck_grp_mtx_stat.lck_grp_mtx_wait_cnt, mtxg.lck_grp_name)
    <span class="enscript-keyword">return</span> out_string

@lldb_command(<span class="enscript-string">'showallmtx'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllMtx</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all mutexes
    &quot;&quot;&quot;</span>

    <span class="enscript-keyword">if</span> kern.ptrsize == 8:
        hdr_format = <span class="enscript-string">'{:&lt;18s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&lt;30s} '</span>
    <span class="enscript-keyword">else</span>:
        hdr_format = <span class="enscript-string">'{:&lt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&lt;30s} '</span>
    
    <span class="enscript-keyword">print</span> hdr_format.format(<span class="enscript-string">'LCK GROUP'</span>, <span class="enscript-string">'CNT'</span>, <span class="enscript-string">'UTIL'</span>, <span class="enscript-string">'MISS'</span>, <span class="enscript-string">'WAIT'</span>, <span class="enscript-string">'NAME'</span>)    

    mtxgrp_queue_head = kern.globals.lck_grp_queue
    mtxgrp_ptr_type = GetType(<span class="enscript-string">'_lck_grp_ *'</span>)   
    
    <span class="enscript-keyword">for</span> mtxgrp_ptr <span class="enscript-keyword">in</span> IterateQueue(mtxgrp_queue_head, mtxgrp_ptr_type, <span class="enscript-string">&quot;lck_grp_link&quot;</span>): 
       <span class="enscript-keyword">print</span> GetMutexEntry(mtxgrp_ptr)
    <span class="enscript-keyword">return</span>
<span class="enscript-comment"># EndMacro: showallmtx
</span>
<span class="enscript-comment"># Macro: showallrwlck
</span>@lldb_type_summary([<span class="enscript-string">'_lck_grp_ *'</span>])
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetRWLEntry</span>(rwlg):
    <span class="enscript-string">&quot;&quot;&quot; Summarize a reader writer lock group with important information.
        params:
        rwlg: value - obj representing a reader writer lock group in kernel
        returns:
        out_string - summary of the reader writer lock group
    &quot;&quot;&quot;</span>
    out_string = <span class="enscript-string">&quot;&quot;</span>

    <span class="enscript-keyword">if</span> kern.ptrsize == 8:
        format_string = <span class="enscript-string">'{0:#018x} {1:10d} {2:10d} {3:10d} {4:10d} {5: &lt;30s} '</span>
    <span class="enscript-keyword">else</span>:
        format_string = <span class="enscript-string">'{0:#010x} {1:10d} {2:10d} {3:10d} {4:10d} {5: &lt;30s} '</span>

    <span class="enscript-keyword">if</span> rwlg.lck_grp_rwcnt:
        out_string += format_string.format(rwlg, rwlg.lck_grp_rwcnt,rwlg.lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_util_cnt,
                                           rwlg.lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_miss_cnt,
                                           rwlg.lck_grp_stat.lck_grp_rw_stat.lck_grp_rw_wait_cnt, rwlg.lck_grp_name)
    <span class="enscript-keyword">return</span> out_string

<span class="enscript-comment">#Macro: showlock
</span>@lldb_type_summary([<span class="enscript-string">'lck_mtx_t *'</span>])
@header(<span class="enscript-string">&quot;===== Mutex Lock Summary =====&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetMutexLockSummary</span>(mtx):
    <span class="enscript-string">&quot;&quot;&quot; Summarize mutex lock with important information.
        params:
        mtx: value - obj representing a mutex lock in kernel
        returns:
        out_str - summary of the mutex lock
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> mtx:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Invalid lock value: 0x0&quot;</span>

    <span class="enscript-keyword">if</span> kern.arch == <span class="enscript-string">&quot;x86_64&quot;</span>:
        out_str = <span class="enscript-string">&quot;Lock Type\t\t: MUTEX\n&quot;</span>
        mtxd = mtx.lck_mtx_sw.lck_mtxd
        out_str += <span class="enscript-string">&quot;Owner Thread\t\t: {:#x}\n&quot;</span>.format(mtxd.lck_mtxd_owner)
        cmd_str = <span class="enscript-string">&quot;p/d ((lck_mtx_t*){:#x})-&gt;lck_mtx_sw.lck_mtxd.&quot;</span>.format(mtx)
        cmd_out = lldb_run_command(cmd_str + <span class="enscript-string">&quot;lck_mtxd_waiters&quot;</span>)
        out_str += <span class="enscript-string">&quot;Number of Waiters\t: {:s}\n&quot;</span>.format(cmd_out.split()[-1])
        cmd_out = lldb_run_command(cmd_str + <span class="enscript-string">&quot;lck_mtxd_ilocked&quot;</span>)
        out_str += <span class="enscript-string">&quot;ILocked\t\t\t: {:s}\n&quot;</span>.format(cmd_out.split()[-1])
        cmd_out = lldb_run_command(cmd_str + <span class="enscript-string">&quot;lck_mtxd_mlocked&quot;</span>)
        out_str += <span class="enscript-string">&quot;MLocked\t\t\t: {:s}\n&quot;</span>.format(cmd_out.split()[-1])
        cmd_out = lldb_run_command(cmd_str + <span class="enscript-string">&quot;lck_mtxd_promoted&quot;</span>)
        out_str += <span class="enscript-string">&quot;Promoted\t\t: {:s}\n&quot;</span>.format(cmd_out.split()[-1])
        cmd_out = lldb_run_command(cmd_str + <span class="enscript-string">&quot;lck_mtxd_spin&quot;</span>)
        out_str += <span class="enscript-string">&quot;Spin\t\t\t: {:s}\n&quot;</span>.format(cmd_out.split()[-1])
        <span class="enscript-keyword">return</span> out_str

    out_str = <span class="enscript-string">&quot;Lock Type\t\t: MUTEX\n&quot;</span>
    out_str += <span class="enscript-string">&quot;Owner Thread\t\t: {:#x}\n&quot;</span>.format(mtx.lck_mtx_hdr.lck_mtxd_data &amp; ~0x3)
    out_str += <span class="enscript-string">&quot;Number of Waiters\t: {:d}\n&quot;</span>.format(mtx.lck_mtx_sw.lck_mtxd.lck_mtxd_waiters)
    out_str += <span class="enscript-string">&quot;Flags\t\t\t: &quot;</span>
    <span class="enscript-keyword">if</span> mtx.lck_mtx_hdr.lck_mtxd_data &amp; 0x1:
        out_str += <span class="enscript-string">&quot;[Interlock Locked] &quot;</span>
    <span class="enscript-keyword">if</span> mtx.lck_mtx_hdr.lck_mtxd_data &amp; 0x2:
        out_str += <span class="enscript-string">&quot;[Wait Flag]&quot;</span>
    <span class="enscript-keyword">if</span> (mtx.lck_mtx_hdr.lck_mtxd_data &amp; 0x3) == 0:
        out_str += <span class="enscript-string">&quot;None&quot;</span>
    <span class="enscript-keyword">return</span> out_str

@lldb_type_summary([<span class="enscript-string">'lck_spin_t *'</span>])
@header(<span class="enscript-string">&quot;===== SpinLock Summary =====&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetSpinLockSummary</span>(spinlock):
    <span class="enscript-string">&quot;&quot;&quot; Summarize spinlock with important information.
        params:
        spinlock: value - obj representing a spinlock in kernel
        returns:
        out_str - summary of the spinlock
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> spinlock:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;Invalid lock value: 0x0&quot;</span>

    out_str = <span class="enscript-string">&quot;Lock Type\t\t: SPINLOCK\n&quot;</span>
    <span class="enscript-keyword">if</span> kern.arch == <span class="enscript-string">&quot;x86_64&quot;</span>:
        out_str += <span class="enscript-string">&quot;Interlock\t\t: {:#x}\n&quot;</span>.format(spinlock.interlock)
        <span class="enscript-keyword">return</span> out_str 

    out_str += <span class="enscript-string">&quot;Owner Thread\t\t: {:#x}\n&quot;</span>.format(spinlock.lck_spin_data &amp; ~0x3)
    out_str += <span class="enscript-string">&quot;Flags\t\t\t: &quot;</span>
    <span class="enscript-keyword">if</span> spinlock.lck_spin_data &amp; 0x1:
        out_str += <span class="enscript-string">&quot;[Interlock Locked] &quot;</span>
    <span class="enscript-keyword">if</span> spinlock.lck_spin_data &amp; 0x2:
        out_str += <span class="enscript-string">&quot;[Wait Flag]&quot;</span>
    <span class="enscript-keyword">if</span> (spinlock.lck_spin_data &amp; 0x3) == 0:
        out_str += <span class="enscript-string">&quot;None&quot;</span> 
    <span class="enscript-keyword">return</span> out_str

@lldb_command(<span class="enscript-string">'showlock'</span>, <span class="enscript-string">'MS'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowLock</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Show info about a lock - its state and owner thread details
        Usage: showlock &lt;address of a lock&gt;
        -M : to consider &lt;addr&gt; as lck_mtx_t 
        -S : to consider &lt;addr&gt; as lck_spin_t 
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Please specify the address of the lock whose info you want to view.&quot;</span>)
        <span class="enscript-keyword">return</span>

    summary_str = <span class="enscript-string">&quot;&quot;</span>
    lock = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'uintptr_t*'</span>)

    <span class="enscript-keyword">if</span> kern.arch == <span class="enscript-string">&quot;x86_64&quot;</span> <span class="enscript-keyword">and</span> lock:
        <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-M&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
            lock_mtx = Cast(lock, <span class="enscript-string">'lck_mtx_t *'</span>)
            summary_str = GetMutexLockSummary(lock_mtx)
        <span class="enscript-keyword">elif</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
            lock_spin = Cast(lock, <span class="enscript-string">'lck_spin_t *'</span>)
            summary_str = GetSpinLockSummary(lock_spin)
        <span class="enscript-keyword">else</span>:
            summary_str = <span class="enscript-string">&quot;Please specify supported lock option(-M/-S)&quot;</span>

        <span class="enscript-keyword">print</span> summary_str
        <span class="enscript-keyword">return</span>

    <span class="enscript-keyword">if</span> lock:
        lock_mtx = Cast(lock, <span class="enscript-string">'lck_mtx_t*'</span>)
        <span class="enscript-keyword">if</span> lock_mtx.lck_mtx_type == 0x22:
            summary_str = GetMutexLockSummary(lock_mtx)

        lock_spin = Cast(lock, <span class="enscript-string">'lck_spin_t*'</span>)
        <span class="enscript-keyword">if</span> lock_spin.lck_spin_type == 0x11:
            summary_str = GetSpinLockSummary(lock_spin)

    <span class="enscript-keyword">if</span> summary_str == <span class="enscript-string">&quot;&quot;</span>:
        summary_str = <span class="enscript-string">&quot;Lock Type\t\t: INVALID LOCK&quot;</span> 
    <span class="enscript-keyword">print</span> summary_str

<span class="enscript-comment">#EndMacro: showlock
</span>
@lldb_command(<span class="enscript-string">'showallrwlck'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllRWLck</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all read/writer locks
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> kern.ptrsize == 8:
        hdr_format = <span class="enscript-string">'{:&lt;18s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&lt;30s} '</span>
    <span class="enscript-keyword">else</span>:
        hdr_format = <span class="enscript-string">'{:&lt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&gt;10s} {:&lt;30s} '</span>

    <span class="enscript-keyword">print</span> hdr_format.format(<span class="enscript-string">'LCK GROUP'</span>, <span class="enscript-string">'CNT'</span>, <span class="enscript-string">'UTIL'</span>, <span class="enscript-string">'MISS'</span>, <span class="enscript-string">'WAIT'</span>, <span class="enscript-string">'NAME'</span>)

    rwlgrp_queue_head = kern.globals.lck_grp_queue
    rwlgrp_ptr_type = GetType(<span class="enscript-string">'_lck_grp_ *'</span>)
    <span class="enscript-keyword">for</span> rwlgrp_ptr <span class="enscript-keyword">in</span> IterateQueue(rwlgrp_queue_head, rwlgrp_ptr_type, <span class="enscript-string">&quot;lck_grp_link&quot;</span>):
       <span class="enscript-keyword">print</span> GetRWLEntry(rwlgrp_ptr)
    <span class="enscript-keyword">return</span>
<span class="enscript-comment"># EndMacro: showallrwlck
</span>
<span class="enscript-comment">#Macro: showbootermemorymap
</span>@lldb_command(<span class="enscript-string">'showbootermemorymap'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowBooterMemoryMap</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Prints out the phys memory map from kernelBootArgs
        Supported only on x86_64
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> kern.arch == <span class="enscript-string">'x86_64'</span>:
        voffset = unsigned(0xFFFFFF8000000000)
    <span class="enscript-keyword">else</span>:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;showbootermemorymap not supported on this architecture&quot;</span>
        <span class="enscript-keyword">return</span>
    
    out_string = <span class="enscript-string">&quot;&quot;</span>
    
    <span class="enscript-comment"># Memory type map
</span>    memtype_dict = {
            0:  <span class="enscript-string">'Reserved'</span>,
            1:  <span class="enscript-string">'LoaderCode'</span>,
            2:  <span class="enscript-string">'LoaderData'</span>,
            3:  <span class="enscript-string">'BS_code'</span>,
            4:  <span class="enscript-string">'BS_data'</span>,
            5:  <span class="enscript-string">'RT_code'</span>,
            6:  <span class="enscript-string">'RT_data'</span>,
            7:  <span class="enscript-string">'Convention'</span>,
            8:  <span class="enscript-string">'Unusable'</span>,
            9:  <span class="enscript-string">'ACPI_recl'</span>,
            10: <span class="enscript-string">'ACPI_NVS'</span>,
            11: <span class="enscript-string">'MemMapIO'</span>,
            12: <span class="enscript-string">'MemPortIO'</span>,
            13: <span class="enscript-string">'PAL_code'</span>
        }

    boot_args = kern.globals.kernelBootArgs
    msize = boot_args.MemoryMapDescriptorSize
    mcount = (boot_args.MemoryMapSize) / unsigned(msize)
    
    out_string += <span class="enscript-string">&quot;{0: &lt;12s} {1: &lt;19s} {2: &lt;19s} {3: &lt;19s} {4: &lt;10s}\n&quot;</span>.format(<span class="enscript-string">&quot;Type&quot;</span>, <span class="enscript-string">&quot;Physical Start&quot;</span>, <span class="enscript-string">&quot;Number of Pages&quot;</span>, <span class="enscript-string">&quot;Virtual Start&quot;</span>, <span class="enscript-string">&quot;Attributes&quot;</span>)
    
    i = 0
    <span class="enscript-keyword">while</span> i &lt; mcount:
        mptr = kern.GetValueFromAddress(unsigned(boot_args.MemoryMap) + voffset + unsigned(i*msize), <span class="enscript-string">'EfiMemoryRange *'</span>)
        mtype = unsigned(mptr.Type)
        <span class="enscript-keyword">if</span> mtype <span class="enscript-keyword">in</span> memtype_dict:
            out_string += <span class="enscript-string">&quot;{0: &lt;12s}&quot;</span>.format(memtype_dict[mtype])
        <span class="enscript-keyword">else</span>:
            out_string += <span class="enscript-string">&quot;{0: &lt;12s}&quot;</span>.format(<span class="enscript-string">&quot;UNKNOWN&quot;</span>)

        <span class="enscript-keyword">if</span> mptr.VirtualStart == 0:
            out_string += <span class="enscript-string">&quot;{0: #019x} {1: #019x} {2: &lt;19s} {3: #019x}\n&quot;</span>.format(mptr.PhysicalStart, mptr.NumberOfPages, <span class="enscript-string">' '</span>*19, mptr.Attribute)
        <span class="enscript-keyword">else</span>:
            out_string += <span class="enscript-string">&quot;{0: #019x} {1: #019x} {2: #019x} {3: #019x}\n&quot;</span>.format(mptr.PhysicalStart, mptr.NumberOfPages, mptr.VirtualStart, mptr.Attribute)
        i = i + 1
    
    <span class="enscript-keyword">print</span> out_string
<span class="enscript-comment">#EndMacro: showbootermemorymap
</span>
@lldb_command(<span class="enscript-string">'show_all_purgeable_objects'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllPurgeableVmObjects</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the purgeable vm objects
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n--------------------    VOLATILE OBJECTS    --------------------\n&quot;</span>
    ShowAllPurgeableVolatileVmObjects()
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n--------------------  NON-VOLATILE OBJECTS  --------------------\n&quot;</span>
    ShowAllPurgeableNonVolatileVmObjects()

@lldb_command(<span class="enscript-string">'show_all_purgeable_nonvolatile_objects'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllPurgeableNonVolatileVmObjects</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the vm objects in
        the purgeable_nonvolatile_queue
    &quot;&quot;&quot;</span>

    nonvolatile_total = <span class="enscript-keyword">lambda</span>:None
    nonvolatile_total.objects = 0
    nonvolatile_total.vsize = 0
    nonvolatile_total.rsize = 0
    nonvolatile_total.wsize = 0
    nonvolatile_total.csize = 0
    nonvolatile_total.disowned_objects = 0
    nonvolatile_total.disowned_vsize = 0
    nonvolatile_total.disowned_rsize = 0
    nonvolatile_total.disowned_wsize = 0
    nonvolatile_total.disowned_csize = 0

    queue_len = kern.globals.purgeable_nonvolatile_count
    queue_head = kern.globals.purgeable_nonvolatile_queue

    <span class="enscript-keyword">print</span> <span class="enscript-string">'purgeable_nonvolatile_queue:{:#018x}  purgeable_volatile_count:{:d}\n'</span>.format(kern.GetLoadAddressForSymbol(<span class="enscript-string">'purgeable_nonvolatile_queue'</span>),queue_len)
    <span class="enscript-keyword">print</span> <span class="enscript-string">'N:non-volatile  V:volatile  E:empty  D:deny\n'</span>

    <span class="enscript-keyword">print</span> <span class="enscript-string">'{:&gt;6s} {:&lt;6s} {:18s} {:1s} {:&gt;6s} {:&gt;16s} {:&gt;10s} {:&gt;10s} {:&gt;10s}   {:18s} {:&gt;6s} {:&lt;20s}\n'</span>.format(<span class="enscript-string">&quot;#&quot;</span>,<span class="enscript-string">&quot;#&quot;</span>,<span class="enscript-string">&quot;object&quot;</span>,<span class="enscript-string">&quot;P&quot;</span>,<span class="enscript-string">&quot;refcnt&quot;</span>,<span class="enscript-string">&quot;size (pages)&quot;</span>,<span class="enscript-string">&quot;resid&quot;</span>,<span class="enscript-string">&quot;wired&quot;</span>,<span class="enscript-string">&quot;compressed&quot;</span>,<span class="enscript-string">&quot;owner&quot;</span>,<span class="enscript-string">&quot;pid&quot;</span>,<span class="enscript-string">&quot;process&quot;</span>)
    idx = 0
    <span class="enscript-keyword">for</span> object <span class="enscript-keyword">in</span> IterateQueue(queue_head, <span class="enscript-string">'struct vm_object *'</span>, <span class="enscript-string">'objq'</span>):
        idx += 1
        ShowPurgeableNonVolatileVmObject(object, idx, queue_len, nonvolatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;disowned objects:{:&lt;10d}  [ virtual:{:&lt;10d}  resident:{:&lt;10d}  wired:{:&lt;10d}  compressed:{:&lt;10d} ]\n&quot;</span>.format(nonvolatile_total.disowned_objects, nonvolatile_total.disowned_vsize, nonvolatile_total.disowned_rsize, nonvolatile_total.disowned_wsize, nonvolatile_total.disowned_csize)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;     all objects:{:&lt;10d}  [ virtual:{:&lt;10d}  resident:{:&lt;10d}  wired:{:&lt;10d}  compressed:{:&lt;10d} ]\n&quot;</span>.format(nonvolatile_total.objects, nonvolatile_total.vsize, nonvolatile_total.rsize, nonvolatile_total.wsize, nonvolatile_total.csize)


<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowPurgeableNonVolatileVmObject</span>(object, idx, queue_len, nonvolatile_total):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to print out a summary a VM object in purgeable_nonvolatile_queue
        params: 
            object - core.value : a object of type 'struct vm_object *'
        returns:
            None
    &quot;&quot;&quot;</span>
    page_size = kern.globals.page_size
    <span class="enscript-keyword">if</span> object.purgable == 0:
        purgable = <span class="enscript-string">&quot;N&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 1:
        purgable = <span class="enscript-string">&quot;V&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 2:
        purgable = <span class="enscript-string">&quot;E&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 3:
        purgable = <span class="enscript-string">&quot;D&quot;</span>
    <span class="enscript-keyword">else</span>:
        purgable = <span class="enscript-string">&quot;?&quot;</span>
    <span class="enscript-keyword">if</span> object.pager == 0:
        compressed_count = 0
    <span class="enscript-keyword">else</span>:
        compressor_pager = Cast(object.pager, <span class="enscript-string">'compressor_pager *'</span>)
        compressed_count = compressor_pager.cpgr_num_slots_occupied

    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;6d}/{:&lt;6d} {:#018x} {:1s} {:&gt;6d} {:&gt;16d} {:&gt;10d} {:&gt;10d} {:&gt;10d}   {:#018x} {:&gt;6d} {:&lt;20s}\n&quot;</span>.format(idx,queue_len,object,purgable,object.ref_count,object.vo_un1.vou_size/page_size,object.resident_page_count,object.wired_page_count,compressed_count, object.vo_un2.vou_purgeable_owner,GetProcPIDForTask(object.vo_un2.vou_purgeable_owner),GetProcNameForTask(object.vo_un2.vou_purgeable_owner))

    nonvolatile_total.objects += 1
    nonvolatile_total.vsize += object.vo_un1.vou_size/page_size
    nonvolatile_total.rsize += object.resident_page_count
    nonvolatile_total.wsize += object.wired_page_count
    nonvolatile_total.csize += compressed_count
    <span class="enscript-keyword">if</span> object.vo_un2.vou_purgeable_owner == 0:
        nonvolatile_total.disowned_objects += 1
        nonvolatile_total.disowned_vsize += object.vo_un1.vou_size/page_size
        nonvolatile_total.disowned_rsize += object.resident_page_count
        nonvolatile_total.disowned_wsize += object.wired_page_count
        nonvolatile_total.disowned_csize += compressed_count


@lldb_command(<span class="enscript-string">'show_all_purgeable_volatile_objects'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllPurgeableVolatileVmObjects</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Routine to print a summary listing of all the vm objects in
        the purgeable queues
    &quot;&quot;&quot;</span>
    volatile_total = <span class="enscript-keyword">lambda</span>:None
    volatile_total.objects = 0
    volatile_total.vsize = 0
    volatile_total.rsize = 0
    volatile_total.wsize = 0
    volatile_total.csize = 0
    volatile_total.disowned_objects = 0
    volatile_total.disowned_vsize = 0
    volatile_total.disowned_rsize = 0
    volatile_total.disowned_wsize = 0
    volatile_total.disowned_csize = 0

    purgeable_queues = kern.globals.purgeable_queues
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;---------- OBSOLETE\n&quot;</span>
    ShowPurgeableQueue(purgeable_queues[0], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n\n---------- FIFO\n&quot;</span>
    ShowPurgeableQueue(purgeable_queues[1], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;\n\n---------- LIFO\n&quot;</span>
    ShowPurgeableQueue(purgeable_queues[2], volatile_total)

    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;disowned objects:{:&lt;10d}  [ virtual:{:&lt;10d}  resident:{:&lt;10d}  wired:{:&lt;10d}  compressed:{:&lt;10d} ]\n&quot;</span>.format(volatile_total.disowned_objects, volatile_total.disowned_vsize, volatile_total.disowned_rsize, volatile_total.disowned_wsize, volatile_total.disowned_csize)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;     all objects:{:&lt;10d}  [ virtual:{:&lt;10d}  resident:{:&lt;10d}  wired:{:&lt;10d}  compressed:{:&lt;10d} ]\n&quot;</span>.format(volatile_total.objects, volatile_total.vsize, volatile_total.rsize, volatile_total.wsize, volatile_total.csize)
    purgeable_count = kern.globals.vm_page_purgeable_count
    purgeable_wired_count = kern.globals.vm_page_purgeable_wired_count
    <span class="enscript-keyword">if</span> purgeable_count != volatile_total.rsize <span class="enscript-keyword">or</span> purgeable_wired_count != volatile_total.wsize:
        mismatch = <span class="enscript-string">&quot;&lt;---------  MISMATCH\n&quot;</span>
    <span class="enscript-keyword">else</span>:
        mismatch = <span class="enscript-string">&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_purgeable_count:                           resident:{:&lt;10d}  wired:{:&lt;10d}  {:s}\n&quot;</span>.format(purgeable_count, purgeable_wired_count, mismatch)


<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowPurgeableQueue</span>(qhead, volatile_total):
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 0\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[0], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 1\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[1], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 2\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[2], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 3\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[3], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 4\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[4], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 5\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[5], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 6\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[6], volatile_total)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;----- GROUP 7\n&quot;</span>
    ShowPurgeableGroup(qhead.objq[7], volatile_total)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowPurgeableGroup</span>(qhead, volatile_total):
    idx = 0
    <span class="enscript-keyword">for</span> object <span class="enscript-keyword">in</span> IterateQueue(qhead, <span class="enscript-string">'struct vm_object *'</span>, <span class="enscript-string">'objq'</span>):
        <span class="enscript-keyword">if</span> idx == 0:
<span class="enscript-comment">#            print &quot;{:&gt;6s} {:18s} {:1s} {:&gt;6s} {:&gt;16s} {:&gt;10s} {:&gt;10s} {:&gt;10s}   {:18s} {:&gt;6s} {:&lt;20s} {:18s} {:&gt;6s} {:&lt;20s} {:s}\n&quot;.format(&quot;#&quot;,&quot;object&quot;,&quot;P&quot;,&quot;refcnt&quot;,&quot;size (pages)&quot;,&quot;resid&quot;,&quot;wired&quot;,&quot;compressed&quot;,&quot;owner&quot;,&quot;pid&quot;,&quot;process&quot;,&quot;volatilizer&quot;,&quot;pid&quot;,&quot;process&quot;,&quot;&quot;)
</span>            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;6s} {:18s} {:1s} {:&gt;6s} {:&gt;16s} {:&gt;10s} {:&gt;10s} {:&gt;10s}   {:18s} {:&gt;6s} {:&lt;20s}\n&quot;</span>.format(<span class="enscript-string">&quot;#&quot;</span>,<span class="enscript-string">&quot;object&quot;</span>,<span class="enscript-string">&quot;P&quot;</span>,<span class="enscript-string">&quot;refcnt&quot;</span>,<span class="enscript-string">&quot;size (pages)&quot;</span>,<span class="enscript-string">&quot;resid&quot;</span>,<span class="enscript-string">&quot;wired&quot;</span>,<span class="enscript-string">&quot;compressed&quot;</span>,<span class="enscript-string">&quot;owner&quot;</span>,<span class="enscript-string">&quot;pid&quot;</span>,<span class="enscript-string">&quot;process&quot;</span>)
        idx += 1
        ShowPurgeableVolatileVmObject(object, idx, volatile_total)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowPurgeableVolatileVmObject</span>(object, idx, volatile_total):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to print out a summary a VM object in a purgeable queue
        params: 
            object - core.value : a object of type 'struct vm_object *'
        returns:
            None
    &quot;&quot;&quot;</span>
<span class="enscript-comment">#    if int(object.vo_un2.vou_purgeable_owner) != int(object.vo_purgeable_volatilizer):
</span><span class="enscript-comment">#        diff=&quot; !=&quot;
</span><span class="enscript-comment">#    else:
</span><span class="enscript-comment">#        diff=&quot;  &quot;
</span>    page_size = kern.globals.page_size
    <span class="enscript-keyword">if</span> object.purgable == 0:
        purgable = <span class="enscript-string">&quot;N&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 1:
        purgable = <span class="enscript-string">&quot;V&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 2:
        purgable = <span class="enscript-string">&quot;E&quot;</span>
    <span class="enscript-keyword">elif</span> object.purgable == 3:
        purgable = <span class="enscript-string">&quot;D&quot;</span>
    <span class="enscript-keyword">else</span>:
        purgable = <span class="enscript-string">&quot;?&quot;</span>
    <span class="enscript-keyword">if</span> object.pager == 0:
        compressed_count = 0
    <span class="enscript-keyword">else</span>:
        compressor_pager = Cast(object.pager, <span class="enscript-string">'compressor_pager *'</span>)
        compressed_count = compressor_pager.cpgr_num_slots_occupied
<span class="enscript-comment">#    print &quot;{:&gt;6d} {:#018x} {:1s} {:&gt;6d} {:&gt;16d} {:&gt;10d} {:&gt;10d} {:&gt;10d} {:#018x} {:&gt;6d} {:&lt;20s}   {:#018x} {:&gt;6d} {:&lt;20s} {:s}\n&quot;.format(idx,object,purgable,object.ref_count,object.vo_un1.vou_size/page_size,object.resident_page_count,object.wired_page_count,compressed_count,object.vo_un2.vou_purgeable_owner,GetProcPIDForTask(object.vo_un2.vou_purgeable_owner),GetProcNameForTask(object.vo_un2.vou_purgeable_owner),object.vo_purgeable_volatilizer,GetProcPIDForTask(object.vo_purgeable_volatilizer),GetProcNameForTask(object.vo_purgeable_volatilizer),diff)
</span>    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;6d} {:#018x} {:1s} {:&gt;6d} {:&gt;16d} {:&gt;10d} {:&gt;10d} {:&gt;10d}   {:#018x} {:&gt;6d} {:&lt;20s}\n&quot;</span>.format(idx,object,purgable,object.ref_count,object.vo_un1.vou_size/page_size,object.resident_page_count,object.wired_page_count,compressed_count, object.vo_un2.vou_purgeable_owner,GetProcPIDForTask(object.vo_un2.vou_purgeable_owner),GetProcNameForTask(object.vo_un2.vou_purgeable_owner))
    volatile_total.objects += 1
    volatile_total.vsize += object.vo_un1.vou_size/page_size
    volatile_total.rsize += object.resident_page_count
    volatile_total.wsize += object.wired_page_count
    volatile_total.csize += compressed_count
    <span class="enscript-keyword">if</span> object.vo_un2.vou_purgeable_owner == 0:
        volatile_total.disowned_objects += 1
        volatile_total.disowned_vsize += object.vo_un1.vou_size/page_size
        volatile_total.disowned_rsize += object.resident_page_count
        volatile_total.disowned_wsize += object.wired_page_count
        volatile_total.disowned_csize += compressed_count


<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetCompressedPagesForObject</span>(obj):
    <span class="enscript-string">&quot;&quot;&quot;Stuff
    &quot;&quot;&quot;</span>
    pager = Cast(obj.pager, <span class="enscript-string">'compressor_pager_t'</span>)
    <span class="enscript-keyword">return</span> pager.cpgr_num_slots_occupied
<span class="enscript-comment">#   if pager.cpgr_num_slots &gt; 128:
</span><span class="enscript-comment">#       slots_arr = pager.cpgr_slots.cpgr_islots
</span><span class="enscript-comment">#       num_indirect_slot_ptr = (pager.cpgr_num_slots + 127) / 128
</span><span class="enscript-comment">#       index = 0
</span><span class="enscript-comment">#       compressor_slot = 0
</span><span class="enscript-comment">#       compressed_pages = 0
</span><span class="enscript-comment">#       while index &lt; num_indirect_slot_ptr:
</span><span class="enscript-comment">#           compressor_slot = 0
</span><span class="enscript-comment">#           if slots_arr[index]:
</span><span class="enscript-comment">#               while compressor_slot &lt; 128:
</span><span class="enscript-comment">#                   if slots_arr[index][compressor_slot]:
</span><span class="enscript-comment">#                       compressed_pages += 1 
</span><span class="enscript-comment">#                   compressor_slot += 1
</span><span class="enscript-comment">#           index += 1
</span><span class="enscript-comment">#   else:
</span><span class="enscript-comment">#       slots_arr = pager.cpgr_slots.cpgr_dslots
</span><span class="enscript-comment">#       compressor_slot = 0
</span><span class="enscript-comment">#       compressed_pages = 0
</span><span class="enscript-comment">#       while compressor_slot &lt; pager.cpgr_num_slots:
</span><span class="enscript-comment">#           if slots_arr[compressor_slot]:
</span><span class="enscript-comment">#               compressed_pages += 1 
</span><span class="enscript-comment">#           compressor_slot += 1
</span><span class="enscript-comment">#   return compressed_pages
</span>
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTaskVMEntries</span>(task, show_pager_info, show_all_shadows):
    <span class="enscript-string">&quot;&quot;&quot;  Routine to print out a summary listing of all the entries in a vm_map
        params: 
            task - core.value : a object of type 'task *'
        returns:
            None
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_map entries for task &quot;</span> + hex(task)
    <span class="enscript-keyword">print</span> GetTaskSummary.header
    <span class="enscript-keyword">print</span> GetTaskSummary(task)
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> task.map:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Task {0: &lt;#020x} has map = 0x0&quot;</span>
        <span class="enscript-keyword">return</span> None
    showmapvme(task.map, show_pager_info, show_all_shadows)

@lldb_command(<span class="enscript-string">&quot;showmapvme&quot;</span>, <span class="enscript-string">&quot;PS&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowMapVME</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot;Routine to print out info about the specified vm_map and its vm entries
        usage: showmapvme &lt;vm_map&gt;
        Use -S flag to show VM object shadow chains
        Use -P flag to show pager info (mapped file, compressed pages, ...)
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Invalid argument.&quot;</span>, ShowMap.__doc__
        <span class="enscript-keyword">return</span>
    show_pager_info = False
    show_all_shadows = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-P&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_pager_info = True
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        show_all_shadows = True
    map = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vm_map_t'</span>)
    showmapvme(map, show_pager_info, show_all_shadows)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">showmapvme</span>(map, show_pager_info, show_all_shadows):
    page_size = kern.globals.page_size
    vnode_pager_ops = kern.globals.vnode_pager_ops
    vnode_pager_ops_addr = unsigned(addressof(vnode_pager_ops))
    rsize = 0
    <span class="enscript-keyword">if</span> map.pmap != 0:
        rsize = int(map.pmap.stats.resident_count)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&lt;18s} {:&lt;18s} {:&lt;18s} {:&gt;10s} {:&gt;18s} {:&gt;18s}:{:&lt;18s}&quot;</span>.format(<span class="enscript-string">&quot;vm_map&quot;</span>,<span class="enscript-string">&quot;pmap&quot;</span>,<span class="enscript-string">&quot;size&quot;</span>,<span class="enscript-string">&quot;#ents&quot;</span>,<span class="enscript-string">&quot;rsize&quot;</span>,<span class="enscript-string">&quot;start&quot;</span>,<span class="enscript-string">&quot;end&quot;</span>)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:#018x} {:#018x} {:#018x} {:&gt;10d} {:&gt;18d} {:#018x}:{:#018x}&quot;</span>.format(map,map.pmap,unsigned(map.size),map.hdr.nentries,rsize,map.hdr.links.start,map.hdr.links.end)
    vme_list_head = map.hdr.links
    vme_ptr_type = GetType(<span class="enscript-string">'vm_map_entry *'</span>)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&lt;18s} {:&gt;18s}:{:&lt;18s} {:&gt;10s} {:&lt;8s} {:&lt;10s} {:&lt;18s} {:&lt;18s}&quot;</span>.format(<span class="enscript-string">&quot;entry&quot;</span>,<span class="enscript-string">&quot;start&quot;</span>,<span class="enscript-string">&quot;end&quot;</span>,<span class="enscript-string">&quot;#pgs&quot;</span>,<span class="enscript-string">&quot;tag.kmod&quot;</span>,<span class="enscript-string">&quot;prot&amp;flags&quot;</span>,<span class="enscript-string">&quot;object&quot;</span>,<span class="enscript-string">&quot;offset&quot;</span>)
    last_end = unsigned(map.hdr.links.start)
    <span class="enscript-keyword">for</span> vme <span class="enscript-keyword">in</span> IterateQueue(vme_list_head, vme_ptr_type, <span class="enscript-string">&quot;links&quot;</span>):
        <span class="enscript-keyword">if</span> unsigned(vme.links.start) != last_end:
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:18s} {:#018x}:{:#018x} {:&gt;10d}&quot;</span>.format(<span class="enscript-string">&quot;------------------&quot;</span>,last_end,vme.links.start,(unsigned(vme.links.start) - last_end)/page_size)
        last_end = unsigned(vme.links.end)
        size = unsigned(vme.links.end) - unsigned(vme.links.start)
        object = vme.vme_object.vmo_object
        <span class="enscript-keyword">if</span> object == 0:
            object_str = <span class="enscript-string">&quot;{:&lt;#018x}&quot;</span>.format(object)
        <span class="enscript-keyword">elif</span> vme.is_sub_map:
            <span class="enscript-keyword">if</span> object == kern.globals.bufferhdr_map:
                object_str = <span class="enscript-string">&quot;BUFFERHDR_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.mb_map:
                object_str = <span class="enscript-string">&quot;MB_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.bsd_pageable_map:
                object_str = <span class="enscript-string">&quot;BSD_PAGEABLE_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.ipc_kernel_map:
                object_str = <span class="enscript-string">&quot;IPC_KERNEL_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.ipc_kernel_copy_map:
                object_str = <span class="enscript-string">&quot;IPC_KERNEL_COPY_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.kalloc_map:
                object_str = <span class="enscript-string">&quot;KALLOC_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.zone_map:
                object_str = <span class="enscript-string">&quot;ZONE_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> hasattr(kern.globals, <span class="enscript-string">'gzalloc_map'</span>) <span class="enscript-keyword">and</span> object == kern.globals.gzalloc_map:
                object_str = <span class="enscript-string">&quot;GZALLOC_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> hasattr(kern.globals, <span class="enscript-string">'g_kext_map'</span>) <span class="enscript-keyword">and</span> object == kern.globals.g_kext_map:
                object_str = <span class="enscript-string">&quot;G_KEXT_MAP&quot;</span>
            <span class="enscript-keyword">elif</span> hasattr(kern.globals, <span class="enscript-string">'vector_upl_submap'</span>) <span class="enscript-keyword">and</span> object == kern.globals.vector_upl_submap:
                object_str = <span class="enscript-string">&quot;VECTOR_UPL_SUBMAP&quot;</span>
            <span class="enscript-keyword">else</span>:
                object_str = <span class="enscript-string">&quot;submap:{:&lt;#018x}&quot;</span>.format(object)
        <span class="enscript-keyword">else</span>:
            <span class="enscript-keyword">if</span> object == kern.globals.kernel_object:
                object_str = <span class="enscript-string">&quot;KERNEL_OBJECT&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.vm_submap_object:
                object_str = <span class="enscript-string">&quot;VM_SUBMAP_OBJECT&quot;</span>
            <span class="enscript-keyword">elif</span> object == kern.globals.compressor_object:
                object_str = <span class="enscript-string">&quot;COMPRESSOR_OBJECT&quot;</span>
            <span class="enscript-keyword">else</span>:
                object_str = <span class="enscript-string">&quot;{:&lt;#018x}&quot;</span>.format(object)
        offset = unsigned(vme.vme_offset) &amp; ~0xFFF
        tag = unsigned(vme.vme_offset &amp; 0xFFF)
        vme_flags = <span class="enscript-string">&quot;&quot;</span>
        <span class="enscript-keyword">if</span> vme.is_sub_map:
            vme_flags += <span class="enscript-string">&quot;s&quot;</span>
        <span class="enscript-keyword">if</span> vme.needs_copy:
            vme_flags += <span class="enscript-string">&quot;n&quot;</span>
        <span class="enscript-keyword">if</span> vme.is_sub_map <span class="enscript-keyword">and</span> vme.use_pmap:
            vme_flags += <span class="enscript-string">&quot;p&quot;</span>
        tagstr = <span class="enscript-string">&quot;&quot;</span>
        <span class="enscript-keyword">if</span> map.pmap == kern.globals.kernel_pmap:
            xsite = Cast(kern.globals.vm_allocation_sites[tag],<span class="enscript-string">'OSKextAccount *'</span>)
            <span class="enscript-keyword">if</span> xsite <span class="enscript-keyword">and</span> xsite.site.flags &amp; 2:
                tagstr = <span class="enscript-string">&quot;.{:&lt;3d}&quot;</span>.format(xsite.loadTag)
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:#018x} {:#018x}:{:#018x} {:&gt;10d} {:&gt;3d}{:&lt;4s}  {:1d}{:1d}{:&lt;8s} {:&lt;18s} {:&lt;#18x}&quot;</span>.format(vme,vme.links.start,vme.links.end,(unsigned(vme.links.end)-unsigned(vme.links.start))/page_size,tag,tagstr,vme.protection,vme.max_protection,vme_flags,object_str,offset)
        <span class="enscript-keyword">if</span> (show_pager_info <span class="enscript-keyword">or</span> show_all_shadows) <span class="enscript-keyword">and</span> vme.is_sub_map == 0 <span class="enscript-keyword">and</span> vme.vme_object.vmo_object != 0:
            object = vme.vme_object.vmo_object
        <span class="enscript-keyword">else</span>:
            object = 0
        depth = 0
        <span class="enscript-keyword">while</span> object != 0:
            depth += 1
            <span class="enscript-keyword">if</span> show_all_shadows == False <span class="enscript-keyword">and</span> depth != 1 <span class="enscript-keyword">and</span> object.shadow != 0:
                offset += unsigned(object.vo_un2.vou_shadow_offset)
                object = object.shadow
                <span class="enscript-keyword">continue</span>
            <span class="enscript-keyword">if</span> object.copy_strategy == 0:
                copy_strategy=<span class="enscript-string">&quot;N&quot;</span>
            <span class="enscript-keyword">elif</span> object.copy_strategy == 2:
                copy_strategy=<span class="enscript-string">&quot;D&quot;</span>
            <span class="enscript-keyword">elif</span> object.copy_strategy == 4:
                copy_strategy=<span class="enscript-string">&quot;S&quot;</span>
            <span class="enscript-keyword">else</span>:
                copy_strategy=str(object.copy_strategy)
            <span class="enscript-keyword">if</span> object.internal:
                internal = <span class="enscript-string">&quot;internal&quot;</span>
            <span class="enscript-keyword">else</span>:
                internal = <span class="enscript-string">&quot;external&quot;</span>
            pager_string = <span class="enscript-string">&quot;&quot;</span>
            pager = object.pager
            <span class="enscript-keyword">if</span> show_pager_info <span class="enscript-keyword">and</span> pager != 0:
                <span class="enscript-keyword">if</span> object.internal:
                    pager_string = <span class="enscript-string">&quot;-&gt; compressed:{:d}&quot;</span>.format(GetCompressedPagesForObject(object))
                <span class="enscript-keyword">elif</span> unsigned(pager.mo_pager_ops) == vnode_pager_ops_addr:
                    vnode_pager = Cast(pager,<span class="enscript-string">'vnode_pager *'</span>)
                    pager_string = <span class="enscript-string">&quot;-&gt; &quot;</span> + GetVnodePath(vnode_pager.vnode_handle)
                <span class="enscript-keyword">else</span>:
                    pager_string = <span class="enscript-string">&quot;-&gt; {:s}:{:#018x}&quot;</span>.format(pager.mo_pager_ops.memory_object_pager_name, pager.mo_pager_ops)
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;18d} {:#018x}:{:#018x} {:#018x} ref:{:&lt;6d} ts:{:1d} strat:{:1s} {:s} ({:d} {:d} {:d}) {:s}&quot;</span>.format(depth,offset,offset+size,object,object.ref_count,object.true_share,copy_strategy,internal,unsigned(object.vo_un1.vou_size)/page_size,object.resident_page_count,object.wired_page_count,pager_string)
<span class="enscript-comment">#            print &quot;        #{:&lt;5d} obj {:#018x} ref:{:&lt;6d} ts:{:1d} strat:{:1s} {:s} size:{:&lt;10d} wired:{:&lt;10d} resident:{:&lt;10d} reusable:{:&lt;10d}&quot;.format(depth,object,object.ref_count,object.true_share,copy_strategy,internal,object.vo_un1.vou_size/page_size,object.wired_page_count,object.resident_page_count,object.reusable_page_count)
</span>            offset += unsigned(object.vo_un2.vou_shadow_offset)
            object = object.shadow
    <span class="enscript-keyword">if</span> unsigned(map.hdr.links.end) &gt; last_end:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:18s} {:#018x}:{:#018x} {:&gt;10d}&quot;</span>.format(<span class="enscript-string">&quot;------------------&quot;</span>,last_end,map.hdr.links.end,(unsigned(map.hdr.links.end) - last_end)/page_size)
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">CountMapTags</span>(map, tagcounts, slow):
    page_size = unsigned(kern.globals.page_size)
    vme_list_head = map.hdr.links
    vme_ptr_type = GetType(<span class="enscript-string">'vm_map_entry *'</span>)
    <span class="enscript-keyword">for</span> vme <span class="enscript-keyword">in</span> IterateQueue(vme_list_head, vme_ptr_type, <span class="enscript-string">&quot;links&quot;</span>):
        object = vme.vme_object.vmo_object
        tag = vme.vme_offset &amp; 0xFFF
        <span class="enscript-keyword">if</span> object == kern.globals.kernel_object:
            count = 0
            <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> slow:
                count = unsigned(vme.links.end - vme.links.start) / page_size
            <span class="enscript-keyword">else</span>:
                addr = unsigned(vme.links.start)
                <span class="enscript-keyword">while</span> addr &lt; unsigned(vme.links.end):
                    hash_id = _calc_vm_page_hash(object, addr)
                    page_list = kern.globals.vm_page_buckets[hash_id].page_list
                    page = _vm_page_unpack_ptr(page_list)
                    <span class="enscript-keyword">while</span> (page != 0):
                        vmpage = kern.GetValueFromAddress(page, <span class="enscript-string">'vm_page_t'</span>)
                        <span class="enscript-keyword">if</span> (addr == unsigned(vmpage.offset)) <span class="enscript-keyword">and</span> (object == vmpage.object):
                            <span class="enscript-keyword">if</span> (<span class="enscript-keyword">not</span> vmpage.local) <span class="enscript-keyword">and</span> (vmpage.wire_count &gt; 0):
                                count += 1
                            <span class="enscript-keyword">break</span>
                        page = _vm_page_unpack_ptr(vmpage.next_m)
                    addr += page_size
            tagcounts[tag] += count
        <span class="enscript-keyword">elif</span> vme.is_sub_map:
            CountMapTags(Cast(object,<span class="enscript-string">'vm_map_t'</span>), tagcounts, slow)
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">CountWiredObject</span>(object, tagcounts):
    tagcounts[unsigned(object.wire_tag)] += object.wired_page_count
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">CountWiredPurgeableGroup</span>(qhead, tagcounts):
    <span class="enscript-keyword">for</span> object <span class="enscript-keyword">in</span> IterateQueue(qhead, <span class="enscript-string">'struct vm_object *'</span>, <span class="enscript-string">'objq'</span>):
        CountWiredObject(object, tagcounts)
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">CountWiredPurgeableQueue</span>(qhead, tagcounts):
    CountWiredPurgeableGroup(qhead.objq[0], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[1], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[2], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[3], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[4], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[5], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[6], tagcounts)
    CountWiredPurgeableGroup(qhead.objq[7], tagcounts)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetKmodIDName</span>(kmod_id):
    kmod_val = kern.globals.kmod
    <span class="enscript-keyword">for</span> kmod <span class="enscript-keyword">in</span> IterateLinkedList(kmod_val, <span class="enscript-string">'next'</span>):
        <span class="enscript-keyword">if</span> (kmod.id == kmod_id):
            <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;{:&lt;50s}&quot;</span>.format(kmod.name)
    <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;??&quot;</span>

<span class="enscript-keyword">def</span> <span class="enscript-function-name">GetVMKernName</span>(tag):
    <span class="enscript-keyword">if</span> 1 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_OSFMK&quot;</span>
    <span class="enscript-keyword">elif</span> 2 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_BSD&quot;</span>
    <span class="enscript-keyword">elif</span> 3 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_IOKIT&quot;</span>
    <span class="enscript-keyword">elif</span> 4 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_LIBKERN&quot;</span>
    <span class="enscript-keyword">elif</span> 5 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_OSKEXT&quot;</span>
    <span class="enscript-keyword">elif</span> 6 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_KEXT&quot;</span>
    <span class="enscript-keyword">elif</span> 7 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_IPC&quot;</span>
    <span class="enscript-keyword">elif</span> 8 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_STACK&quot;</span>
    <span class="enscript-keyword">elif</span> 9 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_CPU&quot;</span>
    <span class="enscript-keyword">elif</span> 10 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_PMAP&quot;</span>
    <span class="enscript-keyword">elif</span> 11 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_PTE&quot;</span>
    <span class="enscript-keyword">elif</span> 12 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_ZONE&quot;</span>
    <span class="enscript-keyword">elif</span> 13 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_KALLOC&quot;</span>
    <span class="enscript-keyword">elif</span> 14 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_COMPRESSOR&quot;</span>
    <span class="enscript-keyword">elif</span> 15 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_COMPRESSED_DATA&quot;</span>
    <span class="enscript-keyword">elif</span> 16 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_PHANTOM_CACHE&quot;</span>
    <span class="enscript-keyword">elif</span> 17 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_WAITQ&quot;</span>
    <span class="enscript-keyword">elif</span> 18 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_DIAG&quot;</span>
    <span class="enscript-keyword">elif</span> 19 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_LOG&quot;</span>
    <span class="enscript-keyword">elif</span> 20 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_FILE&quot;</span>
    <span class="enscript-keyword">elif</span> 21 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_MBUF&quot;</span>
    <span class="enscript-keyword">elif</span> 22 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_UBC&quot;</span>
    <span class="enscript-keyword">elif</span> 23 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_SECURITY&quot;</span>
    <span class="enscript-keyword">elif</span> 24 == tag:
        <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;VM_KERN_MEMORY_MLOCK&quot;</span>
    <span class="enscript-keyword">return</span> <span class="enscript-string">&quot;??&quot;</span>


@lldb_command(<span class="enscript-string">&quot;showvmtags&quot;</span>, <span class="enscript-string">&quot;S&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">showvmtags</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot;Routine to print out info about kernel wired page allocations
        usage: showvmtags
               iterates kernel map and vm objects totaling allocations by tag.
        usage: showvmtags -S
               also iterates kernel object pages individually - slow.
    &quot;&quot;&quot;</span>
    slow = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        slow = True
    page_size = unsigned(kern.globals.page_size)
    tagcounts = []
    <span class="enscript-keyword">for</span> tag <span class="enscript-keyword">in</span> range(256):
        tagcounts.append(0)

    queue_head = kern.globals.vm_objects_wired
    <span class="enscript-keyword">for</span> object <span class="enscript-keyword">in</span> IterateQueue(queue_head, <span class="enscript-string">'struct vm_object *'</span>, <span class="enscript-string">'objq'</span>):
        CountWiredObject(object, tagcounts)

    queue_head = kern.globals.purgeable_nonvolatile_queue
    <span class="enscript-keyword">for</span> object <span class="enscript-keyword">in</span> IterateQueue(queue_head, <span class="enscript-string">'struct vm_object *'</span>, <span class="enscript-string">'objq'</span>):
        CountWiredObject(object, tagcounts)

    purgeable_queues = kern.globals.purgeable_queues
    CountWiredPurgeableQueue(purgeable_queues[0], tagcounts)
    CountWiredPurgeableQueue(purgeable_queues[1], tagcounts)
    CountWiredPurgeableQueue(purgeable_queues[2], tagcounts)

    CountMapTags(kern.globals.kernel_map, tagcounts, slow)

    total = 0
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot; {:&lt;8s}  {:&gt;7s}  {:&lt;50s}&quot;</span>.format(<span class="enscript-string">&quot;tag.kmod&quot;</span>,<span class="enscript-string">&quot;size&quot;</span>,<span class="enscript-string">&quot;name&quot;</span>)
    <span class="enscript-keyword">for</span> tag <span class="enscript-keyword">in</span> range(256):
        <span class="enscript-keyword">if</span> tagcounts[tag]:
            total += tagcounts[tag]
            tagstr = <span class="enscript-string">&quot;&quot;</span>
            sitestr = <span class="enscript-string">&quot;&quot;</span>
            <span class="enscript-keyword">if</span> (tag &lt;= 24):
                sitestr = GetVMKernName(tag)
            <span class="enscript-keyword">else</span>:
                site = kern.globals.vm_allocation_sites[tag]
                <span class="enscript-keyword">if</span> site:
                    <span class="enscript-keyword">if</span> site.flags &amp; 2:
                        xsite = Cast(site,<span class="enscript-string">'OSKextAccount *'</span>)
                        tagstr = <span class="enscript-string">&quot;.{:&lt;3d}&quot;</span>.format(xsite.loadTag)
                        sitestr = GetKmodIDName(xsite.loadTag)
                    <span class="enscript-keyword">else</span>:
                        sitestr = kern.Symbolicate(site)
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot; {:&gt;3d}{:&lt;4s}  {:&gt;7d}K  {:&lt;50s}&quot;</span>.format(tag,tagstr,tagcounts[tag]*page_size / 1024,sitestr)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Total:    {:&gt;7d}K&quot;</span>.format(total*page_size / 1024)
    <span class="enscript-keyword">return</span> None


<span class="enscript-keyword">def</span> <span class="enscript-function-name">FindVMEntriesForVnode</span>(task, vn):
    <span class="enscript-string">&quot;&quot;&quot; returns an array of vme that have the vnode set to defined vnode 
        each entry in array is of format (vme, start_addr, end_address, protection)
    &quot;&quot;&quot;</span>
    retval = []
    vmmap = task.map
    pmap = vmmap.pmap
    pager_ops_addr = unsigned(addressof(kern.globals.vnode_pager_ops))
    debuglog(<span class="enscript-string">&quot;pager_ops_addr %s&quot;</span> % hex(pager_ops_addr))

    <span class="enscript-keyword">if</span> unsigned(pmap) == 0:
        <span class="enscript-keyword">return</span> retval
    vme_list_head = vmmap.hdr.links
    vme_ptr_type = gettype(<span class="enscript-string">'vm_map_entry *'</span>)
    <span class="enscript-keyword">for</span> vme <span class="enscript-keyword">in</span> IterateQueue(vme_list_head, vme_ptr_type, <span class="enscript-string">'links'</span>):
        <span class="enscript-comment">#print vme
</span>        <span class="enscript-keyword">if</span> unsigned(vme.is_sub_map) == 0 <span class="enscript-keyword">and</span> unsigned(vme.vme_object.vmo_object) != 0:
            obj = vme.vme_object.vmo_object
        <span class="enscript-keyword">else</span>:
            <span class="enscript-keyword">continue</span>

        <span class="enscript-keyword">while</span> obj != 0:
            <span class="enscript-keyword">if</span> obj.pager != 0:
                <span class="enscript-keyword">if</span> obj.internal:
                    <span class="enscript-keyword">pass</span>
                <span class="enscript-keyword">else</span>:
                    vn_pager = Cast(obj.pager, <span class="enscript-string">'vnode_pager *'</span>)
                    <span class="enscript-keyword">if</span> unsigned(vn_pager.pager_ops) == pager_ops_addr <span class="enscript-keyword">and</span> unsigned(vn_pager.vnode_handle) == unsigned(vn):
                        retval.append((vme, unsigned(vme.links.start), unsigned(vme.links.end), unsigned(vme.protection)))
            obj = obj.shadow
    <span class="enscript-keyword">return</span> retval

@lldb_command(<span class="enscript-string">'showtaskloadinfo'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowTaskLoadInfo</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Print the load address and uuid for the process
        Usage: (lldb)showtaskloadinfo &lt;task_t&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> cmd_args:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Insufficient arguments&quot;</span>)
    t = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'struct task *'</span>)
    print_format = <span class="enscript-string">&quot;0x{0:x} - 0x{1:x} {2: &lt;50s} (??? - ???) &lt;{3: &lt;36s}&gt; {4: &lt;50s}&quot;</span>
    p = Cast(t.bsd_info, <span class="enscript-string">'struct proc *'</span>)
    uuid = p.p_uuid
    uuid_out_string = <span class="enscript-string">&quot;{a[0]:02X}{a[1]:02X}{a[2]:02X}{a[3]:02X}-{a[4]:02X}{a[5]:02X}-{a[6]:02X}{a[7]:02X}-{a[8]:02X}{a[9]:02X}-{a[10]:02X}{a[11]:02X}{a[12]:02X}{a[13]:02X}{a[14]:02X}{a[15]:02X}&quot;</span>.format(a=uuid)
    filepath = GetVnodePath(p.p_textvp)
    libname = filepath.split(<span class="enscript-string">'/'</span>)[-1]
    <span class="enscript-comment">#print &quot;uuid: %s file: %s&quot; % (uuid_out_string, filepath)
</span>    mappings = FindVMEntriesForVnode(t, p.p_textvp)
    load_addr = 0
    end_addr = 0
    <span class="enscript-keyword">for</span> m <span class="enscript-keyword">in</span> mappings:
        <span class="enscript-keyword">if</span> m[3] == 5:
            load_addr = m[1]
            end_addr = m[2]
            <span class="enscript-comment">#print &quot;Load address: %s&quot; % hex(m[1])
</span>    <span class="enscript-keyword">print</span> print_format.format(load_addr, end_addr, libname, uuid_out_string, filepath)
    <span class="enscript-keyword">return</span> None

@header(<span class="enscript-string">&quot;{0: &lt;20s} {1: &lt;20s} {2: &lt;20s}&quot;</span>.format(<span class="enscript-string">&quot;vm_page_t&quot;</span>, <span class="enscript-string">&quot;offset&quot;</span>, <span class="enscript-string">&quot;object&quot;</span>))
@lldb_command(<span class="enscript-string">'vmpagelookup'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">VMPageLookup</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Print the pages in the page bucket corresponding to the provided object and offset.
        Usage: (lldb)vmpagelookup &lt;vm_object_t&gt; &lt;vm_offset_t&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Please specify an object and offset.&quot;</span>)
    format_string = <span class="enscript-string">&quot;{0: &lt;#020x} {1: &lt;#020x} {2: &lt;#020x}\n&quot;</span>

    obj = kern.GetValueFromAddress(cmd_args[0],<span class="enscript-string">'unsigned long long'</span>)
    off = kern.GetValueFromAddress(cmd_args[1],<span class="enscript-string">'unsigned long long'</span>)

    hash_id = _calc_vm_page_hash(obj, off)

    page_list = kern.globals.vm_page_buckets[hash_id].page_list
    <span class="enscript-keyword">print</span>(<span class="enscript-string">&quot;hash_id: 0x%x page_list: 0x%x\n&quot;</span> % (unsigned(hash_id), unsigned(page_list)))

    <span class="enscript-keyword">print</span> VMPageLookup.header
    page = _vm_page_unpack_ptr(page_list)
    <span class="enscript-keyword">while</span> (page != 0) :
        pg_t = kern.GetValueFromAddress(page, <span class="enscript-string">'vm_page_t'</span>)
        <span class="enscript-keyword">print</span> format_string.format(page, pg_t.offset, pg_t.object)
        page = _vm_page_unpack_ptr(pg_t.next_m)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">_vm_page_unpack_ptr</span>(page):
    <span class="enscript-keyword">if</span> kern.ptrsize == 4 :
        <span class="enscript-keyword">return</span> page

    <span class="enscript-keyword">if</span> page == 0 :
        <span class="enscript-keyword">return</span> page

    min_addr = kern.globals.vm_min_kernel_and_kext_address
    <span class="enscript-comment">#INTEL - min_addr = 0xffffff7f80000000
</span>    <span class="enscript-comment">#ARM - min_addr = 0x80000000
</span>    <span class="enscript-comment">#ARM64 - min_addr = 0xffffff8000000000
</span>    <span class="enscript-keyword">return</span> ((page &lt;&lt; 6) + min_addr)

@lldb_command(<span class="enscript-string">'calcvmpagehash'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">CalcVMPageHash</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot; Get the page bucket corresponding to the provided object and offset.
        Usage: (lldb)calcvmpagehash &lt;vm_object_t&gt; &lt;vm_offset_t&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 2:
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Please specify an object and offset.&quot;</span>)

    obj = kern.GetValueFromAddress(cmd_args[0],<span class="enscript-string">'unsigned long long'</span>)
    off = kern.GetValueFromAddress(cmd_args[1],<span class="enscript-string">'unsigned long long'</span>)

    hash_id = _calc_vm_page_hash(obj, off)

    <span class="enscript-keyword">print</span>(<span class="enscript-string">&quot;hash_id: 0x%x page_list: 0x%x\n&quot;</span> % (unsigned(hash_id), unsigned(kern.globals.vm_page_buckets[hash_id].page_list)))
    <span class="enscript-keyword">return</span> None

<span class="enscript-keyword">def</span> <span class="enscript-function-name">_calc_vm_page_hash</span>(obj, off):
    bucket_hash = (int) (kern.globals.vm_page_bucket_hash)
    hash_mask = (int) (kern.globals.vm_page_hash_mask)

    one = (obj * bucket_hash) &amp; 0xFFFFFFFF
    two = off &gt;&gt; unsigned(kern.globals.page_shift)
    three = two ^ bucket_hash
    four = one + three
    hash_id = four &amp; hash_mask

    <span class="enscript-keyword">return</span> hash_id

@header(<span class="enscript-string">&quot;{0: &lt;10s} of {1: &lt;10s} {2: &lt;20s} {3: &lt;20s} {4: &lt;20s} {5: &lt;10s} {6: &lt;5s}\t {7: &lt;28s}\t{8: &lt;50s}&quot;</span>.format(<span class="enscript-string">&quot;index&quot;</span>, <span class="enscript-string">&quot;total&quot;</span>, <span class="enscript-string">&quot;vm_page_t&quot;</span>, <span class="enscript-string">&quot;offset&quot;</span>, <span class="enscript-string">&quot;next&quot;</span>, <span class="enscript-string">&quot;phys_page&quot;</span>, <span class="enscript-string">&quot;wire#&quot;</span>, <span class="enscript-string">&quot;first bitfield&quot;</span>, <span class="enscript-string">&quot;second bitfield&quot;</span>))
@lldb_command(<span class="enscript-string">'vmobjectwalkpages'</span>, <span class="enscript-string">'SBNQP:'</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">VMObjectWalkPages</span>(cmd_args=None, cmd_options={}):
    <span class="enscript-string">&quot;&quot;&quot; Print the resident pages contained in the provided object. If a vm_page_t is provided as well, we
        specifically look for this page, highlighting it in the output or noting if it was not found. For
        each page, we confirm that it points to the object. We also keep track of the number of pages we
        see and compare this to the object's resident page count field.
        Usage:
            vmobjectwalkpages &lt;vm_object_t&gt; : Walk and print all the pages for a given object (up to 4K pages by default)
            vmobjectwalkpages &lt;vm_object_t&gt; -B : Walk and print all the pages for a given object (up to 4K pages by default), traversing the memq backwards
            vmobjectwalkpages &lt;vm_object_t&gt; -N : Walk and print all the pages for a given object, ignore the page limit
            vmobjectwalkpages &lt;vm_object_t&gt; -Q : Walk all pages for a given object, looking for known signs of corruption (i.e. inactive and active both being set for a page)
            vmobjectwalkpages &lt;vm_object_t&gt; -P &lt;vm_page_t&gt; : Walk all the pages for a given object, annotate the specified page in the output with ***
            vmobjectwalkpages &lt;vm_object_t&gt; -P &lt;vm_page_t&gt; -S : Walk all the pages for a given object, stopping when we find the specified page

    &quot;&quot;&quot;</span>

    <span class="enscript-keyword">if</span> (cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1):
        <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;Please specify at minimum a vm_object_t and optionally a vm_page_t&quot;</span>)

    out_string = <span class="enscript-string">&quot;&quot;</span>

    obj = kern.GetValueFromAddress(cmd_args[0], <span class="enscript-string">'vm_object_t'</span>)

    page = 0
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-P&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        page = kern.GetValueFromAddress(cmd_options[<span class="enscript-string">'-P'</span>], <span class="enscript-string">'vm_page_t'</span>)

    stop = 0
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-S&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        <span class="enscript-keyword">if</span> page == 0:
            <span class="enscript-keyword">raise</span> ArgumentError(<span class="enscript-string">&quot;-S can only be passed when a page is specified with -P&quot;</span>)
        stop = 1

    walk_backwards = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-B&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        walk_backwards = True

    quiet_mode = False
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-Q&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        quiet_mode = True

    <span class="enscript-keyword">if</span> <span class="enscript-keyword">not</span> quiet_mode:
        <span class="enscript-keyword">print</span> VMObjectWalkPages.header
        format_string = <span class="enscript-string">&quot;{0: &lt;#10d} of {1: &lt;#10d} {2: &lt;#020x} {3: &lt;#020x} {4: &lt;#020x} {5: &lt;#010x} {6: &lt;#05d}\t&quot;</span>
        first_bitfield_format_string = <span class="enscript-string">&quot;{0: &lt;#1d}:{1: &lt;#1d}:{2: &lt;#1d}:{3: &lt;#1d}:{4: &lt;#1d}:{5: &lt;#1d}:{6: &lt;#1d}:&quot;</span>
        first_bitfield_format_string += <span class="enscript-string">&quot;{7: &lt;#1d}:{8: &lt;#1d}:{9: &lt;#1d}:{10: &lt;#1d}:{11: &lt;#1d}:{12: &lt;#1d}&quot;</span>
        second_bitfield_format_string = first_bitfield_format_string
        second_bitfield_format_string += <span class="enscript-string">&quot;:{13: &lt;#1d}:{14: &lt;#1d}:{15: &lt;#1d}:{16: &lt;#1d}:{17: &lt;#1d}:{18: &lt;#1d}:{19: &lt;#1d}:&quot;</span>
        second_bitfield_format_string +=  <span class="enscript-string">&quot;{20: &lt;#1d}:{21: &lt;#1d}:{22: &lt;#1d}:{23: &lt;#1d}:{24: &lt;#1d}:{25: &lt;#1d}:{26: &lt;#1d}\n&quot;</span>
        first_bitfield_format_string += <span class="enscript-string">&quot;\t&quot;</span>

    limit = 4096 <span class="enscript-comment">#arbitrary limit of number of pages to walk
</span>    ignore_limit = 0
    <span class="enscript-keyword">if</span> <span class="enscript-string">&quot;-N&quot;</span> <span class="enscript-keyword">in</span> cmd_options:
        ignore_limit = 1

    page_count = 0
    res_page_count = unsigned(obj.resident_page_count)
    page_found = False
    pages_seen = set()

    <span class="enscript-keyword">for</span> vmp <span class="enscript-keyword">in</span> IterateQueue(obj.memq, <span class="enscript-string">&quot;vm_page_t&quot;</span>, <span class="enscript-string">&quot;listq&quot;</span>, walk_backwards):
        page_count += 1
        out_string = <span class="enscript-string">&quot;&quot;</span>
        <span class="enscript-keyword">if</span> (page != 0 <span class="enscript-keyword">and</span> <span class="enscript-keyword">not</span>(page_found) <span class="enscript-keyword">and</span> vmp == page):
            out_string += <span class="enscript-string">&quot;******&quot;</span>
            page_found = True

        <span class="enscript-keyword">if</span> page != 0 <span class="enscript-keyword">or</span> quiet_mode:
             <span class="enscript-keyword">if</span> (page_count % 1000) == 0:
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;traversed %d pages ...\n&quot;</span> % (page_count)
        <span class="enscript-keyword">else</span>:
                out_string += format_string.format(page_count, res_page_count, vmp, vmp.offset, vmp.listq.next, vmp.phys_page, vmp.wire_count)
                out_string += first_bitfield_format_string.format(vmp.active, vmp.inactive, vmp.clean_queue, vmp.local, vmp.speculative,
                                                                    vmp.throttled, vmp.free, vmp.pageout_queue, vmp.laundry, vmp.reference,
                                                                    vmp.gobbled, vmp.private, vmp.no_cache)

                out_string += second_bitfield_format_string.format(vmp.busy, vmp.wanted, vmp.tabled, vmp.hashed, vmp.fictitious, vmp.clustered,
                                                                    vmp.clustered, vmp.pmapped, vmp.xpmapped, vmp.wpmapped, vmp.pageout, vmp.absent,
                                                                    vmp.error, vmp.dirty, vmp.cleaning, vmp.precious, vmp.precious, vmp.overwriting,
                                                                    vmp.restart, vmp.unusual, vmp.encrypted, vmp.encrypted, vmp.encrypted_cleaning,
                                                                    vmp.cs_validated, vmp.cs_tainted, vmp.cs_nx, vmp.reusable, vmp.lopage, vmp.slid, vmp.compressor,
                                                                    vmp.written_by_kernel)

        <span class="enscript-keyword">if</span> (vmp <span class="enscript-keyword">in</span> pages_seen):
            <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot;cycle detected! we've seen vm_page_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) + <span class="enscript-string">&quot; twice. stopping...\n&quot;</span>
            <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">if</span> (vmp.object != obj):
            <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot; vm_page_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) +  <span class="enscript-string">&quot; points to different vm_object_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp.object))
            <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">if</span> (<span class="enscript-keyword">not</span> vmp.local) <span class="enscript-keyword">and</span> (vmp.wire_count &gt; 0):
            <span class="enscript-keyword">if</span> (vmp.active <span class="enscript-keyword">or</span> vmp.inactive <span class="enscript-keyword">or</span> vmp.speculative <span class="enscript-keyword">or</span> vmp.throttled <span class="enscript-keyword">or</span> vmp.pageout_queue):
                <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot; wired page with wrong page queue attributes\n&quot;</span>
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) + <span class="enscript-string">&quot; active: %d inactive: %d speculative: %d throttled %d pageout_queue: %d\n&quot;</span> % (vmp.active,
                                    vmp.inactive, vmp.speculative, vmp.throttled, vmp.pageout_queue)
                <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;stopping...\n&quot;</span>
                <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">if</span> ((vmp.free + vmp.active + vmp.inactive + vmp.speculative + vmp.throttled + vmp.pageout_queue) &gt; 1):
            <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot; more than one pageout queue bit set active\n&quot;</span>
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;vm_page_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) + <span class="enscript-string">&quot; free: %d active: %d inactive: %d speculative: %d throttled: %d pageout_queue: %d\n&quot;</span> % (vmp.free,
                                            vmp.active, vmp.inactive, vmp.speculative, vmp.throttled, vmp.pageout_queue)
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;stopping...\n&quot;</span>
            <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">if</span> ((vmp.__unused_pageq_bits != 0) <span class="enscript-keyword">or</span> (vmp.__unused_object_bits != 0)):
            <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot; unused bits not zero for vm_page_t: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) + <span class="enscript-string">&quot; unused__pageq_bits: %d unused_object_bits : %d\n&quot;</span> % (vmp.__unused_pageq_bits,
                                            vmp.__unused_object_bits)
            <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;stopping...\n&quot;</span>
            <span class="enscript-keyword">return</span>

        pages_seen.add(vmp)

        <span class="enscript-keyword">if</span> False:
            hash_id = _calc_vm_page_hash(obj, vmp.offset)
            hash_page_list = kern.globals.vm_page_buckets[hash_id].page_list
            hash_page = _vm_page_unpack_ptr(hash_page_list)
            hash_page_t = 0

            <span class="enscript-keyword">while</span> (hash_page != 0):
                hash_page_t = kern.GetValueFromAddress(hash_page, <span class="enscript-string">'vm_page_t'</span>)
                <span class="enscript-keyword">if</span> hash_page_t == vmp:
                    <span class="enscript-keyword">break</span>
                hash_page = _vm_page_unpack_ptr(hash_page_t.next_m)

            <span class="enscript-keyword">if</span> (unsigned(vmp) != unsigned(hash_page_t)):
                <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot;unable to find page: &quot;</span> + <span class="enscript-string">&quot;{0: &lt;#020x}&quot;</span>.format(unsigned(vmp)) + <span class="enscript-string">&quot; from object in kernel page bucket list\n&quot;</span>
                <span class="enscript-keyword">print</span> lldb_run_command(<span class="enscript-string">&quot;vm_page_info %s 0x%x&quot;</span> % (cmd_args[0], unsigned(vmp.offset)))
                <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">if</span> (page_count &gt;= limit <span class="enscript-keyword">and</span> <span class="enscript-keyword">not</span>(ignore_limit)):
            <span class="enscript-keyword">print</span> out_string + <span class="enscript-string">&quot;Limit reached (%d pages), stopping...&quot;</span> % (limit)
            <span class="enscript-keyword">return</span>

        <span class="enscript-keyword">print</span> out_string

        <span class="enscript-keyword">if</span> page_found <span class="enscript-keyword">and</span> stop:
            <span class="enscript-keyword">print</span>(<span class="enscript-string">&quot;Object reports resident page count of: %d we stopped after traversing %d and finding the requested page.\n&quot;</span> % (unsigned(obj.res_page_count), unsigned(page_count)))
            <span class="enscript-keyword">return</span>

    <span class="enscript-keyword">if</span> (page != 0):
        <span class="enscript-keyword">print</span>(<span class="enscript-string">&quot;page found? : %s\n&quot;</span> % page_found)

    <span class="enscript-keyword">print</span>(<span class="enscript-string">&quot;Object reports resident page count of %d, we saw %d pages when we walked the resident list.\n&quot;</span> % (unsigned(obj.resident_page_count), unsigned(page_count)))


@lldb_command(<span class="enscript-string">&quot;show_all_apple_protect_pagers&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAllAppleProtectPagers</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;Routine to print all apple_protect pagers
        usage: show_all_apple_protect_pagers
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;3s} {:&lt;3s} {:&lt;18s} {:&gt;5s} {:&gt;5s} {:&gt;6s} {:&lt;18s} {:&lt;18s} {:&lt;18s} {:&lt;18s} {:&lt;18s} {:&lt;18s}\n&quot;</span>.format(<span class="enscript-string">&quot;#&quot;</span>, <span class="enscript-string">&quot;#&quot;</span>, <span class="enscript-string">&quot;pager&quot;</span>, <span class="enscript-string">&quot;refs&quot;</span>, <span class="enscript-string">&quot;ready&quot;</span>, <span class="enscript-string">&quot;mapped&quot;</span>, <span class="enscript-string">&quot;mo_control&quot;</span>, <span class="enscript-string">&quot;object&quot;</span>, <span class="enscript-string">&quot;offset&quot;</span>, <span class="enscript-string">&quot;crypto_offset&quot;</span>, <span class="enscript-string">&quot;crypto_start&quot;</span>, <span class="enscript-string">&quot;crypto_end&quot;</span>)
    qhead = kern.globals.apple_protect_pager_queue
    qtype = GetType(<span class="enscript-string">'apple_protect_pager *'</span>)
    qcnt = kern.globals.apple_protect_pager_count
    idx = 0
    <span class="enscript-keyword">for</span> pager <span class="enscript-keyword">in</span> IterateQueue(qhead, qtype, <span class="enscript-string">&quot;pager_queue&quot;</span>):
        idx = idx + 1
        show_apple_protect_pager(pager, qcnt, idx)

@lldb_command(<span class="enscript-string">&quot;show_apple_protect_pager&quot;</span>)
<span class="enscript-keyword">def</span> <span class="enscript-function-name">ShowAppleProtectPager</span>(cmd_args=None):
    <span class="enscript-string">&quot;&quot;&quot;Routine to print out info about an apple_protect pager
        usage: show_apple_protect_pager &lt;pager&gt;
    &quot;&quot;&quot;</span>
    <span class="enscript-keyword">if</span> cmd_args == None <span class="enscript-keyword">or</span> len(cmd_args) &lt; 1:
        <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;Invalid argument.&quot;</span>, ShowMap.__doc__
        <span class="enscript-keyword">return</span>
    pager = kern.GetValueFromAddress(cmd_ars[0], <span class="enscript-string">'apple_protect_pager_t'</span>)
    show_apple_protect_pager(pager, 1, 1)

<span class="enscript-keyword">def</span> <span class="enscript-function-name">show_apple_protect_pager</span>(pager, qcnt, idx):
    object = pager.backing_object
    shadow = object.shadow
    <span class="enscript-keyword">while</span> shadow != 0:
        object = shadow
        shadow = object.shadow
    vnode_pager = Cast(object.pager,<span class="enscript-string">'vnode_pager *'</span>)
    filename = GetVnodePath(vnode_pager.vnode_handle)
    <span class="enscript-keyword">print</span> <span class="enscript-string">&quot;{:&gt;3}/{:&lt;3d} {:#018x} {:&gt;5d} {:&gt;5d} {:&gt;6d} {:#018x} {:#018x} {:#018x} {:#018x} {:#018x} {:#018x}\n\tcrypt_info:{:#018x} &lt;decrypt:{:#018x} end:{:#018x} ops:{:#018x} refs:{:&lt;d}&gt;\n\tvnode:{:#018x} {:s}\n&quot;</span>.format(idx, qcnt, pager, pager.ref_count, pager.is_ready, pager.is_mapped, pager.pager_control, pager.backing_object, pager.backing_offset, pager.crypto_backing_offset, pager.crypto_start, pager.crypto_end, pager.crypt_info, pager.crypt_info.page_decrypt, pager.crypt_info.crypt_end, pager.crypt_info.crypt_ops, pager.crypt_info.crypt_refcnt, vnode_pager.vnode_handle, filename)
</pre>
<hr />
</body></html>