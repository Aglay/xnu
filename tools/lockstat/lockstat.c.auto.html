<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>lockstat.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">lockstat.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/error.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_error.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mig_errors.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/processor_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_info.h&gt;</span>

<span class="enscript-comment">/*
 *	lockstat.c
 *
 *	Utility to display kernel lock contention statistics.
 *	Usage:
 *	lockstat [all, spin, mutex, rw, &lt;lock group name&gt;] {&lt;repeat interval&gt;} {abs}
 *
 *	Argument 1 specifies the type of lock to display contention statistics
 *	for; alternatively, a lock group (a logically grouped set of locks,
 *	which can encompass multiple types of locks) can be specified by name.
 *	When argument 1 is &quot;all&quot;, statistics are displayed for all lock groups
 *	which have statistics enabled.
 *	Lock types include mutexes, reader-writer locks and spin locks.
 *	Note that support for gathering contention statistics may not be present
 *	for all types of locks on all platforms.
 *
 *	Argument 2 specifies a periodic interval. The program will display an
 *	updated list of statistics every &lt;repeat interval&gt; seconds. This
 *	argument is optional. The updates display the deltas from the previous
 *	set of statistics, unless &quot;abs&quot; is specified as argument 3.
 *
 *	Argument 3, if &quot;abs&quot;, causes the periodically refreshed lock statistics
 *	to be displayed as absolute values rather than deltas from the previous
 *	display.
 *
 *	Types of statistics:
 *	Acquisitions: These can include both normal acquisitions, as well
 *	as acquisition attempts. These are listed in the first column.
 *	Examples include calls to lck_mtx_lock and lck_mtx_try_lock
 *	Misses: Incremented if  a lock acquisition attempt failed, due to
 *	contention.
 *	Waits (Meaningful only for lock types that can block): Incremented
 *	if a lock acquisition attempt proceeded to block.
 *
 *	Direct Waits (currently implemented only on i386/x86_64): For adaptive
 *	locks, such as mutexes, incremented if the owner of the mutex
 *	wasn't active on another processor at the time of the lock
 *	attempt. This indicates that no adaptive spin occurred.
 */</span>

<span class="enscript-comment">/*
 * HISTORY
 * 2005: Bernard Semeria
 *		Created.
 * 2006: Derek Kumar
 *		Display i386 specific stats, fix incremental display, add
 *		explanatory block comment.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">usage</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_spin_hdr</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_spin</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_all_spin</span>(lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_mutex_hdr</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_mutex</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_all_mutex</span>(lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_rw_hdr</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_rw</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">print_all_rw</span>(lockgroup_info_t *lockgroup);
<span class="enscript-type">void</span> <span class="enscript-function-name">prime_lockgroup_deltas</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">get_lockgroup_deltas</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">char</span> *pgmname;
mach_port_t host_control;

lockgroup_info_t	*lockgroup_info, *lockgroup_start, *lockgroup_deltas;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		count;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		gDebug = 1;

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> **argv)
{
	kern_return_t		kr;
	<span class="enscript-type">int</span> 			arg2;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 		i;
	<span class="enscript-type">int</span> 			found;

	setlinebuf(stdout);

	pgmname = argv[0];
	gDebug = (NULL != strstr(argv[0], <span class="enscript-string">&quot;debug&quot;</span>));

	host_control = mach_host_self();  

	kr = host_lockgroup_info(host_control, &amp;lockgroup_info, &amp;count);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
	{
		mach_error(<span class="enscript-string">&quot;host_statistics&quot;</span>, kr);
		exit (EXIT_FAILURE);
	}
	<span class="enscript-keyword">if</span> (gDebug) {
		printf(<span class="enscript-string">&quot;count = %d\n&quot;</span>, count);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
			printf(<span class="enscript-string">&quot;%s\n&quot;</span>,lockgroup_info[i].lockgroup_name);
		}
	}

	<span class="enscript-keyword">switch</span> (argc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		<span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;all&quot;</span>) == 0) {
			print_spin_hdr();
			print_all_spin(lockgroup_info);
			print_mutex_hdr();
			print_all_mutex(lockgroup_info);
			print_rw_hdr();
			print_all_rw(lockgroup_info);
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;spin&quot;</span>) == 0) {
			print_spin_hdr();
			print_all_spin(lockgroup_info);
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;mutex&quot;</span>) == 0) {
			print_mutex_hdr();
			print_all_mutex(lockgroup_info);
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;rw&quot;</span>) == 0) {
			print_rw_hdr();
			print_all_rw(lockgroup_info);
		}
		<span class="enscript-keyword">else</span> {
			found = 0;
			<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++) {
				<span class="enscript-keyword">if</span> (strcmp(argv[1], lockgroup_info[i].lockgroup_name) == 0) {
					found = 1;
					print_spin_hdr();
					print_spin(i, lockgroup_info);
					print_mutex_hdr();
					print_mutex(i, lockgroup_info);
					print_rw_hdr();
					print_rw(i, lockgroup_info);
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> (found == 0) 
			{ usage(); }
		}
		<span class="enscript-keyword">break</span>;	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		<span class="enscript-keyword">if</span> (sscanf(argv[2], <span class="enscript-string">&quot;%d&quot;</span>, &amp;arg2) != 1) {
			usage();
		}
		<span class="enscript-keyword">if</span> (arg2 &lt; 0) {
			usage();
		}
		prime_lockgroup_deltas();
		<span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;all&quot;</span>) == 0) {

			<span class="enscript-keyword">while</span> (1) {
				sleep(arg2);
				get_lockgroup_deltas();
				print_spin_hdr();
				print_all_spin(lockgroup_deltas);
				print_mutex_hdr();
				print_all_mutex(lockgroup_deltas);
				print_rw_hdr();
				print_all_rw(lockgroup_deltas);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;spin&quot;</span>) == 0) {

			<span class="enscript-keyword">while</span> (1) {
				sleep(arg2);
				get_lockgroup_deltas();
				print_spin_hdr();
				print_all_spin(lockgroup_deltas);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;mutex&quot;</span>) == 0) {

			<span class="enscript-keyword">while</span> (1) {
				sleep(arg2);
				get_lockgroup_deltas();
				print_mutex_hdr();
				print_all_mutex(lockgroup_deltas);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;rw&quot;</span>) == 0) {

			<span class="enscript-keyword">while</span> (1) {
				sleep(arg2);
				get_lockgroup_deltas();
				print_rw_hdr();
				print_all_rw(lockgroup_deltas);
			}
		}
		<span class="enscript-keyword">else</span> {

			found = 0;
			<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++) {
				<span class="enscript-keyword">if</span> (strcmp(argv[1], lockgroup_info[i].lockgroup_name) == 0) {
					found = 1;
					<span class="enscript-keyword">while</span> (1) {
						sleep(arg2);
						get_lockgroup_deltas();
						print_spin_hdr();
						print_spin(i, lockgroup_deltas);
						print_mutex_hdr();
						print_mutex(i, lockgroup_deltas);
						print_rw_hdr();
						print_rw(i, lockgroup_deltas);
					}
				}
			}
			<span class="enscript-keyword">if</span> (found == 0)
			{ usage(); }
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		<span class="enscript-keyword">if</span> (strcmp(argv[3], <span class="enscript-string">&quot;abs&quot;</span>) != 0)
		{ usage(); }
		<span class="enscript-keyword">if</span> (sscanf(argv[2], <span class="enscript-string">&quot;%d&quot;</span>, &amp;arg2) != 1)
		{ usage(); }
		<span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;all&quot;</span>) == 0) {
			<span class="enscript-keyword">while</span> (1)
			{
				print_spin_hdr();
				print_all_spin(lockgroup_info);
				print_mutex_hdr();
				print_all_mutex(lockgroup_info);
				print_rw_hdr();
				print_all_rw(lockgroup_info);
				sleep(arg2);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;spin&quot;</span>) == 0) {
			<span class="enscript-keyword">while</span> (1)
			{print_all_spin(lockgroup_info);
				sleep(arg2);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;mutex&quot;</span>) == 0) {
			print_mutex_hdr();
			<span class="enscript-keyword">while</span> (1)
			{print_all_mutex(lockgroup_info);
				sleep(arg2);
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strcmp(argv[1], <span class="enscript-string">&quot;rw&quot;</span>) == 0) {
			print_rw_hdr();
			<span class="enscript-keyword">while</span> (1)
			{print_all_rw(lockgroup_info);
				sleep(arg2);
			}
		}
		<span class="enscript-keyword">else</span> {
			found = 0;
			<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++) {
				<span class="enscript-keyword">if</span> (strcmp(argv[1], lockgroup_info[i].lockgroup_name) == 0) {
					found = 1;
					<span class="enscript-keyword">while</span> (1)
					{
						print_spin_hdr();
						print_spin(i, lockgroup_info);
						print_mutex_hdr();
						print_mutex(i, lockgroup_info);
						print_rw_hdr();
						print_rw(i, lockgroup_info);
						sleep(arg2);
					}
				}
			}
			<span class="enscript-keyword">if</span> (found == 0)
			{ usage(); }
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		usage();
		<span class="enscript-keyword">break</span>;
	}	

	exit(0);
}
 
<span class="enscript-type">void</span> 
<span class="enscript-function-name">usage</span>()
{
	fprintf(stderr, <span class="enscript-string">&quot;Usage: %s [all, spin, mutex, rw, &lt;lock group name&gt;] {&lt;repeat interval&gt;} {abs}\n&quot;</span>, pgmname);
	exit(EXIT_FAILURE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_spin_hdr</span>(<span class="enscript-type">void</span>)
{
	printf(<span class="enscript-string">&quot;    Spinlock acquires           misses   Name\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_spin</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup)
{
	lockgroup_info_t	*curptr = &amp;lockgroup[requested];

	<span class="enscript-keyword">if</span> (curptr-&gt;lock_spin_cnt != 0 &amp;&amp; curptr-&gt;lock_spin_util_cnt != 0) {
		printf(<span class="enscript-string">&quot;%16lld &quot;</span>, curptr-&gt;lock_spin_util_cnt);
		printf(<span class="enscript-string">&quot;%16lld   &quot;</span>, curptr-&gt;lock_spin_miss_cnt);
		printf(<span class="enscript-string">&quot;%-14s\n&quot;</span>, curptr-&gt;lockgroup_name);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_all_spin</span>(lockgroup_info_t *lockgroup)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;

	<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++)
		print_spin(i, lockgroup);
        printf(<span class="enscript-string">&quot;\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_mutex_hdr</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	printf(<span class="enscript-string">&quot;Mutex lock attempts  Misses      Waits Direct Waits Name\n&quot;</span>);
#<span class="enscript-reference">else</span>
        printf(<span class="enscript-string">&quot;     mutex locks           misses            waits   name\n&quot;</span>);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_mutex</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup)
{
	lockgroup_info_t	*curptr = &amp;lockgroup[requested];

	<span class="enscript-keyword">if</span> (curptr-&gt;lock_mtx_cnt != 0 &amp;&amp; curptr-&gt;lock_mtx_util_cnt != 0) {
		printf(<span class="enscript-string">&quot;%16lld &quot;</span>, curptr-&gt;lock_mtx_util_cnt);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		printf(<span class="enscript-string">&quot;%10lld %10lld %10lld   &quot;</span>, curptr-&gt;lock_mtx_miss_cnt,  curptr-&gt;lock_mtx_wait_cnt, curptr-&gt;lock_mtx_held_cnt);
#<span class="enscript-reference">else</span>
		printf(<span class="enscript-string">&quot;%16lld %16lld   &quot;</span>, curptr-&gt;lock_mtx_miss_cnt,  curptr-&gt;lock_mtx_wait_cnt);
#<span class="enscript-reference">endif</span>
		printf(<span class="enscript-string">&quot;%-14s\n&quot;</span>, curptr-&gt;lockgroup_name);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_all_mutex</span>(lockgroup_info_t *lockgroup)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;

	<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++)
		print_mutex(i, lockgroup);
        printf(<span class="enscript-string">&quot;\n&quot;</span>);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_rw_hdr</span>(<span class="enscript-type">void</span>)
{
	printf(<span class="enscript-string">&quot;        RW locks           Misses            Waits   Name\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_rw</span>(<span class="enscript-type">int</span> requested, lockgroup_info_t *lockgroup)
{
	lockgroup_info_t	*curptr = &amp;lockgroup[requested];

	<span class="enscript-keyword">if</span> (curptr-&gt;lock_rw_cnt != 0 &amp;&amp; curptr-&gt;lock_rw_util_cnt != 0) {
		printf(<span class="enscript-string">&quot;%16lld &quot;</span>, curptr-&gt;lock_rw_util_cnt);
		printf(<span class="enscript-string">&quot;%16lld %16lld   &quot;</span>, curptr-&gt;lock_rw_miss_cnt,  curptr-&gt;lock_rw_wait_cnt);
		printf(<span class="enscript-string">&quot;%-14s\n&quot;</span>, curptr-&gt;lockgroup_name);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">print_all_rw</span>(lockgroup_info_t *lockgroup)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		i;

	<span class="enscript-keyword">for</span> (i = 0;i &lt; count;i++)
		print_rw(i, lockgroup);
        printf(<span class="enscript-string">&quot;\n&quot;</span>);

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">prime_lockgroup_deltas</span>(<span class="enscript-type">void</span>)
{
	lockgroup_start = calloc(count, <span class="enscript-keyword">sizeof</span>(lockgroup_info_t));
	<span class="enscript-keyword">if</span> (lockgroup_start == NULL) {
		fprintf(stderr, <span class="enscript-string">&quot;Can't allocate memory for lockgroup info\n&quot;</span>);
		exit (EXIT_FAILURE);
	}
	memcpy(lockgroup_start, lockgroup_info, count * <span class="enscript-keyword">sizeof</span>(lockgroup_info_t));

	lockgroup_deltas = calloc(count,  <span class="enscript-keyword">sizeof</span>(lockgroup_info_t));
	<span class="enscript-keyword">if</span> (lockgroup_deltas == NULL) {
		fprintf(stderr, <span class="enscript-string">&quot;Can't allocate memory for lockgroup info\n&quot;</span>);
		exit (EXIT_FAILURE);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">get_lockgroup_deltas</span>(<span class="enscript-type">void</span>)
{
	kern_return_t 			kr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i;

	kr = host_lockgroup_info(host_control, &amp;lockgroup_info, &amp;count);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
	{
		mach_error(<span class="enscript-string">&quot;host_statistics&quot;</span>, kr);
		exit (EXIT_FAILURE);
	}

	memcpy(lockgroup_deltas, lockgroup_info, count * <span class="enscript-keyword">sizeof</span>(lockgroup_info_t));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		lockgroup_deltas[i].lock_spin_util_cnt =
		    lockgroup_info[i].lock_spin_util_cnt -
		    lockgroup_start[i].lock_spin_util_cnt;
		lockgroup_deltas[i].lock_spin_miss_cnt =
		    lockgroup_info[i].lock_spin_miss_cnt -
		    lockgroup_start[i].lock_spin_miss_cnt;
		lockgroup_deltas[i].lock_mtx_util_cnt =
		    lockgroup_info[i].lock_mtx_util_cnt -
		    lockgroup_start[i].lock_mtx_util_cnt;
		lockgroup_deltas[i].lock_mtx_miss_cnt =
		    lockgroup_info[i].lock_mtx_miss_cnt -
		    lockgroup_start[i].lock_mtx_miss_cnt;
		lockgroup_deltas[i].lock_mtx_wait_cnt =
		    lockgroup_info[i].lock_mtx_wait_cnt -
		    lockgroup_start[i].lock_mtx_wait_cnt;
		lockgroup_deltas[i].lock_mtx_held_cnt =
		    lockgroup_info[i].lock_mtx_held_cnt -
		    lockgroup_start[i].lock_mtx_held_cnt;
		lockgroup_deltas[i].lock_rw_util_cnt =
		    lockgroup_info[i].lock_rw_util_cnt -
		    lockgroup_start[i].lock_rw_util_cnt;
		lockgroup_deltas[i].lock_rw_miss_cnt =
		    lockgroup_info[i].lock_rw_miss_cnt -
		    lockgroup_start[i].lock_rw_miss_cnt;
		lockgroup_deltas[i].lock_rw_wait_cnt =
		    lockgroup_info[i].lock_rw_wait_cnt -
		    lockgroup_start[i].lock_rw_wait_cnt;
	}
	memcpy(lockgroup_start, lockgroup_info, count * <span class="enscript-keyword">sizeof</span>(lockgroup_info_t));
}
</pre>
<hr />
</body></html>