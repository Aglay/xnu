<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kextsymboltool.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kextsymboltool.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ctype.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_init.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/arch.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/fat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/swap.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Typedefs</span>, <span class="enscript-variable-name">Enums</span>, <span class="enscript-variable-name">Constants</span>
<span class="enscript-comment">/*********************************************************************
* Typedefs, Enums, Constants
*********************************************************************/</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    kErrorNone = 0,
    kError,
    kErrorFileAccess,
    kErrorDiskFull,
    kErrorDuplicate
} ToolError;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Function</span> <span class="enscript-variable-name">Protos</span>
<span class="enscript-comment">/*********************************************************************
* Function Protos
*********************************************************************/</span>
__private_extern__ ToolError
<span class="enscript-function-name">readFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, vm_offset_t * objAddr, vm_size_t * objSize);

__private_extern__ ToolError
<span class="enscript-function-name">writeFile</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, size_t length);

__private_extern__ ToolError
<span class="enscript-function-name">seekFile</span>(<span class="enscript-type">int</span> fd, off_t offset);

<span class="enscript-type">extern</span> <span class="enscript-type">char</span>* <span class="enscript-function-name">__cxa_demangle</span> (<span class="enscript-type">const</span> <span class="enscript-type">char</span>* mangled_name,
				   <span class="enscript-type">char</span>* buf,
				   size_t* n,
				   <span class="enscript-type">int</span>* status);

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Functions</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
__private_extern__ ToolError
<span class="enscript-function-name">writeFile</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, size_t length)
{
    ToolError err;

    <span class="enscript-keyword">if</span> (length != (size_t)write(fd, data, length))
        err = kErrorDiskFull;
    <span class="enscript-keyword">else</span>
        err = kErrorNone;

    <span class="enscript-keyword">if</span> (kErrorNone != err)
        perror(<span class="enscript-string">&quot;couldn't write output&quot;</span>);

    <span class="enscript-keyword">return</span>( err );
}

 <span class="enscript-comment">/*********************************************************************
 *********************************************************************/</span>
__private_extern__ ToolError
<span class="enscript-function-name">seekFile</span>(<span class="enscript-type">int</span> fd, off_t offset)
{
    ToolError err;

    <span class="enscript-keyword">if</span> (offset != lseek(fd, offset, SEEK_SET))
        err = kErrorDiskFull;
    <span class="enscript-keyword">else</span>
        err = kErrorNone;

    <span class="enscript-keyword">if</span> (kErrorNone != err)
        perror(<span class="enscript-string">&quot;couldn't write output&quot;</span>);

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
__private_extern__ ToolError
<span class="enscript-function-name">readFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, vm_offset_t * objAddr, vm_size_t * objSize)
{
    ToolError err = kErrorFileAccess;
    <span class="enscript-type">int</span> fd;
    <span class="enscript-type">struct</span> stat stat_buf;

    *objAddr = 0;
    *objSize = 0;

    <span class="enscript-keyword">do</span>
    {
        <span class="enscript-keyword">if</span>((fd = open(path, O_RDONLY)) == -1)
	    <span class="enscript-keyword">continue</span>;

	<span class="enscript-keyword">if</span>(fstat(fd, &amp;stat_buf) == -1)
	    <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (0 == (stat_buf.st_mode &amp; S_IFREG)) 
            <span class="enscript-keyword">continue</span>;

       <span class="enscript-comment">/* Don't try to map an empty file, it fails now due to conformance
        * stuff (PR 4611502).
        */</span>
        <span class="enscript-keyword">if</span> (0 == stat_buf.st_size) {
            err = kErrorNone;
            <span class="enscript-keyword">continue</span>;
        }

	*objSize = stat_buf.st_size;

        *objAddr = (vm_offset_t)mmap(NULL <span class="enscript-comment">/* address */</span>, *objSize,
            PROT_READ|PROT_WRITE, MAP_FILE|MAP_PRIVATE <span class="enscript-comment">/* flags */</span>,
            fd, 0 <span class="enscript-comment">/* offset */</span>);

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">void</span> *)*objAddr == MAP_FAILED) {
            *objAddr = 0;
            *objSize = 0;
	    <span class="enscript-keyword">continue</span>;
	}

	err = kErrorNone;

    } <span class="enscript-keyword">while</span>( false );

    <span class="enscript-keyword">if</span> (-1 != fd)
    {
        close(fd);
    }
    <span class="enscript-keyword">if</span> (kErrorNone != err)
    {
        fprintf(stderr, <span class="enscript-string">&quot;couldn't read %s: %s\n&quot;</span>, path, strerror(errno));
    }

    <span class="enscript-keyword">return</span>( err );
}


<span class="enscript-type">enum</span> { kExported = 0x00000001, kObsolete = 0x00000002 };

<span class="enscript-type">struct</span> symbol {
    <span class="enscript-type">char</span> * name;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> name_len;
    <span class="enscript-type">char</span> * indirect;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> indirect_len;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags;
    <span class="enscript-type">struct</span> symbol * list;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> list_count;
};

<span class="enscript-type">static</span> bool <span class="enscript-function-name">issymchar</span>( <span class="enscript-type">char</span> c )
{
    <span class="enscript-keyword">return</span> ((c &gt; <span class="enscript-string">' '</span>) &amp;&amp; (c &lt;= <span class="enscript-string">'~'</span>) &amp;&amp; (c != <span class="enscript-string">':'</span>) &amp;&amp; (c != <span class="enscript-string">'#'</span>));
}

<span class="enscript-type">static</span> bool <span class="enscript-function-name">iswhitespace</span>( <span class="enscript-type">char</span> c )
{
    <span class="enscript-keyword">return</span> ((c == <span class="enscript-string">' '</span>) || (c == <span class="enscript-string">'\t'</span>));
}

<span class="enscript-comment">/*
 * Function for qsort for comparing symbol list names.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">qsort_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * _left, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * _right)
{
    <span class="enscript-type">struct</span> symbol * left  = (<span class="enscript-type">struct</span> symbol *) _left;
    <span class="enscript-type">struct</span> symbol * right = (<span class="enscript-type">struct</span> symbol *) _right;

    <span class="enscript-keyword">return</span> (strcmp(left-&gt;name, right-&gt;name));
}

<span class="enscript-comment">/*
 * Function for bsearch for finding a symbol name.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bsearch_cmp</span>( <span class="enscript-type">const</span> <span class="enscript-type">void</span> * _key, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * _cmp)
{
    <span class="enscript-type">char</span> * key = (<span class="enscript-type">char</span> *)_key;
    <span class="enscript-type">struct</span> symbol * cmp = (<span class="enscript-type">struct</span> symbol *) _cmp;

    <span class="enscript-keyword">return</span>(strcmp(key, cmp-&gt;name));
}

<span class="enscript-type">struct</span> bsearch_key
{
    <span class="enscript-type">char</span> * name;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> name_len;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bsearch_cmp_prefix</span>( <span class="enscript-type">const</span> <span class="enscript-type">void</span> * _key, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * _cmp)
{
    <span class="enscript-type">struct</span> bsearch_key * key = (<span class="enscript-type">struct</span> bsearch_key *)_key;
    <span class="enscript-type">struct</span> symbol *      cmp = (<span class="enscript-type">struct</span> symbol *) _cmp;

    <span class="enscript-keyword">return</span>(strncmp(key-&gt;name, cmp-&gt;name, key-&gt;name_len));
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">count_symbols</span>(<span class="enscript-type">char</span> * file, vm_size_t file_size)
{
    uint32_t nsyms = 0;
    <span class="enscript-type">char</span> *   scan;
    <span class="enscript-type">char</span> *   eol;
    <span class="enscript-type">char</span> *   next;

    <span class="enscript-keyword">for</span> (scan = file; true; scan = next) {

        eol = memchr(scan, <span class="enscript-string">'\n'</span>, file_size - (scan - file));
        <span class="enscript-keyword">if</span> (eol == NULL) {
            <span class="enscript-keyword">break</span>;
        }
        next = eol + 1;

       <span class="enscript-comment">/* Skip empty lines.
        */</span>
        <span class="enscript-keyword">if</span> (eol == scan) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Skip comment lines.
        */</span>
        <span class="enscript-keyword">if</span> (scan[0] == <span class="enscript-string">'#'</span>) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Scan past any non-symbol characters at the beginning of the line. */</span>
        <span class="enscript-keyword">while</span> ((scan &lt; eol) &amp;&amp; !issymchar(*scan)) {
            scan++;
        }

       <span class="enscript-comment">/* No symbol on line? Move along.
        */</span>
        <span class="enscript-keyword">if</span> (scan == eol) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Skip symbols starting with '.'.
        */</span>
        <span class="enscript-keyword">if</span> (scan[0] == <span class="enscript-string">'.'</span>) {
            <span class="enscript-keyword">continue</span>;
        }
        nsyms++;
    }
    
    <span class="enscript-keyword">return</span> nsyms;
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">store_symbols</span>(<span class="enscript-type">char</span> * file, vm_size_t file_size, <span class="enscript-type">struct</span> symbol * symbols, uint32_t idx, uint32_t max_symbols)
{
    <span class="enscript-type">char</span> *   scan;
    <span class="enscript-type">char</span> *   line;
    <span class="enscript-type">char</span> *   eol;
    <span class="enscript-type">char</span> *   next;

    uint32_t strtabsize;

    strtabsize = 0;

    <span class="enscript-keyword">for</span> (scan = file, line = file; true; scan = next, line = next) {

        <span class="enscript-type">char</span> *       name = NULL;
        <span class="enscript-type">char</span> *       name_term = NULL;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> name_len = 0;
        <span class="enscript-type">char</span> *       indirect = NULL;
        <span class="enscript-type">char</span> *       indirect_term = NULL;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> indirect_len = 0;
        <span class="enscript-type">char</span> *       option = NULL;
        <span class="enscript-type">char</span> *       option_term = NULL;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> option_len = 0;
        <span class="enscript-type">char</span>         optionstr[256];
        boolean_t    obsolete = 0;

        eol = memchr(scan, <span class="enscript-string">'\n'</span>, file_size - (scan - file));
        <span class="enscript-keyword">if</span> (eol == NULL) {
            <span class="enscript-keyword">break</span>;
        }
        next = eol + 1;

       <span class="enscript-comment">/* Skip empty lines.
        */</span>
        <span class="enscript-keyword">if</span> (eol == scan) {
            <span class="enscript-keyword">continue</span>;
        }

        *eol = <span class="enscript-string">'\0'</span>;

       <span class="enscript-comment">/* Skip comment lines.
        */</span>
        <span class="enscript-keyword">if</span> (scan[0] == <span class="enscript-string">'#'</span>) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Scan past any non-symbol characters at the beginning of the line. */</span>
        <span class="enscript-keyword">while</span> ((scan &lt; eol) &amp;&amp; !issymchar(*scan)) {
            scan++;
        }

       <span class="enscript-comment">/* No symbol on line? Move along.
        */</span>
        <span class="enscript-keyword">if</span> (scan == eol) {
            <span class="enscript-keyword">continue</span>;
        }

       <span class="enscript-comment">/* Skip symbols starting with '.'.
        */</span>
        <span class="enscript-keyword">if</span> (scan[0] == <span class="enscript-string">'.'</span>) {
            <span class="enscript-keyword">continue</span>;
        }

        name = scan;

       <span class="enscript-comment">/* Find the end of the symbol.
        */</span>
        <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; issymchar(*scan)) {
            scan++;
        }

       <span class="enscript-comment">/* Note char past end of symbol.
        */</span>
        name_term = scan;

       <span class="enscript-comment">/* Stored length must include the terminating nul char.
        */</span>
        name_len = name_term - name + 1;

       <span class="enscript-comment">/* Now look for an indirect.
        */</span>
        <span class="enscript-keyword">if</span> (*scan != <span class="enscript-string">'\0'</span>) {
            <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; iswhitespace(*scan)) {
                scan++;
            }
            <span class="enscript-keyword">if</span> (*scan == <span class="enscript-string">':'</span>) {
                scan++;
                <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; iswhitespace(*scan)) {
                    scan++;
                }
                <span class="enscript-keyword">if</span> (issymchar(*scan)) {
                    indirect = scan;

                   <span class="enscript-comment">/* Find the end of the symbol.
                    */</span>
                    <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; issymchar(*scan)) {
                        scan++;
                    }

                   <span class="enscript-comment">/* Note char past end of symbol.
                    */</span>
                    indirect_term = scan;

                   <span class="enscript-comment">/* Stored length must include the terminating nul char.
                    */</span>
                    indirect_len = indirect_term - indirect + 1;

                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*scan == <span class="enscript-string">'\0'</span>) {
		    fprintf(stderr, <span class="enscript-string">&quot;bad format in symbol line: %s\n&quot;</span>, line);
		    exit(1);
		}
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*scan != <span class="enscript-string">'\0'</span> &amp;&amp; *scan != <span class="enscript-string">'-'</span>) {
                fprintf(stderr, <span class="enscript-string">&quot;bad format in symbol line: %s\n&quot;</span>, line);
                exit(1);
            }
        }

        <span class="enscript-comment">/* Look for options.
         */</span>
        <span class="enscript-keyword">if</span> (*scan != <span class="enscript-string">'\0'</span>) {
            <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; iswhitespace(*scan)) {
                scan++;
            }

            <span class="enscript-keyword">if</span> (*scan == <span class="enscript-string">'-'</span>) {
                scan++;

                <span class="enscript-keyword">if</span> (isalpha(*scan)) {
                    option = scan;

                   <span class="enscript-comment">/* Find the end of the option.
                    */</span>
                    <span class="enscript-keyword">while</span> ((*scan != <span class="enscript-string">'\0'</span>) &amp;&amp; isalpha(*scan)) {
                        scan++;
                    }

                   <span class="enscript-comment">/* Note char past end of option.
                    */</span>
                    option_term = scan;
                    option_len = option_term - option;

                    <span class="enscript-keyword">if</span> (option_len &gt;= <span class="enscript-keyword">sizeof</span>(optionstr)) {
                        fprintf(stderr, <span class="enscript-string">&quot;option too long in symbol line: %s\n&quot;</span>, line);
                        exit(1);
                    }
                    memcpy(optionstr, option, option_len);
                    optionstr[option_len] = <span class="enscript-string">'\0'</span>;

                    <span class="enscript-comment">/* Find the option.
                     */</span>
                    <span class="enscript-keyword">if</span> (!strncmp(optionstr, <span class="enscript-string">&quot;obsolete&quot;</span>, option_len)) {
                        obsolete = TRUE;
                    }

                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*scan == <span class="enscript-string">'\0'</span>) {
		    fprintf(stderr, <span class="enscript-string">&quot;bad format in symbol line: %s\n&quot;</span>, line);
		    exit(1);
		}

            }

        }

        <span class="enscript-keyword">if</span>(idx &gt;= max_symbols) {
            fprintf(stderr, <span class="enscript-string">&quot;symbol[%d/%d] overflow: %s\n&quot;</span>, idx, max_symbols, line);
            exit(1);
        }

        *name_term = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">if</span> (indirect_term) {
            *indirect_term = <span class="enscript-string">'\0'</span>;
        }
        
        symbols[idx].name = name;
        symbols[idx].name_len = name_len;
        symbols[idx].indirect = indirect;
        symbols[idx].indirect_len = indirect_len;
        symbols[idx].flags = (obsolete) ? kObsolete : 0;

        strtabsize += symbols[idx].name_len + symbols[idx].indirect_len;
        idx++;
    }

    <span class="enscript-keyword">return</span> strtabsize;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> NXArchInfo *
<span class="enscript-function-name">lookup_arch</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *archstring)
{
	<span class="enscript-comment">/*
	 * As new architectures are supported by xnu, add a mapping function
	 * without relying on host libraries.
	 */</span>
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> NXArchInfo archlist[] = {
		{ <span class="enscript-string">&quot;x86_64&quot;</span>, 0x01000007 <span class="enscript-comment">/* CPU_TYPE_X86_64 */</span>, 3 <span class="enscript-comment">/* CPU_SUBTYPE_X86_64_ALL */</span>, NX_LittleEndian, NULL },
		{ <span class="enscript-string">&quot;x86_64h&quot;</span>, 0x01000007 <span class="enscript-comment">/* CPU_TYPE_X86_64 */</span>, 8 <span class="enscript-comment">/* CPU_SUBTYPE_X86_64_H */</span>, NX_LittleEndian, NULL },
	};
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;

	<span class="enscript-keyword">for</span> (i=0; i &lt; <span class="enscript-keyword">sizeof</span>(archlist)/<span class="enscript-keyword">sizeof</span>(archlist[0]); i++) {
		<span class="enscript-keyword">if</span> (0 == strcmp(archstring, archlist[i].name)) {
			<span class="enscript-keyword">return</span> &amp;archlist[i];
		}
	}

	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">main</span>(<span class="enscript-type">int</span> argc, <span class="enscript-type">char</span> * argv[])
{
    ToolError	err;
    <span class="enscript-type">int</span>			i, fd;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *	output_name = NULL;
    uint32_t		zero = 0, num_files = 0;
    uint32_t		filenum;
    uint32_t		strx, strtabsize, strtabpad;
    <span class="enscript-type">struct</span> symbol *	import_symbols;
    <span class="enscript-type">struct</span> symbol *	export_symbols;
    uint32_t		num_import_syms, num_export_syms;
    uint32_t		result_count, num_removed_syms;
    uint32_t		import_idx, export_idx;
    <span class="enscript-type">const</span> NXArchInfo *	host_arch;
    <span class="enscript-type">const</span> NXArchInfo *	target_arch;
    boolean_t		require_imports = true;
    boolean_t		diff = false;


    <span class="enscript-type">struct</span> file {
        vm_offset_t  mapped;
        vm_size_t    mapped_size;
	uint32_t     nsyms;
	boolean_t    import;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * path;
    };
    <span class="enscript-type">struct</span> file files[64];
    
    host_arch = NXGetLocalArchInfo();
    target_arch = host_arch;

    <span class="enscript-keyword">for</span>( i = 1; i &lt; argc; i += 2)
    {
	boolean_t import;

        <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-sect&quot;</span>, argv[i]))
        {
	    require_imports = false;
	    i--;
	    <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-diff&quot;</span>, argv[i]))
        {
	    require_imports = false;
	    diff = true;
	    i--;
	    <span class="enscript-keyword">continue</span>;
        }

	<span class="enscript-keyword">if</span> (i == (argc - 1))
	{
	    fprintf(stderr, <span class="enscript-string">&quot;bad arguments: %s\n&quot;</span>, argv[i]);
	    exit(1);
	}

        <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-arch&quot;</span>, argv[i]))
        {
            target_arch = lookup_arch(argv[i + 1]);
	    <span class="enscript-keyword">if</span> (!target_arch)
	    {
		fprintf(stderr, <span class="enscript-string">&quot;unknown architecture name: %s\n&quot;</span>, argv[i+1]);
		exit(1);
	    }
            <span class="enscript-keyword">continue</span>;
        }
        <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-output&quot;</span>, argv[i]))
        {
	    output_name = argv[i+1];
            <span class="enscript-keyword">continue</span>;
        }

        <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-import&quot;</span>, argv[i]))
	    import = true;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(<span class="enscript-string">&quot;-export&quot;</span>, argv[i]))
	    import = false;
	<span class="enscript-keyword">else</span>
	{
	    fprintf(stderr, <span class="enscript-string">&quot;unknown option: %s\n&quot;</span>, argv[i]);
	    exit(1);
	}

        err = readFile(argv[i+1], &amp;files[num_files].mapped, &amp;files[num_files].mapped_size);
        <span class="enscript-keyword">if</span> (kErrorNone != err)
            exit(1);

        <span class="enscript-keyword">if</span> (files[num_files].mapped &amp;&amp; files[num_files].mapped_size)
	{
	    files[num_files].import = import;
	    files[num_files].path   = argv[i+1];
            num_files++;
	}
    }

    <span class="enscript-keyword">if</span> (!output_name)
    {
	fprintf(stderr, <span class="enscript-string">&quot;no output file\n&quot;</span>);
	exit(1);
    }

    num_import_syms = 0;
    num_export_syms = 0;
    <span class="enscript-keyword">for</span> (filenum = 0; filenum &lt; num_files; filenum++)
    {
        files[filenum].nsyms = count_symbols((<span class="enscript-type">char</span> *) files[filenum].mapped, files[filenum].mapped_size);
	<span class="enscript-keyword">if</span> (files[filenum].import)
	    num_import_syms += files[filenum].nsyms;
	<span class="enscript-keyword">else</span>
	    num_export_syms += files[filenum].nsyms;
    }
    <span class="enscript-keyword">if</span> (!num_export_syms)
    {
	fprintf(stderr, <span class="enscript-string">&quot;no export names\n&quot;</span>);
	exit(1);
    }

    import_symbols = calloc(num_import_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol));
    export_symbols = calloc(num_export_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol));

    import_idx = 0;
    export_idx = 0;

    <span class="enscript-keyword">for</span> (filenum = 0; filenum &lt; num_files; filenum++)
    {
	<span class="enscript-keyword">if</span> (files[filenum].import)
	{
	    store_symbols((<span class="enscript-type">char</span> *) files[filenum].mapped, files[filenum].mapped_size,
					import_symbols, import_idx, num_import_syms);
	    import_idx += files[filenum].nsyms;
	}
	<span class="enscript-keyword">else</span>
	{
	    store_symbols((<span class="enscript-type">char</span> *) files[filenum].mapped, files[filenum].mapped_size,
					export_symbols, export_idx, num_export_syms);
	    export_idx += files[filenum].nsyms;
	}
	<span class="enscript-keyword">if</span> (false &amp;&amp; !files[filenum].nsyms)
	{
	    fprintf(stderr, <span class="enscript-string">&quot;warning: file %s contains no names\n&quot;</span>, files[filenum].path);
	}
    }


    qsort(import_symbols, num_import_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol), &amp;qsort_cmp);
    qsort(export_symbols, num_export_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol), &amp;qsort_cmp);

    result_count = 0;
    num_removed_syms = 0;
    strtabsize = 4;
    <span class="enscript-keyword">if</span> (num_import_syms)
    {
	<span class="enscript-keyword">for</span> (export_idx = 0; export_idx &lt; num_export_syms; export_idx++)
	{
	    <span class="enscript-type">struct</span> symbol * result;
	    <span class="enscript-type">char</span> * name;
	    size_t len;
	    boolean_t wild;

	    name = export_symbols[export_idx].indirect;
	    len  = export_symbols[export_idx].indirect_len;
	    <span class="enscript-keyword">if</span> (!name)
	    {
		name = export_symbols[export_idx].name;
		len  = export_symbols[export_idx].name_len;
	    }
	    wild = ((len &gt; 2) &amp;&amp; (<span class="enscript-string">'*'</span> == name[len-=2]));
	    <span class="enscript-keyword">if</span> (wild)
	    {
		<span class="enscript-type">struct</span> bsearch_key key;
		key.name = name;
		key.name_len = len;
		result = bsearch(&amp;key, import_symbols, 
				    num_import_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol), &amp;bsearch_cmp_prefix);

		<span class="enscript-keyword">if</span> (result)
		{
		    <span class="enscript-type">struct</span> symbol * first;
		    <span class="enscript-type">struct</span> symbol * last;

		    strtabsize += (result-&gt;name_len + result-&gt;indirect_len);

		    first = result;
		    <span class="enscript-keyword">while</span> (--first &gt;= &amp;import_symbols[0])
		    {
			<span class="enscript-keyword">if</span> (bsearch_cmp_prefix(&amp;key, first))
			    <span class="enscript-keyword">break</span>;
			strtabsize += (first-&gt;name_len + first-&gt;indirect_len);
		    }
		    first++;

		    last = result;
		    <span class="enscript-keyword">while</span> (++last &lt; (&amp;import_symbols[0] + num_import_syms))
		    {
			<span class="enscript-keyword">if</span> (bsearch_cmp_prefix(&amp;key, last))
			    <span class="enscript-keyword">break</span>;
			strtabsize += (last-&gt;name_len + last-&gt;indirect_len);
		    }
		    result_count += last - first;
		    result = first;
		    export_symbols[export_idx].list = first;
		    export_symbols[export_idx].list_count = last - first;
		    export_symbols[export_idx].flags |= kExported;
		}
	    }
	    <span class="enscript-keyword">else</span>
		result = bsearch(name, import_symbols, 
				    num_import_syms, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> symbol), &amp;bsearch_cmp);

	    <span class="enscript-keyword">if</span> (!result &amp;&amp; require_imports)
	    {
		<span class="enscript-type">int</span> status;
		<span class="enscript-type">char</span> * demangled_result = 
			__cxa_demangle(export_symbols[export_idx].name + 1, NULL, NULL, &amp;status);
		fprintf(stderr, <span class="enscript-string">&quot;exported name not in import list: %s\n&quot;</span>,
					demangled_result ? demangled_result : export_symbols[export_idx].name);
<span class="enscript-comment">//		fprintf(stderr, &quot;                                : %s\n&quot;, export_symbols[export_idx].name);
</span>		<span class="enscript-keyword">if</span> (demangled_result) {
			free(demangled_result);
		}
		num_removed_syms++;
	    }
	    <span class="enscript-keyword">if</span> (diff)
	    {
		<span class="enscript-keyword">if</span> (!result)
		    result = &amp;export_symbols[export_idx];
		<span class="enscript-keyword">else</span>
		    result = NULL;
	    }
	    <span class="enscript-keyword">if</span> (result &amp;&amp; !wild)
	    {
		export_symbols[export_idx].flags |= kExported;
		strtabsize += (export_symbols[export_idx].name_len + export_symbols[export_idx].indirect_len);
		result_count++;
		export_symbols[export_idx].list = &amp;export_symbols[export_idx];
		export_symbols[export_idx].list_count = 1;
	    }
	}
    }
    strtabpad = (strtabsize + 3) &amp; ~3;

    <span class="enscript-keyword">if</span> (require_imports &amp;&amp; num_removed_syms)
    {
	err = kError;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    fd = open(output_name, O_WRONLY|O_CREAT|O_TRUNC, 0755);
    <span class="enscript-keyword">if</span> (-1 == fd)
    {
	perror(<span class="enscript-string">&quot;couldn't write output&quot;</span>);
	err = kErrorFileAccess;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-type">struct</span> symtab_command symcmd;
    <span class="enscript-type">struct</span> uuid_command uuidcmd;
    off_t  symsoffset;

    symcmd.cmd		= LC_SYMTAB;
    symcmd.cmdsize	= <span class="enscript-keyword">sizeof</span>(symcmd);
    symcmd.nsyms	= result_count;
    symcmd.strsize	= strtabpad;

    uuidcmd.cmd         = LC_UUID;
    uuidcmd.cmdsize     = <span class="enscript-keyword">sizeof</span>(uuidcmd);
    uuid_generate(uuidcmd.uuid);

    <span class="enscript-keyword">if</span> (CPU_ARCH_ABI64 &amp; target_arch-&gt;cputype)
    {
	<span class="enscript-type">struct</span> mach_header_64     hdr;
	<span class="enscript-type">struct</span> segment_command_64 segcmd;

	hdr.magic	= MH_MAGIC_64;
	hdr.cputype	= target_arch-&gt;cputype;
	hdr.cpusubtype	= target_arch-&gt;cpusubtype;
	hdr.filetype	= MH_KEXT_BUNDLE;
	hdr.ncmds	= 3;
	hdr.sizeofcmds	= <span class="enscript-keyword">sizeof</span>(segcmd) + <span class="enscript-keyword">sizeof</span>(symcmd) + <span class="enscript-keyword">sizeof</span>(uuidcmd);
	hdr.flags	= MH_INCRLINK;
	symsoffset      = mach_vm_round_page(hdr.sizeofcmds);

        segcmd.cmd      = LC_SEGMENT_64;
        segcmd.cmdsize  = <span class="enscript-keyword">sizeof</span>(segcmd);
	strncpy(segcmd.segname, SEG_LINKEDIT, <span class="enscript-keyword">sizeof</span>(segcmd.segname));
        segcmd.vmaddr   = 0;
        segcmd.vmsize   = result_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nlist_64) + strtabpad;
        segcmd.fileoff  = symsoffset;
        segcmd.filesize = segcmd.vmsize;
        segcmd.maxprot  = PROT_READ;
        segcmd.initprot = PROT_READ;
        segcmd.nsects   = 0;
        segcmd.flags    = SG_NORELOC;

	symcmd.symoff	= symsoffset;
	symcmd.stroff	= result_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nlist_64) 
				+ symcmd.symoff;

	<span class="enscript-keyword">if</span> (target_arch-&gt;byteorder != host_arch-&gt;byteorder)
	{
	    swap_mach_header_64(&amp;hdr, target_arch-&gt;byteorder);
	    swap_segment_command_64(&amp;segcmd, target_arch-&gt;byteorder);
	}
	err = writeFile(fd, &amp;hdr, <span class="enscript-keyword">sizeof</span>(hdr));
        <span class="enscript-keyword">if</span> (kErrorNone != err)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	err = writeFile(fd, &amp;segcmd, <span class="enscript-keyword">sizeof</span>(segcmd));
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-type">struct</span> mach_header     hdr;
	<span class="enscript-type">struct</span> segment_command segcmd;

	hdr.magic	= MH_MAGIC;
	hdr.cputype	= target_arch-&gt;cputype;
	hdr.cpusubtype	= target_arch-&gt;cpusubtype;
	hdr.filetype	= MH_KEXT_BUNDLE;
	hdr.ncmds	= 3;
	hdr.sizeofcmds	= <span class="enscript-keyword">sizeof</span>(segcmd) + <span class="enscript-keyword">sizeof</span>(symcmd) + <span class="enscript-keyword">sizeof</span>(uuidcmd);
	hdr.flags	= MH_INCRLINK;
        symsoffset      = mach_vm_round_page(hdr.sizeofcmds);

        segcmd.cmd      = LC_SEGMENT;
        segcmd.cmdsize  = <span class="enscript-keyword">sizeof</span>(segcmd);
	strncpy(segcmd.segname, SEG_LINKEDIT, <span class="enscript-keyword">sizeof</span>(segcmd.segname));
        segcmd.vmaddr   = 0;
        segcmd.vmsize   = result_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nlist) + strtabpad;
        segcmd.fileoff  = symsoffset;
        segcmd.filesize = segcmd.vmsize;
        segcmd.maxprot  = PROT_READ;
        segcmd.initprot = PROT_READ;
        segcmd.nsects   = 0;
        segcmd.flags    = SG_NORELOC;

	symcmd.symoff	= symsoffset;
	symcmd.stroff	= result_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nlist) 
				+ symcmd.symoff;

	<span class="enscript-keyword">if</span> (target_arch-&gt;byteorder != host_arch-&gt;byteorder)
	{
	    swap_mach_header(&amp;hdr, target_arch-&gt;byteorder);
	    swap_segment_command(&amp;segcmd, target_arch-&gt;byteorder);
	}
	err = writeFile(fd, &amp;hdr, <span class="enscript-keyword">sizeof</span>(hdr));
        <span class="enscript-keyword">if</span> (kErrorNone != err)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	err = writeFile(fd, &amp;segcmd, <span class="enscript-keyword">sizeof</span>(segcmd));
    }

    <span class="enscript-keyword">if</span> (kErrorNone != err)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;

    <span class="enscript-keyword">if</span> (target_arch-&gt;byteorder != host_arch-&gt;byteorder) {
        swap_symtab_command(&amp;symcmd, target_arch-&gt;byteorder);
        swap_uuid_command(&amp;uuidcmd, target_arch-&gt;byteorder);
    }
    err = writeFile(fd, &amp;symcmd, <span class="enscript-keyword">sizeof</span>(symcmd));
    <span class="enscript-keyword">if</span> (kErrorNone != err)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    err = writeFile(fd, &amp;uuidcmd, <span class="enscript-keyword">sizeof</span>(uuidcmd));
    <span class="enscript-keyword">if</span> (kErrorNone != err)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;

    err = seekFile(fd, symsoffset);
    <span class="enscript-keyword">if</span> (kErrorNone != err)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;

    strx = 4;
    <span class="enscript-keyword">for</span> (export_idx = 0; export_idx &lt; num_export_syms; export_idx++)
    {
	<span class="enscript-keyword">if</span> (!export_symbols[export_idx].name)
	    <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">if</span> (!(kExported &amp; export_symbols[export_idx].flags))
	    <span class="enscript-keyword">continue</span>;

	<span class="enscript-keyword">if</span> (export_idx
	  &amp;&amp; export_symbols[export_idx - 1].name
	  &amp;&amp; !strcmp(export_symbols[export_idx - 1].name, export_symbols[export_idx].name))
	{
	    fprintf(stderr, <span class="enscript-string">&quot;duplicate export: %s\n&quot;</span>, export_symbols[export_idx - 1].name);
	    err = kErrorDuplicate;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	}

	<span class="enscript-keyword">for</span> (import_idx = 0; import_idx &lt; export_symbols[export_idx].list_count; import_idx++)
	{

	    <span class="enscript-keyword">if</span> (export_symbols[export_idx].list != &amp;export_symbols[export_idx])
	    {
		printf(<span class="enscript-string">&quot;wild: %s, %s\n&quot;</span>, export_symbols[export_idx].name, 
			export_symbols[export_idx].list[import_idx].name);
	    }
	    <span class="enscript-keyword">if</span> (CPU_ARCH_ABI64 &amp; target_arch-&gt;cputype)
	    {
		<span class="enscript-type">struct</span> nlist_64 nl;

		nl.n_sect  = 0;
                nl.n_desc  = 0;
		nl.n_un.n_strx = strx;
		strx += export_symbols[export_idx].list[import_idx].name_len;
                
                <span class="enscript-keyword">if</span> (export_symbols[export_idx].flags &amp; kObsolete) {
                    nl.n_desc |= N_DESC_DISCARDED;
                }

		<span class="enscript-keyword">if</span> (export_symbols[export_idx].list[import_idx].indirect)
		{
		    nl.n_type  = N_INDR | N_EXT;
		    nl.n_value = strx;
		    strx += export_symbols[export_idx].list[import_idx].indirect_len;
		}
		<span class="enscript-keyword">else</span>
		{
		    nl.n_type  = N_UNDF | N_EXT;
		    nl.n_value = 0;
		}

		<span class="enscript-keyword">if</span> (target_arch-&gt;byteorder != host_arch-&gt;byteorder)
		    swap_nlist_64(&amp;nl, 1, target_arch-&gt;byteorder);

		err = writeFile(fd, &amp;nl, <span class="enscript-keyword">sizeof</span>(nl));
	    }
	    <span class="enscript-keyword">else</span>
	    {
		<span class="enscript-type">struct</span> nlist nl;

		nl.n_sect  = 0;
		nl.n_desc  = 0;
		nl.n_un.n_strx = strx;
		strx += export_symbols[export_idx].list[import_idx].name_len;
 
                <span class="enscript-keyword">if</span> (export_symbols[export_idx].flags &amp; kObsolete) {
                    nl.n_desc |= N_DESC_DISCARDED;
                }

		<span class="enscript-keyword">if</span> (export_symbols[export_idx].list[import_idx].indirect)
		{
		    nl.n_type  = N_INDR | N_EXT;
		    nl.n_value = strx;
		    strx += export_symbols[export_idx].list[import_idx].indirect_len;
		}
		<span class="enscript-keyword">else</span>
		{
		    nl.n_type  = N_UNDF | N_EXT;
		    nl.n_value = 0;
		}

		<span class="enscript-keyword">if</span> (target_arch-&gt;byteorder != host_arch-&gt;byteorder)
		    swap_nlist(&amp;nl, 1, target_arch-&gt;byteorder);

		err = writeFile(fd, &amp;nl, <span class="enscript-keyword">sizeof</span>(nl));
	    }
	}

	<span class="enscript-keyword">if</span> (kErrorNone != err)
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    strx = <span class="enscript-keyword">sizeof</span>(uint32_t);
    err = writeFile(fd, &amp;zero, strx);
    <span class="enscript-keyword">if</span> (kErrorNone != err)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;

    <span class="enscript-keyword">for</span> (export_idx = 0; export_idx &lt; num_export_syms; export_idx++)
    {
	<span class="enscript-keyword">if</span> (!export_symbols[export_idx].name)
	    <span class="enscript-keyword">continue</span>;

	<span class="enscript-keyword">for</span> (import_idx = 0; import_idx &lt; export_symbols[export_idx].list_count; import_idx++)
	{
	    err = writeFile(fd, export_symbols[export_idx].list[import_idx].name, 
			export_symbols[export_idx].list[import_idx].name_len);
	    <span class="enscript-keyword">if</span> (kErrorNone != err)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	    <span class="enscript-keyword">if</span> (export_symbols[export_idx].list[import_idx].indirect)
	    {
		err = writeFile(fd, export_symbols[export_idx].list[import_idx].indirect, 
			    export_symbols[export_idx].list[import_idx].indirect_len);
		<span class="enscript-keyword">if</span> (kErrorNone != err)
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	    }
	}
    }

    err = writeFile(fd, &amp;zero, strtabpad - strtabsize);
    <span class="enscript-keyword">if</span> (kErrorNone != err)
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
	
    close(fd);


<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">for</span> (filenum = 0; filenum &lt; num_files; filenum++) {
        <span class="enscript-comment">// unmap file
</span>        <span class="enscript-keyword">if</span> (files[filenum].mapped_size)
        {
            munmap((caddr_t)files[filenum].mapped, files[filenum].mapped_size);
            files[filenum].mapped     = 0;
            files[filenum].mapped_size = 0;
        }

    }

    <span class="enscript-keyword">if</span> (kErrorNone != err)
    {
	<span class="enscript-keyword">if</span> (output_name &amp;&amp; strncmp(output_name, <span class="enscript-string">&quot;/dev/&quot;</span>, 5))
	    unlink(output_name);
        exit(1);
    }
    <span class="enscript-keyword">else</span>
        exit(0);
    <span class="enscript-keyword">return</span>(0);
}

</pre>
<hr />
</body></html>