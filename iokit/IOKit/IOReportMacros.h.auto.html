<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOReportMacros.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOReportMacros.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2014 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOREPORT_MACROS_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOREPORT_MACROS_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOReportTypes.h&quot;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IOREPORT_ABORT</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOREPORT_ABORT</span> panic
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
    Background

    These macros allow non-I/O Kit software to generate IOReporting
    reports.  Clients must prevent concurrent access to any given
    report buffer from multiple threads.

    While these macros allow non-I/O Kit software to participate
    in IOReporting, an IOService instance must lend its driver ID,
    respond to the appropriate IOService overrides, and shuttle
    data back and forth.  In some cases, it may be useful to have
    the I/O Kit driver initialize the report buffer with the
    appropriate macro.
*/</span>


<span class="enscript-comment">/* ----- Reporting Single Integers (SimpleReport) ----- */</span>

<span class="enscript-comment">/*
 * The buffer size required for a SimpleReport.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SIMPLEREPORT_BUFSIZE</span>   (sizeof(IOReportElement))


<span class="enscript-comment">/*
 * Initialize a buffer to hold a SimpleReport.
 *
 *                  void* buffer - ptr to SIMPLEREPORT_BUFSIZE bytes
 *                size_t bufSize - sanity check of buffer's size
 *           uint64_t providerID - registry Entry ID of the reporting service
 *            uint64_t channelID - the report's channel ID
 * IOReportCategories categories - categories of this channel
 *
 * If the buffer is not of sufficient size, the macro calls IOREPORT_ABORT().
 * If that returns, the buffer is filled with 0xbadcafe.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_INIT</span>(buffer, bufSize, providerID, channelID, cats)  \
<span class="enscript-keyword">do</span> {  \
    IOReportElement     *__elem = (IOReportElement *)(buffer);  \
    IOSimpleReportValues *__vals;  \
    <span class="enscript-keyword">if</span> ((bufSize) &gt;= SIMPLEREPORT_BUFSIZE) {  \
        __elem-&gt;channel_id = (channelID);  \
        __elem-&gt;provider_id = (providerID);  \
        __elem-&gt;channel_type.report_format = kIOReportFormatSimple;  \
        __elem-&gt;channel_type.reserved = 0;  \
        __elem-&gt;channel_type.categories = (cats);  \
        __elem-&gt;channel_type.nelements = 1;  \
        __elem-&gt;channel_type.element_idx = 0;  \
        __elem-&gt;timestamp = 0;  \
        __vals = (IOSimpleReportValues*)&amp;__elem-&gt;values;  \
        __vals-&gt;simple_value = kIOReportInvalidIntValue;  \
    }  \
    <span class="enscript-keyword">else</span> {  \
        IOREPORT_ABORT(<span class="enscript-string">&quot;bufSize is smaller than the required size\n&quot;</span>);  \
        __POLLUTE_BUF((buffer), (bufSize));  \
    }  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Set a SimpleReport to a new value.
 *
 *    void* simp_buf - ptr to memory initialized by SIMPLEREPORT_INIT()
 * int64_t new_value - new value for the report
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_SETVALUE</span>(simp_buf, new_value)  \
<span class="enscript-keyword">do</span> {  \
    IOReportElement *__elem = (IOReportElement *)(simp_buf);  \
    IOSimpleReportValues *__vals;  \
    __vals = (IOSimpleReportValues*)&amp;__elem-&gt;values;  \
    __vals-&gt;simple_value = (new_value);  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Increment the value of a SimpleReport.
 *
 *    void* simp_buf - ptr to memory initialized by SIMPLEREPORT_INIT()
 * int64_t increment - amount by which to increment the value
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_INCREMENTVALUE</span>(simp_buf, new_value)  \
<span class="enscript-keyword">do</span> {  \
    IOReportElement *__elem = (IOReportElement *)(simp_buf);  \
    IOSimpleReportValues *__vals;  \
    __vals = (IOSimpleReportValues*)&amp;__elem-&gt;values;  \
    __vals-&gt;simple_value += (new_value);  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Prepare a SimpleReport for
 * IOService::updateReport(kIOReportCopyChannelData...)
 *
 * void* simp_buf  - Ptr to memory updated by SIMPLEREPORT_SETVALUE()
 * void* ptr2cpy   - On return, 'ptr2cpy' points to the memory that needs to be
 *                   copied for kIOReportCopyChannelData.
 * size_t size2cpy - On return, 'size2cpy' is set to the size of the report
 *                   data that needs to be copied for kIOReportCopyChannelData.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_UPDATEPREP</span>(simp_buf, ptr2cpy, size2cpy)  \
<span class="enscript-keyword">do</span> {  \
    (ptr2cpy) = (simp_buf);  \
    (size2cpy) = <span class="enscript-keyword">sizeof</span>(IOReportElement);  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Update the result field received as a parameter for
 * kIOReportGetDimensions &amp; kIOReportCopyChannelData actions.
 *
 * IOReportConfigureAction action - configure/updateReport() 'action' param
 *                   void* result - configure/updateReport() 'result' param
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_UPDATERES</span>(action, result)  \
<span class="enscript-keyword">do</span> {  \
    <span class="enscript-keyword">if</span> (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  \
        <span class="enscript-type">int</span> *__nElements = (<span class="enscript-type">int</span> *)(result);  \
        *__nElements += 1;  \
    }  \
} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * Get the 64-bit channel ID of a SimpleReport.
 *
 * void* simp_buf - ptr to memory initialized by SIMPLEREPORT_INIT()
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_GETCHID</span>(simp_buf)  \
    (((IOReportElement *)(simp_buf))-&gt;channel_id)

<span class="enscript-comment">/*
 * Get the IOReportChannelType of a SimpleReport.
 *
 * void* simp_buf - ptr to memory initialized by SIMPLEREPORT_INIT()
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_GETCHTYPE</span>(simp_buf)  \
    (*(uint64_t*)&amp;(((IOReportElement *)(simp_buf))-&gt;channel_type))


<span class="enscript-comment">/*
 * Get the integer value of a SimpleReport.
 *
 * void* simp_buf - memory initialized by SIMPLEREPORT_INIT()
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEREPORT_GETVALUE</span>(simp_buf)  \
    (((IOSimpleReportValues*)&amp;(((IOReportElement*)(simp_buf))-&gt;values))  \
            -&gt;simple_value)


<span class="enscript-comment">/* ----- State Machine Reporting (StateReport) ----- */</span>

<span class="enscript-comment">// Internal struct for StateReport
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
   uint16_t        curr_state;
   uint64_t        update_ts;
   IOReportElement elem[]; <span class="enscript-comment">// Array of elements
</span>} IOStateReportInfo;

<span class="enscript-comment">/*
 * Determine the size required for a StateReport buffer.
 *
 * int nstates - number of states to be reported
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_BUFSIZE</span>(nstates)  \
    (<span class="enscript-keyword">sizeof</span>(IOStateReportInfo) + (nstates) * <span class="enscript-keyword">sizeof</span>(IOReportElement))


<span class="enscript-comment">/*
 * Initialize a StateReport buffer.
 *
 *                   int nstates - number of states to be reported
 *                  void* buffer - ptr to STATEREPORT_BUFSIZE(nstates) bytes
 *                size_t bufSize - sanity check of buffer's size
 *           uint64_t providerID - registry Entry ID of the reporting service
 *            uint64_t channelID - ID of this channel, see IOREPORT_MAKEID()
 * IOReportCategories categories - categories of this channel
 *
 * If the buffer is not of sufficient size, the macro invokes IOREPORT_ABORT.
 * If that returns, the buffer is filled with 0xbadcafe.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_INIT</span>(nstates, buf, bufSize, providerID, channelID, cats) \
<span class="enscript-keyword">do</span> {  \
    IOStateReportInfo *__info = (IOStateReportInfo *)(buf);  \
    IOStateReportValues *__rep;  \
    IOReportElement     *__elem;  \
    <span class="enscript-keyword">if</span> ((bufSize) &gt;= STATEREPORT_BUFSIZE(nstates)) {  \
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> __no = 0; __no &lt; (nstates); __no++) {  \
            __elem =  &amp;(__info-&gt;elem[__no]);  \
            __rep = (IOStateReportValues *) &amp;(__elem-&gt;values);  \
            __elem-&gt;channel_id = (channelID);  \
            __elem-&gt;provider_id = (providerID);  \
            __elem-&gt;channel_type.report_format = kIOReportFormatState;  \
            __elem-&gt;channel_type.reserved = 0;  \
            __elem-&gt;channel_type.categories = (cats);  \
            __elem-&gt;channel_type.nelements = (nstates);  \
            __elem-&gt;channel_type.element_idx = __no;  \
            __elem-&gt;timestamp = 0;  \
            __rep-&gt;state_id = __no;  \
            __rep-&gt;intransitions = 0;  \
            __rep-&gt;upticks = 0;  \
        }  \
        __info-&gt;curr_state = 0;  \
        __info-&gt;update_ts = 0;  \
    }  \
    <span class="enscript-keyword">else</span> {  \
        IOREPORT_ABORT(<span class="enscript-string">&quot;bufSize is smaller than the required size\n&quot;</span>);  \
        __POLLUTE_BUF((buf), (bufSize));  \
    }  \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/*
 * Initialize the state id field of a state with the specified value.  By
 * default, STATEREPORT_INIT() initializes the state IDs with the index of
 * that state.  This macro can be used to provide a more descriptive state id.
 *
 *   void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 * unsigned stateIdx - index of the state, out of bounds -&gt; no-op
 *  uint64_t stateID - new state id, see IOREPORT_MAKEID()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_SETSTATEID</span>(state_buf, stateIdx, stateID)  \
<span class="enscript-keyword">do</span> {  \
    IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);  \
    IOStateReportValues *__rep;  \
    <span class="enscript-keyword">if</span> ((stateIdx) &lt; __info-&gt;elem[0].channel_type.nelements) {  \
        __rep = (IOStateReportValues*) &amp;(__info-&gt;elem[(stateIdx)].values);  \
        __rep-&gt;state_id = (stateID);  \
    }  \
} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * Set the state of a StateReport.
 *
 *      void* state_buf - pointer to memory initialized by STATEREPORT_INIT()
 * unsigned newStateIdx - index of new state, out of bounds -&gt; no-op
 *  uint64_t changeTime - time at which the transition occurred
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_SETSTATE</span>(state_buf, newStateIdx, changeTime)  \
<span class="enscript-keyword">do</span> {  \
    IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);  \
    IOStateReportValues *__rep;  \
    <span class="enscript-keyword">if</span> ((newStateIdx) &lt; __info-&gt;elem[0].channel_type.nelements ) {  \
        __rep = (IOStateReportValues*) &amp;(__info-&gt;elem[__info-&gt;curr_state].values);  \
        <span class="enscript-keyword">if</span> (__info-&gt;update_ts)  \
            __rep-&gt;upticks += (changeTime) - __info-&gt;update_ts;  \
        __info-&gt;elem[(newStateIdx)].timestamp = (changeTime);  \
        __rep = (IOStateReportValues*) &amp;(__info-&gt;elem[(newStateIdx)].values);  \
        __rep-&gt;intransitions++;  \
        __info-&gt;curr_state = (newStateIdx);  \
        __info-&gt;update_ts = (changeTime);  \
    }  \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/*
 * Prepare a StateReport for
 * IOService::updateReport(kIOReportCopyChannelData...)
 *
 *      void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 * uint64_t currentTime - current timestamp
 *        void* ptr2cpy - filled in with pointer to buffer to be copied out
 *      size_t size2cpy - filled in with the size of the buffer to copy out
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_UPDATEPREP</span>(state_buf, currentTime, ptr2cpy, size2cpy)  \
<span class="enscript-keyword">do</span> {  \
    IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);  \
    IOReportElement     *__elem;  \
    IOStateReportValues *__state;  \
    (size2cpy) = __info-&gt;elem[0].channel_type.nelements * <span class="enscript-keyword">sizeof</span>(IOReportElement);  \
    (ptr2cpy) =  (<span class="enscript-type">void</span> *) &amp;__info-&gt;elem[0];  \
    <span class="enscript-keyword">if</span> (__info-&gt;update_ts)  {  \
        __elem = &amp;__info-&gt;elem[__info-&gt;curr_state];  \
        __state = (IOStateReportValues *)&amp;__elem-&gt;values;  \
        __elem-&gt;timestamp = (currentTime);  \
        __state-&gt;upticks  += (currentTime) - __info-&gt;update_ts;  \
        __info-&gt;update_ts = (currentTime);  \
    }  \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/*
 * Update the result field received as a parameter for kIOReportGetDimensions &amp;
 * kIOReportCopyChannelData actions.
 *
 *                void* state_buf - memory initialized by STATEREPORT_INIT()
 * IOReportConfigureAction action - configure/updateReport() 'action'
 *                   void* result - configure/updateReport() 'result'
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_UPDATERES</span>(state_buf, action, result)  \
<span class="enscript-keyword">do</span> {  \
    IOStateReportInfo *__info = (IOStateReportInfo *)(state_buf);  \
    IOReportElement     *__elem;  \
    <span class="enscript-type">int</span> *__nElements = (<span class="enscript-type">int</span> *)(result);  \
    <span class="enscript-keyword">if</span> (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  \
        __elem =  &amp;(__info-&gt;elem[0]);  \
        *__nElements += __elem-&gt;channel_type.nelements;  \
    }  \
} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * Get the 64-bit channel ID of a StateReport.
 *
 * void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_GETCHID</span>(state_buf)  \
    (((IOStateReportInfo *)(state_buf))-&gt;elem[0].channel_id)

<span class="enscript-comment">/*
 * Get the IOReportChannelType of a StateReport.
 *
 * void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_GETCHTYPE</span>(state_buf)  \
    (*(uint64_t*)&amp;(((IOStateReportInfo *)(state_buf))-&gt;elem[0].channel_type))

<span class="enscript-comment">/*
 * Get the number of transitions into a given state.
 *
 *   void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 * unsigned stateIdx - index of state, out of bounds -&gt; kIOReportInvalidValue
 *
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_GETTRANSITIONS</span>(state_buf, stateIdx)  \
    (((stateIdx) &lt; ((IOStateReportInfo *)(state_buf))-&gt;elem[0].channel_type.nelements)  \
        ? ((IOStateReportValues*)&amp;(((IOStateReportInfo*)(state_buf))-&gt;elem[(stateIdx)].values))-&gt;intransitions  \
        : kIOReportInvalidValue)

<span class="enscript-comment">/*
 * Get the total number of ticks spent in a given state.
 *
 *   void* state_buf - ptr to memory initialized by STATEREPORT_INIT()
 * unsigned stateIdx - index of state, out of bounds -&gt; kIOReportInvalidValue
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">STATEREPORT_GETTICKS</span>(state_buf, stateIdx)  \
    (((stateIdx) &lt; ((IOStateReportInfo*)(state_buf))-&gt;elem[0].channel_type.nelements)  \
        ? ((IOStateReportValues*)&amp;(((IOStateReportInfo*)(state_buf))-&gt;elem[(stateIdx)].values))-&gt;upticks  \
        : kIOReportInvalidValue)


<span class="enscript-comment">/* ----- Reporting an Array of Integers (SimpleArrayReport) ----- */</span>

<span class="enscript-comment">/*
 * Determine the buffer size for a SimpleArrayReport.
 *
 * int nValues - number of values to be reported
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_BUFSIZE</span>(nValues) \
    ((((nValues)/IOR_VALUES_PER_ELEMENT) + (((nValues) % IOR_VALUES_PER_ELEMENT) ? 1:0)) \
        * <span class="enscript-keyword">sizeof</span>(IOReportElement))

<span class="enscript-comment">/*
 * Initialize a buffer for use as a SimpleArrayReport.
 *
 *                   int nValues   - number of elements to be reported
 *                     void* buf   - ptr to SIMPLEARRAY_BUFSIZE(nValues) bytes
 *                size_t bufSize   - sanity check of buffer's size
 *           uint64_t providerID   - registry Entry ID of the reporting service
 *            uint64_t channelID   - ID of this channel, see IOREPORT_MAKEID()
 * IOReportCategories categories   - categories of this channel
 *
 * If the buffer is not of sufficient size, the macro invokes IOREPORT_ABORT()
 * and, if that returns, fills the buffer with 0xbadcafe.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_INIT</span>(nValues, buf, bufSize, providerID, channelID, cats) \
<span class="enscript-keyword">do</span> {  \
    IOSimpleArrayReportValues *__rep;  \
    IOReportElement     *__elem;  \
    uint32_t            __nElems = (((nValues) / IOR_VALUES_PER_ELEMENT) + \
                                    (((nValues) % IOR_VALUES_PER_ELEMENT) ? 1 : 0)); \
    <span class="enscript-keyword">if</span> ((bufSize) &gt;= SIMPLEARRAY_BUFSIZE(nValues)) {  \
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> __no = 0; __no &lt; __nElems; __no++) {  \
            __elem =  &amp;(((IOReportElement *)(buf))[__no]);  \
            __rep = (IOSimpleArrayReportValues *) &amp;(__elem-&gt;values);  \
            __elem-&gt;channel_id = (channelID);  \
            __elem-&gt;provider_id = (providerID);  \
            __elem-&gt;channel_type.report_format = kIOReportFormatSimpleArray;  \
            __elem-&gt;channel_type.reserved = 0;  \
            __elem-&gt;channel_type.categories = (cats);  \
            __elem-&gt;channel_type.nelements = (__nElems);  \
            __elem-&gt;channel_type.element_idx = __no;  \
            __elem-&gt;timestamp = 0;  \
            __rep-&gt;simple_values[0] = kIOReportInvalidIntValue;  \
            __rep-&gt;simple_values[1] = kIOReportInvalidIntValue;  \
            __rep-&gt;simple_values[2] = kIOReportInvalidIntValue;  \
            __rep-&gt;simple_values[3] = kIOReportInvalidIntValue;  \
        }  \
    }  \
    <span class="enscript-keyword">else</span> {  \
        IOREPORT_ABORT(<span class="enscript-string">&quot;bufSize is smaller than the required size\n&quot;</span>);  \
        __POLLUTE_BUF((buf), (bufSize));  \
    }  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/* SimpleArrayReport helpers */</span>

    #define __SA_FINDREP(array_buf, idx)  \
        IOSimpleArrayReportValues *__rep;  \
        IOReportElement     *__elem;  \
        <span class="enscript-type">unsigned</span> __elemIdx = (idx) / IOR_VALUES_PER_ELEMENT;  \
        <span class="enscript-type">unsigned</span> __valueIdx = (idx) % IOR_VALUES_PER_ELEMENT;  \
        __elem = &amp;(((IOReportElement *)(array_buf))[0]);  \
        <span class="enscript-keyword">if</span> (__elemIdx &lt; __elem-&gt;channel_type.nelements)  { \
            __elem = &amp;(((IOReportElement *)(array_buf))[__elemIdx]);  \
            __rep = (IOSimpleArrayReportValues *) &amp;(__elem-&gt;values);  \

    #define __SA_MAXINDEX(array_buf)  \
        ((((IOReportElement*)(array_buf))-&gt;channel_type.nelements)  \
            * IOR_VALUES_PER_ELEMENT) - 1

<span class="enscript-comment">/*
 * Set a value at a specified index in a SimpleArrayReport.
 *
 *   void* array_bufbuf - ptr to memory initialized by SIMPLEARRAY_INIT()
 *        unsigned idx  - array index, out of bounds -&gt; no-op
 *    uint64_t newValue - new value to be stored at array[idx]
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_SETVALUE</span>(array_buf, idx, newValue) \
<span class="enscript-keyword">do</span> {  \
    __SA_FINDREP((array_buf), (idx)) \
        __rep-&gt;simple_values[__valueIdx] = (newValue);  \
    } \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/*
 * Increment an array value within a SimpleArrayReport.
 *
 *     void* array_buf - ptr to memory initialized by SIMPLEARRAY_INIT()
 *       unsigned idx  - array index to increment, out of bounds -&gt; no-op
 *      int64_t value  - amount by which to increment array[idx]
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_INCREMENTVALUE</span>(array_buf, idx, value)  \
<span class="enscript-keyword">do</span> {  \
    __SA_FINDREP((array_buf), (idx)) \
        __rep-&gt;simple_values[__valueIdx] += (value);  \
    } \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Prepare a SimpleArrayReport for
 * IOService::updateReport(kIOReportCopyChannelData...)
 *
 *      void* array_buf - ptr to memory initialized by SIMPLEARRAY_INIT()
 *        void* ptr2cpy - filled in with pointer to buffer to be copied out
 *      size_t size2cpy - filled in with the size of the buffer to copy out
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_UPDATEPREP</span>(array_buf, ptr2cpy, size2cpy) \
<span class="enscript-keyword">do</span> {  \
    IOReportElement     *__elem;  \
    __elem = &amp;(((IOReportElement *)(array_buf))[0]);  \
    (ptr2cpy) =  (<span class="enscript-type">void</span> *) (array_buf);  \
    (size2cpy) = __elem-&gt;channel_type.nelements * <span class="enscript-keyword">sizeof</span>(IOReportElement);  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Update the result field received as a parameter for kIOReportGetDimensions &amp;
 * kIOReportCopyChannelData actions.
 *
 *                void* array_buf - memory initialized by SIMPLEARRAY_INIT()
 * IOReportConfigureAction action - configure/updateReport() 'action'
 *                   void* result - configure/updateReport() 'result'
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_UPDATERES</span>(array_buf, action, result) \
<span class="enscript-keyword">do</span> {  \
    IOReportElement     *__elem;  \
    <span class="enscript-type">int</span> *__nElements = (<span class="enscript-type">int</span> *)(result);  \
    __elem = &amp;(((IOReportElement *)(array_buf))[0]);  \
    <span class="enscript-keyword">if</span> (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  \
        *__nElements += __elem-&gt;channel_type.nelements;  \
    }  \
} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * Get the 64-bit channel ID of a SimpleArrayReport.
 *
 * void* array_buf - ptr to memory initialized by SIMPLEARRAY_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_GETCHID</span>(array_buf)  \
    (((IOReportElement *)(array_buf))-&gt;channel_id)


<span class="enscript-comment">/*
 * Get the IOReportChannelType of a SimpleArrayReport.
 *
 * void* simp_buf - ptr to memory initialized by SIMPLEREPORT_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_GETCHTYPE</span>(array_buf)  \
    (*(uint64_t*)&amp;(((IOReportElement *)(array_buf))-&gt;channel_type))

<span class="enscript-comment">/*
 * Get a value from a SimpleArrayReport.
 *
 * void* array_buf - ptr to memory initialized by SIMPLEARRAY_INIT()
 *   unsigned idx  - index of the value, out of bounds -&gt; kIOReportInvalidValue
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SIMPLEARRAY_GETVALUE</span>(array_buf, idx)  \
    (((idx) &gt; __SA_MAXINDEX(array_buf) || (idx) &lt; 0) ? kIOReportInvalidIntValue :  \
    ((IOSimpleArrayReportValues*)&amp;(  \
        ((IOReportElement*)(array_buf))[(idx) / IOR_VALUES_PER_ELEMENT].values))  \
            -&gt;simple_values[(idx) % IOR_VALUES_PER_ELEMENT])


<span class="enscript-comment">/* ----- Histogram Reporting (HistogramReport) ----- */</span>

<span class="enscript-comment">// Internal struct for HistogramReport
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    <span class="enscript-type">int</span>             bucketWidth;
   IOReportElement elem[]; <span class="enscript-comment">// Array of elements
</span>} IOHistReportInfo;

<span class="enscript-comment">/*
 * Determine the size required for a HistogramReport buffer.
 *
 * int nbuckets - number of buckets in the histogram
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_BUFSIZE</span>(nbuckets)  \
    (<span class="enscript-keyword">sizeof</span>(IOHistReportInfo) + ((nbuckets) * <span class="enscript-keyword">sizeof</span>(IOReportElement)))

<span class="enscript-comment">/*
 * Initialize a HistogramReport buffer. Supports only linear scale histogram.
 *
 *                   int nbuckets - number of buckets data is combined into
 *           uint32_t bucketWidth - size of each bucket
 *                  void* buffer - ptr to HISTREPORT_BUFSIZE(nbuckets) bytes
 *                size_t bufSize - sanity check of buffer's size
 *           uint64_t providerID - registry Entry ID of the reporting service
 *            uint64_t channelID - ID of this channel, see IOREPORT_MAKEID()
 * IOReportCategories categories - categories of this channel
 *
 * If the buffer is not of sufficient size, the macro invokes IOREPORT_ABORT.
 * If that returns, the buffer is filled with 0xbadcafe.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_INIT</span>(nbuckets, bktSize, buf, bufSize, providerID, channelID, cats) \
<span class="enscript-keyword">do</span> {  \
    IOHistReportInfo   *__info = (IOHistReportInfo *)(buf);  \
    IOReportElement         *__elem;  \
    IOHistogramReportValues *__rep;  \
    <span class="enscript-keyword">if</span> ((bufSize) &gt;= HISTREPORT_BUFSIZE(nbuckets)) {  \
        __info-&gt;bucketWidth = (bktSize);  \
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> __no = 0; __no &lt; (nbuckets); __no++) {  \
            __elem =  &amp;(__info-&gt;elem[__no]);  \
            __rep = (IOHistogramReportValues *) &amp;(__elem-&gt;values);  \
            __elem-&gt;channel_id = (channelID);  \
            __elem-&gt;provider_id = (providerID);  \
            __elem-&gt;channel_type.report_format = kIOReportFormatHistogram;  \
            __elem-&gt;channel_type.reserved = 0;  \
            __elem-&gt;channel_type.categories = (cats);  \
            __elem-&gt;channel_type.nelements = (nbuckets);  \
            __elem-&gt;channel_type.element_idx = __no;  \
            __elem-&gt;timestamp = 0;  \
            bzero(__rep, <span class="enscript-keyword">sizeof</span>(IOHistogramReportValues)); \
        }  \
    }  \
    <span class="enscript-keyword">else</span> {  \
        IOREPORT_ABORT(<span class="enscript-string">&quot;bufSize is smaller than the required size\n&quot;</span>);  \
        __POLLUTE_BUF((buf), (bufSize));  \
    }  \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Update histogram with a new value.
 *
 *
 *      void* hist_buf - pointer to memory initialized by HISTREPORT_INIT()
 *        int64_t value - new value to add to the histogram
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_TALLYVALUE</span>(hist_buf, value) \
<span class="enscript-keyword">do</span> {  \
    IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);  \
    IOReportElement         *__elem;  \
    IOHistogramReportValues *__rep;  \
    <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> __no = 0; __no &lt; __info-&gt;elem[0].channel_type.nelements; __no++) {  \
        <span class="enscript-keyword">if</span> ((value) &lt;= __info-&gt;bucketWidth * (__no+1)) {  \
            __elem =  &amp;(__info-&gt;elem[__no]);  \
            __rep = (IOHistogramReportValues *) &amp;(__elem-&gt;values);  \
            <span class="enscript-keyword">if</span> (__rep-&gt;bucket_hits == 0) {  \
                __rep-&gt;bucket_min = __rep-&gt;bucket_max = (value);  \
            }  \
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((value) &lt; __rep-&gt;bucket_min) {  \
                __rep-&gt;bucket_min = (value);  \
            }  \
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((value) &gt; __rep-&gt;bucket_max) {  \
                __rep-&gt;bucket_max = (value);  \
            }  \
            __rep-&gt;bucket_sum += (value);  \
            __rep-&gt;bucket_hits++;  \
            <span class="enscript-keyword">break</span>;  \
        }  \
    }  \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Prepare a HistogramReport for
 * IOService::updateReport(kIOReportCopyChannelData...)
 *
 *      void* array_buf - ptr to memory initialized by HISTREPORT_INIT()
 *        void* ptr2cpy - filled in with pointer to buffer to be copied out
 *      size_t size2cpy - filled in with the size of the buffer to copy out
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_UPDATEPREP</span>(hist_buf, ptr2cpy, size2cpy) \
<span class="enscript-keyword">do</span> {  \
    IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);  \
    (size2cpy) = __info-&gt;elem[0].channel_type.nelements * <span class="enscript-keyword">sizeof</span>(IOReportElement);  \
    (ptr2cpy) =  (<span class="enscript-type">void</span> *) &amp;__info-&gt;elem[0];  \
} <span class="enscript-keyword">while</span>(0)


<span class="enscript-comment">/*
 * Update the result field received as a parameter for kIOReportGetDimensions &amp;
 * kIOReportCopyChannelData actions.
 *
 *                void* array_buf - memory initialized by HISTREPORT_INIT()
 * IOReportConfigureAction action - configure/updateReport() 'action'
 *                   void* result - configure/updateReport() 'result'
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_UPDATERES</span>(hist_buf, action, result) \
<span class="enscript-keyword">do</span> {  \
    IOHistReportInfo   *__info = (IOHistReportInfo *)(hist_buf);  \
    <span class="enscript-type">int</span> *__nElements = (<span class="enscript-type">int</span> *)(result);  \
    <span class="enscript-keyword">if</span> (((action) == kIOReportGetDimensions) || ((action) == kIOReportCopyChannelData)) {  \
        *__nElements += __info-&gt;elem[0].channel_type.nelements;  \
    }  \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Get the 64-bit channel ID of a HistogramReport.
 *
 * void* hist_buf - ptr to memory initialized by HISTREPORT_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_GETCHID</span>(hist_buf)  \
    (((IOHistReportInfo *)(hist_buf))-&gt;elem[0].channel_id)

<span class="enscript-comment">/*
 * Get the IOReportChannelType of a HistogramReport.
 *
 * void* hist_buf - ptr to memory initialized by HISTREPORT_INIT()
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HISTREPORT_GETCHTYPE</span>(hist_buf)  \
    (*(uint64_t*)&amp;(((IOHistReportInfo *)(hist_buf))-&gt;elem[0].channel_type))



<span class="enscript-comment">/* generic utilities */</span>

    #define __POLLUTE_BUF(buf, bufSize)  \
    <span class="enscript-keyword">do</span> {  \
        <span class="enscript-type">int</span> __cnt = (bufSize)/<span class="enscript-keyword">sizeof</span>(uint32_t);  \
        <span class="enscript-keyword">while</span> (--__cnt &gt;= 0)  \
            ((uint32_t*)(buf))[__cnt] = 0xbadcafe;  \
    } <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">_IOREPORT_MACROS_H_</span>


</pre>
<hr />
</body></html>