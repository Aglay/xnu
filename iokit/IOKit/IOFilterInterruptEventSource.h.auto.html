<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOFilterInterruptEventSource.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOFilterInterruptEventSource.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
Copyright (c) 1999 Apple Computer, Inc.	 All rights reserved.

HISTORY
    1999-4-15	Godfrey van der Linden(gvdl)
	Created.
*/</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOKIT_IOFILTERINTERRUPTEVENTSOURCE_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOKIT_IOFILTERINTERRUPTEVENTSOURCE_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterruptEventSource.h&gt;</span>

class IOService;

<span class="enscript-comment">/*! @class IOFilterInterruptEventSource : public IOInterruptEventSource
    @abstract Filtering varient of the $link IOInterruptEventSource.
    @discussion An interrupt event source that calls the client to determine if a interrupt event needs to be scheduled on the work loop.  A filter interrupt event source call's the client in the primary interrupt context, the client can then interrogate its hardware and determine if the interrupt needs to be processed yet.
&lt;br&gt;&lt;br&gt;
    As the routine is called in the primary interrupt context great care must be taken in the writing of this routine.  In general none of the generic IOKit environment is safe to call in this context.  We intend this routine to be used by hardware that can interrogate its registers without destroying state.  Primarily this variant of event sources will be used by drivers that share interrupts.  The filter routine will determine if the interrupt is a real interrupt or a ghost and thus optimise the work thread context switch away.
&lt;br&gt;&lt;br&gt;
If you are implementing 'SoftDMA' (or pseudo-DMA), you may not want the I/O Kit to automatically start your interrupt handler routine on your work loop when your filter routine returns true.  In this case, you may choose to have your filter routine schedule the work on the work loop itself and then return false.  If you do this, the interrupt will not be disabled in hardware and you could receive additional primary interrupts before your work loopâ€“level service routine completes.  Because this scheme has implications for synchronization between your filter routine and your interrupt service routine, you should avoid doing this unless your driver requires SoftDMA.
&lt;br&gt;&lt;br&gt;
CAUTION:  Called in primary interrupt context, if you need to disable interrupt to guard you registers against an unexpected call then it is better to use a straight IOInterruptEventSource and its secondary interrupt delivery mechanism.
*/</span>
class IOFilterInterruptEventSource : public IOInterruptEventSource
{
    OSDeclareDefaultStructors(IOFilterInterruptEventSource)

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*!
    @typedef Filter
    @discussion C Function pointer to a routine to call when an interrupt occurs.
    @param owner Pointer to the owning/client instance.
    @param sender Where is the interrupt comming from.
    @result false if this interrupt can be ignored. */</span>
    <span class="enscript-type">typedef</span> bool (*Filter)(OSObject *, IOFilterInterruptEventSource *);

<span class="enscript-comment">/*! @defined IOFilterInterruptAction
    @discussion Backward compatibilty define for the old non-class scoped type definition.  See $link IOFilterInterruptSource::Filter */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOFilterInterruptAction</span> IOFilterInterruptEventSource::Filter

<span class="enscript-reference">private</span>:
    <span class="enscript-comment">// Hide the superclass initializers
</span>    virtual bool init(OSObject *inOwner,
		      <span class="enscript-reference">IOInterruptEventSource</span>::Action inAction = 0,
		      IOService *inProvider = 0,
		      <span class="enscript-type">int</span> inIntIndex = 0) APPLE_KEXT_OVERRIDE;

    <span class="enscript-type">static</span> IOInterruptEventSource *
	interruptEventSource(OSObject *inOwner,
			     <span class="enscript-reference">IOInterruptEventSource</span>::Action inAction = 0,
			     IOService *inProvider = 0,
			     <span class="enscript-type">int</span> inIntIndex = 0);

<span class="enscript-reference">protected</span>:
<span class="enscript-comment">/*! @var filterAction Filter callout */</span>
    Filter filterAction;

<span class="enscript-comment">/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the IOWorkLoop in the future.
    */</span>    
    <span class="enscript-type">struct</span> ExpansionData { };

<span class="enscript-comment">/*! @var reserved
    Reserved for future use.  (Internal use only)  */</span>
    ExpansionData *reserved;

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @function filterInterruptEventSource
    @abstract Factor method to create and initialise an IOFilterInterruptEventSource.  See $link init.
    @param owner Owner/client of this event source.
    @param action 'C' Function to call when something happens.
    @param filter 'C' Function to call when interrupt occurs.
    @param provider Service that provides interrupts.
    @param intIndex Defaults to 0.
    @result a new event source if succesful, 0 otherwise.  */</span>
    <span class="enscript-type">static</span> IOFilterInterruptEventSource *
	filterInterruptEventSource(OSObject *owner,
				   <span class="enscript-reference">IOInterruptEventSource</span>::Action action,
				   Filter filter,
				   IOService *provider,
				   <span class="enscript-type">int</span> intIndex = 0);

<span class="enscript-comment">/*! @function init
    @abstract Primary initialiser for the IOFilterInterruptEventSource class.
    @param owner Owner/client of this event source.
    @param action 'C' Function to call when something happens.
    @param filter 'C' Function to call in primary interrupt context.
    @param provider Service that provides interrupts.
    @param intIndex Interrupt source within provider.  Defaults to 0.
    @result true if the inherited classes and this instance initialise
successfully.  */</span>
    virtual bool init(OSObject *owner,
		      <span class="enscript-reference">IOInterruptEventSource</span>::Action action,
		      Filter filter,
		      IOService *provider,
		      <span class="enscript-type">int</span> intIndex = 0);


<span class="enscript-comment">/*! @function signalInterrupt
    @abstract Cause the work loop to schedule the action.
    @discussion Cause the work loop to schedule the interrupt action even if the filter routine returns 'false'. Note well the interrupting condition MUST be cleared from the hardware otherwise an infinite process interrupt loop will occur.  Use this function when SoftDMA is desired.  See $link IOFilterInterruptSource::Filter */</span>
    virtual <span class="enscript-type">void</span> signalInterrupt();

<span class="enscript-comment">/*! @function getFilterAction
    @abstract Get'ter for filterAction variable.
    @result value of filterAction. */</span>
    virtual Filter getFilterAction() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function normalInterruptOccurred
    @abstract Override $link IOInterruptEventSource::normalInterruptOccured to make a filter callout. */</span>
    virtual <span class="enscript-type">void</span> normalInterruptOccurred(<span class="enscript-type">void</span> *self, IOService *prov, <span class="enscript-type">int</span> ind) APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function disableInterruptOccurred
    @abstract Override $link IOInterruptEventSource::disableInterruptOccurred to make a filter callout. */</span>
    virtual <span class="enscript-type">void</span> disableInterruptOccurred(<span class="enscript-type">void</span> *self, IOService *prov, <span class="enscript-type">int</span> ind) APPLE_KEXT_OVERRIDE;

<span class="enscript-reference">private</span>:
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 0);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 1);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 2);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 3);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 4);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 5);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 6);
    OSMetaClassDeclareReservedUnused(IOFilterInterruptEventSource, 7);
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IOKIT_IOFILTERINTERRUPTEVENTSOURCE_H */</span>
</pre>
<hr />
</body></html>