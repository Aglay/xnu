<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOBufferMemoryDescriptor.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOBufferMemoryDescriptor.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOBUFFERMEMORYDESCRIPTOR_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOBUFFERMEMORYDESCRIPTOR_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>

<span class="enscript-type">enum</span> {
    kIOMemoryPhysicallyContiguous	= 0x00000010,
    kIOMemoryPageable	      		= 0x00000020,
    kIOMemoryPurgeable	      		= 0x00000040,
    kIOMemoryHostPhysicallyContiguous  	= 0x00000080,
    kIOMemorySharingTypeMask		= 0x000f0000,
    kIOMemoryUnshared			= 0x00000000,
    kIOMemoryKernelUserShared		= 0x00010000,
    <span class="enscript-comment">// shared IOMemoryDescriptor options for IOBufferMemoryDescriptor:
</span>    kIOBufferDescriptorMemoryFlags	= kIOMemoryDirectionMask 
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
					| kIOMemoryAutoPrepare
#<span class="enscript-reference">endif</span>
					| kIOMemoryThreadSafe
					| kIOMemoryClearEncrypt
					| kIOMemoryMapperNone
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOBUFFERMEMORYDESCRIPTOR_INTASKWITHOPTIONS_</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOBUFFERMEMORYDESCRIPTOR_HOSTPHYSICALLYCONTIGUOUS_</span>	1
<span class="enscript-comment">/*!
    @class IOBufferMemoryDescriptor
    @abstract Provides a simple memory descriptor that allocates its own buffer memory.
*/</span>

class IOBufferMemoryDescriptor : public IOGeneralMemoryDescriptor
{
    OSDeclareDefaultStructors(IOBufferMemoryDescriptor);

<span class="enscript-reference">private</span>:
<span class="enscript-comment">/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of this class in the future.
    */</span>    
    <span class="enscript-type">struct</span> ExpansionData {
	IOMemoryMap *   map;
    };

<span class="enscript-comment">/*! @var reserved
    Reserved for future use.  (Internal use only)  */</span>
    ExpansionData * reserved;

<span class="enscript-reference">protected</span>:
    <span class="enscript-type">void</span> *               _buffer;
    vm_size_t            _capacity;
    vm_offset_t		 _alignment;
    IOOptionBits	 _options;
<span class="enscript-reference">private</span>:
    uintptr_t		 _internalReserved;
    <span class="enscript-type">unsigned</span>             _internalFlags;

<span class="enscript-reference">private</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual bool initWithOptions(
                               IOOptionBits options,
                               vm_size_t    capacity,
                               vm_offset_t  alignment,
			       task_t	    inTask) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withOptions() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-reference">public</span>:
    virtual bool initWithPhysicalMask(
				task_t		  inTask,
				IOOptionBits      options,
				mach_vm_size_t    capacity,
				mach_vm_address_t alignment,
				mach_vm_address_t physicalMask);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 0);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 1);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    OSMetaClassDeclareReservedUsed(IOBufferMemoryDescriptor, 0);
    OSMetaClassDeclareReservedUsed(IOBufferMemoryDescriptor, 1);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 2);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 3);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 4);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 5);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 6);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 7);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 8);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 9);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 10);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 11);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 12);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 13);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 14);
    OSMetaClassDeclareReservedUnused(IOBufferMemoryDescriptor, 15);

<span class="enscript-reference">protected</span>:
    virtual <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

<span class="enscript-reference">public</span>:

    <span class="enscript-comment">/*
     * withOptions:
     *
     * Returns a new IOBufferMemoryDescriptor with a buffer large enough to
     * hold capacity bytes.  The descriptor's length is initially set to the
     * capacity.
     */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual bool initWithOptions(   IOOptionBits options,
                                    vm_size_t    capacity,
                                    vm_offset_t  alignment) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withOptions() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-type">static</span> IOBufferMemoryDescriptor * withOptions(  IOOptionBits options,
                                                    vm_size_t    capacity,
                                                    vm_offset_t  alignment = 1);

<span class="enscript-comment">/*! @function inTaskWithOptions
    @abstract Creates a memory buffer with memory descriptor for that buffer. 
    @discussion Added in Mac OS X 10.2, this method allocates a memory buffer with a given size and alignment in the task's address space specified, and returns a memory descriptor instance representing the memory. It is recommended that memory allocated for I/O or sharing via mapping be created via IOBufferMemoryDescriptor. Options passed with the request specify the kind of memory to be allocated - pageablity and sharing are specified with option bits. This function may block and so should not be called from interrupt level or while a simple lock is held.
    @param inTask The task the buffer will be allocated in.
    @param options Options for the allocation:&lt;br&gt;
    kIODirectionOut, kIODirectionIn - set the direction of the I/O transfer.&lt;br&gt;
    kIOMemoryPhysicallyContiguous - pass to request memory be physically contiguous. This option is heavily discouraged. The request may fail if memory is fragmented, may cause large amounts of paging activity, and may take a very long time to execute.&lt;br&gt;
    kIOMemoryPageable - pass to request memory be non-wired - the default for kernel allocated memory is wired.&lt;br&gt;
    kIOMemoryPurgeable - pass to request memory that may later have its purgeable state set with IOMemoryDescriptor::setPurgeable. Only supported for kIOMemoryPageable allocations.&lt;br&gt;
    kIOMemoryKernelUserShared - pass to request memory that will be mapped into both the kernel and client applications.&lt;br&gt;
    kIOMapInhibitCache - allocate memory with inhibited cache setting. &lt;br&gt;		
    kIOMapWriteThruCache - allocate memory with writethru cache setting. &lt;br&gt;		
    kIOMapCopybackCache - allocate memory with copyback cache setting. &lt;br&gt;		
    kIOMapWriteCombineCache - allocate memory with writecombined cache setting.
    @param capacity The number of bytes to allocate.
    @param alignment The minimum required alignment of the buffer in bytes - 1 is the default for no required alignment. For example, pass 256 to get memory allocated at an address with bits 0-7 zero.
    @result Returns an instance of class IOBufferMemoryDescriptor to be released by the caller, which will free the memory desriptor and associated buffer. */</span>

    <span class="enscript-type">static</span> IOBufferMemoryDescriptor * inTaskWithOptions(
					    task_t       inTask,
                                            IOOptionBits options,
                                            vm_size_t    capacity,
                                            vm_offset_t  alignment = 1);

<span class="enscript-comment">/*! @function inTaskWithPhysicalMask
    @abstract Creates a memory buffer with memory descriptor for that buffer. 
    @discussion Added in Mac OS X 10.5, this method allocates a memory buffer with a given size and alignment in the task's address space specified, and returns a memory descriptor instance representing the memory. It is recommended that memory allocated for I/O or sharing via mapping be created via IOBufferMemoryDescriptor. Options passed with the request specify the kind of memory to be allocated - pageablity and sharing are specified with option bits. This function may block and so should not be called from interrupt level or while a simple lock is held.
    @param inTask The task the buffer will be mapped in. Pass NULL to create memory unmapped in any task (eg. for use as a DMA buffer).
    @param options Options for the allocation:&lt;br&gt;
    kIODirectionOut, kIODirectionIn - set the direction of the I/O transfer.&lt;br&gt;
    kIOMemoryPhysicallyContiguous - pass to request memory be physically contiguous. This option is heavily discouraged. The request may fail if memory is fragmented, may cause large amounts of paging activity, and may take a very long time to execute.&lt;br&gt;
    kIOMemoryKernelUserShared - pass to request memory that will be mapped into both the kernel and client applications.&lt;br&gt;
    kIOMapInhibitCache - allocate memory with inhibited cache setting. &lt;br&gt;		
    kIOMapWriteThruCache - allocate memory with writethru cache setting. &lt;br&gt;		
    kIOMapCopybackCache - allocate memory with copyback cache setting. &lt;br&gt;		
    kIOMapWriteCombineCache - allocate memory with writecombined cache setting.
    @param capacity The number of bytes to allocate.
    @param mask The buffer will be allocated with pages such that physical addresses will only have bits set present in physicalMask. For example, pass 0x00000000FFFFFFFFULL for a buffer to be accessed by hardware that has 32 address bits.
    @result Returns an instance of class IOBufferMemoryDescriptor to be released by the caller, which will free the memory desriptor and associated buffer. */</span>

    <span class="enscript-type">static</span> IOBufferMemoryDescriptor * inTaskWithPhysicalMask(
					    task_t	      inTask,
                                            IOOptionBits      options,
                                            mach_vm_size_t    capacity,
                                            mach_vm_address_t physicalMask);

    <span class="enscript-comment">/*
     * withCapacity:
     *
     * Returns a new IOBufferMemoryDescriptor with a buffer large enough to
     * hold capacity bytes.  The descriptor's length is initially set to the
     * capacity.
     */</span>
    <span class="enscript-type">static</span> IOBufferMemoryDescriptor * withCapacity(
                                     vm_size_t    capacity,
                                     IODirection  withDirection,
                                     bool         withContiguousMemory = false);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual bool initWithBytes(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * bytes,
                               vm_size_t    withLength,
                               IODirection  withDirection,
                               bool         withContiguousMemory = false) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withBytes() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-comment">/*
     * withBytes:
     *
     * Returns a new IOBufferMemoryDescriptor preloaded with bytes (copied).
     * The descriptor's length and capacity are set to the input buffer's size.
     */</span>
    <span class="enscript-type">static</span> IOBufferMemoryDescriptor * withBytes(
                                     <span class="enscript-type">const</span> <span class="enscript-type">void</span> * bytes,
                                     vm_size_t    withLength,
                                     IODirection  withDirection,
                                     bool         withContiguousMemory = false);

    <span class="enscript-comment">/*
     * setLength:
     *
     * Change the buffer length of the memory descriptor.  When a new buffer
     * is created, the initial length of the buffer is set to be the same as
     * the capacity.  The length can be adjusted via setLength for a shorter
     * transfer (there is no need to create more buffer descriptors when you
     * can reuse an existing one, even for different transfer sizes).   Note
     * that the specified length must not exceed the capacity of the buffer.
     */</span>
    virtual <span class="enscript-type">void</span> setLength(vm_size_t length);

    <span class="enscript-comment">/*
     * setDirection:
     *
     * Change the direction of the transfer.  This method allows one to redirect
     * the descriptor's transfer direction.  This eliminates the need to destroy
     * and create new buffers when different transfer directions are needed.
     */</span>
    virtual <span class="enscript-type">void</span> setDirection(IODirection direction);

    <span class="enscript-comment">/*
     * getCapacity:
     *
     * Get the buffer capacity
     */</span>
    virtual vm_size_t getCapacity() <span class="enscript-type">const</span>;

    <span class="enscript-comment">/*
     * getBytesNoCopy:
     *
     * Return the virtual address of the beginning of the buffer
     */</span>
    virtual <span class="enscript-type">void</span> *getBytesNoCopy();

    <span class="enscript-comment">/*
     * getBytesNoCopy:
     *
     * Return the virtual address of an offset from the beginning of the buffer
     */</span>
    virtual <span class="enscript-type">void</span> *getBytesNoCopy(vm_size_t start, vm_size_t withLength);

    <span class="enscript-comment">/*
     * appendBytes:
     *
     * Add some data to the end of the buffer.  This method automatically
     * maintains the memory descriptor buffer length.  Note that appendBytes
     * will not copy past the end of the memory descriptor's current capacity.
     */</span>
    virtual bool appendBytes(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *bytes, vm_size_t withLength);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual <span class="enscript-type">void</span> * getVirtualSegment(IOByteCount offset,
					IOByteCount * length) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use getBytesNoCopy() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IOBUFFERMEMORYDESCRIPTOR_H */</span>
</pre>
<hr />
</body></html>