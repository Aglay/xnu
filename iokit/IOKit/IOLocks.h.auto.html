<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOLocks.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOLocks.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 *
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__IOKIT_IOLOCKS_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__IOKIT_IOLOCKS_H</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">IOLocks</span>.<span class="enscript-variable-name">h</span> <span class="enscript-variable-name">is</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">kernel</span> <span class="enscript-variable-name">use</span> <span class="enscript-variable-name">only</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReturn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTypes.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

<span class="enscript-comment">/*! @var IOLockGroup
    Global lock group used by all IOKit locks.  To simplify kext debugging and lock-heat analysis, consider using lck_* locks with a per-driver lock group, as defined in kern/locks.h.
*/</span>
<span class="enscript-type">extern</span> lck_grp_t	*IOLockGroup;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOLOCKS_INLINE</span>	1
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Mutex lock operations
 */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
<span class="enscript-type">typedef</span> lck_mtx_t	IOLock;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _IOLock	IOLock;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IOLOCKS_INLINE */</span>


<span class="enscript-comment">/*! @function IOLockAlloc
    @abstract Allocates and initializes a mutex.
    @discussion Allocates a mutex in general purpose memory, and initializes it. Mutexes are general purpose blocking mutual exclusion locks, supplied by libkern/locks.h. This function may block and so should not be called from interrupt level or while a spin lock is held.  IOLocks use the global IOKit lock group, IOLockGroup.  To simplify kext debugging and lock-heat analysis, consider using lck_* locks with a per-driver lock group, as defined in kern/locks.h.
    @result Pointer to the allocated lock, or zero on failure. */</span>

IOLock * <span class="enscript-function-name">IOLockAlloc</span>( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function IOLockFree
    @abstract Frees a mutex.
    @discussion Frees a lock allocated with IOLockAlloc. Mutex should be unlocked with no waiters.
    @param lock Pointer to the allocated lock. */</span>

<span class="enscript-type">void</span>	IOLockFree( IOLock * lock);

<span class="enscript-comment">/*! @function IOLockGetMachLock
    @abstract Accessor to a Mach mutex.
    @discussion Accessor to the Mach mutex.
    @param lock Pointer to the allocated lock. */</span>

lck_mtx_t * <span class="enscript-function-name">IOLockGetMachLock</span>( IOLock * lock);

<span class="enscript-comment">/*! @function IOLockLock
    @abstract Lock a mutex.
    @discussion Lock the mutex. If the lock is held by any thread, block waiting for its unlock. This function may block and so should not be called from interrupt level or while a spin lock is held. Locking the mutex recursively from one thread will result in deadlock. 
    @param lock Pointer to the allocated lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOLockLock</span>(l)	lck_mtx_lock(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>	IOLockLock( IOLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IOLockTryLock
    @abstract Attempt to lock a mutex.
    @discussion Lock the mutex if it is currently unlocked, and return true. If the lock is held by any thread, return false.
    @param lock Pointer to the allocated lock.
    @result True if the mutex was unlocked and is now locked by the caller, otherwise false. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOLockTryLock</span>(l)	lck_mtx_try_lock(l)
#<span class="enscript-reference">else</span>
boolean_t <span class="enscript-function-name">IOLockTryLock</span>( IOLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IOLockUnlock
    @abstract Unlock a mutex.
@discussion Unlock the mutex and wake any blocked waiters. Results are undefined if the caller has not locked the mutex. This function may block and so should not be called from interrupt level or while a spin lock is held. 
    @param lock Pointer to the allocated lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOLockUnlock</span>(l)	lck_mtx_unlock(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>	IOLockUnlock( IOLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IOLockSleep
    @abstract Sleep with mutex unlock and relock
@discussion Prepare to sleep,unlock the mutex, and re-acquire it on wakeup. Results are undefined if the caller has not locked the mutex. This function may block and so should not be called from interrupt level or while a spin lock is held. 
    @param lock Pointer to the locked lock. 
    @param event The event to sleep on. Must be non-NULL.
    @param interType How can the sleep be interrupted.
	@result The wait-result value indicating how the thread was awakened.*/</span>
<span class="enscript-type">int</span>	IOLockSleep( IOLock * lock, <span class="enscript-type">void</span> *event, UInt32 interType) __DARWIN14_ALIAS(IOLockSleep);

<span class="enscript-type">int</span>	IOLockSleepDeadline( IOLock * lock, <span class="enscript-type">void</span> *event,
						 AbsoluteTime deadline, UInt32 interType) __DARWIN14_ALIAS(IOLockSleepDeadline);

<span class="enscript-type">void</span>	IOLockWakeup(IOLock * lock, <span class="enscript-type">void</span> *event, bool oneThread) __DARWIN14_ALIAS(IOLockWakeup);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_OBSOLETE</span>

<span class="enscript-comment">/* The following API is deprecated */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    kIOLockStateUnlocked	= 0,
    kIOLockStateLocked		= 1
} IOLockState;

<span class="enscript-type">void</span>	IOLockInitWithState( IOLock * lock, IOLockState state);
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IOLockInit</span>( l )	IOLockInitWithState( l, kIOLockStateUnlocked);

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">IOTakeLock</span>( IOLock * lock) { IOLockLock(lock); 	     }
<span class="enscript-type">static</span> __inline__ boolean_t <span class="enscript-function-name">IOTryLock</span>(  IOLock * lock) { <span class="enscript-keyword">return</span>(IOLockTryLock(lock)); }
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">IOUnlock</span>(   IOLock * lock) { IOLockUnlock(lock);	     }

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_OBSOLETE */</span>

<span class="enscript-comment">/*
 * Recursive lock operations
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _IORecursiveLock IORecursiveLock;

<span class="enscript-comment">/*! @function IORecursiveLockAlloc
    @abstract Allocates and initializes an recursive lock.
    @discussion Allocates a recursive lock in general purpose memory, and initializes it. Recursive locks function identically to mutexes but allow one thread to lock more than once, with balanced unlocks.  IORecursiveLocks use the global IOKit lock group, IOLockGroup.  To simplify kext debugging and lock-heat analysis, consider using lck_* locks with a per-driver lock group, as defined in kern/locks.h.
    @result Pointer to the allocated lock, or zero on failure. */</span>

IORecursiveLock * <span class="enscript-function-name">IORecursiveLockAlloc</span>( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function IORecursiveLockFree
    @abstract Frees a recursive lock.
    @discussion Frees a lock allocated with IORecursiveLockAlloc. Lock should be unlocked with no waiters. 
    @param lock Pointer to the allocated lock. */</span>

<span class="enscript-type">void</span>		IORecursiveLockFree( IORecursiveLock * lock);

<span class="enscript-comment">/*! @function IORecursiveLockGetMachLock
    @abstract Accessor to a Mach mutex.
    @discussion Accessor to the Mach mutex.
    @param lock Pointer to the allocated lock. */</span>

lck_mtx_t * <span class="enscript-function-name">IORecursiveLockGetMachLock</span>( IORecursiveLock * lock);

<span class="enscript-comment">/*! @function IORecursiveLockLock
    @abstract Lock a recursive lock.
    @discussion Lock the recursive lock. If the lock is held by another thread, block waiting for its unlock. This function may block and so should not be called from interrupt level or while a spin lock is held. The lock may be taken recursively by the same thread, with a balanced number of calls to IORecursiveLockUnlock.
    @param lock Pointer to the allocated lock. */</span>

<span class="enscript-type">void</span>		IORecursiveLockLock( IORecursiveLock * lock);

<span class="enscript-comment">/*! @function IORecursiveLockTryLock
    @abstract Attempt to lock a recursive lock.
    @discussion Lock the lock if it is currently unlocked, or held by the calling thread, and return true. If the lock is held by another thread, return false. Successful calls to IORecursiveLockTryLock should be balanced with calls to IORecursiveLockUnlock.
    @param lock Pointer to the allocated lock.
    @result True if the lock is now locked by the caller, otherwise false. */</span>

boolean_t	IORecursiveLockTryLock( IORecursiveLock * lock);

<span class="enscript-comment">/*! @function IORecursiveLockUnlock
    @abstract Unlock a recursive lock.
@discussion Undo one call to IORecursiveLockLock, if the lock is now unlocked wake any blocked waiters. Results are undefined if the caller does not balance calls to IORecursiveLockLock with IORecursiveLockUnlock. This function may block and so should not be called from interrupt level or while a spin lock is held.
    @param lock Pointer to the allocated lock. */</span>

<span class="enscript-type">void</span>		IORecursiveLockUnlock( IORecursiveLock * lock);

<span class="enscript-comment">/*! @function IORecursiveLockHaveLock
    @abstract Check if a recursive lock is held by the calling thread.
    @discussion If the lock is held by the calling thread, return true, otherwise the lock is unlocked, or held by another thread and false is returned.
    @param lock Pointer to the allocated lock.
    @result True if the calling thread holds the lock otherwise false. */</span>

boolean_t	IORecursiveLockHaveLock( <span class="enscript-type">const</span> IORecursiveLock * lock);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	IORecursiveLockSleep( IORecursiveLock *_lock,
                                      <span class="enscript-type">void</span> *event, UInt32 interType);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	IORecursiveLockSleepDeadline( IORecursiveLock * _lock, <span class="enscript-type">void</span> *event,
											AbsoluteTime deadline, UInt32 interType);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>	IORecursiveLockWakeup( IORecursiveLock *_lock,
                                       <span class="enscript-type">void</span> *event, bool oneThread);

<span class="enscript-comment">/*
 * Complex (read/write) lock operations
 */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
<span class="enscript-type">typedef</span> lck_rw_t		IORWLock;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _IORWLock	IORWLock;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IORWLockAlloc
    @abstract Allocates and initializes a read/write lock.
    @discussion Allocates and initializes a read/write lock in general purpose memory. Read/write locks provide for multiple readers, one exclusive writer, and are supplied by libkern/locks.h. This function may block and so should not be called from interrupt level or while a spin lock is held.  IORWLocks use the global IOKit lock group, IOLockGroup.  To simplify kext debugging and lock-heat analysis, consider using lck_* locks with a per-driver lock group, as defined in kern/locks.h.
    @result Pointer to the allocated lock, or zero on failure. */</span>

IORWLock * <span class="enscript-function-name">IORWLockAlloc</span>( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function IORWLockFree
   @abstract Frees a read/write lock.
   @discussion Frees a lock allocated with IORWLockAlloc. Lock should be unlocked with no waiters.
    @param lock Pointer to the allocated lock. */</span>

<span class="enscript-type">void</span>	IORWLockFree( IORWLock * lock);

<span class="enscript-comment">/*! @function IORWLockGetMachLock
    @abstract Accessor to a Mach read/write lock.
    @discussion Accessor to the Mach read/write lock.
    @param lock Pointer to the allocated lock. */</span>

lck_rw_t * <span class="enscript-function-name">IORWLockGetMachLock</span>( IORWLock * lock);

<span class="enscript-comment">/*! @function IORWLockRead
    @abstract Lock a read/write lock for read.
@discussion Lock the lock for read, allowing multiple readers when there are no writers. If the lock is held for write, block waiting for its unlock. This function may block and so should not be called from interrupt level or while a spin lock is held. Locking the lock recursively from one thread, for read or write, can result in deadlock.
    @param lock Pointer to the allocated lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IORWLockRead</span>(l)	lck_rw_lock_shared(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>	IORWLockRead(IORWLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IORWLockWrite
    @abstract Lock a read/write lock for write.
    @discussion Lock the lock for write, allowing one writer exlusive access. If the lock is held for read or write, block waiting for its unlock. This function may block and so should not be called from interrupt level or while a spin lock is held. Locking the lock recursively from one thread, for read or write, can result in deadlock.
    @param lock Pointer to the allocated lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IORWLockWrite</span>(l)	lck_rw_lock_exclusive(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>	IORWLockWrite( IORWLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IORWLockUnlock
    @abstract Unlock a read/write lock.
    @discussion Undo one call to IORWLockRead or IORWLockWrite. Results are undefined if the caller has not locked the lock. This function may block and so should not be called from interrupt level or while a spin lock is held.
    @param lock Pointer to the allocated lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IORWLockUnlock</span>(l)	lck_rw_done(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>	IORWLockUnlock( IORWLock * lock);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_OBSOLETE</span>

<span class="enscript-comment">/* The following API is deprecated */</span>

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">IOReadLock</span>( IORWLock * lock)   { IORWLockRead(lock);   }
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">IOWriteLock</span>(  IORWLock * lock) { IORWLockWrite(lock);  }
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">void</span> <span class="enscript-function-name">IORWUnlock</span>(   IORWLock * lock) { IORWLockUnlock(lock); }

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_OBSOLETE */</span>


<span class="enscript-comment">/*
 * Simple locks. Cannot block while holding a simple lock.
 */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
<span class="enscript-type">typedef</span> lck_spin_t		IOSimpleLock;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _IOSimpleLock	IOSimpleLock;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IOSimpleLockAlloc
    @abstract Allocates and initializes a spin lock.
    @discussion Allocates and initializes a spin lock in general purpose memory. Spin locks provide non-blocking mutual exclusion for synchronization between thread context and interrupt context, or for multiprocessor synchronization, and are supplied by libkern/locks.h. This function may block and so should not be called from interrupt level or while a spin lock is held.  IOSimpleLocks use the global IOKit lock group, IOLockGroup.  To simplify kext debugging and lock-heat analysis, consider using lck_* locks with a per-driver lock group, as defined in kern/locks.h.
    @result Pointer to the allocated lock, or zero on failure. */</span>

IOSimpleLock * <span class="enscript-function-name">IOSimpleLockAlloc</span>( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function IOSimpleLockFree
    @abstract Frees a spin lock.
    @discussion Frees a lock allocated with IOSimpleLockAlloc.
    @param lock Pointer to the lock. */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOSimpleLockFree</span>( IOSimpleLock * lock );

<span class="enscript-comment">/*! @function IOSimpleLockGetMachLock
    @abstract Accessor to a Mach spin lock.
    @discussion Accessor to the Mach spin lock.
    @param lock Pointer to the allocated lock. */</span>

lck_spin_t * <span class="enscript-function-name">IOSimpleLockGetMachLock</span>( IOSimpleLock * lock);

<span class="enscript-comment">/*! @function IOSimpleLockInit
    @abstract Initialize a spin lock.
    @discussion Initialize an embedded spin lock, to the unlocked state.
    @param lock Pointer to the lock. */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOSimpleLockInit</span>( IOSimpleLock * lock );

<span class="enscript-comment">/*! @function IOSimpleLockLock
    @abstract Lock a spin lock.
@discussion Lock the spin lock. If the lock is held, spin waiting for its unlock. Spin locks disable preemption, cannot be held across any blocking operation, and should be held for very short periods. When used to synchronize between interrupt context and thread context they should be locked with interrupts disabled - IOSimpleLockLockDisableInterrupt() will do both. Locking the lock recursively from one thread will result in deadlock.
    @param lock Pointer to the lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOSimpleLockLock</span>(l)	lck_spin_lock(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSimpleLockLock</span>( IOSimpleLock * lock );
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>


<span class="enscript-comment">/*! @function IOSimpleLockTryLock
    @abstract Attempt to lock a spin lock.
@discussion Lock the spin lock if it is currently unlocked, and return true. If the lock is held, return false. Successful calls to IOSimpleLockTryLock should be balanced with calls to IOSimpleLockUnlock. 
    @param lock Pointer to the lock.
    @result True if the lock was unlocked and is now locked by the caller, otherwise false. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOSimpleLockTryLock</span>(l)	lck_spin_try_lock(l)
#<span class="enscript-reference">else</span>
boolean_t <span class="enscript-function-name">IOSimpleLockTryLock</span>( IOSimpleLock * lock );
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

<span class="enscript-comment">/*! @function IOSimpleLockUnlock
    @abstract Unlock a spin lock.
    @discussion Unlock the lock, and restore preemption. Results are undefined if the caller has not locked the lock.
    @param lock Pointer to the lock. */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IOLOCKS_INLINE</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOSimpleLockUnlock</span>(l)	lck_spin_unlock(l)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSimpleLockUnlock</span>( IOSimpleLock * lock );
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !IOLOCKS_INLINE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">typedef</span> boolean_t IOInterruptState;
#<span class="enscript-reference">else</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">long</span> <span class="enscript-type">int</span> IOInterruptState;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @function IOSimpleLockLockDisableInterrupt
    @abstract Lock a spin lock.
    @discussion Lock the spin lock. If the lock is held, spin waiting for its unlock. Simple locks disable preemption, cannot be held across any blocking operation, and should be held for very short periods. When used to synchronize between interrupt context and thread context they should be locked with interrupts disabled - IOSimpleLockLockDisableInterrupt() will do both. Locking the lock recursively from one thread will result in deadlock.
    @param lock Pointer to the lock. */</span>

<span class="enscript-type">static</span> __inline__
IOInterruptState <span class="enscript-function-name">IOSimpleLockLockDisableInterrupt</span>( IOSimpleLock * lock )
{
    IOInterruptState	state = ml_set_interrupts_enabled( false );
    IOSimpleLockLock( lock );
    <span class="enscript-keyword">return</span>( state );
}

<span class="enscript-comment">/*! @function IOSimpleLockUnlockEnableInterrupt
    @abstract Unlock a spin lock, and restore interrupt state.
    @discussion Unlock the lock, and restore preemption and interrupts to the state as they were when the lock was taken. Results are undefined if the caller has not locked the lock.
    @param lock Pointer to the lock.
    @param state The interrupt state returned by IOSimpleLockLockDisableInterrupt() */</span>

<span class="enscript-type">static</span> __inline__
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSimpleLockUnlockEnableInterrupt</span>( IOSimpleLock * lock,
					IOInterruptState state )
{
    IOSimpleLockUnlock( lock );
    ml_set_interrupts_enabled( state );
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__cplusplus</span>
} <span class="enscript-comment">/* extern &quot;C&quot; */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__IOKIT_IOLOCKS_H */</span>

</pre>
<hr />
</body></html>