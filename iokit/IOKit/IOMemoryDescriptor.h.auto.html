<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOMemoryDescriptor.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOMemoryDescriptor.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOMEMORYDESCRIPTOR_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOMEMORYDESCRIPTOR_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTypes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLocks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>

class IOMemoryMap;
class IOMapper;
class IOService;
class IODMACommand;

<span class="enscript-comment">/*
 * Direction of transfer, with respect to the described memory.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">enum</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
<span class="enscript-type">enum</span> IODirection
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
{
    kIODirectionNone  = 0x0,	<span class="enscript-comment">//                    same as VM_PROT_NONE
</span>    kIODirectionIn    = 0x1,	<span class="enscript-comment">// User land 'read',  same as VM_PROT_READ
</span>    kIODirectionOut   = 0x2,	<span class="enscript-comment">// User land 'write', same as VM_PROT_WRITE
</span>    kIODirectionOutIn = kIODirectionOut | kIODirectionIn,
    kIODirectionInOut = kIODirectionIn  | kIODirectionOut,

    <span class="enscript-comment">// these flags are valid for the prepare() method only
</span>    kIODirectionPrepareToPhys32   = 0x00000004,
    kIODirectionPrepareNoFault    = 0x00000008,
    kIODirectionPrepareReserved1  = 0x00000010,
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IODIRECTIONPREPARENONCOHERENTDEFINED</span>	1
    kIODirectionPrepareNonCoherent = 0x00000020,

     <span class="enscript-comment">// these flags are valid for the complete() method only
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IODIRECTIONCOMPLETEWITHERRORDEFINED</span>		1
     kIODirectionCompleteWithError = 0x00000040,
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IODIRECTIONCOMPLETEWITHDATAVALIDDEFINED</span>	1
     kIODirectionCompleteWithDataValid = 0x00000080,
};
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">typedef</span> IOOptionBits IODirection;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>

<span class="enscript-comment">/*
 * IOOptionBits used in the withOptions variant
 */</span>
<span class="enscript-type">enum</span> {
    kIOMemoryDirectionMask	= 0x00000007,
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    kIOMemoryAutoPrepare	= 0x00000008,	<span class="enscript-comment">// Shared with Buffer MD
</span>#<span class="enscript-reference">endif</span>

    kIOMemoryTypeVirtual	= 0x00000010,
    kIOMemoryTypePhysical	= 0x00000020,
    kIOMemoryTypeUPL		= 0x00000030,
    kIOMemoryTypePersistentMD	= 0x00000040,	<span class="enscript-comment">// Persistent Memory Descriptor
</span>    kIOMemoryTypeUIO		= 0x00000050,
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    kIOMemoryTypeVirtual64	= kIOMemoryTypeVirtual,
    kIOMemoryTypePhysical64	= kIOMemoryTypePhysical,
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    kIOMemoryTypeVirtual64	= 0x00000060,
    kIOMemoryTypePhysical64	= 0x00000070,
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    kIOMemoryTypeMask		= 0x000000f0,

    kIOMemoryAsReference	= 0x00000100,
    kIOMemoryBufferPageable	= 0x00000400,
    kIOMemoryMapperNone		= 0x00000800,	<span class="enscript-comment">// Shared with Buffer MD
</span>    kIOMemoryHostOnly           = 0x00001000,   <span class="enscript-comment">// Never DMA accessible
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    kIOMemoryRedirected		= 0x00004000,
    kIOMemoryPreparedReadOnly	= 0x00008000,
#<span class="enscript-reference">endif</span>
    kIOMemoryPersistent		= 0x00010000,
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    kIOMemoryReserved6156215	= 0x00020000,
#<span class="enscript-reference">endif</span>
    kIOMemoryThreadSafe		= 0x00100000,	<span class="enscript-comment">// Shared with Buffer MD
</span>    kIOMemoryClearEncrypt	= 0x00200000,	<span class="enscript-comment">// Shared with Buffer MD
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    kIOMemoryBufferPurgeable	= 0x00400000,
    kIOMemoryBufferCacheMask	= 0x70000000,
    kIOMemoryBufferCacheShift	= 28,
#<span class="enscript-reference">endif</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOMapperSystem</span>	((IOMapper *) 0)

<span class="enscript-type">enum</span> 
{
    kIOMemoryPurgeableKeepCurrent = 1,

    kIOMemoryPurgeableNonVolatile = 2,
    kIOMemoryPurgeableVolatile    = 3,
    kIOMemoryPurgeableEmpty       = 4,

    <span class="enscript-comment">// modifiers for kIOMemoryPurgeableVolatile behavior
</span>    kIOMemoryPurgeableVolatileGroup0           = VM_VOLATILE_GROUP_0,
    kIOMemoryPurgeableVolatileGroup1           = VM_VOLATILE_GROUP_1,
    kIOMemoryPurgeableVolatileGroup2           = VM_VOLATILE_GROUP_2,
    kIOMemoryPurgeableVolatileGroup3           = VM_VOLATILE_GROUP_3,
    kIOMemoryPurgeableVolatileGroup4           = VM_VOLATILE_GROUP_4,
    kIOMemoryPurgeableVolatileGroup5           = VM_VOLATILE_GROUP_5,
    kIOMemoryPurgeableVolatileGroup6           = VM_VOLATILE_GROUP_6,
    kIOMemoryPurgeableVolatileGroup7           = VM_VOLATILE_GROUP_7,
    kIOMemoryPurgeableVolatileBehaviorFifo     = VM_PURGABLE_BEHAVIOR_FIFO,
    kIOMemoryPurgeableVolatileBehaviorLifo     = VM_PURGABLE_BEHAVIOR_LIFO,
    kIOMemoryPurgeableVolatileOrderingObsolete = VM_PURGABLE_ORDERING_OBSOLETE,
    kIOMemoryPurgeableVolatileOrderingNormal   = VM_PURGABLE_ORDERING_NORMAL,
};
<span class="enscript-type">enum</span> 
{
    kIOMemoryIncoherentIOFlush	 = 1,
    kIOMemoryIncoherentIOStore	 = 2,

    kIOMemoryClearEncrypted      = 50,
    kIOMemorySetEncrypted        = 51,
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IOMEMORYDESCRIPTOR_SUPPORTS_DMACOMMAND</span>	1

<span class="enscript-type">struct</span> IODMAMapSpecification
{
	uint64_t    alignment;
	IOService * device;
	uint32_t    options;
	uint8_t     numAddressBits;
	uint8_t     resvA[3];
	uint32_t    resvB[4];
};

<span class="enscript-type">struct</span> IODMAMapPageList
{
    uint32_t                pageOffset;
    uint32_t                pageListCount;
    <span class="enscript-type">const</span> upl_page_info_t * pageList;
};

<span class="enscript-comment">// mapOptions for iovmMapMemory
</span><span class="enscript-type">enum</span>
{
    kIODMAMapReadAccess           = 0x00000001,
    kIODMAMapWriteAccess          = 0x00000002,
    kIODMAMapPhysicallyContiguous = 0x00000010,
    kIODMAMapDeviceMemory         = 0x00000020,
    kIODMAMapPagingPath           = 0x00000040,
    kIODMAMapIdentityMap          = 0x00000080,

    kIODMAMapPageListFullyOccupied = 0x00000100,
    kIODMAMapFixedAddress          = 0x00000200,
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>

<span class="enscript-comment">// Used for dmaCommandOperation communications for IODMACommand and mappers
</span>
<span class="enscript-type">enum</span>  {
    kIOMDWalkSegments             = 0x01000000,
    kIOMDFirstSegment	          = 1 | kIOMDWalkSegments,
    kIOMDGetCharacteristics       = 0x02000000,
    kIOMDGetCharacteristicsMapped = 1 | kIOMDGetCharacteristics,
    kIOMDDMAActive                = 0x03000000,
    kIOMDSetDMAActive             = 1 | kIOMDDMAActive,
    kIOMDSetDMAInactive           = kIOMDDMAActive,
    kIOMDAddDMAMapSpec            = 0x04000000,
    kIOMDDMAMap                   = 0x05000000,
    kIOMDDMACommandOperationMask  = 0xFF000000,
};
<span class="enscript-type">struct</span> IOMDDMACharacteristics {
    UInt64 fLength;
    UInt32 fSGCount;
    UInt32 fPages;
    UInt32 fPageAlign;
    ppnum_t fHighestPage;
    IODirection fDirection;
    UInt8 fIsPrepared;
};

<span class="enscript-type">struct</span> IOMDDMAMapArgs {
    IOMapper            * fMapper;
    IODMACommand        * fCommand;
    IODMAMapSpecification fMapSpec;
    uint64_t              fOffset;
    uint64_t              fLength;
    uint64_t              fAlloc;
    uint64_t              fAllocLength;
    uint8_t               fMapContig;
};

<span class="enscript-type">struct</span> IOMDDMAWalkSegmentArgs {
    UInt64 fOffset;			<span class="enscript-comment">// Input/Output offset
</span>    UInt64 fIOVMAddr, fLength;		<span class="enscript-comment">// Output variables
</span>    UInt8 fMapped;			<span class="enscript-comment">// Input Variable, Require mapped IOVMA
</span>};
<span class="enscript-type">typedef</span> UInt8 IOMDDMAWalkSegmentState[128];

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>

<span class="enscript-type">enum</span> 
{
    kIOPreparationIDUnprepared = 0,
    kIOPreparationIDUnsupported = 1,
    kIOPreparationIDAlwaysPrepared = 2,
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-type">struct</span> IOMemoryReference;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*! @class IOMemoryDescriptor : public OSObject
    @abstract An abstract base class defining common methods for describing physical or virtual memory.
    @discussion The IOMemoryDescriptor object represents a buffer or range of memory, specified as one or more physical or virtual address ranges. It contains methods to return the memory's physically contiguous segments (fragments), for use with the IOMemoryCursor, and methods to map the memory into any address space with caching and placed mapping options. */</span>

class IOMemoryDescriptor : public OSObject
{
    friend class IOMemoryMap;
    friend class IOMultiMemoryDescriptor;

    OSDeclareDefaultStructors(IOMemoryDescriptor);

<span class="enscript-reference">protected</span>:

<span class="enscript-comment">/*! @var reserved
    Reserved for future use.  (Internal use only)  */</span>
    <span class="enscript-type">struct</span> IOMemoryDescriptorReserved * reserved;

<span class="enscript-reference">protected</span>:
    OSSet *		_mappings;
    IOOptionBits 	_flags;


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-reference">public</span>:
    <span class="enscript-type">struct</span> IOMemoryReference *	_memRef;
<span class="enscript-reference">protected</span>:
#<span class="enscript-reference">else</span>
    <span class="enscript-type">void</span> * __iomd_reserved5;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    uint64_t		__iomd_reserved1;
    uint64_t		__iomd_reserved2;
    uint64_t		__iomd_reserved3;
    uint64_t		__iomd_reserved4;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    IODirection         _direction;        <span class="enscript-comment">/* use _flags instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    IOByteCount         _length;           <span class="enscript-comment">/* length of all ranges */</span>
    IOOptionBits 	_tag;

<span class="enscript-reference">public</span>:
<span class="enscript-type">typedef</span> IOOptionBits DMACommandOps;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual IOPhysicalAddress getSourceSegment( IOByteCount offset,
						IOByteCount * length ) APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function initWithOptions
    @abstract Master initialiser for all variants of memory descriptors.  For a more complete description see IOMemoryDescriptor::withOptions.
    @discussion Note this function can be used to re-init a previously created memory descriptor.
    @result true on success, false on failure. */</span>
    virtual bool initWithOptions(<span class="enscript-type">void</span> *		buffers,
                                 UInt32		count,
                                 UInt32		offset,
                                 task_t		task,
                                 IOOptionBits	options,
                                 IOMapper *	mapper = kIOMapperSystem);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual addr64_t getPhysicalSegment64( IOByteCount offset,
                                            IOByteCount * length ) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use getPhysicalSegment() and kIOMemoryMapperNone instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function setPurgeable
    @abstract Control the purgeable status of a memory descriptors memory.
    @discussion Buffers may be allocated with the ability to have their purgeable status changed - IOBufferMemoryDescriptor with the kIOMemoryPurgeable option, VM_FLAGS_PURGEABLE may be passed to vm_allocate() in user space to allocate such buffers. The purgeable status of such a buffer may be controlled with setPurgeable(). The process of making a purgeable memory descriptor non-volatile and determining its previous state is atomic - if a purgeable memory descriptor is made nonvolatile and the old state is returned as kIOMemoryPurgeableVolatile, then the memory's previous contents are completely intact and will remain so until the memory is made volatile again.  If the old state is returned as kIOMemoryPurgeableEmpty then the memory was reclaimed while it was in a volatile state and its previous contents have been lost.
    @param newState - the desired new purgeable state of the memory:&lt;br&gt;
    kIOMemoryPurgeableKeepCurrent - make no changes to the memory's purgeable state.&lt;br&gt;
    kIOMemoryPurgeableVolatile    - make the memory volatile - the memory may be reclaimed by the VM system without saving its contents to backing store.&lt;br&gt;
    kIOMemoryPurgeableNonVolatile - make the memory nonvolatile - the memory is treated as with usual allocations and must be saved to backing store if paged.&lt;br&gt;
    kIOMemoryPurgeableEmpty       - make the memory volatile, and discard any pages allocated to it.
    @param oldState - if non-NULL, the previous purgeable state of the memory is returned here:&lt;br&gt;
    kIOMemoryPurgeableNonVolatile - the memory was nonvolatile.&lt;br&gt;
    kIOMemoryPurgeableVolatile    - the memory was volatile but its content has not been discarded by the VM system.&lt;br&gt;
    kIOMemoryPurgeableEmpty       - the memory was volatile and has been discarded by the VM system.&lt;br&gt;
    @result An IOReturn code. */</span>

    virtual IOReturn setPurgeable( IOOptionBits newState,
                                    IOOptionBits * oldState );
    

<span class="enscript-comment">/*! @function getPageCounts
    @abstract Retrieve the number of resident and/or dirty pages encompassed by an IOMemoryDescriptor.
    @discussion This method returns the number of resident and/or dirty pages encompassed by an IOMemoryDescriptor.
    @param residentPageCount - If non-null, a pointer to a byte count that will return the number of resident pages encompassed by this IOMemoryDescriptor.
    @param dirtyPageCount - If non-null, a pointer to a byte count that will return the number of dirty pages encompassed by this IOMemoryDescriptor.
    @result An IOReturn code. */</span>

    IOReturn getPageCounts( IOByteCount * residentPageCount,
                            IOByteCount * dirtyPageCount);

<span class="enscript-comment">/*! @function performOperation
    @abstract Perform an operation on the memory descriptor's memory.
    @discussion This method performs some operation on a range of the memory descriptor's memory. When a memory descriptor's memory is not mapped, it should be more efficient to use this method than mapping the memory to perform the operation virtually.
    @param options The operation to perform on the memory:&lt;br&gt;
    kIOMemoryIncoherentIOFlush - pass this option to store to memory and flush any data in the processor cache for the memory range, with synchronization to ensure the data has passed through all levels of processor cache. It may not be supported on all architectures. This type of flush may be used for non-coherent I/O such as AGP - it is NOT required for PCI coherent operations. The memory descriptor must have been previously prepared.&lt;br&gt;
    kIOMemoryIncoherentIOStore - pass this option to store to memory any data in the processor cache for the memory range, with synchronization to ensure the data has passed through all levels of processor cache. It may not be supported on all architectures. This type of flush may be used for non-coherent I/O such as AGP - it is NOT required for PCI coherent operations. The memory descriptor must have been previously prepared.
    @param offset A byte offset into the memory descriptor's memory.
    @param length The length of the data range.
    @result An IOReturn code. */</span>

    virtual IOReturn performOperation( IOOptionBits options,
                                        IOByteCount offset, IOByteCount length );

    <span class="enscript-comment">// Used for dedicated communications for IODMACommand
</span>    virtual IOReturn dmaCommandOperation(DMACommandOps op, <span class="enscript-type">void</span> *vData, UInt dataSize) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getPhysicalSegment
    @abstract Break a memory descriptor into its physically contiguous segments.
    @discussion This method returns the physical address of the byte at the given offset into the memory, and optionally the length of the physically contiguous segment from that offset.
    @param offset A byte offset into the memory whose physical address to return.
    @param length If non-zero, getPhysicalSegment will store here the length of the physically contiguous segement at the given offset.
    @result A physical address, or zero if the offset is beyond the length of the memory. */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual addr64_t getPhysicalSegment( IOByteCount   offset,
                                         IOByteCount * length,
                                         IOOptionBits  options = 0 ) = 0;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    virtual addr64_t getPhysicalSegment( IOByteCount   offset,
                                         IOByteCount * length,
                                         IOOptionBits  options );
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    virtual uint64_t getPreparationID( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span>             setPreparationID( <span class="enscript-type">void</span> );

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    IOMemoryDescriptorReserved * getKernelReserved( <span class="enscript-type">void</span> );
    IOReturn dmaMap(
	IOMapper                    * mapper,
	IODMACommand                * command,
	<span class="enscript-type">const</span> IODMAMapSpecification * mapSpec,
	uint64_t                      offset,
	uint64_t                      length,
	uint64_t                    * mapAddress,
	uint64_t                    * mapLength);
#<span class="enscript-reference">endif</span>
	
<span class="enscript-reference">private</span>:
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 1);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 2);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 3);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 4);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 5);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 6);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 7);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 1);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 2);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 3);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 4);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 5);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 6);
    OSMetaClassDeclareReservedUsed(IOMemoryDescriptor, 7);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 8);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 9);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 10);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 11);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 12);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 13);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 14);
    OSMetaClassDeclareReservedUnused(IOMemoryDescriptor, 15);

<span class="enscript-reference">protected</span>:
    virtual <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;
<span class="enscript-reference">public</span>:
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> initialize( <span class="enscript-type">void</span> );

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @function withAddress
    @abstract Create an IOMemoryDescriptor to describe one virtual range of the kernel task.
    @discussion This method creates and initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the kernel map.  This memory descriptor needs to be prepared before it can be used to extract data from the memory described.
    @param address The virtual address of the first byte in the memory.
    @param withLength The length of memory.
    @param withDirection An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.
    @result The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. */</span>

    <span class="enscript-type">static</span> IOMemoryDescriptor * withAddress(<span class="enscript-type">void</span> *       address,
                                            IOByteCount  withLength,
                                            IODirection  withDirection);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-type">static</span> IOMemoryDescriptor * withAddress(IOVirtualAddress address,
                                            IOByteCount  withLength,
                                            IODirection  withDirection,
                                            task_t       withTask) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withAddressRange() and prepare() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function withPhysicalAddress
    @abstract Create an IOMemoryDescriptor to describe one physical range.
    @discussion This method creates and initializes an IOMemoryDescriptor for memory consisting of a single physical memory range.
    @param address The physical address of the first byte in the memory.
    @param withLength The length of memory.
    @param withDirection An I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures.
    @result The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. */</span>

    <span class="enscript-type">static</span> IOMemoryDescriptor * withPhysicalAddress(
				IOPhysicalAddress	address,
				IOByteCount		withLength,
				IODirection      	withDirection );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
     <span class="enscript-type">static</span> IOMemoryDescriptor * withRanges(IOVirtualRange * ranges,
                                            UInt32           withCount,
                                            IODirection      withDirection,
                                            task_t           withTask,
                                            bool             asReference = false) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withAddressRanges() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function withAddressRange
    @abstract Create an IOMemoryDescriptor to describe one virtual range of the specified map.
    @discussion This method creates and initializes an IOMemoryDescriptor for memory consisting of a single virtual memory range mapped into the specified map.  This memory descriptor needs to be prepared before it can be used to extract data from the memory described.
    @param address The virtual address of the first byte in the memory.
    @param withLength The length of memory.
    @param options
        kIOMemoryDirectionMask (options:direction)	This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures. 
    @param task The task the virtual ranges are mapped into. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api. The task argument may be NULL to specify memory by physical address.
    @result The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. */</span>

    <span class="enscript-type">static</span> IOMemoryDescriptor * withAddressRange(
					mach_vm_address_t address,
					mach_vm_size_t	  length,
					IOOptionBits      options,
					task_t            task);

<span class="enscript-comment">/*! @function withAddressRanges
    @abstract Create an IOMemoryDescriptor to describe one or more virtual ranges.
    @discussion This method creates and initializes an IOMemoryDescriptor for memory consisting of an array of virtual memory ranges each mapped into a specified source task.  This memory descriptor needs to be prepared before it can be used to extract data from the memory described.
    @param ranges An array of IOAddressRange structures which specify the virtual ranges in the specified map which make up the memory to be described. IOAddressRange is the 64bit version of IOVirtualRange.
    @param rangeCount The member count of the ranges array.
    @param options
        kIOMemoryDirectionMask (options:direction)	This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures. 
        kIOMemoryAsReference	For options:type = Virtual or Physical this indicate that the memory descriptor need not copy the ranges array into local memory.  This is an optimisation to try to minimise unnecessary allocations.
    @param task The task each of the virtual ranges are mapped into. Note that unlike IOMemoryDescriptor::withAddress(), kernel_task memory must be explicitly prepared when passed to this api. The task argument may be NULL to specify memory by physical address.
    @result The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. */</span>

    <span class="enscript-type">static</span> IOMemoryDescriptor * withAddressRanges(
					IOAddressRange * ranges,
					UInt32           rangeCount,
					IOOptionBits     options,
					task_t           task);

<span class="enscript-comment">/*! @function withOptions
    @abstract Master initialiser for all variants of memory descriptors.
    @discussion This method creates and initializes an IOMemoryDescriptor for memory it has three main variants: Virtual, Physical &amp; mach UPL.  These variants are selected with the options parameter, see below.  This memory descriptor needs to be prepared before it can be used to extract data from the memory described.


    @param buffers A pointer to an array of IOAddressRange when options:type is kIOMemoryTypeVirtual64 or kIOMemoryTypePhysical64 or a 64bit kernel. For type UPL it is a upl_t returned by the mach/memory_object_types.h apis, primarily used internally by the UBC. IOVirtualRanges or IOPhysicalRanges are 32 bit only types for use when options:type is kIOMemoryTypeVirtual or kIOMemoryTypePhysical on 32bit kernels.

    @param count options:type = Virtual or Physical count contains a count of the number of entires in the buffers array.  For options:type = UPL this field contains a total length.

    @param offset Only used when options:type = UPL, in which case this field contains an offset for the memory within the buffers upl.

    @param task Only used options:type = Virtual, The task each of the virtual ranges are mapped into.

    @param options
        kIOMemoryDirectionMask (options:direction)	This nibble indicates the I/O direction to be associated with the descriptor, which may affect the operation of the prepare and complete methods on some architectures. 
        kIOMemoryTypeMask (options:type)	kIOMemoryTypeVirtual64, kIOMemoryTypeVirtual, kIOMemoryTypePhysical64, kIOMemoryTypePhysical, kIOMemoryTypeUPL Indicates that what type of memory basic memory descriptor to use.  This sub-field also controls the interpretation of the buffers, count, offset &amp; task parameters.
        kIOMemoryAsReference	For options:type = Virtual or Physical this indicate that the memory descriptor need not copy the ranges array into local memory.  This is an optimisation to try to minimise unnecessary allocations.
        kIOMemoryBufferPageable	Only used by the IOBufferMemoryDescriptor as an indication that the kernel virtual memory is in fact pageable and we need to use the kernel pageable submap rather than the default map.
    
    @param mapper Which IOMapper should be used to map the in-memory physical addresses into I/O space addresses.  Defaults to 0 which indicates that the system mapper is to be used, if present.  

    @result The created IOMemoryDescriptor on success, to be released by the caller, or zero on failure. */</span>

    <span class="enscript-type">static</span> IOMemoryDescriptor *withOptions(<span class="enscript-type">void</span> *	buffers,
                                           UInt32	count,
                                           UInt32	offset,
                                           task_t	task,
                                           IOOptionBits	options,
                                           IOMapper *	mapper = kIOMapperSystem);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-type">static</span> IOMemoryDescriptor * withPhysicalRanges(
                                            IOPhysicalRange *	ranges,
                                            UInt32		withCount,
                                            IODirection 	withDirection,
                                            bool		asReference = false) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use withOptions() and kIOMemoryTypePhysical instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-type">static</span> IOMemoryDescriptor *	withSubRange(IOMemoryDescriptor *of,
					     IOByteCount offset,
					     IOByteCount length,
					     IODirection withDirection) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use IOSubMemoryDescriptor::withSubRange() and kIOMemoryThreadSafe instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function withPersistentMemoryDescriptor
    @abstract Copy constructor that generates a new memory descriptor if the backing memory for the same task's virtual address and length has changed.
    @discussion If the original memory descriptor's address and length is still backed by the same real memory, i.e. the user hasn't deallocated and the reallocated memory at the same address then the original memory descriptor is returned with a additional reference.  Otherwise we build a totally new memory descriptor with the same characteristics as the previous one but with a new view of the vm.  Note not legal to call this function with anything except an IOGeneralMemoryDescriptor that was created with the kIOMemoryPersistent option.
    @param originalMD The memory descriptor to be duplicated.
    @result Either the original memory descriptor with an additional retain or a new memory descriptor, 0 for a bad original memory descriptor or some other resource shortage. */</span>
    <span class="enscript-type">static</span> IOMemoryDescriptor *
	withPersistentMemoryDescriptor(IOMemoryDescriptor *originalMD);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-comment">// obsolete initializers
</span>	<span class="enscript-comment">// - initWithOptions is the designated initializer 
</span>    virtual bool initWithAddress(<span class="enscript-type">void</span> *       address,
                                 IOByteCount  withLength,
                                 IODirection  withDirection) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use initWithOptions() instead */</span>
    virtual bool initWithAddress(IOVirtualAddress address,
                                 IOByteCount  withLength,
                                 IODirection  withDirection,
                                 task_t       withTask) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use initWithOptions() instead */</span>
    virtual bool initWithPhysicalAddress(
				 IOPhysicalAddress	address,
				 IOByteCount		withLength,
				 IODirection      	withDirection ) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use initWithOptions() instead */</span>
    virtual bool initWithRanges(IOVirtualRange * ranges,
                                UInt32           withCount,
                                IODirection      withDirection,
                                task_t           withTask,
                                bool             asReference = false) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use initWithOptions() instead */</span>
    virtual bool initWithPhysicalRanges(IOPhysicalRange * ranges,
                                        UInt32           withCount,
                                        IODirection      withDirection,
                                        bool             asReference = false) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use initWithOptions() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>

<span class="enscript-comment">/*! @function getDirection
    @abstract Accessor to get the direction the memory descriptor was created with.
    @discussion This method returns the direction the memory descriptor was created with.
    @result The direction. */</span>

    virtual IODirection getDirection() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getLength
    @abstract Accessor to get the length of the memory descriptor (over all its ranges).
    @discussion This method returns the total length of the memory described by the descriptor, ie. the sum of its ranges' lengths.
    @result The byte count. */</span>

    virtual IOByteCount getLength() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function setTag
    @abstract Set the tag for the memory descriptor.
    @discussion This method sets the tag for the memory descriptor. Tag bits are not interpreted by IOMemoryDescriptor.
    @param tag The tag. */</span>

    virtual <span class="enscript-type">void</span> setTag( IOOptionBits tag );

<span class="enscript-comment">/*! @function getTag
    @abstract Accessor to the retrieve the tag for the memory descriptor.
    @discussion This method returns the tag for the memory descriptor. Tag bits are not interpreted by IOMemoryDescriptor.
    @result The tag. */</span>

    virtual IOOptionBits getTag( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function readBytes
    @abstract Copy data from the memory descriptor's buffer to the specified buffer.
    @discussion This method copies data from the memory descriptor's memory at the given offset, to the caller's buffer.  The memory descriptor MUST have the kIODirectionOut direcction bit set  and be prepared.  kIODirectionOut means that this memory descriptor will be output to an external device, so readBytes is used to get memory into a local buffer for a PIO transfer to the device.
    @param offset A byte offset into the memory descriptor's memory.
    @param bytes The caller supplied buffer to copy the data to.
    @param withLength The length of the data to copy.
    @result The number of bytes copied, zero will be returned if the specified offset is beyond the length of the descriptor. Development/debug kernel builds will assert if the offset is beyond the length of the descriptor. */</span>

    virtual IOByteCount readBytes(IOByteCount offset,
				<span class="enscript-type">void</span> * bytes, IOByteCount withLength);

<span class="enscript-comment">/*! @function writeBytes
    @abstract Copy data to the memory descriptor's buffer from the specified buffer.
    @discussion This method copies data to the memory descriptor's memory at the given offset, from the caller's buffer.  The memory descriptor MUST have the kIODirectionIn direcction bit set  and be prepared.  kIODirectionIn means that this memory descriptor will be input from an external device, so writeBytes is used to write memory into the descriptor for PIO drivers.
    @param offset A byte offset into the memory descriptor's memory.
    @param bytes The caller supplied buffer to copy the data from.
    @param withLength The length of the data to copy.
    @result The number of bytes copied, zero will be returned if the specified offset is beyond the length of the descriptor. Development/debug kernel builds will assert if the offset is beyond the length of the descriptor. */</span>

    virtual IOByteCount writeBytes(IOByteCount offset,
				<span class="enscript-type">const</span> <span class="enscript-type">void</span> * bytes, IOByteCount withLength);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual IOPhysicalAddress getPhysicalSegment(IOByteCount offset,
						 IOByteCount * length);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function getPhysicalAddress
    @abstract Return the physical address of the first byte in the memory.
    @discussion This method returns the physical address of the  first byte in the memory. It is most useful on memory known to be physically contiguous.
    @result A physical address. */</span>

    IOPhysicalAddress getPhysicalAddress();

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual <span class="enscript-type">void</span> * getVirtualSegment(IOByteCount offset,
					IOByteCount * length) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use map() and getVirtualAddress() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function prepare
    @abstract Prepare the memory for an I/O transfer.
    @discussion This involves paging in the memory, if necessary, and wiring it down for the duration of the transfer.  The complete() method completes the processing of the memory after the I/O transfer finishes.  Note that the prepare call is not thread safe and it is expected that the client will more easily be able to guarantee single threading a particular memory descriptor.
    @param forDirection The direction of the I/O just completed, or kIODirectionNone for the direction specified by the memory descriptor.
    @result An IOReturn code. */</span>

    virtual IOReturn prepare(IODirection forDirection = kIODirectionNone) = 0;

<span class="enscript-comment">/*! @function complete
    @abstract Complete processing of the memory after an I/O transfer finishes.
    @discussion This method should not be called unless a prepare was previously issued; the prepare() and complete() must occur in pairs, before and after an I/O transfer involving pageable memory.  In 10.3 or greater systems the direction argument to complete is not longer respected.  The direction is totally determined at prepare() time.
    @param forDirection DEPRECATED The direction of the I/O just completed, or kIODirectionNone for the direction specified by the memory descriptor.
    @result An IOReturn code. */</span>

    virtual IOReturn complete(IODirection forDirection = kIODirectionNone) = 0;

    <span class="enscript-comment">/*
     * Mapping functions.
     */</span>

<span class="enscript-comment">/*! @function createMappingInTask
    @abstract Maps a IOMemoryDescriptor into a task.
    @discussion This is the general purpose method to map all or part of the memory described by a memory descriptor into a task at any available address, or at a fixed address if possible. Caching &amp; read-only options may be set for the mapping. The mapping is represented as a returned reference to a IOMemoryMap object, which may be shared if the mapping is compatible with an existing mapping of the IOMemoryDescriptor. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. 
    @param intoTask Sets the target task for the mapping. Pass kernel_task for the kernel address space.
    @param atAddress If a placed mapping is requested, atAddress specifies its address, and the kIOMapAnywhere should not be set. Otherwise, atAddress is ignored.
    @param options Mapping options are defined in IOTypes.h,&lt;br&gt;
	kIOMapAnywhere should be passed if the mapping can be created anywhere. If not set, the atAddress parameter sets the location of the mapping, if it is available in the target map.&lt;br&gt;
	kIOMapDefaultCache to inhibit the cache in I/O areas, kIOMapCopybackCache in general purpose RAM.&lt;br&gt;
	kIOMapInhibitCache, kIOMapWriteThruCache, kIOMapCopybackCache to set the appropriate caching.&lt;br&gt;
	kIOMapReadOnly to allow only read only accesses to the memory - writes will cause and access fault.&lt;br&gt;
	kIOMapReference will only succeed if the mapping already exists, and the IOMemoryMap object is just an extra reference, ie. no new mapping will be created.&lt;br&gt;
	kIOMapUnique allows a special kind of mapping to be created that may be used with the IOMemoryMap::redirect() API. These mappings will not be shared as is the default - there will always be a unique mapping created for the caller, not an existing mapping with an extra reference.&lt;br&gt;
	kIOMapPrefault will try to prefault the pages corresponding to the mapping. This must not be done on the kernel task, and the memory must have been wired via prepare(). Otherwise, the function will fail.&lt;br&gt;
    @param offset Is a beginning offset into the IOMemoryDescriptor's memory where the mapping starts. Zero is the default to map all the memory.
    @param length Is the length of the mapping requested for a subset of the IOMemoryDescriptor. Zero is the default to map all the memory.
    @result A reference to an IOMemoryMap object representing the mapping, which can supply the virtual address of the mapping and other information. The mapping may be shared with multiple callers - multiple maps are avoided if a compatible one exists. The IOMemoryMap object returned should be released only when the caller has finished accessing the mapping, as freeing the object destroys the mapping. The IOMemoryMap instance also retains the IOMemoryDescriptor it maps while it exists. */</span>

    IOMemoryMap * 	createMappingInTask(
	task_t			intoTask,
	mach_vm_address_t	atAddress,
	IOOptionBits		options,
	mach_vm_size_t		offset = 0,
	mach_vm_size_t		length = 0 );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual IOMemoryMap * 	map(
	task_t		intoTask,
	IOVirtualAddress	atAddress,
	IOOptionBits		options,
	IOByteCount		offset = 0,
	IOByteCount		length = 0 ) APPLE_KEXT_DEPRECATED; <span class="enscript-comment">/* use createMappingInTask() instead */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function map
    @abstract Maps a IOMemoryDescriptor into the kernel map.
    @discussion This is a shortcut method to map all the memory described by a memory descriptor into the kernel map at any available address. See the full version of the createMappingInTask method for further details.
    @param options Mapping options as in the full version of the createMappingInTask method, with kIOMapAnywhere assumed.
    @result See the full version of the createMappingInTask method. */</span>

    virtual IOMemoryMap * 	map(
	IOOptionBits		options = 0 );

<span class="enscript-comment">/*! @function setMapping
    @abstract Establishes an already existing mapping.
    @discussion This method tells the IOMemoryDescriptor about a mapping that exists, but was created elsewhere. It allows later callers of the map method to share this externally created mapping. The IOMemoryMap object returned is created to represent it. This method is not commonly needed.
    @param task Address space in which the mapping exists.
    @param mapAddress Virtual address of the mapping.
    @param options Caching and read-only attributes of the mapping.
    @result A IOMemoryMap object created to represent the mapping. */</span>

    virtual IOMemoryMap * 	setMapping(
	task_t		task,
	IOVirtualAddress	mapAddress,
	IOOptionBits		options = 0 );

    <span class="enscript-comment">// Following methods are private implementation
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
    IOReturn redirect( task_t safeTask, bool redirect );

    IOReturn handleFault(
        <span class="enscript-type">void</span> *			_pager,
	mach_vm_size_t		sourceOffset,
	mach_vm_size_t		length);

    IOReturn populateDevicePager(
        <span class="enscript-type">void</span> *			pager,
	vm_map_t		addressMap,
	mach_vm_address_t	address,
	mach_vm_size_t		sourceOffset,
	mach_vm_size_t		length,
        IOOptionBits		options );

    virtual IOMemoryMap * 	makeMapping(
	IOMemoryDescriptor *	owner,
	task_t			intoTask,
	IOVirtualAddress	atAddress,
	IOOptionBits		options,
	IOByteCount		offset,
	IOByteCount		length );

<span class="enscript-reference">protected</span>:
    virtual <span class="enscript-type">void</span> 		addMapping(
	IOMemoryMap *		mapping );

    virtual <span class="enscript-type">void</span> 		removeMapping(
	IOMemoryMap *		mapping );

    virtual IOReturn doMap(
	vm_map_t		addressMap,
	IOVirtualAddress *	atAddress,
	IOOptionBits		options,
	IOByteCount		sourceOffset = 0,
	IOByteCount		length = 0 );

    virtual IOReturn doUnmap(
	vm_map_t		addressMap,
	IOVirtualAddress	logical,
	IOByteCount		length );
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/*! @class IOMemoryMap : public OSObject
    @abstract A class defining common methods for describing a memory mapping.
    @discussion The IOMemoryMap object represents a mapped range of memory, described by a IOMemoryDescriptor. The mapping may be in the kernel or a non-kernel task and has processor cache mode attributes. IOMemoryMap instances are created by IOMemoryDescriptor when it creates mappings in its map method, and returned to the caller. */</span>

class IOMemoryMap : public OSObject
{
    OSDeclareDefaultStructors(IOMemoryMap)
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-reference">public</span>:
    IOMemoryDescriptor * fMemory;
    IOMemoryMap *	 fSuperMap;
    mach_vm_size_t	 fOffset;
    mach_vm_address_t	 fAddress;
    mach_vm_size_t	 fLength;
    task_t		 fAddressTask;
    vm_map_t		 fAddressMap;
    IOOptionBits	 fOptions;
    upl_t		 fRedirUPL;
    ipc_port_t		 fRedirEntry;
    IOMemoryDescriptor * fOwner;
    uint8_t		 fUserClientUnmap;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    IOTracking           fTracking;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-reference">protected</span>:
    virtual <span class="enscript-type">void</span> taggedRelease(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *tag = 0) <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE;
    virtual <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @function getVirtualAddress
    @abstract Accessor to the virtual address of the first byte in the mapping.
    @discussion This method returns the virtual address of the first byte in the mapping. Since the IOVirtualAddress is only 32bit in 32bit kernels, the getAddress() method should be used for compatibility with 64bit task mappings.
    @result A virtual address. */</span>

    virtual IOVirtualAddress 	getVirtualAddress();

<span class="enscript-comment">/*! @function getPhysicalSegment
    @abstract Break a mapping into its physically contiguous segments.
    @discussion This method returns the physical address of the byte at the given offset into the mapping, and optionally the length of the physically contiguous segment from that offset. It functions similarly to IOMemoryDescriptor::getPhysicalSegment.
    @param offset A byte offset into the mapping whose physical address to return.
    @param length If non-zero, getPhysicalSegment will store here the length of the physically contiguous segement at the given offset.
    @result A physical address, or zero if the offset is beyond the length of the mapping. */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual IOPhysicalAddress 	getPhysicalSegment(IOByteCount offset,
	       					   IOByteCount * length,
	       					   IOOptionBits  options = 0);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    virtual IOPhysicalAddress 	getPhysicalSegment(IOByteCount offset,
	       					   IOByteCount * length);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function getPhysicalAddress
    @abstract Return the physical address of the first byte in the mapping.
    @discussion This method returns the physical address of the  first byte in the mapping. It is most useful on mappings known to be physically contiguous.
    @result A physical address. */</span>

    IOPhysicalAddress getPhysicalAddress();

<span class="enscript-comment">/*! @function getLength
    @abstract Accessor to the length of the mapping.
    @discussion This method returns the length of the mapping.
    @result A byte count. */</span>

    virtual IOByteCount 	getLength();

<span class="enscript-comment">/*! @function getAddressTask
    @abstract Accessor to the task of the mapping.
    @discussion This method returns the mach task the mapping exists in.
    @result A mach task_t. */</span>

    virtual task_t		getAddressTask();

<span class="enscript-comment">/*! @function getMemoryDescriptor
    @abstract Accessor to the IOMemoryDescriptor the mapping was created from.
    @discussion This method returns the IOMemoryDescriptor the mapping was created from.
    @result An IOMemoryDescriptor reference, which is valid while the IOMemoryMap object is retained. It should not be released by the caller. */</span>

    virtual IOMemoryDescriptor * getMemoryDescriptor();

<span class="enscript-comment">/*! @function getMapOptions
    @abstract Accessor to the options the mapping was created with.
    @discussion This method returns the options to IOMemoryDescriptor::map the mapping was created with.
    @result Options for the mapping, including cache settings. */</span>

    virtual IOOptionBits 	getMapOptions();

<span class="enscript-comment">/*! @function unmap
    @abstract Force the IOMemoryMap to unmap, without destroying the object.
    @discussion IOMemoryMap instances will unmap themselves upon free, ie. when the last client with a reference calls release. This method forces the IOMemoryMap to destroy the mapping it represents, regardless of the number of clients. It is not generally used.
    @result An IOReturn code. */</span>

    virtual IOReturn 		unmap();

    virtual <span class="enscript-type">void</span>		taskDied();

<span class="enscript-comment">/*! @function redirect
    @abstract Replace the memory mapped in a process with new backing memory.
    @discussion An IOMemoryMap created with the kIOMapUnique option to IOMemoryDescriptor::map() can remapped to a new IOMemoryDescriptor backing object. If the new IOMemoryDescriptor is specified as NULL, client access to the memory map is blocked until a new backing object has been set. By blocking access and copying data, the caller can create atomic copies of the memory while the client is potentially reading or writing the memory. 
    @param newBackingMemory The IOMemoryDescriptor that represents the physical memory that is to be now mapped in the virtual range the IOMemoryMap represents. If newBackingMemory is NULL, any access to the mapping will hang (in vm_fault()) until access has been restored by a new call to redirect() with non-NULL newBackingMemory argument.
    @param options Mapping options are defined in IOTypes.h, and are documented in IOMemoryDescriptor::map()
    @param offset As with IOMemoryDescriptor::map(), a beginning offset into the IOMemoryDescriptor's memory where the mapping starts. Zero is the default.
    @result An IOReturn code. */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">// For 32 bit XNU, there is a 32 bit (IOByteCount) and a 64 bit (mach_vm_size_t) interface;
</span><span class="enscript-comment">// for 64 bit, these fall together on the 64 bit one.
</span>    virtual IOReturn		redirect(IOMemoryDescriptor * newBackingMemory,
					 IOOptionBits         options,
					 IOByteCount          offset = 0);
#<span class="enscript-reference">endif</span>
    virtual IOReturn		redirect(IOMemoryDescriptor * newBackingMemory,
					 IOOptionBits         options,
					 mach_vm_size_t       offset = 0);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function getAddress
    @abstract Accessor to the virtual address of the first byte in the mapping.
    @discussion This method returns the virtual address of the first byte in the mapping.
    @result A virtual address. */</span>
<span class="enscript-comment">/*! @function getSize
    @abstract Accessor to the length of the mapping.
    @discussion This method returns the length of the mapping.
    @result A byte count. */</span>
    inline mach_vm_address_t 	getAddress() __attribute__((always_inline));
    inline mach_vm_size_t 	getSize() __attribute__((always_inline));
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
<span class="enscript-comment">/*! @function getAddress
    @abstract Accessor to the virtual address of the first byte in the mapping.
    @discussion This method returns the virtual address of the first byte in the mapping.
    @result A virtual address. */</span>
<span class="enscript-comment">/*! @function getSize
    @abstract Accessor to the length of the mapping.
    @discussion This method returns the length of the mapping.
    @result A byte count. */</span>
    virtual mach_vm_address_t 	getAddress();
    virtual mach_vm_size_t 	getSize();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-comment">// for IOMemoryDescriptor use
</span>    IOMemoryMap * copyCompatible( IOMemoryMap * newMapping );

    bool init(
	task_t			intoTask,
	mach_vm_address_t	toAddress,
	IOOptionBits		options,
        mach_vm_size_t		offset,
        mach_vm_size_t		length );

    bool    setMemoryDescriptor(IOMemoryDescriptor * _memory, mach_vm_size_t _offset);

    IOReturn redirect(
	task_t			intoTask, bool redirect );

    IOReturn userClientUnmap();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

    IOReturn wireRange(
    	uint32_t		options,
        mach_vm_size_t		offset,
        mach_vm_size_t		length);

    OSMetaClassDeclareReservedUnused(IOMemoryMap, 0);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 1);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 2);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 3);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 4);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 5);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 6);
    OSMetaClassDeclareReservedUnused(IOMemoryMap, 7);
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-comment">// Also these flags should not overlap with the options to
</span><span class="enscript-comment">//	IOMemoryDescriptor::initWithRanges(... IOOptionsBits options);
</span><span class="enscript-type">enum</span> {
    _kIOMemorySourceSegment	= 0x00002000
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">// The following classes are private implementation of IOMemoryDescriptor - they
</span><span class="enscript-comment">// should not be referenced directly, just through the public API's in the 
</span><span class="enscript-comment">// IOMemoryDescriptor class. For example, an IOGeneralMemoryDescriptor instance
</span><span class="enscript-comment">// might be created by IOMemoryDescriptor::withAddressRange(), but there should be 
</span><span class="enscript-comment">// no need to reference as anything but a generic IOMemoryDescriptor *.
</span>
class IOGeneralMemoryDescriptor : public IOMemoryDescriptor
{
    OSDeclareDefaultStructors(IOGeneralMemoryDescriptor);

<span class="enscript-reference">public</span>:
    <span class="enscript-type">union</span> Ranges {
        IOVirtualRange   *v;
        IOAddressRange   *v64;
        IOPhysicalRange  *p;
	<span class="enscript-type">void</span> 		 *uio;
    };
<span class="enscript-reference">protected</span>:
    Ranges		_ranges;
    <span class="enscript-type">unsigned</span>		_rangesCount;       <span class="enscript-comment">/* number of address ranges in list */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    bool		_rangesIsAllocated; <span class="enscript-comment">/* is list allocated by us? */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    task_t		_task;               <span class="enscript-comment">/* task where all ranges are mapped to */</span>

    <span class="enscript-type">union</span> {
        IOVirtualRange	v;
        IOPhysicalRange	p;
    }			_singleRange;	   <span class="enscript-comment">/* storage space for a single range */</span>

    <span class="enscript-type">unsigned</span>		_wireCount;        <span class="enscript-comment">/* number of outstanding wires */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    uintptr_t _cachedVirtualAddress;

    IOPhysicalAddress	_cachedPhysicalAddress;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    bool		_initialized;      <span class="enscript-comment">/* has superclass been initialized? */</span>

<span class="enscript-reference">public</span>:
    virtual <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

    virtual IOReturn dmaCommandOperation(DMACommandOps op, <span class="enscript-type">void</span> *vData, UInt dataSize) <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE;

    virtual uint64_t getPreparationID( <span class="enscript-type">void</span> ) APPLE_KEXT_OVERRIDE;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-comment">// Internal APIs may be made virtual at some time in the future.
</span>    IOReturn wireVirtual(IODirection forDirection);
    IOReturn dmaMap(
	IOMapper                    * mapper,
	IODMACommand                * command,
	<span class="enscript-type">const</span> IODMAMapSpecification * mapSpec,
	uint64_t                      offset,
	uint64_t                      length,
	uint64_t                    * mapAddress,
	uint64_t                    * mapLength);
    bool initMemoryEntries(size_t size, IOMapper * mapper);

    IOMemoryReference * memoryReferenceAlloc(uint32_t capacity, 
    					     IOMemoryReference * realloc);
    <span class="enscript-type">void</span> memoryReferenceFree(IOMemoryReference * ref);
    <span class="enscript-type">void</span> memoryReferenceRelease(IOMemoryReference * ref);

    IOReturn memoryReferenceCreate(
                        IOOptionBits         options,
                        IOMemoryReference ** reference);

    IOReturn memoryReferenceMap(IOMemoryReference * ref,
			 vm_map_t            map,
			 mach_vm_size_t      inoffset,
			 mach_vm_size_t      size,
			 IOOptionBits        options,
			 mach_vm_address_t * inaddr);

    <span class="enscript-type">static</span> IOReturn memoryReferenceSetPurgeable(
				IOMemoryReference * ref,
				IOOptionBits newState,
				IOOptionBits * oldState);
    <span class="enscript-type">static</span> IOReturn memoryReferenceGetPageCounts(
			       IOMemoryReference * ref,
                               IOByteCount       * residentPageCount,
                               IOByteCount       * dirtyPageCount);
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">private</span>:

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    virtual <span class="enscript-type">void</span> setPosition(IOByteCount position);
    virtual <span class="enscript-type">void</span> mapIntoKernel(<span class="enscript-type">unsigned</span> rangeIndex);
    virtual <span class="enscript-type">void</span> unmapFromKernel();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-comment">// Internal
</span>    OSData *	    _memoryEntries;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    _pages;
    ppnum_t	    _highestPage;
    uint32_t	    __iomd_reservedA;
    uint32_t	    __iomd_reservedB;

    IOLock *	    _prepareLock;

<span class="enscript-reference">public</span>:
    <span class="enscript-comment">/*
     * IOMemoryDescriptor required methods
     */</span>

    <span class="enscript-comment">// Master initaliser
</span>    virtual bool initWithOptions(<span class="enscript-type">void</span> *		buffers,
                                 UInt32		count,
                                 UInt32		offset,
                                 task_t		task,
                                 IOOptionBits	options,
                                 IOMapper *	mapper = kIOMapperSystem) APPLE_KEXT_OVERRIDE;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-comment">// Secondary initialisers
</span>    virtual bool initWithAddress(<span class="enscript-type">void</span> *		address,
                                 IOByteCount	withLength,
                                 IODirection	withDirection) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual bool initWithAddress(IOVirtualAddress address,
                                 IOByteCount    withLength,
                                 IODirection	withDirection,
                                 task_t		withTask) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual bool initWithPhysicalAddress(
				 IOPhysicalAddress	address,
				 IOByteCount		withLength,
				 IODirection      	withDirection ) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual bool initWithRanges(        IOVirtualRange * ranges,
                                        UInt32           withCount,
                                        IODirection      withDirection,
                                        task_t           withTask,
                                        bool             asReference = false) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual bool initWithPhysicalRanges(IOPhysicalRange * ranges,
                                        UInt32           withCount,
                                        IODirection      withDirection,
                                        bool             asReference = false) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual addr64_t getPhysicalSegment64( IOByteCount offset,
                                            IOByteCount * length ) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual IOPhysicalAddress getPhysicalSegment(IOByteCount offset,
						 IOByteCount * length) APPLE_KEXT_OVERRIDE;

    virtual IOPhysicalAddress getSourceSegment(IOByteCount offset,
                                               IOByteCount * length) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;

    virtual <span class="enscript-type">void</span> * getVirtualSegment(IOByteCount offset,
					IOByteCount * length) APPLE_KEXT_OVERRIDE APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    virtual IOReturn setPurgeable( IOOptionBits newState,
                                    IOOptionBits * oldState ) APPLE_KEXT_OVERRIDE;
    
    virtual addr64_t getPhysicalSegment( IOByteCount   offset,
                                         IOByteCount * length,
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
                                         IOOptionBits  options = 0 ) APPLE_KEXT_OVERRIDE;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
                                         IOOptionBits  options ) APPLE_KEXT_OVERRIDE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    virtual IOReturn prepare(IODirection forDirection = kIODirectionNone) APPLE_KEXT_OVERRIDE;

    virtual IOReturn complete(IODirection forDirection = kIODirectionNone) APPLE_KEXT_OVERRIDE;

    virtual IOReturn doMap(
	vm_map_t		addressMap,
	IOVirtualAddress *	atAddress,
	IOOptionBits		options,
	IOByteCount		sourceOffset = 0,
	IOByteCount		length = 0 ) APPLE_KEXT_OVERRIDE;

    virtual IOReturn doUnmap(
	vm_map_t		addressMap,
	IOVirtualAddress	logical,
	IOByteCount		length ) APPLE_KEXT_OVERRIDE;

    virtual bool serialize(OSSerialize *s) <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE;

    <span class="enscript-comment">// Factory method for cloning a persistent IOMD, see IOMemoryDescriptor
</span>    <span class="enscript-type">static</span> IOMemoryDescriptor *
	withPersistentMemoryDescriptor(IOGeneralMemoryDescriptor *originalMD);

};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
mach_vm_address_t 	IOMemoryMap::getAddress()
{
    <span class="enscript-keyword">return</span> (getVirtualAddress());
}

mach_vm_size_t 	IOMemoryMap::getSize()
{
    <span class="enscript-keyword">return</span> (getLength());
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOSubMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IOMEMORYDESCRIPTOR_H */</span>
</pre>
<hr />
</body></html>