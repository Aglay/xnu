<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOService.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOService.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1998,1999 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */</span>
<span class="enscript-comment">/*!
    @header
    This header contains the definition of the IOService class.  IOService is the sole direct subclass of IORegistryEntry and is the base class of almost all I/O Kit family superclasses.  IOService defines methods that support the life cycle of I/O Kit drivers.  For more information on IOService, see {@linkdoc //apple_ref/doc/uid/TP0000011 I/O Kit Fundamentals}.

    @seealso //apple_ref/doc/header/IORegistryEntry.h IORegistryEntry
*/</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOKIT_IOSERVICE_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOKIT_IOSERVICE_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IORegistryEntry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReturn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceMemory.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IONotifier.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLocks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterrupts.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMpowerState.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOServicePM.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReportTypes.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UINT64_MAX</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UINT64_MAX</span>        18446744073709551615ULL
#<span class="enscript-reference">endif</span>


<span class="enscript-type">enum</span> {
    kIODefaultProbeScore    = 0
};

<span class="enscript-comment">// masks for getState()
</span><span class="enscript-type">enum</span> {
    kIOServiceInactiveState = 0x00000001,
    kIOServiceRegisteredState   = 0x00000002,
    kIOServiceMatchedState  = 0x00000004,
    kIOServiceFirstPublishState = 0x00000008,
    kIOServiceFirstMatchState   = 0x00000010
};

<span class="enscript-type">enum</span> {
    <span class="enscript-comment">// options for registerService()
</span>    kIOServiceExclusive     = 0x00000001,

    <span class="enscript-comment">// options for terminate()
</span>    kIOServiceRequired      = 0x00000001,
    kIOServiceTerminate     = 0x00000004,

    <span class="enscript-comment">// options for registerService() &amp; terminate()
</span>    kIOServiceSynchronous   = 0x00000002,
    <span class="enscript-comment">// options for registerService()
</span>    kIOServiceAsynchronous  = 0x00000008
};

<span class="enscript-comment">// options for open()
</span><span class="enscript-type">enum</span> {
    kIOServiceSeize     = 0x00000001,
    kIOServiceFamilyOpenOptions = 0xffff0000
};

<span class="enscript-comment">// options for close()
</span><span class="enscript-type">enum</span> {
    kIOServiceFamilyCloseOptions = 0xffff0000
};

<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> * IONotificationRef;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> IORegistryPlane *  gIOServicePlane;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> IORegistryPlane *  gIOPowerPlane;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOResourcesKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOResourceMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOProviderClassKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIONameMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIONameMatchedKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOPropertyMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOLocationMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOParentMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOPathMatchKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOMatchCategoryKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIODefaultMatchCategoryKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOMatchedServiceCountKey;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOUserClientClassKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOKitDebugKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOServiceKey;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOCommandPoolSizeKey;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOPublishNotification;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOFirstPublishNotification;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOMatchedNotification;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOFirstMatchNotification;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOTerminatedNotification;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOGeneralInterest;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOBusyInterest;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOOpenInterest;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOAppPowerStateInterest;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOPriorityPowerStateInterest;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOConsoleSecurityInterest;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIODeviceMemoryKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOInterruptControllersKey;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *     gIOInterruptSpecifiersKey;

<span class="enscript-type">extern</span> SInt32 <span class="enscript-function-name">IOServiceOrdering</span>( <span class="enscript-type">const</span> OSMetaClassBase * inObj1, <span class="enscript-type">const</span> OSMetaClassBase * inObj2, <span class="enscript-type">void</span> * ref );

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*IOInterruptAction)( OSObject * target, <span class="enscript-type">void</span> * refCon,
                   IOService * nub, <span class="enscript-type">int</span> source );

<span class="enscript-comment">/*! @typedef IOServiceNotificationHandler
    @param target Reference supplied when the notification was registered.
    @param refCon Reference constant supplied when the notification was registered.
    @param newService The IOService object the notification is delivering. It is retained for the duration of the handler's invocation and doesn't need to be released by the handler. */</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">bool</span> (*IOServiceNotificationHandler)( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
                                  IOService * newService );

<span class="enscript-type">typedef</span> <span class="enscript-function-name">bool</span> (*IOServiceMatchingNotificationHandler)( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
                                  IOService * newService,
                                  IONotifier * notifier );

<span class="enscript-comment">/*! @typedef IOServiceInterestHandler
    @param target Reference supplied when the notification was registered.
    @param refCon Reference constant supplied when the notification was registered.
    @param messageType Type of the message - IOKit defined in IOKit/IOMessage.h or family specific.
    @param provider The IOService object who is delivering the notification. It is retained for the duration of the handler's invocation and doesn't need to be released by the handler.
    @param messageArgument An argument for message, dependent on its type.
    @param argSize Non zero if the argument represents a struct of that size, used when delivering messages outside the kernel. */</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">IOReturn</span> (*IOServiceInterestHandler)( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
                                              UInt32 messageType, IOService * provider,
                                              <span class="enscript-type">void</span> * messageArgument, vm_size_t argSize );

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*IOServiceApplierFunction)(IOService * service, <span class="enscript-type">void</span> * context);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*OSObjectApplierFunction)(OSObject * object, <span class="enscript-type">void</span> * context);

class IOUserClient;
class IOPlatformExpert;

<span class="enscript-comment">/*! @class IOService
    @abstract The base class for most I/O Kit families, devices, and drivers.
    @discussion The IOService base class defines APIs used to publish services, instantiate other services based on the existance of a providing service (ie. driver stacking), destroy a service and its dependent stack, notify interested parties of service state changes, and general utility functions useful across all families. 

Types of service are specified with a matching dictionary that describes properties of the service. For example, a matching dictionary might describe any IOUSBDevice (or subclass), an IOUSBDevice with a certain class code, or a IOPCIDevice with a set of matching names or device &amp; vendor IDs. Since the matching dictionary is interpreted by the family which created the service, as well as generically by IOService, the list of properties considered for matching depends on the familiy.

Matching dictionaries are associated with IOService classes by the catalogue, as driver property tables, and also supplied by clients of the notification APIs.

IOService provides matching based on C++ class (via OSMetaClass dynamic casting), registry entry name, a registry path to the service (which includes device tree paths), a name assigned by BSD, or by its location (its point of attachment).

&lt;br&gt;&lt;br&gt;Driver Instantiation by IOService&lt;br&gt;&lt;br&gt;

Drivers are subclasses of IOService, and their availability is managed through the catalogue. They are instantiated based on the publication of an IOService they use (for example, an IOPCIDevice or IOUSBDevice), or when they are added to  the catalogue and the IOService(s) they use are already available.

When an IOService (the &quot;provider&quot;) is published with the @link registerService registerService@/link method, the matching and probing process begins, which is always single threaded per provider. A list of matching dictionaries from the catalog and installed publish notification requests, that successfully match the IOService, is constructed, with ordering supplied by &lt;code&gt;kIOProbeScoreKey&lt;/code&gt; (&quot;IOProbeScore&quot;) property in the dictionary, or supplied with the notification. 

Each entry in the list is then processed in order - for notifications, the notification is delivered, for driver property tables a lot more happens.

The driver class is instantiated and &lt;code&gt;init()&lt;/code&gt; called with its property table. The new driver instance is then attached to the provider, and has its @link probe probe@/link method called with the provider as an argument. The default &lt;code&gt;probe&lt;/code&gt; method does nothing but return success, but a driver may implement this method to interrogate the provider to make sure it can work with it. It may also modify its probe score at this time. After probe, the driver is detached and the next in the list is considered (ie. attached, probed, and detached).

When the probing phase is complete, the list consists of successfully probed drivers, in order of their probe score (after adjustment during the @link probe probe@/link call). The list is then divided into categories based on the &lt;code&gt;kIOMatchCategoryKey&lt;/code&gt; property (&quot;IOMatchCategory&quot;); drivers without a match category are all considered in one default category. Match categories allow multiple clients of a provider to be attached and started, though the provider may also enforce open/close semantics to gain active access to it.

For each category, the highest scoring driver in that category is attached to the provider, and its @link start start@/link method called. If &lt;code&gt;start&lt;/code&gt; is successful, the rest of the drivers in the same match category are discarded, otherwise the next highest scoring driver is started, and so on.

The driver should only consider itself in action when the start method is called, meaning it has been selected for use on the provider, and consuming that particular match category. It should also be prepared to be allocated, probed and freed even if the probe was successful.

After the drivers have all synchronously been started, the installed &quot;matched&quot; notifications that match the registered IOService are delivered.

&lt;br&gt;&lt;br&gt;Properties used by IOService&lt;br&gt;&lt;br&gt;

    &lt;code&gt;kIOClassKey, extern const OSSymbol * gIOClassKey, &quot;IOClass&quot;&lt;/code&gt;
&lt;br&gt;
&lt;br&gt;
Class of the driver to instantiate on matching providers.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIOProviderClassKey, extern const OSSymbol * gIOProviderClassKey, &quot;IOProviderClass&quot;&lt;/code&gt;
&lt;br&gt;
&lt;br&gt;
Class of the provider(s) to be considered for matching, checked with OSDynamicCast so subclasses will also match.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIOProbeScoreKey, extern const OSSymbol * gIOProbeScoreKey, &quot;IOProbeScore&quot;&lt;/code&gt;
&lt;br&gt;
&lt;br&gt;
The probe score initially used to order multiple matching drivers.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIOMatchCategoryKey, extern const OSSymbol * gIOMatchCategoryKey, &quot;IOMatchCategory&quot;&lt;/code&gt;
&lt;br&gt;
&lt;br&gt;
A string defining the driver category for matching purposes. All drivers with no &lt;code&gt;IOMatchCategory&lt;/code&gt; property are considered to be in the same default category. Only one driver in a category can be started on each provider.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIONameMatchKey, extern const OSSymbol * gIONameMatchKey, &quot;IONameMatch&quot;&lt;/code&gt;
&lt;br&gt;
A string or collection of strings that match the provider's name. The comparison is implemented with the @link //apple_ref/cpp/instm/IORegistryEntry/compareNames/virtualbool/(OSObject*,OSString**) IORegistryEntry::compareNames@/link method, which supports a single string, or any collection (OSArray, OSSet, OSDictionary etc.) of strings. IOService objects with device tree properties (eg. IOPCIDevice) will also be matched based on that standard's &quot;compatible&quot;, &quot;name&quot;, &quot;device_type&quot; properties. The matching name will be left in the driver's property table in the &lt;code&gt;kIONameMatchedKey&lt;/code&gt; property.
&lt;br&gt;
Examples
&lt;pre&gt;
@textblock
    &lt;key&gt;IONameMatch&lt;/key&gt;
    &lt;string&gt;pci106b,7&lt;/string&gt;
@/textblock
&lt;/pre&gt;

For a list of possible matching names, a serialized array of strings should used, eg.
&lt;pre&gt;
@textblock
    &lt;key&gt;IONameMatch&lt;/key&gt;
    &lt;array&gt;
        &lt;string&gt;APPL,happy16&lt;/string&gt;
        &lt;string&gt;pci106b,7&lt;/string&gt;
    &lt;/array&gt;
@/textblock
&lt;/pre&gt;

&lt;br&gt;
    &lt;code&gt;kIONameMatchedKey, extern const OSSymbol * gIONameMatchedKey, &quot;IONameMatched&quot;&lt;/code&gt;
&lt;br&gt;
The name successfully matched name from the &lt;code&gt;kIONameMatchKey&lt;/code&gt; property will be left in the driver's property table as the &lt;code&gt;kIONameMatchedKey&lt;/code&gt; property.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIOPropertyMatchKey, extern const OSSymbol * gIOPropertyMatchKey, &quot;IOPropertyMatch&quot;&lt;/code&gt;
&lt;br&gt;
A dictionary of properties that each must exist in the matching IOService and compare successfully with the &lt;code&gt;isEqualTo&lt;/code&gt; method.

&lt;pre&gt;
@textblock
    &lt;key&gt;IOPropertyMatch&lt;/key&gt;
    &lt;dictionary&gt;
        &lt;key&gt;APPL,happy16&lt;/key&gt;
        &lt;string&gt;APPL,meek8&lt;/string&gt;
    &lt;/dictionary&gt;
@/textblock
&lt;/pre&gt;

&lt;br&gt;
    &lt;code&gt;kIOUserClientClassKey, extern const OSSymbol * gIOUserClientClassKey, &quot;IOUserClientClass&quot;&lt;/code&gt;
&lt;br&gt;
The class name that the service will attempt to allocate when a user client connection is requested.  First the device nub is queried, then the nub's provider is queried by default.
&lt;br&gt;
&lt;br&gt;
    &lt;code&gt;kIOKitDebugKey, extern const OSSymbol * gIOKitDebugKey, &quot;IOKitDebug&quot;&lt;/code&gt;
&lt;br&gt;
Set some debug flags for logging the driver loading process. Flags are defined in &lt;code&gt;IOKit/IOKitDebug.h&lt;/code&gt;, but &lt;code&gt;65535&lt;/code&gt; works well.*/</span>

<span class="enscript-type">struct</span> IOInterruptAccountingData;
<span class="enscript-type">struct</span> IOInterruptAccountingReporter;

class IOService : public IORegistryEntry
{
    OSDeclareDefaultStructors(IOService)

<span class="enscript-reference">protected</span>:
<span class="enscript-comment">/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of this class in the future.
    */</span>    
    <span class="enscript-type">struct</span> ExpansionData {
        uint64_t authorizationID;
        <span class="enscript-comment">/*
         * Variables associated with interrupt accounting.  Consists of an array
         * (that pairs reporters with opaque &quot;statistics&quot; objects), the count for
         * the array, and a lock to guard both of the former variables.  The lock
         * is necessary as IOReporting will not update reports in a manner that is
         * synchonized with the service (i.e, on a workloop).
         */</span>
        IOLock * interruptStatisticsLock;
        IOInterruptAccountingReporter * interruptStatisticsArray;
        <span class="enscript-type">int</span> interruptStatisticsArrayCount;
    };

<span class="enscript-comment">/*! @var reserved
    Reserved for future use.  (Internal use only)  */</span>
    ExpansionData * reserved;

<span class="enscript-reference">private</span>:
    IOService *     __provider;
    SInt32      __providerGeneration;
    IOService *     __owner;
    IOOptionBits    __state[2];
    uint64_t        __timeBusy;
    uint64_t        __accumBusy;
    IOServicePM *   pwrMgt;

<span class="enscript-reference">protected</span>:
    <span class="enscript-comment">// TRUE once PMinit has been called
</span>    bool            initialized;

<span class="enscript-reference">public</span>:
    <span class="enscript-comment">// DEPRECATED
</span>    <span class="enscript-type">void</span> *          pm_vars;

<span class="enscript-reference">public</span>:
    <span class="enscript-comment">/* methods available in Mac OS X 10.1 or later */</span>
<span class="enscript-comment">/*! @function requestTerminate
    @abstract Passes a termination up the stack.
    @discussion When an IOService is made inactive the default behavior is to also make any of its clients that have it as their only provider also inactive, in this way recursing the termination up the driver stack. This method allows an IOService object to override this behavior. Returning &lt;code&gt;true&lt;/code&gt; from this method when passed a just terminated provider will cause the client to also be terminated.
    @param provider The terminated provider of this object.
    @param options Options originally passed to terminate, plus &lt;code&gt;kIOServiceRecursing&lt;/code&gt;.
    @result &lt;code&gt;true&lt;/code&gt; if this object should be terminated now that its provider has been. */</span>

    virtual bool requestTerminate( IOService * provider, IOOptionBits options );

<span class="enscript-comment">/*! @function willTerminate
    @abstract Passes a termination up the stack.
    @discussion Notification that a provider has been terminated, sent before recursing up the stack, in root-to-leaf order.
    @param provider The terminated provider of this object.
    @param options Options originally passed to terminate.
    @result &lt;code&gt;true&lt;/code&gt;. */</span>

    virtual bool willTerminate( IOService * provider, IOOptionBits options );

<span class="enscript-comment">/*! @function didTerminate
    @abstract Passes a termination up the stack.
    @discussion Notification that a provider has been terminated, sent after recursing up the stack, in leaf-to-root order.
    @param provider The terminated provider of this object.
    @param options Options originally passed to terminate.
    @param defer If there is pending I/O that requires this object to persist, and the provider is not opened by this object set &lt;code&gt;defer&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; and call the &lt;code&gt;IOService::didTerminate()&lt;/code&gt; implementation when the I/O completes. Otherwise, leave &lt;code&gt;defer&lt;/code&gt; set to its default value of &lt;code&gt;false&lt;/code&gt;.
    @result &lt;code&gt;true&lt;/code&gt;. */</span>

    virtual bool didTerminate( IOService * provider, IOOptionBits options, bool * defer );

<span class="enscript-comment">/*! @function nextIdleTimeout
    @availability Mac OS X v10.4 and later
    @abstract Allows subclasses to customize idle power management behavior.
    @discussion Returns the next time that the device should idle into its next lower power state. Subclasses may override for custom idle behavior.
    
    A power managed driver might override this method to provide a more sophisticated idle power off algorithm than the one defined by power management.
    @param currentTime The current time
    @param lastActivity The time of last activity on this device
    @param powerState The device's current power state.
    @result Returns the next time the device should idle off (in seconds, relative to the current time). */</span>

    virtual SInt32 nextIdleTimeout(AbsoluteTime currentTime, 
        AbsoluteTime lastActivity, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> powerState);

<span class="enscript-comment">/*! @function systemWillShutdown
    @availability Mac OS X v10.5 and later
    @abstract Notifies members of the power plane of system shutdown and restart.
    @discussion This function is called for all members of the power plane in leaf-to-root order. If a subclass needs to wait for a pending I/O, then the call to &lt;code&gt;systemWillShutdown&lt;/code&gt; should be postponed until the I/O completes.
    
    Any power managed driver (which has called @link joinPMtree joinPMtree@/link to join the power plane) interested in taking action at system shutdown or restart should override this method.
    @param specifier &lt;code&gt;kIOMessageSystemWillPowerOff&lt;/code&gt; or &lt;code&gt;kIOMessageSystemWillRestart&lt;/code&gt;. */</span>

    virtual <span class="enscript-type">void</span> systemWillShutdown( IOOptionBits specifier );

<span class="enscript-comment">/*! @function copyClientWithCategory
    @availability Mac OS X v10.6 and later
    @param category An OSSymbol corresponding to an IOMatchCategory matching property.
    @result Returns a reference to the IOService child with the given category. The result should be released by the caller.
*/</span>

    virtual IOService * copyClientWithCategory( <span class="enscript-type">const</span> OSSymbol * category );

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @function       configureReport
    @abstract       configure IOReporting channels
    @availability   SPI on OS X v10.9 / iOS 7 and later

    @param  channels    - channels to configure
    @param  action      - enable/disable/size, etc
    @param  result      - action-specific returned value
    @param  destination - action-specific default destination
*/</span>
virtual IOReturn <span class="enscript-function-name">configureReport</span>(IOReportChannelList   *channels,
                                 IOReportConfigureAction action,
                                 <span class="enscript-type">void</span>                  *result,
                                 <span class="enscript-type">void</span>                  *destination);

<span class="enscript-comment">/*! @function       updateReport
    @abstract       request current data for the specified channels
    @availability   SPI on OS X 10.9 / iOS 7 and later

    @param channels     - channels to be updated
    @param action       - type/style of update
    @param result       - returned details about what was updated
    @param destination  - destination for this update (action-specific)
*/</span>
virtual IOReturn <span class="enscript-function-name">updateReport</span>(IOReportChannelList      *channels,
                              IOReportUpdateAction      action,
                              <span class="enscript-type">void</span>                     *result,
                              <span class="enscript-type">void</span>                     *destination);

<span class="enscript-reference">private</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
    OSMetaClassDeclareReservedUsed(IOService, 0);
    OSMetaClassDeclareReservedUsed(IOService, 1);
    OSMetaClassDeclareReservedUnused(IOService, 2);
    OSMetaClassDeclareReservedUnused(IOService, 3);
    OSMetaClassDeclareReservedUnused(IOService, 4);
    OSMetaClassDeclareReservedUnused(IOService, 5);
    OSMetaClassDeclareReservedUnused(IOService, 6);
    OSMetaClassDeclareReservedUnused(IOService, 7);
#<span class="enscript-reference">else</span>
    OSMetaClassDeclareReservedUsed(IOService, 0);
    OSMetaClassDeclareReservedUsed(IOService, 1);
    OSMetaClassDeclareReservedUsed(IOService, 2);
    OSMetaClassDeclareReservedUsed(IOService, 3);
    OSMetaClassDeclareReservedUsed(IOService, 4);
    OSMetaClassDeclareReservedUsed(IOService, 5);
    OSMetaClassDeclareReservedUsed(IOService, 6);
    OSMetaClassDeclareReservedUsed(IOService, 7);
#<span class="enscript-reference">endif</span>

    OSMetaClassDeclareReservedUnused(IOService, 8);
    OSMetaClassDeclareReservedUnused(IOService, 9);
    OSMetaClassDeclareReservedUnused(IOService, 10);
    OSMetaClassDeclareReservedUnused(IOService, 11);
    OSMetaClassDeclareReservedUnused(IOService, 12);
    OSMetaClassDeclareReservedUnused(IOService, 13);
    OSMetaClassDeclareReservedUnused(IOService, 14);
    OSMetaClassDeclareReservedUnused(IOService, 15);
    OSMetaClassDeclareReservedUnused(IOService, 16);
    OSMetaClassDeclareReservedUnused(IOService, 17);
    OSMetaClassDeclareReservedUnused(IOService, 18);
    OSMetaClassDeclareReservedUnused(IOService, 19);
    OSMetaClassDeclareReservedUnused(IOService, 20);
    OSMetaClassDeclareReservedUnused(IOService, 21);
    OSMetaClassDeclareReservedUnused(IOService, 22);
    OSMetaClassDeclareReservedUnused(IOService, 23);
    OSMetaClassDeclareReservedUnused(IOService, 24);
    OSMetaClassDeclareReservedUnused(IOService, 25);
    OSMetaClassDeclareReservedUnused(IOService, 26);
    OSMetaClassDeclareReservedUnused(IOService, 27);
    OSMetaClassDeclareReservedUnused(IOService, 28);
    OSMetaClassDeclareReservedUnused(IOService, 29);
    OSMetaClassDeclareReservedUnused(IOService, 30);
    OSMetaClassDeclareReservedUnused(IOService, 31);
    OSMetaClassDeclareReservedUnused(IOService, 32);
    OSMetaClassDeclareReservedUnused(IOService, 33);
    OSMetaClassDeclareReservedUnused(IOService, 34);
    OSMetaClassDeclareReservedUnused(IOService, 35);
    OSMetaClassDeclareReservedUnused(IOService, 36);
    OSMetaClassDeclareReservedUnused(IOService, 37);
    OSMetaClassDeclareReservedUnused(IOService, 38);
    OSMetaClassDeclareReservedUnused(IOService, 39);
    OSMetaClassDeclareReservedUnused(IOService, 40);
    OSMetaClassDeclareReservedUnused(IOService, 41);
    OSMetaClassDeclareReservedUnused(IOService, 42);
    OSMetaClassDeclareReservedUnused(IOService, 43);
    OSMetaClassDeclareReservedUnused(IOService, 44);
    OSMetaClassDeclareReservedUnused(IOService, 45);
    OSMetaClassDeclareReservedUnused(IOService, 46);
    OSMetaClassDeclareReservedUnused(IOService, 47);

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @function getState
    @abstract Accessor for IOService state bits, not normally needed or used outside IOService.
    @result State bits for the IOService, eg. &lt;code&gt;kIOServiceInactiveState&lt;/code&gt;, &lt;code&gt;kIOServiceRegisteredState&lt;/code&gt;. */</span>

    virtual IOOptionBits getState( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function isInactive
    @abstract Checks if the IOService object has been terminated, and is in the process of being destroyed.
    @discussion When an IOService object is successfully terminated, it is immediately made inactive, which blocks further attach()es, matching or notifications occuring on the object. It remains inactive until the last client closes, and is then finalized and destroyed.
    @result &lt;code&gt;true&lt;/code&gt; if the IOService object has been terminated. */</span>

    bool isInactive( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

    <span class="enscript-comment">/* Stack creation */</span>

<span class="enscript-comment">/*! @function registerService
    @abstract Starts the registration process for a newly discovered IOService object.
    @discussion This function allows an IOService subclass to be published and made available to possible clients, by starting the registration process and delivering notifications to registered clients. The object should be completely setup and ready to field requests from clients before &lt;code&gt;registerService&lt;/code&gt; is called.
    @param options The default zero options mask is recommended and should be used in most cases. The registration process is usually asynchronous, with possible driver probing and notification occurring some time later. &lt;code&gt;kIOServiceSynchronous&lt;/code&gt; may be passed to carry out the matching and notification process for currently registered clients before returning to the caller. */</span>

    virtual <span class="enscript-type">void</span> registerService( IOOptionBits options = 0 );

<span class="enscript-comment">/*! @function probe
    @abstract During an IOService object's instantiation, probes a matched service to see if it can be used.
    @discussion The registration process for an IOService object (the provider) includes instantiating possible driver clients. The &lt;code&gt;probe&lt;/code&gt; method is called in the client instance to check the matched service can be used before the driver is considered to be started. Since matching screens many possible providers, in many cases the &lt;code&gt;probe&lt;/code&gt; method can be left unimplemented by IOService subclasses. The client is already attached to the provider when &lt;code&gt;probe&lt;/code&gt; is called.
    @param provider The registered IOService object that matches a driver personality's matching dictionary.
    @param score Pointer to the current driver's probe score, which is used to order multiple matching drivers in the same match category. It defaults to the value of the &lt;code&gt;IOProbeScore&lt;/code&gt; property in the drivers property table, or &lt;code&gt;kIODefaultProbeScore&lt;/code&gt; if none is specified. The &lt;code&gt;probe&lt;/code&gt; method may alter the score to affect start order.
    @result An IOService instance or zero when the probe is unsuccessful. In almost all cases the value of &lt;code&gt;this&lt;/code&gt; is returned on success. If another IOService object is returned, the probed instance is detached and freed, and the returned instance is used in its stead for &lt;code&gt;start&lt;/code&gt;. */</span>
    
    virtual IOService * probe(  IOService *     provider,
                                SInt32    *     score );

<span class="enscript-comment">/*! @function start
    @abstract During an IOService object's instantiation, starts the IOService object that has been selected to run on the provider.
    @discussion The &lt;code&gt;start&lt;/code&gt; method of an IOService instance is called by its provider when it has been selected (due to its probe score and match category) as the winning client. The client is already attached to the provider when &lt;code&gt;start&lt;/code&gt; is called.&lt;br&gt;Implementations of &lt;code&gt;start&lt;/code&gt; must call &lt;code&gt;start&lt;/code&gt; on their superclass at an appropriate point. If an implementation of &lt;code&gt;start&lt;/code&gt; has already called &lt;code&gt;super::start&lt;/code&gt; but subsequently determines that it will fail, it must call &lt;code&gt;super::stop&lt;/code&gt; to balance the prior call to &lt;code&gt;super::start&lt;/code&gt; and prevent reference leaks.
    @result &lt;code&gt;true&lt;/code&gt; if the start was successful; &lt;code&gt;false&lt;/code&gt; otherwise (which will cause the instance to be detached and usually freed). */</span>
    
    virtual bool start( IOService * provider );
    
<span class="enscript-comment">/*! @function stop
    @abstract During an IOService termination, the stop method is called in its clients before they are detached &amp; it is destroyed.
    @discussion The termination process for an IOService (the provider) will call stop in each of its clients, after they have closed the provider if they had it open, or immediately on termination. */</span>

    virtual <span class="enscript-type">void</span> stop( IOService * provider );

    <span class="enscript-comment">/* Open / Close */</span>

<span class="enscript-comment">/*! @function open
    @abstract Requests active access to a provider.
    @discussion IOService provides generic open and close semantics to track clients of a provider that have established an active datapath. The use of &lt;code&gt;open&lt;/code&gt; and @link close close@/link, and rules regarding ownership are family defined, and defined by the @link handleOpen handleOpen@/link and @link handleClose handleClose@/link methods in the provider. Some families will limit access to a provider based on its open state.
    @param forClient Designates the client of the provider requesting the open.
    @param options Options for the open. The provider family may implement options for open; IOService defines only &lt;code&gt;kIOServiceSeize&lt;/code&gt; to request the device be withdrawn from its current owner.
    @result &lt;code&gt;true&lt;/code&gt; if the open was successful; &lt;code&gt;false&lt;/code&gt; otherwise. */</span>

    virtual bool open(   IOService *       forClient,
                         IOOptionBits      options = 0,
                         <span class="enscript-type">void</span> *        arg = 0 );

<span class="enscript-comment">/*! @function close
    @abstract Releases active access to a provider.
    @discussion IOService provides generic open and close semantics to track clients of a provider that have established an active datapath. The use of @link open open@/link and &lt;code&gt;close&lt;/code&gt;, and rules regarding ownership are family defined, and defined by the @link handleOpen handleOpen@/link and @link handleClose handleClose@/link methods in the provider.
    @param forClient Designates the client of the provider requesting the close.
    @param options Options available for the close. The provider family may implement options for close; IOService defines none.
    @param arg Family specific arguments which are ignored by IOService. */</span>
    
    virtual <span class="enscript-type">void</span> close(  IOService *       forClient,
                         IOOptionBits      options = 0 );
                         
<span class="enscript-comment">/*! @function isOpen
    @abstract Determines whether a specific, or any, client has an IOService object open.
    @discussion Returns the open state of an IOService object with respect to the specified client, or when it is open by any client.
    @param forClient If non-zero, &lt;codeisOpen&lt;/code returns the open state for that client. If zero is passed, &lt;codeisOpen&lt;/code returns the open state for all clients.
    @result &lt;codetrue&lt;/code if the specific, or any, client has the IOService object open. */</span>

    virtual bool isOpen( <span class="enscript-type">const</span> IOService * forClient = 0 ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function handleOpen
    @abstract Controls the open / close behavior of an IOService object (overrideable by subclasses).
    @discussion IOService calls this method in its subclasses in response to the @link open open@/link method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via &lt;code&gt;open&lt;/code&gt;. The object is locked via @link lockForArbitration lockForArbitration@/link before &lt;code&gt;handleOpen&lt;/code&gt; is called.
    @param forClient Designates the client of the provider requesting the open.
    @param options Options for the open, may be interpreted by the implementor of &lt;code&gt;handleOpen&lt;/code&gt;.
    @result &lt;code&gt;true&lt;/code&gt;if the open was successful; &lt;code&gt;false&lt;/code&gt; otherwise. */</span>

    virtual bool handleOpen(    IOService *   forClient,
                                IOOptionBits      options,
                                <span class="enscript-type">void</span> *        arg );
                                
<span class="enscript-comment">/*! @function handleClose
    @abstract Controls the open / close behavior of an IOService object (overrideable by subclasses).
    @discussion IOService calls this method in its subclasses in response to the @link close close@/link method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via @link open open@/link. The object is locked via @link lockForArbitration lockForArbitration@/link before &lt;code&gt;handleClose&lt;/code&gt; is called.
    @param forClient Designates the client of the provider requesting the close.
    @param options Options for the close, may be interpreted by the implementor of @link handleOpen handleOpen@/link. */</span>

    virtual <span class="enscript-type">void</span> handleClose(   IOService *       forClient,
                                IOOptionBits      options );
                                
<span class="enscript-comment">/*! @function handleIsOpen
    @abstract Controls the open / close behavior of an IOService object (overrideable by subclasses).
    @discussion IOService calls this method in its subclasses in response to the @link open open@/link method, so the subclass may implement the request. The default implementation provides single owner access to an IOService object via @link open open@/link. The object is locked via @link lockForArbitration lockForArbitration@/link before &lt;code&gt;handleIsOpen&lt;/code&gt; is called.
    @param forClient If non-zero, &lt;code&gt;isOpen&lt;/code&gt; returns the open state for that client. If zero is passed, &lt;code&gt;isOpen&lt;/code&gt; returns the open state for all clients.
    @result &lt;code&gt;true&lt;/code&gt; if the specific, or any, client has the IOService object open. */</span>

    virtual bool handleIsOpen(  <span class="enscript-type">const</span> IOService * forClient ) <span class="enscript-type">const</span>;

    <span class="enscript-comment">/* Stacking change */</span>

<span class="enscript-comment">/*! @function terminate
    @abstract Makes an IOService object inactive and begins its destruction.
    @discussion Registering an IOService object informs possible clients of its existance and instantiates drivers that may be used with it; &lt;code&gt;terminate&lt;/code&gt; involves the opposite process of informing clients that an IOService object is no longer able to be used and will be destroyed. By default, if any client has the service open, &lt;code&gt;terminate&lt;/code&gt; fails. If the &lt;code&gt;kIOServiceRequired&lt;/code&gt; flag is passed however, &lt;code&gt;terminate&lt;/code&gt; will be successful though further progress in the destruction of the IOService object will not proceed until the last client has closed it. The service will be made inactive immediately upon successful termination, and all its clients will be notified via their @link message message@/link method with a message of type &lt;code&gt;kIOMessageServiceIsTerminated&lt;/code&gt;. Both these actions take place on the caller's thread. After the IOService object is made inactive, further matching or attach calls will fail on it. Each client has its @link stop stop@/link method called upon their close of an inactive IOService object , or on its termination if they do not have it open. After &lt;code&gt;stop&lt;/code&gt;, @link detach detach@/link is called in each client. When all clients have been detached, the @link finalize finalize@/link method is called in the inactive service. The termination process is inherently asynchronous because it will be deferred until all clients have chosen to close.
    @param options In most cases no options are needed. &lt;code&gt;kIOServiceSynchronous&lt;/code&gt; may be passed to cause &lt;code&gt;terminate&lt;/code&gt; to not return until the service is finalized. */</span>

    virtual bool terminate( IOOptionBits options = 0 );

<span class="enscript-comment">/*! @function finalize
    @abstract Finalizes the destruction of an IOService object.
    @discussion The &lt;code&gt;finalize&lt;/code&gt; method is called in an inactive (ie. terminated) IOService object after the last client has detached. IOService's implementation will call @link stop stop@/link, @link close close@/link, and @link detach detach@/link on each provider. When &lt;code&gt;finalize&lt;/code&gt; returns, the object's retain count will have no references generated by IOService's registration process.
    @param options The options passed to the @link terminate terminate@/link method of the IOService object are passed on to &lt;code&gt;finalize&lt;/code&gt;.
    @result &lt;code&gt;true&lt;/code&gt;. */</span>
    
    virtual bool finalize( IOOptionBits options );

<span class="enscript-comment">/*! @function init
    @abstract Initializes generic IOService data structures (expansion data, etc). */</span>
    virtual bool init( OSDictionary * dictionary = 0 ) APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function init
    @abstract Initializes generic IOService data structures (expansion data, etc). */</span>
    virtual bool init( IORegistryEntry * from,
                       <span class="enscript-type">const</span> IORegistryPlane * inPlane ) APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function free
    @abstract Frees data structures that were allocated when power management was initialized on this service. */</span>
    
    virtual <span class="enscript-type">void</span> free( <span class="enscript-type">void</span> ) APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function lockForArbitration
    @abstract Locks an IOService object against changes in state or ownership.
    @discussion The registration, termination and open / close functions of IOService use &lt;code&gt;lockForArbtration&lt;/code&gt; to single-thread access to an IOService object. &lt;code&gt;lockForArbitration&lt;/code&gt; grants recursive access to the same thread.
    @param isSuccessRequired If a request for access to an IOService object should be denied if it is terminated, pass &lt;code&gt;false&lt;/code&gt;, otherwise pass &lt;code&gt;true&lt;/code&gt;. */</span>
    
    virtual bool lockForArbitration( bool isSuccessRequired = true );
    
<span class="enscript-comment">/*! @function unlockForArbitration
    @abstract Unlocks an IOService obkect after a successful @link lockForArbitration lockForArbitration@/link.
    @discussion A thread granted exclusive access to an IOService object should release it with &lt;code&gt;unlockForArbitration&lt;/code&gt;. */</span>
    
    virtual <span class="enscript-type">void</span> unlockForArbitration( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function terminateClient
    @abstract Passes a termination up the stack.
    @discussion When an IOService object is made inactive the default behavior is to also make any of its clients that have it as their only provider inactive, in this way recursing the termination up the driver stack. This method allows a terminated  IOService object to override this behavior. Note the client may also override this behavior by overriding its @link terminate terminate@/link method.
    @param client The client of the terminated provider.
    @param options Options originally passed to @link terminate terminate@/link, plus &lt;code&gt;kIOServiceRecursing&lt;/code&gt;.
    @result result of the terminate request on the client. */</span>

    virtual bool terminateClient( IOService * client, IOOptionBits options );

    <span class="enscript-comment">/* Busy state indicates discovery, matching or termination is in progress */</span>

<span class="enscript-comment">/*! @function getBusyState
    @abstract Returns the &lt;code&gt;busyState&lt;/code&gt; of an IOService object.
    @discussion Many activities in IOService are asynchronous. When registration, matching, or termination is in progress on an IOService object, its &lt;code&gt;busyState&lt;/code&gt; is increased by one. Change in &lt;code&gt;busyState&lt;/code&gt; to or from zero also changes the IOService object's provider's &lt;code&gt;busyState&lt;/code&gt; by one, which means that an IOService object is marked busy when any of the above activities is ocurring on it or any of its clients.
    @result The &lt;code&gt;busyState&lt;/code&gt; value. */</span>

    virtual UInt32 getBusyState( <span class="enscript-type">void</span> );
    
<span class="enscript-comment">/*! @function adjustBusy
    @abstract Adjusts the &lt;code&gt;busyState&lt;/code&gt; of an IOService object.
    @discussion Applies a delta to an IOService object's &lt;code&gt;busyState&lt;/code&gt;. A change in the &lt;code&gt;busyState&lt;/code&gt; to or from zero will change the IOService object's provider's &lt;code&gt;busyState&lt;/code&gt; by one (in the same direction). 
    @param delta The delta to be applied to the IOService object's &lt;code&gt;busyState&lt;/code&gt;. */</span>

    virtual <span class="enscript-type">void</span> adjustBusy( SInt32 delta );

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        IOReturn waitQuiet(mach_timespec_t * timeout)
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function waitQuiet
    @abstract Waits for an IOService object's &lt;code&gt;busyState&lt;/code&gt; to be zero.
    @discussion Blocks the caller until an IOService object is non busy.
    @param timeout The maximum time to wait in nanoseconds. Default is to wait forever.
    @result Returns an error code if Mach synchronization primitives fail, &lt;code&gt;kIOReturnTimeout&lt;/code&gt;, or &lt;code&gt;kIOReturnSuccess&lt;/code&gt;. */</span>
    
    IOReturn waitQuiet(uint64_t timeout = UINT64_MAX);

    <span class="enscript-comment">/* Matching */</span>

<span class="enscript-comment">/*! @function matchPropertyTable
    @abstract Allows a registered IOService object to implement family specific matching.
    @discussion All matching on an IOService object will call this method to allow a family writer to implement matching in addition to the generic methods provided by IOService. The implementer should examine the matching dictionary passed to see if it contains properties the family understands for matching, and use them to match with the IOService object if so. Note that since matching is also carried out by other parts of the I/O Kit, the matching dictionary may contain properties the family does not understand - these should not be considered matching failures.
    @param table The dictionary of properties to be matched against.
    @param score Pointer to the current driver's probe score, which is used to order multiple matching drivers in the same match category. It defaults to the value of the &lt;code&gt;IOProbeScore&lt;/code&gt; property in the drivers property table, or &lt;code&gt;kIODefaultProbeScore&lt;/code&gt; if none is specified.
    @result &lt;code&gt;false&lt;/code&gt; if the family considers the matching dictionary does not match in properties it understands; &lt;code&gt;true&lt;/code&gt; otherwise. */</span>

    virtual bool matchPropertyTable( OSDictionary * table,
                                     SInt32       * score );

    virtual bool matchPropertyTable( OSDictionary * table );

<span class="enscript-comment">/*! @function matchLocation
    @abstract Allows a registered IOService object to direct location matching.
    @discussion By default, a location matching property will be applied to an IOService object's provider. This method allows that behavior to be overridden by families.
    @param client The IOService object at which matching is taking place.
    @result Returns the IOService instance to be used for location matching. */</span>

    virtual IOService * matchLocation( IOService * client );

    <span class="enscript-comment">/* Resource service */</span>

<span class="enscript-comment">/*! @function publishResource
    @abstract Uses the resource service to publish a property.
    @discussion The resource service uses IOService's matching and notification to allow objects to be published and found by any I/O Kit client by a global name. &lt;code&gt;publishResource&lt;/code&gt; makes an object available to anyone waiting for it or looking for it in the future.
    @param key An OSSymbol key that globally identifies the object.
    @param The object to be published. */</span>

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> publishResource( <span class="enscript-type">const</span> OSSymbol * key, OSObject * value = 0 );

<span class="enscript-comment">/*! @function publishResource
    @abstract Uses the resource service to publish a property.
    @discussion The resource service uses IOService object's matching and notification to allow objects to be published and found by any I/O Kit client by a global name. &lt;code&gt;publishResource&lt;/code&gt; makes an object available to anyone waiting for it or looking for it in the future.
    @param key A C string key that globally identifies the object.
    @param The object to be published. */</span>

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> publishResource( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, OSObject * value = 0 );
    virtual bool addNeededResource( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key );

    <span class="enscript-comment">/* Notifications */</span>

<span class="enscript-comment">/*! @function addNotification
    @abstract Deprecated use addMatchingNotification(). Adds a persistant notification handler to be notified of IOService events.
    @discussion IOService will deliver notifications of changes in state of an IOService object to registered clients. The type of notification is specified by a symbol, for example &lt;code&gt;gIOMatchedNotification&lt;/code&gt; or &lt;code&gt;gIOTerminatedNotification&lt;/code&gt;, and notifications will only include IOService objects that match the supplied matching dictionary. Notifications are ordered by a priority set with &lt;code&gt;addNotification&lt;/code&gt;. When the notification is installed, its handler will be called with each of any currently existing IOService objects that are in the correct state (eg. registered) and match the supplied matching dictionary, avoiding races between finding preexisting and new IOService events. The notification request is identified by an instance of an IONotifier object, through which it can be enabled, disabled, or removed. &lt;code&gt;addNotification&lt;/code&gt; consumes a retain count on the matching dictionary when the notification is removed.
    @param type An OSSymbol identifying the type of notification and IOService state:
&lt;br&gt;    &lt;code&gt;gIOPublishNotification&lt;/code&gt; Delivered when an IOService object is registered.
&lt;br&gt;    &lt;code&gt;gIOFirstPublishNotification&lt;/code&gt; Delivered when an IOService object is registered, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
&lt;br&gt;    &lt;code&gt;gIOMatchedNotification&lt;/code&gt; Delivered when an IOService object has been matched with all client drivers, and they have been probed and started.
&lt;br&gt;    &lt;code&gt;gIOFirstMatchNotification&lt;/code&gt; Delivered when an IOService object has been matched with all client drivers, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
&lt;br&gt;    &lt;code&gt;gIOTerminatedNotification&lt;/code&gt; Delivered after an IOService object has been terminated, during its finalize stage.
    @param matching A matching dictionary to restrict notifications to only matching IOService objects. The dictionary will be released when the notification is removed, consuming the passed-in reference.
    @param handler A C function callback to deliver notifications.
    @param target An instance reference for the callback's use.
    @param ref A reference constant for the callback's use.
    @param priority A constant ordering all notifications of a each type.
    @result An instance of an IONotifier object that can be used to control or destroy the notification request. */</span>

    <span class="enscript-type">static</span> IONotifier * addNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref = 0,
                            SInt32 priority = 0 )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function addMatchingNotification
    @abstract Adds a persistant notification handler to be notified of IOService events.
    @discussion IOService will deliver notifications of changes in state of an IOService object to registered clients. The type of notification is specified by a symbol, for example &lt;code&gt;gIOMatchedNotification&lt;/code&gt; or &lt;code&gt;gIOTerminatedNotification&lt;/code&gt;, and notifications will only include IOService objects that match the supplied matching dictionary. Notifications are ordered by a priority set with &lt;code&gt;addNotification&lt;/code&gt;. When the notification is installed, its handler will be called with each of any currently existing IOService objects that are in the correct state (eg. registered) and match the supplied matching dictionary, avoiding races between finding preexisting and new IOService events. The notification request is identified by an instance of an IONotifier object, through which it can be enabled, disabled, or removed. &lt;code&gt;addMatchingNotification&lt;/code&gt; does not consume a reference on the matching dictionary when the notification is removed, unlike addNotification.
    @param type An OSSymbol identifying the type of notification and IOService state:
&lt;br&gt;    &lt;code&gt;gIOPublishNotification&lt;/code&gt; Delivered when an IOService object is registered.
&lt;br&gt;    &lt;code&gt;gIOFirstPublishNotification&lt;/code&gt; Delivered when an IOService object is registered, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
&lt;br&gt;    &lt;code&gt;gIOMatchedNotification&lt;/code&gt; Delivered when an IOService object has been matched with all client drivers, and they have been probed and started.
&lt;br&gt;    &lt;code&gt;gIOFirstMatchNotification&lt;/code&gt; Delivered when an IOService object has been matched with all client drivers, but only once per IOService instance. Some IOService objects may be reregistered when their state is changed.
&lt;br&gt;    &lt;code&gt;gIOTerminatedNotification&lt;/code&gt; Delivered after an IOService object has been terminated, during its finalize stage.
    @param matching A matching dictionary to restrict notifications to only matching IOService objects. The dictionary is retained while the notification is installed. (Differs from addNotification).
    @param handler A C function callback to deliver notifications.
    @param target An instance reference for the callback's use.
    @param ref A reference constant for the callback's use.
    @param priority A constant ordering all notifications of a each type.
    @result An instance of an IONotifier object that can be used to control or destroy the notification request. */</span>

    <span class="enscript-type">static</span> IONotifier * addMatchingNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceMatchingNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref = 0,
                            SInt32 priority = 0 );

<span class="enscript-comment">/*! @function waitForService
    @abstract Deprecated use waitForMatchingService(). Waits for a matching to service to be published.
    @discussion Provides a method of waiting for an IOService object matching the supplied matching dictionary to be registered and fully matched. 
    @param matching The matching dictionary describing the desired IOService object. &lt;code&gt;waitForService&lt;/code&gt; consumes one reference of the matching dictionary.
    @param timeout The maximum time to wait.
    @result A published IOService object matching the supplied dictionary. */</span>

    <span class="enscript-type">static</span> IOService * waitForService( OSDictionary * matching,
                            mach_timespec_t * timeout = 0);

<span class="enscript-comment">/*! @function waitForMatchingService
    @abstract Waits for a matching to service to be published.
    @discussion Provides a method of waiting for an IOService object matching the supplied matching dictionary to be registered and fully matched. 
    @param matching The matching dictionary describing the desired IOService object. (Does not consume a reference of the matching dictionary - differs from waitForService() which does consume a reference on the matching dictionary.)
    @param timeout The maximum time to wait in nanoseconds. Default is to wait forever.
    @result A published IOService object matching the supplied dictionary. waitForMatchingService returns a reference to the IOService which should be released by the caller. (Differs from waitForService() which does not retain the returned object.) */</span>

    <span class="enscript-type">static</span> IOService * waitForMatchingService( OSDictionary * matching,
                            uint64_t timeout = UINT64_MAX);

<span class="enscript-comment">/*! @function getMatchingServices
    @abstract Finds the set of current published IOService objects matching a matching dictionary.
    @discussion Provides a method of finding the current set of published IOService objects matching the supplied matching dictionary.   
    @param matching The matching dictionary describing the desired IOService objects.
    @result An instance of an iterator over a set of IOService objects. To be released by the caller. */</span>

    <span class="enscript-type">static</span> OSIterator * getMatchingServices( OSDictionary * matching );

<span class="enscript-comment">/*! @function copyMatchingService
    @abstract Finds one of the current published IOService objects matching a matching dictionary.
    @discussion Provides a method to find one member of the set of published IOService objects matching the supplied matching dictionary.   
    @param matching The matching dictionary describing the desired IOService object.
    @result The IOService object or NULL. To be released by the caller. */</span>

    <span class="enscript-type">static</span> IOService * copyMatchingService( OSDictionary * matching );

<span class="enscript-reference">public</span>:
    <span class="enscript-comment">/* Helpers to make matching dictionaries for simple cases,
     * they add keys to an existing dictionary, or create one. */</span>

<span class="enscript-comment">/*! @function serviceMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
    @discussion A very common matching criteria for IOService object is based on its class. &lt;code&gt;serviceMatching&lt;/code&gt; creates a matching dictionary that specifies any IOService object of a class, or its subclasses. The class is specified by name, and an existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param className The class name, as a const C string. Class matching is successful on IOService objects of this class or any subclass.
    @param table If zero, &lt;code&gt;serviceMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * serviceMatching( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * className,
                                           OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function serviceMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService class match.
    @discussion A very common matching criteria for IOService object is based on its class. &lt;code&gt;serviceMatching&lt;/code&gt; creates a matching dictionary that specifies any IOService of a class, or its subclasses. The class is specified by name, and an existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param className The class name, as an OSString (which includes OSSymbol). Class matching is successful on IOService objects of this class or any subclass.
    @param table If zero, &lt;code&gt;serviceMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * serviceMatching( <span class="enscript-type">const</span> OSString * className,
                                           OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function nameMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
    @discussion A very common matching criteria for IOService object is based on its name. &lt;code&gt;nameMatching&lt;/code&gt; creates a matching dictionary that specifies any IOService object which responds successfully to the @link //apple_ref/cpp/instm/IORegistryEntry/compareName/virtualbool/(OSString*,OSString**) IORegistryEntry::compareName@/link method. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param name The service's name, as a const C string. Name matching is successful on IOService objects that respond successfully to the &lt;code&gt;IORegistryEntry::compareName&lt;/code&gt; method.
    @param table If zero, &lt;code&gt;nameMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * nameMatching( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
                                        OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function nameMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService name match.
    @discussion A very common matching criteria for IOService object is based on its name. &lt;code&gt;nameMatching&lt;/code&gt; creates a matching dictionary that specifies any IOService object which responds successfully to the @link //apple_ref/cpp/instm/IORegistryEntry/compareName/virtualbool/(OSString*,OSString**) IORegistryEntry::compareName@/link method. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param name The service's name, as an OSString (which includes OSSymbol). Name matching is successful on IOService objects that respond successfully to the &lt;code&gt;IORegistryEntry::compareName&lt;/code&gt; method.
    @param table If zero, &lt;code&gt;nameMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * nameMatching( <span class="enscript-type">const</span> OSString* name,
                                        OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function resourceMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
    @discussion IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
    @param name The resource name, as a const C string. Resource matching is successful when an object by that name has been published with the &lt;code&gt;publishResource&lt;/code&gt; method.
    @param table If zero, &lt;code&gt;resourceMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * resourceMatching( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
                                            OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function resourceMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a resource service match.
    @discussion IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
    @param name The resource name, as an OSString (which includes OSSymbol). Resource matching is successful when an object by that name has been published with the &lt;code&gt;publishResource&lt;/code&gt; method.
    @param table If zero, &lt;code&gt;resourceMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * resourceMatching( <span class="enscript-type">const</span> OSString * name,
                                            OSDictionary * table = 0 );


<span class="enscript-comment">/*! @function propertyMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify an IOService phandle match.
    @discussion TODO A very common matching criteria for IOService is based on its name. nameMatching will create a matching dictionary that specifies any IOService which respond successfully to the IORegistryEntry method compareName. An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param key The service's phandle, as a const UInt32. PHandle matching is successful on IOService objects that respond successfully to the IORegistryEntry method compareName.
    @param value The service's phandle, as a const UInt32. PHandle matching is successful on IOService's which respond successfully to the IORegistryEntry method compareName.
    @param table If zero, nameMatching will create a matching dictionary and return a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * propertyMatching( <span class="enscript-type">const</span> OSSymbol * key, <span class="enscript-type">const</span> OSObject * value,
                                            OSDictionary * table = 0 );

<span class="enscript-comment">/*! @function registryEntryIDMatching
    @abstract Creates a matching dictionary, or adds matching properties to an existing dictionary, that specify a IORegistryEntryID match.
    @discussion &lt;code&gt;registryEntryIDMatching&lt;/code&gt; creates a matching dictionary that specifies the IOService object with the assigned registry entry ID (returned by &lt;code&gt;IORegistryEntry::getRegistryEntryID()&lt;/code&gt;). An existing dictionary may be passed in, in which case the matching properties will be added to that dictionary rather than creating a new one.
    @param name The service's ID. Matching is successful on the IOService object that return that ID from the &lt;code&gt;IORegistryEntry::getRegistryEntryID()&lt;/code&gt; method.
    @param table If zero, &lt;code&gt;registryEntryIDMatching&lt;/code&gt; creates a matching dictionary and returns a reference to it, otherwise the matching properties are added to the specified dictionary.
    @result The matching dictionary created, or passed in, is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * registryEntryIDMatching( uint64_t entryID,
                                                   OSDictionary * table = 0 );


<span class="enscript-comment">/*! @function addLocation
    @abstract Adds a location matching property to an existing dictionary.
    @discussion This function creates matching properties that specify the location of a IOService object, as an embedded matching dictionary. This matching will be successful on an IOService object that attached to an IOService object which matches this location matching dictionary.
    @param table The matching properties are added to the specified dictionary, which must be non-zero.
    @result The location matching dictionary created is returned on success, or zero on failure. */</span>

    <span class="enscript-type">static</span> OSDictionary * addLocation( OSDictionary * table );

    <span class="enscript-comment">/* Helpers for matching dictionaries. */</span>

<span class="enscript-comment">/*! @function compareProperty
    @abstract Compares a property in a matching dictionary with an IOService object's property table.
    @discussion This is a helper function to aid in implementing @link matchPropertyTable matchPropertyTable@/link. If the property specified by &lt;code&gt;key&lt;/code&gt; exists in the matching dictionary, it is compared with a property of the same name in the IOService object's property table. The comparison is performed with the &lt;code&gt;isEqualTo&lt;/code&gt; method. If the property does not exist in the matching table, success is returned. If the property exists in the matching dictionary but not the IOService property table, failure is returned.
    @param matching The matching dictionary, which must be non-zero.
    @param key The dictionary key specifying the property to be compared, as a C string.
    @result &lt;code&gt;true&lt;/code&gt; if the property does not exist in the matching table. If the property exists in the matching dictionary but not the IOService property table, failure is returned. Otherwise the result of calling the property from the matching dictionary's &lt;code&gt;isEqualTo&lt;/code&gt; method with the IOService property as an argument is returned. */</span>

    virtual bool compareProperty(   OSDictionary   * matching,
                                    <span class="enscript-type">const</span> <span class="enscript-type">char</span>     * key );
<span class="enscript-comment">/*! @function compareProperty
    @abstract Compares a property in a matching dictionary with an IOService object's property table.
    @discussion This is a helper function to aid in implementing @link matchPropertyTable matchPropertyTable@/link. If the property specified by &lt;code&gt;key&lt;/code&gt; exists in the matching dictionary, it is compared with a property of the same name in the IOService object's property table. The comparison is performed with the &lt;code&gt;isEqualTo&lt;/code&gt; method. If the property does not exist in the matching table, success is returned. If the property exists in the matching dictionary but not the IOService property table, failure is returned.
    @param matching The matching dictionary, which must be non-zero.
    @param key The dictionary key specifying the property to be compared, as an OSString (which includes OSSymbol).
    @result &lt;code&gt;true&lt;/code&gt; if the property does not exist in the matching table. If the property exists in the matching dictionary but not the IOService property table, failure is returned. Otherwise the result of calling the property from the matching dictionary's &lt;code&gt;isEqualTo&lt;/code&gt; method with the IOService property as an argument is returned. */</span>

    virtual bool compareProperty(   OSDictionary   * matching,
                                    <span class="enscript-type">const</span> OSString * key );

<span class="enscript-comment">/*! @function compareProperties
    @abstract Compares a set of properties in a matching dictionary with an IOService object's property table.
    @discussion This is a helper function to aid in implementing @link matchPropertyTable matchPropertyTable@/link. A collection of dictionary keys specifies properties in a matching dictionary to be compared, with &lt;code&gt;compareProperty&lt;/code&gt;, with an IOService object's property table, if &lt;code&gt;compareProperty&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for each key, success is returned; otherwise failure.
    @param matching The matching dictionary, which must be non-zero.
    @param keys A collection (eg. OSSet, OSArray, OSDictionary) which should contain OSStrings (or OSSymbols) that specify the property keys to be compared.
    @result Success if &lt;code&gt;compareProperty&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for each key in the collection; otherwise failure. */</span>

    virtual bool compareProperties( OSDictionary   * matching,
                                    OSCollection   * keys );

    <span class="enscript-comment">/* Client / provider accessors */</span>

<span class="enscript-comment">/*! @function attach
    @abstract Attaches an IOService client to a provider in the I/O Registry.
    @discussion This function called in an IOService client enters the client into the I/O Registry as a child of the provider in the service plane. The provider must be active or the attach will fail. Multiple attach calls to the same provider are no-ops and return success. A client may be attached to multiple providers. Entering an object into the I/O Registry retains both the client and provider until they are detached.
    @param provider The IOService object which will serve as this object's provider.
    @result &lt;code&gt;false&lt;/code&gt; if the provider is inactive or on a resource failure; otherwise &lt;code&gt;true&lt;/code&gt;. */</span>

    virtual bool attach( IOService * provider );
    
<span class="enscript-comment">/*! @function detach
    @abstract Detaches an IOService client from a provider in the I/O Registry.
    @discussion This function called in an IOService client removes the client as a child of the provider in the service plane of the I/O Registry. If the provider is not a parent of the client this is a no-op, otherwise the I/O Registry releases both the client and provider.
    @param provider The IOService object to detach from. */</span>

    virtual <span class="enscript-type">void</span> detach( IOService * provider );

<span class="enscript-comment">/*! @function getProvider
    @abstract Returns an IOService object's primary provider.
    @discussion This function called in an IOService client will return the provider to which it was first attached. Because the majority of IOService objects have only one provider, this is a useful simplification and also supports caching of the provider when the I/O Registry is unchanged.
    @result The first provider of the client, or zero if the IOService object is not attached into the I/O Registry. The provider is retained while the client is attached, and should not be released by the caller. */</span>

    virtual IOService * getProvider( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getWorkLoop
    @abstract Returns the current work loop or &lt;code&gt;provider-&gt;getWorkLoop&lt;/code&gt;.
    @discussion This function returns a valid work loop that a client can use to add an IOCommandGate to. The intention is that an IOService client has data that needs to be protected but doesn't want to pay the cost of a dedicated thread. This data has to be accessed from a provider's call-out context as well. So to achieve both of these goals the client creates an IOCommandGate to lock access to his data but he registers it with the provider's work loop, i.e. the work loop which will make the completion call-outs. This avoids a potential deadlock because the work loop gate uses a recursive lock, which allows the same lock to be held multiple times by a single thread.
    @result A work loop, either the current work loop or it walks up the @link getProvider getProvider@/link chain calling &lt;code&gt;getWorkLoop&lt;/code&gt;. Eventually it will reach a valid work loop-based driver or the root of the I/O tree, where it will return a system-wide work loop. Returns 0 if it fails to find (or create) a work loop.*/</span>

    virtual IOWorkLoop * getWorkLoop() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getProviderIterator
    @abstract Returns an iterator over an IOService object's providers.
    @discussion For those few IOService objects that obtain service from multiple providers, this method supplies an iterator over a client's providers. 
    @result An iterator over the providers of the client, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, though they may no longer be attached during the iteration. */</span>

    virtual OSIterator * getProviderIterator( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getOpenProviderIterator
    @abstract Returns an iterator over an client's providers that are currently opened by the client.
    @discussion For those few IOService objects that obtain service from multiple providers, this method supplies an iterator over a client's providers, locking each in turn with @link lockForArbitration lockForArbitration@/link and returning those that have been opened by the client. 
    @result An iterator over the providers the client has open, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, and the current entry in the iteration is locked with &lt;code&gt;lockForArbitration&lt;/code&gt;, protecting it from state changes. */</span>

    virtual OSIterator * getOpenProviderIterator( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getClient
    @abstract Returns an IOService object's primary client.
    @discussion This function called in an IOService provider will return the first client to attach to it. For IOService objects which have only only one client, this may be a useful simplification.
    @result The first client of the provider, or zero if the IOService object is not attached into the I/O Registry. The client is retained while it is attached, and should not be released by the caller. */</span>

    virtual IOService * getClient( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getClientIterator
    @abstract Returns an iterator over an IOService object's clients.
    @discussion For IOService objects that may have multiple clients, this method supplies an iterator over a provider's clients. 
    @result An iterator over the clients of the provider, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, though they may no longer be attached during the iteration. */</span>

    virtual OSIterator * getClientIterator( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getOpenClientIterator
    @abstract Returns an iterator over a provider's clients that currently have opened the provider.
    @discussion For IOService objects that may have multiple clients, this method supplies an iterator over a provider's clients, locking each in turn with @link lockForArbitration lockForArbitration@/link and returning those that have opened the provider. 
    @result An iterator over the clients that have opened the provider, or zero if there is a resource failure. The iterator must be released when the iteration is finished. All objects returned by the iteration are retained while the iterator is valid, and the current entry in the iteration is locked with &lt;code&gt;lockForArbitration&lt;/code&gt;, protecting it from state changes. */</span>

    virtual OSIterator * getOpenClientIterator( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function callPlatformFunction
    @abstract Calls the platform function with the given name.
    @discussion The platform expert or other drivers may implement various functions to control hardware features.  &lt;code&gt;callPlatformFunction&lt;/code&gt; allows any IOService object to access these functions. Normally &lt;code&gt;callPlatformFunction&lt;/code&gt; is called on a service's provider. The provider services the request or passes it to its provider. The system's IOPlatformExpert subclass catches functions it knows about and redirects them into other parts of the service plane. If the IOPlatformExpert subclass cannot execute the function, the base class is called. The IOPlatformExpert base class attempts to find a service to execute the function by looking up the function name in an IOResources name space. A service may publish a service using &lt;code&gt;publishResource(functionName, this)&lt;/code&gt;. If no service can be found to execute the function an error is returned.
    @param functionName Name of the function to be called. When &lt;code&gt;functionName&lt;/code&gt; is a C string, &lt;code&gt;callPlatformFunction&lt;/code&gt; converts the C string to an OSSymbol and calls the OSSymbol version of &lt;code&gt;callPlatformFunction&lt;/code&gt;. This process can block and should not be used from an interrupt context.
    @param waitForFunction If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;callPlatformFunction&lt;/code&gt; will not return until the function has been called.
    @result An IOReturn code; &lt;code&gt;kIOReturnSuccess&lt;/code&gt; if the function was successfully executed, &lt;code&gt;kIOReturnUnsupported&lt;/code&gt; if a service to execute the function could not be found. Other return codes may be returned by the function.*/</span>

    virtual IOReturn callPlatformFunction( <span class="enscript-type">const</span> OSSymbol * functionName,
                                           bool waitForFunction,
                                           <span class="enscript-type">void</span> *param1, <span class="enscript-type">void</span> *param2,
                                           <span class="enscript-type">void</span> *param3, <span class="enscript-type">void</span> *param4 );

    virtual IOReturn callPlatformFunction( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * functionName,
                                           bool waitForFunction,
                                           <span class="enscript-type">void</span> *param1, <span class="enscript-type">void</span> *param2,
                                           <span class="enscript-type">void</span> *param3, <span class="enscript-type">void</span> *param4 );


    <span class="enscript-comment">/* Some accessors */</span>

<span class="enscript-comment">/*! @function getPlatform
    @abstract Returns a pointer to the platform expert instance for the computer.
    @discussion This method provides an accessor to the platform expert instance for the computer. 
    @result A pointer to the IOPlatformExpert instance. It should not be released by the caller. */</span>

    <span class="enscript-type">static</span> IOPlatformExpert * getPlatform( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function getPMRootDomain
    @abstract Returns a pointer to the power management root domain instance for the computer.
    @discussion This method provides an accessor to the power management root domain instance for the computer. 
    @result A pointer to the power management root domain instance. It should not be released by the caller. */</span>

    <span class="enscript-type">static</span> class IOPMrootDomain * getPMRootDomain( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function getServiceRoot
    @abstract Returns a pointer to the root of the service plane.
    @discussion This method provides an accessor to the root of the service plane for the computer. 
    @result A pointer to the IOService instance at the root of the service plane. It should not be released by the caller. */</span>

    <span class="enscript-type">static</span> IOService * getServiceRoot( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function getResourceService
    @abstract Returns a pointer to the IOResources service.
    @discussion IOService maintains a resource service IOResources that allows objects to be published and found globally in the I/O Kit based on a name, using the standard IOService matching and notification calls.
    @result A pointer to the IOResources instance. It should not be released by the caller. */</span>

    <span class="enscript-type">static</span> IOService * getResourceService( <span class="enscript-type">void</span> );

    <span class="enscript-comment">/* Allocate resources for a matched service */</span>

<span class="enscript-comment">/*! @function getResources
    @abstract Allocates any needed resources for a published IOService object before clients attach.
    @discussion This method is called during the registration process for an IOService object if there are successful driver matches, before any clients attach. It allows for lazy allocation of resources to an IOService object when a matching driver is found.
    @result An IOReturn code; &lt;code&gt;kIOReturnSuccess&lt;/code&gt; is necessary for the IOService object to be successfully used, otherwise the registration process for the object is halted. */</span>
    
    virtual IOReturn getResources( <span class="enscript-type">void</span> );

    <span class="enscript-comment">/* Device memory accessors */</span>

<span class="enscript-comment">/*! @function getDeviceMemoryCount
    @abstract Returns a count of the physical memory ranges available for a device.
    @discussion This method returns the count of physical memory ranges, each represented by an IODeviceMemory instance, that have been allocated for a memory mapped device.
    @result An integer count of the number of ranges available. */</span>

    virtual IOItemCount getDeviceMemoryCount( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function getDeviceMemoryWithIndex
    @abstract Returns an instance of IODeviceMemory representing one of a device's memory mapped ranges.
    @discussion This method returns a pointer to an instance of IODeviceMemory for the physical memory range at the given index for a memory mapped device.
    @param index An index into the array of ranges assigned to the device.
    @result A pointer to an instance of IODeviceMemory, or zero if the index is beyond the count available. The IODeviceMemory is retained by the provider, so is valid while attached, or while any mappings to it exist. It should not be released by the caller. See also @link mapDeviceMemoryWithIndex mapDeviceMemoryWithIndex@/link, which creates a device memory mapping. */</span>

    virtual IODeviceMemory * getDeviceMemoryWithIndex( <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index );

<span class="enscript-comment">/*! @function mapDeviceMemoryWithIndex
    @abstract Maps a physical range of a device.
    @discussion This method creates a mapping for the IODeviceMemory at the given index, with &lt;code&gt;IODeviceMemory::map(options)&lt;/code&gt;. The mapping is represented by the returned instance of IOMemoryMap, which should not be released until the mapping is no longer required.
    @param index An index into the array of ranges assigned to the device.
    @result An instance of IOMemoryMap, or zero if the index is beyond the count available. The mapping should be released only when access to it is no longer required. */</span>

    virtual IOMemoryMap * mapDeviceMemoryWithIndex( <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index,
                                                    IOOptionBits options = 0 );

<span class="enscript-comment">/*! @function getDeviceMemory
    @abstract Returns the array of IODeviceMemory objects representing a device's memory mapped ranges.
    @discussion This method returns an array of IODeviceMemory objects representing the physical memory ranges allocated to a memory mapped device.
    @result An OSArray of IODeviceMemory objects, or zero if none are available. The array is retained by the provider, so is valid while attached. */</span>

    virtual OSArray * getDeviceMemory( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function setDeviceMemory
    @abstract Sets the array of IODeviceMemory objects representing a device's memory mapped ranges.
    @discussion This method sets an array of IODeviceMemory objects representing the physical memory ranges allocated to a memory mapped device.
    @param array An OSArray of IODeviceMemory objects, or zero if none are available. The array will be retained by the object. */</span>

    virtual <span class="enscript-type">void</span> setDeviceMemory( OSArray * array );

    <span class="enscript-comment">/* Interrupt accessors */</span>

<span class="enscript-comment">/*! @function registerInterrupt
    @abstract Registers a C function interrupt handler for a device supplying interrupts.
    @discussion This method installs a C function interrupt handler to be called at primary interrupt time for a device's interrupt. Only one handler may be installed per interrupt source. IOInterruptEventSource provides a work loop based abstraction for interrupt delivery that may be more appropriate for work loop based drivers.
    @param source The index of the interrupt source in the device.
    @param target An object instance to be passed to the interrupt handler.
    @param handler The C function to be called at primary interrupt time when the interrupt occurs. The handler should process the interrupt by clearing the interrupt, or by disabling the source.
    @param refCon A reference constant for the handler's use.
    @result An IOReturn code.&lt;br&gt;&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid; &lt;code&gt;kIOReturnNoResources&lt;/code&gt; is returned if the interrupt already has an installed handler. */</span>

    virtual IOReturn registerInterrupt(<span class="enscript-type">int</span> source, OSObject *target,
                                       IOInterruptAction handler,
                                       <span class="enscript-type">void</span> *refCon = 0);
                                       
<span class="enscript-comment">/*! @function unregisterInterrupt
    @abstract Removes a C function interrupt handler for a device supplying hardware interrupts.
    @discussion This method removes a C function interrupt handler previously installed with @link registerInterrupt registerInterrupt@/link.
    @param source The index of the interrupt source in the device.
    @result An IOReturn code (&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid). */</span>

    virtual IOReturn unregisterInterrupt(<span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function addInterruptStatistics
    @abstract Adds a statistics object to the IOService for the given interrupt.
    @discussion This method associates a set of statistics and a reporter for those statistics with an interrupt for this IOService, so that we can interrogate the IOService for statistics pertaining to that interrupt.
    @param statistics The IOInterruptAccountingData container we wish to associate the IOService with.
    @param source The index of the interrupt source in the device. */</span>
    IOReturn addInterruptStatistics(IOInterruptAccountingData * statistics, <span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function removeInterruptStatistics
    @abstract Removes any statistics from the IOService for the given interrupt.
    @discussion This method disassociates any IOInterruptAccountingData container we may have for the given interrupt from the IOService; this indicates that the the interrupt target (at the moment, likely an IOInterruptEventSource) is being destroyed.
    @param source The index of the interrupt source in the device. */</span>
    IOReturn removeInterruptStatistics(<span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function getInterruptType
    @abstract Returns the type of interrupt used for a device supplying hardware interrupts.
    @param source The index of the interrupt source in the device.
    @param interruptType The interrupt type for the interrupt source will be stored here by &lt;code&gt;getInterruptType&lt;/code&gt;.&lt;br&gt; &lt;code&gt;kIOInterruptTypeEdge&lt;/code&gt; will be returned for edge-trigggered sources.&lt;br&gt;&lt;code&gt;kIOInterruptTypeLevel&lt;/code&gt; will be returned for level-trigggered sources.
    @result An IOReturn code (&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid). */</span>

    virtual IOReturn getInterruptType(<span class="enscript-type">int</span> source, <span class="enscript-type">int</span> *interruptType);

<span class="enscript-comment">/*! @function enableInterrupt
    @abstract Enables a device interrupt.
    @discussion It is the caller's responsiblity to keep track of the enable state of the interrupt source.
    @param source The index of the interrupt source in the device.
    @result An IOReturn code (&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid). */</span>

    virtual IOReturn enableInterrupt(<span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function disableInterrupt
    @abstract Synchronously disables a device interrupt.
    @discussion If the interrupt routine is running, the call will block until the routine completes. It is the caller's responsiblity to keep track of the enable state of the interrupt source.
    @param source The index of the interrupt source in the device.
    @result An IOReturn code (&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid). */</span>

    virtual IOReturn disableInterrupt(<span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function causeInterrupt
    @abstract Causes a device interrupt to occur.
    @discussion Emulates a hardware interrupt, to be called from task level.
    @param source The index of the interrupt source in the device.
    @result An IOReturn code (&lt;code&gt;kIOReturnNoInterrupt&lt;/code&gt; is returned if the source is not valid). */</span>

    virtual IOReturn causeInterrupt(<span class="enscript-type">int</span> source);

<span class="enscript-comment">/*! @function requestProbe
    @abstract Requests that hardware be re-scanned for devices.
    @discussion For bus families that do not usually detect device addition or removal, this method represents an external request (eg. from a utility application) to rescan and publish or remove found devices.
    @param options Family defined options, not interpreted by IOService.
    @result An IOReturn code. */</span>

    virtual IOReturn requestProbe( IOOptionBits options );

    <span class="enscript-comment">/* Generic API for non-data-path upstream calls */</span>

<span class="enscript-comment">/*! @function message
    @abstract Receives a generic message delivered from an attached provider.
    @discussion A provider may deliver messages via the &lt;code&gt;message&lt;/code&gt; method to its clients informing them of state changes, such as &lt;code&gt;kIOMessageServiceIsTerminated&lt;/code&gt; or &lt;code&gt;kIOMessageServiceIsSuspended&lt;/code&gt;. Certain messages are defined by the I/O Kit in &lt;code&gt;IOMessage.h&lt;/code&gt; while others may be family dependent. This method is implemented in the client to receive messages.
    @param type A type defined in &lt;code&gt;IOMessage.h&lt;/code&gt; or defined by the provider family.
    @param provider The provider from which the message originates.
    @param argument An argument defined by the provider family, not used by IOService.
    @result An IOReturn code defined by the message type. */</span>

    virtual IOReturn message( UInt32 type, IOService * provider,
                              <span class="enscript-type">void</span> * argument = 0 );
                                
<span class="enscript-comment">/*! @function messageClient
    @abstract Sends a generic message to an attached client.
    @discussion A provider may deliver messages via the @link message message@/link method to its clients informing them of state changes, such as &lt;code&gt;kIOMessageServiceIsTerminated&lt;/code&gt; or &lt;code&gt;kIOMessageServiceIsSuspended&lt;/code&gt;. Certain messages are defined by the I/O Kit in &lt;code&gt;IOMessage.h&lt;/code&gt; while others may be family dependent. This method may be called in the provider to send a message to the specified client, which may be useful for overrides.
    @param messageType A type defined in &lt;code&gt;IOMessage.h&lt;/code&gt; or defined by the provider family.
    @param client A client of the IOService to send the message.
    @param messageArgument An argument defined by the provider family, not used by IOService.
    @param argSize Specifies the size of messageArgument, in bytes.  If argSize is non-zero, messageArgument is treated as a pointer to argSize bytes of data.  If argSize is 0 (the default), messageArgument is treated as an ordinal and passed by value.
    @result The return code from the client message call. */</span>
    
    virtual IOReturn messageClient( UInt32 messageType, OSObject * client,
                                    <span class="enscript-type">void</span> * messageArgument = 0, vm_size_t argSize = 0 );

<span class="enscript-comment">/*! @function messageClients
    @abstract Sends a generic message to all attached clients.
    @discussion A provider may deliver messages via the @link message message@/link method to its clients informing them of state changes, such as &lt;code&gt;kIOMessageServiceIsTerminated&lt;/code&gt; or &lt;code&gt;kIOMessageServiceIsSuspended&lt;/code&gt;. Certain messages are defined by the I/O Kit in &lt;code&gt;IOMessage.h&lt;/code&gt; while others may be family dependent. This method may be called in the provider to send a message to all the attached clients, via the @link messageClient messageClient@/link method.
    @param type A type defined in &lt;code&gt;IOMessage.h&lt;/code&gt; or defined by the provider family.
    @param argument An argument defined by the provider family, not used by IOService.
    @param argSize Specifies the size of argument, in bytes.  If argSize is non-zero, argument is treated as a pointer to argSize bytes of data.  If argSize is 0 (the default), argument is treated as an ordinal and passed by value.
    @result Any non-&lt;code&gt;kIOReturnSuccess&lt;/code&gt; return codes returned by the clients, or &lt;code&gt;kIOReturnSuccess&lt;/code&gt; if all return &lt;code&gt;kIOReturnSuccess&lt;/code&gt;. */</span>

    virtual IOReturn messageClients( UInt32 type,
                                     <span class="enscript-type">void</span> * argument = 0, vm_size_t argSize = 0 );

    virtual IONotifier * registerInterest( <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                                           IOServiceInterestHandler handler,
                                           <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref = 0 );

    virtual <span class="enscript-type">void</span> applyToProviders( IOServiceApplierFunction applier,
                                   <span class="enscript-type">void</span> * context );

    virtual <span class="enscript-type">void</span> applyToClients( IOServiceApplierFunction applier,
                                 <span class="enscript-type">void</span> * context );

    virtual <span class="enscript-type">void</span> applyToInterested( <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                                    OSObjectApplierFunction applier,
                                    <span class="enscript-type">void</span> * context );

    virtual IOReturn acknowledgeNotification( IONotificationRef notification,
                                              IOOptionBits response );

    <span class="enscript-comment">/* User client create */</span>

<span class="enscript-comment">/*! @function newUserClient
    @abstract Creates a connection for a non kernel client.
    @discussion A non kernel client may request a connection be opened via the @link //apple_ref/c/func/IOServiceOpen IOServiceOpen@/link library function, which will call this method in an IOService object. The rules and capabilities of user level clients are family dependent, and use the functions of the IOUserClient class for support. IOService's implementation returns &lt;code&gt;kIOReturnUnsupported&lt;/code&gt;, so any family supporting user clients must implement this method.
    @param owningTask The Mach task of the client thread in the process of opening the user client. Note that in Mac OS X, each process is based on a Mach task and one or more Mach threads. For more information on the composition of a Mach task and its relationship with Mach threads, see {@linkdoc //apple_ref/doc/uid/TP30000905-CH209-TPXREF103 &quot;Tasks and Threads&quot;}.
    @param securityID A token representing the access level for the task.
    @param type A constant specifying the type of connection to be created, specified by the caller of @link //apple_ref/c/func/IOServiceOpen IOServiceOpen@/link and interpreted only by the family.
    @param handler An instance of an IOUserClient object to represent the connection, which will be released when the connection is closed, or zero if the connection was not opened.    
    @param properties A dictionary of additional properties for the connection.
    @result A return code to be passed back to the caller of &lt;code&gt;IOServiceOpen&lt;/code&gt;. */</span>

    virtual IOReturn newUserClient( task_t owningTask, <span class="enscript-type">void</span> * securityID,
                                    UInt32 type, OSDictionary * properties,
                                    IOUserClient ** handler );

    virtual IOReturn newUserClient( task_t owningTask, <span class="enscript-type">void</span> * securityID,
                                    UInt32 type, IOUserClient ** handler );

    <span class="enscript-comment">/* Return code utilities */</span>

<span class="enscript-comment">/*! @function stringFromReturn
    @abstract Supplies a programmer-friendly string from an IOReturn code.
    @discussion Strings are available for the standard return codes in &lt;code&gt;IOReturn.h&lt;/code&gt; in IOService, while subclasses may implement this method to interpret family dependent return codes.
    @param rtn The IOReturn code.
    @result A pointer to a constant string, or zero if the return code is unknown. */</span>
    
    virtual <span class="enscript-type">const</span> <span class="enscript-type">char</span> * stringFromReturn( IOReturn rtn );

<span class="enscript-comment">/*! @function errnoFromReturn
    @abstract Translates an IOReturn code to a BSD &lt;code&gt;errno&lt;/code&gt;.
    @discussion BSD defines its own return codes for its functions in &lt;code&gt;sys/errno.h&lt;/code&gt;, and I/O Kit families may need to supply compliant results in BSD shims. Results are available for the standard return codes in &lt;code&gt;IOReturn.h&lt;/code&gt; in IOService, while subclasses may implement this method to interpret family dependent return codes.
    @param rtn The IOReturn code.
    @result The BSD &lt;code&gt;errno&lt;/code&gt; or &lt;code&gt;EIO&lt;/code&gt; if unknown. */</span>
    
    virtual <span class="enscript-type">int</span> errnoFromReturn( IOReturn rtn );

    <span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
    <span class="enscript-comment">/* * * * * * * * * * end of IOService API  * * * * * * * */</span>
    <span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

    <span class="enscript-comment">/* for IOInterruptController implementors */</span>

    <span class="enscript-type">int</span>               _numInterruptSources;
    IOInterruptSource *_interruptSources;

    <span class="enscript-comment">/* overrides */</span>
    virtual bool serializeProperties( OSSerialize * s ) <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
    <span class="enscript-comment">/* Apple only SPI to control CPU low power modes */</span>
    <span class="enscript-type">void</span>   setCPUSnoopDelay(UInt32 ns);
    UInt32 getCPUSnoopDelay();
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">void</span>   requireMaxBusStall(UInt32 ns);
    <span class="enscript-type">void</span>   requireMaxInterruptDelay(uint32_t ns);

    <span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
    <span class="enscript-comment">/* * * * * * * * * * * * Internals * * * * * * * * * * * */</span>
    <span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
<span class="enscript-reference">public</span>:
    <span class="enscript-comment">// called from other xnu components
</span>    <span class="enscript-type">static</span> <span class="enscript-type">void</span> initialize( <span class="enscript-type">void</span> );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> setPlatform( IOPlatformExpert * platform);
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> setPMRootDomain( class IOPMrootDomain * rootDomain );
    <span class="enscript-type">static</span> IOReturn catalogNewDrivers( OSOrderedSet * newTables );
    uint64_t getAccumulatedBusyTime( <span class="enscript-type">void</span> );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> updateConsoleUsers(OSArray * consoleUsers, IOMessage systemMessage);
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> consoleLockTimer(thread_call_param_t p0, thread_call_param_t p1);
    <span class="enscript-type">void</span> setTerminateDefer(IOService * provider, bool defer);
    uint64_t getAuthorizationID( <span class="enscript-type">void</span> );
    IOReturn setAuthorizationID( uint64_t authorizationID );
    <span class="enscript-type">void</span> cpusRunning(<span class="enscript-type">void</span>);

<span class="enscript-reference">private</span>:
    <span class="enscript-type">static</span> IOReturn waitMatchIdle( UInt32 ms );
    <span class="enscript-type">static</span> IONotifier * installNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceMatchingNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                            SInt32 priority, OSIterator ** existing );
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
    <span class="enscript-type">static</span> IONotifier * installNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                            SInt32 priority, OSIterator ** existing);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__LP64__) */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">private</span>:
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        bool checkResources( <span class="enscript-type">void</span> );
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        bool checkResource( OSObject * matching );

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        <span class="enscript-type">void</span> probeCandidates( OSOrderedSet * matches );
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        bool startCandidate( IOService * candidate );

<span class="enscript-reference">public</span>:
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        IOService * getClientWithCategory( <span class="enscript-type">const</span> OSSymbol * category )
    APPLE_KEXT_DEPRECATED;
        <span class="enscript-comment">// copyClientWithCategory is the public replacement
</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-comment">/* Callable within xnu source only - but require vtable entries to be visible */</span>
<span class="enscript-reference">public</span>:
#<span class="enscript-reference">else</span>
<span class="enscript-reference">private</span>:
#<span class="enscript-reference">endif</span>
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    bool passiveMatch( OSDictionary * matching, bool changesOK = false);
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">void</span> startMatching( IOOptionBits options = 0 );
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">void</span> doServiceMatch( IOOptionBits options );
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">void</span> doServiceTerminate( IOOptionBits options );

<span class="enscript-reference">private</span>:

    bool matchPassive(OSDictionary * table, uint32_t options);
    bool matchInternal(OSDictionary * table, uint32_t options, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * did);
    <span class="enscript-type">static</span> bool instanceMatch(<span class="enscript-type">const</span> OSObject * entry, <span class="enscript-type">void</span> * context);

    <span class="enscript-type">static</span> OSObject * copyExistingServices( OSDictionary * matching,
                                            IOOptionBits inState, IOOptionBits options = 0 );

    <span class="enscript-type">static</span> IONotifier * setNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceMatchingNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                            SInt32 priority = 0 );

    <span class="enscript-type">static</span> IONotifier * doInstallNotification(
                            <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
                            IOServiceMatchingNotificationHandler handler,
                            <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                            SInt32 priority, OSIterator ** existing );

    <span class="enscript-type">static</span> bool syncNotificationHandler( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                            IOService * newService, IONotifier * notifier  );

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">void</span> deliverNotification( <span class="enscript-type">const</span> OSSymbol * type,
                              IOOptionBits orNewState, IOOptionBits andNewState );

    bool invokeNotifer( class _IOServiceNotifier * notify );

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        <span class="enscript-type">void</span> unregisterAllInterest( <span class="enscript-type">void</span> );

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        IOReturn waitForState( UInt32 mask, UInt32 value,
                               mach_timespec_t * timeout = 0 );

    IOReturn waitForState( UInt32 mask, UInt32 value, uint64_t timeout );

    UInt32 _adjustBusy( SInt32 delta );

    bool terminatePhase1( IOOptionBits options = 0 );
    <span class="enscript-type">void</span> scheduleTerminatePhase2( IOOptionBits options = 0 );
    <span class="enscript-type">void</span> scheduleStop( IOService * provider );
    <span class="enscript-type">void</span> scheduleFinalize( <span class="enscript-type">void</span> );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> terminateThread( <span class="enscript-type">void</span> * arg, wait_result_t unused );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> terminateWorker( IOOptionBits options );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionWillTerminate( IOService * victim, IOOptionBits options, 
                                     OSArray * doPhase2List, <span class="enscript-type">void</span>*, <span class="enscript-type">void</span> * );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionDidTerminate( IOService * victim, IOOptionBits options,
                                    <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionWillStop( IOService * victim, IOOptionBits options, 
				<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionDidStop( IOService * victim, IOOptionBits options,
				<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionFinalize( IOService * victim, IOOptionBits options,
                                <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> actionStop( IOService * client, IOService * provider,
                            <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        IOReturn resolveInterrupt(IOService *nub, <span class="enscript-type">int</span> source);
    APPLE_KEXT_COMPATIBILITY_VIRTUAL
        IOReturn lookupInterrupt(<span class="enscript-type">int</span> source, bool resolve, IOInterruptController **interruptController);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-comment">/* end xnu internals */</span>
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">/* power management */</span>
<span class="enscript-reference">public</span>:

<span class="enscript-comment">/*! @function PMinit
    @abstract Initializes power management for a driver.
    @discussion &lt;code&gt;PMinit&lt;/code&gt; allocates and initializes the power management instance variables, and it should be called before accessing those variables or calling the power management methods. This method should be called inside the driver's &lt;code&gt;start&lt;/code&gt; routine and must be paired with a call to @link PMstop PMstop@/link.
    Most calls to &lt;code&gt;PMinit&lt;/code&gt; are followed by calls to @link joinPMtree joinPMtree@/link and @link registerPowerDriver registerPowerDriver@/link. */</span>

    virtual <span class="enscript-type">void</span> PMinit( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function PMstop
    @abstract Stop power managing the driver.
    @discussion Removes the driver from the power plane and stop its power management. This method is synchronous against any power management method invocations (e.g. &lt;code&gt;setPowerState&lt;/code&gt; or &lt;code&gt;setAggressiveness&lt;/code&gt;), so when this method returns it is guaranteed those power management methods will not be entered. Driver should not call any power management methods after this call.
    Calling &lt;code&gt;PMstop&lt;/code&gt; cleans up for the three power management initialization calls: @link PMinit PMinit@/link, @link joinPMtree joinPMtree@/link, and @link registerPowerDriver registerPowerDriver@/link. */</span>

    virtual <span class="enscript-type">void</span> PMstop( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function joinPMtree
    @abstract Joins the driver into the power plane of the I/O Registry.
    @discussion A driver uses this method to call its nub when initializing (usually in its &lt;code&gt;start&lt;/code&gt; routine after calling @link PMinit PMinit@/link), to be attached into the power management hierarchy (i.e., the power plane). A driver usually calls this method on the driver for the device that provides it power (this is frequently the nub).    
    Before this call returns, the caller will probably be called at @link setPowerParent setPowerParent@/link and @link setAggressiveness setAggressiveness@/link and possibly at @link addPowerChild addPowerChild@/link as it is added to the hierarchy. This method may be overridden by a nub subclass.
    @param driver The driver to be added to the power plane, usually &lt;code&gt;this&lt;/code&gt;. */</span>

    virtual <span class="enscript-type">void</span> joinPMtree( IOService * driver );

<span class="enscript-comment">/*! @function registerPowerDriver
    @abstract Registers a set of power states that the driver supports.
    @discussion A driver defines its array of supported power states with power management in its power management initialization (its &lt;code&gt;start&lt;/code&gt; routine). If successful, power management will call the driver to instruct it to change its power state through @link setPowerState setPowerState@/link.
    Most drivers do not need to override &lt;code&gt;registerPowerDriver&lt;/code&gt;. A nub may override &lt;code&gt;registerPowerDriver&lt;/code&gt; if it needs to arrange its children in the power plane differently than the default placement, but this is uncommon.
    @param controllingDriver A pointer to the calling driver, usually &lt;code&gt;this&lt;/code&gt;.
    @param powerStates A driver-defined array of power states that the driver and device support. Power states are defined in &lt;code&gt;pwr_mgt/IOPMpowerState.h&lt;/code&gt;.
    @param numberOfStates The number of power states in the array.
    @result &lt;/code&gt;IOPMNoErr&lt;/code&gt;. All errors are logged via &lt;code&gt;kprintf&lt;/code&gt;. */</span>

    virtual IOReturn registerPowerDriver(
                        IOService *      controllingDriver,
                        IOPMPowerState * powerStates,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>    numberOfStates );

<span class="enscript-comment">/*! @function registerInterestedDriver
    @abstract Allows an IOService object to register interest in the changing power state of a power-managed IOService object.
    @discussion Call &lt;code&gt;registerInterestedDriver&lt;/code&gt; on the IOService object you are interested in receiving power state messages from, and pass a pointer to the interested driver (&lt;code&gt;this&lt;/code&gt;) as an argument.
    The interested driver is retained until the power interest is removed by calling &lt;code&gt;deRegisterInterestedDriver&lt;/code&gt;.
    The interested driver should override @link powerStateWillChangeTo powerStateWillChangeTo@/link and @link powerStateDidChangeTo powerStateDidChangeTo@/link to receive these power change messages.
    Interested drivers must acknowledge power changes in &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; or &lt;code&gt;powerStateDidChangeTo&lt;/code&gt;, either via return value or later calls to @link acknowledgePowerChange acknowledgePowerChange@/link.
    @param theDriver The driver of interest adds this pointer to the list of interested drivers. It informs drivers on this list before and after the power change.
    @result Flags describing the capability of the device in its current power state. If the current power state is not yet defined, zero is returned (this is the case when the driver is not yet in the power domain hierarchy or hasn't fully registered with power management yet). */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOPMPowerFlags registerInterestedDriver( IOService * theDriver );

<span class="enscript-comment">/*! @function deRegisterInterestedDriver
    @abstract De-registers power state interest from a previous call to &lt;code&gt;registerInterestedDriver&lt;/code&gt;.
    @discussion The retain from &lt;code&gt;registerInterestedDriver&lt;/code&gt; is released. This method is synchronous against any &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; or &lt;code&gt;powerStateDidChangeTo&lt;/code&gt; call targeting the interested driver, so when this method returns it is guaranteed those interest handlers will not be entered.
    Most drivers do not need to override &lt;code&gt;deRegisterInterestedDriver&lt;/code&gt;.
    @param theDriver The interested driver previously passed into @link registerInterestedDriver registerInterestedDriver@/link.
    @result A return code that can be ignored by the caller. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn deRegisterInterestedDriver( IOService * theDriver );

<span class="enscript-comment">/*! @function acknowledgePowerChange
    @abstract Acknowledges an in-progress power state change.
    @discussion When power management informs an interested object (via @link powerStateWillChangeTo powerStateWillChangeTo@/link or @link powerStateDidChangeTo powerStateDidChangeTo@/link), the object can return an immediate acknowledgement via a return code, or it may return an indication that it will acknowledge later by calling &lt;code&gt;acknowledgePowerChange&lt;/code&gt;.
    Interested objects are those that have registered as interested drivers, as well as power plane children of the power changing driver. A driver that calls @link registerInterestedDriver registerInterestedDriver@/link must call &lt;code&gt;acknowledgePowerChange&lt;/code&gt;, or use an immediate acknowledgement return from &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; or &lt;code&gt;powerStateDidChangeTo&lt;/code&gt;.
    @param whichDriver A pointer to the calling driver. The called object tracks all interested parties to ensure that all have acknowledged the power state change.
    @result &lt;code&gt;IOPMNoErr&lt;/code&gt;. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn acknowledgePowerChange( IOService * whichDriver );

<span class="enscript-comment">/*! @function acknowledgeSetPowerState
    @abstract Acknowledges the belated completion of a driver's &lt;code&gt;setPowerState&lt;/code&gt; power state change.
    @discussion After power management instructs a driver to change its state via @link setPowerState setPowerState@/link, that driver must acknowledge the change when its device has completed its transition. The acknowledgement may be immediate, via a return code from &lt;code&gt;setPowerState&lt;/code&gt;, or delayed, via this call to &lt;code&gt;acknowledgeSetPowerState&lt;/code&gt;.
    Any driver that does not return &lt;code&gt;kIOPMAckImplied&lt;/code&gt; from its &lt;code&gt;setPowerState&lt;/code&gt; implementation must later call &lt;code&gt;acknowledgeSetPowerState&lt;/code&gt;.
    @result &lt;code&gt;IOPMNoErr&lt;/code&gt;. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn acknowledgeSetPowerState( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function requestPowerDomainState
    @abstract Tells a driver to adjust its power state.
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual IOReturn requestPowerDomainState(
                        IOPMPowerFlags desiredState,
                        IOPowerConnection * whichChild,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> specificationFlags );

<span class="enscript-comment">/*! @function makeUsable
    @abstract Requests that a device become usable.
    @discussion This method is called when some client of a device (or the device's own driver) is asking for the device to become usable. Power management responds by telling the object upon which this method is called to change to its highest power state.
    &lt;code&gt;makeUsable&lt;/code&gt; is implemented using @link changePowerStateToPriv changePowerStateToPriv@/link. Subsequent requests for lower power, such as from &lt;code&gt;changePowerStateToPriv&lt;/code&gt;, will pre-empt this request.
    @result A return code that can be ignored by the caller. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn makeUsable( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function temporaryPowerClampOn
    @abstract A driver calls this method to hold itself in the highest power state until it has children.
    @discussion Use &lt;code&gt;temporaryPowerClampOn&lt;/code&gt; to hold your driver in its highest power state while waiting for child devices to attach. After children have attached, the clamp is released and the device's power state is controlled by the children's requirements.
    @result A return code that can be ignored by the caller. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn temporaryPowerClampOn( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function changePowerStateTo
    @abstract Sets a driver's power state.
    @discussion This function is one of several that are used to set a driver's power state. In most circumstances, however, you should call @link changePowerStateToPriv changePowerStateToPriv@/link instead.
    Calls to &lt;code&gt;changePowerStateTo&lt;/code&gt;, &lt;code&gt;changePowerStateToPriv&lt;/code&gt;, and a driver's power children all affect the power state of a driver. For legacy design reasons, they have overlapping functionality. Although you should call &lt;code&gt;changePowerStateToPriv&lt;/code&gt; to change your device's power state, you might need to call &lt;code&gt;changePowerStateTo&lt;/code&gt; in the following circumstances:
    &lt;ul&gt;&lt;li&gt;If a driver will be using &lt;code&gt;changePowerStateToPriv&lt;/code&gt; to change its power state, it should call &lt;code&gt;changePowerStateTo(0)&lt;/code&gt; in its &lt;code&gt;start&lt;/code&gt; routine to eliminate the influence &lt;code&gt;changePowerStateTo&lt;/code&gt; has on power state calculations.
    &lt;li&gt;Call &lt;code&gt;changePowerStateTo&lt;/code&gt; in conjunction with @link setIdleTimerPeriod setIdleTimerPeriod@/link and @link activityTickle activityTickle@/link to idle a driver into a low power state. For a driver with 3 power states, for example, &lt;code&gt;changePowerStateTo(1)&lt;/code&gt; sets a minimum level of power state 1, such that the idle timer period may not set your device's power any lower than state 1.&lt;/ul&gt;
    @param ordinal The number of the desired power state in the power state array. 
    @result A return code that can be ignored by the caller. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOReturn changePowerStateTo( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal );

<span class="enscript-comment">/*! @function currentCapability
    @abstract Finds out the capability of a device's current power state.
    @result A copy of the &lt;code&gt;capabilityFlags&lt;/code&gt; field for the current power state in the power state array. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    IOPMPowerFlags currentCapability( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function currentPowerConsumption
    @abstract Finds out the current power consumption of a device.
    @discussion Most Mac OS X power managed drivers do not report their power consumption via the &lt;code&gt;staticPower&lt;/code&gt; field. Thus this call will not accurately reflect power consumption for most drivers.
    @result A copy of the &lt;code&gt;staticPower&lt;/code&gt; field for the current power state in the power state array. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> currentPowerConsumption( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function activityTickle
    @abstract Informs power management when a power-managed device is in use, so that power management can track when it is idle and adjust its power state accordingly.
    @discussion The &lt;code&gt;activityTickle&lt;/code&gt; method is provided for objects in the system (or for the driver itself) to tell a driver that its device is being used.
    The IOService superclass can manage idleness determination with a simple idle timer mechanism and this &lt;code&gt;activityTickle&lt;/code&gt; call. To start this up, the driver calls its superclass's &lt;code&gt;setIdleTimerPeriod&lt;/code&gt;. This starts a timer for the time interval specified in the call. When the timer expires, the superclass checks to see if there has been any activity since the last timer expiration. (It checks to see if &lt;code&gt;activityTickle&lt;/code&gt; has been called). If there has been activity, it restarts the timer, and this process continues. When the timer expires, and there has been no device activity, the superclass lowers the device power state to the next lower state. This can continue until the device is in state zero.
    After the device has been powered down by at least one power state, a subsequent call to &lt;code&gt;activityTickle&lt;/code&gt; causes the device to be switched to a higher state required for the activity.    
    If the driver is managing the idleness determination totally on its own, the value of the &lt;code&gt;type&lt;/code&gt; parameter should be &lt;code&gt;kIOPMSubclassPolicy&lt;/code&gt;, and the driver should override the &lt;code&gt;activityTickle&lt;/code&gt; method. The superclass IOService implementation of &lt;code&gt;activityTickle&lt;/code&gt; does nothing with the &lt;code&gt;kIOPMSubclassPolicy&lt;/code&gt; argument.
    @param type When &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;kIOPMSubclassPolicy&lt;/code&gt;, &lt;code&gt;activityTickle&lt;/code&gt; is not handled in IOService and should be intercepted by the subclass. When &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;kIOPMSuperclassPolicy1&lt;/code&gt;, an activity flag is set and the device state is checked. If the device has been powered down, it is powered up again.
    @param stateNumber When &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;kIOPMSuperclassPolicy1&lt;/code&gt;, &lt;code&gt;stateNumber&lt;/code&gt; contains the desired power state ordinal for the activity. If the device is in a lower state, the superclass will switch it to this state. This is for devices that can handle some accesses in lower power states; the device is powered up only as far as it needs to be for the activity.
    @result When &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;kIOPMSuperclassPolicy1&lt;/code&gt;, the superclass returns &lt;code&gt;true&lt;/code&gt; if the device is currently in the state specified by &lt;code&gt;stateNumber&lt;/code&gt;. If the device is in a lower state and must be powered up, the superclass returns &lt;code&gt;false&lt;/code&gt;; in this case the superclass will initiate a power change to power the device up. */</span>

    virtual bool activityTickle(
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNumber = 0 );

<span class="enscript-comment">/*! @function setAggressiveness
    @abstract Broadcasts an aggressiveness factor from the parent of a driver to the driver.
    @discussion Implement &lt;code&gt;setAggressiveness&lt;/code&gt; to receive a notification when an &quot;aggressiveness Aggressiveness factors are a loose set of power management variables that contain values for system sleep timeout, display sleep timeout, whether the system is on battery or AC, and other power management features. There are several aggressiveness factors that can be broadcast and a driver may take action on whichever factors apply to it.
    A driver that has joined the power plane via @link joinPMtree joinPMtree@/link will receive &lt;code&gt;setAgressiveness&lt;/code&gt; calls when aggressiveness factors change.
    A driver may override this call if it needs to do something with the new factor (such as change its idle timeout). If overridden, the driver must  call its superclass's &lt;code&gt;setAgressiveness&lt;/code&gt; method in its own &lt;code&gt;setAgressiveness&lt;/code&gt; implementation.
    Most drivers do not need to implement &lt;code&gt;setAgressiveness&lt;/code&gt;.
    @param type The aggressiveness factor type, such as &lt;code&gt;kPMMinutesToDim&lt;/code&gt;, &lt;code&gt;kPMMinutesToSpinDown&lt;/code&gt;, &lt;code&gt;kPMMinutesToSleep&lt;/code&gt;, and &lt;code&gt;kPMPowerSource&lt;/code&gt;. (Aggressiveness factors are defined in &lt;code&gt;pwr_mgt/IOPM.h&lt;/code&gt;.)
    @param newLevel The aggressiveness factor's new value.
    @result &lt;code&gt;IOPMNoErr&lt;/code&gt;. */</span>

    virtual IOReturn setAggressiveness(
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> newLevel );

<span class="enscript-comment">/*! @function getAggressiveness
    @abstract Returns the current aggressiveness value for the given type.
    @param type The aggressiveness factor to query.
    @param currentLevel Upon successful return, contains the value of aggressiveness factor &lt;code&gt;type&lt;/code&gt;.
    @result &lt;code&gt;kIOReturnSuccess&lt;/code&gt; upon success; an I/O Kit error code otherwise. */</span>

    virtual IOReturn getAggressiveness(
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> * currentLevel );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function systemWake
    @abstract Tells every driver in the power plane that the system is waking up.
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual IOReturn systemWake( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function temperatureCriticalForZone
    @abstract Alerts a driver to a critical temperature in some thermal zone.
    @discussion This call is unused by power management. It is not intended to be called or overridden. */</span>

    virtual IOReturn temperatureCriticalForZone( IOService * whichZone )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function youAreRoot
    @abstract Informs power management which IOService object is the power plane root.
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual IOReturn youAreRoot( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function setPowerParent
    @abstract This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual IOReturn setPowerParent(
                        IOPowerConnection * parent,
                        bool stateKnown,
                        IOPMPowerFlags currentState )
    APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*! @function addPowerChild
    @abstract Informs a driver that it has a new child.
    @discussion The Platform Expert uses this method to call a driver and introduce it to a new child. This call is handled internally by power management. It is not intended to be overridden or called by drivers.
    @param theChild A pointer to the child IOService object. */</span>

    virtual IOReturn addPowerChild( IOService * theChild );

<span class="enscript-comment">/*! @function removePowerChild
    @abstract Informs a power managed driver that one of its power plane childen is disappearing.
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual IOReturn removePowerChild( IOPowerConnection * theChild );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function command_received
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual <span class="enscript-type">void</span> command_received( <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * , <span class="enscript-type">void</span> * , <span class="enscript-type">void</span> * );
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @function start_PM_idle_timer
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    APPLE_KEXT_COMPATIBILITY_VIRTUAL
    <span class="enscript-type">void</span> start_PM_idle_timer( <span class="enscript-type">void</span> );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function PM_idle_timer_expiration
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual <span class="enscript-type">void</span> PM_idle_timer_expiration( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function PM_Clamp_Timer_Expired
    @discussion This call is handled internally by power management. It is not intended to be overridden or called by drivers. */</span>

    virtual <span class="enscript-type">void</span> PM_Clamp_Timer_Expired( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @function setIdleTimerPeriod
    @abstract Sets or changes the idle timer period.
    @discussion A driver using the idleness determination provided by IOService calls its superclass with this method to set or change the idle timer period. See @link activityTickle activityTickle@/link for a description of this type of idleness determination.
    @param period The desired idle timer period in seconds.
    @result &lt;code&gt;kIOReturnSuccess&lt;/code&gt; upon success; an I/O Kit error code otherwise. */</span>

    virtual IOReturn setIdleTimerPeriod( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function getPMworkloop
    @abstract Returns a pointer to the system-wide power management work loop.
    @availability Deprecated in Mac OS X version 10.6.
    @discussion Most drivers should create their own work loops to synchronize their code; drivers should not run arbitrary code on the power management work loop. */</span>

    virtual IOWorkLoop * getPMworkloop( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @function getPowerState
    @abstract Determines a device's power state.
    @discussion A device's &quot;current power state&quot; is updated at the end of each power state transition (e.g. transition from state 1 to state 0, or state 0 to state 2). This transition includes the time spent powering on or off any power plane children. Thus, if a child calls &lt;code&gt;getPowerState&lt;/code&gt; on its power parent during system wake from sleep, the call will return the index to the device's off state rather than its on state.
    @result The current power state's index into the device's power state array. */</span>

    UInt32 getPowerState( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function setPowerState
    @abstract Requests a power managed driver to change the power state of its device.
    @discussion A power managed driver must override &lt;code&gt;setPowerState&lt;/code&gt; to take part in system power management. After a driver is registered with power management, the system uses &lt;code&gt;setPowerState&lt;/code&gt; to power the device off and on for system sleep and wake.
    Calls to @link PMinit PMinit@/link and @link registerPowerDriver registerPowerDriver@/link enable power management to change a device's power state using &lt;code&gt;setPowerState&lt;/code&gt;. &lt;code&gt;setPowerState&lt;/code&gt; is called in a clean and separate thread context.
    @param powerStateOrdinal The number in the power state array of the state the driver is being instructed to switch to. 
    @param whatDevice A pointer to the power management object which registered to manage power for this device. In most cases, &lt;code&gt;whatDevice&lt;/code&gt; will be equal to your driver's own &lt;code&gt;this&lt;/code&gt; pointer.
    @result The driver must return &lt;code&gt;IOPMAckImplied&lt;/code&gt; if it has complied with the request when it returns. Otherwise if it has started the process of changing power state but not finished it, the driver should return a number of microseconds which is an upper limit of the time it will need to finish. Then, when it has completed the power switch, it should call @link acknowledgeSetPowerState acknowledgeSetPowerState@/link. */</span>

    virtual IOReturn setPowerState(
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> powerStateOrdinal,
                        IOService *   whatDevice );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function clampPowerOn
    @abstract Deprecated. Do not use. */</span>

    virtual <span class="enscript-type">void</span> clampPowerOn( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> duration );
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*! @function maxCapabilityForDomainState
    @abstract Determines a driver's highest power state possible for a given power domain state.
    @discussion This happens when the power domain is changing state and power management needs to determine which state the device is capable of in the new domain state.
    Most drivers do not need to implement this method, and can rely upon the default IOService implementation. The IOService implementation scans the power state array looking for the highest state whose &lt;code&gt;inputPowerRequirement&lt;/code&gt; field exactly matches the value of the &lt;code&gt;domainState&lt;/code&gt; parameter. If more intelligent determination is required, the driver itself should implement the method and override the superclass's implementation.
    @param domainState Flags that describe the character of &quot;domain power&quot;; they represent the &lt;code&gt;outputPowerCharacter&lt;/code&gt; field of a state in the power domain's power state array.
    @result A state number. */</span>

    virtual <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> maxCapabilityForDomainState( IOPMPowerFlags domainState );

<span class="enscript-comment">/*! @function initialPowerStateForDomainState
    @abstract Determines which power state a device is in, given the current power domain state.
    @discussion Power management calls this method once, when the driver is initializing power management.
    Most drivers do not need to implement this method, and can rely upon the default IOService implementation. The IOService implementation scans the power state array looking for the highest state whose &lt;code&gt;inputPowerRequirement&lt;/code&gt; field exactly matches the value of the &lt;code&gt;domainState&lt;/code&gt; parameter. If more intelligent determination is required, the power managed driver should implement the method and override the superclass's implementation.
    @param domainState Flags that describe the character of &quot;domain power&quot;; they represent the &lt;code&gt;outputPowerCharacter&lt;/code&gt; field of a state in the power domain's power state array.
    @result A state number. */</span>

    virtual <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> initialPowerStateForDomainState( IOPMPowerFlags domainState );

<span class="enscript-comment">/*! @function powerStateForDomainState
    @abstract Determines what power state the device would be in for a given power domain state.
    @discussion This call is unused by power management. Drivers should override &lt;code&gt;initialPowerStateForDomainState&lt;/code&gt; and/or &lt;code&gt;maxCapabilityForDomainState&lt;/code&gt; instead to change the default mapping of domain state to driver power state.
    @param domainState Flags that describe the character of &quot;domain power&quot;; they represent the &lt;code&gt;outputPowerCharacter&lt;/code&gt; field of a state in the power domain's power state array.
    @result A state number. */</span>

    virtual <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> powerStateForDomainState( IOPMPowerFlags domainState );

<span class="enscript-comment">/*! @function powerStateWillChangeTo
    @abstract Informs interested parties that a device is about to change its power state.
    @discussion Power management informs interested parties that a device is about to change to a different power state. Interested parties are those that have registered for this notification via @link registerInterestedDriver registerInterestedDriver@/link. If you have called &lt;code&gt;registerInterestedDriver&lt;/code&gt; on a power managed driver, you must implement &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; and @link powerStateDidChangeTo powerStateDidChangeTo@/link to receive the notifications.
    &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; is called in a clean and separate thread context. &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; is called before a power state transition takes place; &lt;code&gt;powerStateDidChangeTo&lt;/code&gt; is called after the transition has completed.
    @param capabilities Flags that describe the capability of the device in the new power state (they come from the &lt;code&gt;capabilityFlags&lt;/code&gt; field of the new state in the power state array).
    @param stateNumber The number of the state in the state array that the device is switching to.
    @param whatDevice A pointer to the driver that is changing. It can be used by a driver that is receiving power state change notifications for multiple devices to distinguish between them.
    @result The driver returns &lt;code&gt;IOPMAckImplied&lt;/code&gt; if it has prepared for the power change when it returns. If it has started preparing but not finished, it should return a number of microseconds which is an upper limit of the time it will need to finish preparing. Then, when it has completed its preparations, it should call @link acknowledgePowerChange acknowledgePowerChange@/link. */</span>

    virtual IOReturn powerStateWillChangeTo(
                        IOPMPowerFlags  capabilities,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   stateNumber,
                        IOService *     whatDevice );

<span class="enscript-comment">/*! @function powerStateDidChangeTo
    @abstract Informs interested parties that a device has changed to a different power state.
    @discussion Power management informs interested parties that a device has changed to a different power state. Interested parties are those that have registered for this notification via @link registerInterestedDriver registerInterestedDriver@/link. If you have called &lt;code&gt;registerInterestedDriver&lt;/code&gt; on a power managed driver, you must implemnt @link powerStateWillChangeTo powerStateWillChangeTo@/link and &lt;code&gt;powerStateDidChangeTo&lt;/code&gt; to receive the notifications.
    &lt;code&gt;powerStateDidChangeTo&lt;/code&gt; is called in a clean and separate thread context. &lt;code&gt;powerStateWillChangeTo&lt;/code&gt; is called before a power state transition takes place; &lt;code&gt;powerStateDidChangeTo&lt;/code&gt; is called after the transition has completed.
    @param capabilities Flags that describe the capability of the device in the new power state (they come from the &lt;code&gt;capabilityFlags&lt;/code&gt; field of the new state in the power state array).
    @param stateNumber The number of the state in the state array that the device is switching to.
    @param whatDevice A pointer to the driver that is changing. It can be used by a driver that is receiving power state change notifications for multiple devices to distinguish between them.
    @result The driver returns &lt;code&gt;IOPMAckImplied&lt;/code&gt; if it has prepared for the power change when it returns. If it has started preparing but not finished, it should return a number of microseconds which is an upper limit of the time it will need to finish preparing. Then, when it has completed its preparations, it should call @link acknowledgePowerChange acknowledgePowerChange@/link. */</span>

    virtual IOReturn powerStateDidChangeTo(
                        IOPMPowerFlags  capabilities,
                        <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   stateNumber,
                        IOService *     whatDevice );

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*! @function didYouWakeSystem
    @abstract Asks a driver if its device is the one that just woke the system from sleep.
    @availability Deprecated in Mac OS X version 10.6.
    @discussion Power management calls a power managed driver with this method to ask if its device is the one that just woke the system from sleep. If a device is capable of waking the system from sleep, its driver should implement &lt;code&gt;didYouWakeSystem&lt;/code&gt; and return &lt;code&gt;true&lt;/code&gt; if its device was responsible for waking the system.
    @result &lt;code&gt;true&lt;/code&gt; if the driver's device woke the system and &lt;code&gt;false&lt;/code&gt; otherwise. */</span>

    virtual bool didYouWakeSystem( <span class="enscript-type">void</span> )
    APPLE_KEXT_DEPRECATED;

<span class="enscript-comment">/*! @function newTemperature
    @abstract Tells a power managed driver that the temperature in the thermal zone has changed.
    @discussion This call is unused by power management. It is not intended to be called or overridden. */</span>

    virtual IOReturn newTemperature( <span class="enscript-type">long</span> currentTemp, IOService * whichZone )
    APPLE_KEXT_DEPRECATED;
#<span class="enscript-reference">endif</span>

    virtual bool askChangeDown( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    virtual bool tellChangeDown( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    virtual <span class="enscript-type">void</span> tellNoChangeDown ( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    virtual <span class="enscript-type">void</span> tellChangeUp( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    virtual IOReturn allowPowerChange( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon );
    virtual IOReturn cancelPowerChange( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon );

<span class="enscript-reference">protected</span>:
<span class="enscript-comment">/*! @function changePowerStateToPriv 
    @abstract Tells a driver's superclass to change the power state of its device.
    @discussion A driver uses this method to tell its superclass to change the power state of the device. This is the recommended way to change the power state of a device.
    Three things affect driver power state: @link changePowerStateTo changePowerStateTo@/link, &lt;code&gt;changePowerStateToPriv&lt;/code&gt;, and the desires of the driver's power plane children. Power management puts the device into the maximum state governed by those three entities.
    Drivers may eliminate the influence of the &lt;code&gt;changePowerStateTo&lt;/code&gt; method on power state one of two ways. See @link powerOverrideOnPriv powerOverrideOnPriv@/link to ignore the method's influence, or call &lt;code&gt;changePowerStateTo(0)&lt;/code&gt; in the driver's &lt;code&gt;start&lt;/code&gt; routine to remove the &lt;code&gt;changePowerStateTo&lt;/code&gt; method's power request.
    @param ordinal The number of the desired power state in the power state array.
    @result A return code that can be ignored by the caller. */</span>

    IOReturn changePowerStateToPriv( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal );

<span class="enscript-comment">/*! @function powerOverrideOnPriv
    @abstract Allows a driver to ignore its children's power management requests and only use changePowerStateToPriv to define its own power state.
    @discussion Power management normally keeps a device at the highest state required by its requests via @link changePowerStateTo changePowerStateTo@/link, @link changePowerStateToPriv changePowerStateToPriv@/link, and its children. However, a driver may ensure a lower power state than otherwise required by itself and its children using &lt;code&gt;powerOverrideOnPriv&lt;/code&gt;. When the override is on, power management keeps the device's power state in the state specified by &lt;code&gt;changePowerStateToPriv&lt;/code&gt;. Turning on the override will initiate a power change if the driver's &lt;code&gt;changePowerStateToPriv&lt;/code&gt; desired power state is different from the maximum of the &lt;code&gt;changePowerStateTo&lt;/code&gt; desired power state and the children's desires.
    @result A return code that can be ignored by the caller. */</span>

    IOReturn powerOverrideOnPriv( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function powerOverrideOffPriv
    @abstract Allows a driver to disable a power override.
    @discussion When a driver has enabled an override via @link powerOverrideOnPriv powerOverrideOnPriv@/link, it can disable it again by calling this method in its superclass. Disabling the override reverts to the default algorithm for determining a device's power state. The superclass will now keep the device at the highest state required by &lt;code&gt;changePowerStateTo&lt;/code&gt;, &lt;code&gt;changePowerStateToPriv&lt;/code&gt;, and its children. Turning off the override will initiate a power change if the driver's desired power state is different from the maximum of the power managed driver's desire and the children's desires.
    @result A return code that can be ignored by the caller. */</span>

    IOReturn powerOverrideOffPriv( <span class="enscript-type">void</span> );

<span class="enscript-comment">/*! @function powerChangeDone
    @abstract Tells a driver when a power state change is complete.
    @discussion Power management uses this method to inform a driver when a power change is completely done, when all interested parties have acknowledged the @link powerStateDidChangeTo powerStateDidChangeTo@/link call. The default implementation of this method is null; the method is meant to be overridden by subclassed power managed drivers. A driver should use this method to find out if a power change it initiated is complete.
    @param stateNumber The number of the state in the state array that the device has switched from. */</span>

    virtual <span class="enscript-type">void</span> powerChangeDone( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNumber );
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>
    <span class="enscript-comment">/* Power management internals */</span>
<span class="enscript-reference">public</span>:
    <span class="enscript-type">void</span> idleTimerExpired( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> settleTimerExpired( <span class="enscript-type">void</span> );
    IOReturn synchronizePowerTree( IOOptionBits options = 0, IOService * notifyRoot = 0 );
    bool assertPMDriverCall( IOPMDriverCallEntry * callEntry, IOOptionBits options = 0, IOPMinformee * inform = 0 );
    <span class="enscript-type">void</span> deassertPMDriverCall( IOPMDriverCallEntry * callEntry );
    IOReturn changePowerStateWithOverrideTo( IOPMPowerStateIndex ordinal, IOPMRequestTag tag );
    IOReturn changePowerStateForRootDomain( IOPMPowerStateIndex ordinal );
    IOReturn setIgnoreIdleTimer( bool ignore );
    IOReturn quiescePowerTree( <span class="enscript-type">void</span> * target, IOPMCompletionAction action, <span class="enscript-type">void</span> * param );
    uint32_t getPowerStateForClient( <span class="enscript-type">const</span> OSSymbol * client );
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * getIOMessageString( uint32_t msg );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> setAdvisoryTickleEnable( bool enable );
    <span class="enscript-type">void</span> reset_watchdog_timer( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> start_watchdog_timer ( <span class="enscript-type">void</span> );
    bool stop_watchdog_timer ( <span class="enscript-type">void</span> );
    IOReturn registerInterestForNotifer( IONotifier *notify, <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                  IOServiceInterestHandler handler, <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref );

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-type">static</span> IOWorkLoop * getPMworkloop( <span class="enscript-type">void</span> );
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">protected</span>:
    bool tellClientsWithResponse( <span class="enscript-type">int</span> messageType );
    <span class="enscript-type">void</span> tellClients( <span class="enscript-type">int</span> messageType );
    <span class="enscript-type">void</span> PMDebug( uint32_t event, uintptr_t param1, uintptr_t param2 );

<span class="enscript-reference">private</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-type">void</span> ack_timer_ticked ( <span class="enscript-type">void</span> );
    IOReturn serializedAllowPowerChange2 ( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    IOReturn serializedCancelPowerChange2 ( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    IOReturn powerDomainWillChangeTo( IOPMPowerFlags, IOPowerConnection * );
    IOReturn powerDomainDidChangeTo( IOPMPowerFlags, IOPowerConnection * );
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">void</span> PMfree( <span class="enscript-type">void</span> );
    bool tellChangeDown1 ( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    bool tellChangeDown2 ( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> );
    IOReturn startPowerChange( IOPMPowerChangeFlags, IOPMPowerStateIndex, IOPMPowerFlags, IOPowerConnection *, IOPMPowerFlags );
    <span class="enscript-type">void</span> setParentInfo ( IOPMPowerFlags, IOPowerConnection *, bool );
    IOReturn notifyAll ( uint32_t nextMS );
    bool notifyChild ( IOPowerConnection * child );
    IOPMPowerStateIndex getPowerStateForDomainFlags( IOPMPowerFlags flags );

    <span class="enscript-comment">// power change initiated by driver
</span>    <span class="enscript-type">void</span> OurChangeStart( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurSyncStart ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeTellClientsPowerDown ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeTellUserPMPolicyPowerDown ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeTellPriorityClientsPowerDown ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeTellCapabilityWillChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeNotifyInterestedDriversWillChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeSetPowerState ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeWaitForPowerSettle ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeNotifyInterestedDriversDidChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeTellCapabilityDidChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> OurChangeFinish ( <span class="enscript-type">void</span> );

    <span class="enscript-comment">// downward power change initiated by a power parent
</span>    IOReturn ParentChangeStart( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeTellPriorityClientsPowerDown ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeTellCapabilityWillChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeNotifyInterestedDriversWillChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeSetPowerState ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeWaitForPowerSettle ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeNotifyInterestedDriversDidChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeTellCapabilityDidChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeAcknowledgePowerChange ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> ParentChangeRootChangeDown( <span class="enscript-type">void</span> );

    <span class="enscript-type">void</span> all_done ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> start_ack_timer ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> stop_ack_timer ( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> start_ack_timer( UInt32 value, UInt32 scale );
    <span class="enscript-type">void</span> startSettleTimer( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> start_spindump_timer( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * delay_type );
    <span class="enscript-type">void</span> stop_spindump_timer( <span class="enscript-type">void</span> );
    bool checkForDone ( <span class="enscript-type">void</span> );
    bool responseValid ( uint32_t x, <span class="enscript-type">int</span> pid );
    <span class="enscript-type">void</span> computeDesiredState( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> tempDesire, bool computeOnly );
    <span class="enscript-type">void</span> trackSystemSleepPreventers( IOPMPowerStateIndex, IOPMPowerStateIndex, IOPMPowerChangeFlags );
    <span class="enscript-type">void</span> tellSystemCapabilityChange( uint32_t nextMS );
    <span class="enscript-type">void</span> restartIdleTimer( <span class="enscript-type">void</span> );

    <span class="enscript-type">static</span> <span class="enscript-type">void</span> ack_timer_expired( thread_call_param_t, thread_call_param_t );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> watchdog_timer_expired ( thread_call_param_t arg0, thread_call_param_t arg1 );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> spindump_timer_expired( thread_call_param_t arg0, thread_call_param_t arg1 );
    <span class="enscript-type">static</span> IOReturn actionAckTimerExpired(OSObject *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * );
    <span class="enscript-type">static</span> IOReturn watchdog_timer_expired ( OSObject *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * );
    <span class="enscript-type">static</span> IOReturn actionSpinDumpTimerExpired(OSObject *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * );

    <span class="enscript-type">static</span> IOReturn actionDriverCalloutDone(OSObject *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * );
    <span class="enscript-type">static</span> IOPMRequest * acquirePMRequest( IOService * target, IOOptionBits type, IOPMRequest * active = 0 );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> releasePMRequest( IOPMRequest * request );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> pmDriverCallout( IOService * from );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> pmTellAppWithResponse( OSObject * object, <span class="enscript-type">void</span> * context );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> pmTellClientWithResponse( OSObject * object, <span class="enscript-type">void</span> * context );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> pmTellCapabilityAppWithResponse ( OSObject * object, <span class="enscript-type">void</span> * arg );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> pmTellCapabilityClientWithResponse( OSObject * object, <span class="enscript-type">void</span> * arg );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> submitPMRequest( IOPMRequest * request );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> submitPMRequests( IOPMRequest ** request, IOItemCount count );
    bool ackTimerTick( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> addPowerChild1( IOPMRequest * request );
    <span class="enscript-type">void</span> addPowerChild2( IOPMRequest * request );
    <span class="enscript-type">void</span> addPowerChild3( IOPMRequest * request );
    <span class="enscript-type">void</span> adjustPowerState( uint32_t clamp = 0 );
    <span class="enscript-type">void</span> handlePMstop( IOPMRequest * request );
    <span class="enscript-type">void</span> handleRegisterPowerDriver( IOPMRequest * request );
    bool handleAcknowledgePowerChange( IOPMRequest * request );
    <span class="enscript-type">void</span> handlePowerDomainWillChangeTo( IOPMRequest * request );
    <span class="enscript-type">void</span> handlePowerDomainDidChangeTo( IOPMRequest * request );
    <span class="enscript-type">void</span> handleRequestPowerState( IOPMRequest * request );
    <span class="enscript-type">void</span> handlePowerOverrideChanged( IOPMRequest * request );
    <span class="enscript-type">void</span> handleActivityTickle( IOPMRequest * request );
    <span class="enscript-type">void</span> handleInterestChanged( IOPMRequest * request );
    <span class="enscript-type">void</span> handleSynchronizePowerTree( IOPMRequest * request );
    <span class="enscript-type">void</span> executePMRequest( IOPMRequest * request );
    bool actionPMWorkQueueInvoke( IOPMRequest * request, IOPMWorkQueue * queue );
    bool actionPMWorkQueueRetire( IOPMRequest * request, IOPMWorkQueue * queue );
    bool actionPMRequestQueue( IOPMRequest * request, IOPMRequestQueue * queue );
    bool actionPMReplyQueue( IOPMRequest * request, IOPMRequestQueue * queue );
    bool actionPMCompletionQueue( IOPMRequest * request, IOPMCompletionQueue * queue );
    bool notifyInterestedDrivers( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyInterestedDriversDone( <span class="enscript-type">void</span> );
    bool notifyControllingDriver( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyControllingDriverDone( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> driverSetPowerState( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> driverInformPowerChange( <span class="enscript-type">void</span> );
    bool isPMBlocked( IOPMRequest * request, <span class="enscript-type">int</span> count );
    <span class="enscript-type">void</span> notifyChildren( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyChildrenOrdered( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyChildrenDelayed( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyRootDomain( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> notifyRootDomainDone( <span class="enscript-type">void</span> );
    <span class="enscript-type">void</span> cleanClientResponses ( bool logErrors );
    <span class="enscript-type">void</span> updatePowerClient( <span class="enscript-type">const</span> OSSymbol * client, uint32_t powerState );
    <span class="enscript-type">void</span> removePowerClient( <span class="enscript-type">const</span> OSSymbol * client );
    IOReturn requestPowerState( <span class="enscript-type">const</span> OSSymbol * client, uint32_t state );
    IOReturn requestDomainPower( IOPMPowerStateIndex ourPowerState, IOOptionBits options = 0 );
    IOReturn configurePowerStatesReport( IOReportConfigureAction action, <span class="enscript-type">void</span> *result );
    IOReturn updatePowerStatesReport( IOReportConfigureAction action, <span class="enscript-type">void</span> *result, <span class="enscript-type">void</span> *destination );
    IOReturn configureSimplePowerReport(IOReportConfigureAction action, <span class="enscript-type">void</span> *result );
    IOReturn updateSimplePowerReport( IOReportConfigureAction action, <span class="enscript-type">void</span> *result, <span class="enscript-type">void</span> *destination );
    <span class="enscript-type">void</span> waitForPMDriverCall( IOService * target = 0 );
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! _IOKIT_IOSERVICE_H */</span>
</pre>
<hr />
</body></html>