<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOInterruptEventSource.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOInterruptEventSource.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2014 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
Copyright (c) 1998 Apple Computer, Inc.	 All rights reserved.

HISTORY
    1998-7-13	Godfrey van der Linden(gvdl)
	Created.
    1998-10-30	Godfrey van der Linden(gvdl)
	Converted to C++
*/</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IOKIT_IOINTERRUPTEVENTSOURCE_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IOKIT_IOINTERRUPTEVENTSOURCE_H</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOEventSource.h&gt;</span>

class IOService;

<span class="enscript-type">struct</span> IOInterruptAccountingData;

<span class="enscript-comment">/*! @class IOInterruptEventSource : public IOEventSource
    @abstract Event source for interrupt delivery to work-loop based drivers.
    @discussion The IOInterruptEventSource is a generic object that delivers calls interrupt routines in it's client in a guaranteed single-threaded manner.  IOInterruptEventSource is part of the IOKit $link IOWorkLoop infrastructure where the semantic that one and only one action method is executing within a work-loops event chain.
&lt;br&gt;&lt;br&gt;
When the action method is called in the client member function will receive 2 arguments, (IOEventSource *) sender and (int) count, See $link IOInterruptEventSource::Action.	Where sender will be reference to the interrupt that occurred and the count will be computed by the difference between the $link producerCount and $link consumerCount.  This number may not be reliable as no attempt is made to adjust for around the world type problems but is provided for general information and statistic gathering.
&lt;br&gt;&lt;br&gt;
In general a client will use the factory member function to create and initialise the event source and then add it to their work-loop.  It is the work loop's responsiblity to maintain the new event source in it's event chain.  See $link IOWorkLoop.
&lt;br&gt;&lt;br&gt;
An interrupt event source attaches itself to the given provider's interrupt source at initialisation time.  At this time it determines if it is connected to a level or edge triggered interrupt.  If the interrupt is an level triggered interrupt the event source automatically disables the interrupt source at primary interrupt time and after it call's the client it automatically reenables the interrupt.  This action is fairly expensive but it is 100% safe and defaults sensibly so that the driver writer does not have to implement type dependant interrupt routines.  So to repeat, the driver writer does not have to be concerned by the actual underlying interrupt mechanism as the event source hides the complexity.
&lt;br&gt;&lt;br&gt;
Saying this if the hardware is a multi-device card, for instance a 4 port NIC, where all of the devices are sharing one level triggered interrupt AND it is possible to determine each port's interrupt state non-destructively then the $link IOFilterInterruptEventSource would be a better choice.
&lt;br&gt;&lt;br&gt;
Warning:  All IOInterruptEventSources are created in the disabled state.  If you want to actually schedule interrupt delivery do not forget to enable the source.
*/</span>
class IOInterruptEventSource : public IOEventSource
{
    OSDeclareDefaultStructors(IOInterruptEventSource)

<span class="enscript-reference">public</span>:
<span class="enscript-comment">/*! @typedef Action
    @discussion 'C' pointer prototype of functions that are called in a single threaded context when an interrupt occurs.
    @param owner Pointer to client instance.
    @param sender Pointer to generation interrupt event source.
    @param count Number of interrupts seen before delivery. */</span>
    <span class="enscript-type">typedef</span> <span class="enscript-type">void</span> (*Action)(OSObject *, IOInterruptEventSource *, <span class="enscript-type">int</span> count);

<span class="enscript-comment">/*! @defined IOInterruptEventAction
    @discussion Backward compatibilty define for the old non-class scoped type definition.  See $link IOInterruptEventSource::Action */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOInterruptEventAction</span> IOInterruptEventSource::Action

<span class="enscript-reference">protected</span>:
<span class="enscript-comment">/*! @var provider IOService that provides interrupts for delivery. */</span>
    IOService *provider;

<span class="enscript-comment">/*! @var intIndex */</span>
    <span class="enscript-type">int</span> intIndex;

<span class="enscript-comment">/*! @var producerCount
    Current count of produced interrupts that have been received. */</span>
    <span class="enscript-type">volatile</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> producerCount;

<span class="enscript-comment">/*! @var consumerCount
    Current count of produced interrupts that the owner has been informed of. */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> consumerCount;

<span class="enscript-comment">/*! @var autoDisable Do we need to automatically disable the interrupt source when we take an interrupt, i.e. we are level triggered. */</span>
    bool autoDisable;

<span class="enscript-comment">/*! @var explicitDisable Has the user expicitly disabled this event source, if so then do not overide their request when returning from the callout */</span>
    bool explicitDisable;

<span class="enscript-comment">/*! @struct ExpansionData
    @discussion This structure will be used to expand the capablilties of the IOWorkLoop in the future.
    */</span>    
    <span class="enscript-type">struct</span> ExpansionData {
        IOInterruptAccountingData * statistics;
    };

<span class="enscript-comment">/*! @var reserved
    Reserved for future use.  (Internal use only)  */</span>
    ExpansionData *reserved;

<span class="enscript-comment">/*! @function free
    @abstract Sub-class implementation of free method, disconnects from the interrupt source. */</span>
    virtual <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function checkForWork
    @abstract Pure Virtual member function used by IOWorkLoop for issueing a client calls.
    @discussion This function called when the work-loop is ready to check for any work to do and then to call out the owner/action.
    @result Return true if this function needs to be called again before all its outstanding events have been processed. */</span>
    virtual bool checkForWork() APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function setWorkLoop
    @abstract Sub-class implementation of setWorkLoop method. */</span>
    virtual <span class="enscript-type">void</span> setWorkLoop(IOWorkLoop *inWorkLoop) APPLE_KEXT_OVERRIDE;

<span class="enscript-reference">public</span>:

<span class="enscript-comment">/*! @function interruptEventSource
    @abstract Factory function for IOInterruptEventSources creation and initialisation.
    @param owner Owning client of the new event source.
    @param action 'C' Function to call when something happens.
    @param provider IOService that represents the interrupt source.  Defaults to 0.  When no provider is defined the event source assumes that the client will in some manner call the interruptOccured method explicitly.  This will start the ball rolling for safe delivery of asynchronous event's into the driver.
    @param intIndex The index of the interrupt within the provider's interrupt sources.  Defaults to 0, i.e. the first interrupt in the provider.
    @result A new interrupt event source if successfully created and initialised, 0 otherwise.  */</span>
    <span class="enscript-type">static</span> IOInterruptEventSource *
	interruptEventSource(OSObject *owner,
			     Action action,
			     IOService *provider = 0,
			     <span class="enscript-type">int</span> intIndex = 0);

<span class="enscript-comment">/*! @function init
    @abstract Primary initialiser for the IOInterruptEventSource class.
    @param owner Owning client of the new event source.
    @param action 'C' Function to call when something happens.
    @param provider IOService that represents the interrupt source.  Defaults to 0.  When no provider is defined the event source assumes that the client will in some manner call the interruptOccured method explicitly.  This will start the ball rolling for safe delivery of asynchronous event's into the driver.
    @param intIndex The index of the interrupt within the provider's interrupt sources.  Defaults to 0, i.e. the first interrupt in the provider.
    @result true if the inherited classes and this instance initialise
successfully.  */</span>
    virtual bool init(OSObject *owner,
                      Action action,
		      IOService *provider = 0,
		      <span class="enscript-type">int</span> intIndex = 0);

<span class="enscript-comment">/*! @function enable
    @abstract Enable event source.
    @discussion A subclass implementation is expected to respect the enabled
state when checkForWork is called.  Calling this function will cause the
work-loop to be signalled so that a checkForWork is performed. */</span>
    virtual <span class="enscript-type">void</span> enable() APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function disable
    @abstract Disable event source.
    @discussion A subclass implementation is expected to respect the enabled
state when checkForWork is called. */</span>
    virtual <span class="enscript-type">void</span> disable() APPLE_KEXT_OVERRIDE;

<span class="enscript-comment">/*! @function getProvider
    @abstract Get'ter for $link provider variable.
    @result value of provider. */</span>
    virtual <span class="enscript-type">const</span> IOService *getProvider() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getIntIndex
    @abstract Get'ter for $link intIndex interrupt index variable.
    @result value of intIndex. */</span>
    virtual <span class="enscript-type">int</span> getIntIndex() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function getAutoDisable
    @abstract Get'ter for $link autoDisable variable.
    @result value of autoDisable. */</span>
    virtual bool getAutoDisable() <span class="enscript-type">const</span>;

<span class="enscript-comment">/*! @function interruptOccurred
    @abstract Functions that get called by the interrupt controller. See $link IOService::registerInterrupt
    @param nub Where did the interrupt originate from
    @param ind What is this interrupts index within 'nub'. */</span>
    virtual <span class="enscript-type">void</span> interruptOccurred(<span class="enscript-type">void</span> *, IOService *nub, <span class="enscript-type">int</span> ind);

<span class="enscript-comment">/*! @function normalInterruptOccurred
    @abstract Functions that get called by the interrupt controller.See $link IOService::registerInterrupt
    @param nub Where did the interrupt originate from
    @param ind What is this interrupts index within 'nub'. */</span>
    virtual <span class="enscript-type">void</span> normalInterruptOccurred(<span class="enscript-type">void</span> *, IOService *nub, <span class="enscript-type">int</span> ind);

<span class="enscript-comment">/*! @function disableInterruptOccurred
    @abstract Functions that get called by the interrupt controller.See $link IOService::registerInterrupt
    @param nub Where did the interrupt originate from
    @param ind What is this interrupts index within 'nub'. */</span>
    virtual <span class="enscript-type">void</span> disableInterruptOccurred(<span class="enscript-type">void</span> *, IOService *nub, <span class="enscript-type">int</span> ind);
    
<span class="enscript-comment">/*! @function warmCPU
    @abstract Tries to reduce latency for an interrupt which will be received near a specified time.
    @discussion Warms up a CPU in advance of an interrupt so that the interrupt may be serviced with predictable latency.  
    The warm-up is not periodic; callers should call warmCPU once in advance of each interrupt.  It is recommended that
    requests be issues in serial (i.e. each after the target for the previous call has elapsed), as there is a systemwide
    cap on the number of outstanding requests.  This routine may be disruptive to the system if used with very small intervals
    between requests; it should be used only in cases where interrupt latency is absolutely critical, and tens or hundreds of 
    milliseconds between targets is the expected time scale.  NOTE: it is not safe to call this method with interrupts disabled.
    @param abstime Time at which interrupt is expected. */</span>
    IOReturn warmCPU(uint64_t abstime);

<span class="enscript-reference">private</span>:
    IOReturn registerInterruptHandler(IOService *inProvider, <span class="enscript-type">int</span> inIntIndex);
    <span class="enscript-type">void</span> unregisterInterruptHandler(IOService *inProvider, <span class="enscript-type">int</span> inIntIndex);

<span class="enscript-reference">private</span>:
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 0);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 1);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 2);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 3);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 4);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 5);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 6);
    OSMetaClassDeclareReservedUnused(IOInterruptEventSource, 7);
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IOKIT_IOINTERRUPTEVENTSOURCE_H */</span>
</pre>
<hr />
</body></html>