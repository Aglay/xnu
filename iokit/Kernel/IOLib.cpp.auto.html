<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOLib.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOLib.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/* 
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * HISTORY
 *
 * 17-Apr-91   Portions from libIO.m, Doug Mitchell at NeXT.
 * 17-Nov-98   cpp
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSCPPDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReturn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLocks.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMapper.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBufferMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span> 

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;libkern/OSAtomic.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOStatisticsPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOKITSTATS</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsAlloc</span>(type, size) \
<span class="enscript-keyword">do</span> { \
	<span class="enscript-reference">IOStatistics</span>::countAlloc(type, size); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsAlloc</span>(type, size)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOKITSTATS */</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TRACK_ALLOC</span>	(IOTRACKING &amp;&amp; (kIOTracking &amp; gIOKitDebug))


<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span>
{


mach_timespec_t IOZeroTvalspec = { 0, 0 };

<span class="enscript-type">extern</span> ppnum_t <span class="enscript-function-name">pmap_find_phys</span>(pmap_t pmap, addr64_t va);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">__doprnt</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*fmt,
	va_list			argp,
	<span class="enscript-type">void</span>			(*putc)(<span class="enscript-type">int</span>, <span class="enscript-type">void</span> *),
	<span class="enscript-type">void</span>                    *arg,
	<span class="enscript-type">int</span>			radix,
	<span class="enscript-type">int</span>			is_log);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cons_putc_locked</span>(<span class="enscript-type">char</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_log_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_log_unlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">logwakeup</span>();


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

lck_grp_t	*IOLockGroup;

<span class="enscript-comment">/*
 * Global variables for use by iLogger
 * These symbols are for use only by Apple diagnostic code.
 * Binary compatibility is not guaranteed for kexts that reference these symbols.
 */</span>

<span class="enscript-type">void</span> *_giDebugLogInternal	= NULL;
<span class="enscript-type">void</span> *_giDebugLogDataInternal	= NULL;
<span class="enscript-type">void</span> *_giDebugReserved1		= NULL;
<span class="enscript-type">void</span> *_giDebugReserved2		= NULL;

iopa_t gIOBMDPageAllocator;

<span class="enscript-comment">/*
 * Static variables for this module.
 */</span>

<span class="enscript-type">static</span> queue_head_t gIOMallocContiguousEntries;
<span class="enscript-type">static</span> lck_mtx_t *  gIOMallocContiguousEntriesLock;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
<span class="enscript-type">enum</span> { kIOMaxPageableMaps    = 8 };
<span class="enscript-type">enum</span> { kIOPageableMapSize    = 512 * 1024 * 1024 };
<span class="enscript-type">enum</span> { kIOPageableMaxMapSize = 512 * 1024 * 1024 };
#<span class="enscript-reference">else</span>
<span class="enscript-type">enum</span> { kIOMaxPageableMaps    = 16 };
<span class="enscript-type">enum</span> { kIOPageableMapSize    = 96 * 1024 * 1024 };
<span class="enscript-type">enum</span> { kIOPageableMaxMapSize = 96 * 1024 * 1024 };
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    vm_map_t		map;
    vm_offset_t	address;
    vm_offset_t	end;
} IOMapData;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> {
    UInt32	count;
    UInt32	hint;
    IOMapData	maps[ kIOMaxPageableMaps ];
    lck_mtx_t *	lock;
} gIOKitPageableSpace;

<span class="enscript-type">static</span> iopa_t gIOPageablePageAllocator;

uint32_t  gIOPageAllocChunkBytes;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
IOTrackingQueue * gIOMallocTracking;
IOTrackingQueue * gIOWireTracking;
IOTrackingQueue * gIOMapTracking;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOTRACKING */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOLibInit</span>(<span class="enscript-type">void</span>)
{
    kern_return_t ret;

    <span class="enscript-type">static</span> <span class="enscript-type">bool</span> libInitialized;

    <span class="enscript-keyword">if</span>(libInitialized)
        <span class="enscript-keyword">return</span>;	

    IOLockGroup = lck_grp_alloc_init(<span class="enscript-string">&quot;IOKit&quot;</span>, LCK_GRP_ATTR_NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    IOTrackingInit();
    gIOMallocTracking = IOTrackingQueueAlloc(kIOMallocTrackingName, 0, 0,         true);
    gIOWireTracking   = IOTrackingQueueAlloc(kIOWireTrackingName,   0, page_size, false);
    gIOMapTracking    = IOTrackingQueueAlloc(kIOMapTrackingName,    0, page_size, false);
#<span class="enscript-reference">endif</span>

    gIOKitPageableSpace.maps[0].address = 0;
    ret = kmem_suballoc(kernel_map,
                    &amp;gIOKitPageableSpace.maps[0].address,
                    kIOPageableMapSize,
                    TRUE,
                    VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IOKIT),
                    &amp;gIOKitPageableSpace.maps[0].map);
    <span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
        panic(<span class="enscript-string">&quot;failed to allocate iokit pageable map\n&quot;</span>);

    gIOKitPageableSpace.lock 		= lck_mtx_alloc_init(IOLockGroup, LCK_ATTR_NULL);
    gIOKitPageableSpace.maps[0].end	= gIOKitPageableSpace.maps[0].address + kIOPageableMapSize;
    gIOKitPageableSpace.hint		= 0;
    gIOKitPageableSpace.count		= 1;

    gIOMallocContiguousEntriesLock 	= lck_mtx_alloc_init(IOLockGroup, LCK_ATTR_NULL);
    queue_init( &amp;gIOMallocContiguousEntries );

    gIOPageAllocChunkBytes = PAGE_SIZE/64;
    assert(<span class="enscript-keyword">sizeof</span>(iopa_page_t) &lt;= gIOPageAllocChunkBytes);
    iopa_init(&amp;gIOBMDPageAllocator);
    iopa_init(&amp;gIOPageablePageAllocator);


    libInitialized = true;
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> uint32_t 
<span class="enscript-function-name">log2up</span>(uint32_t size)
{
    <span class="enscript-keyword">if</span> (size &lt;= 1) size = 0;
    <span class="enscript-keyword">else</span> size = 32 - __builtin_clz(size - 1);
    <span class="enscript-keyword">return</span> (size);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOThread <span class="enscript-function-name">IOCreateThread</span>(IOThreadFunc fcn, <span class="enscript-type">void</span> *arg)
{
	kern_return_t	result;
	thread_t		thread;

	result = kernel_thread_start((thread_continue_t)fcn, arg, &amp;thread);
	<span class="enscript-keyword">if</span> (result != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> (NULL);

	thread_deallocate(thread);

	<span class="enscript-keyword">return</span> (thread);
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOExitThread</span>(<span class="enscript-type">void</span>)
{
    (<span class="enscript-type">void</span>) thread_terminate(current_thread());
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
<span class="enscript-type">struct</span> IOLibMallocHeader
{
    IOTrackingAddress tracking;
};
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sizeofIOLibMallocHeader</span>	(sizeof(IOLibMallocHeader) - (TRACK_ALLOC ? 0 : sizeof(IOTrackingAddress)))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sizeofIOLibMallocHeader</span>	(0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOMalloc</span>(vm_size_t size)
{
    <span class="enscript-type">void</span> * address;
    vm_size_t allocSize;

    allocSize = size + sizeofIOLibMallocHeader;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    <span class="enscript-keyword">if</span> (sizeofIOLibMallocHeader &amp;&amp; (allocSize &lt;= size)) <span class="enscript-keyword">return</span> (NULL);	<span class="enscript-comment">// overflow
</span>#<span class="enscript-reference">endif</span>
    address = kalloc_tag_bt(allocSize, VM_KERN_MEMORY_IOKIT);

    <span class="enscript-keyword">if</span> ( address ) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC) {
	    IOLibMallocHeader * hdr;
	    hdr = (typeof(hdr)) address;
	    bzero(&amp;hdr-&gt;tracking, <span class="enscript-keyword">sizeof</span>(hdr-&gt;tracking));
	    hdr-&gt;tracking.address = ~(((uintptr_t) address) + sizeofIOLibMallocHeader);
	    hdr-&gt;tracking.size    = size;
	    IOTrackingAdd(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size, true);
	}
#<span class="enscript-reference">endif</span>
	address = (typeof(address)) (((uintptr_t) address) + sizeofIOLibMallocHeader);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
    OSAddAtomic(size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>
	IOStatisticsAlloc(kIOStatisticsMalloc, size);
    }

    <span class="enscript-keyword">return</span> address;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOFree</span>(<span class="enscript-type">void</span> * address, vm_size_t size)
{
    <span class="enscript-keyword">if</span> (address) {

	address = (typeof(address)) (((uintptr_t) address) - sizeofIOLibMallocHeader);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC) {
	    IOLibMallocHeader * hdr;
	    hdr = (typeof(hdr)) address;
            <span class="enscript-keyword">if</span> (size != hdr-&gt;tracking.size)
	    {
		OSReportWithBacktrace(<span class="enscript-string">&quot;bad IOFree size 0x%lx should be 0x%lx&quot;</span>, size, hdr-&gt;tracking.size);
		size = hdr-&gt;tracking.size;
	    }
	    IOTrackingRemove(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size);
	}
#<span class="enscript-reference">endif</span>

	kfree(address, size + sizeofIOLibMallocHeader);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
    OSAddAtomic(-size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>
	IOStatisticsAlloc(kIOStatisticsFree, size);
    }
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

vm_tag_t 
<span class="enscript-function-name">IOMemoryTag</span>(vm_map_t map)
{
    vm_tag_t tag;

    <span class="enscript-keyword">if</span> (!vm_kernel_map_is_kernel(map)) <span class="enscript-keyword">return</span> (VM_MEMORY_IOKIT);

    tag = vm_tag_bt();
    <span class="enscript-keyword">if</span> (tag == VM_KERN_MEMORY_NONE) tag = VM_KERN_MEMORY_IOKIT;

    <span class="enscript-keyword">return</span> (tag);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">struct</span> IOLibPageMallocHeader
{
    mach_vm_size_t    allocationSize;
    mach_vm_address_t allocationAddress;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    IOTrackingAddress tracking;
#<span class="enscript-reference">endif</span>
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sizeofIOLibPageMallocHeader</span>	(sizeof(IOLibPageMallocHeader) - (TRACK_ALLOC ? 0 : sizeof(IOTrackingAddress)))
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">sizeofIOLibPageMallocHeader</span>	(sizeof(IOLibPageMallocHeader))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOMallocAligned</span>(vm_size_t size, vm_size_t alignment)
{
    kern_return_t	    kr;
    vm_offset_t		    address;
    vm_offset_t		    allocationAddress;
    vm_size_t		    adjustedSize;
    uintptr_t		    alignMask;
    IOLibPageMallocHeader * hdr;

    <span class="enscript-keyword">if</span> (size == 0)
        <span class="enscript-keyword">return</span> 0;

    alignment = (1UL &lt;&lt; log2up(alignment));
    alignMask = alignment - 1;
    adjustedSize = size + sizeofIOLibPageMallocHeader;

    <span class="enscript-keyword">if</span> (size &gt; adjustedSize) {
	    address = 0;    <span class="enscript-comment">/* overflow detected */</span>
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (adjustedSize &gt;= page_size) {

        kr = kernel_memory_allocate(kernel_map, &amp;address,
					size, alignMask, 0, IOMemoryTag(kernel_map));
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kr)	address = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TRACK_ALLOC) IOTrackingAlloc(gIOMallocTracking, address, size);
#<span class="enscript-reference">endif</span>

    } <span class="enscript-keyword">else</span> {

	adjustedSize += alignMask;

	<span class="enscript-keyword">if</span> (adjustedSize &gt;= page_size) {

	    kr = kernel_memory_allocate(kernel_map, &amp;allocationAddress,
					    adjustedSize, 0, 0, IOMemoryTag(kernel_map));
	    <span class="enscript-keyword">if</span> (KERN_SUCCESS != kr) allocationAddress = 0;

	} <span class="enscript-keyword">else</span>
	    allocationAddress = (vm_address_t) kalloc_tag_bt(adjustedSize, VM_KERN_MEMORY_IOKIT);

        <span class="enscript-keyword">if</span> (allocationAddress) {
            address = (allocationAddress + alignMask + sizeofIOLibPageMallocHeader)
                    &amp; (~alignMask);

	    hdr = (typeof(hdr))(address - sizeofIOLibPageMallocHeader);
	    hdr-&gt;allocationSize    = adjustedSize;
	    hdr-&gt;allocationAddress = allocationAddress;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	    <span class="enscript-keyword">if</span> (TRACK_ALLOC) {
	        bzero(&amp;hdr-&gt;tracking, <span class="enscript-keyword">sizeof</span>(hdr-&gt;tracking));
	        hdr-&gt;tracking.address = ~address;
	        hdr-&gt;tracking.size = size;
	        IOTrackingAdd(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size, true);
	    }
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span>
	    address = 0;
    }

    assert(0 == (address &amp; alignMask));

    <span class="enscript-keyword">if</span>( address) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
		OSAddAtomic(size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>
    	IOStatisticsAlloc(kIOStatisticsMallocAligned, size);
	}

    <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) address;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOFreeAligned</span>(<span class="enscript-type">void</span> * address, vm_size_t size)
{
    vm_address_t	    allocationAddress;
    vm_size_t	            adjustedSize;
    IOLibPageMallocHeader * hdr;

    <span class="enscript-keyword">if</span>( !address)
	<span class="enscript-keyword">return</span>;

    assert(size);

    adjustedSize = size + sizeofIOLibPageMallocHeader;
    <span class="enscript-keyword">if</span> (adjustedSize &gt;= page_size) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC) IOTrackingFree(gIOMallocTracking, (uintptr_t) address, size);
#<span class="enscript-reference">endif</span>
        kmem_free( kernel_map, (vm_offset_t) address, size);

    } <span class="enscript-keyword">else</span> {
        hdr = (typeof(hdr)) (((uintptr_t)address) - sizeofIOLibPageMallocHeader);
      	adjustedSize = hdr-&gt;allocationSize;
        allocationAddress = hdr-&gt;allocationAddress;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC)
	{
            <span class="enscript-keyword">if</span> (size != hdr-&gt;tracking.size)
	    {
		OSReportWithBacktrace(<span class="enscript-string">&quot;bad IOFreeAligned size 0x%lx should be 0x%lx&quot;</span>, size, hdr-&gt;tracking.size);
		size = hdr-&gt;tracking.size;
	    }
	    IOTrackingRemove(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (adjustedSize &gt;= page_size) {
	    kmem_free( kernel_map, allocationAddress, adjustedSize);
	} <span class="enscript-keyword">else</span> {
	    kfree((<span class="enscript-type">void</span> *)allocationAddress, adjustedSize);
	}
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
    OSAddAtomic(-size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>

    IOStatisticsAlloc(kIOStatisticsFreeAligned, size);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOKernelFreePhysical</span>(mach_vm_address_t address, mach_vm_size_t size)
{
    mach_vm_address_t       allocationAddress;
    mach_vm_size_t          adjustedSize;
    IOLibPageMallocHeader * hdr;

    <span class="enscript-keyword">if</span> (!address)
	<span class="enscript-keyword">return</span>;

    assert(size);

    adjustedSize = (2 * size) + sizeofIOLibPageMallocHeader;
    <span class="enscript-keyword">if</span> (adjustedSize &gt;= page_size) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC) IOTrackingFree(gIOMallocTracking, address, size);
#<span class="enscript-reference">endif</span>
	kmem_free( kernel_map, (vm_offset_t) address, size);

    } <span class="enscript-keyword">else</span> {

        hdr = (typeof(hdr)) (((uintptr_t)address) - sizeofIOLibPageMallocHeader);
      	adjustedSize = hdr-&gt;allocationSize;
        allocationAddress = hdr-&gt;allocationAddress;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	<span class="enscript-keyword">if</span> (TRACK_ALLOC) IOTrackingRemove(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size);
#<span class="enscript-reference">endif</span>
	kfree((<span class="enscript-type">void</span> *)allocationAddress, adjustedSize);
    }

    IOStatisticsAlloc(kIOStatisticsFreeContiguous, size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
    OSAddAtomic(-size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>
}


mach_vm_address_t
<span class="enscript-function-name">IOKernelAllocateWithPhysicalRestrict</span>(mach_vm_size_t size, mach_vm_address_t maxPhys, 
			                mach_vm_size_t alignment, <span class="enscript-type">bool</span> contiguous)
{
    kern_return_t	    kr;
    mach_vm_address_t	    address;
    mach_vm_address_t	    allocationAddress;
    mach_vm_size_t	    adjustedSize;
    mach_vm_address_t	    alignMask;
    IOLibPageMallocHeader * hdr;

    <span class="enscript-keyword">if</span> (size == 0)
	<span class="enscript-keyword">return</span> (0);
    <span class="enscript-keyword">if</span> (alignment == 0) 
        alignment = 1;

    alignMask = alignment - 1;
    adjustedSize = (2 * size) + sizeofIOLibPageMallocHeader;
    <span class="enscript-keyword">if</span> (adjustedSize &lt; size) <span class="enscript-keyword">return</span> (0);

    contiguous = (contiguous &amp;&amp; (adjustedSize &gt; page_size))
                   || (alignment &gt; page_size);

    <span class="enscript-keyword">if</span> (contiguous || maxPhys)
    {
        <span class="enscript-type">int</span> options = 0;
	vm_offset_t virt;

	adjustedSize = size;
        contiguous = (contiguous &amp;&amp; (adjustedSize &gt; page_size))
                           || (alignment &gt; page_size);

	<span class="enscript-keyword">if</span> (!contiguous)
	{
	    <span class="enscript-keyword">if</span> (maxPhys &lt;= 0xFFFFFFFF)
	    {
		maxPhys = 0;
		options |= KMA_LOMEM;
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gIOLastPage &amp;&amp; (atop_64(maxPhys) &gt; gIOLastPage))
	    {
		maxPhys = 0;
	    }
	}
	<span class="enscript-keyword">if</span> (contiguous || maxPhys)
	{
	    kr = kmem_alloc_contig(kernel_map, &amp;virt, size,
				   alignMask, atop(maxPhys), atop(alignMask), 0, IOMemoryTag(kernel_map));
	}
	<span class="enscript-keyword">else</span>
	{
	    kr = kernel_memory_allocate(kernel_map, &amp;virt,
					size, alignMask, options, IOMemoryTag(kernel_map));
	}
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == kr)
	{
	    address = virt;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	    <span class="enscript-keyword">if</span> (TRACK_ALLOC) IOTrackingAlloc(gIOMallocTracking, address, size);
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">else</span>
	    address = 0;
    }
    <span class="enscript-keyword">else</span>
    {
	adjustedSize += alignMask;
        <span class="enscript-keyword">if</span> (adjustedSize &lt; size) <span class="enscript-keyword">return</span> (0);
        allocationAddress = (mach_vm_address_t) kalloc_tag_bt(adjustedSize, VM_KERN_MEMORY_IOKIT);

        <span class="enscript-keyword">if</span> (allocationAddress) {


            address = (allocationAddress + alignMask + sizeofIOLibPageMallocHeader)
                    &amp; (~alignMask);

            <span class="enscript-keyword">if</span> (atop_32(address) != atop_32(address + size - 1))
                address = round_page(address);

	    hdr = (typeof(hdr))(address - sizeofIOLibPageMallocHeader);
	    hdr-&gt;allocationSize    = adjustedSize;
	    hdr-&gt;allocationAddress = allocationAddress;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
	    <span class="enscript-keyword">if</span> (TRACK_ALLOC) {
	        bzero(&amp;hdr-&gt;tracking, <span class="enscript-keyword">sizeof</span>(hdr-&gt;tracking));
	        hdr-&gt;tracking.address = ~address;
	        hdr-&gt;tracking.size    = size;
	        IOTrackingAdd(gIOMallocTracking, &amp;hdr-&gt;tracking.tracking, size, true);
	    }
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span>
	    address = 0;
    }

    <span class="enscript-keyword">if</span> (address) {
    IOStatisticsAlloc(kIOStatisticsMallocContiguous, size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
    OSAddAtomic(size, &amp;debug_iomalloc_size);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">return</span> (address);
}


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">struct</span> _IOMallocContiguousEntry
{
    mach_vm_address_t	       virtualAddr;
    IOBufferMemoryDescriptor * md;
    queue_chain_t	       link;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _IOMallocContiguousEntry _IOMallocContiguousEntry;

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOMallocContiguous</span>(vm_size_t size, vm_size_t alignment,
			   IOPhysicalAddress * physicalAddress)
{
    mach_vm_address_t	address = 0;

    <span class="enscript-keyword">if</span> (size == 0)
	<span class="enscript-keyword">return</span> 0;
    <span class="enscript-keyword">if</span> (alignment == 0) 
	alignment = 1;

    <span class="enscript-comment">/* Do we want a physical address? */</span>
    <span class="enscript-keyword">if</span> (!physicalAddress)
    {
	address = IOKernelAllocateWithPhysicalRestrict(size, 0 <span class="enscript-comment">/*maxPhys*/</span>, alignment, true);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span>
    {
	IOBufferMemoryDescriptor * bmd;
	mach_vm_address_t          physicalMask;
	vm_offset_t		   alignMask;

	alignMask = alignment - 1;
	physicalMask = (0xFFFFFFFF ^ alignMask);

	bmd = IOBufferMemoryDescriptor::inTaskWithPhysicalMask(
		kernel_task, kIOMemoryPhysicallyContiguous, size, physicalMask);
	<span class="enscript-keyword">if</span> (!bmd)
	    <span class="enscript-keyword">break</span>;
	
	_IOMallocContiguousEntry *
	entry = IONew(_IOMallocContiguousEntry, 1);
	<span class="enscript-keyword">if</span> (!entry)
	{
	    bmd-&gt;release();
	    <span class="enscript-keyword">break</span>;
	}
	entry-&gt;virtualAddr = (mach_vm_address_t) bmd-&gt;getBytesNoCopy();
	entry-&gt;md          = bmd;
	lck_mtx_lock(gIOMallocContiguousEntriesLock);
	queue_enter( &amp;gIOMallocContiguousEntries, entry, 
		    _IOMallocContiguousEntry *, link );
	lck_mtx_unlock(gIOMallocContiguousEntriesLock);

	address          = (mach_vm_address_t) entry-&gt;virtualAddr;
	*physicalAddress = bmd-&gt;getPhysicalAddress();
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) address;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOFreeContiguous</span>(<span class="enscript-type">void</span> * _address, vm_size_t size)
{
    _IOMallocContiguousEntry * entry;
    IOMemoryDescriptor *       md = NULL;

    mach_vm_address_t address = (mach_vm_address_t) _address;

    <span class="enscript-keyword">if</span>( !address)
	<span class="enscript-keyword">return</span>;

    assert(size);

    lck_mtx_lock(gIOMallocContiguousEntriesLock);
    queue_iterate( &amp;gIOMallocContiguousEntries, entry,
		    _IOMallocContiguousEntry *, link )
    {
	<span class="enscript-keyword">if</span>( entry-&gt;virtualAddr == address ) {
	    md   = entry-&gt;md;
	    queue_remove( &amp;gIOMallocContiguousEntries, entry,
			    _IOMallocContiguousEntry *, link );
	    <span class="enscript-keyword">break</span>;
	}
    }
    lck_mtx_unlock(gIOMallocContiguousEntriesLock);

    <span class="enscript-keyword">if</span> (md)
    {
	md-&gt;release();
	IODelete(entry, _IOMallocContiguousEntry, 1);
    }
    <span class="enscript-keyword">else</span>
    {
	IOKernelFreePhysical((mach_vm_address_t) address, size);
    }
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

kern_return_t <span class="enscript-function-name">IOIteratePageableMaps</span>(vm_size_t size,
                    IOIteratePageableMapsCallback callback, <span class="enscript-type">void</span> * ref)
{
    kern_return_t	kr = kIOReturnNotReady;
    vm_size_t		segSize;
    UInt32		attempts;
    UInt32		index;
    vm_offset_t		min;
    vm_map_t		map;

    <span class="enscript-keyword">if</span> (size &gt; kIOPageableMaxMapSize)
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    <span class="enscript-keyword">do</span> {
        index = gIOKitPageableSpace.hint;
        attempts = gIOKitPageableSpace.count;
        <span class="enscript-keyword">while</span>( attempts--) {
            kr = (*callback)(gIOKitPageableSpace.maps[index].map, ref);
            <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr) {
                gIOKitPageableSpace.hint = index;
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">if</span>( index)
                index--;
            <span class="enscript-keyword">else</span>
                index = gIOKitPageableSpace.count - 1;
        }
        <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr)
            <span class="enscript-keyword">break</span>;

        lck_mtx_lock( gIOKitPageableSpace.lock );

        index = gIOKitPageableSpace.count;
        <span class="enscript-keyword">if</span>( index &gt;= (kIOMaxPageableMaps - 1)) {
            lck_mtx_unlock( gIOKitPageableSpace.lock );
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span>( size &lt; kIOPageableMapSize)
            segSize = kIOPageableMapSize;
        <span class="enscript-keyword">else</span>
            segSize = size;

        min = 0;
        kr = kmem_suballoc(kernel_map,
                    &amp;min,
                    segSize,
                    TRUE,
                    VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_IOKIT),
                    &amp;map);
        <span class="enscript-keyword">if</span>( KERN_SUCCESS != kr) {
            lck_mtx_unlock( gIOKitPageableSpace.lock );
            <span class="enscript-keyword">break</span>;
        }

        gIOKitPageableSpace.maps[index].map 	= map;
        gIOKitPageableSpace.maps[index].address = min;
        gIOKitPageableSpace.maps[index].end 	= min + segSize;
        gIOKitPageableSpace.hint 		= index;
        gIOKitPageableSpace.count 		= index + 1;

        lck_mtx_unlock( gIOKitPageableSpace.lock );

    } <span class="enscript-keyword">while</span>( true );

    <span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">struct</span> IOMallocPageableRef
{
    vm_offset_t address;
    vm_size_t	size;
    vm_tag_t    tag;
};

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">IOMallocPageableCallback</span>(vm_map_t map, <span class="enscript-type">void</span> * _ref)
{
    <span class="enscript-type">struct</span> IOMallocPageableRef * ref = (<span class="enscript-type">struct</span> IOMallocPageableRef *) _ref;
    kern_return_t	         kr;

    kr = kmem_alloc_pageable( map, &amp;ref-&gt;address, ref-&gt;size, ref-&gt;tag );

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">IOMallocPageablePages</span>(vm_size_t size, vm_size_t alignment, vm_tag_t tag)
{
    kern_return_t	       kr = kIOReturnNotReady;
    <span class="enscript-type">struct</span> IOMallocPageableRef ref;

    <span class="enscript-keyword">if</span> (alignment &gt; page_size)
        <span class="enscript-keyword">return</span>( 0 );
    <span class="enscript-keyword">if</span> (size &gt; kIOPageableMaxMapSize)
        <span class="enscript-keyword">return</span>( 0 );

    ref.size = size;
    ref.tag  = tag;
    kr = IOIteratePageableMaps( size, &amp;IOMallocPageableCallback, &amp;ref );
    <span class="enscript-keyword">if</span>( kIOReturnSuccess != kr)
        ref.address = 0;

    <span class="enscript-keyword">return</span>( (<span class="enscript-type">void</span> *) ref.address );
}

vm_map_t <span class="enscript-function-name">IOPageableMapForAddress</span>( uintptr_t address )
{
    vm_map_t	map = 0;
    UInt32	index;
    
    <span class="enscript-keyword">for</span>( index = 0; index &lt; gIOKitPageableSpace.count; index++) {
        <span class="enscript-keyword">if</span>( (address &gt;= gIOKitPageableSpace.maps[index].address)
         &amp;&amp; (address &lt; gIOKitPageableSpace.maps[index].end) ) {
            map = gIOKitPageableSpace.maps[index].map;
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">if</span>( !map)
        panic(<span class="enscript-string">&quot;IOPageableMapForAddress: null&quot;</span>);

    <span class="enscript-keyword">return</span>( map );
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOFreePageablePages</span>(<span class="enscript-type">void</span> * address, vm_size_t size)
{
    vm_map_t map;
    
    map = IOPageableMapForAddress( (vm_address_t) address);
    <span class="enscript-keyword">if</span>( map)
        kmem_free( map, (vm_offset_t) address, size);
}

<span class="enscript-type">static</span> uintptr_t <span class="enscript-function-name">IOMallocOnePageablePage</span>(iopa_t * a)
{
    <span class="enscript-keyword">return</span> ((uintptr_t) IOMallocPageablePages(page_size, page_size, VM_KERN_MEMORY_IOKIT));
}

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOMallocPageable</span>(vm_size_t size, vm_size_t alignment)
{
    <span class="enscript-type">void</span> * addr;

    <span class="enscript-keyword">if</span> (size &gt;= (page_size - 4*gIOPageAllocChunkBytes)) addr = IOMallocPageablePages(size, alignment, IOMemoryTag(kernel_map));
    <span class="enscript-keyword">else</span>                   addr = ((<span class="enscript-type">void</span> * ) iopa_alloc(&amp;gIOPageablePageAllocator, &amp;IOMallocOnePageablePage, size, alignment));

    <span class="enscript-keyword">if</span> (addr) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
	   OSAddAtomicLong(size, &amp;debug_iomallocpageable_size);
#<span class="enscript-reference">endif</span>
       IOStatisticsAlloc(kIOStatisticsMallocPageable, size);
    }

    <span class="enscript-keyword">return</span> (addr);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOFreePageable</span>(<span class="enscript-type">void</span> * address, vm_size_t size)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOALLOCDEBUG</span>
	OSAddAtomicLong(-size, &amp;debug_iomallocpageable_size);
#<span class="enscript-reference">endif</span>
    IOStatisticsAlloc(kIOStatisticsFreePageable, size);

    <span class="enscript-keyword">if</span> (size &lt; (page_size - 4*gIOPageAllocChunkBytes))
    {
	address = (<span class="enscript-type">void</span> *) iopa_free(&amp;gIOPageablePageAllocator, (uintptr_t) address, size);
	size = page_size;
    }
    <span class="enscript-keyword">if</span> (address) IOFreePageablePages(address, size);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">iopa_init</span>(iopa_t * a)
{
    bzero(a, <span class="enscript-keyword">sizeof</span>(*a));
    a-&gt;lock = IOLockAlloc();
    queue_init(&amp;a-&gt;list);
}

<span class="enscript-type">static</span> uintptr_t
<span class="enscript-function-name">iopa_allocinpage</span>(iopa_page_t * pa, uint32_t count, uint64_t align)
{
    uint32_t n, s;
    uint64_t avail = pa-&gt;avail;

    assert(avail);

    <span class="enscript-comment">// find strings of count 1 bits in avail
</span>    <span class="enscript-keyword">for</span> (n = count; n &gt; 1; n -= s)
    {
    	s = n &gt;&gt; 1;
    	avail = avail &amp; (avail &lt;&lt; s);
    }
    <span class="enscript-comment">// and aligned
</span>    avail &amp;= align;

    <span class="enscript-keyword">if</span> (avail)
    {
	n = __builtin_clzll(avail);
	pa-&gt;avail &amp;= ~((-1ULL &lt;&lt; (64 - count)) &gt;&gt; n);
	<span class="enscript-keyword">if</span> (!pa-&gt;avail &amp;&amp; pa-&gt;link.next)
	{
	    remque(&amp;pa-&gt;link);
	    pa-&gt;link.next = 0;
	}
	<span class="enscript-keyword">return</span> (n * gIOPageAllocChunkBytes + trunc_page((uintptr_t) pa));
    }

    <span class="enscript-keyword">return</span> (0);
}

uintptr_t 
<span class="enscript-function-name">iopa_alloc</span>(iopa_t * a, iopa_proc_t alloc, vm_size_t bytes, uint32_t balign)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> uint64_t align_masks[] = {
	0xFFFFFFFFFFFFFFFF,
	0xAAAAAAAAAAAAAAAA,
	0x8888888888888888,
	0x8080808080808080,
	0x8000800080008000,
	0x8000000080000000,
	0x8000000000000000,
    };
    iopa_page_t * pa;
    uintptr_t     addr = 0;
    uint32_t      count;
    uint64_t      align;

    <span class="enscript-keyword">if</span> (!bytes) bytes = 1;
    count = (bytes + gIOPageAllocChunkBytes - 1) / gIOPageAllocChunkBytes;
    align = align_masks[log2up((balign + gIOPageAllocChunkBytes - 1) / gIOPageAllocChunkBytes)];

    IOLockLock(a-&gt;lock);
    __IGNORE_WCASTALIGN(pa = (typeof(pa)) queue_first(&amp;a-&gt;list));
    <span class="enscript-keyword">while</span> (!queue_end(&amp;a-&gt;list, &amp;pa-&gt;link))
    {
	addr = iopa_allocinpage(pa, count, align);
	<span class="enscript-keyword">if</span> (addr)
	{
	    a-&gt;bytecount += bytes;
	    <span class="enscript-keyword">break</span>;
	}
	__IGNORE_WCASTALIGN(pa = (typeof(pa)) queue_next(&amp;pa-&gt;link));
    }
    IOLockUnlock(a-&gt;lock);

    <span class="enscript-keyword">if</span> (!addr)
    {
	addr = alloc(a);
	<span class="enscript-keyword">if</span> (addr)
	{
	    pa = (typeof(pa)) (addr + page_size - gIOPageAllocChunkBytes);
	    pa-&gt;signature = kIOPageAllocSignature;
	    pa-&gt;avail     = -2ULL;

	    addr = iopa_allocinpage(pa, count, align);
	    IOLockLock(a-&gt;lock);
	    <span class="enscript-keyword">if</span> (pa-&gt;avail) enqueue_head(&amp;a-&gt;list, &amp;pa-&gt;link);
	    a-&gt;pagecount++;
	    <span class="enscript-keyword">if</span> (addr) a-&gt;bytecount += bytes;
	    IOLockUnlock(a-&gt;lock);
	}
    }

    assert((addr &amp; ((1 &lt;&lt; log2up(balign)) - 1)) == 0);
    <span class="enscript-keyword">return</span> (addr);
}

uintptr_t 
<span class="enscript-function-name">iopa_free</span>(iopa_t * a, uintptr_t addr, vm_size_t bytes)
{
    iopa_page_t * pa;
    uint32_t      count;
    uintptr_t     chunk;

    <span class="enscript-keyword">if</span> (!bytes) bytes = 1;

    chunk = (addr &amp; page_mask);
    assert(0 == (chunk &amp; (gIOPageAllocChunkBytes - 1)));

    pa = (typeof(pa)) (addr | (page_size - gIOPageAllocChunkBytes));
    assert(kIOPageAllocSignature == pa-&gt;signature);

    count = (bytes + gIOPageAllocChunkBytes - 1) / gIOPageAllocChunkBytes;
    chunk /= gIOPageAllocChunkBytes;

    IOLockLock(a-&gt;lock);
    <span class="enscript-keyword">if</span> (!pa-&gt;avail)
    {
	assert(!pa-&gt;link.next);
	enqueue_tail(&amp;a-&gt;list, &amp;pa-&gt;link);
    }
    pa-&gt;avail |= ((-1ULL &lt;&lt; (64 - count)) &gt;&gt; chunk);
    <span class="enscript-keyword">if</span> (pa-&gt;avail != -2ULL) pa = 0;
    <span class="enscript-keyword">else</span>
    {
        remque(&amp;pa-&gt;link);
        pa-&gt;link.next = 0;
        pa-&gt;signature = 0;
	a-&gt;pagecount--;
	<span class="enscript-comment">// page to free
</span>	pa = (typeof(pa)) trunc_page(pa);
    }
    a-&gt;bytecount -= bytes;
    IOLockUnlock(a-&gt;lock);

    <span class="enscript-keyword">return</span> ((uintptr_t) pa);
}
    
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOReturn <span class="enscript-function-name">IOSetProcessorCacheMode</span>( task_t task, IOVirtualAddress address,
				  IOByteCount length, IOOptionBits cacheMode )
{
    IOReturn	ret = kIOReturnSuccess;
    ppnum_t	pagenum;

    <span class="enscript-keyword">if</span>( task != kernel_task)
	<span class="enscript-keyword">return</span>( kIOReturnUnsupported );
    <span class="enscript-keyword">if</span> ((address | length) &amp; PAGE_MASK)
    {
<span class="enscript-comment">//	OSReportWithBacktrace(&quot;IOSetProcessorCacheMode(0x%x, 0x%x, 0x%x) fails\n&quot;, address, length, cacheMode);
</span>	<span class="enscript-keyword">return</span>( kIOReturnUnsupported );
    }
    length = round_page(address + length) - trunc_page( address );
    address = trunc_page( address );

    <span class="enscript-comment">// make map mode
</span>    cacheMode = (cacheMode &lt;&lt; kIOMapCacheShift) &amp; kIOMapCacheMask;

    <span class="enscript-keyword">while</span>( (kIOReturnSuccess == ret) &amp;&amp; (length &gt; 0) ) {

	<span class="enscript-comment">// Get the physical page number
</span>	pagenum = pmap_find_phys(kernel_pmap, (addr64_t)address);
	<span class="enscript-keyword">if</span>( pagenum) {
            ret = IOUnmapPages( get_task_map(task), address, page_size );
	    ret = IOMapPages( get_task_map(task), address, ptoa_64(pagenum), page_size, cacheMode );
	} <span class="enscript-keyword">else</span>
	    ret = kIOReturnVMError;

	address += page_size;
	length -= page_size;
    }

    <span class="enscript-keyword">return</span>( ret );
}


IOReturn <span class="enscript-function-name">IOFlushProcessorCache</span>( task_t task, IOVirtualAddress address,
				  IOByteCount length )
{
    <span class="enscript-keyword">if</span>( task != kernel_task)
	<span class="enscript-keyword">return</span>( kIOReturnUnsupported );

    flush_dcache64( (addr64_t) address, (<span class="enscript-type">unsigned</span>) length, false );

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

vm_offset_t <span class="enscript-function-name">OSKernelStackRemaining</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> (ml_stack_remaining());
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/*
 * Spin for indicated number of milliseconds.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSleep</span>(<span class="enscript-type">unsigned</span> milliseconds)
{
    delay_for_interval(milliseconds, kMillisecondScale);
}

<span class="enscript-comment">/*
 * Spin for indicated number of milliseconds, and potentially an
 * additional number of milliseconds up to the leeway values.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSleepWithLeeway</span>(<span class="enscript-type">unsigned</span> intervalMilliseconds, <span class="enscript-type">unsigned</span> leewayMilliseconds)
{
    delay_for_interval_with_leeway(intervalMilliseconds, leewayMilliseconds, kMillisecondScale);
}

<span class="enscript-comment">/*
 * Spin for indicated number of microseconds.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IODelay</span>(<span class="enscript-type">unsigned</span> microseconds)
{
    delay_for_interval(microseconds, kMicrosecondScale);
}

<span class="enscript-comment">/*
 * Spin for indicated number of nanoseconds.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPause</span>(<span class="enscript-type">unsigned</span> nanoseconds)
{
    delay_for_interval(nanoseconds, kNanosecondScale);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_iolog_consputc</span>(<span class="enscript-type">int</span> ch, <span class="enscript-type">void</span> *arg __unused)
{
    cons_putc_locked(ch);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_iolog_logputc</span>(<span class="enscript-type">int</span> ch, <span class="enscript-type">void</span> *arg __unused)
{
    log_putc_locked(ch);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOLog</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
    va_list ap;

    va_start(ap, format);
    IOLogv(format, ap);
    va_end(ap);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOLogv</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, va_list ap)
{
    va_list ap2;

    va_copy(ap2, ap);

    bsd_log_lock();
    __doprnt(format, ap, _iolog_logputc, NULL, 16, TRUE);
    bsd_log_unlock();
    logwakeup();

    __doprnt(format, ap2, _iolog_consputc, NULL, 16, TRUE);
    va_end(ap2);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPanic</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *reason)
{
	panic(<span class="enscript-string">&quot;%s&quot;</span>, reason);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/*
 * Convert a integer constant (typically a #define or enum) to a string.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> noValue[80];	<span class="enscript-comment">// that's pretty
</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">IOFindNameForValue</span>(<span class="enscript-type">int</span> value, <span class="enscript-type">const</span> IONamedValue *regValueArray)
{
	<span class="enscript-keyword">for</span>( ; regValueArray-&gt;name; regValueArray++) {
		<span class="enscript-keyword">if</span>(regValueArray-&gt;value == value)
			<span class="enscript-keyword">return</span>(regValueArray-&gt;name);
	}
	snprintf(noValue, <span class="enscript-keyword">sizeof</span>(noValue), <span class="enscript-string">&quot;0x%x (UNDEFINED)&quot;</span>, value);
	<span class="enscript-keyword">return</span>((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)noValue);
}

IOReturn <span class="enscript-function-name">IOFindValueForName</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *string, 
	<span class="enscript-type">const</span> IONamedValue *regValueArray,
	<span class="enscript-type">int</span> *value)
{
	<span class="enscript-keyword">for</span>( ; regValueArray-&gt;name; regValueArray++) {
		<span class="enscript-keyword">if</span>(!strcmp(regValueArray-&gt;name, string)) {
			*value = regValueArray-&gt;value;
			<span class="enscript-keyword">return</span> kIOReturnSuccess;
		}
	}
	<span class="enscript-keyword">return</span> kIOReturnBadArgument;
}

OSString * <span class="enscript-function-name">IOCopyLogNameForPID</span>(<span class="enscript-type">int</span> pid)
{
    <span class="enscript-type">char</span>   buf[128];
    size_t len;
    snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;pid %d, &quot;</span>, pid);
    len = strlen(buf);
    proc_name(pid, buf + len, <span class="enscript-keyword">sizeof</span>(buf) - len);
    <span class="enscript-keyword">return</span> (OSString::withCString(buf));
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOAlignment <span class="enscript-function-name">IOSizeToAlignment</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size)
{
    <span class="enscript-type">int</span> shift;
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> intsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) * 8;
    
    <span class="enscript-keyword">for</span> (shift = 1; shift &lt; intsize; shift++) {
	<span class="enscript-keyword">if</span> (size &amp; 0x80000000)
	    <span class="enscript-keyword">return</span> (IOAlignment)(intsize - shift);
	size &lt;&lt;= 1;
    }
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">IOAlignmentToSize</span>(IOAlignment align)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size;
    
    <span class="enscript-keyword">for</span> (size = 1; align; align--) {
	size &lt;&lt;= 1;
    }
    <span class="enscript-keyword">return</span> size;
}

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>



</pre>
<hr />
</body></html>