<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOInterruptController.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOInterruptController.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2012 Apple Inc. All rights reserved.
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterrupts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterruptController.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTimeStamp.h&gt;</span>


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOService

<span class="enscript-function-name">OSDefineMetaClassAndAbstractStructors</span>(IOInterruptController, IOService);

<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOInterruptController, 5);

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOReturn <span class="enscript-function-name">IOInterruptController::registerInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source,
						  <span class="enscript-type">void</span> *target,
						  IOInterruptHandler handler,
						  <span class="enscript-type">void</span> *refCon)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  <span class="enscript-type">int</span>               wasDisabledSoft;
  IOReturn          error;
  OSData            *vectorData;
  IOOptionBits      options;
  <span class="enscript-type">bool</span>              canBeShared, shouldBeShared, wasAlreadyRegisterd;

  IOService         *originalNub = NULL; <span class="enscript-comment">// Protected by wasAlreadyRegisterd
</span>  <span class="enscript-type">int</span>               originalSource = 0; <span class="enscript-comment">// Protected by wasAlreadyRegisterd
</span> 

  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  <span class="enscript-comment">// Get the lock for this vector.
</span>  IOLockLock(vector-&gt;interruptLock);
  
  <span class="enscript-comment">// Check if the interrupt source can/should be shared.
</span>  canBeShared = vectorCanBeShared(vectorNumber, vector);
  IODTGetInterruptOptions(nub, source, &amp;options);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
  <span class="enscript-type">int</span>   interruptType;
  <span class="enscript-keyword">if</span> (OSDynamicCast(IOPlatformDevice, getProvider()) &amp;&amp;
      (getInterruptType(nub, source, &amp;interruptType) == kIOReturnSuccess) &amp;&amp;
      (kIOInterruptTypeLevel &amp; interruptType))
  {
    options |= kIODTInterruptShared;
  }
#<span class="enscript-reference">endif</span>
  shouldBeShared = canBeShared &amp;&amp; (options &amp; kIODTInterruptShared);
  wasAlreadyRegisterd = vector-&gt;interruptRegistered;
  
  <span class="enscript-comment">// If the vector is registered and can not be shared return error.
</span>  <span class="enscript-keyword">if</span> (wasAlreadyRegisterd &amp;&amp; !canBeShared) {
    IOLockUnlock(vector-&gt;interruptLock);
    <span class="enscript-keyword">return</span> kIOReturnNoResources;
  }
  
  <span class="enscript-comment">// If this vector is already in use, and can be shared (implied),
</span>  <span class="enscript-comment">// or it is not registered and should be shared,
</span>  <span class="enscript-comment">// register as a shared interrupt.
</span>  <span class="enscript-keyword">if</span> (wasAlreadyRegisterd || shouldBeShared) {
    <span class="enscript-comment">// If this vector is not already shared, break it out.
</span>    <span class="enscript-keyword">if</span> (vector-&gt;sharedController == 0) {
      <span class="enscript-comment">// Make the IOShareInterruptController instance
</span>      vector-&gt;sharedController = <span class="enscript-keyword">new</span> IOSharedInterruptController;
      <span class="enscript-keyword">if</span> (vector-&gt;sharedController == 0) {
        IOLockUnlock(vector-&gt;interruptLock);
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;
      }
      
      <span class="enscript-keyword">if</span> (wasAlreadyRegisterd) {
	<span class="enscript-comment">// Save the nub and source for the original consumer.
</span>	originalNub = vector-&gt;nub;
	originalSource = vector-&gt;source;
	
	<span class="enscript-comment">// Physically disable the interrupt, but mark it as being enabled in the hardware.
</span>	<span class="enscript-comment">// The interruptDisabledSoft now indicates the driver's request for enablement.
</span>	disableVectorHard(vectorNumber, vector);
	vector-&gt;interruptDisabledHard = 0;
      }
      
      <span class="enscript-comment">// Initialize the new shared interrupt controller.
</span>      error = vector-&gt;sharedController-&gt;initInterruptController(<span class="enscript-keyword">this</span>, vectorData);
      <span class="enscript-comment">// If the IOSharedInterruptController could not be initalized,
</span>      <span class="enscript-comment">// if needed, put the original consumer's interrupt back to normal and
</span>      <span class="enscript-comment">// get rid of whats left of the shared controller.
</span>      <span class="enscript-keyword">if</span> (error != kIOReturnSuccess) {
	<span class="enscript-keyword">if</span> (wasAlreadyRegisterd) enableInterrupt(originalNub, originalSource);
        vector-&gt;sharedController-&gt;release();
        vector-&gt;sharedController = 0;
        IOLockUnlock(vector-&gt;interruptLock);
        <span class="enscript-keyword">return</span> error;
      }
      
      <span class="enscript-comment">// If there was an original consumer try to register it on the shared controller.
</span>      <span class="enscript-keyword">if</span> (wasAlreadyRegisterd) {
	error = vector-&gt;sharedController-&gt;registerInterrupt(originalNub,
							    originalSource,
							    vector-&gt;target,
							    vector-&gt;handler,
							    vector-&gt;refCon);
	<span class="enscript-comment">// If the original consumer could not be moved to the shared controller,
</span>	<span class="enscript-comment">// put the original consumor's interrupt back to normal and
</span>	<span class="enscript-comment">// get rid of whats left of the shared controller.
</span>	<span class="enscript-keyword">if</span> (error != kIOReturnSuccess) {
	  <span class="enscript-comment">// Save the driver's interrupt enablement state.
</span>	  wasDisabledSoft = vector-&gt;interruptDisabledSoft;
	  
	  <span class="enscript-comment">// Make the interrupt really hard disabled.
</span>	  vector-&gt;interruptDisabledSoft = 1;
	  vector-&gt;interruptDisabledHard = 1;
	  
	  <span class="enscript-comment">// Enable the original consumer's interrupt if needed.
</span>	  <span class="enscript-keyword">if</span> (!wasDisabledSoft) originalNub-&gt;enableInterrupt(originalSource);
	  enableInterrupt(originalNub, originalSource);
	  
	  vector-&gt;sharedController-&gt;release();
	  vector-&gt;sharedController = 0;
	  IOLockUnlock(vector-&gt;interruptLock);
	  <span class="enscript-keyword">return</span> error;
	}
      }
      
      <span class="enscript-comment">// Fill in vector with the shared controller's info.
</span>      vector-&gt;handler = (IOInterruptHandler)vector-&gt;sharedController-&gt;getInterruptHandlerAddress();
      vector-&gt;nub     = vector-&gt;sharedController;
      vector-&gt;source  = 0;
      vector-&gt;target  = vector-&gt;sharedController;
      vector-&gt;refCon  = 0;
      
      <span class="enscript-comment">// If the interrupt was already registered,
</span>      <span class="enscript-comment">// save the driver's interrupt enablement state.
</span>      <span class="enscript-keyword">if</span> (wasAlreadyRegisterd) wasDisabledSoft = vector-&gt;interruptDisabledSoft;
      <span class="enscript-keyword">else</span> wasDisabledSoft = true;
      
      <span class="enscript-comment">// Do any specific initalization for this vector if it has not yet been used.
</span>      <span class="enscript-keyword">if</span> (!wasAlreadyRegisterd) initVector(vectorNumber, vector);
      
      <span class="enscript-comment">// Make the interrupt really hard disabled.
</span>      vector-&gt;interruptDisabledSoft = 1;
      vector-&gt;interruptDisabledHard = 1;
      vector-&gt;interruptRegistered   = 1;
      
      <span class="enscript-comment">// Enable the original consumer's interrupt if needed.
</span>      <span class="enscript-comment">// originalNub is protected by wasAlreadyRegisterd here (see line 184).
</span>      <span class="enscript-keyword">if</span> (!wasDisabledSoft) originalNub-&gt;enableInterrupt(originalSource);
    }
    
    error = vector-&gt;sharedController-&gt;registerInterrupt(nub, source, target,
                                                        handler, refCon);
    IOLockUnlock(vector-&gt;interruptLock);
    <span class="enscript-keyword">return</span> error;
  }
  
  <span class="enscript-comment">// Fill in vector with the client's info.
</span>  vector-&gt;handler = handler;
  vector-&gt;nub     = nub;
  vector-&gt;source  = source;
  vector-&gt;target  = target;
  vector-&gt;refCon  = refCon;
  
  <span class="enscript-comment">// Do any specific initalization for this vector.
</span>  initVector(vectorNumber, vector);
  
  <span class="enscript-comment">// Get the vector ready.  It starts hard disabled.
</span>  vector-&gt;interruptDisabledHard = 1;
  vector-&gt;interruptDisabledSoft = 1;
  vector-&gt;interruptRegistered   = 1;
  
  IOLockUnlock(vector-&gt;interruptLock);
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOInterruptController::unregisterInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  <span class="enscript-comment">// Get the lock for this vector.
</span>  IOLockLock(vector-&gt;interruptLock);
  
  <span class="enscript-comment">// Return success if it is not already registered
</span>  <span class="enscript-keyword">if</span> (!vector-&gt;interruptRegistered) {
    IOLockUnlock(vector-&gt;interruptLock);
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
  }
  
  <span class="enscript-comment">// Soft disable the source.
</span>  disableInterrupt(nub, source);
  
  <span class="enscript-comment">// Turn the source off at hardware. 
</span>  disableVectorHard(vectorNumber, vector);
  
  <span class="enscript-comment">// Clear all the storage for the vector except for interruptLock.
</span>  vector-&gt;interruptActive = 0;
  vector-&gt;interruptDisabledSoft = 0;
  vector-&gt;interruptDisabledHard = 0;
  vector-&gt;interruptRegistered = 0;
  vector-&gt;nub = 0;
  vector-&gt;source = 0;
  vector-&gt;handler = 0;
  vector-&gt;target = 0;
  vector-&gt;refCon = 0;
  
  IOLockUnlock(vector-&gt;interruptLock);
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOInterruptController::getInterruptType</span>(IOService *nub, <span class="enscript-type">int</span> source,
						 <span class="enscript-type">int</span> *interruptType)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  
  <span class="enscript-keyword">if</span> (interruptType == 0) <span class="enscript-keyword">return</span> kIOReturnBadArgument;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  *interruptType = getVectorType(vectorNumber, vector);
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOInterruptController::enableInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  <span class="enscript-keyword">if</span> (vector-&gt;interruptDisabledSoft) {
    vector-&gt;interruptDisabledSoft = 0;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    OSMemoryBarrier();
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!getPlatform()-&gt;atInterruptLevel()) {
      <span class="enscript-keyword">while</span> (vector-&gt;interruptActive)
	{}
    }
    <span class="enscript-keyword">if</span> (vector-&gt;interruptDisabledHard) {
      vector-&gt;interruptDisabledHard = 0;
      
      enableVector(vectorNumber, vector);
    }
  }
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOInterruptController::disableInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  vector-&gt;interruptDisabledSoft = 1;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
  OSMemoryBarrier();
#<span class="enscript-reference">endif</span>
  
  <span class="enscript-keyword">if</span> (!getPlatform()-&gt;atInterruptLevel()) {
    <span class="enscript-keyword">while</span> (vector-&gt;interruptActive)
	{}
  }
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOInterruptController::causeInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;

  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  causeVector(vectorNumber, vector);
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOInterruptAction <span class="enscript-function-name">IOInterruptController::getInterruptHandlerAddress</span>(<span class="enscript-type">void</span>)
{
  <span class="enscript-keyword">return</span> 0;
}

IOReturn <span class="enscript-function-name">IOInterruptController::handleInterrupt</span>(<span class="enscript-type">void</span> *refCon, IOService *nub,
						<span class="enscript-type">int</span> source)
{
  <span class="enscript-keyword">return</span> kIOReturnInvalid;
}


<span class="enscript-comment">// Methods to be overridden for simplifed interrupt controller subclasses.
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOInterruptController::vectorCanBeShared</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
					      IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
  <span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOInterruptController::initVector</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
				       IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
}

<span class="enscript-type">int</span> <span class="enscript-function-name">IOInterruptController::getVectorType</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
					  IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
  <span class="enscript-keyword">return</span> kIOInterruptTypeEdge;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOInterruptController::disableVectorHard</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
					      IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOInterruptController::enableVector</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
					 IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOInterruptController::causeVector</span>(IOInterruptVectorNumber <span class="enscript-comment">/*vectorNumber*/</span>,
					IOInterruptVector *<span class="enscript-comment">/*vector*/</span>)
{
}


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span>  <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOInterruptController

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOSharedInterruptController, IOInterruptController);

<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedInterruptController, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedInterruptController, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedInterruptController, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedInterruptController, 3);

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOSharedInterruptControllerDefaultVectors</span> (128)

IOReturn <span class="enscript-function-name">IOSharedInterruptController::initInterruptController</span>(IOInterruptController *parentController, OSData *parentSource)
{
  <span class="enscript-type">int</span>      cnt, interruptType;
  IOReturn error;

  reserved = NULL;
  
  <span class="enscript-keyword">if</span> (!super::init())
    <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  <span class="enscript-comment">// Set provider to this so enable/disable nub stuff works.
</span>  provider = <span class="enscript-keyword">this</span>;
  
  <span class="enscript-comment">// Allocate the IOInterruptSource so this can act like a nub.
</span>  _interruptSources = (IOInterruptSource *)IOMalloc(<span class="enscript-keyword">sizeof</span>(IOInterruptSource));
  <span class="enscript-keyword">if</span> (_interruptSources == 0) <span class="enscript-keyword">return</span> kIOReturnNoMemory;
  _numInterruptSources = 1;
  
  <span class="enscript-comment">// Set up the IOInterruptSource to point at this.
</span>  parentController-&gt;retain();
  parentSource-&gt;retain();
  _interruptSources[0].interruptController = parentController;
  _interruptSources[0].vectorData = parentSource;
  
  sourceIsLevel = false;
  error = provider-&gt;getInterruptType(0, &amp;interruptType);
  <span class="enscript-keyword">if</span> (error == kIOReturnSuccess) {
    <span class="enscript-keyword">if</span> (interruptType &amp; kIOInterruptTypeLevel)
      sourceIsLevel = true;
  }
  
  <span class="enscript-comment">// Allocate the memory for the vectors
</span>  numVectors = kIOSharedInterruptControllerDefaultVectors; <span class="enscript-comment">// For now a constant number.
</span>  vectors = (IOInterruptVector *)IOMalloc(numVectors * <span class="enscript-keyword">sizeof</span>(IOInterruptVector));
  <span class="enscript-keyword">if</span> (vectors == NULL) {
    IOFree(_interruptSources, <span class="enscript-keyword">sizeof</span>(IOInterruptSource));
    <span class="enscript-keyword">return</span> kIOReturnNoMemory;
  }
  bzero(vectors, numVectors * <span class="enscript-keyword">sizeof</span>(IOInterruptVector));
  
  <span class="enscript-comment">// Allocate the lock for the controller.
</span>  controllerLock = IOSimpleLockAlloc();
  <span class="enscript-keyword">if</span> (controllerLock == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  <span class="enscript-comment">// Allocate locks for the vectors.
</span>  <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; numVectors; cnt++) {
    vectors[cnt].interruptLock = IOLockAlloc();
    <span class="enscript-keyword">if</span> (vectors[cnt].interruptLock == NULL) {
      <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; numVectors; cnt++) {
	<span class="enscript-keyword">if</span> (vectors[cnt].interruptLock != NULL)
	  IOLockFree(vectors[cnt].interruptLock);
      }
      <span class="enscript-keyword">return</span> kIOReturnNoResources;
    }
  }
  
  numVectors = 0; <span class="enscript-comment">// reset the high water mark for used vectors
</span>  vectorsRegistered = 0;
  vectorsEnabled = 0;
  controllerDisabled = 1;
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::registerInterrupt</span>(IOService *nub,
							<span class="enscript-type">int</span> source,
							<span class="enscript-type">void</span> *target,
							IOInterruptHandler handler,
							<span class="enscript-type">void</span> *refCon)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector = 0;
  OSData            *vectorData;
  IOInterruptState  interruptState;
  
  interruptSources = nub-&gt;_interruptSources;
  
  <span class="enscript-comment">// Find a free vector.
</span>  vectorNumber = kIOSharedInterruptControllerDefaultVectors;
  <span class="enscript-keyword">while</span> (vectorsRegistered != kIOSharedInterruptControllerDefaultVectors) {
    <span class="enscript-keyword">for</span> (vectorNumber = 0; vectorNumber &lt; kIOSharedInterruptControllerDefaultVectors; vectorNumber++) {
      vector = &amp;vectors[vectorNumber];
      
      <span class="enscript-comment">// Get the lock for this vector.
</span>      IOLockLock(vector-&gt;interruptLock);
      
      <span class="enscript-comment">// Is it unregistered?
</span>      <span class="enscript-keyword">if</span> (!vector-&gt;interruptRegistered) <span class="enscript-keyword">break</span>;
      
      <span class="enscript-comment">// Move along to the next one.
</span>      IOLockUnlock(vector-&gt;interruptLock);
    }
    
    <span class="enscript-keyword">if</span> (vectorNumber != kIOSharedInterruptControllerDefaultVectors) <span class="enscript-keyword">break</span>;
  }
  
  <span class="enscript-comment">// Could not find a free one, so give up.
</span>  <span class="enscript-keyword">if</span> (vectorNumber == kIOSharedInterruptControllerDefaultVectors) {
    <span class="enscript-keyword">return</span> kIOReturnNoResources;
  }
  
  <span class="enscript-comment">// Create the vectorData for the IOInterruptSource.
</span>  vectorData = OSData::withBytes(&amp;vectorNumber, <span class="enscript-keyword">sizeof</span>(vectorNumber));
  <span class="enscript-keyword">if</span> (vectorData == 0) {
    <span class="enscript-keyword">return</span> kIOReturnNoMemory;
  }
  
  <span class="enscript-comment">// Fill in the IOInterruptSource with the controller's info.
</span>  interruptSources[source].interruptController = <span class="enscript-keyword">this</span>;
  interruptSources[source].vectorData = vectorData;
  
  <span class="enscript-comment">// Fill in vector with the client's info.
</span>  vector-&gt;handler = handler;
  vector-&gt;nub     = nub;
  vector-&gt;source  = source;
  vector-&gt;target  = target;
  vector-&gt;refCon  = refCon;
  
  <span class="enscript-comment">// Get the vector ready.  It starts off soft disabled.
</span>  vector-&gt;interruptDisabledSoft = 1;
  vector-&gt;interruptRegistered   = 1;
  
  interruptState = IOSimpleLockLockDisableInterrupt(controllerLock);
  <span class="enscript-comment">// Move the high water mark if needed
</span>  <span class="enscript-keyword">if</span> (++vectorsRegistered &gt; numVectors) numVectors = vectorsRegistered;
  IOSimpleLockUnlockEnableInterrupt(controllerLock, interruptState);
  
  IOLockUnlock(vector-&gt;interruptLock);
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::unregisterInterrupt</span>(IOService *nub,
							  <span class="enscript-type">int</span> source)
{
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  IOInterruptState  interruptState;

  <span class="enscript-keyword">for</span> (vectorNumber = 0; vectorNumber &lt; kIOSharedInterruptControllerDefaultVectors; vectorNumber++) {
    vector = &amp;vectors[vectorNumber];

    <span class="enscript-comment">// Get the lock for this vector.
</span>    IOLockLock(vector-&gt;interruptLock);

    <span class="enscript-comment">// Return success if it is not already registered
</span>    <span class="enscript-keyword">if</span> (!vector-&gt;interruptRegistered
     || (vector-&gt;nub != nub) || (vector-&gt;source != source)) {
        IOLockUnlock(vector-&gt;interruptLock);
        <span class="enscript-keyword">continue</span>;
    }

    <span class="enscript-comment">// Soft disable the source and the controller too.
</span>    disableInterrupt(nub, source);

    <span class="enscript-comment">// Clear all the storage for the vector except for interruptLock.
</span>    vector-&gt;interruptActive = 0;
    vector-&gt;interruptDisabledSoft = 0;
    vector-&gt;interruptDisabledHard = 0;
    vector-&gt;interruptRegistered = 0;
    vector-&gt;nub = 0;
    vector-&gt;source = 0;
    vector-&gt;handler = 0;
    vector-&gt;target = 0;
    vector-&gt;refCon = 0;

    interruptState = IOSimpleLockLockDisableInterrupt(controllerLock);
    vectorsRegistered--;
    IOSimpleLockUnlockEnableInterrupt(controllerLock, interruptState);

    <span class="enscript-comment">// Move along to the next one.
</span>    IOLockUnlock(vector-&gt;interruptLock);
  }

  <span class="enscript-comment">// Re-enable the controller if all vectors are enabled.
</span>  <span class="enscript-keyword">if</span> (vectorsEnabled == vectorsRegistered) {
    controllerDisabled = 0;
    provider-&gt;enableInterrupt(0);
  }

  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::getInterruptType</span>(IOService *<span class="enscript-comment">/*nub*/</span>,
						       <span class="enscript-type">int</span> <span class="enscript-comment">/*source*/</span>,
						       <span class="enscript-type">int</span> *interruptType)
{
  <span class="enscript-keyword">return</span> provider-&gt;getInterruptType(0, interruptType);
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::enableInterrupt</span>(IOService *nub,
						      <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  IOInterruptState  interruptState;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  interruptState = IOSimpleLockLockDisableInterrupt(controllerLock);
  <span class="enscript-keyword">if</span> (!vector-&gt;interruptDisabledSoft) {
    IOSimpleLockUnlockEnableInterrupt(controllerLock, interruptState);
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
  }
  
  vector-&gt;interruptDisabledSoft = 0;
  vectorsEnabled++;
  IOSimpleLockUnlockEnableInterrupt(controllerLock, interruptState);
  
  <span class="enscript-keyword">if</span> (controllerDisabled &amp;&amp; (vectorsEnabled == vectorsRegistered)) {
    controllerDisabled = 0;
    provider-&gt;enableInterrupt(0);
  }
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::disableInterrupt</span>(IOService *nub,
						       <span class="enscript-type">int</span> source)
{
  IOInterruptSource *interruptSources;
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  OSData            *vectorData;
  IOInterruptState  interruptState;
  
  interruptSources = nub-&gt;_interruptSources;
  vectorData = interruptSources[source].vectorData;
  vectorNumber = *(IOInterruptVectorNumber *)vectorData-&gt;getBytesNoCopy();
  vector = &amp;vectors[vectorNumber];
  
  interruptState = IOSimpleLockLockDisableInterrupt(controllerLock); 
  <span class="enscript-keyword">if</span> (!vector-&gt;interruptDisabledSoft) {
    vector-&gt;interruptDisabledSoft = 1;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    OSMemoryBarrier();
#<span class="enscript-reference">endif</span>

    vectorsEnabled--;
  }
  IOSimpleLockUnlockEnableInterrupt(controllerLock, interruptState);
  
  <span class="enscript-keyword">if</span> (!getPlatform()-&gt;atInterruptLevel()) {
    <span class="enscript-keyword">while</span> (vector-&gt;interruptActive)
	{}
  }
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOInterruptAction <span class="enscript-function-name">IOSharedInterruptController::getInterruptHandlerAddress</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> OSMemberFunctionCast(IOInterruptAction,
			<span class="enscript-keyword">this</span>, &amp;IOSharedInterruptController::handleInterrupt);
}

IOReturn <span class="enscript-function-name">IOSharedInterruptController::handleInterrupt</span>(<span class="enscript-type">void</span> * <span class="enscript-comment">/*refCon*/</span>,
						      IOService * nub,
						      <span class="enscript-type">int</span> <span class="enscript-comment">/*source*/</span>)
{
  IOInterruptVectorNumber vectorNumber;
  IOInterruptVector *vector;
  
  <span class="enscript-keyword">for</span> (vectorNumber = 0; vectorNumber &lt; numVectors; vectorNumber++) {
    vector = &amp;vectors[vectorNumber];
    
    vector-&gt;interruptActive = 1;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    OSMemoryBarrier();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!vector-&gt;interruptDisabledSoft) {
	  
	  <span class="enscript-comment">// Call the handler if it exists.
</span>	  <span class="enscript-keyword">if</span> (vector-&gt;interruptRegistered) {
		  
		  <span class="enscript-type">bool</span>	trace = (gIOKitTrace &amp; kIOTraceInterrupts) ? true : false;
		  
		  <span class="enscript-keyword">if</span> (trace)
			  IOTimeStampStartConstant(IODBG_INTC(IOINTC_HANDLER),
									   (uintptr_t) vectorNumber, (uintptr_t) vector-&gt;handler, (uintptr_t)vector-&gt;target);
		  
		  <span class="enscript-comment">// Call handler.
</span>		  vector-&gt;handler(vector-&gt;target, vector-&gt;refCon, vector-&gt;nub, vector-&gt;source);
		  
		  <span class="enscript-keyword">if</span> (trace)
			  IOTimeStampEndConstant(IODBG_INTC(IOINTC_HANDLER),
									 (uintptr_t) vectorNumber, (uintptr_t) vector-&gt;handler, (uintptr_t)vector-&gt;target);
		  
		}
	}
    
    vector-&gt;interruptActive = 0;
  }
  
  <span class="enscript-comment">// if any of the vectors are dissabled, then dissable this controller.
</span>  IOSimpleLockLock(controllerLock);
  <span class="enscript-keyword">if</span> (vectorsEnabled != vectorsRegistered) {
    nub-&gt;disableInterrupt(0);
    controllerDisabled = 1;
  }
  IOSimpleLockUnlock(controllerLock);
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

</pre>
<hr />
</body></html>