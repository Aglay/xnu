<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOServicePM.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOServicePM.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMessage.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOEventSource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOWorkLoop.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCommand.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTimeStamp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReportMacros.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMlog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMinformee.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMinformeeList.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPowerConnection.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/RootDomain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMPrivate.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

<span class="enscript-comment">// Required for notification instrumentation
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePrivate.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePMPrivate.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">settle_timer_expired</span>(thread_call_param_t, thread_call_param_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">idle_timer_expired</span>(thread_call_param_t, thread_call_param_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tellKernelClientApplier</span>(OSObject * object, <span class="enscript-type">void</span> * arg);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tellAppClientApplier</span>(OSObject * object, <span class="enscript-type">void</span> * arg);

<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">computeTimeDeltaNS</span>( <span class="enscript-type">const</span> AbsoluteTime * start )
{
    AbsoluteTime    now;
    uint64_t        nsec;

    clock_get_uptime(&amp;now);
    SUB_ABSOLUTETIME(&amp;now, start);
    absolutetime_to_nanoseconds(now, &amp;nsec);
    <span class="enscript-keyword">return</span> nsec;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PM_VARS_SUPPORT</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOPMprot, OSObject)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// Globals
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                  gIOPMInitialized       = false;
<span class="enscript-type">static</span> uint32_t              gIOPMBusyRequestCount  = 0;
<span class="enscript-type">static</span> uint32_t              gIOPMWorkInvokeCount   = 0;
<span class="enscript-type">static</span> uint32_t              gIOPMTickleGeneration  = 0;
<span class="enscript-type">static</span> IOWorkLoop *          gIOPMWorkLoop          = 0;
<span class="enscript-type">static</span> IOPMRequestQueue *    gIOPMRequestQueue      = 0;
<span class="enscript-type">static</span> IOPMRequestQueue *    gIOPMReplyQueue        = 0;
<span class="enscript-type">static</span> IOPMWorkQueue *       gIOPMWorkQueue         = 0;
<span class="enscript-type">static</span> IOPMCompletionQueue * gIOPMCompletionQueue   = 0;
<span class="enscript-type">static</span> IOPMRequest *         gIOPMRequest           = 0;
<span class="enscript-type">static</span> IOService *           gIOPMRootNode          = 0;
<span class="enscript-type">static</span> IOPlatformExpert *    gPlatform              = 0;

<span class="enscript-type">static</span> <span class="enscript-type">char</span>                  gIOSpinDumpKextName[128];
<span class="enscript-type">static</span> <span class="enscript-type">char</span>                  gIOSpinDumpDelayType[16];
<span class="enscript-type">static</span> uint32_t              gIOSpinDumpDelayDuration = 0;

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_STRING</span>(_debug, OID_AUTO, swd_kext_name,
        CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
        &amp;gIOSpinDumpKextName, <span class="enscript-keyword">sizeof</span>(gIOSpinDumpKextName), <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_STRING</span>(_debug, OID_AUTO, swd_delay_type,
        CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
        &amp;gIOSpinDumpDelayType, <span class="enscript-keyword">sizeof</span>(gIOSpinDumpDelayType), <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, swd_delay_duration,
        CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
        &amp;gIOSpinDumpDelayDuration, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">const</span> OSSymbol *             gIOPMPowerClientDevice     = 0;
<span class="enscript-type">const</span> OSSymbol *             gIOPMPowerClientDriver     = 0;
<span class="enscript-type">const</span> OSSymbol *             gIOPMPowerClientChildProxy = 0;
<span class="enscript-type">const</span> OSSymbol *             gIOPMPowerClientChildren   = 0;
<span class="enscript-type">const</span> OSSymbol *             gIOPMPowerClientRootDomain = 0;

<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol *      gIOPMPowerClientAdvisoryTickle = 0;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>                  gIOPMAdvisoryTickleEnabled = true;
<span class="enscript-type">static</span> thread_t              gIOPMWatchDogThread        = NULL;
uint32_t                     gCanSleepTimeout           = 0;

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">getPMRequestType</span>( <span class="enscript-type">void</span> )
{
    uint32_t type = kIOPMRequestTypeInvalid;
    <span class="enscript-keyword">if</span> (gIOPMRequest)
        type = gIOPMRequest-&gt;getType();
    <span class="enscript-keyword">return</span> type;
}

<span class="enscript-type">static</span> IOPMRequestTag <span class="enscript-function-name">getPMRequestTag</span>( <span class="enscript-type">void</span> )
{
    IOPMRequestTag tag = 0;
    <span class="enscript-keyword">if</span> (gIOPMRequest &amp;&amp;
        (gIOPMRequest-&gt;getType() == kIOPMRequestTypeRequestPowerStateOverride))
    {
        tag = gIOPMRequest-&gt;fRequestTag;
    }
    <span class="enscript-keyword">return</span> tag;
}

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, pmtimeout, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;gCanSleepTimeout, 0, <span class="enscript-string">&quot;Power Management Timeout&quot;</span>);

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// Macros
</span><span class="enscript-comment">//******************************************************************************
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_ERROR</span>(x...)              do { kprintf(x);IOLog(x); \
                                    } <span class="enscript-keyword">while</span> (false)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOG</span>(x...)                do { kprintf(x); } while (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOG1</span>(x...)               do {  \
                                    <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug) \
                                        kprintf(x); } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOG2</span>(x...)               do {  \
                                    <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug) \
                                        kprintf(x); } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOG3</span>(x...)               do { kprintf(x); } while (false)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOG3</span>(x...)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RD_LOG</span>(x...)                do { \
                                    <span class="enscript-keyword">if</span> ((kIOLogPMRootDomain &amp; gIOKitDebug) &amp;&amp; \
                                        (getPMRootDomain() == <span class="enscript-keyword">this</span>)) { \
                                        kprintf(<span class="enscript-string">&quot;PMRD: &quot;</span> x); \
                                    }} <span class="enscript-keyword">while</span> (false)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_ASSERT_IN_GATE</span>(x)          \
<span class="enscript-keyword">do</span> {                                  \
    assert(gIOPMWorkLoop-&gt;inGate());  \
} <span class="enscript-keyword">while</span>(false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOCK</span>()                   IOLockLock(fPMLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_UNLOCK</span>()                 IOLockUnlock(fPMLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOCK_SLEEP</span>(event, dl)    IOLockSleepDeadline(fPMLock, event, dl, THREAD_UNINT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_LOCK_WAKEUP</span>(event)       IOLockWakeup(fPMLock, event, false)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">us_per_s</span>                    1000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ns_per_us</span>                   1000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">k30Seconds</span>                  (30*us_per_s)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">k5Seconds</span>                   ( 5*us_per_s)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kCanSleepMaxTimeReq</span>         k30Seconds
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMaxTimeRequested</span>           k30Seconds
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMinAckTimeoutTicks</span>         (10*1000000)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMTardyAckSPSKey</span>         <span class="enscript-string">&quot;IOPMTardyAckSetPowerState&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMTardyAckPSCKey</span>         <span class="enscript-string">&quot;IOPMTardyAckPowerStateChange&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kPwrMgtKey</span>                  <span class="enscript-string">&quot;IOPowerManagement&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">OUR_PMLog</span>(t, a, b) do {          \
    <span class="enscript-keyword">if</span> (gIOKitDebug &amp; kIOLogPower)       \
        pwrMgt-&gt;pmPrint(t, a, b);        \
    <span class="enscript-keyword">if</span> (gIOKitTrace &amp; kIOTracePowerMgmt) \
        pwrMgt-&gt;pmTrace(t, a, b);        \
    } <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NS_TO_MS</span>(nsec)              ((int)((nsec) / 1000000ULL))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NS_TO_US</span>(nsec)              ((int)((nsec) / 1000ULL))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SUPPORT_IDLE_CANCEL</span>         1

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMPowerStateMax</span>          0xFFFFFFFF
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kInvalidTicklePowerState</span>    kIOPMPowerStateMax

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kNoTickleCancelWindow</span>       (60ULL * 1000ULL * 1000ULL * 1000ULL)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IS_PM_ROOT</span>                  (this == gIOPMRootNode)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IS_ROOT_DOMAIN</span>              (getPMRootDomain() == this)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IS_POWER_DROP</span>               (StateOrder(fHeadNotePowerState) &lt; StateOrder(fCurrentPowerState))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IS_POWER_RISE</span>               (StateOrder(fHeadNotePowerState) &gt; StateOrder(fCurrentPowerState))

<span class="enscript-comment">// log setPowerStates longer than (ns):
</span>#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>          (300ULL * 1000ULL * 1000ULL)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>          (50ULL * 1000ULL * 1000ULL)
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">// log app responses longer than (ns):
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>      (100ULL * 1000ULL * 1000ULL)
<span class="enscript-comment">// use message tracer to log messages longer than (ns):
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_MSG_TRACER</span> (3 * 1000ULL * 1000ULL * 1000ULL)

<span class="enscript-type">enum</span> {
    kReserveDomainPower = 1
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MS_PUSH</span>(n)  \
    <span class="enscript-keyword">do</span> { assert(kIOPM_BadMachineState == fSavedMachineState); \
         assert(kIOPM_BadMachineState != n); \
         fSavedMachineState = n; } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MS_POP</span>()    \
    <span class="enscript-keyword">do</span> { assert(kIOPM_BadMachineState != fSavedMachineState); \
         fMachineState = fSavedMachineState; \
         fSavedMachineState = kIOPM_BadMachineState; } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_ACTION_0</span>(a) \
    <span class="enscript-keyword">do</span> { <span class="enscript-keyword">if</span> (fPMActions.a) { \
         (fPMActions.a)(fPMActions.target, <span class="enscript-keyword">this</span>, &amp;fPMActions); } \
         } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_ACTION_2</span>(a, x, y) \
    <span class="enscript-keyword">do</span> { <span class="enscript-keyword">if</span> (fPMActions.a) { \
         (fPMActions.a)(fPMActions.target, <span class="enscript-keyword">this</span>, &amp;fPMActions, x, y, \
            getPMRequestTag()); } \
         } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PM_ACTION_3</span>(a, x, y, z) \
    <span class="enscript-keyword">do</span> { <span class="enscript-keyword">if</span> (fPMActions.a) { \
         (fPMActions.a)(fPMActions.target, <span class="enscript-keyword">this</span>, &amp;fPMActions, x, y, z); } \
         } <span class="enscript-keyword">while</span> (false)

<span class="enscript-type">static</span> OSNumber * <span class="enscript-function-name">copyClientIDForNotification</span>(
    OSObject *object,
    IOPMInterestContext *context);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">logClientIDForNotification</span>(
    OSObject *object,
    IOPMInterestContext *context,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *logString);

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// PM machine states
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Check kgmacros after modifying machine states.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">enum</span> {
    kIOPM_Finished                                      = 0,

    kIOPM_OurChangeTellClientsPowerDown                 = 1,
    kIOPM_OurChangeTellUserPMPolicyPowerDown            = 2,
    kIOPM_OurChangeTellPriorityClientsPowerDown         = 3,
    kIOPM_OurChangeNotifyInterestedDriversWillChange    = 4,
    kIOPM_OurChangeSetPowerState                        = 5,
    kIOPM_OurChangeWaitForPowerSettle                   = 6,
    kIOPM_OurChangeNotifyInterestedDriversDidChange     = 7,
    kIOPM_OurChangeTellCapabilityDidChange              = 8,
    kIOPM_OurChangeFinish                               = 9,

    kIOPM_ParentChangeTellPriorityClientsPowerDown      = 10,
    kIOPM_ParentChangeNotifyInterestedDriversWillChange = 11,
    kIOPM_ParentChangeSetPowerState                     = 12,
    kIOPM_ParentChangeWaitForPowerSettle                = 13,
    kIOPM_ParentChangeNotifyInterestedDriversDidChange  = 14,
    kIOPM_ParentChangeTellCapabilityDidChange           = 15,
    kIOPM_ParentChangeAcknowledgePowerChange            = 16,

    kIOPM_NotifyChildrenStart                           = 17,
    kIOPM_NotifyChildrenOrdered                         = 18,
    kIOPM_NotifyChildrenDelayed                         = 19,
    kIOPM_SyncTellClientsPowerDown                      = 20,
    kIOPM_SyncTellPriorityClientsPowerDown              = 21,
    kIOPM_SyncNotifyWillChange                          = 22,
    kIOPM_SyncNotifyDidChange                           = 23,
    kIOPM_SyncTellCapabilityDidChange                   = 24,
    kIOPM_SyncFinish                                    = 25,
    kIOPM_TellCapabilityChangeDone                      = 26,
    kIOPM_DriverThreadCallDone                          = 27,

    kIOPM_BadMachineState                               = 0xFFFFFFFF
};

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] PMinit
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Initialize power management.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PMinit</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> ( !initialized )
    {
        <span class="enscript-keyword">if</span> ( !gIOPMInitialized )
        {
            gPlatform = getPlatform();
            gIOPMWorkLoop = IOWorkLoop::workLoop();
            <span class="enscript-keyword">if</span> (gIOPMWorkLoop)
            {
                gIOPMRequestQueue = IOPMRequestQueue::create(
                    <span class="enscript-keyword">this</span>, OSMemberFunctionCast(IOPMRequestQueue::Action,
                        <span class="enscript-keyword">this</span>, &amp;IOService::actionPMRequestQueue));

                gIOPMReplyQueue = IOPMRequestQueue::create(
                    <span class="enscript-keyword">this</span>, OSMemberFunctionCast(IOPMRequestQueue::Action,
                        <span class="enscript-keyword">this</span>, &amp;IOService::actionPMReplyQueue));

                gIOPMWorkQueue = IOPMWorkQueue::create(<span class="enscript-keyword">this</span>,
                    OSMemberFunctionCast(IOPMWorkQueue::Action, <span class="enscript-keyword">this</span>,
                        &amp;IOService::actionPMWorkQueueInvoke),
                    OSMemberFunctionCast(IOPMWorkQueue::Action, <span class="enscript-keyword">this</span>,
                        &amp;IOService::actionPMWorkQueueRetire));

                gIOPMCompletionQueue = IOPMCompletionQueue::create(
                    <span class="enscript-keyword">this</span>, OSMemberFunctionCast(IOPMCompletionQueue::Action,
                        <span class="enscript-keyword">this</span>, &amp;IOService::actionPMCompletionQueue));

                <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;addEventSource(gIOPMRequestQueue) !=
                    kIOReturnSuccess)
                {
                    gIOPMRequestQueue-&gt;release();
                    gIOPMRequestQueue = 0;
                }

                <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;addEventSource(gIOPMReplyQueue) !=
                    kIOReturnSuccess)
                {
                    gIOPMReplyQueue-&gt;release();
                    gIOPMReplyQueue = 0;
                }

                <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;addEventSource(gIOPMWorkQueue) !=
                    kIOReturnSuccess)
                {
                    gIOPMWorkQueue-&gt;release();
                    gIOPMWorkQueue = 0;
                }

                <span class="enscript-comment">// Must be added after the work queue, which pushes request
</span>                <span class="enscript-comment">// to the completion queue without signaling the work loop.
</span>                <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;addEventSource(gIOPMCompletionQueue) !=
                    kIOReturnSuccess)
                {
                    gIOPMCompletionQueue-&gt;release();
                    gIOPMCompletionQueue = 0;
                }

                gIOPMPowerClientDevice =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;DevicePowerState&quot;</span> );

                gIOPMPowerClientDriver =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;DriverPowerState&quot;</span> );

                gIOPMPowerClientChildProxy =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;ChildProxyPowerState&quot;</span> );

                gIOPMPowerClientChildren =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;ChildrenPowerState&quot;</span> );

                gIOPMPowerClientAdvisoryTickle =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;AdvisoryTicklePowerState&quot;</span> );

                gIOPMPowerClientRootDomain =
                    <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy( <span class="enscript-string">&quot;RootDomainPower&quot;</span> );

                gIOSpinDumpKextName[0] = <span class="enscript-string">'\0'</span>;
                gIOSpinDumpDelayType[0] = <span class="enscript-string">'\0'</span>;
            }

            <span class="enscript-keyword">if</span> (gIOPMRequestQueue &amp;&amp; gIOPMReplyQueue &amp;&amp; gIOPMCompletionQueue)
                gIOPMInitialized = true;
        }
        <span class="enscript-keyword">if</span> (!gIOPMInitialized)
            <span class="enscript-keyword">return</span>;

        pwrMgt = <span class="enscript-keyword">new</span> IOServicePM;
        pwrMgt-&gt;init();
        setProperty(kPwrMgtKey, pwrMgt);

        queue_init(&amp;pwrMgt-&gt;WorkChain);
        queue_init(&amp;pwrMgt-&gt;RequestHead);
        queue_init(&amp;pwrMgt-&gt;PMDriverCallQueue);

        fOwner                      = <span class="enscript-keyword">this</span>;
        fPMLock                     = IOLockAlloc();
        fInterestedDrivers          = <span class="enscript-keyword">new</span> IOPMinformeeList;
        fInterestedDrivers-&gt;initialize();
        fDesiredPowerState          = kPowerStateZero;
        fDeviceDesire               = kPowerStateZero;
        fInitialPowerChange         = true;
        fInitialSetPowerState       = true;
        fPreviousRequestPowerFlags  = 0;
        fDeviceOverrideEnabled      = false;
        fMachineState               = kIOPM_Finished;
        fSavedMachineState          = kIOPM_BadMachineState;
        fIdleTimerMinPowerState     = kPowerStateZero;
        fActivityLock               = IOLockAlloc();
        fStrictTreeOrder            = false;
        fActivityTicklePowerState   = kInvalidTicklePowerState;
        fAdvisoryTicklePowerState   = kInvalidTicklePowerState;
        fControllingDriver          = NULL;
        fPowerStates                = NULL;
        fNumberOfPowerStates        = 0;
        fCurrentPowerState          = kPowerStateZero;
        fParentsCurrentPowerFlags   = 0;
        fMaxPowerState              = kPowerStateZero;
        fName                       = getName();
        fParentsKnowState           = false;
        fSerialNumber               = 0;
        fResponseArray              = NULL;
        fNotifyClientArray          = NULL;
        fCurrentPowerConsumption    = kIOPMUnknown;
        fOverrideMaxPowerState      = kIOPMPowerStateMax;

        <span class="enscript-keyword">if</span> (!gIOPMRootNode &amp;&amp; (getParentEntry(gIOPowerPlane) == getRegistryRoot()))
        {
            gIOPMRootNode = <span class="enscript-keyword">this</span>;
            fParentsKnowState = true;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (getProperty(kIOPMResetPowerStateOnWakeKey) == kOSBooleanTrue)
        {
            fResetPowerStateOnWake = true;
        }

        <span class="enscript-keyword">if</span> (IS_ROOT_DOMAIN)
        {
            fWatchdogTimer = thread_call_allocate(
                  &amp;IOService::watchdog_timer_expired, (thread_call_param_t)<span class="enscript-keyword">this</span>);
        }

        fAckTimer = thread_call_allocate(
            &amp;IOService::ack_timer_expired, (thread_call_param_t)<span class="enscript-keyword">this</span>);
        fSettleTimer = thread_call_allocate(
            &amp;settle_timer_expired, (thread_call_param_t)<span class="enscript-keyword">this</span>);
        fIdleTimer = thread_call_allocate(
            &amp;idle_timer_expired, (thread_call_param_t)<span class="enscript-keyword">this</span>);
        fDriverCallEntry = thread_call_allocate(
            (thread_call_func_t) &amp;IOService::pmDriverCallout, <span class="enscript-keyword">this</span>);
        assert(fDriverCallEntry);
        <span class="enscript-keyword">if</span> (kIOKextSpinDump &amp; gIOKitDebug)
        {
            fSpinDumpTimer = thread_call_allocate(
                &amp;IOService::spindump_timer_expired, (thread_call_param_t)<span class="enscript-keyword">this</span>);
        }

        <span class="enscript-comment">// Check for powerChangeDone override.
</span>        <span class="enscript-keyword">if</span> (OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                getResourceService(), &amp;IOService::powerChangeDone) !=
              OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                <span class="enscript-keyword">this</span>, &amp;IOService::powerChangeDone))
        {
            fPCDFunctionOverride = true;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PM_VARS_SUPPORT</span>
        IOPMprot * prot = <span class="enscript-keyword">new</span> IOPMprot;
        <span class="enscript-keyword">if</span> (prot)
        {
            prot-&gt;init();
            prot-&gt;ourName = fName;
            prot-&gt;thePlatform = gPlatform;
            fPMVars = prot;
            pm_vars = prot;
        }
#<span class="enscript-reference">else</span>
        pm_vars = (<span class="enscript-type">void</span> *) (uintptr_t) true;
#<span class="enscript-reference">endif</span>

        initialized = true;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] PMfree
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Free the data created by PMinit. Only called from IOService::free().
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PMfree</span>( <span class="enscript-type">void</span> )
{
    initialized = false;
    pm_vars = 0;

    <span class="enscript-keyword">if</span> ( pwrMgt )
    {
        assert(fMachineState == kIOPM_Finished);
        assert(fInsertInterestSet == NULL);
        assert(fRemoveInterestSet == NULL);
        assert(fNotifyChildArray  == NULL);
        assert(queue_empty(&amp;pwrMgt-&gt;RequestHead));
        assert(queue_empty(&amp;fPMDriverCallQueue));

        <span class="enscript-keyword">if</span> (fWatchdogTimer) {
            thread_call_cancel(fWatchdogTimer);
            thread_call_free(fWatchdogTimer);
            fWatchdogTimer = NULL;
        }

        <span class="enscript-keyword">if</span> ( fSettleTimer ) {
            thread_call_cancel(fSettleTimer);
            thread_call_free(fSettleTimer);
            fSettleTimer = NULL;
        }
        <span class="enscript-keyword">if</span> ( fAckTimer ) {
            thread_call_cancel(fAckTimer);
            thread_call_free(fAckTimer);
            fAckTimer = NULL;
        }
        <span class="enscript-keyword">if</span> ( fIdleTimer ) {
            thread_call_cancel(fIdleTimer);
            thread_call_free(fIdleTimer);
            fIdleTimer = NULL;
        }
        <span class="enscript-keyword">if</span> ( fDriverCallEntry ) {
            thread_call_free(fDriverCallEntry);
            fDriverCallEntry = NULL;
        }
        <span class="enscript-keyword">if</span> ( fSpinDumpTimer ) {
            thread_call_cancel(fSpinDumpTimer);
            thread_call_free(fSpinDumpTimer);
            fSpinDumpTimer = NULL;
        }
        <span class="enscript-keyword">if</span> ( fPMLock ) {
            IOLockFree(fPMLock);
            fPMLock = NULL;
        }
        <span class="enscript-keyword">if</span> ( fActivityLock ) {
            IOLockFree(fActivityLock);
            fActivityLock = NULL;
        }
        <span class="enscript-keyword">if</span> ( fInterestedDrivers ) {
            fInterestedDrivers-&gt;release();
            fInterestedDrivers = NULL;
        }
        <span class="enscript-keyword">if</span> (fDriverCallParamSlots &amp;&amp; fDriverCallParamPtr) {
            IODelete(fDriverCallParamPtr, DriverCallParam, fDriverCallParamSlots);
            fDriverCallParamPtr = 0;
            fDriverCallParamSlots = 0;
        }
        <span class="enscript-keyword">if</span> ( fResponseArray ) {
            fResponseArray-&gt;release();
            fResponseArray = NULL;
        }
        <span class="enscript-keyword">if</span> ( fNotifyClientArray ) {
            fNotifyClientArray-&gt;release();
            fNotifyClientArray = NULL;
        }
        <span class="enscript-keyword">if</span> (fPowerStates &amp;&amp; fNumberOfPowerStates) {
            IODelete(fPowerStates, IOPMPSEntry, fNumberOfPowerStates);
            fNumberOfPowerStates = 0;
            fPowerStates = NULL;
        }
        <span class="enscript-keyword">if</span> (fPowerClients) {
            fPowerClients-&gt;release();
            fPowerClients = 0;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PM_VARS_SUPPORT</span>
        <span class="enscript-keyword">if</span> (fPMVars)
        {
            fPMVars-&gt;release();
            fPMVars = 0;
        }
#<span class="enscript-reference">endif</span>

        pwrMgt-&gt;release();
        pwrMgt = 0;
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PMDebug</span>( uint32_t event, uintptr_t param1, uintptr_t param2 )
{
    OUR_PMLog(event, param1, param2);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] joinPMtree
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A policy-maker calls its nub here when initializing, to be attached into
</span><span class="enscript-comment">// the power management hierarchy.  The default function is to call the
</span><span class="enscript-comment">// platform expert, which knows how to do it.  This method is overridden
</span><span class="enscript-comment">// by a nub subclass which may either know how to do it, or may need to
</span><span class="enscript-comment">// take other action.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This may be the only &quot;power management&quot; method used in a nub,
</span><span class="enscript-comment">// meaning it may not be initialized for power management.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::joinPMtree</span>( IOService * driver )
{
    IOPlatformExpert *  platform;

    platform = getPlatform();
    assert(platform != 0);
    platform-&gt;PMRegisterDevice(<span class="enscript-keyword">this</span>, driver);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] youAreRoot
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power Managment is informing us that we are the root power domain.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::youAreRoot</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> IOPMNoErr;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] PMstop
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Immediately stop driver callouts. Schedule an async stop request to detach
</span><span class="enscript-comment">// from power plane.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PMstop</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span>;

    PM_LOCK();

    <span class="enscript-keyword">if</span> (fLockedFlags.PMStop)
    {
        PM_LOG2(<span class="enscript-string">&quot;%s: PMstop() already stopped\n&quot;</span>, fName);
        PM_UNLOCK();
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Inhibit future driver calls.
</span>    fLockedFlags.PMStop = true;

    <span class="enscript-comment">// Wait for all prior driver calls to finish.
</span>    waitForPMDriverCall();

    PM_UNLOCK();

    <span class="enscript-comment">// The rest of the work is performed async.
</span>    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypePMStop );
    <span class="enscript-keyword">if</span> (request)
    {
        PM_LOG2(<span class="enscript-string">&quot;%s: %p PMstop\n&quot;</span>, getName(), OBFUSCATE(<span class="enscript-keyword">this</span>));
        submitPMRequest( request );
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handlePMstop
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Disconnect the node from all parents and children in the power plane.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handlePMstop</span>( IOPMRequest * request )
{
    OSIterator *        iter;
    OSObject *          next;
    IOPowerConnection * connection;
    IOService *         theChild;
    IOService *         theParent;

    PM_ASSERT_IN_GATE();
    PM_LOG2(<span class="enscript-string">&quot;%s: %p %s start\n&quot;</span>, getName(), OBFUSCATE(<span class="enscript-keyword">this</span>), __FUNCTION__);

    <span class="enscript-comment">// remove driver from prevent system sleep lists
</span>    getPMRootDomain()-&gt;updatePreventIdleSleepList(<span class="enscript-keyword">this</span>, false);
    getPMRootDomain()-&gt;updatePreventSystemSleepList(<span class="enscript-keyword">this</span>, false);

    <span class="enscript-comment">// remove the property
</span>    removeProperty(kPwrMgtKey);

    <span class="enscript-comment">// detach parents
</span>    iter = getParentIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ( (next = iter-&gt;getNextObject()) )
        {
            <span class="enscript-keyword">if</span> ( (connection = OSDynamicCast(IOPowerConnection, next)) )
            {
                theParent = (IOService *)connection-&gt;copyParentEntry(gIOPowerPlane);
                <span class="enscript-keyword">if</span> ( theParent )
                {
                    theParent-&gt;removePowerChild(connection);
                    theParent-&gt;release();
                }
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-comment">// detach IOConnections
</span>    detachAbove( gIOPowerPlane );

    <span class="enscript-comment">// no more power state changes
</span>    fParentsKnowState = false;

    <span class="enscript-comment">// detach children
</span>    iter = getChildIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ( (next = iter-&gt;getNextObject()) )
        {
            <span class="enscript-keyword">if</span> ( (connection = OSDynamicCast(IOPowerConnection, next)) )
            {
                theChild = ((IOService *)(connection-&gt;copyChildEntry(gIOPowerPlane)));
                <span class="enscript-keyword">if</span> ( theChild )
                {
                    <span class="enscript-comment">// detach nub from child
</span>                    connection-&gt;detachFromChild(theChild, gIOPowerPlane);
                    theChild-&gt;release();
                }
                <span class="enscript-comment">// detach us from nub
</span>                detachFromChild(connection, gIOPowerPlane);
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-comment">// Remove all interested drivers from the list, including the power
</span>    <span class="enscript-comment">// controlling driver.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// Usually, the controlling driver and the policy-maker functionality
</span>    <span class="enscript-comment">// are implemented by the same object, and without the deregistration,
</span>    <span class="enscript-comment">// the object will be holding an extra retain on itself, and cannot
</span>    <span class="enscript-comment">// be freed.
</span>
    <span class="enscript-keyword">if</span> ( fInterestedDrivers )
    {
        IOPMinformeeList *  list = fInterestedDrivers;
        IOPMinformee *      item;

        PM_LOCK();
        <span class="enscript-keyword">while</span> ((item = list-&gt;firstInList()))
        {
            list-&gt;removeFromList(item-&gt;whatObject);
        }
        PM_UNLOCK();
    }

    <span class="enscript-comment">// Clear idle period to prevent idleTimerExpired() from servicing
</span>    <span class="enscript-comment">// idle timer expirations.
</span>
    fIdleTimerPeriod = 0;
    <span class="enscript-keyword">if</span> (fIdleTimer &amp;&amp; thread_call_cancel(fIdleTimer))
        release();

    PM_LOG2(<span class="enscript-string">&quot;%s: %p %s done\n&quot;</span>, getName(), OBFUSCATE(<span class="enscript-keyword">this</span>), __FUNCTION__);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] addPowerChild
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power Management is informing us who our children are.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::addPowerChild</span>( IOService * child )
{
    IOPowerConnection * connection  = 0;
    IOPMRequest *       requests[3] = {0, 0, 0};
    OSIterator *        iter;
    <span class="enscript-type">bool</span>                ok = true;

    <span class="enscript-keyword">if</span> (!child)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    <span class="enscript-keyword">if</span> (!initialized || !child-&gt;initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    OUR_PMLog( kPMLogAddChild, (uintptr_t) child, 0 );

    <span class="enscript-keyword">do</span> {
        <span class="enscript-comment">// Is this child already one of our children?
</span>
        iter = child-&gt;getParentIterator( gIOPowerPlane );
        <span class="enscript-keyword">if</span> ( iter )
        {
            IORegistryEntry *   entry;
            OSObject *          next;

            <span class="enscript-keyword">while</span> ((next = iter-&gt;getNextObject()))
            {
                <span class="enscript-keyword">if</span> ((entry = OSDynamicCast(IORegistryEntry, next)) &amp;&amp;
                    isChild(entry, gIOPowerPlane))
                {
                    ok = false;
                    <span class="enscript-keyword">break</span>;
                }
            }
            iter-&gt;release();
        }
        <span class="enscript-keyword">if</span> (!ok)
        {
            PM_LOG(<span class="enscript-string">&quot;%s: %s (%p) is already a child\n&quot;</span>,
                getName(), child-&gt;getName(), OBFUSCATE(child));
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Add the child to the power plane immediately, but the
</span>        <span class="enscript-comment">// joining connection is marked as not ready.
</span>        <span class="enscript-comment">// We want the child to appear in the power plane before
</span>        <span class="enscript-comment">// returning to the caller, but don't want the caller to
</span>        <span class="enscript-comment">// block on the PM work loop.
</span>
        connection = <span class="enscript-keyword">new</span> IOPowerConnection;
        <span class="enscript-keyword">if</span> (!connection)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Create a chain of PM requests to perform the bottom-half
</span>        <span class="enscript-comment">// work from the PM work loop.
</span>
        requests[0] = acquirePMRequest(
                    <span class="enscript-comment">/* target */</span> <span class="enscript-keyword">this</span>,
                    <span class="enscript-comment">/* type */</span>   kIOPMRequestTypeAddPowerChild1 );

        requests[1] = acquirePMRequest(
                    <span class="enscript-comment">/* target */</span> child,
                    <span class="enscript-comment">/* type */</span>   kIOPMRequestTypeAddPowerChild2 );

        requests[2] = acquirePMRequest(
                    <span class="enscript-comment">/* target */</span> <span class="enscript-keyword">this</span>,
                    <span class="enscript-comment">/* type */</span>   kIOPMRequestTypeAddPowerChild3 );

        <span class="enscript-keyword">if</span> (!requests[0] || !requests[1] || !requests[2])
            <span class="enscript-keyword">break</span>;

        requests[0]-&gt;attachNextRequest( requests[1] );
        requests[1]-&gt;attachNextRequest( requests[2] );

        connection-&gt;init();
        connection-&gt;start(<span class="enscript-keyword">this</span>);
        connection-&gt;setAwaitingAck(false);
        connection-&gt;setReadyFlag(false);

        attachToChild( connection, gIOPowerPlane );
        connection-&gt;attachToChild( child, gIOPowerPlane );

        <span class="enscript-comment">// connection needs to be released
</span>        requests[0]-&gt;fArg0 = connection;
        requests[1]-&gt;fArg0 = connection;
        requests[2]-&gt;fArg0 = connection;

        submitPMRequests( requests, 3 );
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (connection)  connection-&gt;release();
    <span class="enscript-keyword">if</span> (requests[0]) releasePMRequest(requests[0]);
    <span class="enscript-keyword">if</span> (requests[1]) releasePMRequest(requests[1]);
    <span class="enscript-keyword">if</span> (requests[2]) releasePMRequest(requests[2]);

    <span class="enscript-comment">// Silent failure, to prevent platform drivers from adding the child
</span>    <span class="enscript-comment">// to the root domain.
</span>
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] addPowerChild1
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Step 1/3 of adding a power child. Called on the power parent.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::addPowerChild1</span>( IOPMRequest * request )
{
    IOPMPowerStateIndex tempDesire = kPowerStateZero;

    <span class="enscript-comment">// Make us temporary usable before adding the child.
</span>
    PM_ASSERT_IN_GATE();
    OUR_PMLog( kPMLogMakeUsable, kPMLogMakeUsable, 0 );

    <span class="enscript-keyword">if</span> (fControllingDriver &amp;&amp; inPlane(gIOPowerPlane) &amp;&amp; fParentsKnowState)
    {
        tempDesire = fHighestPowerState;
    }

    <span class="enscript-keyword">if</span> ((tempDesire != kPowerStateZero) &amp;&amp;
        (IS_PM_ROOT || (StateOrder(fMaxPowerState) &gt;= StateOrder(tempDesire))))
    {
        adjustPowerState(tempDesire);
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] addPowerChild2
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Step 2/3 of adding a power child. Called on the joining child.
</span><span class="enscript-comment">// Execution blocked behind addPowerChild1.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::addPowerChild2</span>( IOPMRequest * request )
{
    IOPowerConnection * connection = (IOPowerConnection *) request-&gt;fArg0;
    IOService *         parent;
    IOPMPowerFlags      powerFlags;
    <span class="enscript-type">bool</span>                knowsState;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       powerState;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       tempDesire;

    PM_ASSERT_IN_GATE();
    parent = (IOService *) connection-&gt;getParentEntry(gIOPowerPlane);

    <span class="enscript-keyword">if</span> (!parent || !inPlane(gIOPowerPlane))
    {
        PM_LOG(<span class="enscript-string">&quot;%s: addPowerChild2 not in power plane\n&quot;</span>, getName());
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Parent will be waiting for us to complete this stage.
</span>    <span class="enscript-comment">// It is safe to directly access parent's vars.
</span>
    knowsState = (parent-&gt;fPowerStates) &amp;&amp; (parent-&gt;fParentsKnowState);
    powerState = parent-&gt;fCurrentPowerState;

    <span class="enscript-keyword">if</span> (knowsState)
        powerFlags = parent-&gt;fPowerStates[powerState].outputPowerFlags;
    <span class="enscript-keyword">else</span>
        powerFlags = 0;

    <span class="enscript-comment">// Set our power parent.
</span>
    OUR_PMLog(kPMLogSetParent, knowsState, powerFlags);

    setParentInfo( powerFlags, connection, knowsState );

    connection-&gt;setReadyFlag(true);

    <span class="enscript-keyword">if</span> ( fControllingDriver &amp;&amp; fParentsKnowState )
    {
        fMaxPowerState = fControllingDriver-&gt;maxCapabilityForDomainState(fParentsCurrentPowerFlags);
        <span class="enscript-comment">// initially change into the state we are already in
</span>        tempDesire = fControllingDriver-&gt;initialPowerStateForDomainState(fParentsCurrentPowerFlags);
        fPreviousRequestPowerFlags = (IOPMPowerFlags)(-1);
        adjustPowerState(tempDesire);
    }

    getPMRootDomain()-&gt;tagPowerPlaneService(<span class="enscript-keyword">this</span>, &amp;fPMActions);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] addPowerChild3
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Step 3/3 of adding a power child. Called on the parent.
</span><span class="enscript-comment">// Execution blocked behind addPowerChild2.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::addPowerChild3</span>( IOPMRequest * request )
{
    IOPowerConnection * connection = (IOPowerConnection *) request-&gt;fArg0;
    IOService *         child;
    IOPMrootDomain *    rootDomain = getPMRootDomain();

    PM_ASSERT_IN_GATE();
    child = (IOService *) connection-&gt;getChildEntry(gIOPowerPlane);

    <span class="enscript-keyword">if</span> (child &amp;&amp; inPlane(gIOPowerPlane))
    {
        <span class="enscript-keyword">if</span> ((<span class="enscript-keyword">this</span> != rootDomain) &amp;&amp; child-&gt;getProperty(<span class="enscript-string">&quot;IOPMStrictTreeOrder&quot;</span>))
        {
            PM_LOG1(<span class="enscript-string">&quot;%s: strict PM order enforced\n&quot;</span>, getName());
            fStrictTreeOrder = true;
        }

        <span class="enscript-keyword">if</span> (rootDomain)
            rootDomain-&gt;joinAggressiveness( child );
    }
    <span class="enscript-keyword">else</span>
    {
        PM_LOG(<span class="enscript-string">&quot;%s: addPowerChild3 not in power plane\n&quot;</span>, getName());
    }

    connection-&gt;release();
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] setPowerParent
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power Management is informing us who our parent is.
</span><span class="enscript-comment">// If we have a controlling driver, find out, given our newly-informed
</span><span class="enscript-comment">// power domain state, what state it would be in, and then tell it
</span><span class="enscript-comment">// to assume that state.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::setPowerParent</span>(
    IOPowerConnection * theParent, <span class="enscript-type">bool</span> stateKnown, IOPMPowerFlags powerFlags )
{
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] removePowerChild
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called on a parent whose child is being removed by PMstop().
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::removePowerChild</span>( IOPowerConnection * theNub )
{
    IORegistryEntry *   theChild;

    PM_ASSERT_IN_GATE();
    OUR_PMLog( kPMLogRemoveChild, 0, 0 );

    theNub-&gt;retain();

    <span class="enscript-comment">// detach nub from child
</span>    theChild = theNub-&gt;copyChildEntry(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( theChild )
    {
        theNub-&gt;detachFromChild(theChild, gIOPowerPlane);
        theChild-&gt;release();
    }
    <span class="enscript-comment">// detach from the nub
</span>    detachFromChild(theNub, gIOPowerPlane);

    <span class="enscript-comment">// Are we awaiting an ack from this child?
</span>    <span class="enscript-keyword">if</span> ( theNub-&gt;getAwaitingAck() )
    {
        <span class="enscript-comment">// yes, pretend we got one
</span>        theNub-&gt;setAwaitingAck(false);
        <span class="enscript-keyword">if</span> (fHeadNotePendingAcks != 0 )
        {
            <span class="enscript-comment">// that's one fewer ack to worry about
</span>            fHeadNotePendingAcks--;

            <span class="enscript-comment">// is that the last?
</span>            <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks == 0 )
            {
                stop_ack_timer();

                <span class="enscript-comment">// This parent may have a request in the work queue that is
</span>                <span class="enscript-comment">// blocked on fHeadNotePendingAcks=0. And removePowerChild()
</span>                <span class="enscript-comment">// is called while executing the child's PMstop request so they
</span>                <span class="enscript-comment">// can occur simultaneously. IOPMWorkQueue::checkForWork() must
</span>                <span class="enscript-comment">// restart and check all request queues again.
</span>
                gIOPMWorkQueue-&gt;incrementProducerCount();
            }
        }
    }

    theNub-&gt;release();

    <span class="enscript-comment">// A child has gone away, re-scan children desires and clamp bits.
</span>    <span class="enscript-comment">// The fPendingAdjustPowerRequest helps to reduce redundant parent work.
</span>
    <span class="enscript-keyword">if</span> (!fAdjustPowerScheduled)
    {
        IOPMRequest * request;
        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeAdjustPowerState );
        <span class="enscript-keyword">if</span> (request)
        {
            submitPMRequest( request );
            fAdjustPowerScheduled = true;
        }
    }

    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] registerPowerDriver
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A driver has called us volunteering to control power to our device.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::registerPowerDriver</span>(
    IOService *         powerDriver,
    IOPMPowerState *    powerStates,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       numberOfStates )
{
    IOPMRequest *       request;
    IOPMPSEntry *       powerStatesCopy = 0;
    IOPMPowerStateIndex stateOrder;
    IOReturn            error = kIOReturnSuccess;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    <span class="enscript-keyword">if</span> (!powerStates || (numberOfStates &lt; 2))
    {
        OUR_PMLog(kPMLogControllingDriverErr5, numberOfStates, 0);
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    <span class="enscript-keyword">if</span> (!powerDriver || !powerDriver-&gt;initialized)
    {
        OUR_PMLog(kPMLogControllingDriverErr4, 0, 0);
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    <span class="enscript-keyword">if</span> (powerStates[0].version &gt; kIOPMPowerStateVersion2)
    {
        OUR_PMLog(kPMLogControllingDriverErr1, powerStates[0].version, 0);
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    <span class="enscript-keyword">do</span> {
        <span class="enscript-comment">// Make a copy of the supplied power state array.
</span>        powerStatesCopy = IONew(IOPMPSEntry, numberOfStates);
        <span class="enscript-keyword">if</span> (!powerStatesCopy)
        {
            error = kIOReturnNoMemory;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Initialize to bogus values
</span>        <span class="enscript-keyword">for</span> (IOPMPowerStateIndex i = 0; i &lt; numberOfStates; i++)
            powerStatesCopy[i].stateOrderToIndex = kIOPMPowerStateMax;

        <span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; numberOfStates; i++)
        {
            powerStatesCopy[i].capabilityFlags  = powerStates[i].capabilityFlags;
            powerStatesCopy[i].outputPowerFlags = powerStates[i].outputPowerCharacter;
            powerStatesCopy[i].inputPowerFlags  = powerStates[i].inputPowerRequirement;
            powerStatesCopy[i].staticPower      = powerStates[i].staticPower;
            powerStatesCopy[i].settleUpTime     = powerStates[i].settleUpTime;
            powerStatesCopy[i].settleDownTime   = powerStates[i].settleDownTime;
            <span class="enscript-keyword">if</span> (powerStates[i].version &gt;= kIOPMPowerStateVersion2)
                stateOrder = powerStates[i].stateOrder;
            <span class="enscript-keyword">else</span>
                stateOrder = i;

            <span class="enscript-keyword">if</span> (stateOrder &lt; numberOfStates)
            {
                powerStatesCopy[i].stateOrder = stateOrder;
                powerStatesCopy[stateOrder].stateOrderToIndex = i;
            }
        }

        <span class="enscript-keyword">for</span> (IOPMPowerStateIndex i = 0; i &lt; numberOfStates; i++)
        {
            <span class="enscript-keyword">if</span> (powerStatesCopy[i].stateOrderToIndex == kIOPMPowerStateMax)
            {
                <span class="enscript-comment">// power state order missing
</span>                error = kIOReturnBadArgument;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">if</span> (kIOReturnSuccess != error)
            <span class="enscript-keyword">break</span>;

        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeRegisterPowerDriver );
        <span class="enscript-keyword">if</span> (!request)
        {
            error = kIOReturnNoMemory;
            <span class="enscript-keyword">break</span>;
        }

        powerDriver-&gt;retain();
        request-&gt;fArg0 = (<span class="enscript-type">void</span> *) powerDriver;
        request-&gt;fArg1 = (<span class="enscript-type">void</span> *) powerStatesCopy;
        request-&gt;fArg2 = (<span class="enscript-type">void</span> *) numberOfStates;

        submitPMRequest( request );
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (powerStatesCopy)
        IODelete(powerStatesCopy, IOPMPSEntry, numberOfStates);

    <span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleRegisterPowerDriver
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleRegisterPowerDriver</span>( IOPMRequest * request )
{
    IOService *     powerDriver    = (IOService *)   request-&gt;fArg0;
    IOPMPSEntry *   powerStates    = (IOPMPSEntry *) request-&gt;fArg1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   numberOfStates = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) request-&gt;fArg2;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   i, stateIndex;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   lowestPowerState;
    IOService *     root;
    OSIterator *    iter;

    PM_ASSERT_IN_GATE();
    assert(powerStates);
    assert(powerDriver);
    assert(numberOfStates &gt; 1);

    <span class="enscript-keyword">if</span> ( !fNumberOfPowerStates )
    {
        OUR_PMLog(kPMLogControllingDriver,
            (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) numberOfStates,
            (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) kIOPMPowerStateVersion1);

        fPowerStates            = powerStates;
        fNumberOfPowerStates    = numberOfStates;
        fControllingDriver      = powerDriver;
        fCurrentCapabilityFlags = fPowerStates[0].capabilityFlags;

        lowestPowerState   = fPowerStates[0].stateOrderToIndex;
        fHighestPowerState = fPowerStates[numberOfStates - 1].stateOrderToIndex;

        <span class="enscript-comment">// OR'in all the output power flags
</span>        fMergedOutputPowerFlags = 0;
        fDeviceUsablePowerState = lowestPowerState;
        <span class="enscript-keyword">for</span> ( i = 0; i &lt; numberOfStates; i++ )
        {
            fMergedOutputPowerFlags |= fPowerStates[i].outputPowerFlags;

            stateIndex = fPowerStates[i].stateOrderToIndex;
            assert(stateIndex &lt; numberOfStates);
            <span class="enscript-keyword">if</span> ((fDeviceUsablePowerState == lowestPowerState) &amp;&amp;
                (fPowerStates[stateIndex].capabilityFlags &amp; IOPMDeviceUsable))
            {
                <span class="enscript-comment">// The minimum power state that the device is usable
</span>                fDeviceUsablePowerState = stateIndex;
            }
        }

        <span class="enscript-comment">// Register powerDriver as interested, unless already done.
</span>        <span class="enscript-comment">// We don't want to register the default implementation since
</span>        <span class="enscript-comment">// it does nothing. One ramification of not always registering
</span>        <span class="enscript-comment">// is the one fewer retain count held.
</span>
        root = getPlatform()-&gt;getProvider();
        assert(root);
        <span class="enscript-keyword">if</span> (!root ||
            ((OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                root, &amp;IOService::powerStateDidChangeTo)) !=
            ((OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                <span class="enscript-keyword">this</span>, &amp;IOService::powerStateDidChangeTo)))) ||
            ((OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                root, &amp;IOService::powerStateWillChangeTo)) !=
            ((OSMemberFunctionCast(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span>),
                <span class="enscript-keyword">this</span>, &amp;IOService::powerStateWillChangeTo)))))
        {
            <span class="enscript-keyword">if</span> (fInterestedDrivers-&gt;findItem(powerDriver) == NULL)
            {
                PM_LOCK();
                fInterestedDrivers-&gt;appendNewInformee(powerDriver);
                PM_UNLOCK();
            }
        }

        <span class="enscript-comment">// Examine all existing power clients and perform limit check.
</span>
        <span class="enscript-keyword">if</span> (fPowerClients &amp;&amp;
            (iter = OSCollectionIterator::withCollection(fPowerClients)))
        {
            <span class="enscript-type">const</span> OSSymbol * client;
            <span class="enscript-keyword">while</span> ((client = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
            {
                IOPMPowerStateIndex powerState = getPowerStateForClient(client);
                <span class="enscript-keyword">if</span> (powerState &gt;= numberOfStates)
                {
                    updatePowerClient(client, fHighestPowerState);
                }
            }
            iter-&gt;release();
        }

        <span class="enscript-keyword">if</span> ( inPlane(gIOPowerPlane) &amp;&amp; fParentsKnowState )
        {
            IOPMPowerStateIndex tempDesire;
            fMaxPowerState = fControllingDriver-&gt;maxCapabilityForDomainState(fParentsCurrentPowerFlags);
            <span class="enscript-comment">// initially change into the state we are already in
</span>            tempDesire = fControllingDriver-&gt;initialPowerStateForDomainState(fParentsCurrentPowerFlags);
            adjustPowerState(tempDesire);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        OUR_PMLog(kPMLogControllingDriverErr2, numberOfStates, 0);
        IODelete(powerStates, IOPMPSEntry, numberOfStates);
    }

    powerDriver-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] registerInterestedDriver
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Add the caller to our list of interested drivers and return our current
</span><span class="enscript-comment">// power state.  If we don't have a power-controlling driver yet, we will
</span><span class="enscript-comment">// call this interested driver again later when we do get a driver and find
</span><span class="enscript-comment">// out what the current power state of the device is.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOPMPowerFlags <span class="enscript-function-name">IOService::registerInterestedDriver</span>( IOService * driver )
{
    IOPMRequest *   request;
    <span class="enscript-type">bool</span>            signal;

    <span class="enscript-keyword">if</span> (!driver || !initialized || !fInterestedDrivers)
        <span class="enscript-keyword">return</span> 0;

    PM_LOCK();
    signal = (!fInsertInterestSet &amp;&amp; !fRemoveInterestSet);
    <span class="enscript-keyword">if</span> (fInsertInterestSet == NULL)
        fInsertInterestSet = OSSet::withCapacity(4);
    <span class="enscript-keyword">if</span> (fInsertInterestSet)
    {
        fInsertInterestSet-&gt;setObject(driver);
        <span class="enscript-keyword">if</span> (fRemoveInterestSet)
            fRemoveInterestSet-&gt;removeObject(driver);
    }
    PM_UNLOCK();

    <span class="enscript-keyword">if</span> (signal)
    {
        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeInterestChanged );
        <span class="enscript-keyword">if</span> (request)
            submitPMRequest( request );
    }

    <span class="enscript-comment">// This return value cannot be trusted, but return a value
</span>    <span class="enscript-comment">// for those clients that care.
</span>
    OUR_PMLog(kPMLogInterestedDriver, kIOPMDeviceUsable, 2);
    <span class="enscript-keyword">return</span> kIOPMDeviceUsable;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] deRegisterInterestedDriver
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::deRegisterInterestedDriver</span>( IOService * driver )
{
    IOPMinformee *      item;
    IOPMRequest *       request;
    <span class="enscript-type">bool</span>                signal;

    <span class="enscript-keyword">if</span> (!driver)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    <span class="enscript-keyword">if</span> (!initialized || !fInterestedDrivers)
        <span class="enscript-keyword">return</span> IOPMNotPowerManaged;

    PM_LOCK();
    <span class="enscript-keyword">if</span> (fInsertInterestSet)
    {
        fInsertInterestSet-&gt;removeObject(driver);
    }

    item = fInterestedDrivers-&gt;findItem(driver);
    <span class="enscript-keyword">if</span> (!item)
    {
        PM_UNLOCK();
        <span class="enscript-keyword">return</span> kIOReturnNotFound;
    }

    signal = (!fRemoveInterestSet &amp;&amp; !fInsertInterestSet);
    <span class="enscript-keyword">if</span> (fRemoveInterestSet == NULL)
        fRemoveInterestSet = OSSet::withCapacity(4);
    <span class="enscript-keyword">if</span> (fRemoveInterestSet)
    {
        fRemoveInterestSet-&gt;setObject(driver);
        <span class="enscript-keyword">if</span> (item-&gt;active)
        {
            item-&gt;active = false;
            waitForPMDriverCall( driver );
        }
    }
    PM_UNLOCK();

    <span class="enscript-keyword">if</span> (signal)
    {
        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeInterestChanged );
        <span class="enscript-keyword">if</span> (request)
            submitPMRequest( request );
    }

    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleInterestChanged
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Handle interest added or removed.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleInterestChanged</span>( IOPMRequest * request )
{
    IOService *         driver;
    IOPMinformee *      informee;
    IOPMinformeeList *  list = fInterestedDrivers;

    PM_LOCK();

    <span class="enscript-keyword">if</span> (fInsertInterestSet)
    {
        <span class="enscript-keyword">while</span> ((driver = (IOService *) fInsertInterestSet-&gt;getAnyObject()))
        {
            <span class="enscript-keyword">if</span> (list-&gt;findItem(driver) == NULL)
            {
                informee = list-&gt;appendNewInformee(driver);
            }
            fInsertInterestSet-&gt;removeObject(driver);
        }
        fInsertInterestSet-&gt;release();
        fInsertInterestSet = 0;
    }

    <span class="enscript-keyword">if</span> (fRemoveInterestSet)
    {
        <span class="enscript-keyword">while</span> ((driver = (IOService *) fRemoveInterestSet-&gt;getAnyObject()))
        {
            informee = list-&gt;findItem(driver);
            <span class="enscript-keyword">if</span> (informee)
            {
                <span class="enscript-comment">// Clean-up async interest acknowledgement
</span>                <span class="enscript-keyword">if</span> (fHeadNotePendingAcks &amp;&amp; informee-&gt;timer)
                {
                    informee-&gt;timer = 0;
                    fHeadNotePendingAcks--;
                }
                list-&gt;removeFromList(driver);
            }
            fRemoveInterestSet-&gt;removeObject(driver);
        }
        fRemoveInterestSet-&gt;release();
        fRemoveInterestSet = 0;
    }

    PM_UNLOCK();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] acknowledgePowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// After we notified one of the interested drivers or a power-domain child
</span><span class="enscript-comment">// of an impending change in power, it has called to say it is now
</span><span class="enscript-comment">// prepared for the change.  If this object is the last to
</span><span class="enscript-comment">// acknowledge this change, we take whatever action we have been waiting
</span><span class="enscript-comment">// for.
</span><span class="enscript-comment">// That may include acknowledging to our parent.  In this case, we do it
</span><span class="enscript-comment">// last of all to insure that this doesn't cause the parent to call us some-
</span><span class="enscript-comment">// where else and alter data we are relying on here (like the very existance
</span><span class="enscript-comment">// of a &quot;current change note&quot;.)
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::acknowledgePowerChange</span>( IOService * whichObject )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;
    <span class="enscript-keyword">if</span> (!whichObject)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeAckPowerChange );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    whichObject-&gt;retain();
    request-&gt;fArg0 = whichObject;

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleAcknowledgePowerChange
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::handleAcknowledgePowerChange</span>( IOPMRequest * request )
{
    IOPMinformee *      informee;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       childPower = kIOPMUnknown;
    IOService *         theChild;
    IOService *         whichObject;
    <span class="enscript-type">bool</span>                all_acked  = false;

    PM_ASSERT_IN_GATE();
    whichObject = (IOService *) request-&gt;fArg0;
    assert(whichObject);

    <span class="enscript-comment">// one of our interested drivers?
</span>    informee = fInterestedDrivers-&gt;findItem( whichObject );
    <span class="enscript-keyword">if</span> ( informee == NULL )
    {
        <span class="enscript-keyword">if</span> ( !isChild(whichObject, gIOPowerPlane) )
        {
            OUR_PMLog(kPMLogAcknowledgeErr1, 0, 0);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">no_err</span>;
        } <span class="enscript-keyword">else</span> {
            OUR_PMLog(kPMLogChildAcknowledge, fHeadNotePendingAcks, 0);
        }
    } <span class="enscript-keyword">else</span> {
        OUR_PMLog(kPMLogDriverAcknowledge, fHeadNotePendingAcks, 0);
    }

    <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks != 0 )
    {
        assert(fPowerStates != NULL);

         <span class="enscript-comment">// yes, make sure we're expecting acks
</span>        <span class="enscript-keyword">if</span> ( informee != NULL )
        {
            <span class="enscript-comment">// it's an interested driver
</span>            <span class="enscript-comment">// make sure we're expecting this ack
</span>            <span class="enscript-keyword">if</span> ( informee-&gt;timer != 0 )
            {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>
                <span class="enscript-keyword">if</span> (informee-&gt;timer &gt; 0)
                {
                    uint64_t nsec = computeTimeDeltaNS(&amp;informee-&gt;startTime);
                    <span class="enscript-keyword">if</span> (nsec &gt; LOG_SETPOWER_TIMES) {
                        getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                            gIOPMStatsDriverPSChangeSlow, informee-&gt;whatObject-&gt;getName(), 
                            fDriverCallReason, NS_TO_MS(nsec), 0, NULL, fHeadNotePowerState);
                    }
                }
#<span class="enscript-reference">endif</span>
                <span class="enscript-comment">// mark it acked
</span>                informee-&gt;timer = 0;
                <span class="enscript-comment">// that's one fewer to worry about
</span>                fHeadNotePendingAcks--;
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// this driver has already acked
</span>                OUR_PMLog(kPMLogAcknowledgeErr2, 0, 0);
            }
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// it's a child
</span>            <span class="enscript-comment">// make sure we're expecting this ack
</span>            <span class="enscript-keyword">if</span> ( ((IOPowerConnection *)whichObject)-&gt;getAwaitingAck() )
            {
                <span class="enscript-comment">// that's one fewer to worry about
</span>                fHeadNotePendingAcks--;
                ((IOPowerConnection *)whichObject)-&gt;setAwaitingAck(false);
                theChild = (IOService *)whichObject-&gt;copyChildEntry(gIOPowerPlane);
                <span class="enscript-keyword">if</span> ( theChild )
                {
                    childPower = theChild-&gt;currentPowerConsumption();
                    theChild-&gt;release();
                }
                <span class="enscript-keyword">if</span> ( childPower == kIOPMUnknown )
                {
                    fHeadNotePowerArrayEntry-&gt;staticPower = kIOPMUnknown;
                } <span class="enscript-keyword">else</span> {
                    <span class="enscript-keyword">if</span> (fHeadNotePowerArrayEntry-&gt;staticPower != kIOPMUnknown)
                    {
                        fHeadNotePowerArrayEntry-&gt;staticPower += childPower;
                    }
                }
            }
        }

        <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks == 0 ) {
            <span class="enscript-comment">// yes, stop the timer
</span>            stop_ack_timer();
            <span class="enscript-comment">// and now we can continue
</span>            all_acked = true;
        }
    } <span class="enscript-keyword">else</span> {
        OUR_PMLog(kPMLogAcknowledgeErr3, 0, 0); <span class="enscript-comment">// not expecting anybody to ack
</span>    }

<span class="enscript-reference">no_err</span>:
    <span class="enscript-keyword">if</span> (whichObject)
        whichObject-&gt;release();

    <span class="enscript-keyword">return</span> all_acked;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] acknowledgeSetPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// After we instructed our controlling driver to change power states,
</span><span class="enscript-comment">// it has called to say it has finished doing so.
</span><span class="enscript-comment">// We continue to process the power state change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::acknowledgeSetPowerState</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeAckSetPowerState );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] adjustPowerState
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::adjustPowerState</span>( uint32_t clamp )
{
    PM_ASSERT_IN_GATE();
    computeDesiredState(clamp, false);
    <span class="enscript-keyword">if</span> (fControllingDriver &amp;&amp; fParentsKnowState &amp;&amp; inPlane(gIOPowerPlane))
    {
        IOPMPowerChangeFlags changeFlags = kIOPMSelfInitiated;

        <span class="enscript-comment">// Indicate that children desires must be ignored, and do not ask
</span>        <span class="enscript-comment">// apps for permission to drop power. This is used by root domain
</span>        <span class="enscript-comment">// for demand sleep.
</span>
        <span class="enscript-keyword">if</span> (getPMRequestType() == kIOPMRequestTypeRequestPowerStateOverride)
            changeFlags |= (kIOPMIgnoreChildren | kIOPMSkipAskPowerDown);

        startPowerChange(
             <span class="enscript-comment">/* flags        */</span> changeFlags,
             <span class="enscript-comment">/* power state  */</span> fDesiredPowerState,
             <span class="enscript-comment">/* domain flags */</span> 0,
             <span class="enscript-comment">/* connection   */</span> 0,
             <span class="enscript-comment">/* parent flags */</span> 0);
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] synchronizePowerTree
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::synchronizePowerTree</span>(
    IOOptionBits    options,
    IOService *     notifyRoot )
{
    IOPMRequest *   request_c = 0;
    IOPMRequest *   request_s;

    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> != getPMRootDomain())
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kIOPMNotYetInitialized;

    OUR_PMLog(kPMLogCSynchronizePowerTree, options, (notifyRoot != 0));

    <span class="enscript-keyword">if</span> (notifyRoot)
    {
        IOPMRequest * nr;

        <span class="enscript-comment">// Cancels don't need to be synchronized.
</span>        nr = acquirePMRequest(notifyRoot, kIOPMRequestTypeChildNotifyDelayCancel);
        <span class="enscript-keyword">if</span> (nr) submitPMRequest(nr);
        nr = acquirePMRequest(getPMRootDomain(), kIOPMRequestTypeChildNotifyDelayCancel);
        <span class="enscript-keyword">if</span> (nr) submitPMRequest(nr);
    }

    request_s = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeSynchronizePowerTree );
    <span class="enscript-keyword">if</span> (!request_s)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">error_no_memory</span>;

    <span class="enscript-keyword">if</span> (options &amp; kIOPMSyncCancelPowerDown)
        request_c = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeIdleCancel );
    <span class="enscript-keyword">if</span> (request_c)
    {
        request_c-&gt;attachNextRequest( request_s );
        submitPMRequest(request_c);
    }

    request_s-&gt;fArg0 = (<span class="enscript-type">void</span> *)(uintptr_t) options;
    submitPMRequest(request_s);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;

<span class="enscript-reference">error_no_memory</span>:
    <span class="enscript-keyword">if</span> (request_c) releasePMRequest(request_c);
    <span class="enscript-keyword">if</span> (request_s) releasePMRequest(request_s);
    <span class="enscript-keyword">return</span> kIOReturnNoMemory;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleSynchronizePowerTree
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleSynchronizePowerTree</span>( IOPMRequest * request )
{
    PM_ASSERT_IN_GATE();
    <span class="enscript-keyword">if</span> (fControllingDriver &amp;&amp; fParentsKnowState &amp;&amp; inPlane(gIOPowerPlane) &amp;&amp;
        (fCurrentPowerState == fHighestPowerState))
    {
        IOOptionBits options = (uintptr_t) request-&gt;fArg0;

        startPowerChange(
             <span class="enscript-comment">/* flags        */</span> kIOPMSelfInitiated | kIOPMSynchronize |
                                (options &amp; kIOPMSyncNoChildNotify),
             <span class="enscript-comment">/* power state  */</span> fCurrentPowerState,
             <span class="enscript-comment">/* domain flags */</span> 0,
             <span class="enscript-comment">/* connection   */</span> 0,
             <span class="enscript-comment">/* parent flags */</span> 0);
    }
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] powerDomainWillChangeTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by the power-hierarchy parent notifying of a new power state
</span><span class="enscript-comment">// in the power domain.
</span><span class="enscript-comment">// We enqueue a parent power-change to our queue of power changes.
</span><span class="enscript-comment">// This may or may not cause us to change power, depending on what
</span><span class="enscript-comment">// kind of change is occuring in the domain.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerDomainWillChangeTo</span>(
    IOPMPowerFlags      newPowerFlags,
    IOPowerConnection * whichParent )
{
    assert(false);
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handlePowerDomainWillChangeTo
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handlePowerDomainWillChangeTo</span>( IOPMRequest * request )
{
    IOPMPowerFlags       parentPowerFlags = (IOPMPowerFlags) request-&gt;fArg0;
    IOPowerConnection *  whichParent = (IOPowerConnection *) request-&gt;fArg1;
    IOPMPowerChangeFlags parentChangeFlags = (IOPMPowerChangeFlags)(uintptr_t) request-&gt;fArg2;
    IOPMPowerChangeFlags myChangeFlags;
    OSIterator *         iter;
    OSObject *           next;
    IOPowerConnection *  connection;
    IOPMPowerStateIndex  maxPowerState;
    IOPMPowerFlags       combinedPowerFlags;
    <span class="enscript-type">bool</span>                 savedParentsKnowState;
    IOReturn             result = IOPMAckImplied;

    PM_ASSERT_IN_GATE();
    OUR_PMLog(kPMLogWillChange, parentPowerFlags, 0);

    <span class="enscript-keyword">if</span> (!inPlane(gIOPowerPlane) || !whichParent || !whichParent-&gt;getAwaitingAck())
    {
        PM_LOG(<span class="enscript-string">&quot;%s::%s not in power tree\n&quot;</span>, getName(), __FUNCTION__);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit_no_ack</span>;
    }

    savedParentsKnowState = fParentsKnowState;

    <span class="enscript-comment">// Combine parents' output power flags.
</span>
    combinedPowerFlags = 0;

    iter = getParentIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ( (next = iter-&gt;getNextObject()) )
        {
            <span class="enscript-keyword">if</span> ( (connection = OSDynamicCast(IOPowerConnection, next)) )
            {
                <span class="enscript-keyword">if</span> ( connection == whichParent )
                    combinedPowerFlags |= parentPowerFlags;
                <span class="enscript-keyword">else</span>
                    combinedPowerFlags |= connection-&gt;parentCurrentPowerFlags();
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-comment">// If our initial change has yet to occur, then defer the power change
</span>    <span class="enscript-comment">// until after the power domain has completed its power transition.
</span>
    <span class="enscript-keyword">if</span> ( fControllingDriver &amp;&amp; !fInitialPowerChange )
    {
        maxPowerState = fControllingDriver-&gt;maxCapabilityForDomainState(
                            combinedPowerFlags);

        <span class="enscript-keyword">if</span> (parentChangeFlags &amp; kIOPMDomainPowerDrop)
        {
            <span class="enscript-comment">// fMaxPowerState set a limit on self-initiated power changes.
</span>            <span class="enscript-comment">// Update it before a parent power drop.
</span>            fMaxPowerState = maxPowerState;
        }

        <span class="enscript-comment">// Use kIOPMSynchronize below instead of kIOPMRootBroadcastFlags
</span>        <span class="enscript-comment">// to avoid propagating the root change flags if any service must
</span>        <span class="enscript-comment">// change power state due to root's will-change notification.
</span>        <span class="enscript-comment">// Root does not change power state for kIOPMSynchronize.
</span>
        myChangeFlags = kIOPMParentInitiated | kIOPMDomainWillChange |
                        (parentChangeFlags &amp; kIOPMSynchronize);

        result = startPowerChange(
                 <span class="enscript-comment">/* flags        */</span> myChangeFlags,
                 <span class="enscript-comment">/* power state  */</span> maxPowerState,
                 <span class="enscript-comment">/* domain flags */</span> combinedPowerFlags,
                 <span class="enscript-comment">/* connection   */</span> whichParent,
                 <span class="enscript-comment">/* parent flags */</span> parentPowerFlags);
    }

    <span class="enscript-comment">// If parent is dropping power, immediately update the parent's
</span>    <span class="enscript-comment">// capability flags. Any future merging of parent(s) combined
</span>    <span class="enscript-comment">// power flags should account for this power drop.
</span>
    <span class="enscript-keyword">if</span> (parentChangeFlags &amp; kIOPMDomainPowerDrop)
    {
        setParentInfo(parentPowerFlags, whichParent, true);
    }

    <span class="enscript-comment">// Parent is expecting an ACK from us. If we did not embark on a state
</span>    <span class="enscript-comment">// transition, i.e. startPowerChange() returned IOPMAckImplied. We are
</span>    <span class="enscript-comment">// still required to issue an ACK to our parent.
</span>
    <span class="enscript-keyword">if</span> (IOPMAckImplied == result)
    {
        IOService * parent;
        parent = (IOService *) whichParent-&gt;copyParentEntry(gIOPowerPlane);
        assert(parent);
        <span class="enscript-keyword">if</span> ( parent )
        {
            parent-&gt;acknowledgePowerChange( whichParent );
            parent-&gt;release();
        }
    }

<span class="enscript-reference">exit_no_ack</span>:
    <span class="enscript-comment">// Drop the retain from notifyChild().
</span>    <span class="enscript-keyword">if</span> (whichParent) whichParent-&gt;release();
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] powerDomainDidChangeTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by the power-hierarchy parent after the power state of the power domain
</span><span class="enscript-comment">// has settled at a new level.
</span><span class="enscript-comment">// We enqueue a parent power-change to our queue of power changes.
</span><span class="enscript-comment">// This may or may not cause us to change power, depending on what
</span><span class="enscript-comment">// kind of change is occuring in the domain.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerDomainDidChangeTo</span>(
    IOPMPowerFlags      newPowerFlags,
    IOPowerConnection * whichParent )
{
    assert(false);
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handlePowerDomainDidChangeTo
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handlePowerDomainDidChangeTo</span>( IOPMRequest * request )
{
    IOPMPowerFlags       parentPowerFlags = (IOPMPowerFlags) request-&gt;fArg0;
    IOPowerConnection *  whichParent = (IOPowerConnection *) request-&gt;fArg1;
    IOPMPowerChangeFlags parentChangeFlags = (IOPMPowerChangeFlags)(uintptr_t) request-&gt;fArg2;
    IOPMPowerChangeFlags myChangeFlags;
    IOPMPowerStateIndex  maxPowerState;
    IOPMPowerStateIndex  initialDesire = kPowerStateZero;
    <span class="enscript-type">bool</span>                 computeDesire = false;
    <span class="enscript-type">bool</span>                 desireChanged = false;
    <span class="enscript-type">bool</span>                 savedParentsKnowState;
    IOReturn             result = IOPMAckImplied;

    PM_ASSERT_IN_GATE();
    OUR_PMLog(kPMLogDidChange, parentPowerFlags, 0);

    <span class="enscript-keyword">if</span> (!inPlane(gIOPowerPlane) || !whichParent || !whichParent-&gt;getAwaitingAck())
    {
        PM_LOG(<span class="enscript-string">&quot;%s::%s not in power tree\n&quot;</span>, getName(), __FUNCTION__);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit_no_ack</span>;
    }

    savedParentsKnowState = fParentsKnowState;

    setParentInfo(parentPowerFlags, whichParent, true);

    <span class="enscript-keyword">if</span> ( fControllingDriver )
    {
        maxPowerState = fControllingDriver-&gt;maxCapabilityForDomainState(
                            fParentsCurrentPowerFlags);

        <span class="enscript-keyword">if</span> ((parentChangeFlags &amp; kIOPMDomainPowerDrop) == 0)
        {
            <span class="enscript-comment">// fMaxPowerState set a limit on self-initiated power changes.
</span>            <span class="enscript-comment">// Update it after a parent power rise.
</span>            fMaxPowerState = maxPowerState;
        }

        <span class="enscript-keyword">if</span> (fInitialPowerChange)
        {
            computeDesire = true;
            initialDesire = fControllingDriver-&gt;initialPowerStateForDomainState(
                                fParentsCurrentPowerFlags);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parentChangeFlags &amp; kIOPMRootChangeUp)
        {
            <span class="enscript-keyword">if</span> (fAdvisoryTickleUsed)
            {
                <span class="enscript-comment">// On system wake, re-compute the desired power state since
</span>                <span class="enscript-comment">// gIOPMAdvisoryTickleEnabled will change for a full wake,
</span>                <span class="enscript-comment">// which is an input to computeDesiredState(). This is not
</span>                <span class="enscript-comment">// necessary for a dark wake because powerChangeDone() will
</span>                <span class="enscript-comment">// handle the dark to full wake case, but it does no harm.
</span>
                desireChanged = true;
            }

            <span class="enscript-keyword">if</span> (fResetPowerStateOnWake)
            {
                <span class="enscript-comment">// Query the driver for the desired power state on system wake.
</span>                <span class="enscript-comment">// Default implementation returns the lowest power state.
</span>
                IOPMPowerStateIndex wakePowerState =
                    fControllingDriver-&gt;initialPowerStateForDomainState(
                        kIOPMRootDomainState | kIOPMPowerOn );

                <span class="enscript-comment">// fDesiredPowerState was adjusted before going to sleep
</span>                <span class="enscript-comment">// with fDeviceDesire at min.
</span>
                <span class="enscript-keyword">if</span> (StateOrder(wakePowerState) &gt; StateOrder(fDesiredPowerState))
                {
                    <span class="enscript-comment">// Must schedule a power adjustment if we changed the
</span>                    <span class="enscript-comment">// device desire. That will update the desired domain
</span>                    <span class="enscript-comment">// power on the parent power connection and ping the
</span>                    <span class="enscript-comment">// power parent if necessary.
</span>
                    updatePowerClient(gIOPMPowerClientDevice, wakePowerState);
                    desireChanged = true;
                }
            }
        }

        <span class="enscript-keyword">if</span> (computeDesire || desireChanged)
            computeDesiredState(initialDesire, false);

        <span class="enscript-comment">// Absorb and propagate parent's broadcast flags
</span>        myChangeFlags = kIOPMParentInitiated | kIOPMDomainDidChange |
                        (parentChangeFlags &amp; kIOPMRootBroadcastFlags);

        result = startPowerChange(
                 <span class="enscript-comment">/* flags        */</span> myChangeFlags,
                 <span class="enscript-comment">/* power state  */</span> maxPowerState,
                 <span class="enscript-comment">/* domain flags */</span> fParentsCurrentPowerFlags,
                 <span class="enscript-comment">/* connection   */</span> whichParent,
                 <span class="enscript-comment">/* parent flags */</span> 0);
    }

    <span class="enscript-comment">// Parent is expecting an ACK from us. If we did not embark on a state
</span>    <span class="enscript-comment">// transition, i.e. startPowerChange() returned IOPMAckImplied. We are
</span>    <span class="enscript-comment">// still required to issue an ACK to our parent.
</span>
    <span class="enscript-keyword">if</span> (IOPMAckImplied == result)
    {
        IOService * parent;
        parent = (IOService *) whichParent-&gt;copyParentEntry(gIOPowerPlane);
        assert(parent);
        <span class="enscript-keyword">if</span> ( parent )
        {
            parent-&gt;acknowledgePowerChange( whichParent );
            parent-&gt;release();
        }
    }

    <span class="enscript-comment">// If the parent registers its power driver late, then this is the
</span>    <span class="enscript-comment">// first opportunity to tell our parent about our desire. Or if the
</span>    <span class="enscript-comment">// child's desire changed during a parent change notify.
</span>
    <span class="enscript-keyword">if</span> (fControllingDriver &amp;&amp;
        ((!savedParentsKnowState &amp;&amp; fParentsKnowState) || desireChanged))
    {
        PM_LOG1(<span class="enscript-string">&quot;%s::powerDomainDidChangeTo parentsKnowState %d\n&quot;</span>,
            getName(), fParentsKnowState);
        requestDomainPower( fDesiredPowerState );
    }

<span class="enscript-reference">exit_no_ack</span>:
    <span class="enscript-comment">// Drop the retain from notifyChild().
</span>    <span class="enscript-keyword">if</span> (whichParent) whichParent-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] setParentInfo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Set our connection data for one specific parent, and then combine all the parent
</span><span class="enscript-comment">// data together.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setParentInfo</span>(
    IOPMPowerFlags      newPowerFlags,
    IOPowerConnection * whichParent,
    <span class="enscript-type">bool</span>                knowsState )
{
    OSIterator *        iter;
    OSObject *          next;
    IOPowerConnection * conn;

    PM_ASSERT_IN_GATE();

    <span class="enscript-comment">// set our connection data
</span>    whichParent-&gt;setParentCurrentPowerFlags(newPowerFlags);
    whichParent-&gt;setParentKnowsState(knowsState);

    <span class="enscript-comment">// recompute our parent info
</span>    fParentsCurrentPowerFlags = 0;
    fParentsKnowState = true;

    iter = getParentIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ( (next = iter-&gt;getNextObject()) )
        {
            <span class="enscript-keyword">if</span> ( (conn = OSDynamicCast(IOPowerConnection, next)) )
            {
                fParentsKnowState &amp;= conn-&gt;parentKnowsState();
                fParentsCurrentPowerFlags |= conn-&gt;parentCurrentPowerFlags();
            }
        }
        iter-&gt;release();
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// [private] trackSystemSleepPreventers
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::trackSystemSleepPreventers</span>(
    IOPMPowerStateIndex     oldPowerState,
    IOPMPowerStateIndex     newPowerState,
    IOPMPowerChangeFlags    changeFlags __unused )
{
    IOPMPowerFlags  oldCapability, newCapability;

    oldCapability = fPowerStates[oldPowerState].capabilityFlags &amp;
                    (kIOPMPreventIdleSleep | kIOPMPreventSystemSleep);
    newCapability = fPowerStates[newPowerState].capabilityFlags &amp;
                    (kIOPMPreventIdleSleep | kIOPMPreventSystemSleep);

    <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMInitialPowerChange)
        oldCapability = 0;
    <span class="enscript-keyword">if</span> (oldCapability == newCapability)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> ((oldCapability ^ newCapability) &amp; kIOPMPreventIdleSleep)
    {
        <span class="enscript-type">bool</span> enablePrevention  = ((oldCapability &amp; kIOPMPreventIdleSleep) == 0);
        <span class="enscript-type">bool</span> idleCancelAllowed = getPMRootDomain()-&gt;updatePreventIdleSleepList(
                                    <span class="enscript-keyword">this</span>, enablePrevention);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SUPPORT_IDLE_CANCEL</span>
        <span class="enscript-keyword">if</span> (idleCancelAllowed &amp;&amp; enablePrevention)
        {
            IOPMRequest *   cancelRequest;

            cancelRequest = acquirePMRequest( getPMRootDomain(), kIOPMRequestTypeIdleCancel );
            <span class="enscript-keyword">if</span> (cancelRequest)
            {
                submitPMRequest( cancelRequest );
            }
        }
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">if</span> ((oldCapability ^ newCapability) &amp; kIOPMPreventSystemSleep)
    {
        getPMRootDomain()-&gt;updatePreventSystemSleepList(<span class="enscript-keyword">this</span>,
            ((oldCapability &amp; kIOPMPreventSystemSleep) == 0));
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] requestPowerDomainState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called on a power parent when a child's power requirement changes.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::requestPowerDomainState</span>(
    IOPMPowerFlags      childRequestPowerFlags,
    IOPowerConnection * childConnection,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       specification )
{
    IOPMPowerStateIndex order, powerState;
    IOPMPowerFlags      outputPowerFlags;
    IOService *         child;
    IOPMRequest *       subRequest;
    <span class="enscript-type">bool</span>                adjustPower = false;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;onThread() == false)
    {
        PM_LOG(<span class="enscript-string">&quot;%s::requestPowerDomainState\n&quot;</span>, getName());
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }

    OUR_PMLog(kPMLogRequestDomain, childRequestPowerFlags, specification);

    <span class="enscript-keyword">if</span> (!isChild(childConnection, gIOPowerPlane))
        <span class="enscript-keyword">return</span> kIOReturnNotAttached;

    <span class="enscript-keyword">if</span> (!fControllingDriver || !fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> kIOReturnNotReady;

    child = (IOService *) childConnection-&gt;getChildEntry(gIOPowerPlane);
    assert(child);

    <span class="enscript-comment">// Remove flags from child request which we can't possibly supply
</span>    childRequestPowerFlags &amp;= fMergedOutputPowerFlags;

    <span class="enscript-comment">// Merge in the power flags contributed by this power parent
</span>    <span class="enscript-comment">// at its current or impending power state.
</span>
    outputPowerFlags = fPowerStates[fCurrentPowerState].outputPowerFlags;
    <span class="enscript-keyword">if</span> (fMachineState != kIOPM_Finished)
    {
        <span class="enscript-keyword">if</span> (IS_POWER_DROP &amp;&amp; !IS_ROOT_DOMAIN)
        {
            <span class="enscript-comment">// Use the lower power state when dropping power.
</span>            <span class="enscript-comment">// Must be careful since a power drop can be cancelled
</span>            <span class="enscript-comment">// from the following states:
</span>            <span class="enscript-comment">// - kIOPM_OurChangeTellClientsPowerDown
</span>            <span class="enscript-comment">// - kIOPM_OurChangeTellPriorityClientsPowerDown
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// The child must not wait for this parent to raise power
</span>            <span class="enscript-comment">// if the power drop was cancelled. The solution is to cancel
</span>            <span class="enscript-comment">// the power drop if possible, then schedule an adjustment to
</span>            <span class="enscript-comment">// re-evaluate the parent's power state.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// Root domain is excluded to avoid idle sleep issues. And allow
</span>            <span class="enscript-comment">// root domain children to pop up when system is going to sleep.
</span>
            <span class="enscript-keyword">if</span> ((fMachineState == kIOPM_OurChangeTellClientsPowerDown) ||
                (fMachineState == kIOPM_OurChangeTellPriorityClientsPowerDown))
            {
                fDoNotPowerDown = true;     <span class="enscript-comment">// cancel power drop
</span>                adjustPower     = true;     <span class="enscript-comment">// schedule an adjustment
</span>                PM_LOG1(<span class="enscript-string">&quot;%s: power drop cancelled in state %u by %s\n&quot;</span>,
                    getName(), fMachineState, child-&gt;getName());
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Beyond cancellation point, report the impending state.
</span>                outputPowerFlags =
                    fPowerStates[fHeadNotePowerState].outputPowerFlags;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IS_POWER_RISE)
        {
            <span class="enscript-comment">// When raising power, must report the output power flags from
</span>            <span class="enscript-comment">// child's perspective. A child power request may arrive while
</span>            <span class="enscript-comment">// parent is transitioning upwards. If a request arrives after
</span>            <span class="enscript-comment">// setParentInfo() has already recorded the output power flags
</span>            <span class="enscript-comment">// for the next power state, then using the power supplied by
</span>            <span class="enscript-comment">// fCurrentPowerState is incorrect, and might cause the child
</span>            <span class="enscript-comment">// to wait when it should not.
</span>
            outputPowerFlags = childConnection-&gt;parentCurrentPowerFlags();
        }
    }
    child-&gt;fHeadNoteDomainTargetFlags |= outputPowerFlags;

    <span class="enscript-comment">// Map child's requested power flags to one of our power state.
</span>
    <span class="enscript-keyword">for</span> (order = 0; order &lt; fNumberOfPowerStates; order++)
    {
        powerState = fPowerStates[order].stateOrderToIndex;
        <span class="enscript-keyword">if</span> ((fPowerStates[powerState].outputPowerFlags &amp; childRequestPowerFlags)
            == childRequestPowerFlags)
            <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (order &gt;= fNumberOfPowerStates)
    {
        powerState = kPowerStateZero;
    }

    <span class="enscript-comment">// Conditions that warrants a power adjustment on this parent.
</span>    <span class="enscript-comment">// Adjust power will also propagate any changes to the child's
</span>    <span class="enscript-comment">// prevent idle/sleep flags towards the root domain.
</span>
    <span class="enscript-keyword">if</span> (!childConnection-&gt;childHasRequestedPower() ||
        (powerState != childConnection-&gt;getDesiredDomainState()))
        adjustPower = true;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_DEBUG_LOGS</span>
    <span class="enscript-keyword">if</span> (adjustPower)
    {
        PM_LOG(<span class="enscript-string">&quot;requestPowerDomainState[%s]: %s, init %d, %u-&gt;%u\n&quot;</span>,
            getName(), child-&gt;getName(),
            !childConnection-&gt;childHasRequestedPower(),
            (uint32_t) childConnection-&gt;getDesiredDomainState(),
            (uint32_t) powerState);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Record the child's desires on the connection.
</span>    childConnection-&gt;setChildHasRequestedPower();
    childConnection-&gt;setDesiredDomainState( powerState );

    <span class="enscript-comment">// Schedule a request to re-evaluate all children desires and
</span>    <span class="enscript-comment">// adjust power state. Submit a request if one wasn't pending,
</span>    <span class="enscript-comment">// or if the current request is part of a call tree.
</span>
    <span class="enscript-keyword">if</span> (adjustPower &amp;&amp; !fDeviceOverrideEnabled &amp;&amp;
        (!fAdjustPowerScheduled || gIOPMRequest-&gt;getRootRequest()))
    {
        subRequest = acquirePMRequest(
            <span class="enscript-keyword">this</span>, kIOPMRequestTypeAdjustPowerState, gIOPMRequest );
        <span class="enscript-keyword">if</span> (subRequest)
        {
            submitPMRequest( subRequest );
            fAdjustPowerScheduled = true;
        }
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] temporaryPowerClampOn
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A power domain wants to clamp its power on till it has children which
</span><span class="enscript-comment">// will thendetermine the power domain state.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We enter the highest state until addPowerChild is called.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::temporaryPowerClampOn</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> requestPowerState( gIOPMPowerClientChildProxy, kIOPMPowerStateMax );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] makeUsable
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Some client of our device is asking that we become usable.  Although
</span><span class="enscript-comment">// this has not come from a subclassed device object, treat it exactly
</span><span class="enscript-comment">// as if it had.  In this way, subsequent requests for lower power from
</span><span class="enscript-comment">// a subclassed device object will pre-empt this request.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We treat this as a subclass object request to switch to the
</span><span class="enscript-comment">// highest power state.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::makeUsable</span>( <span class="enscript-type">void</span> )
{
    OUR_PMLog(kPMLogMakeUsable, 0, 0);
    <span class="enscript-keyword">return</span> requestPowerState( gIOPMPowerClientDevice, kIOPMPowerStateMax );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] currentCapability
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOPMPowerFlags <span class="enscript-function-name">IOService::currentCapability</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotPowerManaged;

    <span class="enscript-keyword">return</span> fCurrentCapabilityFlags;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] changePowerStateTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by our power-controlling driver to change power state. The new desired
</span><span class="enscript-comment">// power state is computed and compared against the current power state. If those
</span><span class="enscript-comment">// power states differ, then a power state change is initiated.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::changePowerStateTo</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal )
{
    OUR_PMLog(kPMLogChangeStateTo, ordinal, 0);
    <span class="enscript-keyword">return</span> requestPowerState( gIOPMPowerClientDriver, ordinal );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] changePowerStateToPriv
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by our driver subclass to change power state. The new desired power
</span><span class="enscript-comment">// state is computed and compared against the current power state. If those
</span><span class="enscript-comment">// power states differ, then a power state change is initiated.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::changePowerStateToPriv</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal )
{
    OUR_PMLog(kPMLogChangeStateToPriv, ordinal, 0);
    <span class="enscript-keyword">return</span> requestPowerState( gIOPMPowerClientDevice, ordinal );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] changePowerStateWithOverrideTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by our driver subclass to change power state. The new desired power
</span><span class="enscript-comment">// state is computed and compared against the current power state. If those
</span><span class="enscript-comment">// power states differ, then a power state change is initiated.
</span><span class="enscript-comment">// Override enforced - Children and Driver desires are ignored.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::changePowerStateWithOverrideTo</span>( IOPMPowerStateIndex ordinal,
                                                    IOPMRequestTag tag )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kIOPMNotYetInitialized;

    OUR_PMLog(kPMLogChangeStateToPriv, ordinal, 0);

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeRequestPowerStateOverride );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    gIOPMPowerClientDevice-&gt;retain();
    request-&gt;fRequestTag = tag;
    request-&gt;fArg0 = (<span class="enscript-type">void</span> *) ordinal;
    request-&gt;fArg1 = (<span class="enscript-type">void</span> *) gIOPMPowerClientDevice;
    request-&gt;fArg2 = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOT_READY</span>
    <span class="enscript-keyword">if</span> (action)
        request-&gt;installCompletionAction( action, target, param );
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Prevent needless downwards power transitions by clamping power
</span>    <span class="enscript-comment">// until the scheduled request is executed.
</span>
    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate() &amp;&amp; (ordinal &lt; fNumberOfPowerStates))
    {
        fTempClampPowerState = StateMax(fTempClampPowerState, ordinal);
        fTempClampCount++;
        fOverrideMaxPowerState = ordinal;
        request-&gt;fArg2 = (<span class="enscript-type">void</span> *) (uintptr_t) true;
    }

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] changePowerStateForRootDomain
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Adjust the root domain's power desire on the target
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::changePowerStateForRootDomain</span>( IOPMPowerStateIndex ordinal )
{
    OUR_PMLog(kPMLogChangeStateForRootDomain, ordinal, 0);
    <span class="enscript-keyword">return</span> requestPowerState( gIOPMPowerClientRootDomain, ordinal );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public for PMRD] quiescePowerTree
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For root domain to issue a request to quiesce the power tree.
</span><span class="enscript-comment">// Supplied callback invoked upon completion.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::quiescePowerTree</span>(
    <span class="enscript-type">void</span> * target, IOPMCompletionAction action, <span class="enscript-type">void</span> * param )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kIOPMNotYetInitialized;
    <span class="enscript-keyword">if</span> (!target || !action)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    OUR_PMLog(kPMLogQuiescePowerTree, 0, 0);

    <span class="enscript-comment">// Target the root node instead of root domain. This is to avoid blocking
</span>    <span class="enscript-comment">// the quiesce request behind an existing root domain request in the work
</span>    <span class="enscript-comment">// queue. Root parent and root domain requests in the work queue must not
</span>    <span class="enscript-comment">// block the completion of the quiesce request.
</span>
    request = acquirePMRequest(gIOPMRootNode, kIOPMRequestTypeQuiescePowerTree);
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    request-&gt;installCompletionAction(target, action, param);

    <span class="enscript-comment">// Submit through the normal request flow. This will make sure any request
</span>    <span class="enscript-comment">// already in the request queue will get pushed over to the work queue for
</span>    <span class="enscript-comment">// execution. Any request submitted after this request may not be serviced.
</span>
    submitPMRequest( request );
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] requestPowerState
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::requestPowerState</span>(
    <span class="enscript-type">const</span> OSSymbol *      client,
    uint32_t              state )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!client)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kIOPMNotYetInitialized;

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeRequestPowerState );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    client-&gt;retain();
    request-&gt;fArg0 = (<span class="enscript-type">void</span> *)(uintptr_t) state;
    request-&gt;fArg1 = (<span class="enscript-type">void</span> *)            client;
    request-&gt;fArg2 = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOT_READY</span>
    <span class="enscript-keyword">if</span> (action)
        request-&gt;installCompletionAction( action, target, param );
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Prevent needless downwards power transitions by clamping power
</span>    <span class="enscript-comment">// until the scheduled request is executed.
</span>
    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate() &amp;&amp; (state &lt; fNumberOfPowerStates))
    {
        fTempClampPowerState = StateMax(fTempClampPowerState, state);
        fTempClampCount++;
        request-&gt;fArg2 = (<span class="enscript-type">void</span> *) (uintptr_t) true;
    }

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleRequestPowerState
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleRequestPowerState</span>( IOPMRequest * request )
{
    <span class="enscript-type">const</span> OSSymbol * client = (<span class="enscript-type">const</span> OSSymbol *)    request-&gt;fArg1;
    uint32_t         state  = (uint32_t)(uintptr_t) request-&gt;fArg0;

    PM_ASSERT_IN_GATE();
    <span class="enscript-keyword">if</span> (request-&gt;fArg2)
    {
        assert(fTempClampCount != 0);
        <span class="enscript-keyword">if</span> (fTempClampCount)  fTempClampCount--;
        <span class="enscript-keyword">if</span> (!fTempClampCount) fTempClampPowerState = kPowerStateZero;
    }

    <span class="enscript-keyword">if</span> (fNumberOfPowerStates &amp;&amp; (state &gt;= fNumberOfPowerStates))
        state = fHighestPowerState;

    <span class="enscript-comment">// The power suppression due to changePowerStateWithOverrideTo() expires
</span>    <span class="enscript-comment">// upon the next &quot;device&quot; power request - changePowerStateToPriv().
</span>
    <span class="enscript-keyword">if</span> ((getPMRequestType() != kIOPMRequestTypeRequestPowerStateOverride) &amp;&amp;
        (client == gIOPMPowerClientDevice))
        fOverrideMaxPowerState = kIOPMPowerStateMax;

    <span class="enscript-keyword">if</span> ((state == kPowerStateZero) &amp;&amp;
        (client != gIOPMPowerClientDevice) &amp;&amp;
        (client != gIOPMPowerClientDriver) &amp;&amp;
        (client != gIOPMPowerClientChildProxy))
        removePowerClient(client);
    <span class="enscript-keyword">else</span>
        updatePowerClient(client, state);

    adjustPowerState();
    client-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] Helper functions to update/remove power clients.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::updatePowerClient</span>( <span class="enscript-type">const</span> OSSymbol * client, uint32_t powerState )
{
    IOPMPowerStateIndex oldPowerState = kPowerStateZero;

    <span class="enscript-keyword">if</span> (!fPowerClients)
        fPowerClients = OSDictionary::withCapacity(4);
    <span class="enscript-keyword">if</span> (fPowerClients &amp;&amp; client)
    {
        OSNumber * num = (OSNumber *) fPowerClients-&gt;getObject(client);
        <span class="enscript-keyword">if</span> (num)
        {
            oldPowerState = num-&gt;unsigned32BitValue();
            num-&gt;setValue(powerState);
        }
        <span class="enscript-keyword">else</span>
        {
            num = OSNumber::withNumber(powerState, 32);
            <span class="enscript-keyword">if</span> (num)
            {
                fPowerClients-&gt;setObject(client, num);
                num-&gt;release();
            }
        }

        PM_ACTION_3(actionUpdatePowerClient, client, oldPowerState, powerState);
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::removePowerClient</span>( <span class="enscript-type">const</span> OSSymbol * client )
{
    <span class="enscript-keyword">if</span> (fPowerClients &amp;&amp; client)
        fPowerClients-&gt;removeObject(client);
}

uint32_t <span class="enscript-function-name">IOService::getPowerStateForClient</span>( <span class="enscript-type">const</span> OSSymbol * client )
{
    uint32_t powerState = kPowerStateZero;

    <span class="enscript-keyword">if</span> (fPowerClients &amp;&amp; client)
    {
        OSNumber * num = (OSNumber *) fPowerClients-&gt;getObject(client);
        <span class="enscript-keyword">if</span> (num) powerState = num-&gt;unsigned32BitValue();
    }
    <span class="enscript-keyword">return</span> powerState;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] powerOverrideOnPriv
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerOverrideOnPriv</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate())
    {
        fDeviceOverrideEnabled = true;
        <span class="enscript-keyword">return</span> IOPMNoErr;
    }

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypePowerOverrideOnPriv );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] powerOverrideOffPriv
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerOverrideOffPriv</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate())
    {
        fDeviceOverrideEnabled = false;
        <span class="enscript-keyword">return</span> IOPMNoErr;
    }

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypePowerOverrideOffPriv );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    submitPMRequest( request );
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handlePowerOverrideChanged
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handlePowerOverrideChanged</span>( IOPMRequest * request )
{
    PM_ASSERT_IN_GATE();
    <span class="enscript-keyword">if</span> (request-&gt;getType() == kIOPMRequestTypePowerOverrideOnPriv)
    {
        OUR_PMLog(kPMLogOverrideOn, 0, 0);
        fDeviceOverrideEnabled = true;
    }
    <span class="enscript-keyword">else</span>
    {
        OUR_PMLog(kPMLogOverrideOff, 0, 0);
        fDeviceOverrideEnabled = false;
    }

    adjustPowerState();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] computeDesiredState
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::computeDesiredState</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> localClamp, <span class="enscript-type">bool</span> computeOnly )
{
    OSIterator *        iter;
    OSObject *          next;
    IOPowerConnection * connection;
    uint32_t            desiredState  = kPowerStateZero;
    uint32_t            newPowerState = kPowerStateZero;
    <span class="enscript-type">bool</span>                hasChildren   = false;

    <span class="enscript-comment">// Desired power state is always 0 without a controlling driver.
</span>
    <span class="enscript-keyword">if</span> (!fNumberOfPowerStates)
    {
        fDesiredPowerState = kPowerStateZero;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Examine the children's desired power state.
</span>
    iter = getChildIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">while</span> ((next = iter-&gt;getNextObject()))
        {
            <span class="enscript-keyword">if</span> ((connection = OSDynamicCast(IOPowerConnection, next)))
            {
                <span class="enscript-keyword">if</span> (connection-&gt;getReadyFlag() == false)
                {
                    PM_LOG3(<span class="enscript-string">&quot;[%s] %s: connection not ready\n&quot;</span>,
                        getName(), __FUNCTION__);
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-keyword">if</span> (connection-&gt;childHasRequestedPower())
                    hasChildren = true;
                desiredState = StateMax(connection-&gt;getDesiredDomainState(), desiredState);
            }
        }
        iter-&gt;release();
    }
    <span class="enscript-keyword">if</span> (hasChildren)
        updatePowerClient(gIOPMPowerClientChildren, desiredState);
    <span class="enscript-keyword">else</span>
        removePowerClient(gIOPMPowerClientChildren);

    <span class="enscript-comment">// Iterate through all power clients to determine the min power state.
</span>
    iter = OSCollectionIterator::withCollection(fPowerClients);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-type">const</span> OSSymbol * client;
        <span class="enscript-keyword">while</span> ((client = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
        {
            <span class="enscript-comment">// Ignore child and driver when override is in effect.
</span>            <span class="enscript-keyword">if</span> ((fDeviceOverrideEnabled ||
                (getPMRequestType() == kIOPMRequestTypeRequestPowerStateOverride)) &amp;&amp;
                ((client == gIOPMPowerClientChildren) ||
                 (client == gIOPMPowerClientDriver)))
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">// Ignore child proxy when children are present.
</span>            <span class="enscript-keyword">if</span> (hasChildren &amp;&amp; (client == gIOPMPowerClientChildProxy))
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">// Advisory tickles are irrelevant unless system is in full wake
</span>            <span class="enscript-keyword">if</span> (client == gIOPMPowerClientAdvisoryTickle &amp;&amp;
                !gIOPMAdvisoryTickleEnabled)
                <span class="enscript-keyword">continue</span>;

            desiredState = getPowerStateForClient(client);
            assert(desiredState &lt; fNumberOfPowerStates);
            PM_LOG1(<span class="enscript-string">&quot;  %u %s\n&quot;</span>,
                desiredState, client-&gt;getCStringNoCopy());

            newPowerState = StateMax(newPowerState, desiredState);

            <span class="enscript-keyword">if</span> (client == gIOPMPowerClientDevice)
                fDeviceDesire = desiredState;
        }
        iter-&gt;release();
    }

    <span class="enscript-comment">// Factor in the temporary power desires.
</span>
    newPowerState = StateMax(newPowerState, localClamp);
    newPowerState = StateMax(newPowerState, fTempClampPowerState);

    <span class="enscript-comment">// Limit check against max power override.
</span>
    newPowerState = StateMin(newPowerState, fOverrideMaxPowerState);

    <span class="enscript-comment">// Limit check against number of power states.
</span>
    <span class="enscript-keyword">if</span> (newPowerState &gt;= fNumberOfPowerStates)
        newPowerState = fHighestPowerState;

    fDesiredPowerState = newPowerState;

    PM_LOG1(<span class="enscript-string">&quot;  temp %u, clamp %u, current %u, new %u\n&quot;</span>,
        (uint32_t) localClamp, (uint32_t) fTempClampPowerState,
        (uint32_t) fCurrentPowerState, newPowerState);

    <span class="enscript-keyword">if</span> (!computeOnly)
    {
        <span class="enscript-comment">// Restart idle timer if possible when device desire has increased.
</span>        <span class="enscript-comment">// Or if an advisory desire exists.
</span>
        <span class="enscript-keyword">if</span> (fIdleTimerPeriod &amp;&amp; fIdleTimerStopped)
        {
            restartIdleTimer();
        }

        <span class="enscript-comment">// Invalidate cached tickle power state when desires change, and not
</span>        <span class="enscript-comment">// due to a tickle request. In case the driver has requested a lower
</span>        <span class="enscript-comment">// power state, but the tickle is caching a higher power state which
</span>        <span class="enscript-comment">// will drop future tickles until the cached value is lowered or in-
</span>        <span class="enscript-comment">// validated. The invalidation must occur before the power transition
</span>        <span class="enscript-comment">// to avoid dropping a necessary tickle.
</span>
        <span class="enscript-keyword">if</span> ((getPMRequestType() != kIOPMRequestTypeActivityTickle) &amp;&amp;
            (fActivityTicklePowerState != kInvalidTicklePowerState))
        {
            IOLockLock(fActivityLock);
            fActivityTicklePowerState = kInvalidTicklePowerState;
            IOLockUnlock(fActivityLock);
        }
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] currentPowerConsumption
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-function-name">IOService::currentPowerConsumption</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kIOPMUnknown;

    <span class="enscript-keyword">return</span> fCurrentPowerConsumption;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] getPMworkloop
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOWorkLoop * <span class="enscript-function-name">IOService::getPMworkloop</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> gIOPMWorkLoop;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOT_YET</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// Power Parent/Children Applier
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">applyToPowerChildren</span>(
    IOService *               service,
    IOServiceApplierFunction  applier,
    <span class="enscript-type">void</span> *                    context,
    IOOptionBits              options )
{
    PM_ASSERT_IN_GATE();

    IORegistryEntry *       entry;
    IORegistryIterator *    iter;
    IOPowerConnection *     connection;
    IOService *             child;

    iter = IORegistryIterator::iterateOver(service, gIOPowerPlane, options);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">while</span> ((entry = iter-&gt;getNextObject()))
        {
            <span class="enscript-comment">// Get child of IOPowerConnection objects
</span>            <span class="enscript-keyword">if</span> ((connection = OSDynamicCast(IOPowerConnection, entry)))
            {
                child = (IOService *) connection-&gt;copyChildEntry(gIOPowerPlane);
                <span class="enscript-keyword">if</span> (child)
                {
                    (*applier)(child, context);
                    child-&gt;release();
                }
            }
        }
        iter-&gt;release();
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">applyToPowerParent</span>(
    IOService *               service,
    IOServiceApplierFunction  applier,
    <span class="enscript-type">void</span> *                    context,
    IOOptionBits              options )
{
    PM_ASSERT_IN_GATE();

    IORegistryEntry *       entry;
    IORegistryIterator *    iter;
    IOPowerConnection *     connection;
    IOService *             parent;

    iter = IORegistryIterator::iterateOver(service, gIOPowerPlane,
            options | kIORegistryIterateParents);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">while</span> ((entry = iter-&gt;getNextObject()))
        {
            <span class="enscript-comment">// Get child of IOPowerConnection objects
</span>            <span class="enscript-keyword">if</span> ((connection = OSDynamicCast(IOPowerConnection, entry)))
            {
                parent = (IOService *) connection-&gt;copyParentEntry(gIOPowerPlane);
                <span class="enscript-keyword">if</span> (parent)
                {
                    (*applier)(parent, context);
                    parent-&gt;release();
                }
            }
        }
        iter-&gt;release();
    }
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NOT_YET */</span>

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Activity Tickle &amp; Idle Timer
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setAdvisoryTickleEnable</span>( <span class="enscript-type">bool</span> enable )
{
    gIOPMAdvisoryTickleEnabled = enable;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] activityTickle
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The tickle with parameter kIOPMSuperclassPolicy1 causes the activity
</span><span class="enscript-comment">// flag to be set, and the device state checked.  If the device has been
</span><span class="enscript-comment">// powered down, it is powered up again.
</span><span class="enscript-comment">// The tickle with parameter kIOPMSubclassPolicy is ignored here and
</span><span class="enscript-comment">// should be intercepted by a subclass.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::activityTickle</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNumber )
{
    IOPMRequest *   request;
    <span class="enscript-type">bool</span>            noPowerChange = true;
    uint32_t        tickleFlags;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> true;    <span class="enscript-comment">// no power change
</span>
    <span class="enscript-keyword">if</span> ((type == kIOPMSuperclassPolicy1) &amp;&amp; StateOrder(stateNumber))
    {
        IOLockLock(fActivityLock);

        <span class="enscript-comment">// Record device activity for the idle timer handler.
</span>
        fDeviceWasActive = true;
        fActivityTickleCount++;
        clock_get_uptime(&amp;fDeviceActiveTimestamp);

        PM_ACTION_0(actionActivityTickle);

        <span class="enscript-comment">// Record the last tickle power state.
</span>        <span class="enscript-comment">// This helps to filter out redundant tickles as
</span>        <span class="enscript-comment">// this function may be called from the data path.
</span>
        <span class="enscript-keyword">if</span> ((fActivityTicklePowerState == kInvalidTicklePowerState)
        || StateOrder(fActivityTicklePowerState) &lt; StateOrder(stateNumber))
        {
            fActivityTicklePowerState = stateNumber;
            noPowerChange = false;

            tickleFlags = kTickleTypeActivity | kTickleTypePowerRise;
            request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeActivityTickle );
            <span class="enscript-keyword">if</span> (request)
            {
                request-&gt;fArg0 = (<span class="enscript-type">void</span> *)            stateNumber;
                request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) tickleFlags;
                request-&gt;fArg2 = (<span class="enscript-type">void</span> *)(uintptr_t) gIOPMTickleGeneration;
                submitPMRequest(request);
            }
        }

        IOLockUnlock(fActivityLock);
    }

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((type == kIOPMActivityTickleTypeAdvisory) &amp;&amp;
             ((stateNumber = fDeviceUsablePowerState) != kPowerStateZero))
    {
        IOLockLock(fActivityLock);

        fAdvisoryTickled = true;

        <span class="enscript-keyword">if</span> (fAdvisoryTicklePowerState != stateNumber)
        {
            fAdvisoryTicklePowerState = stateNumber;
            noPowerChange = false;

            tickleFlags = kTickleTypeAdvisory | kTickleTypePowerRise;
            request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeActivityTickle );
            <span class="enscript-keyword">if</span> (request)
            {
                request-&gt;fArg0 = (<span class="enscript-type">void</span> *)            stateNumber;
                request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) tickleFlags;
                request-&gt;fArg2 = (<span class="enscript-type">void</span> *)(uintptr_t) gIOPMTickleGeneration;
                submitPMRequest(request);
            }
        }

        IOLockUnlock(fActivityLock);
    }

    <span class="enscript-comment">// Returns false if the activityTickle might cause a transition to a
</span>    <span class="enscript-comment">// higher powered state, true otherwise.
</span>
    <span class="enscript-keyword">return</span> noPowerChange;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] handleActivityTickle
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleActivityTickle</span>( IOPMRequest * request )
{
    uint32_t ticklePowerState   = (uint32_t)(uintptr_t) request-&gt;fArg0;
    uint32_t tickleFlags        = (uint32_t)(uintptr_t) request-&gt;fArg1;
    uint32_t tickleGeneration   = (uint32_t)(uintptr_t) request-&gt;fArg2;
    <span class="enscript-type">bool</span>     adjustPower        = false;

    PM_ASSERT_IN_GATE();
    <span class="enscript-keyword">if</span> (fResetPowerStateOnWake &amp;&amp; (tickleGeneration != gIOPMTickleGeneration))
    {
        <span class="enscript-comment">// Drivers that don't want power restored on wake will drop any
</span>        <span class="enscript-comment">// tickles that pre-dates the current system wake. The model is
</span>        <span class="enscript-comment">// that each wake is a fresh start, with power state depressed
</span>        <span class="enscript-comment">// until a new tickle or an explicit power up request from the
</span>        <span class="enscript-comment">// driver. It is possible for the PM work loop to enter the
</span>        <span class="enscript-comment">// system sleep path with tickle requests queued.
</span>
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (tickleFlags &amp; kTickleTypeActivity)
    {
        IOPMPowerStateIndex deviceDesireOrder = StateOrder(fDeviceDesire);
        uint32_t idleTimerGeneration = ticklePowerState; <span class="enscript-comment">// kTickleTypePowerDrop
</span>
        <span class="enscript-keyword">if</span> (tickleFlags &amp; kTickleTypePowerRise)
        {
            <span class="enscript-keyword">if</span> ((StateOrder(ticklePowerState) &gt; deviceDesireOrder) &amp;&amp;
                (ticklePowerState &lt; fNumberOfPowerStates))
            {
                fIdleTimerMinPowerState = ticklePowerState;
                updatePowerClient(gIOPMPowerClientDevice, ticklePowerState);
                adjustPower = true;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((deviceDesireOrder &gt; StateOrder(fIdleTimerMinPowerState)) &amp;&amp;
                 (idleTimerGeneration == fIdleTimerGeneration))
        {
            <span class="enscript-comment">// Power drop due to idle timer expiration.
</span>            <span class="enscript-comment">// Do not allow idle timer to reduce power below tickle power.
</span>            <span class="enscript-comment">// This prevents the idle timer from decreasing the device desire
</span>            <span class="enscript-comment">// to zero and cancelling the effect of a pre-sleep tickle when
</span>            <span class="enscript-comment">// system wakes up to doze state, while the device is unable to
</span>            <span class="enscript-comment">// raise its power state to satisfy the tickle.
</span>
            deviceDesireOrder--;
            <span class="enscript-keyword">if</span> (deviceDesireOrder &lt; fNumberOfPowerStates)
            {
                ticklePowerState = fPowerStates[deviceDesireOrder].stateOrderToIndex;
                updatePowerClient(gIOPMPowerClientDevice, ticklePowerState);
                adjustPower = true;
            }
        }
    }
    <span class="enscript-keyword">else</span>    <span class="enscript-comment">// advisory tickle
</span>    {
        <span class="enscript-keyword">if</span> (tickleFlags &amp; kTickleTypePowerRise)
        {
            <span class="enscript-keyword">if</span> ((ticklePowerState == fDeviceUsablePowerState) &amp;&amp;
                (ticklePowerState &lt; fNumberOfPowerStates))
            {
                updatePowerClient(gIOPMPowerClientAdvisoryTickle, ticklePowerState);
                fHasAdvisoryDesire = true;
                fAdvisoryTickleUsed = true;
                adjustPower = true;
            }
            <span class="enscript-keyword">else</span>
            {
                IOLockLock(fActivityLock);
                fAdvisoryTicklePowerState = kInvalidTicklePowerState;
                IOLockUnlock(fActivityLock);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fHasAdvisoryDesire)
        {
            removePowerClient(gIOPMPowerClientAdvisoryTickle);
            fHasAdvisoryDesire = false;
            adjustPower = true;
        }
    }

    <span class="enscript-keyword">if</span> (adjustPower)
    {
        adjustPowerState();
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// [public] setIdleTimerPeriod
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A subclass policy-maker is using our standard idleness detection service.
</span><span class="enscript-comment">// Start the idle timer. Period is in seconds.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::setIdleTimerPeriod</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> period )
{
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    OUR_PMLog(kPMLogSetIdleTimerPeriod, period, fIdleTimerPeriod);

    IOPMRequest * request =
        acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeSetIdleTimerPeriod );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    request-&gt;fArg0 = (<span class="enscript-type">void</span> *) period;
    submitPMRequest( request );

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::setIgnoreIdleTimer</span>( <span class="enscript-type">bool</span> ignore )
{
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> IOPMNotYetInitialized;

    OUR_PMLog(kIOPMRequestTypeIgnoreIdleTimer, ignore, 0);

    IOPMRequest * request =
        acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeIgnoreIdleTimer );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    request-&gt;fArg0 = (<span class="enscript-type">void</span> *) ignore;
    submitPMRequest( request );

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// [public] nextIdleTimeout
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Returns how many &quot;seconds from now&quot; the device should idle into its
</span><span class="enscript-comment">// next lowest power state.
</span><span class="enscript-comment">//******************************************************************************
</span>
SInt32 <span class="enscript-function-name">IOService::nextIdleTimeout</span>(
    AbsoluteTime currentTime,
    AbsoluteTime lastActivity,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> powerState)
{
    AbsoluteTime        delta;
    UInt64              delta_ns;
    SInt32              delta_secs;
    SInt32              delay_secs;

    <span class="enscript-comment">// Calculate time difference using funky macro from clock.h.
</span>    delta = currentTime;
    SUB_ABSOLUTETIME(&amp;delta, &amp;lastActivity);

    <span class="enscript-comment">// Figure it in seconds.
</span>    absolutetime_to_nanoseconds(delta, &amp;delta_ns);
    delta_secs = (SInt32)(delta_ns / NSEC_PER_SEC);

    <span class="enscript-comment">// Be paranoid about delta somehow exceeding timer period.
</span>    <span class="enscript-keyword">if</span> (delta_secs &lt; (<span class="enscript-type">int</span>) fIdleTimerPeriod)
        delay_secs = (<span class="enscript-type">int</span>) fIdleTimerPeriod - delta_secs;
    <span class="enscript-keyword">else</span>
        delay_secs = (<span class="enscript-type">int</span>) fIdleTimerPeriod;

    <span class="enscript-keyword">return</span> (SInt32)delay_secs;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] start_PM_idle_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::start_PM_idle_timer</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span>    maxTimeout = 100000;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span>    minTimeout = 1;
    AbsoluteTime        uptime, deadline;
    SInt32              idle_in = 0;
    boolean_t           pending;

    <span class="enscript-keyword">if</span> (!initialized || !fIdleTimerPeriod)
        <span class="enscript-keyword">return</span>;

    IOLockLock(fActivityLock);

    clock_get_uptime(&amp;uptime);

    <span class="enscript-comment">// Subclasses may modify idle sleep algorithm
</span>    idle_in = nextIdleTimeout(uptime, fDeviceActiveTimestamp, fCurrentPowerState);

    <span class="enscript-comment">// Check for out-of range responses
</span>    <span class="enscript-keyword">if</span> (idle_in &gt; maxTimeout)
    {
        <span class="enscript-comment">// use standard implementation
</span>        idle_in = IOService::nextIdleTimeout(uptime,
                        fDeviceActiveTimestamp,
                        fCurrentPowerState);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (idle_in &lt; minTimeout) {
        idle_in = fIdleTimerPeriod;
    }

    IOLockUnlock(fActivityLock);

    fNextIdleTimerPeriod = idle_in;
    fIdleTimerStartTime = uptime;

    retain();
    clock_interval_to_absolutetime_interval(idle_in, kSecondScale, &amp;deadline);
    ADD_ABSOLUTETIME(&amp;deadline, &amp;uptime);
    pending = thread_call_enter_delayed(fIdleTimer, deadline);
    <span class="enscript-keyword">if</span> (pending) release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] restartIdleTimer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::restartIdleTimer</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (fDeviceDesire != kPowerStateZero)
    {
        fIdleTimerStopped = false;
        fActivityTickleCount = 0;
        start_PM_idle_timer();
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fHasAdvisoryDesire)
    {
        fIdleTimerStopped = false;
        start_PM_idle_timer();
    }
    <span class="enscript-keyword">else</span>
    {
        fIdleTimerStopped = true;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// idle_timer_expired
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">idle_timer_expired</span>(
    thread_call_param_t arg0, thread_call_param_t arg1 )
{
    IOService * me = (IOService *) arg0;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop)
        gIOPMWorkLoop-&gt;runAction(
            OSMemberFunctionCast(IOWorkLoop::Action, me,
                &amp;IOService::idleTimerExpired),
            me);

    me-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] idleTimerExpired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The idle timer has expired. If there has been activity since the last
</span><span class="enscript-comment">// expiration, just restart the timer and return.  If there has not been
</span><span class="enscript-comment">// activity, switch to the next lower power state and restart the timer.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::idleTimerExpired</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest *   request;
    <span class="enscript-type">bool</span>            restartTimer = true;
    uint32_t        tickleFlags;

    <span class="enscript-keyword">if</span> ( !initialized || !fIdleTimerPeriod || fIdleTimerStopped ||
         fLockedFlags.PMStop )
        <span class="enscript-keyword">return</span>;

    fIdleTimerStartTime = 0;

    IOLockLock(fActivityLock);

    <span class="enscript-comment">// Check for device activity (tickles) over last timer period.
</span>
    <span class="enscript-keyword">if</span> (fDeviceWasActive)
    {
        <span class="enscript-comment">// Device was active - do not drop power, restart timer.
</span>        fDeviceWasActive = false;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!fIdleTimerIgnored)
    {
        <span class="enscript-comment">// No device activity - drop power state by one level.
</span>        <span class="enscript-comment">// Decrement the cached tickle power state when possible.
</span>        <span class="enscript-comment">// This value may be kInvalidTicklePowerState before activityTickle()
</span>        <span class="enscript-comment">// is called, but the power drop request must be issued regardless.
</span>
        <span class="enscript-keyword">if</span> ((fActivityTicklePowerState != kInvalidTicklePowerState) &amp;&amp;
            (fActivityTicklePowerState != kPowerStateZero))
            fActivityTicklePowerState--;

        tickleFlags = kTickleTypeActivity | kTickleTypePowerDrop;
        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeActivityTickle );
        <span class="enscript-keyword">if</span> (request)
        {
            request-&gt;fArg0 = (<span class="enscript-type">void</span> *)(uintptr_t) fIdleTimerGeneration;
            request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) tickleFlags;
            request-&gt;fArg2 = (<span class="enscript-type">void</span> *)(uintptr_t) gIOPMTickleGeneration;
            submitPMRequest( request );

            <span class="enscript-comment">// Do not restart timer until after the tickle request has been
</span>            <span class="enscript-comment">// processed.
</span>
            restartTimer = false;
        }
    }

    <span class="enscript-keyword">if</span> (fAdvisoryTickled)
    {
        fAdvisoryTickled = false;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fHasAdvisoryDesire)
    {
        <span class="enscript-comment">// Want new tickles to turn into pm request after we drop the lock
</span>        fAdvisoryTicklePowerState = kInvalidTicklePowerState;

        tickleFlags = kTickleTypeAdvisory | kTickleTypePowerDrop;
        request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeActivityTickle );
        <span class="enscript-keyword">if</span> (request)
        {
            request-&gt;fArg0 = (<span class="enscript-type">void</span> *)(uintptr_t) fIdleTimerGeneration;
            request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) tickleFlags;
            request-&gt;fArg2 = (<span class="enscript-type">void</span> *)(uintptr_t) gIOPMTickleGeneration;
            submitPMRequest( request );

            <span class="enscript-comment">// Do not restart timer until after the tickle request has been
</span>            <span class="enscript-comment">// processed.
</span>
            restartTimer = false;
        }
    }

    IOLockUnlock(fActivityLock);

    <span class="enscript-keyword">if</span> (restartTimer)
        start_PM_idle_timer();
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] PM_idle_timer_expiration
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PM_idle_timer_expiration</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] command_received
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::command_received</span>( <span class="enscript-type">void</span> *statePtr , <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> * , <span class="enscript-type">void</span> * )
{
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] setAggressiveness
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Pass on the input parameters to all power domain children. All those which are
</span><span class="enscript-comment">// power domains will pass it on to their children, etc.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::setAggressiveness</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> newLevel )
{
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] getAggressiveness
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by the user client.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::getAggressiveness</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> type, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> * currentLevel )
{
    IOPMrootDomain *    rootDomain = getPMRootDomain();

    <span class="enscript-keyword">if</span> (!rootDomain)
        <span class="enscript-keyword">return</span> kIOReturnNotReady;

    <span class="enscript-keyword">return</span> rootDomain-&gt;getAggressiveness( type, currentLevel );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] getPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*********************************************************************************
</span>
UInt32 <span class="enscript-function-name">IOService::getPowerState</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> kPowerStateZero;

    <span class="enscript-keyword">return</span> fCurrentPowerState;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] systemWake
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Pass this to all power domain children. All those which are
</span><span class="enscript-comment">// power domains will pass it on to their children, etc.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::systemWake</span>( <span class="enscript-type">void</span> )
{
    OSIterator *        iter;
    OSObject *          next;
    IOPowerConnection * connection;
    IOService *         theChild;

    iter = getChildIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ( (next = iter-&gt;getNextObject()) )
        {
            <span class="enscript-keyword">if</span> ( (connection = OSDynamicCast(IOPowerConnection, next)) )
            {
                <span class="enscript-keyword">if</span> (connection-&gt;getReadyFlag() == false)
                {
                    PM_LOG3(<span class="enscript-string">&quot;[%s] %s: connection not ready\n&quot;</span>,
                        getName(), __FUNCTION__);
                    <span class="enscript-keyword">continue</span>;
                }

                theChild = (IOService *)connection-&gt;copyChildEntry(gIOPowerPlane);
                <span class="enscript-keyword">if</span> ( theChild )
                {
                    theChild-&gt;systemWake();
                    theChild-&gt;release();
                }
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-keyword">if</span> ( fControllingDriver != NULL )
    {
        <span class="enscript-keyword">if</span> ( fControllingDriver-&gt;didYouWakeSystem() )
        {
            makeUsable();
        }
    }

    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] temperatureCriticalForZone
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::temperatureCriticalForZone</span>( IOService * whichZone )
{
    IOService * theParent;
    IOService * theNub;

    OUR_PMLog(kPMLogCriticalTemp, 0, 0);

    <span class="enscript-keyword">if</span> ( inPlane(gIOPowerPlane) &amp;&amp; !IS_PM_ROOT )
    {
        theNub = (IOService *)copyParentEntry(gIOPowerPlane);
        <span class="enscript-keyword">if</span> ( theNub )
        {
            theParent = (IOService *)theNub-&gt;copyParentEntry(gIOPowerPlane);
            theNub-&gt;release();
            <span class="enscript-keyword">if</span> ( theParent )
            {
                theParent-&gt;temperatureCriticalForZone(whichZone);
                theParent-&gt;release();
            }
        }
    }
    <span class="enscript-keyword">return</span> IOPMNoErr;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Power Change (Common)
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] startPowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All power state changes starts here.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::startPowerChange</span>(
    IOPMPowerChangeFlags    changeFlags,
    IOPMPowerStateIndex     powerState,
    IOPMPowerFlags          domainFlags,
    IOPowerConnection *     parentConnection,
    IOPMPowerFlags          parentFlags )
{
    PM_ASSERT_IN_GATE();
    assert( fMachineState == kIOPM_Finished );
    assert( powerState &lt; fNumberOfPowerStates );

    <span class="enscript-keyword">if</span> (powerState &gt;= fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> IOPMAckImplied;

    fIsPreChange = true;
    PM_ACTION_2(actionPowerChangeOverride, &amp;powerState, &amp;changeFlags);

    <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMExpireIdleTimer)
    {
        <span class="enscript-comment">// Root domain requested removal of tickle influence
</span>        <span class="enscript-keyword">if</span> (StateOrder(fDeviceDesire) &gt; StateOrder(powerState))
        {
            <span class="enscript-comment">// Reset device desire down to the clamped power state
</span>            updatePowerClient(gIOPMPowerClientDevice, powerState);
            computeDesiredState(kPowerStateZero, true);

            <span class="enscript-comment">// Invalidate tickle cache so the next tickle will issue a request
</span>            IOLockLock(fActivityLock);
            fDeviceWasActive = false;
            fActivityTicklePowerState = kInvalidTicklePowerState;
            IOLockUnlock(fActivityLock);

            fIdleTimerMinPowerState = kPowerStateZero;
        }
    }

    <span class="enscript-comment">// Root domain's override handler may cancel the power change by
</span>    <span class="enscript-comment">// setting the kIOPMNotDone flag.
</span>
    <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMNotDone)
        <span class="enscript-keyword">return</span> IOPMAckImplied;

    <span class="enscript-comment">// Forks to either Driver or Parent initiated power change paths.
</span>
    fHeadNoteChangeFlags      = changeFlags;
    fHeadNotePowerState       = powerState;
    fHeadNotePowerArrayEntry  = &amp;fPowerStates[ powerState ];
    fHeadNoteParentConnection = NULL;

    <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMSelfInitiated)
    {
        <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMSynchronize)
            OurSyncStart();
        <span class="enscript-keyword">else</span>
            OurChangeStart();
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">else</span>
    {
        assert(changeFlags &amp; kIOPMParentInitiated);
        fHeadNoteDomainFlags = domainFlags;
        fHeadNoteParentFlags = parentFlags;
        fHeadNoteParentConnection = parentConnection;
        <span class="enscript-keyword">return</span> ParentChangeStart();
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyInterestedDrivers
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::notifyInterestedDrivers</span>( <span class="enscript-type">void</span> )
{
    IOPMinformee *      informee;
    IOPMinformeeList *  list = fInterestedDrivers;
    DriverCallParam *   param;
    IOItemCount         count;

    PM_ASSERT_IN_GATE();
    assert( fDriverCallParamCount == 0 );
    assert( fHeadNotePendingAcks == 0 );

    fHeadNotePendingAcks = 0;

    count = list-&gt;numberOfItems();
    <span class="enscript-keyword">if</span> (!count)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;  <span class="enscript-comment">// no interested drivers
</span>
    <span class="enscript-comment">// Allocate an array of interested drivers and their return values
</span>    <span class="enscript-comment">// for the callout thread. Everything else is still &quot;owned&quot; by the
</span>    <span class="enscript-comment">// PM work loop, which can run to process acknowledgePowerChange()
</span>    <span class="enscript-comment">// responses.
</span>
    param = (DriverCallParam *) fDriverCallParamPtr;
    <span class="enscript-keyword">if</span> (count &gt; fDriverCallParamSlots)
    {
        <span class="enscript-keyword">if</span> (fDriverCallParamSlots)
        {
            assert(fDriverCallParamPtr);
            IODelete(fDriverCallParamPtr, DriverCallParam, fDriverCallParamSlots);
            fDriverCallParamPtr = 0;
            fDriverCallParamSlots = 0;
        }

        param = IONew(DriverCallParam, count);
        <span class="enscript-keyword">if</span> (!param)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;  <span class="enscript-comment">// no memory
</span>
        fDriverCallParamPtr   = (<span class="enscript-type">void</span> *) param;
        fDriverCallParamSlots = count;
    }

    informee = list-&gt;firstInList();
    assert(informee);
    <span class="enscript-keyword">for</span> (IOItemCount i = 0; i &lt; count; i++)
    {
        informee-&gt;timer = -1;
        param[i].Target = informee;
        informee-&gt;retain();
        informee = list-&gt;nextInList( informee );
    }

    fDriverCallParamCount = count;
    fHeadNotePendingAcks  = count;

    <span class="enscript-comment">// Block state machine and wait for callout completion.
</span>    assert(!fDriverCallBusy);
    fDriverCallBusy = true;
    thread_call_enter( fDriverCallEntry );
    <span class="enscript-keyword">return</span> true;

<span class="enscript-reference">done</span>:
    <span class="enscript-comment">// Return false if there are no interested drivers or could not schedule
</span>    <span class="enscript-comment">// callout thread due to error.
</span>    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyInterestedDriversDone
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyInterestedDriversDone</span>( <span class="enscript-type">void</span> )
{
    IOPMinformee *      informee;
    IOItemCount         count;
    DriverCallParam *   param;
    IOReturn            result;

    PM_ASSERT_IN_GATE();
    assert( fDriverCallBusy == false );
    assert( fMachineState == kIOPM_DriverThreadCallDone );

    param = (DriverCallParam *) fDriverCallParamPtr;
    count = fDriverCallParamCount;

    <span class="enscript-keyword">if</span> (param &amp;&amp; count)
    {
        <span class="enscript-keyword">for</span> (IOItemCount i = 0; i &lt; count; i++, param++)
        {
            informee = (IOPMinformee *) param-&gt;Target;
            result   = param-&gt;Result;

            <span class="enscript-keyword">if</span> ((result == IOPMAckImplied) || (result &lt; 0))
            {
                <span class="enscript-comment">// Interested driver return IOPMAckImplied.
</span>                <span class="enscript-comment">// If informee timer is zero, it must have de-registered
</span>                <span class="enscript-comment">// interest during the thread callout. That also drops
</span>                <span class="enscript-comment">// the pending ack count.
</span>
                <span class="enscript-keyword">if</span> (fHeadNotePendingAcks &amp;&amp; informee-&gt;timer)
                    fHeadNotePendingAcks--;

                informee-&gt;timer = 0;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (informee-&gt;timer)
            {
                assert(informee-&gt;timer == -1);

                <span class="enscript-comment">// Driver has not acked, and has returned a positive result.
</span>                <span class="enscript-comment">// Enforce a minimum permissible timeout value.
</span>                <span class="enscript-comment">// Make the min value large enough so timeout is less likely
</span>                <span class="enscript-comment">// to occur if a driver misinterpreted that the return value
</span>                <span class="enscript-comment">// should be in microsecond units.  And make it large enough
</span>                <span class="enscript-comment">// to be noticeable if a driver neglects to ack.
</span>
                <span class="enscript-keyword">if</span> (result &lt; kMinAckTimeoutTicks)
                    result = kMinAckTimeoutTicks;

                informee-&gt;timer = (result / (ACK_TIMER_PERIOD / ns_per_us)) + 1;
            }
            <span class="enscript-comment">// else, child has already acked or driver has removed interest,
</span>            <span class="enscript-comment">// and head_note_pendingAcks decremented.
</span>            <span class="enscript-comment">// informee may have been removed from the interested drivers list,
</span>            <span class="enscript-comment">// thus the informee must be retained across the callout.
</span>
            informee-&gt;release();
        }

        fDriverCallParamCount = 0;

        <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks )
        {
            OUR_PMLog(kPMLogStartAckTimer, 0, 0);
            start_ack_timer();
        }
    }

    MS_POP();  <span class="enscript-comment">// pop the machine state passed to notifyAll()
</span>
    <span class="enscript-comment">// If interest acks are outstanding, block the state machine until
</span>    <span class="enscript-comment">// fHeadNotePendingAcks drops to zero before notifying root domain.
</span>    <span class="enscript-comment">// Otherwise notify root domain directly.
</span>
    <span class="enscript-keyword">if</span> (!fHeadNotePendingAcks)
    {
        notifyRootDomain();
    }
    <span class="enscript-keyword">else</span>
    {
        MS_PUSH(fMachineState);
        fMachineState = kIOPM_NotifyChildrenStart;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyRootDomain
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyRootDomain</span>( <span class="enscript-type">void</span> )
{
    assert( fDriverCallBusy == false );

    <span class="enscript-comment">// Only for root domain in the will-change phase
</span>    <span class="enscript-keyword">if</span> (!IS_ROOT_DOMAIN || (fMachineState != kIOPM_OurChangeSetPowerState))
    {
        notifyChildren();
        <span class="enscript-keyword">return</span>;
    }

    MS_PUSH(fMachineState);  <span class="enscript-comment">// push notifyAll() machine state
</span>    fMachineState = kIOPM_DriverThreadCallDone;

    <span class="enscript-comment">// Call IOPMrootDomain::willNotifyPowerChildren() on a thread call
</span>    <span class="enscript-comment">// to avoid a deadlock.
</span>    fDriverCallReason = kRootDomainInformPreChange;
    fDriverCallBusy   = true;
    thread_call_enter( fDriverCallEntry );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyRootDomainDone</span>( <span class="enscript-type">void</span> )
{
    assert( fDriverCallBusy == false );
    assert( fMachineState == kIOPM_DriverThreadCallDone );

    MS_POP();   <span class="enscript-comment">// pop notifyAll() machine state
</span>    notifyChildren();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyChildren
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyChildren</span>( <span class="enscript-type">void</span> )
{
    OSIterator *        iter;
    OSObject *          next;
    IOPowerConnection * connection;
    OSArray *           children = 0;
    IOPMrootDomain *    rootDomain;
    <span class="enscript-type">bool</span>                delayNotify = false;

    <span class="enscript-keyword">if</span> ((fHeadNotePowerState != fCurrentPowerState) &amp;&amp;
        (IS_POWER_DROP == fIsPreChange) &amp;&amp;
        ((rootDomain = getPMRootDomain()) == <span class="enscript-keyword">this</span>))
    {
        rootDomain-&gt;tracePoint( IS_POWER_DROP ?
            kIOPMTracePointSleepPowerPlaneDrivers :
            kIOPMTracePointWakePowerPlaneDrivers  );
    }

    <span class="enscript-keyword">if</span> (fStrictTreeOrder)
        children = OSArray::withCapacity(8);

    <span class="enscript-comment">// Sum child power consumption in notifyChild()
</span>    fHeadNotePowerArrayEntry-&gt;staticPower = 0;

    iter = getChildIterator(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( iter )
    {
        <span class="enscript-keyword">while</span> ((next = iter-&gt;getNextObject()))
        {
            <span class="enscript-keyword">if</span> ((connection = OSDynamicCast(IOPowerConnection, next)))
            {
                <span class="enscript-keyword">if</span> (connection-&gt;getReadyFlag() == false)
                {
                    PM_LOG3(<span class="enscript-string">&quot;[%s] %s: connection not ready\n&quot;</span>,
                        getName(), __FUNCTION__);
                    <span class="enscript-keyword">continue</span>;
                }

                <span class="enscript-comment">// Mechanism to postpone the did-change notification to
</span>                <span class="enscript-comment">// certain power children to order those children last.
</span>                <span class="enscript-comment">// Cannot be used together with strict tree ordering.
</span>
                <span class="enscript-keyword">if</span> (!fIsPreChange &amp;&amp;
                    connection-&gt;delayChildNotification &amp;&amp;
                    getPMRootDomain()-&gt;shouldDelayChildNotification(<span class="enscript-keyword">this</span>))
                {
                    <span class="enscript-keyword">if</span> (!children)
                    {
                        children = OSArray::withCapacity(8);
                        <span class="enscript-keyword">if</span> (children)
                            delayNotify = true;
                    }
                    <span class="enscript-keyword">if</span> (delayNotify)
                    {
                        children-&gt;setObject( connection );
                        <span class="enscript-keyword">continue</span>;
                    }
                }

                <span class="enscript-keyword">if</span> (!delayNotify &amp;&amp; children)
                    children-&gt;setObject( connection );
                <span class="enscript-keyword">else</span>
                    notifyChild( connection );
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-keyword">if</span> (children &amp;&amp; (children-&gt;getCount() == 0))
    {
        children-&gt;release();
        children = 0;
    }
    <span class="enscript-keyword">if</span> (children)
    {
        assert(fNotifyChildArray == 0);
        fNotifyChildArray = children;
        MS_PUSH(fMachineState);

        <span class="enscript-keyword">if</span> (delayNotify)
        {
            <span class="enscript-comment">// Block until all non-delayed children have acked their
</span>            <span class="enscript-comment">// notification. Then notify the remaining delayed child
</span>            <span class="enscript-comment">// in the array. This is used to hold off graphics child
</span>            <span class="enscript-comment">// notification while the rest of the system powers up.
</span>            <span class="enscript-comment">// If a hid tickle arrives during this time, the delayed
</span>            <span class="enscript-comment">// children are immediately notified and root domain will
</span>            <span class="enscript-comment">// not clamp power for dark wake.
</span>
            fMachineState = kIOPM_NotifyChildrenDelayed;
            PM_LOG2(<span class="enscript-string">&quot;%s: %d children in delayed array\n&quot;</span>,
                getName(), children-&gt;getCount());
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Child array created to support strict notification order.
</span>            <span class="enscript-comment">// Notify children in the array one at a time.
</span>
            fMachineState = kIOPM_NotifyChildrenOrdered;
        }
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyChildrenOrdered
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyChildrenOrdered</span>( <span class="enscript-type">void</span> )
{
    PM_ASSERT_IN_GATE();
    assert(fNotifyChildArray);
    assert(fMachineState == kIOPM_NotifyChildrenOrdered);

    <span class="enscript-comment">// Notify one child, wait for it to ack, then repeat for next child.
</span>    <span class="enscript-comment">// This is a workaround for some drivers with multiple instances at
</span>    <span class="enscript-comment">// the same branch in the power tree, but the driver is slow to power
</span>    <span class="enscript-comment">// up unless the tree ordering is observed. Problem observed only on
</span>    <span class="enscript-comment">// system wake, not on system sleep.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// We have the ability to power off in reverse child index order.
</span>    <span class="enscript-comment">// That works nicely on some machines, but not on all HW configs.
</span>
    <span class="enscript-keyword">if</span> (fNotifyChildArray-&gt;getCount())
    {
        IOPowerConnection * connection;
        connection = (IOPowerConnection *) fNotifyChildArray-&gt;getObject(0);
        notifyChild( connection );
        fNotifyChildArray-&gt;removeObject(0);
    }
    <span class="enscript-keyword">else</span>
    {
        fNotifyChildArray-&gt;release();
        fNotifyChildArray = 0;

        MS_POP();   <span class="enscript-comment">// pushed by notifyChildren()
</span>    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyChildrenDelayed
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyChildrenDelayed</span>( <span class="enscript-type">void</span> )
{
    IOPowerConnection * connection;

    PM_ASSERT_IN_GATE();
    assert(fNotifyChildArray);
    assert(fMachineState == kIOPM_NotifyChildrenDelayed);

    <span class="enscript-comment">// Wait after all non-delayed children and interested drivers have ack'ed,
</span>    <span class="enscript-comment">// then notify all delayed children. If notify delay is canceled, child
</span>    <span class="enscript-comment">// acks may be outstanding with PM blocked on fHeadNotePendingAcks != 0.
</span>    <span class="enscript-comment">// But the handling for either case is identical.
</span>
    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; ; i++)
    {
        connection = (IOPowerConnection *) fNotifyChildArray-&gt;getObject(i);
        <span class="enscript-keyword">if</span> (!connection)
            <span class="enscript-keyword">break</span>;

        notifyChild( connection );
    }

    PM_LOG2(<span class="enscript-string">&quot;%s: notified delayed children\n&quot;</span>, getName());
    fNotifyChildArray-&gt;release();
    fNotifyChildArray = 0;

    MS_POP();   <span class="enscript-comment">// pushed by notifyChildren()
</span>}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyAll
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::notifyAll</span>( uint32_t nextMS )
{
    <span class="enscript-comment">// Save the machine state to be restored by notifyInterestedDriversDone()
</span>
    PM_ASSERT_IN_GATE();
    MS_PUSH(nextMS);
    fMachineState     = kIOPM_DriverThreadCallDone;
    fDriverCallReason = fIsPreChange ?
                        kDriverCallInformPreChange : kDriverCallInformPostChange;

    <span class="enscript-keyword">if</span> (!notifyInterestedDrivers())
        notifyInterestedDriversDone();

    <span class="enscript-keyword">return</span> IOPMWillAckLater;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private, static] pmDriverCallout
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Thread call context
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::actionDriverCalloutDone</span>(
    OSObject * target,
    <span class="enscript-type">void</span> * arg0, <span class="enscript-type">void</span> * arg1,
    <span class="enscript-type">void</span> * arg2, <span class="enscript-type">void</span> * arg3 )
{
    IOServicePM * pwrMgt = (IOServicePM *) arg0;

    assert( fDriverCallBusy );
    fDriverCallBusy = false;

    assert(gIOPMWorkQueue);
    gIOPMWorkQueue-&gt;signalWorkAvailable();

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::pmDriverCallout</span>( IOService * from )
{
    assert(from);
    <span class="enscript-keyword">switch</span> (from-&gt;fDriverCallReason)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallSetPowerState</span>:
            from-&gt;driverSetPowerState();
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallInformPreChange</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallInformPostChange</span>:
            from-&gt;driverInformPowerChange();
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kRootDomainInformPreChange</span>:
            getPMRootDomain()-&gt;willNotifyPowerChildren(from-&gt;fHeadNotePowerState);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            panic(<span class="enscript-string">&quot;IOService::pmDriverCallout bad machine state %x&quot;</span>,
                from-&gt;fDriverCallReason);
    }

    gIOPMWorkLoop-&gt;runAction(actionDriverCalloutDone,
        <span class="enscript-comment">/* target */</span> from,
        <span class="enscript-comment">/* arg0   */</span> (<span class="enscript-type">void</span> *) from-&gt;pwrMgt );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] driverSetPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Thread call context
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::driverSetPowerState</span>( <span class="enscript-type">void</span> )
{
    IOPMPowerStateIndex powerState;
    DriverCallParam *   param;
    IOPMDriverCallEntry callEntry;
    AbsoluteTime        end;
    IOReturn            result;
    uint32_t            oldPowerState = getPowerState();

    assert( fDriverCallBusy );
    assert( fDriverCallParamPtr );
    assert( fDriverCallParamCount == 1 );

    param = (DriverCallParam *) fDriverCallParamPtr;
    powerState = fHeadNotePowerState;

    <span class="enscript-keyword">if</span> (assertPMDriverCall(&amp;callEntry))
    {
        OUR_PMLog(          kPMLogProgramHardware, (uintptr_t) <span class="enscript-keyword">this</span>, powerState);
        start_spindump_timer(<span class="enscript-string">&quot;SetState&quot;</span>);
        clock_get_uptime(&amp;fDriverCallStartTime);
        result = fControllingDriver-&gt;setPowerState( powerState, <span class="enscript-keyword">this</span> );
        clock_get_uptime(&amp;end);
        stop_spindump_timer();
        OUR_PMLog((UInt32) -kPMLogProgramHardware, (uintptr_t) <span class="enscript-keyword">this</span>, (UInt32) result);

        deassertPMDriverCall(&amp;callEntry);

        <span class="enscript-comment">// Record the most recent max power state residency timings.
</span>        <span class="enscript-comment">// Use with DeviceActiveTimestamp to diagnose tickle issues.
</span>        <span class="enscript-keyword">if</span> (powerState == fHighestPowerState)
            fMaxPowerStateEntryTime = end;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (oldPowerState == fHighestPowerState)
            fMaxPowerStateExitTime = end;

        <span class="enscript-keyword">if</span> (result &lt; 0)
        {
            PM_LOG(<span class="enscript-string">&quot;%s::setPowerState(%p, %lu -&gt; %lu) returned 0x%x\n&quot;</span>,
                fName, OBFUSCATE(<span class="enscript-keyword">this</span>), fCurrentPowerState, powerState, result);
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>
        <span class="enscript-keyword">if</span> ((result == IOPMAckImplied) || (result &lt; 0))
        {
            uint64_t    nsec;

            SUB_ABSOLUTETIME(&amp;end, &amp;fDriverCallStartTime);
            absolutetime_to_nanoseconds(end, &amp;nsec);
            <span class="enscript-keyword">if</span> (nsec &gt; LOG_SETPOWER_TIMES) {
                getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                    gIOPMStatsDriverPSChangeSlow,
                    fName, kDriverCallSetPowerState, NS_TO_MS(nsec), 0, NULL, powerState);
            }
        }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">else</span>
        result = kIOPMAckImplied;

    param-&gt;Result = result;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] driverInformPowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Thread call context
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::driverInformPowerChange</span>( <span class="enscript-type">void</span> )
{
    IOPMinformee *      informee;
    IOService *         driver;
    DriverCallParam *   param;
    IOPMDriverCallEntry callEntry;
    IOPMPowerFlags      powerFlags;
    IOPMPowerStateIndex powerState;
    AbsoluteTime        end;
    IOReturn            result;
    IOItemCount         count;

    assert( fDriverCallBusy );
    assert( fDriverCallParamPtr );
    assert( fDriverCallParamCount );

    param = (DriverCallParam *) fDriverCallParamPtr;
    count = fDriverCallParamCount;

    powerFlags = fHeadNotePowerArrayEntry-&gt;capabilityFlags;
    powerState = fHeadNotePowerState;

    <span class="enscript-keyword">for</span> (IOItemCount i = 0; i &lt; count; i++)
    {
        informee = (IOPMinformee *) param-&gt;Target;
        driver   = informee-&gt;whatObject;

        <span class="enscript-keyword">if</span> (assertPMDriverCall(&amp;callEntry, 0, informee))
        {
            <span class="enscript-keyword">if</span> (fDriverCallReason == kDriverCallInformPreChange)
            {
                OUR_PMLog(kPMLogInformDriverPreChange, (uintptr_t) <span class="enscript-keyword">this</span>, powerState);
                start_spindump_timer(<span class="enscript-string">&quot;WillChange&quot;</span>);
                clock_get_uptime(&amp;informee-&gt;startTime);
                result = driver-&gt;powerStateWillChangeTo(powerFlags, powerState, <span class="enscript-keyword">this</span>);
                clock_get_uptime(&amp;end);
                stop_spindump_timer();
                OUR_PMLog((UInt32)-kPMLogInformDriverPreChange, (uintptr_t) <span class="enscript-keyword">this</span>, result);
            }
            <span class="enscript-keyword">else</span>
            {
                OUR_PMLog(kPMLogInformDriverPostChange, (uintptr_t) <span class="enscript-keyword">this</span>, powerState);
                start_spindump_timer(<span class="enscript-string">&quot;DidChange&quot;</span>);
                clock_get_uptime(&amp;informee-&gt;startTime);
                result = driver-&gt;powerStateDidChangeTo(powerFlags, powerState, <span class="enscript-keyword">this</span>);
                clock_get_uptime(&amp;end);
                stop_spindump_timer();
                OUR_PMLog((UInt32)-kPMLogInformDriverPostChange, (uintptr_t) <span class="enscript-keyword">this</span>, result);
            }

            deassertPMDriverCall(&amp;callEntry);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>
            <span class="enscript-keyword">if</span> ((result == IOPMAckImplied) || (result &lt; 0))
            {
                uint64_t nsec;

                SUB_ABSOLUTETIME(&amp;end, &amp;informee-&gt;startTime);
                absolutetime_to_nanoseconds(end, &amp;nsec);
                <span class="enscript-keyword">if</span> (nsec &gt; LOG_SETPOWER_TIMES) {
                    getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                        gIOPMStatsDriverPSChangeSlow, driver-&gt;getName(),
                        fDriverCallReason, NS_TO_MS(nsec), 0, NULL, powerState);
                }
            }
#<span class="enscript-reference">endif</span>
        }
        <span class="enscript-keyword">else</span>
            result = kIOPMAckImplied;

        param-&gt;Result = result;
        param++;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyChild
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify a power domain child of an upcoming power change.
</span><span class="enscript-comment">// If the object acknowledges the current change, we return TRUE.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::notifyChild</span>( IOPowerConnection * theNub )
{
    IOReturn                ret = IOPMAckImplied;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>           childPower;
    IOService *             theChild;
    IOPMRequest *           childRequest;
    IOPMPowerChangeFlags    requestArg2;
    <span class="enscript-type">int</span>                     requestType;

    PM_ASSERT_IN_GATE();
    theChild = (IOService *)(theNub-&gt;copyChildEntry(gIOPowerPlane));
    <span class="enscript-keyword">if</span> (!theChild)
    {
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-comment">// Unless the child handles the notification immediately and returns
</span>    <span class="enscript-comment">// kIOPMAckImplied, we'll be awaiting their acknowledgement later.
</span>    fHeadNotePendingAcks++;
    theNub-&gt;setAwaitingAck(true);

    requestArg2 = fHeadNoteChangeFlags;
    <span class="enscript-keyword">if</span> (StateOrder(fHeadNotePowerState) &lt; StateOrder(fCurrentPowerState))
        requestArg2 |= kIOPMDomainPowerDrop;

    requestType = fIsPreChange ?
        kIOPMRequestTypePowerDomainWillChange :
        kIOPMRequestTypePowerDomainDidChange;

    childRequest = acquirePMRequest( theChild, requestType );
    <span class="enscript-keyword">if</span> (childRequest)
    {
        theNub-&gt;retain();
        childRequest-&gt;fArg0 = (<span class="enscript-type">void</span> *) fHeadNotePowerArrayEntry-&gt;outputPowerFlags;
        childRequest-&gt;fArg1 = (<span class="enscript-type">void</span> *) theNub;
        childRequest-&gt;fArg2 = (<span class="enscript-type">void</span> *)(uintptr_t) requestArg2;
        theChild-&gt;submitPMRequest( childRequest );
        ret = IOPMWillAckLater;
    }
    <span class="enscript-keyword">else</span>
    {
        ret = IOPMAckImplied;
        fHeadNotePendingAcks--;
        theNub-&gt;setAwaitingAck(false);
        childPower = theChild-&gt;currentPowerConsumption();
        <span class="enscript-keyword">if</span> ( childPower == kIOPMUnknown )
        {
            fHeadNotePowerArrayEntry-&gt;staticPower = kIOPMUnknown;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-keyword">if</span> (fHeadNotePowerArrayEntry-&gt;staticPower != kIOPMUnknown )
                fHeadNotePowerArrayEntry-&gt;staticPower += childPower;
        }
    }

    theChild-&gt;release();
    <span class="enscript-keyword">return</span> (IOPMAckImplied == ret);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyControllingDriver
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::notifyControllingDriver</span>( <span class="enscript-type">void</span> )
{
    DriverCallParam *   param;

    PM_ASSERT_IN_GATE();
    assert( fDriverCallParamCount == 0  );
    assert( fControllingDriver );

    <span class="enscript-keyword">if</span> (fInitialSetPowerState)
    {
        fInitialSetPowerState = false;
        fHeadNoteChangeFlags |= kIOPMInitialPowerChange;

        <span class="enscript-comment">// Driver specified flag to skip the inital setPowerState()
</span>        <span class="enscript-keyword">if</span> (fHeadNotePowerArrayEntry-&gt;capabilityFlags &amp; kIOPMInitialDeviceState)
        {
            <span class="enscript-keyword">return</span> false;
        }
    }

    param = (DriverCallParam *) fDriverCallParamPtr;
    <span class="enscript-keyword">if</span> (!param)
    {
        param = IONew(DriverCallParam, 1);
        <span class="enscript-keyword">if</span> (!param)
            <span class="enscript-keyword">return</span> false;   <span class="enscript-comment">// no memory
</span>
        fDriverCallParamPtr   = (<span class="enscript-type">void</span> *) param;
        fDriverCallParamSlots = 1;
    }

    param-&gt;Target = fControllingDriver;
    fDriverCallParamCount = 1;
    fDriverTimer = -1;

    <span class="enscript-comment">// Block state machine and wait for callout completion.
</span>    assert(!fDriverCallBusy);
    fDriverCallBusy = true;
    thread_call_enter( fDriverCallEntry );

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] notifyControllingDriverDone
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::notifyControllingDriverDone</span>( <span class="enscript-type">void</span> )
{
    DriverCallParam *   param;
    IOReturn            result;

    PM_ASSERT_IN_GATE();
    param = (DriverCallParam *) fDriverCallParamPtr;

    assert( fDriverCallBusy == false );
    assert( fMachineState == kIOPM_DriverThreadCallDone );

    <span class="enscript-keyword">if</span> (param &amp;&amp; fDriverCallParamCount)
    {
        assert(fDriverCallParamCount == 1);

        <span class="enscript-comment">// the return value from setPowerState()
</span>        result = param-&gt;Result;

        <span class="enscript-keyword">if</span> ((result == IOPMAckImplied) || (result &lt; 0))
        {
            fDriverTimer = 0;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fDriverTimer)
        {
            assert(fDriverTimer == -1);

            <span class="enscript-comment">// Driver has not acked, and has returned a positive result.
</span>            <span class="enscript-comment">// Enforce a minimum permissible timeout value.
</span>            <span class="enscript-comment">// Make the min value large enough so timeout is less likely
</span>            <span class="enscript-comment">// to occur if a driver misinterpreted that the return value
</span>            <span class="enscript-comment">// should be in microsecond units.  And make it large enough
</span>            <span class="enscript-comment">// to be noticeable if a driver neglects to ack.
</span>
            <span class="enscript-keyword">if</span> (result &lt; kMinAckTimeoutTicks)
                result = kMinAckTimeoutTicks;

            fDriverTimer = (result / (ACK_TIMER_PERIOD / ns_per_us)) + 1;
        }
        <span class="enscript-comment">// else, child has already acked and driver_timer reset to 0.
</span>
        fDriverCallParamCount = 0;

        <span class="enscript-keyword">if</span> ( fDriverTimer )
        {
            OUR_PMLog(kPMLogStartAckTimer, 0, 0);
            start_ack_timer();
        }
    }

    MS_POP();   <span class="enscript-comment">// pushed by OurChangeSetPowerState()
</span>    fIsPreChange  = false;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] all_done
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// A power change is done.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::all_done</span>( <span class="enscript-type">void</span> )
{
    IOPMPowerStateIndex     prevPowerState;
    <span class="enscript-type">const</span> IOPMPSEntry *     powerStatePtr;
    IOPMDriverCallEntry     callEntry;
    uint32_t                prevMachineState = fMachineState;
    <span class="enscript-type">bool</span>                    actionCalled = false;
    uint64_t                ts;

    fMachineState = kIOPM_Finished;

    <span class="enscript-keyword">if</span> ((fHeadNoteChangeFlags &amp; kIOPMSynchronize) &amp;&amp;
        ((prevMachineState == kIOPM_Finished) ||
         (prevMachineState == kIOPM_SyncFinish)))
    {
        <span class="enscript-comment">// Sync operation and no power change occurred.
</span>        <span class="enscript-comment">// Do not inform driver and clients about this request completion,
</span>        <span class="enscript-comment">// except for the originator (root domain).
</span>
        PM_ACTION_2(actionPowerChangeDone,
            fHeadNotePowerState, fHeadNoteChangeFlags);

        <span class="enscript-keyword">if</span> (getPMRequestType() == kIOPMRequestTypeSynchronizePowerTree)
        {
            powerChangeDone(fCurrentPowerState);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fAdvisoryTickleUsed)
        {
            <span class="enscript-comment">// Not root domain and advisory tickle target.
</span>            <span class="enscript-comment">// Re-adjust power after power tree sync at the 'did' pass
</span>            <span class="enscript-comment">// to recompute desire and adjust power state between dark
</span>            <span class="enscript-comment">// and full wake transitions. Root domain is responsible
</span>            <span class="enscript-comment">// for calling setAdvisoryTickleEnable() before starting
</span>            <span class="enscript-comment">// the kIOPMSynchronize power change.
</span>
            <span class="enscript-keyword">if</span> (!fAdjustPowerScheduled &amp;&amp;
                (fHeadNoteChangeFlags &amp; kIOPMDomainDidChange))
            {
                IOPMRequest * request;
                request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeAdjustPowerState );
                <span class="enscript-keyword">if</span> (request)
                {
                    submitPMRequest( request );
                    fAdjustPowerScheduled = true;
                }
            }
        }

        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// our power change
</span>    <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMSelfInitiated)
    {
        <span class="enscript-comment">// power state changed
</span>        <span class="enscript-keyword">if</span> ((fHeadNoteChangeFlags &amp; kIOPMNotDone) == 0)
        {
            trackSystemSleepPreventers(
                fCurrentPowerState, fHeadNotePowerState, fHeadNoteChangeFlags);

            <span class="enscript-comment">// we changed, tell our parent
</span>            requestDomainPower(fHeadNotePowerState);

            <span class="enscript-comment">// yes, did power raise?
</span>            <span class="enscript-keyword">if</span> ( StateOrder(fCurrentPowerState) &lt; StateOrder(fHeadNotePowerState) )
            {
                <span class="enscript-comment">// yes, inform clients and apps
</span>                tellChangeUp (fHeadNotePowerState);
            }
            prevPowerState = fCurrentPowerState;
            <span class="enscript-comment">// either way
</span>            fCurrentPowerState = fHeadNotePowerState;
            PM_LOCK();
            <span class="enscript-keyword">if</span> (fReportBuf) {
               ts = mach_absolute_time();
               STATEREPORT_SETSTATE(fReportBuf, fCurrentPowerState, ts);
            }
            PM_UNLOCK();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PM_VARS_SUPPORT</span>
            fPMVars-&gt;myCurrentState = fCurrentPowerState;
#<span class="enscript-reference">endif</span>
            OUR_PMLog(kPMLogChangeDone, fCurrentPowerState, prevPowerState);
            PM_ACTION_2(actionPowerChangeDone,
                fHeadNotePowerState, fHeadNoteChangeFlags);
            actionCalled = true;

            powerStatePtr = &amp;fPowerStates[fCurrentPowerState];
            fCurrentCapabilityFlags = powerStatePtr-&gt;capabilityFlags;
            <span class="enscript-keyword">if</span> (fCurrentCapabilityFlags &amp; kIOPMStaticPowerValid)
                fCurrentPowerConsumption = powerStatePtr-&gt;staticPower;

            <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMRootChangeDown)
            {
                <span class="enscript-comment">// Bump tickle generation count once the entire tree is down
</span>                gIOPMTickleGeneration++;
            }

            <span class="enscript-comment">// inform subclass policy-maker
</span>            <span class="enscript-keyword">if</span> (fPCDFunctionOverride &amp;&amp; fParentsKnowState &amp;&amp;
                assertPMDriverCall(&amp;callEntry, kIOPMADC_NoInactiveCheck))
            {
                powerChangeDone(prevPowerState);
                deassertPMDriverCall(&amp;callEntry);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (getPMRequestType() == kIOPMRequestTypeRequestPowerStateOverride)
        {
            <span class="enscript-comment">// changePowerStateWithOverrideTo() was cancelled
</span>            fOverrideMaxPowerState = kIOPMPowerStateMax;
        }
    }

    <span class="enscript-comment">// parent-initiated power change
</span>    <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMParentInitiated)
    {
        <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMRootChangeDown)
            ParentChangeRootChangeDown();

        <span class="enscript-comment">// power state changed
</span>        <span class="enscript-keyword">if</span> ((fHeadNoteChangeFlags &amp; kIOPMNotDone) == 0)
        {
            trackSystemSleepPreventers(
                fCurrentPowerState, fHeadNotePowerState, fHeadNoteChangeFlags);

            <span class="enscript-comment">// did power raise?
</span>            <span class="enscript-keyword">if</span> ( StateOrder(fCurrentPowerState) &lt; StateOrder(fHeadNotePowerState) )
            {
                <span class="enscript-comment">// yes, inform clients and apps
</span>                tellChangeUp (fHeadNotePowerState);
            }
            <span class="enscript-comment">// either way
</span>            prevPowerState = fCurrentPowerState;
            fCurrentPowerState = fHeadNotePowerState;
            PM_LOCK();
            <span class="enscript-keyword">if</span> (fReportBuf) {
               ts = mach_absolute_time();
               STATEREPORT_SETSTATE(fReportBuf, fCurrentPowerState, ts);
            }
            PM_UNLOCK();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PM_VARS_SUPPORT</span>
            fPMVars-&gt;myCurrentState = fCurrentPowerState;
#<span class="enscript-reference">endif</span>

            OUR_PMLog(kPMLogChangeDone, fCurrentPowerState, prevPowerState);
            PM_ACTION_2(actionPowerChangeDone,
                fHeadNotePowerState, fHeadNoteChangeFlags);
            actionCalled = true;

            powerStatePtr = &amp;fPowerStates[fCurrentPowerState];
            fCurrentCapabilityFlags = powerStatePtr-&gt;capabilityFlags;
            <span class="enscript-keyword">if</span> (fCurrentCapabilityFlags &amp; kIOPMStaticPowerValid)
                fCurrentPowerConsumption = powerStatePtr-&gt;staticPower;

            <span class="enscript-comment">// inform subclass policy-maker
</span>            <span class="enscript-keyword">if</span> (fPCDFunctionOverride &amp;&amp; fParentsKnowState &amp;&amp;
                assertPMDriverCall(&amp;callEntry, kIOPMADC_NoInactiveCheck))
            {
                powerChangeDone(prevPowerState);
                deassertPMDriverCall(&amp;callEntry);
            }
        }
    }

    <span class="enscript-comment">// When power rises enough to satisfy the tickle's desire for more power,
</span>    <span class="enscript-comment">// the condition preventing idle-timer from dropping power is removed.
</span>
    <span class="enscript-keyword">if</span> (StateOrder(fCurrentPowerState) &gt;= StateOrder(fIdleTimerMinPowerState))
    {
        fIdleTimerMinPowerState = kPowerStateZero;
    }

    <span class="enscript-keyword">if</span> (!actionCalled)
    {
        PM_ACTION_2(actionPowerChangeDone,
            fHeadNotePowerState, fHeadNoteChangeFlags);
    }
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Power Change Initiated by Driver
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeStart
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Begin the processing of a power change initiated by us.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeStart</span>( <span class="enscript-type">void</span> )
{
    PM_ASSERT_IN_GATE();
    OUR_PMLog( kPMLogStartDeviceChange, fHeadNotePowerState, fCurrentPowerState );

    <span class="enscript-comment">// fMaxPowerState is our maximum possible power state based on the current
</span>    <span class="enscript-comment">// power state of our parents.  If we are trying to raise power beyond the
</span>    <span class="enscript-comment">// maximum, send an async request for more power to all parents.
</span>
    <span class="enscript-keyword">if</span> (!IS_PM_ROOT &amp;&amp; (StateOrder(fMaxPowerState) &lt; StateOrder(fHeadNotePowerState)))
    {
        fHeadNoteChangeFlags |= kIOPMNotDone;
        requestDomainPower(fHeadNotePowerState);
        OurChangeFinish();
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Redundant power changes skips to the end of the state machine.
</span>
    <span class="enscript-keyword">if</span> (!fInitialPowerChange &amp;&amp; (fHeadNotePowerState == fCurrentPowerState))
    {
        OurChangeFinish();
        <span class="enscript-keyword">return</span>;
    }
    fInitialPowerChange = false;

    <span class="enscript-comment">// Change started, but may not complete...
</span>    <span class="enscript-comment">// Can be canceled (power drop) or deferred (power rise).
</span>
    PM_ACTION_2(actionPowerChangeStart, fHeadNotePowerState, &amp;fHeadNoteChangeFlags);

    <span class="enscript-comment">// Two separate paths, depending if power is being raised or lowered.
</span>    <span class="enscript-comment">// Lowering power is subject to approval by clients of this service.
</span>
    <span class="enscript-keyword">if</span> (IS_POWER_DROP)
    {
        fDoNotPowerDown = false;

        <span class="enscript-comment">// Ask for persmission to drop power state
</span>        fMachineState = kIOPM_OurChangeTellClientsPowerDown;
        fOutOfBandParameter = kNotifyApps;
        askChangeDown(fHeadNotePowerState);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// This service is raising power and parents are able to support the
</span>        <span class="enscript-comment">// new power state. However a parent may have already committed to
</span>        <span class="enscript-comment">// drop power, which might force this object to temporarily drop power.
</span>        <span class="enscript-comment">// This results in &quot;oscillations&quot; before the state machines converge
</span>        <span class="enscript-comment">// to a steady state.
</span>        <span class="enscript-comment">//
</span>        <span class="enscript-comment">// To prevent this, a child must make a power reservation against all
</span>        <span class="enscript-comment">// parents before raising power. If the reservation fails, indicating
</span>        <span class="enscript-comment">// that the child will be unable to sustain the higher power state,
</span>        <span class="enscript-comment">// then the child will signal the parent to adjust power, and the child
</span>        <span class="enscript-comment">// will defer its power change.
</span>
        IOReturn ret;

        <span class="enscript-comment">// Reserve parent power necessary to achieve fHeadNotePowerState.
</span>        ret = requestDomainPower( fHeadNotePowerState, kReserveDomainPower );
        <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess)
        {
            <span class="enscript-comment">// Reservation failed, defer power rise.
</span>            fHeadNoteChangeFlags |= kIOPMNotDone;
            OurChangeFinish();
            <span class="enscript-keyword">return</span>;
        }

        OurChangeTellCapabilityWillChange();
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] requestDomainPowerApplier
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Call requestPowerDomainState() on all power parents.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">struct</span> IOPMRequestDomainPowerContext {
    IOService *     child;              <span class="enscript-comment">// the requesting child
</span>    IOPMPowerFlags  requestPowerFlags;  <span class="enscript-comment">// power flags requested by child
</span>};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">requestDomainPowerApplier</span>(
    IORegistryEntry *   entry,
    <span class="enscript-type">void</span> *              inContext )
{
    IOPowerConnection *             connection;
    IOService *                     parent;
    IOPMRequestDomainPowerContext * context;

    <span class="enscript-keyword">if</span> ((connection = OSDynamicCast(IOPowerConnection, entry)) == 0)
        <span class="enscript-keyword">return</span>;
    parent = (IOService *) connection-&gt;copyParentEntry(gIOPowerPlane);
    <span class="enscript-keyword">if</span> (!parent)
        <span class="enscript-keyword">return</span>;

    assert(inContext);
    context = (IOPMRequestDomainPowerContext *) inContext;

    <span class="enscript-keyword">if</span> (connection-&gt;parentKnowsState() &amp;&amp; connection-&gt;getReadyFlag())
    {
        parent-&gt;requestPowerDomainState(
            context-&gt;requestPowerFlags,
            connection,
            IOPMLowestState);
    }

    parent-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] requestDomainPower
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by a power child to broadcast its desired power state to all parents.
</span><span class="enscript-comment">// If the child self-initiates a power change, it must call this function to
</span><span class="enscript-comment">// allow its parents to adjust power state.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::requestDomainPower</span>(
    IOPMPowerStateIndex ourPowerState,
    IOOptionBits        options )
{
    IOPMPowerFlags                  requestPowerFlags;
    IOPMPowerStateIndex             maxPowerState;
    IOPMRequestDomainPowerContext   context;

    PM_ASSERT_IN_GATE();
    assert(ourPowerState &lt; fNumberOfPowerStates);
    <span class="enscript-keyword">if</span> (ourPowerState &gt;= fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    <span class="enscript-keyword">if</span> (IS_PM_ROOT)
        <span class="enscript-keyword">return</span> kIOReturnSuccess;

    <span class="enscript-comment">// Fetch our input power flags for the requested power state.
</span>    <span class="enscript-comment">// Parent request is stated in terms of required power flags.
</span>
    requestPowerFlags = fPowerStates[ourPowerState].inputPowerFlags;

    <span class="enscript-comment">// Disregard the &quot;previous request&quot; for power reservation.
</span>
    <span class="enscript-keyword">if</span> (((options &amp; kReserveDomainPower) == 0) &amp;&amp;
        (fPreviousRequestPowerFlags == requestPowerFlags))
    {
        <span class="enscript-comment">// skip if domain already knows our requirements
</span>        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    fPreviousRequestPowerFlags = requestPowerFlags;

    <span class="enscript-comment">// The results will be collected by fHeadNoteDomainTargetFlags
</span>    context.child              = <span class="enscript-keyword">this</span>;
    context.requestPowerFlags  = requestPowerFlags;
    fHeadNoteDomainTargetFlags = 0;
    applyToParents(requestDomainPowerApplier, &amp;context, gIOPowerPlane);

    <span class="enscript-keyword">if</span> (options &amp; kReserveDomainPower)
    {
        maxPowerState = fControllingDriver-&gt;maxCapabilityForDomainState(
                            fHeadNoteDomainTargetFlags );

        <span class="enscript-keyword">if</span> (StateOrder(maxPowerState) &lt; StateOrder(ourPowerState))
        {
            PM_LOG1(<span class="enscript-string">&quot;%s: power desired %u:0x%x got %u:0x%x\n&quot;</span>,
                getName(),
                (uint32_t) ourPowerState, (uint32_t) requestPowerFlags,
                (uint32_t) maxPowerState, (uint32_t) fHeadNoteDomainTargetFlags);
            <span class="enscript-keyword">return</span> kIOReturnNoPower;
        }
    }

<span class="enscript-reference">done</span>:
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurSyncStart
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurSyncStart</span>( <span class="enscript-type">void</span> )
{
    PM_ASSERT_IN_GATE();

    <span class="enscript-keyword">if</span> (fInitialPowerChange)
        <span class="enscript-keyword">return</span>;

    PM_ACTION_2(actionPowerChangeStart, fHeadNotePowerState, &amp;fHeadNoteChangeFlags);

    <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMNotDone)
    {
        OurChangeFinish();
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMSyncTellPowerDown)
    {
        fDoNotPowerDown = false;

        <span class="enscript-comment">// Ask for permission to drop power state
</span>        fMachineState = kIOPM_SyncTellClientsPowerDown;
        fOutOfBandParameter = kNotifyApps;
        askChangeDown(fHeadNotePowerState);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Only inform capability app and clients.
</span>        tellSystemCapabilityChange( kIOPM_SyncNotifyWillChange );
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeTellClientsPowerDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our permission to drop
</span><span class="enscript-comment">// power. Here we notify them that we will lower the power and wait for acks.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeTellClientsPowerDown</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>(!IS_ROOT_DOMAIN)
        fMachineState = kIOPM_OurChangeTellPriorityClientsPowerDown;
    <span class="enscript-keyword">else</span>
    {
        fMachineState = kIOPM_OurChangeTellUserPMPolicyPowerDown;
    }
    tellChangeDown1(fHeadNotePowerState);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeTellUserPMPolicyPowerDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our permission to drop
</span><span class="enscript-comment">// power. Here we notify power management policy in user-space and wait for acks
</span><span class="enscript-comment">// one last time before we lower power
</span><span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeTellUserPMPolicyPowerDown</span> ( <span class="enscript-type">void</span> )
{
    fMachineState = kIOPM_OurChangeTellPriorityClientsPowerDown;
    fOutOfBandParameter = kNotifyApps;

    tellClientsWithResponse(kIOPMMessageLastCallBeforeSleep);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeTellPriorityClientsPowerDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our intention to drop
</span><span class="enscript-comment">// power.  Here we notify &quot;priority&quot; clients that we are lowering power.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeTellPriorityClientsPowerDown</span>( <span class="enscript-type">void</span> )
{
    fMachineState = kIOPM_OurChangeNotifyInterestedDriversWillChange;
    tellChangeDown2(fHeadNotePowerState);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeTellCapabilityWillChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Extra stage for root domain to notify apps and drivers about the
</span><span class="enscript-comment">// system capability change when raising power state.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeTellCapabilityWillChange</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!IS_ROOT_DOMAIN)
        <span class="enscript-keyword">return</span> OurChangeNotifyInterestedDriversWillChange();

    tellSystemCapabilityChange( kIOPM_OurChangeNotifyInterestedDriversWillChange );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeNotifyInterestedDriversWillChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our power state change.
</span><span class="enscript-comment">// Here we notify interested drivers pre-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeNotifyInterestedDriversWillChange</span>( <span class="enscript-type">void</span> )
{
    IOPMrootDomain * rootDomain;
    <span class="enscript-keyword">if</span> ((rootDomain = getPMRootDomain()) == <span class="enscript-keyword">this</span>)
    {
        <span class="enscript-keyword">if</span> (IS_POWER_DROP)
        {
            rootDomain-&gt;tracePoint( kIOPMTracePointSleepWillChangeInterests );
        }
        <span class="enscript-keyword">else</span>
            rootDomain-&gt;tracePoint( kIOPMTracePointWakeWillChangeInterests );
    }

    notifyAll( kIOPM_OurChangeSetPowerState );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeSetPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Instruct our controlling driver to program the hardware for the power state
</span><span class="enscript-comment">// change. Wait for async completions.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeSetPowerState</span>( <span class="enscript-type">void</span> )
{
    MS_PUSH( kIOPM_OurChangeWaitForPowerSettle );
    fMachineState     = kIOPM_DriverThreadCallDone;
    fDriverCallReason = kDriverCallSetPowerState;

    <span class="enscript-keyword">if</span> (notifyControllingDriver() == false)
        notifyControllingDriverDone();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeWaitForPowerSettle
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Our controlling driver has completed the power state change we initiated.
</span><span class="enscript-comment">// Wait for the driver specified settle time to expire.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeWaitForPowerSettle</span>( <span class="enscript-type">void</span> )
{
    fMachineState = kIOPM_OurChangeNotifyInterestedDriversDidChange;
    startSettleTimer();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeNotifyInterestedDriversDidChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power has settled on a power change we initiated. Here we notify
</span><span class="enscript-comment">// all our interested drivers post-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeNotifyInterestedDriversDidChange</span>( <span class="enscript-type">void</span> )
{
    IOPMrootDomain * rootDomain;
    <span class="enscript-keyword">if</span> ((rootDomain = getPMRootDomain()) == <span class="enscript-keyword">this</span>)
    {
        rootDomain-&gt;tracePoint( IS_POWER_DROP ?
            kIOPMTracePointSleepDidChangeInterests :
            kIOPMTracePointWakeDidChangeInterests  );
    }

    notifyAll( kIOPM_OurChangeTellCapabilityDidChange );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeTellCapabilityDidChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For root domain to notify capability power-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeTellCapabilityDidChange</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!IS_ROOT_DOMAIN)
        <span class="enscript-keyword">return</span> OurChangeFinish();

    getPMRootDomain()-&gt;tracePoint( IS_POWER_DROP ?
        kIOPMTracePointSleepCapabilityClients :
        kIOPMTracePointWakeCapabilityClients  );

    tellSystemCapabilityChange( kIOPM_OurChangeFinish );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] OurChangeFinish
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Done with this self-induced power state change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::OurChangeFinish</span>( <span class="enscript-type">void</span> )
{
    all_done();
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Power Change Initiated by Parent
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeStart
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Here we begin the processing of a power change initiated by our parent.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::ParentChangeStart</span>( <span class="enscript-type">void</span> )
{
    PM_ASSERT_IN_GATE();
    OUR_PMLog( kPMLogStartParentChange, fHeadNotePowerState, fCurrentPowerState );

    <span class="enscript-comment">// Root power domain has transitioned to its max power state
</span>    <span class="enscript-keyword">if</span> ((fHeadNoteChangeFlags &amp; (kIOPMDomainDidChange | kIOPMRootChangeUp)) ==
                                (kIOPMDomainDidChange | kIOPMRootChangeUp))
    {
        <span class="enscript-comment">// Restart the idle timer stopped by ParentChangeRootChangeDown()
</span>        <span class="enscript-keyword">if</span> (fIdleTimerPeriod &amp;&amp; fIdleTimerStopped)
        {
            restartIdleTimer();
        }
    }

    <span class="enscript-comment">// Power domain is forcing us to lower power
</span>    <span class="enscript-keyword">if</span> ( StateOrder(fHeadNotePowerState) &lt; StateOrder(fCurrentPowerState) )
    {
        PM_ACTION_2(actionPowerChangeStart, fHeadNotePowerState, &amp;fHeadNoteChangeFlags);

        <span class="enscript-comment">// Tell apps and kernel clients
</span>        fInitialPowerChange = false;
        fMachineState = kIOPM_ParentChangeTellPriorityClientsPowerDown;
        tellChangeDown1(fHeadNotePowerState);
        <span class="enscript-keyword">return</span> IOPMWillAckLater;
    }

    <span class="enscript-comment">// Power domain is allowing us to raise power up to fHeadNotePowerState
</span>    <span class="enscript-keyword">if</span> ( StateOrder(fHeadNotePowerState) &gt; StateOrder(fCurrentPowerState) )
    {
        <span class="enscript-keyword">if</span> ( StateOrder(fDesiredPowerState) &gt; StateOrder(fCurrentPowerState) )
        {
            <span class="enscript-keyword">if</span> ( StateOrder(fDesiredPowerState) &lt; StateOrder(fHeadNotePowerState) )
            {
                <span class="enscript-comment">// We power up, but not all the way
</span>                fHeadNotePowerState = fDesiredPowerState;
                fHeadNotePowerArrayEntry = &amp;fPowerStates[fDesiredPowerState];
                OUR_PMLog(kPMLogAmendParentChange, fHeadNotePowerState, 0);
             }
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// We don't need to change
</span>            fHeadNotePowerState = fCurrentPowerState;
            fHeadNotePowerArrayEntry = &amp;fPowerStates[fCurrentPowerState];
            OUR_PMLog(kPMLogAmendParentChange, fHeadNotePowerState, 0);
        }
    }

    <span class="enscript-keyword">if</span> ( fHeadNoteChangeFlags &amp; kIOPMDomainDidChange )
    {
        <span class="enscript-keyword">if</span> ( StateOrder(fHeadNotePowerState) &gt; StateOrder(fCurrentPowerState) )
        {
            PM_ACTION_2(actionPowerChangeStart,
                fHeadNotePowerState, &amp;fHeadNoteChangeFlags);

            <span class="enscript-comment">// Parent did change up - start our change up
</span>            fInitialPowerChange = false;
            ParentChangeTellCapabilityWillChange();
            <span class="enscript-keyword">return</span> IOPMWillAckLater;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMRootBroadcastFlags)
        {
            <span class="enscript-comment">// No need to change power state, but broadcast change
</span>            <span class="enscript-comment">// to our children.
</span>            fMachineState     = kIOPM_SyncNotifyDidChange;
            fDriverCallReason = kDriverCallInformPreChange;
            fHeadNoteChangeFlags |= kIOPMNotDone;
            notifyChildren();
            <span class="enscript-keyword">return</span> IOPMWillAckLater;
        }
    }

    <span class="enscript-comment">// No power state change necessary
</span>    fHeadNoteChangeFlags |= kIOPMNotDone;

    all_done();
    <span class="enscript-keyword">return</span> IOPMAckImplied;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeRootChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Root domain has finished the transition to the system sleep state. And all
</span><span class="enscript-comment">// drivers in the power plane should have powered down. Cancel the idle timer,
</span><span class="enscript-comment">// and also reset the device desire for those drivers that don't want power
</span><span class="enscript-comment">// automatically restored on wake.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeRootChangeDown</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">// Always stop the idle timer before root power down
</span>    <span class="enscript-keyword">if</span> (fIdleTimerPeriod &amp;&amp; !fIdleTimerStopped)
    {
        fIdleTimerStopped = true;
        <span class="enscript-keyword">if</span> (fIdleTimer &amp;&amp; thread_call_cancel(fIdleTimer))
            release();
    }

    <span class="enscript-keyword">if</span> (fResetPowerStateOnWake)
    {
        <span class="enscript-comment">// Reset device desire down to the lowest power state.
</span>        <span class="enscript-comment">// Advisory tickle desire is intentionally untouched since
</span>        <span class="enscript-comment">// it has no effect until system is promoted to full wake.
</span>
        <span class="enscript-keyword">if</span> (fDeviceDesire != kPowerStateZero)
        {
            updatePowerClient(gIOPMPowerClientDevice, kPowerStateZero);
            computeDesiredState(kPowerStateZero, true);
            requestDomainPower( fDesiredPowerState );
            PM_LOG1(<span class="enscript-string">&quot;%s: tickle desire removed\n&quot;</span>, fName);
        }

        <span class="enscript-comment">// Invalidate tickle cache so the next tickle will issue a request
</span>        IOLockLock(fActivityLock);
        fDeviceWasActive = false;
        fActivityTicklePowerState = kInvalidTicklePowerState;
        IOLockUnlock(fActivityLock);

        fIdleTimerMinPowerState = kPowerStateZero;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fAdvisoryTickleUsed)
    {
        <span class="enscript-comment">// Less aggressive mechanism to accelerate idle timer expiration
</span>        <span class="enscript-comment">// before system sleep. May not always allow the driver to wake
</span>        <span class="enscript-comment">// up from system sleep in the min power state.
</span>
        AbsoluteTime    now;
        uint64_t        nsec;
        <span class="enscript-type">bool</span>            dropTickleDesire = false;

        <span class="enscript-keyword">if</span> (fIdleTimerPeriod &amp;&amp; !fIdleTimerIgnored &amp;&amp;
            (fIdleTimerMinPowerState == kPowerStateZero) &amp;&amp;
            (fDeviceDesire != kPowerStateZero))
        {
            IOLockLock(fActivityLock);

            <span class="enscript-keyword">if</span> (!fDeviceWasActive)
            {
                <span class="enscript-comment">// No tickles since the last idle timer expiration.
</span>                <span class="enscript-comment">// Safe to drop the device desire to zero.
</span>                dropTickleDesire = true;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// Was tickled since the last idle timer expiration,
</span>                <span class="enscript-comment">// but not in the last minute.
</span>                clock_get_uptime(&amp;now);
                SUB_ABSOLUTETIME(&amp;now, &amp;fDeviceActiveTimestamp);
                absolutetime_to_nanoseconds(now, &amp;nsec);
                <span class="enscript-keyword">if</span> (nsec &gt;= kNoTickleCancelWindow)
                {
                    dropTickleDesire = true;
                }
            }

            <span class="enscript-keyword">if</span> (dropTickleDesire)
            {
                <span class="enscript-comment">// Force the next tickle to raise power state
</span>                fDeviceWasActive = false;
                fActivityTicklePowerState = kInvalidTicklePowerState;
            }

            IOLockUnlock(fActivityLock);
        }

        <span class="enscript-keyword">if</span> (dropTickleDesire)
        {
            <span class="enscript-comment">// Advisory tickle desire is intentionally untouched since
</span>            <span class="enscript-comment">// it has no effect until system is promoted to full wake.
</span>
            updatePowerClient(gIOPMPowerClientDevice, kPowerStateZero);
            computeDesiredState(kPowerStateZero, true);
            PM_LOG1(<span class="enscript-string">&quot;%s: tickle desire dropped\n&quot;</span>, fName);
        }
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeTellPriorityClientsPowerDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our intention to drop
</span><span class="enscript-comment">// power.  Here we notify &quot;priority&quot; clients that we are lowering power.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeTellPriorityClientsPowerDown</span>( <span class="enscript-type">void</span> )
{
    fMachineState = kIOPM_ParentChangeNotifyInterestedDriversWillChange;
    tellChangeDown2(fHeadNotePowerState);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeTellCapabilityWillChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All (legacy) applications and kernel clients have acknowledged, extra stage for
</span><span class="enscript-comment">// root domain to notify apps and drivers about the system capability change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeTellCapabilityWillChange</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!IS_ROOT_DOMAIN)
        <span class="enscript-keyword">return</span> ParentChangeNotifyInterestedDriversWillChange();

    tellSystemCapabilityChange( kIOPM_ParentChangeNotifyInterestedDriversWillChange );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeNotifyInterestedDriversWillChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// All applications and kernel clients have acknowledged our power state change.
</span><span class="enscript-comment">// Here we notify interested drivers pre-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeNotifyInterestedDriversWillChange</span>( <span class="enscript-type">void</span> )
{
    notifyAll( kIOPM_ParentChangeSetPowerState );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeSetPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Instruct our controlling driver to program the hardware for the power state
</span><span class="enscript-comment">// change. Wait for async completions.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeSetPowerState</span>( <span class="enscript-type">void</span> )
{
    MS_PUSH( kIOPM_ParentChangeWaitForPowerSettle );
    fMachineState     = kIOPM_DriverThreadCallDone;
    fDriverCallReason = kDriverCallSetPowerState;

    <span class="enscript-keyword">if</span> (notifyControllingDriver() == false)
        notifyControllingDriverDone();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeWaitForPowerSettle
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Our controlling driver has completed the power state change initiated by our
</span><span class="enscript-comment">// parent. Wait for the driver specified settle time to expire.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeWaitForPowerSettle</span>( <span class="enscript-type">void</span> )
{
    fMachineState = kIOPM_ParentChangeNotifyInterestedDriversDidChange;
    startSettleTimer();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeNotifyInterestedDriversDidChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power has settled on a power change initiated by our parent. Here we notify
</span><span class="enscript-comment">// all our interested drivers post-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeNotifyInterestedDriversDidChange</span>( <span class="enscript-type">void</span> )
{
    notifyAll( kIOPM_ParentChangeTellCapabilityDidChange );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentChangeTellCapabilityDidChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For root domain to notify capability power-change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeTellCapabilityDidChange</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!IS_ROOT_DOMAIN)
        <span class="enscript-keyword">return</span> ParentChangeAcknowledgePowerChange();

    tellSystemCapabilityChange( kIOPM_ParentChangeAcknowledgePowerChange );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ParentAcknowledgePowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Acknowledge our power parent that our power change is done.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ParentChangeAcknowledgePowerChange</span>( <span class="enscript-type">void</span> )
{
    IORegistryEntry *   nub;
    IOService *         parent;

    nub = fHeadNoteParentConnection;
    nub-&gt;retain();
    all_done();
    parent = (IOService *)nub-&gt;copyParentEntry(gIOPowerPlane);
    <span class="enscript-keyword">if</span> ( parent )
    {
        parent-&gt;acknowledgePowerChange((IOService *)nub);
        parent-&gt;release();
    }
    nub-&gt;release();
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Ack and Settle timers
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] settleTimerExpired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Power has settled after our last change.  Notify interested parties that
</span><span class="enscript-comment">// there is a new power state.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::settleTimerExpired</span>( <span class="enscript-type">void</span> )
{
    fSettleTimeUS = 0;
    gIOPMWorkQueue-&gt;signalWorkAvailable();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// settle_timer_expired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Holds a retain while the settle timer callout is in flight.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">settle_timer_expired</span>( thread_call_param_t arg0, thread_call_param_t arg1 )
{
    IOService * me = (IOService *) arg0;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop &amp;&amp; gIOPMWorkQueue)
    {
        gIOPMWorkLoop-&gt;runAction(
            OSMemberFunctionCast(IOWorkLoop::Action, me, &amp;IOService::settleTimerExpired),
            me);
    }
    me-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] startSettleTimer
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Calculate a power-settling delay in microseconds and start a timer.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::startSettleTimer</span>( <span class="enscript-type">void</span> )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOT_USEFUL</span>
    <span class="enscript-comment">// This function is broken and serves no useful purpose since it never
</span>    <span class="enscript-comment">// updates fSettleTimeUS to a non-zero value to stall the state machine,
</span>    <span class="enscript-comment">// yet it starts a delay timer. It appears no driver relies on a delay
</span>    <span class="enscript-comment">// from settleUpTime and settleDownTime in the power state table.
</span>
    AbsoluteTime        deadline;
    IOPMPowerStateIndex stateIndex;
    IOPMPowerStateIndex currentOrder, newOrder, i;
    uint32_t            settleTime = 0;
    boolean_t           pending;

    PM_ASSERT_IN_GATE();

    currentOrder = StateOrder(fCurrentPowerState);
    newOrder     = StateOrder(fHeadNotePowerState);

    i = currentOrder;

    <span class="enscript-comment">// lowering power
</span>    <span class="enscript-keyword">if</span> ( newOrder &lt; currentOrder )
    {
        <span class="enscript-keyword">while</span> ( i &gt; newOrder )
        {
            stateIndex = fPowerStates[i].stateOrderToIndex;
            settleTime += (uint32_t) fPowerStates[stateIndex].settleDownTime;
            i--;
        }
    }

    <span class="enscript-comment">// raising power
</span>    <span class="enscript-keyword">if</span> ( newOrder &gt; currentOrder )
    {
        <span class="enscript-keyword">while</span> ( i &lt; newOrder )
        {
            stateIndex = fPowerStates[i+1].stateOrderToIndex;
            settleTime += (uint32_t) fPowerStates[stateIndex].settleUpTime;
            i++;
        }
    }

    <span class="enscript-keyword">if</span> (settleTime)
    {
        retain();
        clock_interval_to_deadline(settleTime, kMicrosecondScale, &amp;deadline);
        pending = thread_call_enter_delayed(fSettleTimer, deadline);
        <span class="enscript-keyword">if</span> (pending) release();
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] ackTimerTick
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The acknowledgement timeout periodic timer has ticked.
</span><span class="enscript-comment">// If we are awaiting acks for a power change notification,
</span><span class="enscript-comment">// we decrement the timer word of each interested driver which hasn't acked.
</span><span class="enscript-comment">// If a timer word becomes zero, we pretend the driver aknowledged.
</span><span class="enscript-comment">// If we are waiting for the controlling driver to change the power
</span><span class="enscript-comment">// state of the hardware, we decrement its timer word, and if it becomes
</span><span class="enscript-comment">// zero, we pretend the driver acknowledged.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Returns true if the timer tick made it possible to advance to the next
</span><span class="enscript-comment">// machine state, false otherwise.
</span><span class="enscript-comment">//*********************************************************************************
</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::ack_timer_ticked</span> ( <span class="enscript-type">void</span> )
{
    assert(false);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::ackTimerTick</span>( <span class="enscript-type">void</span> )
{
    IOPMinformee *      nextObject;
    <span class="enscript-type">bool</span>                done = false;

    PM_ASSERT_IN_GATE();
    <span class="enscript-keyword">switch</span> (fMachineState) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeWaitForPowerSettle</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeWaitForPowerSettle</span>:
            <span class="enscript-comment">// are we waiting for controlling driver to acknowledge?
</span>            <span class="enscript-keyword">if</span> ( fDriverTimer &gt; 0 )
            {
                <span class="enscript-comment">// yes, decrement timer tick
</span>                fDriverTimer--;
                <span class="enscript-keyword">if</span> ( fDriverTimer == 0 )
                {
                    <span class="enscript-comment">// controlling driver is tardy
</span>                    uint64_t nsec = computeTimeDeltaNS(&amp;fDriverCallStartTime);
                    OUR_PMLog(kPMLogCtrlDriverTardy, 0, 0);
                    setProperty(kIOPMTardyAckSPSKey, kOSBooleanTrue);
                    PM_ERROR(<span class="enscript-string">&quot;%s::setPowerState(%p, %lu -&gt; %lu) timed out after %d ms\n&quot;</span>,
                        fName, OBFUSCATE(<span class="enscript-keyword">this</span>), fCurrentPowerState, fHeadNotePowerState, NS_TO_MS(nsec));

                    <span class="enscript-keyword">if</span> (gIOKitDebug &amp; kIOLogDebugPower)
                    {
                        panic(<span class="enscript-string">&quot;%s::setPowerState(%p, %lu -&gt; %lu) timed out after %d ms&quot;</span>,
                            fName, <span class="enscript-keyword">this</span>, fCurrentPowerState, fHeadNotePowerState, NS_TO_MS(nsec));
                    }
                    <span class="enscript-keyword">else</span>
                    {
                        <span class="enscript-comment">// Unblock state machine and pretend driver has acked.
</span>                        done = true;
                    }
                } <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">// still waiting, set timer again
</span>                    start_ack_timer();
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_NotifyChildrenStart</span>:
            <span class="enscript-comment">// are we waiting for interested parties to acknowledge?
</span>            <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks != 0 )
            {
                <span class="enscript-comment">// yes, go through the list of interested drivers
</span>                nextObject = fInterestedDrivers-&gt;firstInList();
                <span class="enscript-comment">// and check each one
</span>                <span class="enscript-keyword">while</span> (  nextObject != NULL )
                {
                    <span class="enscript-keyword">if</span> ( nextObject-&gt;timer &gt; 0 )
                    {
                        nextObject-&gt;timer--;
                        <span class="enscript-comment">// this one should have acked by now
</span>                        <span class="enscript-keyword">if</span> ( nextObject-&gt;timer == 0 )
                        {
                            uint64_t nsec = computeTimeDeltaNS(&amp;nextObject-&gt;startTime);
                            OUR_PMLog(kPMLogIntDriverTardy, 0, 0);
                            nextObject-&gt;whatObject-&gt;setProperty(kIOPMTardyAckPSCKey, kOSBooleanTrue);
                            PM_ERROR(<span class="enscript-string">&quot;%s::powerState%sChangeTo(%p, %s, %lu -&gt; %lu) timed out after %d ms\n&quot;</span>,
                                nextObject-&gt;whatObject-&gt;getName(),
                                (fDriverCallReason == kDriverCallInformPreChange) ? <span class="enscript-string">&quot;Will&quot;</span> : <span class="enscript-string">&quot;Did&quot;</span>,
                                OBFUSCATE(nextObject-&gt;whatObject), fName, fCurrentPowerState, fHeadNotePowerState,
                                NS_TO_MS(nsec));

                            <span class="enscript-comment">// Pretend driver has acked.
</span>                            fHeadNotePendingAcks--;
                        }
                    }
                    nextObject = fInterestedDrivers-&gt;nextInList(nextObject);
                }

                <span class="enscript-comment">// is that the last?
</span>                <span class="enscript-keyword">if</span> ( fHeadNotePendingAcks == 0 )
                {
                    <span class="enscript-comment">// yes, we can continue
</span>                    done = true;
                } <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">// no, set timer again
</span>                    start_ack_timer();
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// TODO: aggreggate this
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellClientsPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellUserPMPolicyPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellPriorityClientsPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeNotifyInterestedDriversWillChange</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeTellPriorityClientsPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeNotifyInterestedDriversWillChange</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncTellClientsPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncTellPriorityClientsPowerDown</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncNotifyWillChange</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_TellCapabilityChangeDone</span>:
            <span class="enscript-comment">// apps didn't respond in time
</span>            cleanClientResponses(true);
            OUR_PMLog(kPMLogClientTardy, 0, 1);
            <span class="enscript-comment">// tardy equates to approval
</span>            done = true;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            PM_LOG1(<span class="enscript-string">&quot;%s: unexpected ack timer tick (state = %d)\n&quot;</span>,
                getName(), fMachineState);
            <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> done;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] start_watchdog_timer
</span><span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IOService::start_watchdog_timer</span>( <span class="enscript-type">void</span> )
{
    AbsoluteTime    deadline;
    boolean_t       pending;
    <span class="enscript-type">static</span> <span class="enscript-type">int</span>      timeout = -1;

    <span class="enscript-keyword">if</span> (!fWatchdogTimer || (kIOSleepWakeWdogOff &amp; gIOKitDebug))
       <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (thread_call_isactive(fWatchdogTimer)) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (timeout == -1) {
       PE_parse_boot_argn(<span class="enscript-string">&quot;swd_timeout&quot;</span>, &amp;timeout, <span class="enscript-keyword">sizeof</span>(timeout));
    }
    <span class="enscript-keyword">if</span> (timeout &lt; 60) {
       timeout = WATCHDOG_TIMER_PERIOD;
    }

    clock_interval_to_deadline(timeout, kSecondScale, &amp;deadline);

    retain();
    pending = thread_call_enter_delayed(fWatchdogTimer, deadline);
    <span class="enscript-keyword">if</span> (pending) release();

}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] stop_watchdog_timer
</span><span class="enscript-comment">// Returns true if watchdog was enabled and stopped now
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::stop_watchdog_timer</span>( <span class="enscript-type">void</span> )
{
    boolean_t   pending;

    <span class="enscript-keyword">if</span> (!fWatchdogTimer || (kIOSleepWakeWdogOff &amp; gIOKitDebug))
       <span class="enscript-keyword">return</span> false;

    pending = thread_call_cancel(fWatchdogTimer);
    <span class="enscript-keyword">if</span> (pending) release();

    <span class="enscript-keyword">return</span> pending;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// reset_watchdog_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::reset_watchdog_timer</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (stop_watchdog_timer())
        start_watchdog_timer();
}


<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static] watchdog_timer_expired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Inside PM work loop's gate.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">IOService::watchdog_timer_expired</span>( thread_call_param_t arg0, thread_call_param_t arg1 )
{
    IOService * me = (IOService *) arg0;


    gIOPMWatchDogThread = current_thread();
    getPMRootDomain()-&gt;sleepWakeDebugTrig(true);
    gIOPMWatchDogThread = 0;
    thread_call_free(me-&gt;fWatchdogTimer);
    me-&gt;fWatchdogTimer = 0;

    <span class="enscript-keyword">return</span> ;
}


<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] start_ack_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::start_ack_timer</span>( <span class="enscript-type">void</span> )
{
    start_ack_timer( ACK_TIMER_PERIOD, kNanosecondScale );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::start_ack_timer</span> ( UInt32 interval, UInt32 scale )
{
    AbsoluteTime    deadline;
    boolean_t       pending;

    clock_interval_to_deadline(interval, scale, &amp;deadline);

    retain();
    pending = thread_call_enter_delayed(fAckTimer, deadline);
    <span class="enscript-keyword">if</span> (pending) release();

    <span class="enscript-comment">// Stop watchdog if ack is delayed by more than a sec
</span>    <span class="enscript-keyword">if</span> (interval * scale &gt; kSecondScale) {
        stop_watchdog_timer();
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] stop_ack_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::stop_ack_timer</span>( <span class="enscript-type">void</span> )
{
    boolean_t   pending;

    pending = thread_call_cancel(fAckTimer);
    <span class="enscript-keyword">if</span> (pending) release();

    start_watchdog_timer();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static] actionAckTimerExpired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Inside PM work loop's gate.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn
<span class="enscript-function-name">IOService::actionAckTimerExpired</span>(
    OSObject * target,
    <span class="enscript-type">void</span> * arg0, <span class="enscript-type">void</span> * arg1,
    <span class="enscript-type">void</span> * arg2, <span class="enscript-type">void</span> * arg3 )
{
    IOService * me = (IOService *) target;
    <span class="enscript-type">bool</span>        done;

    <span class="enscript-comment">// done will be true if the timer tick unblocks the machine state,
</span>    <span class="enscript-comment">// otherwise no need to signal the work loop.
</span>
    done = me-&gt;ackTimerTick();
    <span class="enscript-keyword">if</span> (done &amp;&amp; gIOPMWorkQueue)
    {
        gIOPMWorkQueue-&gt;signalWorkAvailable();
        me-&gt;start_watchdog_timer();
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// ack_timer_expired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Thread call function. Holds a retain while the callout is in flight.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">IOService::ack_timer_expired</span>( thread_call_param_t arg0, thread_call_param_t arg1 )
{
    IOService * me = (IOService *) arg0;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop)
    {
        gIOPMWorkLoop-&gt;runAction(&amp;actionAckTimerExpired, me);
    }
    me-&gt;release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] start_spindump_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::start_spindump_timer</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * delay_type )
{
    AbsoluteTime    deadline;
    boolean_t       pending;

    <span class="enscript-keyword">if</span> (!fSpinDumpTimer || !(kIOKextSpinDump &amp; gIOKitDebug))
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (gIOSpinDumpKextName[0] == <span class="enscript-string">'\0'</span> &amp;&amp;
        !(PE_parse_boot_argn(<span class="enscript-string">&quot;swd_kext_name&quot;</span>, &amp;gIOSpinDumpKextName,
        <span class="enscript-keyword">sizeof</span>(gIOSpinDumpKextName))))
    {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (strncmp(gIOSpinDumpKextName, fName, <span class="enscript-keyword">sizeof</span>(gIOSpinDumpKextName)) != 0)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (gIOSpinDumpDelayType[0] == <span class="enscript-string">'\0'</span> &amp;&amp;
        !(PE_parse_boot_argn(<span class="enscript-string">&quot;swd_delay_type&quot;</span>, &amp;gIOSpinDumpDelayType,
        <span class="enscript-keyword">sizeof</span>(gIOSpinDumpDelayType))))
    {
        strncpy(gIOSpinDumpDelayType, <span class="enscript-string">&quot;SetState&quot;</span>, <span class="enscript-keyword">sizeof</span>(gIOSpinDumpDelayType));
    }

    <span class="enscript-keyword">if</span> (strncmp(delay_type, gIOSpinDumpDelayType, <span class="enscript-keyword">sizeof</span>(gIOSpinDumpDelayType)) != 0)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (gIOSpinDumpDelayDuration == 0 &amp;&amp;
        !(PE_parse_boot_argn(<span class="enscript-string">&quot;swd_delay_duration&quot;</span>, &amp;gIOSpinDumpDelayDuration,
        <span class="enscript-keyword">sizeof</span>(gIOSpinDumpDelayDuration))))
    {
        gIOSpinDumpDelayDuration = 300;
    }

    clock_interval_to_deadline(gIOSpinDumpDelayDuration, kMillisecondScale, &amp;deadline);

    retain();
    pending = thread_call_enter_delayed(fSpinDumpTimer, deadline);
    <span class="enscript-keyword">if</span> (pending) release();
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] stop_spindump_timer
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::stop_spindump_timer</span>( <span class="enscript-type">void</span> )
{
    boolean_t   pending;

    <span class="enscript-keyword">if</span> (!fSpinDumpTimer || !(kIOKextSpinDump &amp; gIOKitDebug))
        <span class="enscript-keyword">return</span>;

    pending = thread_call_cancel(fSpinDumpTimer);
    <span class="enscript-keyword">if</span> (pending) release();
}


<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static] actionSpinDumpTimerExpired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Inside PM work loop's gate.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn
<span class="enscript-function-name">IOService::actionSpinDumpTimerExpired</span>(
    OSObject * target,
    <span class="enscript-type">void</span> * arg0, <span class="enscript-type">void</span> * arg1,
    <span class="enscript-type">void</span> * arg2, <span class="enscript-type">void</span> * arg3 )
{
    getPMRootDomain()-&gt;takeStackshot(false, false, true);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// spindump_timer_expired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Thread call function. Holds a retain while the callout is in flight.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">IOService::spindump_timer_expired</span>( thread_call_param_t arg0, thread_call_param_t arg1 )
{
    IOService * me = (IOService *) arg0;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop)
    {
        gIOPMWorkLoop-&gt;runAction(&amp;actionSpinDumpTimerExpired, me);
    }
    me-&gt;release();
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Client Messaging
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] tellSystemCapabilityChange
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::tellSystemCapabilityChange</span>( uint32_t nextMS )
{
    MS_PUSH( nextMS );
    fMachineState       = kIOPM_TellCapabilityChangeDone;
    fOutOfBandMessage   = kIOMessageSystemCapabilityChange;

    <span class="enscript-keyword">if</span> (fIsPreChange)
    {
        <span class="enscript-comment">// Notify app first on pre-change.
</span>        fOutOfBandParameter = kNotifyCapabilityChangeApps;
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Notify kernel clients first on post-change.
</span>        fOutOfBandParameter = kNotifyCapabilityChangePriority;
    }

    tellClientsWithResponse( fOutOfBandMessage );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] askChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Ask registered applications and kernel clients if we can change to a lower
</span><span class="enscript-comment">// power state.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Subclass can override this to send a different message type.  Parameter is
</span><span class="enscript-comment">// the destination state number.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Return true if we don't have to wait for acknowledgements
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::askChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    <span class="enscript-keyword">return</span> tellClientsWithResponse( kIOMessageCanDevicePowerOff );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] tellChangeDown1
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are definitely
</span><span class="enscript-comment">// dropping power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Return true if we don't have to wait for acknowledgements
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::tellChangeDown1</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    fOutOfBandParameter = kNotifyApps;
    <span class="enscript-keyword">return</span> tellChangeDown(stateNum);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] tellChangeDown2
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify priority clients that we are definitely dropping power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Return true if we don't have to wait for acknowledgements
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::tellChangeDown2</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    fOutOfBandParameter = kNotifyPriority;
    <span class="enscript-keyword">return</span> tellChangeDown(stateNum);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] tellChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are definitely
</span><span class="enscript-comment">// dropping power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Subclass can override this to send a different message type.  Parameter is
</span><span class="enscript-comment">// the destination state number.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Return true if we don't have to wait for acknowledgements
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::tellChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    <span class="enscript-keyword">return</span> tellClientsWithResponse( kIOMessageDeviceWillPowerOff );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// cleanClientResponses
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">logAppTimeouts</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPMInterestContext *   context = (IOPMInterestContext *) arg;
    OSObject *              flag;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            clientIndex;
    <span class="enscript-type">int</span>                     pid = -1;
    <span class="enscript-type">char</span>                    name[128];

    <span class="enscript-keyword">if</span> (OSDynamicCast(_IOServiceInterestNotifier, object))
    {
        <span class="enscript-comment">// Discover the 'counter' value or index assigned to this client
</span>        <span class="enscript-comment">// when it was notified, by searching for the array index of the
</span>        <span class="enscript-comment">// client in an array holding the cached interested clients.
</span>
        clientIndex = context-&gt;notifyClients-&gt;getNextIndexOfObject(object, 0);

        <span class="enscript-keyword">if</span> ((clientIndex != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1) &amp;&amp;
            (flag = context-&gt;responseArray-&gt;getObject(clientIndex)) &amp;&amp;
            (flag != kOSBooleanTrue))
        {
            OSNumber *clientID = copyClientIDForNotification(object, context);

            name[0] = <span class="enscript-string">'\0'</span>;
            <span class="enscript-keyword">if</span> (clientID) {
                pid = clientID-&gt;unsigned32BitValue();
                proc_name(pid, name, <span class="enscript-keyword">sizeof</span>(name));
                clientID-&gt;release();
            }

            PM_ERROR(context-&gt;errorLog, pid, name);

            <span class="enscript-comment">// TODO: record message type if possible
</span>            <span class="enscript-reference">IOService</span>::getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                gIOPMStatsApplicationResponseTimedOut,
                name, 0, (30*1000), pid, object);

        }
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::cleanClientResponses</span>( <span class="enscript-type">bool</span> logErrors )
{
    <span class="enscript-keyword">if</span> (logErrors &amp;&amp; fResponseArray)
    {
        <span class="enscript-keyword">switch</span> ( fOutOfBandParameter ) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyApps</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyCapabilityChangeApps</span>:
                <span class="enscript-keyword">if</span> (fNotifyClientArray)
                {
                    IOPMInterestContext context;

                    context.responseArray    = fResponseArray;
                    context.notifyClients    = fNotifyClientArray;
                    context.serialNumber     = fSerialNumber;
                    context.messageType      = kIOMessageCopyClientID;
                    context.notifyType       = kNotifyApps;
                    context.isPreChange      = fIsPreChange;
                    context.enableTracing    = false;
                    context.us               = <span class="enscript-keyword">this</span>;
                    context.maxTimeRequested = 0;
                    context.stateNumber      = fHeadNotePowerState;
                    context.stateFlags       = fHeadNotePowerArrayEntry-&gt;capabilityFlags;
                    context.changeFlags      = fHeadNoteChangeFlags;
                    context.errorLog         = <span class="enscript-string">&quot;PM notification timeout (pid %d, %s)\n&quot;</span>;

                    applyToInterested(gIOAppPowerStateInterest, logAppTimeouts, (<span class="enscript-type">void</span> *) &amp;context);
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                <span class="enscript-comment">// kNotifyPriority, kNotifyCapabilityChangePriority
</span>                <span class="enscript-comment">// TODO: identify the priority client that has not acked
</span>                PM_ERROR(<span class="enscript-string">&quot;PM priority notification timeout\n&quot;</span>);
                <span class="enscript-keyword">if</span> (gIOKitDebug &amp; kIOLogDebugPower)
                {
                    panic(<span class="enscript-string">&quot;PM priority notification timeout&quot;</span>);
                }
                <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span> (fResponseArray)
    {
        fResponseArray-&gt;release();
        fResponseArray = NULL;
    }
    <span class="enscript-keyword">if</span> (fNotifyClientArray)
    {
        fNotifyClientArray-&gt;release();
        fNotifyClientArray = NULL;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] tellClientsWithResponse
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are definitely
</span><span class="enscript-comment">// dropping power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Return true if we don't have to wait for acknowledgements
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::tellClientsWithResponse</span>( <span class="enscript-type">int</span> messageType )
{
    IOPMInterestContext     context;
    <span class="enscript-type">bool</span>                    isRootDomain = IS_ROOT_DOMAIN;
    uint32_t                maxTimeOut = kMaxTimeRequested;

    PM_ASSERT_IN_GATE();
    assert( fResponseArray == NULL );
    assert( fNotifyClientArray == NULL );

    <span class="enscript-keyword">if</span>(messageType == (<span class="enscript-type">int</span>)kIOPMMessageLastCallBeforeSleep)
        RD_LOG(<span class="enscript-string">&quot;tellClientsWithResponse( kIOPMMessageLastCallBeforeSleep, %d )\n&quot;</span>,
                fOutOfBandParameter);
    <span class="enscript-keyword">else</span>
        RD_LOG(<span class="enscript-string">&quot;tellClientsWithResponse( %s, %d )\n&quot;</span>,
                getIOMessageString(messageType), fOutOfBandParameter);

    fResponseArray = OSArray::withCapacity( 1 );
    <span class="enscript-keyword">if</span> (!fResponseArray)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    fResponseArray-&gt;setCapacityIncrement(8);
    <span class="enscript-keyword">if</span> (++fSerialNumber == 0)
        fSerialNumber++;

    context.responseArray    = fResponseArray;
    context.notifyClients    = 0;
    context.serialNumber     = fSerialNumber;
    context.messageType      = messageType;
    context.notifyType       = fOutOfBandParameter;
    context.isPreChange      = fIsPreChange;
    context.enableTracing    = false;
    context.us               = <span class="enscript-keyword">this</span>;
    context.maxTimeRequested = 0;
    context.stateNumber      = fHeadNotePowerState;
    context.stateFlags       = fHeadNotePowerArrayEntry-&gt;capabilityFlags;
    context.changeFlags      = fHeadNoteChangeFlags;
    context.messageFilter    = (isRootDomain) ?
                               OSMemberFunctionCast(
                                    IOPMMessageFilter,
                                    <span class="enscript-keyword">this</span>,
                                    &amp;IOPMrootDomain::systemMessageFilter) : 0;

    <span class="enscript-keyword">switch</span> ( fOutOfBandParameter ) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyApps</span>:
            applyToInterested( gIOAppPowerStateInterest,
                pmTellAppWithResponse, (<span class="enscript-type">void</span> *) &amp;context );

            <span class="enscript-keyword">if</span> (isRootDomain &amp;&amp;
                (fMachineState != kIOPM_OurChangeTellClientsPowerDown) &amp;&amp;
                (fMachineState != kIOPM_SyncTellClientsPowerDown) &amp;&amp;
                (context.messageType != kIOPMMessageLastCallBeforeSleep))
            {
                <span class="enscript-comment">// Notify capability app for tellChangeDown1()
</span>                <span class="enscript-comment">// but not for askChangeDown().
</span>                context.notifyType  = kNotifyCapabilityChangeApps;
                context.messageType = kIOMessageSystemCapabilityChange;
                applyToInterested( gIOAppPowerStateInterest,
                    pmTellCapabilityAppWithResponse, (<span class="enscript-type">void</span> *) &amp;context );
                context.notifyType  = fOutOfBandParameter;
                context.messageType = messageType;
            }
	    <span class="enscript-keyword">if</span>(context.messageType == kIOMessageCanSystemSleep)
	    {
		maxTimeOut = kCanSleepMaxTimeReq;
		<span class="enscript-keyword">if</span>(gCanSleepTimeout)
		{
		    maxTimeOut = (gCanSleepTimeout*us_per_s);
		}
	    }
	    context.maxTimeRequested = maxTimeOut;
            applyToInterested( gIOGeneralInterest,
                pmTellClientWithResponse, (<span class="enscript-type">void</span> *) &amp;context );

            fNotifyClientArray = context.notifyClients;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyPriority</span>:
            context.enableTracing = isRootDomain;
            applyToInterested( gIOPriorityPowerStateInterest,
                pmTellClientWithResponse, (<span class="enscript-type">void</span> *) &amp;context );

            <span class="enscript-keyword">if</span> (isRootDomain)
            {
                <span class="enscript-comment">// Notify capability clients for tellChangeDown2().
</span>                context.notifyType  = kNotifyCapabilityChangePriority;
                context.messageType = kIOMessageSystemCapabilityChange;
                applyToInterested( gIOPriorityPowerStateInterest,
                    pmTellCapabilityClientWithResponse, (<span class="enscript-type">void</span> *) &amp;context );
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyCapabilityChangeApps</span>:
            applyToInterested( gIOAppPowerStateInterest,
                pmTellCapabilityAppWithResponse, (<span class="enscript-type">void</span> *) &amp;context );
            fNotifyClientArray = context.notifyClients;
	    <span class="enscript-keyword">if</span>(context.messageType == kIOMessageCanSystemSleep)
	    {
		maxTimeOut = kCanSleepMaxTimeReq;
		<span class="enscript-keyword">if</span>(gCanSleepTimeout)
		{
		    maxTimeOut = (gCanSleepTimeout*us_per_s);
		}
	    }
	    context.maxTimeRequested = maxTimeOut;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kNotifyCapabilityChangePriority</span>:
            applyToInterested( gIOPriorityPowerStateInterest,
                pmTellCapabilityClientWithResponse, (<span class="enscript-type">void</span> *) &amp;context );
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-comment">// do we have to wait for somebody?
</span>    <span class="enscript-keyword">if</span> ( !checkForDone() )
    {
        OUR_PMLog(kPMLogStartAckTimer, context.maxTimeRequested, 0);
        <span class="enscript-keyword">if</span> (context.enableTracing)
            getPMRootDomain()-&gt;traceDetail( context.maxTimeRequested / 1000 );
        start_ack_timer( context.maxTimeRequested / 1000, kMillisecondScale );
        <span class="enscript-keyword">return</span> false;
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-comment">// everybody responded
</span>    <span class="enscript-keyword">if</span> (fResponseArray)
    {
        fResponseArray-&gt;release();
        fResponseArray = NULL;
    }
    <span class="enscript-keyword">if</span> (fNotifyClientArray)
    {
        fNotifyClientArray-&gt;release();
        fNotifyClientArray = NULL;
    }

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static private] pmTellAppWithResponse
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We send a message to an application, and we expect a response, so we compute a
</span><span class="enscript-comment">// cookie we can identify the response with.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::pmTellAppWithResponse</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPMInterestContext *   context = (IOPMInterestContext *) arg;
    IOServicePM *           pwrMgt = context-&gt;us-&gt;pwrMgt;
    uint32_t                msgIndex, msgRef, msgType;
    OSNumber                *clientID = NULL;
    proc_t                  proc = NULL;
    boolean_t               proc_suspended = FALSE;
    OSObject *              waitForReply = kOSBooleanTrue;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>
    AbsoluteTime            now;
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!OSDynamicCast(_IOServiceInterestNotifier, object))
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (context-&gt;us == getPMRootDomain())
    {
        <span class="enscript-keyword">if</span> ((clientID = copyClientIDForNotification(object, context)))
        {
            uint32_t clientPID = clientID-&gt;unsigned32BitValue();
            clientID-&gt;release();
            proc = proc_find(clientPID);

            <span class="enscript-keyword">if</span> (proc)
            {
                proc_suspended = get_task_pidsuspended((task_t) proc-&gt;task);
                proc_rele(proc);

                <span class="enscript-keyword">if</span> (proc_suspended)
                {
                    logClientIDForNotification(object, context, <span class="enscript-string">&quot;PMTellAppWithResponse - Suspended&quot;</span>);
                    <span class="enscript-keyword">return</span>;
                }
            }
        }
    }

    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, 0, &amp;waitForReply))
    {
        <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
        {
            logClientIDForNotification(object, context, <span class="enscript-string">&quot;DROP App&quot;</span>);
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Create client array (for tracking purposes) only if the service
</span>    <span class="enscript-comment">// has app clients. Usually only root domain does.
</span>    <span class="enscript-keyword">if</span> (0 == context-&gt;notifyClients)
        context-&gt;notifyClients = OSArray::withCapacity( 32 );

    msgType  = context-&gt;messageType;
    msgIndex = context-&gt;responseArray-&gt;getCount();
    msgRef   = ((context-&gt;serialNumber &amp; 0xFFFF) &lt;&lt; 16) + (msgIndex &amp; 0xFFFF);

    OUR_PMLog(kPMLogAppNotify, msgType, msgRef);
    <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
    {
        logClientIDForNotification(object, context, <span class="enscript-string">&quot;MESG App&quot;</span>);
    }

    <span class="enscript-keyword">if</span> (waitForReply == kOSBooleanTrue) 
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>
        OSNumber * num;
        clock_get_uptime(&amp;now);
        num = OSNumber::withNumber(AbsoluteTime_to_scalar(&amp;now), <span class="enscript-keyword">sizeof</span>(uint64_t) * 8);
        <span class="enscript-keyword">if</span> (num)
        {
            context-&gt;responseArray-&gt;setObject(msgIndex, num);
            num-&gt;release();
        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        context-&gt;responseArray-&gt;setObject(msgIndex, kOSBooleanFalse);
    }
    <span class="enscript-keyword">else</span> 
    {
        context-&gt;responseArray-&gt;setObject(msgIndex, kOSBooleanTrue);
        <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
        {
            logClientIDForNotification(object, context, <span class="enscript-string">&quot;App response ignored&quot;</span>);
        }
    }

    <span class="enscript-keyword">if</span> (context-&gt;notifyClients)
        context-&gt;notifyClients-&gt;setObject(msgIndex, object);

    context-&gt;us-&gt;messageClient(msgType, object, (<span class="enscript-type">void</span> *)(uintptr_t) msgRef);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static private] pmTellClientWithResponse
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We send a message to an in-kernel client, and we expect a response,
</span><span class="enscript-comment">// so we compute a cookie we can identify the response with.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::pmTellClientWithResponse</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPowerStateChangeNotification  notify;
    IOPMInterestContext *           context = (IOPMInterestContext *) arg;
    OSObject *                      replied = kOSBooleanTrue;
    _IOServiceInterestNotifier *    notifier;
    uint32_t                        msgIndex, msgRef, msgType;
    IOReturn                        retCode;

    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, 0, 0))
    {
        <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp;
            (OSDynamicCast(_IOServiceInterestNotifier, object)))
        {
            _IOServiceInterestNotifier *n = (_IOServiceInterestNotifier *) object;
            PM_LOG(<span class="enscript-string">&quot;%s DROP Client %s, notifier %p, handler %p\n&quot;</span>,
                context-&gt;us-&gt;getName(),
                getIOMessageString(context-&gt;messageType),
                OBFUSCATE(object), OBFUSCATE(n-&gt;handler));
        }
        <span class="enscript-keyword">return</span>;
    }

    notifier = OSDynamicCast(_IOServiceInterestNotifier, object);
    msgType  = context-&gt;messageType;
    msgIndex = context-&gt;responseArray-&gt;getCount();
    msgRef   = ((context-&gt;serialNumber &amp; 0xFFFF) &lt;&lt; 16) + (msgIndex &amp; 0xFFFF);

    IOServicePM * pwrMgt = context-&gt;us-&gt;pwrMgt;
    <span class="enscript-keyword">if</span> (gIOKitDebug &amp; kIOLogPower) {
        OUR_PMLog(kPMLogClientNotify, msgRef, msgType);
        <span class="enscript-keyword">if</span> (OSDynamicCast(IOService, object)) {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *who = ((IOService *) object)-&gt;getName();
            gPlatform-&gt;PMLog(who, kPMLogClientNotify, (uintptr_t) object, 0);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (notifier) {
            OUR_PMLog(kPMLogClientNotify, (uintptr_t) notifier-&gt;handler, 0);
        }
    }
    <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp; notifier)
    {
        PM_LOG(<span class="enscript-string">&quot;%s MESG Client %s, notifier %p, handler %p\n&quot;</span>,
            context-&gt;us-&gt;getName(),
            getIOMessageString(msgType),
            OBFUSCATE(object), OBFUSCATE(notifier-&gt;handler));
    }

    notify.powerRef    = (<span class="enscript-type">void</span> *)(uintptr_t) msgRef;
    notify.returnValue = 0;
    notify.stateNumber = context-&gt;stateNumber;
    notify.stateFlags  = context-&gt;stateFlags;

    <span class="enscript-keyword">if</span> (context-&gt;enableTracing &amp;&amp; (notifier != 0))
    {
        uint32_t detail = ((msgIndex &amp; 0xff) &lt;&lt; 24) |
                          ((msgType &amp; 0xfff) &lt;&lt; 12) |
                          (((uintptr_t) notifier-&gt;handler) &amp; 0xfff);
        getPMRootDomain()-&gt;traceDetail( detail );
    }

    retCode = context-&gt;us-&gt;messageClient(msgType, object, (<span class="enscript-type">void</span> *) &amp;notify, <span class="enscript-keyword">sizeof</span>(notify));

    <span class="enscript-keyword">if</span> (kIOReturnSuccess == retCode)
    {
        <span class="enscript-keyword">if</span> (0 == notify.returnValue) {
            OUR_PMLog(kPMLogClientAcknowledge, msgRef, (uintptr_t) object);
        } <span class="enscript-keyword">else</span> {
            replied = kOSBooleanFalse;
            <span class="enscript-keyword">if</span> ( notify.returnValue &gt; context-&gt;maxTimeRequested )
            {
                <span class="enscript-keyword">if</span> (notify.returnValue &gt; kPriorityClientMaxWait)
                {
                    context-&gt;maxTimeRequested = kPriorityClientMaxWait;
                    PM_ERROR(<span class="enscript-string">&quot;%s: client %p returned %llu for %s\n&quot;</span>,
                        context-&gt;us-&gt;getName(),
                        notifier ? (<span class="enscript-type">void</span> *)  OBFUSCATE(notifier-&gt;handler) : OBFUSCATE(object),
                        (uint64_t) notify.returnValue,
                        getIOMessageString(msgType));
                }
                <span class="enscript-keyword">else</span>
                    context-&gt;maxTimeRequested = notify.returnValue;
            }
        }
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">// not a client of ours
</span>        <span class="enscript-comment">// so we won't be waiting for response
</span>        OUR_PMLog(kPMLogClientAcknowledge, msgRef, 0);
    }

    context-&gt;responseArray-&gt;setObject(msgIndex, replied);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static private] pmTellCapabilityAppWithResponse
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::pmTellCapabilityAppWithResponse</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPMSystemCapabilityChangeParameters msgArg;
    IOPMInterestContext *       context = (IOPMInterestContext *) arg;
    OSObject *                  replied = kOSBooleanTrue;
    IOServicePM *               pwrMgt = context-&gt;us-&gt;pwrMgt;
    uint32_t                    msgIndex, msgRef, msgType;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>
    AbsoluteTime                now;
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!OSDynamicCast(_IOServiceInterestNotifier, object))
        <span class="enscript-keyword">return</span>;

    memset(&amp;msgArg, 0, <span class="enscript-keyword">sizeof</span>(msgArg));
    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, &amp;msgArg, &amp;replied))
    {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Create client array (for tracking purposes) only if the service
</span>    <span class="enscript-comment">// has app clients. Usually only root domain does.
</span>    <span class="enscript-keyword">if</span> (0 == context-&gt;notifyClients)
        context-&gt;notifyClients = OSArray::withCapacity( 32 );

    msgType  = context-&gt;messageType;
    msgIndex = context-&gt;responseArray-&gt;getCount();
    msgRef   = ((context-&gt;serialNumber &amp; 0xFFFF) &lt;&lt; 16) + (msgIndex &amp; 0xFFFF);

    OUR_PMLog(kPMLogAppNotify, msgType, msgRef);
    <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
    {
        <span class="enscript-comment">// Log client pid/name and client array index.
</span>        OSNumber * clientID = NULL;
        OSString * clientIDString = NULL;;
        context-&gt;us-&gt;messageClient(kIOMessageCopyClientID, object, &amp;clientID);
        <span class="enscript-keyword">if</span> (clientID) {
            clientIDString = IOCopyLogNameForPID(clientID-&gt;unsigned32BitValue());
        }

        PM_LOG(<span class="enscript-string">&quot;%s MESG App(%u) %s, wait %u, %s\n&quot;</span>,
            context-&gt;us-&gt;getName(),
            msgIndex, getIOMessageString(msgType),
            (replied != kOSBooleanTrue),
            clientIDString ? clientIDString-&gt;getCStringNoCopy() : <span class="enscript-string">&quot;&quot;</span>);
        <span class="enscript-keyword">if</span> (clientID) clientID-&gt;release();
        <span class="enscript-keyword">if</span> (clientIDString) clientIDString-&gt;release();
    }

    msgArg.notifyRef = msgRef;
    msgArg.maxWaitForReply = 0;

    <span class="enscript-keyword">if</span> (replied == kOSBooleanTrue)
    {
        msgArg.notifyRef = 0;
        context-&gt;responseArray-&gt;setObject(msgIndex, kOSBooleanTrue);
        <span class="enscript-keyword">if</span> (context-&gt;notifyClients)
            context-&gt;notifyClients-&gt;setObject(msgIndex, kOSBooleanTrue);
    }
    <span class="enscript-keyword">else</span>
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>
        OSNumber * num;
        clock_get_uptime(&amp;now);
        num = OSNumber::withNumber(AbsoluteTime_to_scalar(&amp;now), <span class="enscript-keyword">sizeof</span>(uint64_t) * 8);
        <span class="enscript-keyword">if</span> (num)
        {
            context-&gt;responseArray-&gt;setObject(msgIndex, num);
            num-&gt;release();
        }
        <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        context-&gt;responseArray-&gt;setObject(msgIndex, kOSBooleanFalse);

        <span class="enscript-keyword">if</span> (context-&gt;notifyClients)
            context-&gt;notifyClients-&gt;setObject(msgIndex, object);
    }

    context-&gt;us-&gt;messageClient(msgType, object, (<span class="enscript-type">void</span> *) &amp;msgArg, <span class="enscript-keyword">sizeof</span>(msgArg));
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [static private] pmTellCapabilityClientWithResponse
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::pmTellCapabilityClientWithResponse</span>(
    OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPMSystemCapabilityChangeParameters msgArg;
    IOPMInterestContext *           context = (IOPMInterestContext *) arg;
    OSObject *                      replied = kOSBooleanTrue;
    _IOServiceInterestNotifier *    notifier;
    uint32_t                        msgIndex, msgRef, msgType;
    IOReturn                        retCode;

    memset(&amp;msgArg, 0, <span class="enscript-keyword">sizeof</span>(msgArg));
    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, &amp;msgArg, 0))
    {
        <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp;
            (OSDynamicCast(_IOServiceInterestNotifier, object)))
        {
            _IOServiceInterestNotifier *n = (_IOServiceInterestNotifier *) object;
            PM_LOG(<span class="enscript-string">&quot;%s DROP Client %s, notifier %p, handler %p\n&quot;</span>,
                context-&gt;us-&gt;getName(),
                getIOMessageString(context-&gt;messageType),
                OBFUSCATE(object), OBFUSCATE(n-&gt;handler));
        }
        <span class="enscript-keyword">return</span>;
    }

    notifier = OSDynamicCast(_IOServiceInterestNotifier, object);
    msgType  = context-&gt;messageType;
    msgIndex = context-&gt;responseArray-&gt;getCount();
    msgRef   = ((context-&gt;serialNumber &amp; 0xFFFF) &lt;&lt; 16) + (msgIndex &amp; 0xFFFF);

    IOServicePM * pwrMgt = context-&gt;us-&gt;pwrMgt;
    <span class="enscript-keyword">if</span> (gIOKitDebug &amp; kIOLogPower) {
        OUR_PMLog(kPMLogClientNotify, msgRef, msgType);
        <span class="enscript-keyword">if</span> (OSDynamicCast(IOService, object)) {
            <span class="enscript-type">const</span> <span class="enscript-type">char</span> *who = ((IOService *) object)-&gt;getName();
            gPlatform-&gt;PMLog(who, kPMLogClientNotify, (uintptr_t) object, 0);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (notifier) {
            OUR_PMLog(kPMLogClientNotify, (uintptr_t) notifier-&gt;handler, 0);
        }
    }
    <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp; notifier)
    {
        PM_LOG(<span class="enscript-string">&quot;%s MESG Client %s, notifier %p, handler %p\n&quot;</span>,
            context-&gt;us-&gt;getName(),
            getIOMessageString(msgType),
            OBFUSCATE(object), OBFUSCATE(notifier-&gt;handler));
    }

    msgArg.notifyRef = msgRef;
    msgArg.maxWaitForReply = 0;

    <span class="enscript-keyword">if</span> (context-&gt;enableTracing &amp;&amp; (notifier != 0))
    {
        uint32_t detail = ((msgIndex &amp; 0xff) &lt;&lt; 24) |
                          ((msgType &amp; 0xfff) &lt;&lt; 12) |
                          (((uintptr_t) notifier-&gt;handler) &amp; 0xfff);
        getPMRootDomain()-&gt;traceDetail( detail );
    }

    retCode = context-&gt;us-&gt;messageClient(
        msgType, object, (<span class="enscript-type">void</span> *) &amp;msgArg, <span class="enscript-keyword">sizeof</span>(msgArg));

    <span class="enscript-keyword">if</span> ( kIOReturnSuccess == retCode )
    {
        <span class="enscript-keyword">if</span> ( 0 == msgArg.maxWaitForReply )
        {
            <span class="enscript-comment">// client doesn't want time to respond
</span>            OUR_PMLog(kPMLogClientAcknowledge, msgRef, (uintptr_t) object);
        }
        <span class="enscript-keyword">else</span>
        {
            replied = kOSBooleanFalse;
            <span class="enscript-keyword">if</span> ( msgArg.maxWaitForReply &gt; context-&gt;maxTimeRequested )
            {
                <span class="enscript-keyword">if</span> (msgArg.maxWaitForReply &gt; kCapabilityClientMaxWait)
                {
                    context-&gt;maxTimeRequested = kCapabilityClientMaxWait;
                    PM_ERROR(<span class="enscript-string">&quot;%s: client %p returned %u for %s\n&quot;</span>,
                        context-&gt;us-&gt;getName(),
                        notifier ? (<span class="enscript-type">void</span> *) OBFUSCATE(notifier-&gt;handler) : OBFUSCATE(object),
                        msgArg.maxWaitForReply,
                        getIOMessageString(msgType));
                }
                <span class="enscript-keyword">else</span>
                    context-&gt;maxTimeRequested = msgArg.maxWaitForReply;
            }
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// not a client of ours
</span>        <span class="enscript-comment">// so we won't be waiting for response
</span>        OUR_PMLog(kPMLogClientAcknowledge, msgRef, 0);
    }

    context-&gt;responseArray-&gt;setObject(msgIndex, replied);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] tellNoChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are not
</span><span class="enscript-comment">// dropping power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Subclass can override this to send a different message type.  Parameter is
</span><span class="enscript-comment">// the aborted destination state number.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::tellNoChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> )
{
    <span class="enscript-keyword">return</span> tellClients( kIOMessageDeviceWillNotPowerOff );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] tellChangeUp
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are raising power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Subclass can override this to send a different message type.  Parameter is
</span><span class="enscript-comment">// the aborted destination state number.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::tellChangeUp</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> )
{
    <span class="enscript-keyword">return</span> tellClients( kIOMessageDeviceHasPoweredOn );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] tellClients
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients of something.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::tellClients</span>( <span class="enscript-type">int</span> messageType )
{
    IOPMInterestContext     context;

    RD_LOG(<span class="enscript-string">&quot;tellClients( %s )\n&quot;</span>, getIOMessageString(messageType));

    memset(&amp;context, 0, <span class="enscript-keyword">sizeof</span>(context));
    context.messageType   = messageType;
    context.isPreChange   = fIsPreChange;
    context.us            = <span class="enscript-keyword">this</span>;
    context.stateNumber   = fHeadNotePowerState;
    context.stateFlags    = fHeadNotePowerArrayEntry-&gt;capabilityFlags;
    context.changeFlags   = fHeadNoteChangeFlags;
    context.messageFilter = (IS_ROOT_DOMAIN) ?
                            OSMemberFunctionCast(
                                IOPMMessageFilter,
                                <span class="enscript-keyword">this</span>,
                                &amp;IOPMrootDomain::systemMessageFilter) : 0;

    context.notifyType    = kNotifyPriority;
    applyToInterested( gIOPriorityPowerStateInterest,
        tellKernelClientApplier, (<span class="enscript-type">void</span> *) &amp;context );

    context.notifyType    = kNotifyApps;
    applyToInterested( gIOAppPowerStateInterest,
        tellAppClientApplier, (<span class="enscript-type">void</span> *) &amp;context );

    applyToInterested( gIOGeneralInterest,
        tellKernelClientApplier, (<span class="enscript-type">void</span> *) &amp;context );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] tellKernelClientApplier
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Message a kernel client.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tellKernelClientApplier</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPowerStateChangeNotification  notify;
    IOPMInterestContext *           context = (IOPMInterestContext *) arg;

    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, 0, 0))
    {
        <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp;
            (OSDynamicCast(_IOServiceInterestNotifier, object)))
        {
            _IOServiceInterestNotifier *n = (_IOServiceInterestNotifier *) object;
            PM_LOG(<span class="enscript-string">&quot;%s DROP Client %s, notifier %p, handler %p\n&quot;</span>,
                context-&gt;us-&gt;getName(),
                <span class="enscript-reference">IOService</span>::getIOMessageString(context-&gt;messageType),
                OBFUSCATE(object), OBFUSCATE(n-&gt;handler));
        }
        <span class="enscript-keyword">return</span>;
    }

    notify.powerRef     = (<span class="enscript-type">void</span> *) 0;
    notify.returnValue  = 0;
    notify.stateNumber  = context-&gt;stateNumber;
    notify.stateFlags   = context-&gt;stateFlags;

    context-&gt;us-&gt;messageClient(context-&gt;messageType, object, &amp;notify, <span class="enscript-keyword">sizeof</span>(notify));

    <span class="enscript-keyword">if</span> ((kIOLogDebugPower &amp; gIOKitDebug) &amp;&amp;
        (OSDynamicCast(_IOServiceInterestNotifier, object)))
    {
        _IOServiceInterestNotifier *n = (_IOServiceInterestNotifier *) object;
        PM_LOG(<span class="enscript-string">&quot;%s MESG Client %s, notifier %p, handler %p\n&quot;</span>,
            context-&gt;us-&gt;getName(),
            <span class="enscript-reference">IOService</span>::getIOMessageString(context-&gt;messageType),
            OBFUSCATE(object), OBFUSCATE(n-&gt;handler));
    }
}

<span class="enscript-type">static</span> OSNumber * <span class="enscript-function-name">copyClientIDForNotification</span>(
    OSObject *object,
    IOPMInterestContext *context)
{
    OSNumber *clientID = NULL;
    context-&gt;us-&gt;messageClient(kIOMessageCopyClientID, object, &amp;clientID);
    <span class="enscript-keyword">return</span> clientID;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">logClientIDForNotification</span>(
    OSObject *object,
    IOPMInterestContext *context,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *logString)
{
    OSString *logClientID = NULL;
    OSNumber *clientID = copyClientIDForNotification(object, context);

    <span class="enscript-keyword">if</span> (logString)
    {
        <span class="enscript-keyword">if</span> (clientID)
            logClientID = IOCopyLogNameForPID(clientID-&gt;unsigned32BitValue());

        PM_LOG(<span class="enscript-string">&quot;%s %s %s, %s\n&quot;</span>,
            context-&gt;us-&gt;getName(), logString,
            <span class="enscript-reference">IOService</span>::getIOMessageString(context-&gt;messageType),
            logClientID ? logClientID-&gt;getCStringNoCopy() : <span class="enscript-string">&quot;&quot;</span>);

        <span class="enscript-keyword">if</span> (logClientID)
            logClientID-&gt;release();
    }

    <span class="enscript-keyword">if</span> (clientID)
        clientID-&gt;release();

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tellAppClientApplier</span>( OSObject * object, <span class="enscript-type">void</span> * arg )
{
    IOPMInterestContext * context = (IOPMInterestContext *) arg;
    OSNumber            * clientID = NULL;
    proc_t                proc = NULL;
    boolean_t             proc_suspended = FALSE;

    <span class="enscript-keyword">if</span> (context-&gt;us == IOService::getPMRootDomain())
    {
        <span class="enscript-keyword">if</span> ((clientID = copyClientIDForNotification(object, context)))
        {
            uint32_t clientPID = clientID-&gt;unsigned32BitValue();
            clientID-&gt;release();
            proc = proc_find(clientPID);

            <span class="enscript-keyword">if</span> (proc)
            {
                proc_suspended = get_task_pidsuspended((task_t) proc-&gt;task);
                proc_rele(proc);

                <span class="enscript-keyword">if</span> (proc_suspended)
                {
                    logClientIDForNotification(object, context, <span class="enscript-string">&quot;tellAppClientApplier - Suspended&quot;</span>);
                    <span class="enscript-keyword">return</span>;
                }
            }
        }
    }

    <span class="enscript-keyword">if</span> (context-&gt;messageFilter &amp;&amp;
        !context-&gt;messageFilter(context-&gt;us, object, context, 0, 0))
    {
        <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
        {
            logClientIDForNotification(object, context, <span class="enscript-string">&quot;DROP App&quot;</span>);
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
    {
        logClientIDForNotification(object, context, <span class="enscript-string">&quot;MESG App&quot;</span>);
    }

    context-&gt;us-&gt;messageClient(context-&gt;messageType, object, 0);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] checkForDone
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::checkForDone</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">int</span>         i = 0;
    OSObject *  theFlag;

    <span class="enscript-keyword">if</span> (fResponseArray == NULL) {
        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-keyword">for</span> (i = 0; ; i++) {
        theFlag = fResponseArray-&gt;getObject(i);

        <span class="enscript-keyword">if</span> (NULL == theFlag) {
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (kOSBooleanTrue != theFlag) {
            <span class="enscript-keyword">return</span> false;
        }
    }
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] responseValid
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::responseValid</span>( uint32_t refcon, <span class="enscript-type">int</span> pid )
{
    UInt16          serialComponent;
    UInt16          ordinalComponent;
    OSObject *      theFlag;
    OSObject        *object = 0;

    serialComponent  = (refcon &gt;&gt; 16) &amp; 0xFFFF;
    ordinalComponent = (refcon &amp; 0xFFFF);

    <span class="enscript-keyword">if</span> ( serialComponent != fSerialNumber )
    {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> ( fResponseArray == NULL )
    {
        <span class="enscript-keyword">return</span> false;
    }

    theFlag = fResponseArray-&gt;getObject(ordinalComponent);

    <span class="enscript-keyword">if</span> ( theFlag == 0 )
    {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> (fNotifyClientArray) 
        object = fNotifyClientArray-&gt;getObject(ordinalComponent);

    OSNumber * num;
    <span class="enscript-keyword">if</span> ((num = OSDynamicCast(OSNumber, theFlag)))
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_APP_RESPONSE_TIMES</span>
        AbsoluteTime    now;
        AbsoluteTime    start;
        uint64_t        nsec;
        <span class="enscript-type">char</span>            name[128];

        name[0] = <span class="enscript-string">'\0'</span>;
        proc_name(pid, name, <span class="enscript-keyword">sizeof</span>(name));
        clock_get_uptime(&amp;now);
        AbsoluteTime_to_scalar(&amp;start) = num-&gt;unsigned64BitValue();
        SUB_ABSOLUTETIME(&amp;now, &amp;start);
        absolutetime_to_nanoseconds(now, &amp;nsec);

        <span class="enscript-keyword">if</span> (kIOLogDebugPower &amp; gIOKitDebug)
        {
            PM_LOG(<span class="enscript-string">&quot;Ack(%u) %u ms\n&quot;</span>,
                (uint32_t) ordinalComponent,
                NS_TO_MS(nsec));
        }

        <span class="enscript-comment">// &gt; 100 ms
</span>        <span class="enscript-keyword">if</span> (nsec &gt; LOG_APP_RESPONSE_TIMES)
        {
            IOLog(<span class="enscript-string">&quot;PM response took %d ms (%d, %s)\n&quot;</span>, NS_TO_MS(nsec),
                pid, name);
        }

        <span class="enscript-keyword">if</span> (nsec &gt; LOG_APP_RESPONSE_MSG_TRACER)
        {
            <span class="enscript-comment">// TODO: populate the messageType argument
</span>            getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                gIOPMStatsApplicationResponseSlow,
                name, 0, NS_TO_MS(nsec), pid, object);
        }
        <span class="enscript-keyword">else</span>
        {
            getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                gIOPMStatsApplicationResponsePrompt,
                name, 0, NS_TO_MS(nsec), pid, object);
        }

#<span class="enscript-reference">endif</span>
        theFlag = kOSBooleanFalse;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (object) {
        getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
            gIOPMStatsApplicationResponsePrompt, 
            0, 0, 0, pid, object);

    }

    <span class="enscript-keyword">if</span> ( kOSBooleanFalse == theFlag )
    {
        fResponseArray-&gt;replaceObject(ordinalComponent, kOSBooleanTrue);
    }

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] allowPowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Our power state is about to lower, and we have notified applications
</span><span class="enscript-comment">// and kernel clients, and one of them has acknowledged.  If this is the last to do
</span><span class="enscript-comment">// so, and all acknowledgements are positive, we continue with the power change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::allowPowerChange</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon )
{
    IOPMRequest * request;

    <span class="enscript-keyword">if</span> ( !initialized )
    {
        <span class="enscript-comment">// we're unloading
</span>        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeAllowPowerChange );
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    request-&gt;fArg0 = (<span class="enscript-type">void</span> *)            refcon;
    request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) proc_selfpid();
    request-&gt;fArg2 = (<span class="enscript-type">void</span> *)            0;
    submitPMRequest( request );

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOReturn <span class="enscript-function-name">IOService::serializedAllowPowerChange2</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon )
{
    <span class="enscript-comment">// [deprecated] public
</span>    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] cancelPowerChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Our power state is about to lower, and we have notified applications
</span><span class="enscript-comment">// and kernel clients, and one of them has vetoed the change.  If this is the last
</span><span class="enscript-comment">// client to respond, we abandon the power change.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::cancelPowerChange</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon )
{
    IOPMRequest *   request;
    <span class="enscript-type">char</span>            name[128];
    pid_t           pid = proc_selfpid();

    <span class="enscript-keyword">if</span> ( !initialized )
    {
        <span class="enscript-comment">// we're unloading
</span>        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }

    name[0] = <span class="enscript-string">'\0'</span>;
    proc_name(pid, name, <span class="enscript-keyword">sizeof</span>(name));
    PM_ERROR(<span class="enscript-string">&quot;PM notification cancel (pid %d, %s)\n&quot;</span>, pid, name);

    request = acquirePMRequest( <span class="enscript-keyword">this</span>, kIOPMRequestTypeCancelPowerChange );
    <span class="enscript-keyword">if</span> (!request)
    {
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;
    }

    request-&gt;fArg0 = (<span class="enscript-type">void</span> *)            refcon;
    request-&gt;fArg1 = (<span class="enscript-type">void</span> *)(uintptr_t) proc_selfpid();
    request-&gt;fArg2 = (<span class="enscript-type">void</span> *)            OSString::withCString(name);
    submitPMRequest( request );

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOReturn <span class="enscript-function-name">IOService::serializedCancelPowerChange2</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> refcon )
{
    <span class="enscript-comment">// [deprecated] public
</span>    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// PM_Clamp_Timer_Expired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// called when clamp timer expires...set power state to 0.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::PM_Clamp_Timer_Expired</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// clampPowerOn
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Set to highest available power state for a minimum of duration milliseconds
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::clampPowerOn</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> duration )
{
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//  configurePowerStateReport
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//  Configures the IOStateReport for kPMPowerStateChannel
</span><span class="enscript-comment">//*********************************************************************************
</span>IOReturn <span class="enscript-function-name">IOService::configurePowerStatesReport</span>( IOReportConfigureAction action, <span class="enscript-type">void</span> *result )
{

    IOReturn rc = kIOReturnSuccess;
    size_t  reportSize;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> i;
    uint64_t                ts;

    <span class="enscript-keyword">if</span> (!pwrMgt)
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">if</span> (!fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> kIOReturnSuccess; <span class="enscript-comment">// For drivers which are in power plane, but haven't called registerPowerDriver()
</span>    PM_LOCK();

    <span class="enscript-keyword">switch</span> (action)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportEnable</span>:
            <span class="enscript-keyword">if</span> (fReportBuf)
            {
               fReportClientCnt++;
               <span class="enscript-keyword">break</span>;
            }
            reportSize = STATEREPORT_BUFSIZE(fNumberOfPowerStates);
            fReportBuf = IOMalloc(reportSize);
            <span class="enscript-keyword">if</span> (!fReportBuf) {
                rc = kIOReturnNoMemory;
                <span class="enscript-keyword">break</span>;
            }
            memset(fReportBuf, 0, reportSize);

            STATEREPORT_INIT(fNumberOfPowerStates, fReportBuf, reportSize,
                getRegistryEntryID(), kPMPowerStatesChID,  kIOReportCategoryPower);

            <span class="enscript-keyword">for</span> (i = 0; i &lt; fNumberOfPowerStates; i++) {
                <span class="enscript-type">unsigned</span> bits = 0;

                <span class="enscript-keyword">if</span> (fPowerStates[i].capabilityFlags &amp; kIOPMPowerOn)
                   bits |= kPMReportPowerOn;
                <span class="enscript-keyword">if</span> (fPowerStates[i].capabilityFlags &amp; kIOPMDeviceUsable)
                   bits |= kPMReportDeviceUsable;
                <span class="enscript-keyword">if</span> (fPowerStates[i].capabilityFlags &amp; kIOPMLowPower)
                   bits |= kPMReportLowPower;

                STATEREPORT_SETSTATEID(fReportBuf, i, ((bits &amp; 0xff) &lt;&lt; 8) |
                            ((StateOrder(fMaxPowerState) &amp; 0xf) &lt;&lt; 4) | (StateOrder(i) &amp; 0xf));
            }
            ts = mach_absolute_time();
            STATEREPORT_SETSTATE(fReportBuf, fCurrentPowerState, ts);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportDisable</span>:
            <span class="enscript-keyword">if</span> (fReportClientCnt == 0) {
               rc = kIOReturnBadArgument;
               <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">if</span> (fReportClientCnt == 1)
            {
                IOFree(fReportBuf, STATEREPORT_BUFSIZE(fNumberOfPowerStates));
                fReportBuf = NULL;
            }
            fReportClientCnt--;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportGetDimensions</span>:
            <span class="enscript-keyword">if</span> (fReportBuf)
                STATEREPORT_UPDATERES(fReportBuf, kIOReportGetDimensions, result);
            <span class="enscript-keyword">break</span>;
    }

    PM_UNLOCK();

    <span class="enscript-keyword">return</span> rc;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//  updatePowerStateReport
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//  Updates the IOStateReport for kPMPowerStateChannel
</span><span class="enscript-comment">//*********************************************************************************
</span>IOReturn <span class="enscript-function-name">IOService::updatePowerStatesReport</span>( IOReportConfigureAction action, <span class="enscript-type">void</span> *result, <span class="enscript-type">void</span> *destination )
{
    uint32_t size2cpy;
    <span class="enscript-type">void</span> *data2cpy;
    uint64_t ts;
    IOReturn rc = kIOReturnSuccess;
    IOBufferMemoryDescriptor *dest = OSDynamicCast(IOBufferMemoryDescriptor, (OSObject *)destination);


    <span class="enscript-keyword">if</span> (!pwrMgt)
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    <span class="enscript-keyword">if</span> (!fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> kIOReturnSuccess;

    <span class="enscript-keyword">if</span> ( !result || !dest ) <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    PM_LOCK();

    <span class="enscript-keyword">switch</span> (action) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportCopyChannelData</span>:
            <span class="enscript-keyword">if</span> ( !fReportBuf )  {
                rc = kIOReturnNotOpen;
                <span class="enscript-keyword">break</span>;
            }

            ts = mach_absolute_time();
            STATEREPORT_UPDATEPREP(fReportBuf, ts, data2cpy, size2cpy);
            <span class="enscript-keyword">if</span> (size2cpy &gt; (dest-&gt;getCapacity() - dest-&gt;getLength()) )  {
                rc = kIOReturnOverrun;
                <span class="enscript-keyword">break</span>;
            }

            STATEREPORT_UPDATERES(fReportBuf, kIOReportCopyChannelData, result);
            dest-&gt;appendBytes(data2cpy, size2cpy);

        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">break</span>;

    }

    PM_UNLOCK();

    <span class="enscript-keyword">return</span> rc;

}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//  configureSimplePowerReport
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//  Configures the IOSimpleReport for given channel id
</span><span class="enscript-comment">//*********************************************************************************
</span>IOReturn <span class="enscript-function-name">IOService::configureSimplePowerReport</span>(IOReportConfigureAction action, <span class="enscript-type">void</span> *result )
{

    IOReturn rc = kIOReturnSuccess;

    <span class="enscript-keyword">if</span> ( !pwrMgt )
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">if</span> ( !fNumberOfPowerStates )
        <span class="enscript-keyword">return</span> rc;

    <span class="enscript-keyword">switch</span> (action)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportEnable</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportDisable</span>:
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportGetDimensions</span>:
             SIMPLEREPORT_UPDATERES(kIOReportGetDimensions, result);
            <span class="enscript-keyword">break</span>;
    }


    <span class="enscript-keyword">return</span> rc;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//  updateSimplePowerReport
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//  Updates the IOSimpleReport for the given chanel id
</span><span class="enscript-comment">//*********************************************************************************
</span>IOReturn <span class="enscript-function-name">IOService::updateSimplePowerReport</span>( IOReportConfigureAction action, <span class="enscript-type">void</span> *result, <span class="enscript-type">void</span> *destination )
{
    uint32_t size2cpy;
    <span class="enscript-type">void</span> *data2cpy;
    uint64_t buf[SIMPLEREPORT_BUFSIZE/<span class="enscript-keyword">sizeof</span>(uint64_t)+1]; <span class="enscript-comment">// Force a 8-byte alignment
</span>    IOBufferMemoryDescriptor *dest = OSDynamicCast(IOBufferMemoryDescriptor, (OSObject *)destination);
    IOReturn rc = kIOReturnSuccess;
    <span class="enscript-type">unsigned</span> bits = 0;


    <span class="enscript-keyword">if</span> ( !pwrMgt )
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    <span class="enscript-keyword">if</span> ( !result || !dest ) <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    <span class="enscript-keyword">if</span> ( !fNumberOfPowerStates )
        <span class="enscript-keyword">return</span> rc;
    PM_LOCK();

    <span class="enscript-keyword">switch</span> (action) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportCopyChannelData</span>:

            SIMPLEREPORT_INIT(buf, <span class="enscript-keyword">sizeof</span>(buf),  getRegistryEntryID(), kPMCurrStateChID, kIOReportCategoryPower);

            <span class="enscript-keyword">if</span> (fPowerStates[fCurrentPowerState].capabilityFlags &amp; kIOPMPowerOn)
               bits |= kPMReportPowerOn;
            <span class="enscript-keyword">if</span> (fPowerStates[fCurrentPowerState].capabilityFlags &amp; kIOPMDeviceUsable)
               bits |= kPMReportDeviceUsable;
            <span class="enscript-keyword">if</span> (fPowerStates[fCurrentPowerState].capabilityFlags &amp; kIOPMLowPower)
               bits |= kPMReportLowPower;


            SIMPLEREPORT_SETVALUE(buf, ((bits &amp; 0xff) &lt;&lt; 8) | ((StateOrder(fMaxPowerState) &amp; 0xf) &lt;&lt; 4) |
                                                               (StateOrder(fCurrentPowerState) &amp; 0xf));

            SIMPLEREPORT_UPDATEPREP(buf, data2cpy, size2cpy);
            <span class="enscript-keyword">if</span> (size2cpy &gt; (dest-&gt;getCapacity() - dest-&gt;getLength()))  {
                rc = kIOReturnOverrun;
                <span class="enscript-keyword">break</span>;
            }

            SIMPLEREPORT_UPDATERES(kIOReportCopyChannelData, result);
            dest-&gt;appendBytes(data2cpy, size2cpy);

        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">break</span>;

    }

    PM_UNLOCK();

    <span class="enscript-keyword">return</span> kIOReturnSuccess;

}



<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Driver Overrides
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] setPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::setPowerState</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> powerStateOrdinal, IOService * whatDevice )
{
    <span class="enscript-keyword">return</span> IOPMNoErr;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] maxCapabilityForDomainState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Finds the highest power state in the array whose input power requirement
</span><span class="enscript-comment">// is equal to the input parameter. Where a more intelligent decision is
</span><span class="enscript-comment">// possible, override this in the subclassed driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOPMPowerStateIndex <span class="enscript-function-name">IOService::getPowerStateForDomainFlags</span>( IOPMPowerFlags flags )
{
    IOPMPowerStateIndex stateIndex;

    <span class="enscript-keyword">if</span> (!fNumberOfPowerStates)
        <span class="enscript-keyword">return</span> kPowerStateZero;

    <span class="enscript-keyword">for</span> ( <span class="enscript-type">int</span> order = fNumberOfPowerStates - 1; order &gt;= 0; order-- )
    {
        stateIndex = fPowerStates[order].stateOrderToIndex;

        <span class="enscript-keyword">if</span> ( (flags &amp; fPowerStates[stateIndex].inputPowerFlags) ==
                      fPowerStates[stateIndex].inputPowerFlags )
        {
            <span class="enscript-keyword">return</span> stateIndex;
        }
    }
    <span class="enscript-keyword">return</span> kPowerStateZero;
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-function-name">IOService::maxCapabilityForDomainState</span>( IOPMPowerFlags domainState )
{
    <span class="enscript-keyword">return</span> getPowerStateForDomainFlags(domainState);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] initialPowerStateForDomainState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called to query the power state for the initial power transition.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-function-name">IOService::initialPowerStateForDomainState</span>( IOPMPowerFlags domainState )
{
    <span class="enscript-keyword">if</span> (fResetPowerStateOnWake &amp;&amp; (domainState &amp; kIOPMRootDomainState))
    {
        <span class="enscript-comment">// Return lowest power state for any root power domain changes
</span>        <span class="enscript-keyword">return</span> kPowerStateZero;
    }

    <span class="enscript-keyword">return</span> getPowerStateForDomainFlags(domainState);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] powerStateForDomainState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This method is not called from PM.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-function-name">IOService::powerStateForDomainState</span>( IOPMPowerFlags domainState )
{
    <span class="enscript-keyword">return</span> getPowerStateForDomainFlags(domainState);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] didYouWakeSystem
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::didYouWakeSystem</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> false;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] powerStateWillChangeTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerStateWillChangeTo</span>( IOPMPowerFlags, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>, IOService * )
{
    <span class="enscript-keyword">return</span> kIOPMAckImplied;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] powerStateDidChangeTo
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::powerStateDidChangeTo</span>( IOPMPowerFlags, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>, IOService * )
{
    <span class="enscript-keyword">return</span> kIOPMAckImplied;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [protected] powerChangeDone
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called from PM work loop thread.
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass policy-maker.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::powerChangeDone</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> )
{
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [deprecated] newTemperature
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Does nothing here.  This should be implemented in a subclass driver.
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOService::newTemperature</span>( <span class="enscript-type">long</span> currentTemp, IOService * whichZone )
{
    <span class="enscript-keyword">return</span> IOPMNoErr;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [public] systemWillShutdown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// System shutdown and restart notification.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::systemWillShutdown</span>( IOOptionBits specifier )
{
    IOPMrootDomain * rootDomain = IOService::getPMRootDomain();
    <span class="enscript-keyword">if</span> (rootDomain)
        rootDomain-&gt;acknowledgeSystemWillShutdown( <span class="enscript-keyword">this</span> );
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PM State Machine
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private static] acquirePMRequest
</span><span class="enscript-comment">//*********************************************************************************
</span>
IOPMRequest *
<span class="enscript-function-name">IOService::acquirePMRequest</span>( IOService * target, IOOptionBits requestType,
                             IOPMRequest * active )
{
    IOPMRequest * request;

    assert(target);

    request = IOPMRequest::create();
    <span class="enscript-keyword">if</span> (request)
    {
        request-&gt;init( target, requestType );
        <span class="enscript-keyword">if</span> (active)
        {
            IOPMRequest * root = active-&gt;getRootRequest();
            <span class="enscript-keyword">if</span> (root) request-&gt;attachRootRequest(root);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        PM_ERROR(<span class="enscript-string">&quot;%s: No memory for PM request type 0x%x\n&quot;</span>,
            target-&gt;getName(), (uint32_t) requestType);
    }
    <span class="enscript-keyword">return</span> request;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private static] releasePMRequest
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::releasePMRequest</span>( IOPMRequest * request )
{
    <span class="enscript-keyword">if</span> (request)
    {
        request-&gt;reset();
        request-&gt;release();
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private static] submitPMRequest
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::submitPMRequest</span>( IOPMRequest * request )
{
    assert( request );
    assert( gIOPMReplyQueue );
    assert( gIOPMRequestQueue );

    PM_LOG1(<span class="enscript-string">&quot;[+ %02lx] %p [%p %s] %p %p %p\n&quot;</span>,
        (<span class="enscript-type">long</span>)request-&gt;getType(), OBFUSCATE(request),
        OBFUSCATE(request-&gt;getTarget()), request-&gt;getTarget()-&gt;getName(),
        OBFUSCATE(request-&gt;fArg0),
        OBFUSCATE(request-&gt;fArg1), OBFUSCATE(request-&gt;fArg2));

    <span class="enscript-keyword">if</span> (request-&gt;isReplyType())
        gIOPMReplyQueue-&gt;queuePMRequest( request );
    <span class="enscript-keyword">else</span>
        gIOPMRequestQueue-&gt;queuePMRequest( request );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::submitPMRequests</span>( IOPMRequest ** requests, IOItemCount count )
{
    assert( requests );
    assert( count &gt; 0 );
    assert( gIOPMRequestQueue );

    <span class="enscript-keyword">for</span> (IOItemCount i = 0; i &lt; count; i++)
    {
        IOPMRequest * req = requests[i];
        PM_LOG1(<span class="enscript-string">&quot;[+ %02lx] %p [%p %s] %p %p %p\n&quot;</span>,
            (<span class="enscript-type">long</span>)req-&gt;getType(), OBFUSCATE(req),
            OBFUSCATE(req-&gt;getTarget()), req-&gt;getTarget()-&gt;getName(),
            OBFUSCATE(req-&gt;fArg0),
            OBFUSCATE(req-&gt;fArg1), OBFUSCATE(req-&gt;fArg2));
    }

    gIOPMRequestQueue-&gt;queuePMRequestChain( requests, count );
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] actionPMRequestQueue
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMRequestQueue::checkForWork() passing a new request to the request target.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::actionPMRequestQueue</span>(
    IOPMRequest *       request,
    IOPMRequestQueue *  queue )
{
    <span class="enscript-type">bool</span> more;

    <span class="enscript-keyword">if</span> (initialized)
    {
        <span class="enscript-comment">// Work queue will immediately execute the request if the per-service
</span>        <span class="enscript-comment">// request queue is empty. Note pwrMgt is the target's IOServicePM.
</span>
        more = gIOPMWorkQueue-&gt;queuePMRequest(request, pwrMgt);
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Calling PM without PMinit() is not allowed, fail the request.
</span>        <span class="enscript-comment">// Need to signal more when completing attached requests.
</span>
        PM_LOG(<span class="enscript-string">&quot;%s: PM not initialized\n&quot;</span>, getName());
        PM_LOG1(<span class="enscript-string">&quot;[- %02x] %p [%p %s] !initialized\n&quot;</span>,
            request-&gt;getType(), OBFUSCATE(request),
            OBFUSCATE(<span class="enscript-keyword">this</span>), getName());

        more = gIOPMCompletionQueue-&gt;queuePMRequest(request);
        <span class="enscript-keyword">if</span> (more) gIOPMWorkQueue-&gt;incrementProducerCount();
    }

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] actionPMCompletionQueue
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMCompletionQueue::checkForWork() passing a completed request to the
</span><span class="enscript-comment">// request target.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::actionPMCompletionQueue</span>(
    IOPMRequest *         request,
    IOPMCompletionQueue * queue )
{
    <span class="enscript-type">bool</span>            more = (request-&gt;getNextRequest() != 0);
    IOPMRequest *   root = request-&gt;getRootRequest();

    <span class="enscript-keyword">if</span> (root &amp;&amp; (root != request))
        more = true;
    <span class="enscript-keyword">if</span> (more)
        gIOPMWorkQueue-&gt;incrementProducerCount();

    releasePMRequest( request );
    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] actionPMWorkQueueRetire
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMWorkQueue::checkForWork() passing a retired request to the request target.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::actionPMWorkQueueRetire</span>( IOPMRequest * request, IOPMWorkQueue * queue )
{
    assert(request &amp;&amp; queue);

    PM_LOG1(<span class="enscript-string">&quot;[- %02x] %p [%p %s] state %d, busy %d\n&quot;</span>,
        request-&gt;getType(), OBFUSCATE(request),
        OBFUSCATE(<span class="enscript-keyword">this</span>), getName(),
        fMachineState, gIOPMBusyRequestCount);

    <span class="enscript-comment">// Catch requests created by idleTimerExpired()
</span>    <span class="enscript-keyword">if</span> (request-&gt;getType() == kIOPMRequestTypeActivityTickle)
    {
        uint32_t tickleFlags = (uint32_t)(uintptr_t) request-&gt;fArg1;

        <span class="enscript-keyword">if</span> ((tickleFlags &amp; kTickleTypePowerDrop) &amp;&amp; fIdleTimerPeriod)
        {
            restartIdleTimer();
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tickleFlags == (kTickleTypeActivity | kTickleTypePowerRise))
        {
            <span class="enscript-comment">// Invalidate any idle power drop that got queued while
</span>            <span class="enscript-comment">// processing this request.
</span>            fIdleTimerGeneration++;
        }
    }
    
    <span class="enscript-comment">// When the completed request is linked, tell work queue there is
</span>    <span class="enscript-comment">// more work pending.
</span>
    <span class="enscript-keyword">return</span> (gIOPMCompletionQueue-&gt;queuePMRequest( request ));
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] isPMBlocked
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Check if machine state transition is blocked.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::isPMBlocked</span>( IOPMRequest * request, <span class="enscript-type">int</span> count )
{
    <span class="enscript-type">int</span> reason = 0;

    <span class="enscript-keyword">do</span> {
        <span class="enscript-keyword">if</span> (kIOPM_Finished == fMachineState)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">if</span> (kIOPM_DriverThreadCallDone == fMachineState)
        {
            <span class="enscript-comment">// 5 = kDriverCallInformPreChange
</span>            <span class="enscript-comment">// 6 = kDriverCallInformPostChange
</span>            <span class="enscript-comment">// 7 = kDriverCallSetPowerState
</span>            <span class="enscript-comment">// 8 = kRootDomainInformPreChange
</span>            <span class="enscript-keyword">if</span> (fDriverCallBusy)
                reason = 5 + fDriverCallReason;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Waiting on driver's setPowerState() timeout.
</span>        <span class="enscript-keyword">if</span> (fDriverTimer)
        {
            reason = 1; <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Child or interested driver acks pending.
</span>        <span class="enscript-keyword">if</span> (fHeadNotePendingAcks)
        {
            reason = 2; <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Waiting on apps or priority power interest clients.
</span>        <span class="enscript-keyword">if</span> (fResponseArray)
        {
            reason = 3; <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Waiting on settle timer expiration.
</span>        <span class="enscript-keyword">if</span> (fSettleTimeUS)
        {
            reason = 4; <span class="enscript-keyword">break</span>;
        }
    } <span class="enscript-keyword">while</span> (false);

    fWaitReason = reason;

    <span class="enscript-keyword">if</span> (reason)
    {
        <span class="enscript-keyword">if</span> (count)
        {
            PM_LOG1(<span class="enscript-string">&quot;[B %02x] %p [%p %s] state %d, reason %d\n&quot;</span>,
                request-&gt;getType(), OBFUSCATE(request),
                OBFUSCATE(<span class="enscript-keyword">this</span>), getName(),
                fMachineState, reason);
        }

        <span class="enscript-keyword">return</span> true;
    }

    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] actionPMWorkQueueInvoke
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMWorkQueue::checkForWork() passing a request to the
</span><span class="enscript-comment">// request target for execution.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::actionPMWorkQueueInvoke</span>( IOPMRequest * request, IOPMWorkQueue * queue )
{
    <span class="enscript-type">bool</span>    done = false;
    <span class="enscript-type">int</span>     loop = 0;

    assert(request &amp;&amp; queue);

    <span class="enscript-keyword">while</span> (isPMBlocked(request, loop++) == false)
    {
        PM_LOG1(<span class="enscript-string">&quot;[W %02x] %p [%p %s] state %d\n&quot;</span>,
            request-&gt;getType(), OBFUSCATE(request),
            OBFUSCATE(<span class="enscript-keyword">this</span>), getName(), fMachineState);

        gIOPMRequest = request;
        gIOPMWorkInvokeCount++;

        <span class="enscript-comment">// Every PM machine states must be handled in one of the cases below.
</span>
        <span class="enscript-keyword">switch</span> ( fMachineState )
        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_Finished</span>:
                start_watchdog_timer();

                executePMRequest( request );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellClientsPowerDown</span>:
                <span class="enscript-comment">// Root domain might self cancel due to assertions.
</span>                <span class="enscript-keyword">if</span> (IS_ROOT_DOMAIN)
                {
                    <span class="enscript-type">bool</span> cancel = (<span class="enscript-type">bool</span>) fDoNotPowerDown;
                    getPMRootDomain()-&gt;askChangeDownDone(
                        &amp;fHeadNoteChangeFlags, &amp;cancel);
                    fDoNotPowerDown = cancel;
                }

                <span class="enscript-comment">// askChangeDown() done, was it vetoed?
</span>                <span class="enscript-keyword">if</span> (!fDoNotPowerDown)
                {
                    <span class="enscript-comment">// no, we can continue
</span>                    OurChangeTellClientsPowerDown();
                }
                <span class="enscript-keyword">else</span>
                {
                    OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                    PM_ERROR(<span class="enscript-string">&quot;%s: idle cancel, state %u\n&quot;</span>, fName, fMachineState);
                    <span class="enscript-comment">// yes, rescind the warning
</span>                    tellNoChangeDown(fHeadNotePowerState);
                    <span class="enscript-comment">// mark the change note un-actioned
</span>                    fHeadNoteChangeFlags |= kIOPMNotDone;
                    <span class="enscript-comment">// and we're done
</span>                    OurChangeFinish();
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellUserPMPolicyPowerDown</span>:
                <span class="enscript-comment">// PMRD: tellChangeDown/kNotifyApps done, was it cancelled?
</span>                <span class="enscript-keyword">if</span> (fDoNotPowerDown)
                {
                    OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                    PM_ERROR(<span class="enscript-string">&quot;%s: idle cancel, state %u\n&quot;</span>, fName, fMachineState);
                    <span class="enscript-comment">// yes, rescind the warning
</span>                    tellNoChangeDown(fHeadNotePowerState);
                    <span class="enscript-comment">// mark the change note un-actioned
</span>                    fHeadNoteChangeFlags |= kIOPMNotDone;
                    <span class="enscript-comment">// and we're done
</span>                    OurChangeFinish();
                }
                <span class="enscript-keyword">else</span>
                    OurChangeTellUserPMPolicyPowerDown();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellPriorityClientsPowerDown</span>:
                <span class="enscript-comment">// PMRD:     LastCallBeforeSleep notify done
</span>                <span class="enscript-comment">// Non-PMRD: tellChangeDown/kNotifyApps done
</span>                <span class="enscript-keyword">if</span> (fDoNotPowerDown)
                {
                    OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                    PM_ERROR(<span class="enscript-string">&quot;%s: idle revert, state %u\n&quot;</span>, fName, fMachineState);
                    <span class="enscript-comment">// no, tell clients we're back in the old state
</span>                    tellChangeUp(fCurrentPowerState);
                    <span class="enscript-comment">// mark the change note un-actioned
</span>                    fHeadNoteChangeFlags |= kIOPMNotDone;
                    <span class="enscript-comment">// and we're done
</span>                    OurChangeFinish();
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// yes, we can continue
</span>                    OurChangeTellPriorityClientsPowerDown();
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeNotifyInterestedDriversWillChange</span>:
                OurChangeNotifyInterestedDriversWillChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeSetPowerState</span>:
                OurChangeSetPowerState();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeWaitForPowerSettle</span>:
                OurChangeWaitForPowerSettle();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeNotifyInterestedDriversDidChange</span>:
                OurChangeNotifyInterestedDriversDidChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeTellCapabilityDidChange</span>:
                OurChangeTellCapabilityDidChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_OurChangeFinish</span>:
                OurChangeFinish();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeTellPriorityClientsPowerDown</span>:
                ParentChangeTellPriorityClientsPowerDown();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeNotifyInterestedDriversWillChange</span>:
                ParentChangeNotifyInterestedDriversWillChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeSetPowerState</span>:
                ParentChangeSetPowerState();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeWaitForPowerSettle</span>:
                ParentChangeWaitForPowerSettle();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeNotifyInterestedDriversDidChange</span>:
                ParentChangeNotifyInterestedDriversDidChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeTellCapabilityDidChange</span>:
                ParentChangeTellCapabilityDidChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_ParentChangeAcknowledgePowerChange</span>:
                ParentChangeAcknowledgePowerChange();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_DriverThreadCallDone</span>:
                <span class="enscript-keyword">switch</span> (fDriverCallReason)
                {
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallInformPreChange</span>:
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallInformPostChange</span>:
                        notifyInterestedDriversDone();
                        <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">kDriverCallSetPowerState</span>:
                        notifyControllingDriverDone();
                        <span class="enscript-keyword">break</span>;
                    <span class="enscript-keyword">case</span> <span class="enscript-reference">kRootDomainInformPreChange</span>:
                        notifyRootDomainDone();
                        <span class="enscript-keyword">break</span>;
                    <span class="enscript-reference">default</span>:
                        panic(<span class="enscript-string">&quot;%s: bad call reason %x&quot;</span>,
                            getName(), fDriverCallReason);
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_NotifyChildrenOrdered</span>:
                notifyChildrenOrdered();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_NotifyChildrenDelayed</span>:
                notifyChildrenDelayed();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_NotifyChildrenStart</span>:
                <span class="enscript-comment">// pop notifyAll() state saved by notifyInterestedDriversDone()
</span>                MS_POP();
                notifyRootDomain();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncTellClientsPowerDown</span>:
                <span class="enscript-comment">// Root domain might self cancel due to assertions.
</span>                <span class="enscript-keyword">if</span> (IS_ROOT_DOMAIN)
                {
                    <span class="enscript-type">bool</span> cancel = (<span class="enscript-type">bool</span>) fDoNotPowerDown;
                    getPMRootDomain()-&gt;askChangeDownDone(
                        &amp;fHeadNoteChangeFlags, &amp;cancel);
                    fDoNotPowerDown = cancel;
                }
                <span class="enscript-keyword">if</span> (!fDoNotPowerDown)
                {
                    fMachineState = kIOPM_SyncTellPriorityClientsPowerDown;
                    fOutOfBandParameter = kNotifyApps;
                    tellChangeDown(fHeadNotePowerState);
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Cancelled by IOPMrootDomain::askChangeDownDone() or
</span>                    <span class="enscript-comment">// askChangeDown/kNotifyApps
</span>                    OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                    PM_ERROR(<span class="enscript-string">&quot;%s: idle cancel, state %u\n&quot;</span>, fName, fMachineState);
                    tellNoChangeDown(fHeadNotePowerState);
                    fHeadNoteChangeFlags |= kIOPMNotDone;
                    OurChangeFinish();
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncTellPriorityClientsPowerDown</span>:
                <span class="enscript-comment">// PMRD: tellChangeDown/kNotifyApps done, was it cancelled?
</span>                <span class="enscript-keyword">if</span> (!fDoNotPowerDown)
                {
                    fMachineState = kIOPM_SyncNotifyWillChange;
                    fOutOfBandParameter = kNotifyPriority;
                    tellChangeDown(fHeadNotePowerState);
                }
                <span class="enscript-keyword">else</span>
                {
                    OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                    PM_ERROR(<span class="enscript-string">&quot;%s: idle revert, state %u\n&quot;</span>, fName, fMachineState);
                    tellChangeUp(fCurrentPowerState);
                    fHeadNoteChangeFlags |= kIOPMNotDone;
                    OurChangeFinish();
                }
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncNotifyWillChange</span>:
                <span class="enscript-keyword">if</span> (kIOPMSyncNoChildNotify &amp; fHeadNoteChangeFlags)
                {
                    fMachineState = kIOPM_SyncFinish;
                    <span class="enscript-keyword">continue</span>;
                }
                fMachineState     = kIOPM_SyncNotifyDidChange;
                fDriverCallReason = kDriverCallInformPreChange;
                notifyChildren();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncNotifyDidChange</span>:
                fIsPreChange = false;

                <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMParentInitiated)
                {
                    fMachineState = kIOPM_SyncFinish;
                }
                <span class="enscript-keyword">else</span>
                {
                    assert(IS_ROOT_DOMAIN);
                    fMachineState = kIOPM_SyncTellCapabilityDidChange;
                }

                fDriverCallReason = kDriverCallInformPostChange;
                notifyChildren();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncTellCapabilityDidChange</span>:
                tellSystemCapabilityChange( kIOPM_SyncFinish );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_SyncFinish</span>:
                <span class="enscript-keyword">if</span> (fHeadNoteChangeFlags &amp; kIOPMParentInitiated)
                    ParentChangeAcknowledgePowerChange();
                <span class="enscript-keyword">else</span>
                    OurChangeFinish();
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPM_TellCapabilityChangeDone</span>:
                <span class="enscript-keyword">if</span> (fIsPreChange)
                {
                    <span class="enscript-keyword">if</span> (fOutOfBandParameter == kNotifyCapabilityChangePriority)
                    {
                        MS_POP();   <span class="enscript-comment">// tellSystemCapabilityChange()
</span>                        <span class="enscript-keyword">continue</span>;
                    }
                    fOutOfBandParameter = kNotifyCapabilityChangePriority;
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-keyword">if</span> (fOutOfBandParameter == kNotifyCapabilityChangeApps)
                    {
                        MS_POP();   <span class="enscript-comment">// tellSystemCapabilityChange()
</span>                        <span class="enscript-keyword">continue</span>;
                    }
                    fOutOfBandParameter = kNotifyCapabilityChangeApps;
                }
                tellClientsWithResponse( fOutOfBandMessage );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                panic(<span class="enscript-string">&quot;PMWorkQueueInvoke: unknown machine state %x&quot;</span>,
                    fMachineState);
        }

        gIOPMRequest = 0;

        <span class="enscript-keyword">if</span> (fMachineState == kIOPM_Finished)
        {
            stop_watchdog_timer();
            done = true;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">return</span> done;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] executePMRequest
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::executePMRequest</span>( IOPMRequest * request )
{
    assert( kIOPM_Finished == fMachineState );

    <span class="enscript-keyword">switch</span> (request-&gt;getType())
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypePMStop</span>:
            handlePMstop( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAddPowerChild1</span>:
            addPowerChild1( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAddPowerChild2</span>:
            addPowerChild2( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAddPowerChild3</span>:
            addPowerChild3( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeRegisterPowerDriver</span>:
            handleRegisterPowerDriver( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAdjustPowerState</span>:
            fAdjustPowerScheduled = false;
            adjustPowerState();
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypePowerDomainWillChange</span>:
            handlePowerDomainWillChangeTo( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypePowerDomainDidChange</span>:
            handlePowerDomainDidChangeTo( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeRequestPowerState</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeRequestPowerStateOverride</span>:
            handleRequestPowerState( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypePowerOverrideOnPriv</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypePowerOverrideOffPriv</span>:
            handlePowerOverrideChanged( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeActivityTickle</span>:
            handleActivityTickle( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeSynchronizePowerTree</span>:
            handleSynchronizePowerTree( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeSetIdleTimerPeriod</span>:
            {
                fIdleTimerPeriod = (uintptr_t) request-&gt;fArg0;
                fNextIdleTimerPeriod = fIdleTimerPeriod;
                <span class="enscript-keyword">if</span> ((false == fLockedFlags.PMStop) &amp;&amp; (fIdleTimerPeriod &gt; 0))
                    restartIdleTimer();
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeIgnoreIdleTimer</span>:
            fIdleTimerIgnored = request-&gt;fArg0 ? 1 : 0;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeQuiescePowerTree</span>:
            gIOPMWorkQueue-&gt;finishQuiesceRequest(request);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            panic(<span class="enscript-string">&quot;executePMRequest: unknown request type %x&quot;</span>, request-&gt;getType());
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] actionPMReplyQueue
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMRequestQueue::checkForWork() passing a reply-type request to the
</span><span class="enscript-comment">// request target.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::actionPMReplyQueue</span>( IOPMRequest * request, IOPMRequestQueue * queue )
{
    <span class="enscript-type">bool</span> more = false;

    assert( request &amp;&amp; queue );
    assert( request-&gt;isReplyType() );

    PM_LOG1(<span class="enscript-string">&quot;[A %02x] %p [%p %s] state %d\n&quot;</span>,
        request-&gt;getType(), OBFUSCATE(request),
        OBFUSCATE(<span class="enscript-keyword">this</span>), getName(), fMachineState);

    <span class="enscript-keyword">switch</span> ( request-&gt;getType() )
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAllowPowerChange</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeCancelPowerChange</span>:
            <span class="enscript-comment">// Check if we are expecting this response.
</span>            <span class="enscript-keyword">if</span> (responseValid((uint32_t)(uintptr_t) request-&gt;fArg0,
                              (<span class="enscript-type">int</span>)(uintptr_t) request-&gt;fArg1))
            {
                <span class="enscript-keyword">if</span> (kIOPMRequestTypeCancelPowerChange == request-&gt;getType())
                {
                    <span class="enscript-comment">// Clients are not allowed to cancel when kIOPMSkipAskPowerDown
</span>                    <span class="enscript-comment">// flag is set. Only root domain will set this flag.
</span>                    <span class="enscript-comment">// However, there is one exception to this rule. User-space PM
</span>                    <span class="enscript-comment">// policy may choose to cancel sleep even after all clients have
</span>                    <span class="enscript-comment">// been notified that we will lower power.
</span>
                    <span class="enscript-keyword">if</span> ((fMachineState == kIOPM_OurChangeTellUserPMPolicyPowerDown)
                    || (fMachineState == kIOPM_OurChangeTellPriorityClientsPowerDown)
                    || ((fHeadNoteChangeFlags &amp; kIOPMSkipAskPowerDown) == 0))
                    {
                        fDoNotPowerDown = true;

                        OSString * name = (OSString *) request-&gt;fArg2;
                        getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                            gIOPMStatsApplicationResponseCancel,
                            name ? name-&gt;getCStringNoCopy() : <span class="enscript-string">&quot;&quot;</span>, 0,
                            0, (<span class="enscript-type">int</span>)(uintptr_t) request-&gt;fArg1, 0);
                    }
                }

                <span class="enscript-keyword">if</span> (checkForDone())
                {
                    stop_ack_timer();
                    cleanClientResponses(false);
                    more = true;
                }
            }
            <span class="enscript-comment">// OSString containing app name in Arg2 must be released.
</span>            <span class="enscript-keyword">if</span> (request-&gt;getType() == kIOPMRequestTypeCancelPowerChange)
            {
                OSObject * obj = (OSObject *) request-&gt;fArg2;
                <span class="enscript-keyword">if</span> (obj) obj-&gt;release();
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAckPowerChange</span>:
            more = handleAcknowledgePowerChange( request );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeAckSetPowerState</span>:
            <span class="enscript-keyword">if</span> (fDriverTimer == -1)
            {
                <span class="enscript-comment">// driver acked while setPowerState() call is in-flight.
</span>                <span class="enscript-comment">// take this ack, return value from setPowerState() is irrelevant.
</span>                OUR_PMLog(kPMLogDriverAcknowledgeSet,
                    (uintptr_t) <span class="enscript-keyword">this</span>, fDriverTimer);
                fDriverTimer = 0;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fDriverTimer &gt; 0)
            {
                <span class="enscript-comment">// expected ack, stop the timer
</span>                stop_ack_timer();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_SETPOWER_TIMES</span>
                uint64_t nsec = computeTimeDeltaNS(&amp;fDriverCallStartTime);
                <span class="enscript-keyword">if</span> (nsec &gt; LOG_SETPOWER_TIMES) {
                    getPMRootDomain()-&gt;pmStatsRecordApplicationResponse(
                        gIOPMStatsDriverPSChangeSlow,
                        fName, kDriverCallSetPowerState, NS_TO_MS(nsec), 0, NULL, fHeadNotePowerState);
                }
#<span class="enscript-reference">endif</span>
                OUR_PMLog(kPMLogDriverAcknowledgeSet, (uintptr_t) <span class="enscript-keyword">this</span>, fDriverTimer);
                fDriverTimer = 0;
                more = true;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// unexpected ack
</span>                OUR_PMLog(kPMLogAcknowledgeErr4, (uintptr_t) <span class="enscript-keyword">this</span>, 0);
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeInterestChanged</span>:
            handleInterestChanged( request );
            more = true;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeIdleCancel</span>:
            <span class="enscript-keyword">if</span> ((fMachineState == kIOPM_OurChangeTellClientsPowerDown)
             || (fMachineState == kIOPM_OurChangeTellUserPMPolicyPowerDown)
             || (fMachineState == kIOPM_OurChangeTellPriorityClientsPowerDown)
             || (fMachineState == kIOPM_SyncTellClientsPowerDown)
             || (fMachineState == kIOPM_SyncTellPriorityClientsPowerDown))
            {
                OUR_PMLog(kPMLogIdleCancel, (uintptr_t) <span class="enscript-keyword">this</span>, fMachineState);
                PM_LOG2(<span class="enscript-string">&quot;%s: cancel from machine state %d\n&quot;</span>,
                    getName(), fMachineState);
                fDoNotPowerDown = true;
                <span class="enscript-comment">// Stop waiting for app replys.
</span>                <span class="enscript-keyword">if</span> ((fMachineState == kIOPM_OurChangeTellPriorityClientsPowerDown) ||
                    (fMachineState == kIOPM_OurChangeTellUserPMPolicyPowerDown) ||
                    (fMachineState == kIOPM_SyncTellPriorityClientsPowerDown) ||
                    (fMachineState == kIOPM_SyncTellClientsPowerDown) )
                    cleanClientResponses(false);
                more = true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMRequestTypeChildNotifyDelayCancel</span>:
            <span class="enscript-keyword">if</span> (fMachineState == kIOPM_NotifyChildrenDelayed)
            {
                PM_LOG2(<span class="enscript-string">&quot;%s: delay notify cancelled\n&quot;</span>, getName());
                notifyChildrenDelayed();
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            panic(<span class="enscript-string">&quot;PMReplyQueue: unknown reply type %x&quot;</span>, request-&gt;getType());
    }

    more |= gIOPMCompletionQueue-&gt;queuePMRequest(request);
    <span class="enscript-keyword">if</span> (more)
        gIOPMWorkQueue-&gt;incrementProducerCount();

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] assertPMDriverCall / deassertPMDriverCall
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::assertPMDriverCall</span>(
    IOPMDriverCallEntry *   entry,
    IOOptionBits            options,
    IOPMinformee *          inform )
{
    IOService * target = 0;
    <span class="enscript-type">bool</span>        ok = false;

    <span class="enscript-keyword">if</span> (!initialized)
        <span class="enscript-keyword">return</span> false;

    PM_LOCK();

    <span class="enscript-keyword">if</span> (fLockedFlags.PMStop)
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }

    <span class="enscript-keyword">if</span> (((options &amp; kIOPMADC_NoInactiveCheck) == 0) &amp;&amp; isInactive())
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }

    <span class="enscript-keyword">if</span> (inform)
    {
        <span class="enscript-keyword">if</span> (!inform-&gt;active)
        {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        target = inform-&gt;whatObject;
        <span class="enscript-keyword">if</span> (target-&gt;isInactive())
        {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
    }

    entry-&gt;thread = current_thread();
    entry-&gt;target = target;
    queue_enter(&amp;fPMDriverCallQueue, entry, IOPMDriverCallEntry *, link);
    ok = true;

<span class="enscript-reference">fail</span>:
    PM_UNLOCK();

    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::deassertPMDriverCall</span>( IOPMDriverCallEntry * entry )
{
    <span class="enscript-type">bool</span> wakeup = false;

    PM_LOCK();

    assert( !queue_empty(&amp;fPMDriverCallQueue) );
    queue_remove(&amp;fPMDriverCallQueue, entry, IOPMDriverCallEntry *, link);
    <span class="enscript-keyword">if</span> (fLockedFlags.PMDriverCallWait)
    {
        wakeup = true;
    }

    PM_UNLOCK();

    <span class="enscript-keyword">if</span> (wakeup)
        PM_LOCK_WAKEUP(&amp;fPMDriverCallQueue);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::waitForPMDriverCall</span>( IOService * target )
{
    <span class="enscript-type">const</span> IOPMDriverCallEntry * entry;
    thread_t                    thread = current_thread();
    AbsoluteTime                deadline;
    <span class="enscript-type">int</span>                         waitResult;
    <span class="enscript-type">bool</span>                        log = true;
    <span class="enscript-type">bool</span>                        wait;

    <span class="enscript-keyword">do</span> {
        wait = false;
        queue_iterate(&amp;fPMDriverCallQueue, entry, <span class="enscript-type">const</span> IOPMDriverCallEntry *, link)
        {
            <span class="enscript-comment">// Target of interested driver call
</span>            <span class="enscript-keyword">if</span> (target &amp;&amp; (target != entry-&gt;target))
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> (entry-&gt;thread == thread)
            {
                <span class="enscript-keyword">if</span> (log)
                {
                    PM_LOG(<span class="enscript-string">&quot;%s: %s(%s) on PM thread\n&quot;</span>,
                        fName, __FUNCTION__, target ? target-&gt;getName() : <span class="enscript-string">&quot;&quot;</span>);
                    OSReportWithBacktrace(<span class="enscript-string">&quot;%s: %s(%s) on PM thread\n&quot;</span>,
                        fName, __FUNCTION__, target ? target-&gt;getName() : <span class="enscript-string">&quot;&quot;</span>);
                    log = false;
                }
                <span class="enscript-keyword">continue</span>;
            }

            wait = true;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (wait)
        {
            fLockedFlags.PMDriverCallWait = true;
            clock_interval_to_deadline(15, kSecondScale, &amp;deadline);
            waitResult = PM_LOCK_SLEEP(&amp;fPMDriverCallQueue, deadline);
            fLockedFlags.PMDriverCallWait = false;
            <span class="enscript-keyword">if</span> (THREAD_TIMED_OUT == waitResult)
            {
                PM_ERROR(<span class="enscript-string">&quot;%s: waitForPMDriverCall timeout\n&quot;</span>, fName);
                wait = false;
            }
        }
    } <span class="enscript-keyword">while</span> (wait);
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// [private] Debug helpers
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">IOService::getIOMessageString</span>( uint32_t msg )
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MSG_ENTRY</span>(x)    {(int) x, #x}

    <span class="enscript-type">static</span> <span class="enscript-type">const</span> IONamedValue msgNames[] = {
        MSG_ENTRY( kIOMessageCanDevicePowerOff      ),
        MSG_ENTRY( kIOMessageDeviceWillPowerOff     ),
        MSG_ENTRY( kIOMessageDeviceWillNotPowerOff  ),
        MSG_ENTRY( kIOMessageDeviceHasPoweredOn     ),
        MSG_ENTRY( kIOMessageCanSystemPowerOff      ),
        MSG_ENTRY( kIOMessageSystemWillPowerOff     ),
        MSG_ENTRY( kIOMessageSystemWillNotPowerOff  ),
        MSG_ENTRY( kIOMessageCanSystemSleep         ),
        MSG_ENTRY( kIOMessageSystemWillSleep        ),
        MSG_ENTRY( kIOMessageSystemWillNotSleep     ),
        MSG_ENTRY( kIOMessageSystemHasPoweredOn     ),
        MSG_ENTRY( kIOMessageSystemWillRestart      ),
        MSG_ENTRY( kIOMessageSystemWillPowerOn      ),
        MSG_ENTRY( kIOMessageSystemCapabilityChange ),
        MSG_ENTRY( kIOPMMessageLastCallBeforeSleep  )
    };

    <span class="enscript-keyword">return</span> IOFindNameForValue(msg, msgNames);
}


<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IOPMRequest
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// IOPMRequest Class
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Requests from PM clients, and also used for inter-object messaging within PM.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IOPMRequest, IOCommand );

IOPMRequest * <span class="enscript-function-name">IOPMRequest::create</span>( <span class="enscript-type">void</span> )
{
    IOPMRequest * me = OSTypeAlloc(IOPMRequest);
    <span class="enscript-keyword">if</span> (me &amp;&amp; !me-&gt;init(0, kIOPMRequestTypeInvalid))
    {
        me-&gt;release();
        me = 0;
    }
    <span class="enscript-keyword">return</span> me;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequest::init</span>( IOService * target, IOOptionBits type )
{
    <span class="enscript-keyword">if</span> (!IOCommand::init())
        <span class="enscript-keyword">return</span> false;

    fRequestType = type;
    fTarget = target;

    <span class="enscript-keyword">if</span> (fTarget)
        fTarget-&gt;retain();

    <span class="enscript-comment">// Root node and root domain requests does not prevent the power tree from
</span>    <span class="enscript-comment">// becoming quiescent.
</span>
    fIsQuiesceBlocker = ((fTarget != gIOPMRootNode) &amp;&amp;
                         (fTarget != IOService::getPMRootDomain()));

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMRequest::reset</span>( <span class="enscript-type">void</span> )
{
    assert( fWorkWaitCount == 0 );
    assert( fFreeWaitCount == 0 );

    detachNextRequest();
    detachRootRequest();

    <span class="enscript-keyword">if</span> (fCompletionAction &amp;&amp; (fRequestType == kIOPMRequestTypeQuiescePowerTree))
    {
        <span class="enscript-comment">// Call the completion on PM work loop context
</span>        fCompletionAction(fCompletionTarget, fCompletionParam);
        fCompletionAction = 0;
    }

    fRequestType = kIOPMRequestTypeInvalid;

    <span class="enscript-keyword">if</span> (fTarget)
    {
        fTarget-&gt;release();
        fTarget = 0;
    }
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequest::attachNextRequest</span>( IOPMRequest * next )
{
    <span class="enscript-type">bool</span> ok = false;

    <span class="enscript-keyword">if</span> (!fRequestNext)
    {
        <span class="enscript-comment">// Postpone the execution of the next request after
</span>        <span class="enscript-comment">// this request.
</span>        fRequestNext = next;
        fRequestNext-&gt;fWorkWaitCount++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_REQUEST_ATTACH</span>
        PM_LOG(<span class="enscript-string">&quot;Attached next: %p [0x%x] -&gt; %p [0x%x, %u] %s\n&quot;</span>,
            OBFUSCATE(<span class="enscript-keyword">this</span>), fRequestType, OBFUSCATE(fRequestNext),
            fRequestNext-&gt;fRequestType,
            (uint32_t) fRequestNext-&gt;fWorkWaitCount,
            fTarget-&gt;getName());
#<span class="enscript-reference">endif</span>
        ok = true;
    }
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequest::detachNextRequest</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">bool</span> ok = false;

    <span class="enscript-keyword">if</span> (fRequestNext)
    {
        assert(fRequestNext-&gt;fWorkWaitCount);
        <span class="enscript-keyword">if</span> (fRequestNext-&gt;fWorkWaitCount)
            fRequestNext-&gt;fWorkWaitCount--;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_REQUEST_ATTACH</span>
        PM_LOG(<span class="enscript-string">&quot;Detached next: %p [0x%x] -&gt; %p [0x%x, %u] %s\n&quot;</span>,
            OBFUSCATE(<span class="enscript-keyword">this</span>), fRequestType, OBFUSCATE(fRequestNext),
            fRequestNext-&gt;fRequestType,
            (uint32_t) fRequestNext-&gt;fWorkWaitCount,
            fTarget-&gt;getName());
#<span class="enscript-reference">endif</span>
        fRequestNext = 0;
        ok = true;
    }
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequest::attachRootRequest</span>( IOPMRequest * root )
{
    <span class="enscript-type">bool</span> ok = false;

    <span class="enscript-keyword">if</span> (!fRequestRoot)
    {
        <span class="enscript-comment">// Delay the completion of the root request after
</span>        <span class="enscript-comment">// this request.
</span>        fRequestRoot = root;
        fRequestRoot-&gt;fFreeWaitCount++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_REQUEST_ATTACH</span>
        PM_LOG(<span class="enscript-string">&quot;Attached root: %p [0x%x] -&gt; %p [0x%x, %u] %s\n&quot;</span>,
            OBFUSCATE(<span class="enscript-keyword">this</span>), (uint32_t) fType, OBFUSCATE(fRequestRoot),
            (uint32_t) fRequestRoot-&gt;fType,
            (uint32_t) fRequestRoot-&gt;fFreeWaitCount,
            fTarget-&gt;getName());
#<span class="enscript-reference">endif</span>
        ok = true;
    }
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequest::detachRootRequest</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">bool</span> ok = false;

    <span class="enscript-keyword">if</span> (fRequestRoot)
    {
        assert(fRequestRoot-&gt;fFreeWaitCount);
        <span class="enscript-keyword">if</span> (fRequestRoot-&gt;fFreeWaitCount)
            fRequestRoot-&gt;fFreeWaitCount--;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LOG_REQUEST_ATTACH</span>
        PM_LOG(<span class="enscript-string">&quot;Detached root: %p [0x%x] -&gt; %p [0x%x, %u] %s\n&quot;</span>,
            OBFUSCATE(<span class="enscript-keyword">this</span>), (uint32_t) fType, OBFUSCATE(fRequestRoot),
            (uint32_t) fRequestRoot-&gt;fType,
            (uint32_t) fRequestRoot-&gt;fFreeWaitCount,
            fTarget-&gt;getName());
#<span class="enscript-reference">endif</span>
        fRequestRoot = 0;
        ok = true;
    }
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IOPMRequestQueue
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// IOPMRequestQueue Class
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Global queues. Queues are created once and never released.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IOPMRequestQueue, IOEventSource );

IOPMRequestQueue * <span class="enscript-function-name">IOPMRequestQueue::create</span>( IOService * inOwner, Action inAction )
{
    IOPMRequestQueue * me = OSTypeAlloc(IOPMRequestQueue);
    <span class="enscript-keyword">if</span> (me &amp;&amp; !me-&gt;init(inOwner, inAction))
    {
        me-&gt;release();
        me = 0;
    }
    <span class="enscript-keyword">return</span> me;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequestQueue::init</span>( IOService * inOwner, Action inAction )
{
    <span class="enscript-keyword">if</span> (!inAction || !IOEventSource::init(inOwner, (IOEventSourceAction)inAction))
        <span class="enscript-keyword">return</span> false;

    queue_init(&amp;fQueue);
    fLock = IOLockAlloc();
    <span class="enscript-keyword">return</span> (fLock != 0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMRequestQueue::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (fLock)
    {
        IOLockFree(fLock);
        fLock = 0;
    }
    <span class="enscript-keyword">return</span> IOEventSource::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMRequestQueue::queuePMRequest</span>( IOPMRequest * request )
{
    assert(request);
    IOLockLock(fLock);
    queue_enter(&amp;fQueue, request, typeof(request), fCommandChain);
    IOLockUnlock(fLock);
    <span class="enscript-keyword">if</span> (workLoop) signalWorkAvailable();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOPMRequestQueue::queuePMRequestChain</span>( IOPMRequest ** requests, IOItemCount count )
{
    IOPMRequest * next;

    assert(requests &amp;&amp; count);
    IOLockLock(fLock);
    <span class="enscript-keyword">while</span> (count--)
    {
        next = *requests;
        requests++;
        queue_enter(&amp;fQueue, next, typeof(next), fCommandChain);
    }
    IOLockUnlock(fLock);
    <span class="enscript-keyword">if</span> (workLoop) signalWorkAvailable();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMRequestQueue::checkForWork</span>( <span class="enscript-type">void</span> )
{
    Action          dqAction = (Action) action;
    IOPMRequest *   request;
    IOService *     target;
    <span class="enscript-type">int</span>             dequeueCount = 0;
    <span class="enscript-type">bool</span>            more = false;

    IOLockLock( fLock );

    <span class="enscript-keyword">while</span> (!queue_empty(&amp;fQueue))
    {
        <span class="enscript-keyword">if</span> (dequeueCount++ &gt;= kMaxDequeueCount)
        {
            <span class="enscript-comment">// Allow other queues a chance to work
</span>            more = true;
            <span class="enscript-keyword">break</span>;
        }
    
        queue_remove_first(&amp;fQueue, request, typeof(request), fCommandChain);
        IOLockUnlock(fLock);
        target = request-&gt;getTarget();
        assert(target);
        more |= (*dqAction)( target, request, <span class="enscript-keyword">this</span> );
        IOLockLock( fLock );
    }

    IOLockUnlock( fLock );
    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IOPMWorkQueue
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// IOPMWorkQueue Class
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Queue of IOServicePM objects, each with a queue of IOPMRequest sharing the
</span><span class="enscript-comment">// same target.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IOPMWorkQueue, IOEventSource );

IOPMWorkQueue *
<span class="enscript-function-name">IOPMWorkQueue::create</span>( IOService * inOwner, Action invoke, Action retire )
{
    IOPMWorkQueue * me = OSTypeAlloc(IOPMWorkQueue);
    <span class="enscript-keyword">if</span> (me &amp;&amp; !me-&gt;init(inOwner, invoke, retire))
    {
        me-&gt;release();
        me = 0;
    }
    <span class="enscript-keyword">return</span> me;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMWorkQueue::init</span>( IOService * inOwner, Action invoke, Action retire )
{
    <span class="enscript-keyword">if</span> (!invoke || !retire ||
        !IOEventSource::init(inOwner, (IOEventSourceAction)0))
        <span class="enscript-keyword">return</span> false;

    queue_init(&amp;fWorkQueue);

    fInvokeAction  = invoke;
    fRetireAction  = retire;
    fConsumerCount = fProducerCount = 0;

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMWorkQueue::queuePMRequest</span>( IOPMRequest * request, IOServicePM * pwrMgt )
{
    queue_head_t *  requestQueue;
    <span class="enscript-type">bool</span>            more  = false;
    <span class="enscript-type">bool</span>            empty;

    assert( request );
    assert( pwrMgt );
    assert( onThread() );
    assert( queue_next(&amp;request-&gt;fCommandChain) ==
            queue_prev(&amp;request-&gt;fCommandChain) );

    gIOPMBusyRequestCount++;

    <span class="enscript-keyword">if</span> (request-&gt;isQuiesceType())
    {
        <span class="enscript-keyword">if</span> ((request-&gt;getTarget() == gIOPMRootNode) &amp;&amp; !fQuiesceStartTime)
        {
            <span class="enscript-comment">// Attach new quiesce request to all quiesce blockers in the queue
</span>            fQuiesceStartTime = mach_absolute_time();
            attachQuiesceRequest(request);
            fQuiesceRequest = request;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fQuiesceRequest &amp;&amp; request-&gt;isQuiesceBlocker())
    {
        <span class="enscript-comment">// Attach the new quiesce blocker to the blocked quiesce request
</span>        request-&gt;attachNextRequest(fQuiesceRequest);
    }

    <span class="enscript-comment">// Add new request to the tail of the per-service request queue.
</span>    <span class="enscript-comment">// Then immediately check the request queue to minimize latency
</span>    <span class="enscript-comment">// if the queue was empty.
</span>
    requestQueue = &amp;pwrMgt-&gt;RequestHead;
    empty = queue_empty(requestQueue);
    queue_enter(requestQueue, request, typeof(request), fCommandChain);
    <span class="enscript-keyword">if</span> (empty)
    {
        more = checkRequestQueue(requestQueue, &amp;empty);
        <span class="enscript-keyword">if</span> (!empty)
        {
            <span class="enscript-comment">// Request just added is blocked, add its target IOServicePM
</span>            <span class="enscript-comment">// to the work queue.
</span>            assert( queue_next(&amp;pwrMgt-&gt;WorkChain) ==
                    queue_prev(&amp;pwrMgt-&gt;WorkChain) );

            queue_enter(&amp;fWorkQueue, pwrMgt, typeof(pwrMgt), WorkChain);
            fQueueLength++;
            PM_LOG3(<span class="enscript-string">&quot;IOPMWorkQueue: [%u] added %s@%p to queue\n&quot;</span>,
                fQueueLength, pwrMgt-&gt;Name, OBFUSCATE(pwrMgt));
        }
    }

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMWorkQueue::checkRequestQueue</span>( queue_head_t * requestQueue, <span class="enscript-type">bool</span> * empty )
{
    IOPMRequest *   request;
    IOService *     target;
    <span class="enscript-type">bool</span>            more = false;
    <span class="enscript-type">bool</span>            done = false;

    assert(!queue_empty(requestQueue));
    <span class="enscript-keyword">do</span> {
        request = (typeof(request)) queue_first(requestQueue);
        <span class="enscript-keyword">if</span> (request-&gt;isWorkBlocked())
            <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// request dispatch blocked on attached request
</span>
        target = request-&gt;getTarget();
        <span class="enscript-keyword">if</span> (fInvokeAction)
        {
            done = (*fInvokeAction)( target, request, <span class="enscript-keyword">this</span> );
        }
        <span class="enscript-keyword">else</span>
        {
            PM_LOG(<span class="enscript-string">&quot;PM request 0x%x dropped\n&quot;</span>, request-&gt;getType());
            done = true;
        }
        <span class="enscript-keyword">if</span> (!done)
            <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// PM state machine blocked
</span>
        assert(gIOPMBusyRequestCount &gt; 0);
        <span class="enscript-keyword">if</span> (gIOPMBusyRequestCount)
            gIOPMBusyRequestCount--;

        <span class="enscript-keyword">if</span> (request == fQuiesceRequest)
        {
            fQuiesceRequest = 0;
        }

        queue_remove_first(requestQueue, request, typeof(request), fCommandChain);
        more |= (*fRetireAction)( target, request, <span class="enscript-keyword">this</span> );
        done = queue_empty(requestQueue);
    } <span class="enscript-keyword">while</span> (!done);

    *empty = done;

    <span class="enscript-keyword">if</span> (more)
    {
        <span class="enscript-comment">// Retired a request that may unblock a previously visited request
</span>        <span class="enscript-comment">// that is still waiting on the work queue. Must trigger another
</span>        <span class="enscript-comment">// queue check.
</span>        fProducerCount++;
    }

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMWorkQueue::checkForWork</span>( <span class="enscript-type">void</span> )
{
    IOServicePM *   entry;
    IOServicePM *   next;
    <span class="enscript-type">bool</span>            more = false;
    <span class="enscript-type">bool</span>            empty;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">WORK_QUEUE_STATS</span>
    fStatCheckForWork++;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Iterate over all IOServicePM entries in the work queue,
</span>    <span class="enscript-comment">// and check each entry's request queue.
</span>
    <span class="enscript-keyword">while</span> (fConsumerCount != fProducerCount)
    {
        PM_LOG3(<span class="enscript-string">&quot;IOPMWorkQueue: checkForWork %u %u\n&quot;</span>,
            fProducerCount, fConsumerCount);

        fConsumerCount = fProducerCount;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">WORK_QUEUE_STATS</span>
        <span class="enscript-keyword">if</span> (queue_empty(&amp;fWorkQueue))
        {
            fStatQueueEmpty++;
            <span class="enscript-keyword">break</span>;
        }
        fStatScanEntries++;
        uint32_t cachedWorkCount = gIOPMWorkInvokeCount;
#<span class="enscript-reference">endif</span>

        __IGNORE_WCASTALIGN(entry = (typeof(entry)) queue_first(&amp;fWorkQueue));
        <span class="enscript-keyword">while</span> (!queue_end(&amp;fWorkQueue, (queue_entry_t) entry))
        {
            more |= checkRequestQueue(&amp;entry-&gt;RequestHead, &amp;empty);

            <span class="enscript-comment">// Get next entry, points to head if current entry is last.
</span>            __IGNORE_WCASTALIGN(next = (typeof(next)) queue_next(&amp;entry-&gt;WorkChain));

            <span class="enscript-comment">// if request queue is empty, remove IOServicePM from work queue.
</span>            <span class="enscript-keyword">if</span> (empty)
            {
                assert(fQueueLength);
                <span class="enscript-keyword">if</span> (fQueueLength) fQueueLength--;
                PM_LOG3(<span class="enscript-string">&quot;IOPMWorkQueue: [%u] removed %s@%p from queue\n&quot;</span>,
                    fQueueLength, entry-&gt;Name, OBFUSCATE(entry));
                queue_remove(&amp;fWorkQueue, entry, typeof(entry), WorkChain);
            }
            entry = next;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">WORK_QUEUE_STATS</span>
        <span class="enscript-keyword">if</span> (cachedWorkCount == gIOPMWorkInvokeCount)
            fStatNoWorkDone++;
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMWorkQueue::signalWorkAvailable</span>( <span class="enscript-type">void</span> )
{
    fProducerCount++;
    <span class="enscript-reference">IOEventSource</span>::signalWorkAvailable();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMWorkQueue::incrementProducerCount</span>( <span class="enscript-type">void</span> )
{
    fProducerCount++;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMWorkQueue::attachQuiesceRequest</span>( IOPMRequest * quiesceRequest )
{
    IOServicePM *   entry;
    IOPMRequest *   request;

    <span class="enscript-keyword">if</span> (queue_empty(&amp;fWorkQueue))
    {
        <span class="enscript-keyword">return</span>;
    }

    queue_iterate(&amp;fWorkQueue, entry, typeof(entry), WorkChain)
    {
        queue_iterate(&amp;entry-&gt;RequestHead, request, typeof(request), fCommandChain)
        {
            <span class="enscript-comment">// Attach the quiesce request to any request in the queue that
</span>            <span class="enscript-comment">// is not linked to a next request. These requests will block
</span>            <span class="enscript-comment">// the quiesce request.
</span>            
            <span class="enscript-keyword">if</span> (request-&gt;isQuiesceBlocker())
            {
                request-&gt;attachNextRequest(quiesceRequest);
            }
        }
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMWorkQueue::finishQuiesceRequest</span>( IOPMRequest * quiesceRequest )
{
    <span class="enscript-keyword">if</span> (fQuiesceRequest &amp;&amp; (quiesceRequest == fQuiesceRequest) &amp;&amp;
        (fQuiesceStartTime != 0))
    {
        fInvokeAction = 0;
        fQuiesceFinishTime = mach_absolute_time();
    }
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IOPMCompletionQueue
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// IOPMCompletionQueue Class
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IOPMCompletionQueue, IOEventSource );

IOPMCompletionQueue *
<span class="enscript-function-name">IOPMCompletionQueue::create</span>( IOService * inOwner, Action inAction )
{
    IOPMCompletionQueue * me = OSTypeAlloc(IOPMCompletionQueue);
    <span class="enscript-keyword">if</span> (me &amp;&amp; !me-&gt;init(inOwner, inAction))
    {
        me-&gt;release();
        me = 0;
    }
    <span class="enscript-keyword">return</span> me;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMCompletionQueue::init</span>( IOService * inOwner, Action inAction )
{
    <span class="enscript-keyword">if</span> (!inAction || !IOEventSource::init(inOwner, (IOEventSourceAction)inAction))
        <span class="enscript-keyword">return</span> false;

    queue_init(&amp;fQueue);
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMCompletionQueue::queuePMRequest</span>( IOPMRequest * request )
{
    <span class="enscript-type">bool</span> more;

    assert(request);
    <span class="enscript-comment">// unblock dependent request
</span>    more = request-&gt;detachNextRequest();
    queue_enter(&amp;fQueue, request, typeof(request), fCommandChain);
    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMCompletionQueue::checkForWork</span>( <span class="enscript-type">void</span> )
{
    Action          dqAction = (Action) action;
    IOPMRequest *   request;
    IOPMRequest *   next;
    IOService *     target;
    <span class="enscript-type">bool</span>            more = false;

    request = (typeof(request)) queue_first(&amp;fQueue);
    <span class="enscript-keyword">while</span> (!queue_end(&amp;fQueue, (queue_entry_t) request))
    {
        next = (typeof(next)) queue_next(&amp;request-&gt;fCommandChain);
        <span class="enscript-keyword">if</span> (!request-&gt;isFreeBlocked())
        {
            queue_remove(&amp;fQueue, request, typeof(request), fCommandChain);
            target = request-&gt;getTarget();
            assert(target);
            more |= (*dqAction)( target, request, <span class="enscript-keyword">this</span> );
        }
        request = next;
    }

    <span class="enscript-keyword">return</span> more;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IOServicePM
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOServicePM, OSObject)

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// serialize
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Serialize IOServicePM for debugging.
</span><span class="enscript-comment">//*********************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">setPMProperty</span>( OSDictionary * dict, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, uint64_t value )
{
    OSNumber * num = OSNumber::withNumber(value, <span class="enscript-keyword">sizeof</span>(value) * 8);
    <span class="enscript-keyword">if</span> (num)
    {
        dict-&gt;setObject(key, num);
        num-&gt;release();
    }
}

IOReturn <span class="enscript-function-name">IOServicePM::gatedSerialize</span>( OSSerialize * s  ) <span class="enscript-type">const</span>
{
    OSDictionary *  dict;
    <span class="enscript-type">bool</span>            ok = false;
    <span class="enscript-type">int</span>             powerClamp = -1;
    <span class="enscript-type">int</span>             dictSize = 6;

    <span class="enscript-keyword">if</span> (IdleTimerPeriod)
        dictSize += 4;

    <span class="enscript-keyword">if</span> (PMActions.parameter &amp; kPMActionsFlagLimitPower)
    {
        dictSize += 1;
        powerClamp = 0;
        <span class="enscript-keyword">if</span> (PMActions.parameter &amp;
            (kPMActionsFlagIsDisplayWrangler | kPMActionsFlagIsGraphicsDevice))
            powerClamp++;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">WORK_QUEUE_STATS</span>
    <span class="enscript-keyword">if</span> (gIOPMRootNode == ControllingDriver)
        dictSize += 4;
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (PowerClients)
        dict = OSDictionary::withDictionary(
            PowerClients, PowerClients-&gt;getCount() + dictSize);
    <span class="enscript-keyword">else</span>
        dict = OSDictionary::withCapacity(dictSize);

    <span class="enscript-keyword">if</span> (dict)
    {
        setPMProperty(dict, <span class="enscript-string">&quot;CurrentPowerState&quot;</span>, CurrentPowerState);
        setPMProperty(dict, <span class="enscript-string">&quot;CapabilityFlags&quot;</span>, CurrentCapabilityFlags);
        <span class="enscript-keyword">if</span> (NumberOfPowerStates)
            setPMProperty(dict, <span class="enscript-string">&quot;MaxPowerState&quot;</span>, NumberOfPowerStates-1);
        <span class="enscript-keyword">if</span> (DesiredPowerState != CurrentPowerState)
            setPMProperty(dict, <span class="enscript-string">&quot;DesiredPowerState&quot;</span>, DesiredPowerState);
        <span class="enscript-keyword">if</span> (kIOPM_Finished != MachineState)
            setPMProperty(dict, <span class="enscript-string">&quot;MachineState&quot;</span>, MachineState);
        <span class="enscript-keyword">if</span> (DeviceOverrideEnabled)
            dict-&gt;setObject(<span class="enscript-string">&quot;PowerOverrideOn&quot;</span>, kOSBooleanTrue);
        <span class="enscript-keyword">if</span> (powerClamp &gt;= 0)
            setPMProperty(dict, <span class="enscript-string">&quot;PowerClamp&quot;</span>, powerClamp);

        <span class="enscript-keyword">if</span> (IdleTimerPeriod)
        {
            AbsoluteTime    now;
            AbsoluteTime    delta;
            uint64_t        nsecs;

            clock_get_uptime(&amp;now);

            <span class="enscript-comment">// The idle timer period in milliseconds
</span>            setPMProperty(dict, <span class="enscript-string">&quot;IdleTimerPeriod&quot;</span>, NextIdleTimerPeriod * 1000ULL);

            <span class="enscript-comment">// Number of tickles since the last idle timer expiration
</span>            setPMProperty(dict, <span class="enscript-string">&quot;ActivityTickles&quot;</span>, ActivityTickleCount);

            <span class="enscript-keyword">if</span> (AbsoluteTime_to_scalar(&amp;DeviceActiveTimestamp))
            {
                <span class="enscript-comment">// Milliseconds since the last activity tickle
</span>                delta = now;
                SUB_ABSOLUTETIME(&amp;delta, &amp;DeviceActiveTimestamp);
                absolutetime_to_nanoseconds(delta, &amp;nsecs);
                setPMProperty(dict, <span class="enscript-string">&quot;TimeSinceLastTickle&quot;</span>, NS_TO_MS(nsecs));
            }

            <span class="enscript-keyword">if</span> (!IdleTimerStopped &amp;&amp; AbsoluteTime_to_scalar(&amp;IdleTimerStartTime))
            {
                <span class="enscript-comment">// Idle timer elapsed time in milliseconds
</span>                delta = now;
                SUB_ABSOLUTETIME(&amp;delta, &amp;IdleTimerStartTime);
                absolutetime_to_nanoseconds(delta, &amp;nsecs);
                setPMProperty(dict, <span class="enscript-string">&quot;IdleTimerElapsedTime&quot;</span>, NS_TO_MS(nsecs));
            }
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">WORK_QUEUE_STATS</span>
        <span class="enscript-keyword">if</span> (gIOPMRootNode == Owner)
        {
            setPMProperty(dict, <span class="enscript-string">&quot;WQ-CheckForWork&quot;</span>,
                gIOPMWorkQueue-&gt;fStatCheckForWork);
            setPMProperty(dict, <span class="enscript-string">&quot;WQ-ScanEntries&quot;</span>,
                gIOPMWorkQueue-&gt;fStatScanEntries);
            setPMProperty(dict, <span class="enscript-string">&quot;WQ-QueueEmpty&quot;</span>,
                gIOPMWorkQueue-&gt;fStatQueueEmpty);
            setPMProperty(dict, <span class="enscript-string">&quot;WQ-NoWorkDone&quot;</span>,
                gIOPMWorkQueue-&gt;fStatNoWorkDone);
        }
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">if</span> (HasAdvisoryDesire &amp;&amp; !gIOPMAdvisoryTickleEnabled)
        {
            <span class="enscript-comment">// Don't report advisory tickle when it has no influence
</span>            dict-&gt;removeObject(gIOPMPowerClientAdvisoryTickle);
        }

        ok = dict-&gt;serialize(s);
        dict-&gt;release();
    }

    <span class="enscript-keyword">return</span> (ok ? kIOReturnSuccess : kIOReturnNoMemory);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOServicePM::serialize</span>( OSSerialize * s ) <span class="enscript-type">const</span>
{
    IOReturn ret = kIOReturnNotReady;

    <span class="enscript-keyword">if</span> (gIOPMWatchDogThread == current_thread())
    {
       <span class="enscript-comment">// Calling without lock as this data is collected for debug purpose, before reboot.
</span>       <span class="enscript-comment">// The workloop is probably already hung in state machine.
</span>       ret = gatedSerialize(s);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gIOPMWorkLoop)
    {
        ret = gIOPMWorkLoop-&gt;runAction(
            OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>, &amp;IOServicePM::gatedSerialize),
            (OSObject *) <span class="enscript-keyword">this</span>, (<span class="enscript-type">void</span> *) s);
    }

    <span class="enscript-keyword">return</span> (kIOReturnSuccess == ret);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOServicePM::pmPrint</span>(
    uint32_t        event,
    uintptr_t       param1,
    uintptr_t       param2 ) <span class="enscript-type">const</span>
{
    gPlatform-&gt;PMLog(Name, event, param1, param2);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOServicePM::pmTrace</span>(
    uint32_t        event,
    uintptr_t       param1,
    uintptr_t       param2 ) <span class="enscript-type">const</span>
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *  who = Name;
    uint64_t    regId = Owner-&gt;getRegistryEntryID();
    uintptr_t    name = 0;

    <span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t sStartStopBitField[] =
    { 0x00000000, 0x00000040 }; <span class="enscript-comment">// Only Program Hardware so far
</span>
    <span class="enscript-comment">// Arcane formula from Hacker's Delight by Warren
</span>    <span class="enscript-comment">// abs(x)  = ((int) x &gt;&gt; 31) ^ (x + ((int) x &gt;&gt; 31))
</span>    uint32_t sgnevent = ((<span class="enscript-type">int</span>) event &gt;&gt; 31);
    uint32_t absevent = sgnevent ^ (event + sgnevent);
    uint32_t code     = IODBG_POWER(absevent);

    uint32_t bit = 1 &lt;&lt; (absevent &amp; 0x1f);
    <span class="enscript-keyword">if</span> ((absevent &lt; (<span class="enscript-keyword">sizeof</span>(sStartStopBitField) * 8)) &amp;&amp;
        (sStartStopBitField[absevent &gt;&gt; 5] &amp; bit))
    {
        <span class="enscript-comment">// Or in the START or END bits, Start = 1 &amp; END = 2
</span>        <span class="enscript-comment">//      If sgnevent ==  0 then START -  0 =&gt; START
</span>        <span class="enscript-comment">// else if sgnevent == -1 then START - -1 =&gt; END
</span>        code |= DBG_FUNC_START - sgnevent;
    }

    <span class="enscript-comment">// Copy the first characters of the name into an uintptr_t
</span>    <span class="enscript-keyword">for</span> (uint32_t i = 0; (i &lt; <span class="enscript-keyword">sizeof</span>(uintptr_t) &amp;&amp; who[i] != 0); i++)
    {
        ((<span class="enscript-type">char</span> *) &amp;name)[<span class="enscript-keyword">sizeof</span>(uintptr_t) - i - 1] = who[i];
    }

    IOTimeStampConstant(code, name, (uintptr_t) regId, param1, param2);
}

</pre>
<hr />
</body></html>