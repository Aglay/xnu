<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOSharedDataQueue.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOSharedDataQueue.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOSharedDataQueue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODataQueueShared.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">enqueue</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">enqueue</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">dequeue</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">dequeue</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IODataQueue

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOSharedDataQueue, IODataQueue)

IOSharedDataQueue *<span class="enscript-function-name">IOSharedDataQueue::withCapacity</span>(UInt32 size)
{
    IOSharedDataQueue *dataQueue = <span class="enscript-keyword">new</span> IOSharedDataQueue;

    <span class="enscript-keyword">if</span> (dataQueue) {
        <span class="enscript-keyword">if</span>  (!dataQueue-&gt;initWithCapacity(size)) {
            dataQueue-&gt;release();
            dataQueue = 0;
        }
    }

    <span class="enscript-keyword">return</span> dataQueue;
}

IOSharedDataQueue *<span class="enscript-function-name">IOSharedDataQueue::withEntries</span>(UInt32 numEntries, UInt32 entrySize)
{
    IOSharedDataQueue *dataQueue = <span class="enscript-keyword">new</span> IOSharedDataQueue;

    <span class="enscript-keyword">if</span> (dataQueue) {
        <span class="enscript-keyword">if</span> (!dataQueue-&gt;initWithEntries(numEntries, entrySize)) {
            dataQueue-&gt;release();
            dataQueue = 0;
        }
    }

    <span class="enscript-keyword">return</span> dataQueue;
}

Boolean <span class="enscript-function-name">IOSharedDataQueue::initWithCapacity</span>(UInt32 size)
{
    IODataQueueAppendix *   appendix;
    vm_size_t               allocSize;

    <span class="enscript-keyword">if</span> (!super::init()) {
        <span class="enscript-keyword">return</span> false;
    }

    _reserved = (ExpansionData *)IOMalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ExpansionData));
    <span class="enscript-keyword">if</span> (!_reserved) {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> (size &gt; UINT32_MAX - DATA_QUEUE_MEMORY_HEADER_SIZE - DATA_QUEUE_MEMORY_APPENDIX_SIZE) {
        <span class="enscript-keyword">return</span> false;
    }
    
    allocSize = round_page(size + DATA_QUEUE_MEMORY_HEADER_SIZE + DATA_QUEUE_MEMORY_APPENDIX_SIZE);

    <span class="enscript-keyword">if</span> (allocSize &lt; size) {
        <span class="enscript-keyword">return</span> false;
    }

    dataQueue = (IODataQueueMemory *)IOMallocAligned(allocSize, PAGE_SIZE);
    <span class="enscript-keyword">if</span> (dataQueue == 0) {
        <span class="enscript-keyword">return</span> false;
    }
    bzero(dataQueue, allocSize);

    dataQueue-&gt;queueSize    = size;
<span class="enscript-comment">//  dataQueue-&gt;head         = 0;
</span><span class="enscript-comment">//  dataQueue-&gt;tail         = 0;
</span>
    <span class="enscript-keyword">if</span> (!setQueueSize(size)) {
        <span class="enscript-keyword">return</span> false;
    }
    
    appendix            = (IODataQueueAppendix *)((UInt8 *)dataQueue + size + DATA_QUEUE_MEMORY_HEADER_SIZE);
    appendix-&gt;version   = 0;

    <span class="enscript-keyword">if</span> (!notifyMsg) {
        notifyMsg = IOMalloc(<span class="enscript-keyword">sizeof</span>(mach_msg_header_t));
        <span class="enscript-keyword">if</span> (!notifyMsg)
            <span class="enscript-keyword">return</span> false;
    }
    bzero(notifyMsg, <span class="enscript-keyword">sizeof</span>(mach_msg_header_t));

    setNotificationPort(MACH_PORT_NULL);

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOSharedDataQueue::free</span>()
{
    <span class="enscript-keyword">if</span> (dataQueue) {
        IOFreeAligned(dataQueue, round_page(getQueueSize() + DATA_QUEUE_MEMORY_HEADER_SIZE + DATA_QUEUE_MEMORY_APPENDIX_SIZE));
        dataQueue = NULL;
        <span class="enscript-keyword">if</span> (notifyMsg) {
            IOFree(notifyMsg, <span class="enscript-keyword">sizeof</span>(mach_msg_header_t));
            notifyMsg = NULL;
        }
    }

    <span class="enscript-keyword">if</span> (_reserved) {
        IOFree (_reserved, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ExpansionData));
        _reserved = NULL;
    } 
    
    <span class="enscript-reference">super</span>::free();
}

IOMemoryDescriptor *<span class="enscript-function-name">IOSharedDataQueue::getMemoryDescriptor</span>()
{
    IOMemoryDescriptor *descriptor = 0;

    <span class="enscript-keyword">if</span> (dataQueue != 0) {
        descriptor = IOMemoryDescriptor::withAddress(dataQueue, getQueueSize() + DATA_QUEUE_MEMORY_HEADER_SIZE + DATA_QUEUE_MEMORY_APPENDIX_SIZE, kIODirectionOutIn);
    }

    <span class="enscript-keyword">return</span> descriptor;
}


IODataQueueEntry * <span class="enscript-function-name">IOSharedDataQueue::peek</span>()
{
    IODataQueueEntry *entry = 0;

    <span class="enscript-keyword">if</span> (dataQueue &amp;&amp; (dataQueue-&gt;head != dataQueue-&gt;tail)) {
        IODataQueueEntry *  head        = 0;
        UInt32              headSize    = 0;
        UInt32              headOffset  = dataQueue-&gt;head;
        UInt32              queueSize   = getQueueSize();
        
        <span class="enscript-keyword">if</span> (headOffset &gt;= queueSize) {
            <span class="enscript-keyword">return</span> NULL;
        }
        
        head         = (IODataQueueEntry *)((<span class="enscript-type">char</span> *)dataQueue-&gt;queue + headOffset);
        headSize     = head-&gt;size;
        
        <span class="enscript-comment">// Check if there's enough room before the end of the queue for a header.
</span>        <span class="enscript-comment">// If there is room, check if there's enough room to hold the header and
</span>        <span class="enscript-comment">// the data.
</span>        
        <span class="enscript-keyword">if</span> ((headOffset &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) ||
            (headOffset + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; queueSize) ||
            (headOffset + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; UINT32_MAX - headSize) ||
            (headOffset + headSize + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; queueSize)) {
            <span class="enscript-comment">// No room for the header or the data, wrap to the beginning of the queue.
</span>            <span class="enscript-comment">// Note: wrapping even with the UINT32_MAX checks, as we have to support
</span>            <span class="enscript-comment">// queueSize of UINT32_MAX
</span>            entry = dataQueue-&gt;queue;
        } <span class="enscript-keyword">else</span> {
            entry = head;
        }
    }

    <span class="enscript-keyword">return</span> entry;
}

Boolean <span class="enscript-function-name">IOSharedDataQueue::enqueue</span>(<span class="enscript-type">void</span> * data, UInt32 dataSize)
{
    <span class="enscript-type">const</span> UInt32       head      = dataQueue-&gt;head;  <span class="enscript-comment">// volatile
</span>    <span class="enscript-type">const</span> UInt32       tail      = dataQueue-&gt;tail;
    <span class="enscript-type">const</span> UInt32       entrySize = dataSize + DATA_QUEUE_ENTRY_HEADER_SIZE;
    IODataQueueEntry * entry;
    
    <span class="enscript-comment">// Check for overflow of entrySize
</span>    <span class="enscript-keyword">if</span> (dataSize &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) {
        <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-comment">// Check for underflow of (getQueueSize() - tail)
</span>    <span class="enscript-keyword">if</span> (getQueueSize() &lt; tail || getQueueSize() &lt; head) {
        <span class="enscript-keyword">return</span> false;
    }
    
    <span class="enscript-keyword">if</span> ( tail &gt;= head )
    {
        <span class="enscript-comment">// Is there enough room at the end for the entry?
</span>        <span class="enscript-keyword">if</span> ((entrySize &lt;= UINT32_MAX - tail) &amp;&amp;
            ((tail + entrySize) &lt;= getQueueSize()) )
        {
            entry = (IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail);
            
            entry-&gt;size = dataSize;
            memcpy(&amp;entry-&gt;data, data, dataSize);
            
            <span class="enscript-comment">// The tail can be out of bound when the size of the new entry
</span>            <span class="enscript-comment">// exactly matches the available space at the end of the queue.
</span>            <span class="enscript-comment">// The tail can range from 0 to dataQueue-&gt;queueSize inclusive.
</span>            
            OSAddAtomic(entrySize, (SInt32 *)&amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( head &gt; entrySize )     <span class="enscript-comment">// Is there enough room at the beginning?
</span>        {
            <span class="enscript-comment">// Wrap around to the beginning, but do not allow the tail to catch
</span>            <span class="enscript-comment">// up to the head.
</span>            
            dataQueue-&gt;queue-&gt;size = dataSize;
            
            <span class="enscript-comment">// We need to make sure that there is enough room to set the size before
</span>            <span class="enscript-comment">// doing this. The user client checks for this and will look for the size
</span>            <span class="enscript-comment">// at the beginning if there isn't room for it at the end.
</span>            
            <span class="enscript-keyword">if</span> ( ( getQueueSize() - tail ) &gt;= DATA_QUEUE_ENTRY_HEADER_SIZE )
            {
                ((IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail))-&gt;size = dataSize;
            }
            
            memcpy(&amp;dataQueue-&gt;queue-&gt;data, data, dataSize);
            OSCompareAndSwap(dataQueue-&gt;tail, entrySize, &amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> false;    <span class="enscript-comment">// queue is full
</span>        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Do not allow the tail to catch up to the head when the queue is full.
</span>        <span class="enscript-comment">// That's why the comparison uses a '&gt;' rather than '&gt;='.
</span>        
        <span class="enscript-keyword">if</span> ( (head - tail) &gt; entrySize )
        {
            entry = (IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail);
            
            entry-&gt;size = dataSize;
            memcpy(&amp;entry-&gt;data, data, dataSize);
            OSAddAtomic(entrySize, (SInt32 *)&amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> false;    <span class="enscript-comment">// queue is full
</span>        }
    }
    
    <span class="enscript-comment">// Send notification (via mach message) that data is available.
</span>    
    <span class="enscript-keyword">if</span> ( ( head == tail )                                                   <span class="enscript-comment">/* queue was empty prior to enqueue() */</span>
        ||   ( dataQueue-&gt;head == tail ) )   <span class="enscript-comment">/* queue was emptied during enqueue() */</span>
    {
        sendDataAvailableNotification();
    }
    
    <span class="enscript-keyword">return</span> true;
}

Boolean <span class="enscript-function-name">IOSharedDataQueue::dequeue</span>(<span class="enscript-type">void</span> *data, UInt32 *dataSize)
{
    Boolean             retVal          = TRUE;
    IODataQueueEntry *  entry           = 0;
    UInt32              entrySize       = 0;
    UInt32              newHeadOffset   = 0;

    <span class="enscript-keyword">if</span> (dataQueue) {
        <span class="enscript-keyword">if</span> (dataQueue-&gt;head != dataQueue-&gt;tail) {
            IODataQueueEntry *  head        = 0;
            UInt32              headSize    = 0;
            UInt32              headOffset  = dataQueue-&gt;head;
            UInt32              queueSize   = getQueueSize();
            
            <span class="enscript-keyword">if</span> (headOffset &gt; queueSize) {
                <span class="enscript-keyword">return</span> false;
            }
            
            head         = (IODataQueueEntry *)((<span class="enscript-type">char</span> *)dataQueue-&gt;queue + headOffset);
            headSize     = head-&gt;size;
            
            <span class="enscript-comment">// we wrapped around to beginning, so read from there
</span>            <span class="enscript-comment">// either there was not even room for the header
</span>            <span class="enscript-keyword">if</span> ((headOffset &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) ||
                (headOffset + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; queueSize) ||
                <span class="enscript-comment">// or there was room for the header, but not for the data
</span>                (headOffset + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; UINT32_MAX - headSize) ||
                (headOffset + headSize + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; queueSize)) {
                <span class="enscript-comment">// Note: we have to wrap to the beginning even with the UINT32_MAX checks
</span>                <span class="enscript-comment">// because we have to support a queueSize of UINT32_MAX.
</span>                entry           = dataQueue-&gt;queue;
                entrySize       = entry-&gt;size;
                <span class="enscript-keyword">if</span> ((entrySize &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) ||
                    (entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; queueSize)) {
                    <span class="enscript-keyword">return</span> false;
                }
                newHeadOffset   = entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE;
                <span class="enscript-comment">// else it is at the end
</span>            } <span class="enscript-keyword">else</span> {
                entry           = head;
                entrySize       = entry-&gt;size;
                <span class="enscript-keyword">if</span> ((entrySize &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) ||
                    (entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; UINT32_MAX - headOffset) ||
                    (entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE + headOffset &gt; queueSize)) {
                    <span class="enscript-keyword">return</span> false;
                }
                newHeadOffset   = headOffset + entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE;
            }
        }
        
        <span class="enscript-keyword">if</span> (entry) {
            <span class="enscript-keyword">if</span> (data) {
                <span class="enscript-keyword">if</span> (dataSize) {
                    <span class="enscript-keyword">if</span> (entrySize &lt;= *dataSize) {
                        memcpy(data, &amp;(entry-&gt;data), entrySize);
                        OSCompareAndSwap( dataQueue-&gt;head, newHeadOffset, (SInt32 *)&amp;dataQueue-&gt;head);
                    } <span class="enscript-keyword">else</span> {
                        retVal = FALSE;
                    }
                } <span class="enscript-keyword">else</span> {
                    retVal = FALSE;
                }
            } <span class="enscript-keyword">else</span> {
                OSCompareAndSwap( dataQueue-&gt;head, newHeadOffset, (SInt32 *)&amp;dataQueue-&gt;head);
            }

            <span class="enscript-keyword">if</span> (dataSize) {
                *dataSize = entrySize;
            }
        } <span class="enscript-keyword">else</span> {
            retVal = FALSE;
        }
    } <span class="enscript-keyword">else</span> {
        retVal = FALSE;
    }
    
    <span class="enscript-keyword">return</span> retVal;
}

UInt32 <span class="enscript-function-name">IOSharedDataQueue::getQueueSize</span>()
{
    <span class="enscript-keyword">if</span> (!_reserved) {
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">return</span> _reserved-&gt;queueSize;
}

Boolean <span class="enscript-function-name">IOSharedDataQueue::setQueueSize</span>(UInt32 size)
{
    <span class="enscript-keyword">if</span> (!_reserved) {
        <span class="enscript-keyword">return</span> false;
    }
    _reserved-&gt;queueSize = size;
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOSharedDataQueue, 7);
</pre>
<hr />
</body></html>