<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOService.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOService.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSUnserialize.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCommand.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceMemory.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterrupts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterruptController.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMessage.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitKeysPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOUserClient.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOWorkLoop.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTimeStamp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOInterruptAccountingPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKernelReporters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/AppleKeyStoreInterface.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG</span> kprintf
<span class="enscript-comment">//#define LOG IOLog
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MATCH_DEBUG</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">OBFUSCATE</span>(x) ((void *)(VM_KERNEL_ADDRPERM(x)))

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePrivate.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>

<span class="enscript-comment">// take lockForArbitration before LOCKNOTIFY
</span>
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IORegistryEntry

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOService, IORegistryEntry)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(_IOServiceNotifier, IONotifier)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(_IOServiceInterestNotifier, IONotifier)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(_IOConfigThread, OSObject)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(_IOServiceJob, OSObject)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOResources, IOService)

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(_IOOpenServiceIterator, OSIterator)

<span class="enscript-function-name">OSDefineMetaClassAndAbstractStructors</span>(IONotifier, OSObject)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> IOPlatformExpert *	gIOPlatform;
<span class="enscript-type">static</span> <span class="enscript-type">class</span> IOPMrootDomain *	gIOPMRootDomain;
<span class="enscript-type">const</span> IORegistryPlane *		gIOServicePlane;
<span class="enscript-type">const</span> IORegistryPlane *		gIOPowerPlane;
<span class="enscript-type">const</span> OSSymbol *		gIODeviceMemoryKey;
<span class="enscript-type">const</span> OSSymbol *		gIOInterruptControllersKey;
<span class="enscript-type">const</span> OSSymbol *		gIOInterruptSpecifiersKey;

<span class="enscript-type">const</span> OSSymbol *		gIOResourcesKey;
<span class="enscript-type">const</span> OSSymbol *		gIOResourceMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIOProviderClassKey;
<span class="enscript-type">const</span> OSSymbol * 		gIONameMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIONameMatchedKey;
<span class="enscript-type">const</span> OSSymbol *		gIOPropertyMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIOLocationMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIOParentMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIOPathMatchKey;
<span class="enscript-type">const</span> OSSymbol *		gIOMatchCategoryKey;
<span class="enscript-type">const</span> OSSymbol *		gIODefaultMatchCategoryKey;
<span class="enscript-type">const</span> OSSymbol *		gIOMatchedServiceCountKey;

<span class="enscript-type">const</span> OSSymbol *		gIOMapperIDKey;
<span class="enscript-type">const</span> OSSymbol *		gIOUserClientClassKey;
<span class="enscript-type">const</span> OSSymbol *		gIOKitDebugKey;

<span class="enscript-type">const</span> OSSymbol *		gIOCommandPoolSizeKey;

<span class="enscript-type">const</span> OSSymbol *		gIOConsoleLockedKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleUsersKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionUIDKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionAuditIDKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleUsersSeedKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionOnConsoleKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionLoginDoneKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionSecureInputPIDKey;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSessionScreenLockedTimeKey;

clock_sec_t			gIOConsoleLockTime;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>			gIOConsoleLoggedIn;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
<span class="enscript-type">static</span> uint32_t			gIOScreenLockState;
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> IORegistryEntry *        gIOChosenEntry;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>			gIOResourceGenerationCount;

<span class="enscript-type">const</span> OSSymbol *		gIOServiceKey;
<span class="enscript-type">const</span> OSSymbol *		gIOPublishNotification;
<span class="enscript-type">const</span> OSSymbol *		gIOFirstPublishNotification;
<span class="enscript-type">const</span> OSSymbol *		gIOMatchedNotification;
<span class="enscript-type">const</span> OSSymbol *		gIOFirstMatchNotification;
<span class="enscript-type">const</span> OSSymbol *		gIOTerminatedNotification;

<span class="enscript-type">const</span> OSSymbol *		gIOGeneralInterest;
<span class="enscript-type">const</span> OSSymbol *		gIOBusyInterest;
<span class="enscript-type">const</span> OSSymbol *		gIOAppPowerStateInterest;
<span class="enscript-type">const</span> OSSymbol *		gIOPriorityPowerStateInterest;
<span class="enscript-type">const</span> OSSymbol *		gIOConsoleSecurityInterest;

<span class="enscript-type">const</span>  OSSymbol *               gAKSGetKey;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">const</span> OSSymbol *                gIOCreateEFIDevicePathSymbol;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> OSDictionary * 		gNotifications;
<span class="enscript-type">static</span> IORecursiveLock *	gNotificationLock;

<span class="enscript-type">static</span> IOService *		gIOResources;
<span class="enscript-type">static</span> IOService * 		gIOServiceRoot;

<span class="enscript-type">static</span> OSOrderedSet *		gJobs;
<span class="enscript-type">static</span> semaphore_port_t		gJobsSemaphore;
<span class="enscript-type">static</span> IOLock *			gJobsLock;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			gOutstandingJobs;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			gNumConfigThreads;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			gNumWaitingThreads;
<span class="enscript-type">static</span> IOLock *			gIOServiceBusyLock;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>             gCPUsRunning;

<span class="enscript-type">static</span> thread_t			gIOTerminateThread;
<span class="enscript-type">static</span> UInt32			gIOTerminateWork;
<span class="enscript-type">static</span> OSArray *		gIOTerminatePhase2List;
<span class="enscript-type">static</span> OSArray *		gIOStopList;
<span class="enscript-type">static</span> OSArray *		gIOStopProviderList;
<span class="enscript-type">static</span> OSArray *		gIOFinalizeList;

<span class="enscript-type">static</span> SInt32			gIOConsoleUsersSeed;
<span class="enscript-type">static</span> OSData *			gIOConsoleUsersSeedValue;

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> OSSymbol *		gIODTPHandleKey;

<span class="enscript-type">const</span> OSSymbol *		gIOPlatformFunctionHandlerSet;

<span class="enscript-type">static</span> IOLock *			gIOConsoleUsersLock;
<span class="enscript-type">static</span> thread_call_t		gIOConsoleLockCallout;

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCKREADNOTIFY</span>()	\
    IORecursiveLockLock( gNotificationLock )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCKWRITENOTIFY</span>()	\
    IORecursiveLockLock( gNotificationLock )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCKWRITE2READNOTIFY</span>()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNLOCKNOTIFY</span>()		\
    IORecursiveLockUnlock( gNotificationLock )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SLEEPNOTIFY</span>(event) \
    IORecursiveLockSleep( gNotificationLock, (<span class="enscript-type">void</span> *)(event), THREAD_UNINT )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SLEEPNOTIFYTO</span>(event, deadline) \
    IORecursiveLockSleepDeadline( gNotificationLock, (<span class="enscript-type">void</span> *)(event), deadline, THREAD_UNINT )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">WAKEUPNOTIFY</span>(event) \
	IORecursiveLockWakeup( gNotificationLock, (<span class="enscript-type">void</span> *)(event), <span class="enscript-comment">/* wake one */</span> false )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">randomDelay</span>()	\
        <span class="enscript-type">int</span> del = read_processor_clock();				\
        del = (((<span class="enscript-type">int</span>)IOThreadSelf()) ^ del ^ (del &gt;&gt; 10)) &amp; 0x3ff;	\
        IOSleep( del );

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">queue_element</span>(entry, element, type, field) do {	\
	vm_address_t __ele = (vm_address_t) (entry);	\
	__ele -= -4 + ((size_t)(&amp;((type) 4)-&gt;field));	\
	(element) = (type) __ele;			\
    } <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">iterqueue</span>(que, elt)				\
	<span class="enscript-keyword">for</span> (queue_entry_t elt = queue_first(que);	\
	     !queue_end(que, elt);			\
	     elt = queue_next(elt))

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">struct</span> IOInterruptAccountingReporter {
    IOSimpleReporter * reporter; <span class="enscript-comment">/* Reporter responsible for communicating the statistics */</span>
    IOInterruptAccountingData * statistics; <span class="enscript-comment">/* The live statistics values, if any */</span>
};

<span class="enscript-type">struct</span> ArbitrationLockQueueElement {
    queue_chain_t link;
    IOThread      thread;
    IOService *   service;
    <span class="enscript-type">unsigned</span>      count;
    <span class="enscript-type">bool</span>          required;
    <span class="enscript-type">bool</span>          aborted;
};

<span class="enscript-type">static</span> queue_head_t gArbitrationLockQueueActive;
<span class="enscript-type">static</span> queue_head_t gArbitrationLockQueueWaiting;
<span class="enscript-type">static</span> queue_head_t gArbitrationLockQueueFree;
<span class="enscript-type">static</span> IOLock *     gArbitrationLockQueueLock;

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::isInactive</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
    { <span class="enscript-keyword">return</span>( 0 != (kIOServiceInactiveState &amp; getState())); }

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

<span class="enscript-comment">// Only used by the intel implementation of
</span><span class="enscript-comment">//     IOService::requireMaxBusStall(UInt32 ns)
</span><span class="enscript-comment">//     IOService::requireMaxInterruptDelay(uint32_t ns)
</span><span class="enscript-type">struct</span> CpuDelayEntry
{
    IOService * fService;
    UInt32      fMaxDelay;
    UInt32      fDelayType;
};

<span class="enscript-type">enum</span> {
    kCpuDelayBusStall, kCpuDelayInterrupt,
    kCpuNumDelayTypes
};

<span class="enscript-type">static</span> OSData          *sCpuDelayData = OSData::withCapacity(8 * <span class="enscript-keyword">sizeof</span>(CpuDelayEntry));
<span class="enscript-type">static</span> IORecursiveLock *sCpuDelayLock = IORecursiveLockAlloc();
<span class="enscript-type">static</span> OSArray         *sCpuLatencyHandlers[kCpuNumDelayTypes];
<span class="enscript-type">const</span> OSSymbol         *sCPULatencyFunctionName[kCpuNumDelayTypes];
<span class="enscript-type">static</span> OSNumber * sCPULatencyHolder[kCpuNumDelayTypes];
<span class="enscript-type">static</span> <span class="enscript-type">char</span> sCPULatencyHolderName[kCpuNumDelayTypes][128];
<span class="enscript-type">static</span> OSNumber * sCPULatencySet[kCpuNumDelayTypes];

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">requireMaxCpuDelay</span>(IOService * service, UInt32 ns, UInt32 delayType);
<span class="enscript-type">static</span> IOReturn
<span class="enscript-function-name">setLatencyHandler</span>(UInt32 delayType, IOService * target, <span class="enscript-type">bool</span> enable);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::initialize</span>( <span class="enscript-type">void</span> )
{
    kern_return_t	err;

    gIOServicePlane	= IORegistryEntry::makePlane( kIOServicePlane );
    gIOPowerPlane 	= IORegistryEntry::makePlane( kIOPowerPlane );

    gIOProviderClassKey = OSSymbol::withCStringNoCopy( kIOProviderClassKey );
    gIONameMatchKey	= OSSymbol::withCStringNoCopy( kIONameMatchKey );
    gIONameMatchedKey	= OSSymbol::withCStringNoCopy( kIONameMatchedKey );
    gIOPropertyMatchKey	= OSSymbol::withCStringNoCopy( kIOPropertyMatchKey );
    gIOPathMatchKey 	= OSSymbol::withCStringNoCopy( kIOPathMatchKey );
    gIOLocationMatchKey	= OSSymbol::withCStringNoCopy( kIOLocationMatchKey );
    gIOParentMatchKey	= OSSymbol::withCStringNoCopy( kIOParentMatchKey );

    gIOMatchCategoryKey	= OSSymbol::withCStringNoCopy( kIOMatchCategoryKey );
    gIODefaultMatchCategoryKey	= OSSymbol::withCStringNoCopy( 
					kIODefaultMatchCategoryKey );
    gIOMatchedServiceCountKey	= OSSymbol::withCStringNoCopy( 
					kIOMatchedServiceCountKey );

    gIOUserClientClassKey = OSSymbol::withCStringNoCopy( kIOUserClientClassKey );

    gIOResourcesKey	= OSSymbol::withCStringNoCopy( kIOResourcesClass );
    gIOResourceMatchKey	= OSSymbol::withCStringNoCopy( kIOResourceMatchKey );

    gIODeviceMemoryKey	= OSSymbol::withCStringNoCopy( <span class="enscript-string">&quot;IODeviceMemory&quot;</span> );
    gIOInterruptControllersKey
	= OSSymbol::withCStringNoCopy(<span class="enscript-string">&quot;IOInterruptControllers&quot;</span>);
    gIOInterruptSpecifiersKey
	= OSSymbol::withCStringNoCopy(<span class="enscript-string">&quot;IOInterruptSpecifiers&quot;</span>);

    gIOMapperIDKey = OSSymbol::withCStringNoCopy(kIOMapperIDKey);

    gIOKitDebugKey	= OSSymbol::withCStringNoCopy( kIOKitDebugKey );

    gIOCommandPoolSizeKey	= OSSymbol::withCStringNoCopy( kIOCommandPoolSizeKey );

    gIOGeneralInterest 		= OSSymbol::withCStringNoCopy( kIOGeneralInterest );
    gIOBusyInterest   		= OSSymbol::withCStringNoCopy( kIOBusyInterest );
    gIOAppPowerStateInterest   	= OSSymbol::withCStringNoCopy( kIOAppPowerStateInterest );
    gIOPriorityPowerStateInterest   	= OSSymbol::withCStringNoCopy( kIOPriorityPowerStateInterest );
    gIOConsoleSecurityInterest 	= OSSymbol::withCStringNoCopy( kIOConsoleSecurityInterest );

    gNotifications		= OSDictionary::withCapacity( 1 );
    gIOPublishNotification	= OSSymbol::withCStringNoCopy(
						 kIOPublishNotification );
    gIOFirstPublishNotification	= OSSymbol::withCStringNoCopy(
                                                 kIOFirstPublishNotification );
    gIOMatchedNotification	= OSSymbol::withCStringNoCopy(
						 kIOMatchedNotification );
    gIOFirstMatchNotification	= OSSymbol::withCStringNoCopy(
						 kIOFirstMatchNotification );
    gIOTerminatedNotification	= OSSymbol::withCStringNoCopy(
						 kIOTerminatedNotification );
    gIOServiceKey		= OSSymbol::withCStringNoCopy( kIOServiceClass);

    gIOConsoleLockedKey		= OSSymbol::withCStringNoCopy( kIOConsoleLockedKey);
    gIOConsoleUsersKey		= OSSymbol::withCStringNoCopy( kIOConsoleUsersKey);
    gIOConsoleSessionUIDKey	= OSSymbol::withCStringNoCopy( kIOConsoleSessionUIDKey);
    gIOConsoleSessionAuditIDKey	= OSSymbol::withCStringNoCopy( kIOConsoleSessionAuditIDKey);

    gIOConsoleUsersSeedKey	         = OSSymbol::withCStringNoCopy(kIOConsoleUsersSeedKey);
    gIOConsoleSessionOnConsoleKey        = OSSymbol::withCStringNoCopy(kIOConsoleSessionOnConsoleKey);
    gIOConsoleSessionLoginDoneKey        = OSSymbol::withCStringNoCopy(kIOConsoleSessionLoginDoneKey);
    gIOConsoleSessionSecureInputPIDKey   = OSSymbol::withCStringNoCopy(kIOConsoleSessionSecureInputPIDKey);
    gIOConsoleSessionScreenLockedTimeKey = OSSymbol::withCStringNoCopy(kIOConsoleSessionScreenLockedTimeKey);

    gIOConsoleUsersSeedValue	       = OSData::withBytesNoCopy(&amp;gIOConsoleUsersSeed, <span class="enscript-keyword">sizeof</span>(gIOConsoleUsersSeed));

    gIOPlatformFunctionHandlerSet		= OSSymbol::withCStringNoCopy(kIOPlatformFunctionHandlerSet);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    sCPULatencyFunctionName[kCpuDelayBusStall]	= OSSymbol::withCStringNoCopy(kIOPlatformFunctionHandlerMaxBusDelay);
    sCPULatencyFunctionName[kCpuDelayInterrupt]	= OSSymbol::withCStringNoCopy(kIOPlatformFunctionHandlerMaxInterruptDelay);
    uint32_t  idx;
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; kCpuNumDelayTypes; idx++)
    {
	sCPULatencySet[idx]    = OSNumber::withNumber(-1U, 32);
	sCPULatencyHolder[idx] = OSNumber::withNumber(0ULL, 64);
        assert(sCPULatencySet[idx] &amp;&amp; sCPULatencyHolder[idx]);
    }
    gIOCreateEFIDevicePathSymbol = OSSymbol::withCString(<span class="enscript-string">&quot;CreateEFIDevicePath&quot;</span>);
#<span class="enscript-reference">endif</span>
    gNotificationLock	 	= IORecursiveLockAlloc();

    gAKSGetKey                   = OSSymbol::withCStringNoCopy(AKS_PLATFORM_FUNCTION_GETKEY);

    assert( gIOServicePlane &amp;&amp; gIODeviceMemoryKey
        &amp;&amp; gIOInterruptControllersKey &amp;&amp; gIOInterruptSpecifiersKey
        &amp;&amp; gIOResourcesKey &amp;&amp; gNotifications &amp;&amp; gNotificationLock
        &amp;&amp; gIOProviderClassKey &amp;&amp; gIONameMatchKey &amp;&amp; gIONameMatchedKey
	&amp;&amp; gIOMatchCategoryKey &amp;&amp; gIODefaultMatchCategoryKey
        &amp;&amp; gIOPublishNotification &amp;&amp; gIOMatchedNotification
        &amp;&amp; gIOTerminatedNotification &amp;&amp; gIOServiceKey
	&amp;&amp; gIOConsoleUsersKey &amp;&amp; gIOConsoleSessionUIDKey
    &amp;&amp; gIOConsoleSessionOnConsoleKey &amp;&amp; gIOConsoleSessionSecureInputPIDKey
	&amp;&amp; gIOConsoleUsersSeedKey &amp;&amp; gIOConsoleUsersSeedValue);

    gJobsLock	= IOLockAlloc();
    gJobs 	= OSOrderedSet::withCapacity( 10 );

    gIOServiceBusyLock = IOLockAlloc();

    gIOConsoleUsersLock = IOLockAlloc();

    err = semaphore_create(kernel_task, &amp;gJobsSemaphore, SYNC_POLICY_FIFO, 0);

    gIOConsoleLockCallout = thread_call_allocate(&amp;IOService::consoleLockTimer, NULL);

    <span class="enscript-reference">IORegistryEntry</span>::getRegistryRoot()-&gt;setProperty(gIOConsoleLockedKey, kOSBooleanTrue);

    assert( gIOServiceBusyLock &amp;&amp; gJobs &amp;&amp; gJobsLock &amp;&amp; gIOConsoleUsersLock
    		&amp;&amp; gIOConsoleLockCallout &amp;&amp; (err == KERN_SUCCESS) );

    gIOResources = IOResources::resources();
    assert( gIOResources );

    gArbitrationLockQueueLock = IOLockAlloc();
    queue_init(&amp;gArbitrationLockQueueActive);
    queue_init(&amp;gArbitrationLockQueueWaiting);
    queue_init(&amp;gArbitrationLockQueueFree);

    assert( gArbitrationLockQueueLock );

    gIOTerminatePhase2List = OSArray::withCapacity( 2 );
    gIOStopList            = OSArray::withCapacity( 16 );
    gIOStopProviderList    = OSArray::withCapacity( 16 );
    gIOFinalizeList	   = OSArray::withCapacity( 16 );
    assert( gIOTerminatePhase2List &amp;&amp; gIOStopList &amp;&amp; gIOStopProviderList &amp;&amp; gIOFinalizeList );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">getCpuDelayBusStallHolderName</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> sCPULatencyHolderName[kCpuDelayBusStall];
}

}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
<span class="enscript-type">static</span> UInt64 <span class="enscript-function-name">getDebugFlags</span>( OSDictionary * props )
{
    OSNumber *	debugProp;
    UInt64	debugFlags;

    debugProp = OSDynamicCast( OSNumber,
		props-&gt;getObject( gIOKitDebugKey ));
    <span class="enscript-keyword">if</span>( debugProp)
	debugFlags = debugProp-&gt;unsigned64BitValue();
    <span class="enscript-keyword">else</span>
	debugFlags = gIOKitDebug;

    <span class="enscript-keyword">return</span>( debugFlags );
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// Probe a matched service and return an instance to be started.
</span><span class="enscript-comment">// The default score is from the property table, &amp; may be altered
</span><span class="enscript-comment">// during probe to change the start order.
</span>
IOService * <span class="enscript-function-name">IOService::probe</span>(	IOService * provider,
				SInt32	  * score )
{
    <span class="enscript-keyword">return</span>( <span class="enscript-keyword">this</span> );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::start</span>( IOService * provider )
{
    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::stop</span>( IOService * provider )
{
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::init</span>( OSDictionary * dictionary )
{
    <span class="enscript-type">bool</span> ret;

    ret = super::init(dictionary);
    <span class="enscript-keyword">if</span> (!ret)     <span class="enscript-keyword">return</span> (false);
    <span class="enscript-keyword">if</span> (reserved) <span class="enscript-keyword">return</span> (true);

    reserved = IONew(ExpansionData, 1);
    <span class="enscript-keyword">if</span> (!reserved) <span class="enscript-keyword">return</span> (false);
    bzero(reserved, <span class="enscript-keyword">sizeof</span>(*reserved));

    <span class="enscript-comment">/*
     * TODO: Improve on this.  Previous efforts to more lazily allocate this
     * lock based on the presence of specifiers ran into issues as some
     * platforms set up the specifiers after IOService initialization.
     *
     * We may be able to get away with a global lock, as this should only be
     * contended by IOReporting clients and driver start/stop (unless a
     * driver wants to remove/add handlers in the course of normal operation,
     * which should be unlikely).
     */</span>
    reserved-&gt;interruptStatisticsLock = IOLockAlloc(); 
    <span class="enscript-keyword">if</span> (!reserved-&gt;interruptStatisticsLock) <span class="enscript-keyword">return</span> (false);

    <span class="enscript-keyword">return</span> (true);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::init</span>( IORegistryEntry * from,
                      <span class="enscript-type">const</span> IORegistryPlane * inPlane )
{
    <span class="enscript-type">bool</span> ret;

    ret = super::init(from, inPlane);
    <span class="enscript-keyword">if</span> (!ret)     <span class="enscript-keyword">return</span> (false);
    <span class="enscript-keyword">if</span> (reserved) <span class="enscript-keyword">return</span> (true);

    reserved = IONew(ExpansionData, 1);
    <span class="enscript-keyword">if</span> (!reserved) <span class="enscript-keyword">return</span> (false);
    bzero(reserved, <span class="enscript-keyword">sizeof</span>(*reserved));

    <span class="enscript-comment">/*
     * TODO: Improve on this.  Previous efforts to more lazily allocate this
     * lock based on the presence of specifiers ran into issues as some
     * platforms set up the specifiers after IOService initialization.
     *
     * We may be able to get away with a global lock, as this should only be
     * contended by IOReporting clients and driver start/stop (unless a
     * driver wants to remove/add handlers in the course of normal operation,
     * which should be unlikely).
     */</span>
    reserved-&gt;interruptStatisticsLock = IOLockAlloc(); 
    <span class="enscript-keyword">if</span> (!reserved-&gt;interruptStatisticsLock) <span class="enscript-keyword">return</span> (false);

    <span class="enscript-keyword">return</span> (true);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">int</span> i = 0;
    requireMaxBusStall(0);
    requireMaxInterruptDelay(0);
    <span class="enscript-keyword">if</span>( getPropertyTable())
        unregisterAllInterest();
    PMfree();

    <span class="enscript-keyword">if</span> (reserved) {
        <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray) {
            <span class="enscript-keyword">for</span> (i = 0; i &lt; reserved-&gt;interruptStatisticsArrayCount; i++) {
                <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray[i].reporter)
                    reserved-&gt;interruptStatisticsArray[i].reporter-&gt;release();
            }

            IODelete(reserved-&gt;interruptStatisticsArray, IOInterruptAccountingReporter, reserved-&gt;interruptStatisticsArrayCount);
        }

        <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsLock)
            IOLockFree(reserved-&gt;interruptStatisticsLock);
        IODelete(reserved, ExpansionData, 1);
    }

    <span class="enscript-keyword">if</span> (_numInterruptSources &amp;&amp; _interruptSources)
    {
	IOFree(_interruptSources, _numInterruptSources * <span class="enscript-keyword">sizeof</span>(IOInterruptSource));
	_interruptSources = 0;
    }

    <span class="enscript-reference">super</span>::free();
}

<span class="enscript-comment">/*
 * Attach in service plane
 */</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::attach</span>( IOService * provider )
{
    <span class="enscript-type">bool</span>	ok;

    <span class="enscript-keyword">if</span>( provider) {

	<span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogAttach)
            LOG( <span class="enscript-string">&quot;%s::attach(%s)\n&quot;</span>, getName(),
                    provider-&gt;getName());

        provider-&gt;lockForArbitration();
        <span class="enscript-keyword">if</span>( provider-&gt;__state[0] &amp; kIOServiceInactiveState)
            ok = false;
        <span class="enscript-keyword">else</span>
            ok = attachToParent( provider, gIOServicePlane);
        provider-&gt;unlockForArbitration();

    } <span class="enscript-keyword">else</span> {
	gIOServiceRoot = <span class="enscript-keyword">this</span>;
	ok = attachToParent( getRegistryRoot(), gIOServicePlane);
    }

    <span class="enscript-keyword">if</span> (ok &amp;&amp; !__provider) (<span class="enscript-type">void</span>) getProvider();

    <span class="enscript-keyword">return</span>( ok );
}

IOService * <span class="enscript-function-name">IOService::getServiceRoot</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( gIOServiceRoot );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::detach</span>( IOService * provider )
{
    IOService * newProvider = 0;
    SInt32	busy;
    <span class="enscript-type">bool</span>	adjParent;

    <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogAttach)
        LOG(<span class="enscript-string">&quot;%s::detach(%s)\n&quot;</span>, getName(), provider-&gt;getName());

    lockForArbitration();

    uint64_t regID1 = provider-&gt;getRegistryEntryID();
    uint64_t regID2 = getRegistryEntryID();
    IOServiceTrace(
	IOSERVICE_DETACH,
	(uintptr_t) regID1,
	(uintptr_t) (regID1 &gt;&gt; 32),
	(uintptr_t) regID2,
	(uintptr_t) (regID2 &gt;&gt; 32));

    adjParent = ((busy = (__state[1] &amp; kIOServiceBusyStateMask))
               &amp;&amp; (provider == getProvider()));

    detachFromParent( provider, gIOServicePlane );

    <span class="enscript-keyword">if</span>( busy) {
        newProvider = getProvider();
        <span class="enscript-keyword">if</span>( busy &amp;&amp; (__state[1] &amp; kIOServiceTermPhase3State) &amp;&amp; (0 == newProvider))
            _adjustBusy( -busy );
    }

    <span class="enscript-keyword">if</span> (kIOServiceInactiveState &amp; __state[0]) {
	getMetaClass()-&gt;removeInstance(<span class="enscript-keyword">this</span>);
	IORemoveServicePlatformActions(<span class="enscript-keyword">this</span>);
    }

    unlockForArbitration();

    <span class="enscript-keyword">if</span>( newProvider) {
        newProvider-&gt;lockForArbitration();
        newProvider-&gt;_adjustBusy(1);
        newProvider-&gt;unlockForArbitration();
    }

    <span class="enscript-comment">// check for last client detach from a terminated service
</span>    <span class="enscript-keyword">if</span>( provider-&gt;lockForArbitration( true ))
    {
	<span class="enscript-keyword">if</span> (kIOServiceStartState &amp; __state[1])
	{
	    provider-&gt;scheduleTerminatePhase2();
	}
        <span class="enscript-keyword">if</span>( adjParent) provider-&gt;_adjustBusy( -1 );
        <span class="enscript-keyword">if</span>( (provider-&gt;__state[1] &amp; kIOServiceTermPhase3State)
         &amp;&amp; (0 == provider-&gt;getClient())) {
            provider-&gt;scheduleFinalize();
        }
        provider-&gt;unlockForArbitration();
    }
}

<span class="enscript-comment">/*
 * Register instance - publish it for matching
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::registerService</span>( IOOptionBits options )
{
    <span class="enscript-type">char</span> *		pathBuf;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *	path;
    <span class="enscript-type">char</span> *		skip;
    <span class="enscript-type">int</span>			len;
    <span class="enscript-type">enum</span> { kMaxPathLen	= 256 };
    <span class="enscript-type">enum</span> { kMaxChars	= 63 };

    IORegistryEntry * parent = <span class="enscript-keyword">this</span>;
    IORegistryEntry * root = getRegistryRoot();
    <span class="enscript-keyword">while</span>( parent &amp;&amp; (parent != root))
        parent = parent-&gt;getParentEntry( gIOServicePlane);

    <span class="enscript-keyword">if</span>( parent != root) {
        IOLog(<span class="enscript-string">&quot;%s: not registry member at registerService()\n&quot;</span>, getName());
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Allow the Platform Expert to adjust this node.
</span>    <span class="enscript-keyword">if</span>( gIOPlatform &amp;&amp; (!gIOPlatform-&gt;platformAdjustService(<span class="enscript-keyword">this</span>)))
	<span class="enscript-keyword">return</span>;

    IOInstallServicePlatformActions(<span class="enscript-keyword">this</span>);

    <span class="enscript-keyword">if</span>( (<span class="enscript-keyword">this</span> != gIOResources)
     &amp;&amp; (kIOLogRegister &amp; gIOKitDebug)) {

        pathBuf = (<span class="enscript-type">char</span> *) IOMalloc( kMaxPathLen );

        IOLog( <span class="enscript-string">&quot;Registering: &quot;</span> );

        len = kMaxPathLen;
        <span class="enscript-keyword">if</span>( pathBuf &amp;&amp; getPath( pathBuf, &amp;len, gIOServicePlane)) {

            path = pathBuf;
            <span class="enscript-keyword">if</span>( len &gt; kMaxChars) {
                IOLog(<span class="enscript-string">&quot;..&quot;</span>);
                len -= kMaxChars;
                path += len;
                <span class="enscript-keyword">if</span>( (skip = strchr( path, <span class="enscript-string">'/'</span>)))
                    path = skip;
            }
        } <span class="enscript-keyword">else</span>
            path = getName();

        IOLog( <span class="enscript-string">&quot;%s\n&quot;</span>, path );

	<span class="enscript-keyword">if</span>( pathBuf)
	    IOFree( pathBuf, kMaxPathLen );
    }

    startMatching( options );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::startMatching</span>( IOOptionBits options )
{
    IOService *	provider;
    UInt32	prevBusy = 0;
    <span class="enscript-type">bool</span>	needConfig;
    <span class="enscript-type">bool</span>	needWake = false;
    <span class="enscript-type">bool</span>	ok;
    <span class="enscript-type">bool</span>	sync;
    <span class="enscript-type">bool</span>	waitAgain;

    lockForArbitration();

    sync = (options &amp; kIOServiceSynchronous)
	|| ((provider = getProvider())
		&amp;&amp; (provider-&gt;__state[1] &amp; kIOServiceSynchronousState));

	<span class="enscript-keyword">if</span> ( options &amp; kIOServiceAsynchronous )
		sync = false;

    needConfig =  (0 == (__state[1] &amp; (kIOServiceNeedConfigState | kIOServiceConfigState)))
	       &amp;&amp; (0 == (__state[0] &amp; kIOServiceInactiveState));

    __state[1] |= kIOServiceNeedConfigState;

<span class="enscript-comment">//    __state[0] &amp;= ~kIOServiceInactiveState;
</span>
<span class="enscript-comment">//    if( sync) LOG(&quot;OSKernelStackRemaining = %08x @ %s\n&quot;,
</span><span class="enscript-comment">//			OSKernelStackRemaining(), getName());
</span>
    <span class="enscript-keyword">if</span>( needConfig) {
        needWake = (0 != (kIOServiceSyncPubState &amp; __state[1]));
    }

    <span class="enscript-keyword">if</span>( sync)
	__state[1] |= kIOServiceSynchronousState;
    <span class="enscript-keyword">else</span>
	__state[1] &amp;= ~kIOServiceSynchronousState;

    <span class="enscript-keyword">if</span>( needConfig) prevBusy = _adjustBusy( 1 );

    unlockForArbitration();

    <span class="enscript-keyword">if</span>( needConfig) {

        <span class="enscript-keyword">if</span>( needWake) {
            IOLockLock( gIOServiceBusyLock );
            thread_wakeup( (event_t) <span class="enscript-keyword">this</span><span class="enscript-comment">/*&amp;__state[1]*/</span> );
            IOLockUnlock( gIOServiceBusyLock );

        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( !sync || (kIOServiceAsynchronous &amp; options)) {

            ok = (0 != _IOServiceJob::startJob( <span class="enscript-keyword">this</span>, kMatchNubJob, options ));
    
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {

            <span class="enscript-keyword">if</span>( (__state[1] &amp; kIOServiceNeedConfigState))
                doServiceMatch( options );

            lockForArbitration();
            IOLockLock( gIOServiceBusyLock );

            waitAgain = ((prevBusy &lt; (__state[1] &amp; kIOServiceBusyStateMask))
				       &amp;&amp; (0 == (__state[0] &amp; kIOServiceInactiveState)));

            <span class="enscript-keyword">if</span>( waitAgain)
                __state[1] |= kIOServiceSyncPubState | kIOServiceBusyWaiterState;
            <span class="enscript-keyword">else</span>
                __state[1] &amp;= ~kIOServiceSyncPubState;

            unlockForArbitration();

            <span class="enscript-keyword">if</span>( waitAgain)
                assert_wait( (event_t) <span class="enscript-keyword">this</span><span class="enscript-comment">/*&amp;__state[1]*/</span>, THREAD_UNINT);

            IOLockUnlock( gIOServiceBusyLock );
            <span class="enscript-keyword">if</span>( waitAgain)
                thread_block(THREAD_CONTINUE_NULL);

        } <span class="enscript-keyword">while</span>( waitAgain );
    }
}

IOReturn <span class="enscript-function-name">IOService::catalogNewDrivers</span>( OSOrderedSet * newTables )
{
    OSDictionary *	table;
    OSSet *	        set;
    OSSet *	        allSet = 0;
    IOService *		service;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
    SInt32		count = 0;
#<span class="enscript-reference">endif</span>

    newTables-&gt;retain();
    
    <span class="enscript-keyword">while</span>( (table = (OSDictionary *) newTables-&gt;getFirstObject())) {

        LOCKWRITENOTIFY();
        set = (OSSet *) copyExistingServices( table, 
						kIOServiceRegisteredState,
						kIOServiceExistingSet);
        UNLOCKNOTIFY();
        <span class="enscript-keyword">if</span>( set) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
            count += set-&gt;getCount();
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (allSet) {
                allSet-&gt;merge((<span class="enscript-type">const</span> OSSet *) set);
                set-&gt;release();
            }
            <span class="enscript-keyword">else</span>
                allSet = set;
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
        <span class="enscript-keyword">if</span>( getDebugFlags( table ) &amp; kIOLogMatch)
            LOG(<span class="enscript-string">&quot;Matching service count = %ld\n&quot;</span>, (<span class="enscript-type">long</span>)count);
#<span class="enscript-reference">endif</span>
        newTables-&gt;removeObject(table);
    }

    <span class="enscript-keyword">if</span> (allSet) {
        <span class="enscript-keyword">while</span>( (service = (IOService *) allSet-&gt;getAnyObject())) {
            service-&gt;startMatching(kIOServiceAsynchronous);
            allSet-&gt;removeObject(service);
        }
        allSet-&gt;release();
    }

    newTables-&gt;release();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

 _IOServiceJob * _IOServiceJob::startJob( IOService * nub, <span class="enscript-type">int</span> type,
						IOOptionBits options )
{
    _IOServiceJob *	job;

    job = <span class="enscript-keyword">new</span> _IOServiceJob;
    <span class="enscript-keyword">if</span>( job &amp;&amp; !job-&gt;init()) {
        job-&gt;release();
        job = 0;
    }

    <span class="enscript-keyword">if</span>( job) {
        job-&gt;type	= type;
        job-&gt;nub	= nub;
	job-&gt;options	= options;
        nub-&gt;retain();			<span class="enscript-comment">// thread will release()
</span>        pingConfig( job );
    }

    <span class="enscript-keyword">return</span>( job );
}

<span class="enscript-comment">/*
 * Called on a registered service to see if it matches
 * a property table.
 */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::matchPropertyTable</span>( OSDictionary * table, SInt32 * score )
{
    <span class="enscript-keyword">return</span>( matchPropertyTable(table) );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::matchPropertyTable</span>( OSDictionary * table )
{
    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-comment">/*
 * Called on a matched service to allocate resources
 * before first driver is attached.
 */</span>

IOReturn <span class="enscript-function-name">IOService::getResources</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( kIOReturnSuccess);
}

<span class="enscript-comment">/*
 * Client/provider accessors
 */</span>

IOService * <span class="enscript-function-name">IOService::getProvider</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    IOService *	self = (IOService *) <span class="enscript-keyword">this</span>;
    IOService *	parent;
    SInt32	generation;

    generation = getGenerationCount();
    <span class="enscript-keyword">if</span>( __providerGeneration == generation)
	<span class="enscript-keyword">return</span>( __provider );

    parent = (IOService *) getParentEntry( gIOServicePlane);
    <span class="enscript-keyword">if</span>( parent == IORegistryEntry::getRegistryRoot())
	<span class="enscript-comment">/* root is not an IOService */</span>
	parent = 0;

    self-&gt;__provider = parent;
    OSMemoryBarrier();
    <span class="enscript-comment">// save the count from before call to getParentEntry()
</span>    self-&gt;__providerGeneration = generation;

    <span class="enscript-keyword">return</span>( parent );
}

IOWorkLoop * <span class="enscript-function-name">IOService::getWorkLoop</span>() <span class="enscript-type">const</span>
{ 
    IOService *provider = getProvider();

    <span class="enscript-keyword">if</span> (provider)
	<span class="enscript-keyword">return</span> provider-&gt;getWorkLoop();
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span> 0;
}

OSIterator * <span class="enscript-function-name">IOService::getProviderIterator</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( getParentIterator( gIOServicePlane));
}

IOService * <span class="enscript-function-name">IOService::getClient</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( (IOService *) getChildEntry( gIOServicePlane));
}

OSIterator * <span class="enscript-function-name">IOService::getClientIterator</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( getChildIterator( gIOServicePlane));
}

OSIterator * <span class="enscript-function-name">_IOOpenServiceIterator::iterator</span>( OSIterator * _iter,
						<span class="enscript-type">const</span> IOService * client,
						<span class="enscript-type">const</span> IOService * provider )
{
    _IOOpenServiceIterator * inst;

    <span class="enscript-keyword">if</span>( !_iter)
	<span class="enscript-keyword">return</span>( 0 );

    inst = <span class="enscript-keyword">new</span> _IOOpenServiceIterator;

    <span class="enscript-keyword">if</span>( inst &amp;&amp; !inst-&gt;init()) {
	inst-&gt;release();
	inst = 0;
    }
    <span class="enscript-keyword">if</span>( inst) {
	inst-&gt;iter = _iter;
	inst-&gt;client = client;
	inst-&gt;provider = provider;
    }

    <span class="enscript-keyword">return</span>( inst );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOOpenServiceIterator::free</span>()
{
    iter-&gt;release();
    <span class="enscript-keyword">if</span>( last)
	last-&gt;unlockForArbitration();
    <span class="enscript-reference">OSIterator</span>::free();
}

OSObject * <span class="enscript-function-name">_IOOpenServiceIterator::getNextObject</span>()
{
    IOService * next;

    <span class="enscript-keyword">if</span>( last)
	last-&gt;unlockForArbitration();

    <span class="enscript-keyword">while</span>( (next = (IOService *) iter-&gt;getNextObject())) {

	next-&gt;lockForArbitration();
	<span class="enscript-keyword">if</span>( (client &amp;&amp; (next-&gt;isOpen( client )))
	 || (provider &amp;&amp; (provider-&gt;isOpen( next ))) )
            <span class="enscript-keyword">break</span>;
	next-&gt;unlockForArbitration();
    }

    last = next;

    <span class="enscript-keyword">return</span>( next );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">_IOOpenServiceIterator::isValid</span>()
{
    <span class="enscript-keyword">return</span>( iter-&gt;isValid() );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOOpenServiceIterator::reset</span>()
{
    <span class="enscript-keyword">if</span>( last) {
	last-&gt;unlockForArbitration();
	last = 0;
    }
    iter-&gt;reset();
}

OSIterator * <span class="enscript-function-name">IOService::getOpenProviderIterator</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( _IOOpenServiceIterator::iterator( getProviderIterator(), <span class="enscript-keyword">this</span>, 0 ));
}

OSIterator * <span class="enscript-function-name">IOService::getOpenClientIterator</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( _IOOpenServiceIterator::iterator( getClientIterator(), 0, <span class="enscript-keyword">this</span> ));
}


IOReturn <span class="enscript-function-name">IOService::callPlatformFunction</span>( <span class="enscript-type">const</span> OSSymbol * functionName,
					  <span class="enscript-type">bool</span> waitForFunction,
					  <span class="enscript-type">void</span> *param1, <span class="enscript-type">void</span> *param2,
					  <span class="enscript-type">void</span> *param3, <span class="enscript-type">void</span> *param4 )
{
  IOReturn  result = kIOReturnUnsupported;
  IOService *provider;

  <span class="enscript-keyword">if</span> (gIOPlatformFunctionHandlerSet == functionName)
  {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-type">const</span> OSSymbol * functionHandlerName = (<span class="enscript-type">const</span> OSSymbol *) param1;
    IOService *	     target		 = (IOService *) param2;
    <span class="enscript-type">bool</span>	     enable		 = (param3 != 0);

    <span class="enscript-keyword">if</span> (sCPULatencyFunctionName[kCpuDelayBusStall] == functionHandlerName)
	result = setLatencyHandler(kCpuDelayBusStall, target, enable);
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sCPULatencyFunctionName[kCpuDelayInterrupt] == param1)
	result = setLatencyHandler(kCpuDelayInterrupt, target, enable);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>
  }

  <span class="enscript-keyword">if</span> ((kIOReturnUnsupported == result) &amp;&amp; (provider = getProvider())) {
    result = provider-&gt;callPlatformFunction(functionName, waitForFunction,
					    param1, param2, param3, param4);
  }
  
  <span class="enscript-keyword">return</span> result;
}

IOReturn <span class="enscript-function-name">IOService::callPlatformFunction</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * functionName,
					  <span class="enscript-type">bool</span> waitForFunction,
					  <span class="enscript-type">void</span> *param1, <span class="enscript-type">void</span> *param2,
					  <span class="enscript-type">void</span> *param3, <span class="enscript-type">void</span> *param4 )
{
  IOReturn result = kIOReturnNoMemory;
  <span class="enscript-type">const</span> OSSymbol *functionSymbol = OSSymbol::withCString(functionName);
  
  <span class="enscript-keyword">if</span> (functionSymbol != 0) {
    result = callPlatformFunction(functionSymbol, waitForFunction,
				  param1, param2, param3, param4);
    functionSymbol-&gt;release();
  }
  
  <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*
 * Accessors for global services
 */</span>

IOPlatformExpert * <span class="enscript-function-name">IOService::getPlatform</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( gIOPlatform);
}

<span class="enscript-type">class</span> IOPMrootDomain * <span class="enscript-function-name">IOService::getPMRootDomain</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( gIOPMRootDomain);
}

IOService * <span class="enscript-function-name">IOService::getResourceService</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( gIOResources );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setPlatform</span>( IOPlatformExpert * platform)
{
    gIOPlatform = platform;
    gIOResources-&gt;attachToParent( gIOServiceRoot, gIOServicePlane );

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

    <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * keys[kCpuNumDelayTypes] = {
    	kIOPlatformMaxBusDelay, kIOPlatformMaxInterruptDelay };
    <span class="enscript-type">const</span> OSObject * objs[2];
    OSArray * array;
    uint32_t  idx;
    
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; kCpuNumDelayTypes; idx++)
    {
	objs[0] = sCPULatencySet[idx];
	objs[1] = sCPULatencyHolder[idx];
        array   = OSArray::withObjects(objs, 2);
        <span class="enscript-keyword">if</span> (!array) <span class="enscript-keyword">break</span>;
	platform-&gt;setProperty(keys[idx], array);
	array-&gt;release();
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setPMRootDomain</span>( <span class="enscript-type">class</span> IOPMrootDomain * rootDomain)
{
    gIOPMRootDomain = rootDomain;
    publishResource(<span class="enscript-string">&quot;IOKit&quot;</span>);
}

<span class="enscript-comment">/*
 * Stacking change
 */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::lockForArbitration</span>( <span class="enscript-type">bool</span> isSuccessRequired )
{
    <span class="enscript-type">bool</span>                          found;
    <span class="enscript-type">bool</span>                          success;
    ArbitrationLockQueueElement * element;
    ArbitrationLockQueueElement * active;
    ArbitrationLockQueueElement * waiting;

    <span class="enscript-type">enum</span> { kPutOnFreeQueue, kPutOnActiveQueue, kPutOnWaitingQueue } action;

    <span class="enscript-comment">// lock global access
</span>    IOTakeLock( gArbitrationLockQueueLock );

    <span class="enscript-comment">// obtain an unused queue element
</span>    <span class="enscript-keyword">if</span>( !queue_empty( &amp;gArbitrationLockQueueFree )) {
        queue_remove_first( &amp;gArbitrationLockQueueFree,
                            element,
                            ArbitrationLockQueueElement *,
                            link );
    } <span class="enscript-keyword">else</span> {
        element = IONew( ArbitrationLockQueueElement, 1 );
        assert( element );
    }

    <span class="enscript-comment">// prepare the queue element
</span>    element-&gt;thread   = IOThreadSelf();
    element-&gt;service  = <span class="enscript-keyword">this</span>;
    element-&gt;count    = 1;
    element-&gt;required = isSuccessRequired;
    element-&gt;aborted  = false;

    <span class="enscript-comment">// determine whether this object is already locked (ie. on active queue)
</span>    found = false;
    queue_iterate( &amp;gArbitrationLockQueueActive,
                    active,
                    ArbitrationLockQueueElement *,
                    link )
    {
        <span class="enscript-keyword">if</span>( active-&gt;service == element-&gt;service ) {
            found = true;
            <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span>( found ) { <span class="enscript-comment">// this object is already locked
</span>
        <span class="enscript-comment">// determine whether it is the same or a different thread trying to lock
</span>        <span class="enscript-keyword">if</span>( active-&gt;thread != element-&gt;thread ) { <span class="enscript-comment">// it is a different thread
</span>
            ArbitrationLockQueueElement * victim = 0;

            <span class="enscript-comment">// before placing this new thread on the waiting queue, we look for
</span>            <span class="enscript-comment">// a deadlock cycle...
</span>
            <span class="enscript-keyword">while</span>( 1 ) {
                <span class="enscript-comment">// determine whether the active thread holding the object we
</span>                <span class="enscript-comment">// want is waiting for another object to be unlocked
</span>                found = false;
                queue_iterate( &amp;gArbitrationLockQueueWaiting,
                               waiting,
                               ArbitrationLockQueueElement *,
                               link )
                {
                    <span class="enscript-keyword">if</span>( waiting-&gt;thread == active-&gt;thread ) {
                        assert( false == waiting-&gt;aborted );
                        found = true;
                        <span class="enscript-keyword">break</span>;
                    }
                }

                <span class="enscript-keyword">if</span>( found ) { <span class="enscript-comment">// yes, active thread waiting for another object
</span>
                    <span class="enscript-comment">// this may be a candidate for rejection if the required
</span>                    <span class="enscript-comment">// flag is not set, should we detect a deadlock later on
</span>                    <span class="enscript-keyword">if</span>( false == waiting-&gt;required )
                        victim = waiting;

                    <span class="enscript-comment">// find the thread that is holding this other object, that
</span>                    <span class="enscript-comment">// is blocking the active thread from proceeding (fun :-)
</span>                    found = false;
                    queue_iterate( &amp;gArbitrationLockQueueActive,
                                   active,      <span class="enscript-comment">// (reuse active queue element)
</span>                                   ArbitrationLockQueueElement *,
                                   link )
                    {
                        <span class="enscript-keyword">if</span>( active-&gt;service == waiting-&gt;service ) {
                            found = true;
                            <span class="enscript-keyword">break</span>;
                        }
                    }

                    <span class="enscript-comment">// someone must be holding it or it wouldn't be waiting
</span>                    assert( found );

                    <span class="enscript-keyword">if</span>( active-&gt;thread == element-&gt;thread ) {

                        <span class="enscript-comment">// doh, it's waiting for the thread that originated
</span>                        <span class="enscript-comment">// this whole lock (ie. current thread) -&gt; deadlock
</span>                        <span class="enscript-keyword">if</span>( false == element-&gt;required ) { <span class="enscript-comment">// willing to fail?
</span>
                            <span class="enscript-comment">// the originating thread doesn't have the required
</span>                            <span class="enscript-comment">// flag, so it can fail
</span>                            success = false; <span class="enscript-comment">// (fail originating lock request)
</span>                            <span class="enscript-keyword">break</span>; <span class="enscript-comment">// (out of while)
</span>
                        } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// originating thread is not willing to fail
</span>
                            <span class="enscript-comment">// see if we came across a waiting thread that did
</span>                            <span class="enscript-comment">// not have the 'required' flag set: we'll fail it
</span>                            <span class="enscript-keyword">if</span>( victim ) {

                                <span class="enscript-comment">// we do have a willing victim, fail it's lock
</span>                                victim-&gt;aborted = true;

                                <span class="enscript-comment">// take the victim off the waiting queue
</span>                                queue_remove( &amp;gArbitrationLockQueueWaiting,
                                              victim,
                                              ArbitrationLockQueueElement *,
                                              link );

                                <span class="enscript-comment">// wake the victim
</span>                                IOLockWakeup( gArbitrationLockQueueLock, 
                                              victim, 
                                              <span class="enscript-comment">/* one thread */</span> true );

                                <span class="enscript-comment">// allow this thread to proceed (ie. wait)
</span>                                success = true; <span class="enscript-comment">// (put request on wait queue)
</span>                                <span class="enscript-keyword">break</span>; <span class="enscript-comment">// (out of while)
</span>                            } <span class="enscript-keyword">else</span> {

                                <span class="enscript-comment">// all the waiting threads we came across in
</span>                                <span class="enscript-comment">// finding this loop had the 'required' flag
</span>                                <span class="enscript-comment">// set, so we've got a deadlock we can't avoid
</span>                                panic(<span class="enscript-string">&quot;I/O Kit: Unrecoverable deadlock.&quot;</span>);
                            }
                        }
                    } <span class="enscript-keyword">else</span> {
                        <span class="enscript-comment">// repeat while loop, redefining active thread to be the
</span>                        <span class="enscript-comment">// thread holding &quot;this other object&quot; (see above), and
</span>                        <span class="enscript-comment">// looking for threads waiting on it; note the active
</span>                        <span class="enscript-comment">// variable points to &quot;this other object&quot; already... so
</span>                        <span class="enscript-comment">// there nothing to do in this else clause.
</span>                    }
                } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// no, active thread is not waiting for another object
</span>                      
                    success = true; <span class="enscript-comment">// (put request on wait queue)
</span>                    <span class="enscript-keyword">break</span>; <span class="enscript-comment">// (out of while)
</span>                }
            } <span class="enscript-comment">// while forever
</span>
            <span class="enscript-keyword">if</span>( success ) { <span class="enscript-comment">// put the request on the waiting queue?
</span>                kern_return_t wait_result;

                <span class="enscript-comment">// place this thread on the waiting queue and put it to sleep;
</span>                <span class="enscript-comment">// we place it at the tail of the queue...
</span>                queue_enter( &amp;gArbitrationLockQueueWaiting,
                             element,
                             ArbitrationLockQueueElement *,
                             link );

                <span class="enscript-comment">// declare that this thread will wait for a given event
</span><span class="enscript-reference">restart_sleep</span>:  wait_result = assert_wait( element,
					   element-&gt;required ? THREAD_UNINT
					   : THREAD_INTERRUPTIBLE );

                <span class="enscript-comment">// unlock global access
</span>                IOUnlock( gArbitrationLockQueueLock );

                <span class="enscript-comment">// put thread to sleep, waiting for our event to fire...
</span>		<span class="enscript-keyword">if</span> (wait_result == THREAD_WAITING)
		    wait_result = thread_block(THREAD_CONTINUE_NULL);


                <span class="enscript-comment">// ...and we've been woken up; we might be in one of two states:
</span>                <span class="enscript-comment">// (a) we've been aborted and our queue element is not on
</span>                <span class="enscript-comment">//     any of the three queues, but is floating around
</span>                <span class="enscript-comment">// (b) we're allowed to proceed with the lock and we have
</span>                <span class="enscript-comment">//     already been moved from the waiting queue to the
</span>                <span class="enscript-comment">//     active queue.
</span>                <span class="enscript-comment">// ...plus a 3rd state, should the thread have been interrupted:
</span>                <span class="enscript-comment">// (c) we're still on the waiting queue
</span>
                <span class="enscript-comment">// determine whether we were interrupted out of our sleep
</span>                <span class="enscript-keyword">if</span>( THREAD_INTERRUPTED == wait_result ) {

                    <span class="enscript-comment">// re-lock global access
</span>                    IOTakeLock( gArbitrationLockQueueLock );

                    <span class="enscript-comment">// determine whether we're still on the waiting queue
</span>                    found = false;
                    queue_iterate( &amp;gArbitrationLockQueueWaiting,
                                   waiting,     <span class="enscript-comment">// (reuse waiting queue element)
</span>                                   ArbitrationLockQueueElement *,
                                   link )
                    {
                        <span class="enscript-keyword">if</span>( waiting == element ) {
                            found = true;
                            <span class="enscript-keyword">break</span>;
                        }
                    }

                    <span class="enscript-keyword">if</span>( found ) { <span class="enscript-comment">// yes, we're still on the waiting queue
</span>
                        <span class="enscript-comment">// determine whether we're willing to fail
</span>                        <span class="enscript-keyword">if</span>( false == element-&gt;required ) {

                            <span class="enscript-comment">// mark us as aborted
</span>                            element-&gt;aborted = true;

                            <span class="enscript-comment">// take us off the waiting queue
</span>                            queue_remove( &amp;gArbitrationLockQueueWaiting,
                                          element,
                                          ArbitrationLockQueueElement *,
                                          link );
                        } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// we are not willing to fail
</span>
                            <span class="enscript-comment">// ignore interruption, go back to sleep
</span>                            <span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_sleep</span>;
                        }
                    }

                    <span class="enscript-comment">// unlock global access
</span>                    IOUnlock( gArbitrationLockQueueLock );

                    <span class="enscript-comment">// proceed as though this were a normal wake up
</span>                    wait_result = THREAD_AWAKENED;
                }

                assert( THREAD_AWAKENED == wait_result );

                <span class="enscript-comment">// determine whether we've been aborted while we were asleep
</span>                <span class="enscript-keyword">if</span>( element-&gt;aborted ) {
                    assert( false == element-&gt;required );

                    <span class="enscript-comment">// re-lock global access
</span>                    IOTakeLock( gArbitrationLockQueueLock );

                    action = kPutOnFreeQueue;
                    success = false;
                } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// we weren't aborted, so we must be ready to go :-)
</span>
                    <span class="enscript-comment">// we've already been moved from waiting to active queue
</span>                    <span class="enscript-keyword">return</span> true;
                }

            } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// the lock request is to be failed
</span>
                <span class="enscript-comment">// return unused queue element to queue
</span>                action = kPutOnFreeQueue;
            }
        } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// it is the same thread, recursive access is allowed
</span>
            <span class="enscript-comment">// add one level of recursion
</span>            active-&gt;count++;

            <span class="enscript-comment">// return unused queue element to queue
</span>            action = kPutOnFreeQueue;
            success = true;
        }
    } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// this object is not already locked, so let this thread through
</span>        action = kPutOnActiveQueue;
        success = true;
    }

    <span class="enscript-comment">// put the new element on a queue
</span>    <span class="enscript-keyword">if</span>( kPutOnActiveQueue == action ) {
        queue_enter( &amp;gArbitrationLockQueueActive,
                     element,
                     ArbitrationLockQueueElement *,
                     link );
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( kPutOnFreeQueue == action ) {
        queue_enter( &amp;gArbitrationLockQueueFree,
                     element,
                     ArbitrationLockQueueElement *,
                     link );
    } <span class="enscript-keyword">else</span> {
        assert( 0 ); <span class="enscript-comment">// kPutOnWaitingQueue never occurs, handled specially above
</span>    }

    <span class="enscript-comment">// unlock global access
</span>    IOUnlock( gArbitrationLockQueueLock );

    <span class="enscript-keyword">return</span>( success );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::unlockForArbitration</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-type">bool</span>                          found;
    ArbitrationLockQueueElement * element;

    <span class="enscript-comment">// lock global access
</span>    IOTakeLock( gArbitrationLockQueueLock );

    <span class="enscript-comment">// find the lock element for this object (ie. on active queue)
</span>    found = false;
    queue_iterate( &amp;gArbitrationLockQueueActive,
                    element,
                    ArbitrationLockQueueElement *,
                    link )
    {
        <span class="enscript-keyword">if</span>( element-&gt;service == <span class="enscript-keyword">this</span> ) {
            found = true;
            <span class="enscript-keyword">break</span>;
        }
    }

    assert( found );

    <span class="enscript-comment">// determine whether the lock has been taken recursively
</span>    <span class="enscript-keyword">if</span>( element-&gt;count &gt; 1 ) {
        <span class="enscript-comment">// undo one level of recursion
</span>        element-&gt;count--;

    } <span class="enscript-keyword">else</span> {

        <span class="enscript-comment">// remove it from the active queue
</span>        queue_remove( &amp;gArbitrationLockQueueActive,
                      element,
                      ArbitrationLockQueueElement *,
                      link );

        <span class="enscript-comment">// put it on the free queue
</span>        queue_enter( &amp;gArbitrationLockQueueFree,
                     element,
                     ArbitrationLockQueueElement *,
                     link );

        <span class="enscript-comment">// determine whether a thread is waiting for object (head to tail scan)
</span>        found = false;
        queue_iterate( &amp;gArbitrationLockQueueWaiting,
                       element,
                       ArbitrationLockQueueElement *,
                       link )
        {
            <span class="enscript-keyword">if</span>( element-&gt;service == <span class="enscript-keyword">this</span> ) {
                found = true;
                <span class="enscript-keyword">break</span>;
            }
        }

        <span class="enscript-keyword">if</span> ( found ) { <span class="enscript-comment">// we found an interested thread on waiting queue
</span>
            <span class="enscript-comment">// remove it from the waiting queue
</span>            queue_remove( &amp;gArbitrationLockQueueWaiting,
                          element,
                          ArbitrationLockQueueElement *,
                          link );

            <span class="enscript-comment">// put it on the active queue
</span>            queue_enter( &amp;gArbitrationLockQueueActive,
                         element,
                         ArbitrationLockQueueElement *,
                         link );

            <span class="enscript-comment">// wake the waiting thread
</span>            IOLockWakeup( gArbitrationLockQueueLock,
                          element,
                          <span class="enscript-comment">/* one thread */</span> true );
        }
    }

    <span class="enscript-comment">// unlock global access
</span>    IOUnlock( gArbitrationLockQueueLock );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::applyToProviders</span>( IOServiceApplierFunction applier,
                                  <span class="enscript-type">void</span> * context )
{
    applyToParents( (IORegistryEntryApplierFunction) applier,
                    context, gIOServicePlane );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::applyToClients</span>( IOServiceApplierFunction applier,
                                <span class="enscript-type">void</span> * context )
{
    applyToChildren( (IORegistryEntryApplierFunction) applier,
                     context, gIOServicePlane );
}


<span class="enscript-comment">/*
 * Client messages
 */</span>


<span class="enscript-comment">// send a message to a client or interested party of this service
</span>IOReturn <span class="enscript-function-name">IOService::messageClient</span>( UInt32 type, OSObject * client,
                                   <span class="enscript-type">void</span> * argument, vm_size_t argSize )
{
    IOReturn 				ret;
    IOService * 			service;
    _IOServiceInterestNotifier *	notify;

    <span class="enscript-keyword">if</span>( (service = OSDynamicCast( IOService, client)))
        ret = service-&gt;message( type, <span class="enscript-keyword">this</span>, argument );
    
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (notify = OSDynamicCast( _IOServiceInterestNotifier, client))) {

        _IOServiceNotifierInvocation invocation;
        <span class="enscript-type">bool</span>			 willNotify;
    
        invocation.thread = current_thread();
    
        LOCKWRITENOTIFY();
        willNotify = (0 != (kIOServiceNotifyEnable &amp; notify-&gt;state));
    
        <span class="enscript-keyword">if</span>( willNotify) {
            queue_enter( &amp;notify-&gt;handlerInvocations, &amp;invocation,
                            _IOServiceNotifierInvocation *, link );
        }
        UNLOCKNOTIFY();
    
        <span class="enscript-keyword">if</span>( willNotify) {

            ret = (*notify-&gt;handler)( notify-&gt;target, notify-&gt;ref,
                                          type, <span class="enscript-keyword">this</span>, argument, argSize );
    
            LOCKWRITENOTIFY();
            queue_remove( &amp;notify-&gt;handlerInvocations, &amp;invocation,
                            _IOServiceNotifierInvocation *, link );
            <span class="enscript-keyword">if</span>( kIOServiceNotifyWaiter &amp; notify-&gt;state) {
                notify-&gt;state &amp;= ~kIOServiceNotifyWaiter;
                WAKEUPNOTIFY( notify );
            }
            UNLOCKNOTIFY();

        } <span class="enscript-keyword">else</span>
            ret = kIOReturnSuccess;

    } <span class="enscript-keyword">else</span>
        ret = kIOReturnBadArgument;

    <span class="enscript-keyword">return</span>( ret );
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">applyToInterestNotifiers</span>(<span class="enscript-type">const</span> IORegistryEntry *target,
			 <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
			 OSObjectApplierFunction applier,
			 <span class="enscript-type">void</span> * context )
{
    OSArray *		copyArray = 0;

    LOCKREADNOTIFY();

    IOCommand *notifyList =
	OSDynamicCast( IOCommand, target-&gt;getProperty( typeOfInterest ));

    <span class="enscript-keyword">if</span>( notifyList) {
        copyArray = OSArray::withCapacity(1);

	<span class="enscript-comment">// iterate over queue, entry is set to each element in the list
</span>	iterqueue(&amp;notifyList-&gt;fCommandChain, entry) {
	    _IOServiceInterestNotifier * notify;

	    queue_element(entry, notify, _IOServiceInterestNotifier *, chain);
	    copyArray-&gt;setObject(notify);
	}
    }
    UNLOCKNOTIFY();

    <span class="enscript-keyword">if</span>( copyArray) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	index;
	OSObject *	next;

	<span class="enscript-keyword">for</span>( index = 0; (next = copyArray-&gt;getObject( index )); index++)
	    (*applier)(next, context);
	copyArray-&gt;release();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::applyToInterested</span>( <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                                   OSObjectApplierFunction applier,
                                   <span class="enscript-type">void</span> * context )
{
    <span class="enscript-keyword">if</span> (gIOGeneralInterest == typeOfInterest)
	applyToClients( (IOServiceApplierFunction) applier, context );
    applyToInterestNotifiers(<span class="enscript-keyword">this</span>, typeOfInterest, applier, context);
}

<span class="enscript-type">struct</span> MessageClientsContext {
    IOService *	service;
    UInt32	type;
    <span class="enscript-type">void</span> *	argument;
    vm_size_t	argSize;
    IOReturn	ret;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">messageClientsApplier</span>( OSObject * object, <span class="enscript-type">void</span> * ctx )
{
    IOReturn		    ret;
    MessageClientsContext * context = (MessageClientsContext *) ctx;

    ret = context-&gt;service-&gt;messageClient( context-&gt;type,
                                           object, context-&gt;argument, context-&gt;argSize );    
    <span class="enscript-keyword">if</span>( kIOReturnSuccess != ret)
        context-&gt;ret = ret;
}

<span class="enscript-comment">// send a message to all clients
</span>IOReturn <span class="enscript-function-name">IOService::messageClients</span>( UInt32 type,
                                    <span class="enscript-type">void</span> * argument, vm_size_t argSize )
{
    MessageClientsContext	context;

    context.service	= <span class="enscript-keyword">this</span>;
    context.type	= type;
    context.argument	= argument;
    context.argSize	= argSize;
    context.ret		= kIOReturnSuccess;

    applyToInterested( gIOGeneralInterest,
                       &amp;messageClientsApplier, &amp;context );

    <span class="enscript-keyword">return</span>( context.ret );
}

IOReturn <span class="enscript-function-name">IOService::acknowledgeNotification</span>( IONotificationRef notification,
                                              IOOptionBits response )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported );
}

IONotifier * <span class="enscript-function-name">IOService::registerInterest</span>( <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                  IOServiceInterestHandler handler, <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref )
{
    _IOServiceInterestNotifier * notify = 0;
    IOReturn rc = kIOReturnError;

    notify = <span class="enscript-keyword">new</span> _IOServiceInterestNotifier;
    <span class="enscript-keyword">if</span> (!notify) <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-keyword">if</span>(notify-&gt;init()) {
        rc = registerInterestForNotifer(notify, typeOfInterest,
                              handler, target, ref);
    }

    <span class="enscript-keyword">if</span> (rc != kIOReturnSuccess) {
        notify-&gt;release();
        notify = 0;
    }

    <span class="enscript-keyword">return</span>( notify );
}

IOReturn <span class="enscript-function-name">IOService::registerInterestForNotifer</span>( IONotifier *svcNotify, <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                  IOServiceInterestHandler handler, <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref )
{
    IOReturn rc = kIOReturnSuccess;
    _IOServiceInterestNotifier  *notify = 0;

    <span class="enscript-keyword">if</span>( (typeOfInterest != gIOGeneralInterest)
     &amp;&amp; (typeOfInterest != gIOBusyInterest)
     &amp;&amp; (typeOfInterest != gIOAppPowerStateInterest)
     &amp;&amp; (typeOfInterest != gIOConsoleSecurityInterest)
     &amp;&amp; (typeOfInterest != gIOPriorityPowerStateInterest))
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    <span class="enscript-keyword">if</span> (!svcNotify || !(notify = OSDynamicCast(_IOServiceInterestNotifier, svcNotify)))
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    lockForArbitration();
    <span class="enscript-keyword">if</span>( 0 == (__state[0] &amp; kIOServiceInactiveState)) {

        notify-&gt;handler = handler;
        notify-&gt;target = target;
        notify-&gt;ref = ref;
        notify-&gt;state = kIOServiceNotifyEnable;

        <span class="enscript-comment">////// queue
</span>
        LOCKWRITENOTIFY();

        <span class="enscript-comment">// Get the head of the notifier linked list
</span>        IOCommand * notifyList;
        OSObject  * obj = copyProperty( typeOfInterest );
        <span class="enscript-keyword">if</span> (!(notifyList = OSDynamicCast(IOCommand, obj))) {
            notifyList = OSTypeAlloc(IOCommand);
            <span class="enscript-keyword">if</span> (notifyList) {
                notifyList-&gt;init();
                <span class="enscript-type">bool</span> ok = setProperty( typeOfInterest, notifyList);
                notifyList-&gt;release();
                <span class="enscript-keyword">if</span> (!ok) notifyList = 0;
            }
        }
        <span class="enscript-keyword">if</span> (obj) obj-&gt;release();

        <span class="enscript-keyword">if</span> (notifyList) {
            enqueue(&amp;notifyList-&gt;fCommandChain, &amp;notify-&gt;chain);
            notify-&gt;retain();	<span class="enscript-comment">// ref'ed while in list
</span>        }

        UNLOCKNOTIFY();
    }
    <span class="enscript-keyword">else</span> {
        rc = kIOReturnNotReady;
    }
    unlockForArbitration();

    <span class="enscript-keyword">return</span> rc;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cleanInterestList</span>( OSObject * head )
{
    IOCommand *notifyHead = OSDynamicCast(IOCommand, head);
    <span class="enscript-keyword">if</span> (!notifyHead)
	<span class="enscript-keyword">return</span>;

    LOCKWRITENOTIFY();
    <span class="enscript-keyword">while</span> ( queue_entry_t entry = dequeue(&amp;notifyHead-&gt;fCommandChain) ) {
	queue_next(entry) = queue_prev(entry) = 0;

	_IOServiceInterestNotifier * notify;

	queue_element(entry, notify, _IOServiceInterestNotifier *, chain);
	notify-&gt;release();
    }
    UNLOCKNOTIFY();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::unregisterAllInterest</span>( <span class="enscript-type">void</span> )
{
    cleanInterestList( getProperty( gIOGeneralInterest ));
    cleanInterestList( getProperty( gIOBusyInterest ));
    cleanInterestList( getProperty( gIOAppPowerStateInterest ));
    cleanInterestList( getProperty( gIOPriorityPowerStateInterest ));
    cleanInterestList( getProperty( gIOConsoleSecurityInterest ));
}

<span class="enscript-comment">/*
 * _IOServiceInterestNotifier
 */</span>

<span class="enscript-comment">// wait for all threads, other than the current one,
</span><span class="enscript-comment">//  to exit the handler
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceInterestNotifier::wait</span>()
{
    _IOServiceNotifierInvocation * next;
    <span class="enscript-type">bool</span> doWait;

    <span class="enscript-keyword">do</span> {
        doWait = false;
        queue_iterate( &amp;handlerInvocations, next,
                        _IOServiceNotifierInvocation *, link) {
            <span class="enscript-keyword">if</span>( next-&gt;thread != current_thread() ) {
                doWait = true;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">if</span>( doWait) {
            state |= kIOServiceNotifyWaiter;
	       SLEEPNOTIFY(<span class="enscript-keyword">this</span>);
        }

    } <span class="enscript-keyword">while</span>( doWait );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceInterestNotifier::free</span>()
{
    assert( queue_empty( &amp;handlerInvocations ));
    <span class="enscript-reference">OSObject</span>::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceInterestNotifier::remove</span>()
{
    LOCKWRITENOTIFY();

    <span class="enscript-keyword">if</span>( queue_next( &amp;chain )) {
	remqueue(&amp;chain);
	queue_next( &amp;chain) = queue_prev( &amp;chain) = 0;
	release();
    }

    state &amp;= ~kIOServiceNotifyEnable;

    wait();

    UNLOCKNOTIFY();
    
    release();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">_IOServiceInterestNotifier::disable</span>()
{
    <span class="enscript-type">bool</span>	ret;

    LOCKWRITENOTIFY();

    ret = (0 != (kIOServiceNotifyEnable &amp; state));
    state &amp;= ~kIOServiceNotifyEnable;
    <span class="enscript-keyword">if</span>( ret)
        wait();

    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( ret );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceInterestNotifier::enable</span>( <span class="enscript-type">bool</span> was )
{
    LOCKWRITENOTIFY();
    <span class="enscript-keyword">if</span>( was)
        state |= kIOServiceNotifyEnable;
    <span class="enscript-keyword">else</span>
        state &amp;= ~kIOServiceNotifyEnable;
    UNLOCKNOTIFY();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">_IOServiceInterestNotifier::init</span>()
{
    queue_init( &amp;handlerInvocations );
    <span class="enscript-keyword">return</span> (OSObject::init());
}
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/*
 * Termination
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">tailQ</span>(o)		setObject(o)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">headQ</span>(o)		setObject(0, o)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TLOG</span>(fmt, args...)  	{ if(kIOLogYield &amp; gIOKitDebug) { IOLog(<span class="enscript-string">&quot;[%llx] &quot;</span>, thread_tid(current_thread())); IOLog(fmt, ## args); }}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_workLoopAction</span>( IOWorkLoop::Action action,
                             IOService * service,
                             <span class="enscript-type">void</span> * p0 = 0, <span class="enscript-type">void</span> * p1 = 0,
                             <span class="enscript-type">void</span> * p2 = 0, <span class="enscript-type">void</span> * p3 = 0 )
{
    IOWorkLoop * wl;

    <span class="enscript-keyword">if</span>( (wl = service-&gt;getWorkLoop())) {
        wl-&gt;retain();
        wl-&gt;runAction( action, service, p0, p1, p2, p3 );
        wl-&gt;release();
    } <span class="enscript-keyword">else</span>
        (*action)( service, p0, p1, p2, p3 );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::requestTerminate</span>( IOService * provider, IOOptionBits options )
{
    <span class="enscript-type">bool</span> ok;

    <span class="enscript-comment">// if its our only provider
</span>    ok = isParent( provider, gIOServicePlane, true);

    <span class="enscript-comment">// -- compat
</span>    <span class="enscript-keyword">if</span>( ok) {
        provider-&gt;terminateClient( <span class="enscript-keyword">this</span>, options | kIOServiceRecursing );
        ok = (0 != (kIOServiceInactiveState &amp; __state[0]));
    }
    <span class="enscript-comment">// --
</span>
    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::terminatePhase1</span>( IOOptionBits options )
{
    IOService *	 victim;
    IOService *	 client;
    OSIterator * iter;
    OSArray *	 makeInactive;
    OSArray *	 waitingInactive;
    <span class="enscript-type">int</span>          waitResult = THREAD_AWAKENED;
    <span class="enscript-type">bool</span>         wait;
    <span class="enscript-type">bool</span>		 ok;
    <span class="enscript-type">bool</span>		 didInactive;
    <span class="enscript-type">bool</span>		 startPhase2 = false;

    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::terminatePhase1(%08llx)\n&quot;</span>, getName(), getRegistryEntryID(), (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);

    uint64_t regID = getRegistryEntryID();
    IOServiceTrace(
	IOSERVICE_TERMINATE_PHASE1,
	(uintptr_t) regID, 
	(uintptr_t) (regID &gt;&gt; 32),
	(uintptr_t) <span class="enscript-keyword">this</span>,
	(uintptr_t) options);

    <span class="enscript-comment">// -- compat
</span>    <span class="enscript-keyword">if</span>( options &amp; kIOServiceRecursing) {
        lockForArbitration();
	<span class="enscript-keyword">if</span> (0 == (kIOServiceInactiveState &amp; __state[0]))
	{
	    __state[0] |= kIOServiceInactiveState;
	    __state[1] |= kIOServiceRecursing | kIOServiceTermPhase1State;
	}
        unlockForArbitration();

        <span class="enscript-keyword">return</span>( true );
    }
    <span class="enscript-comment">// -- 
</span>
    makeInactive    = OSArray::withCapacity( 16 );
    waitingInactive = OSArray::withCapacity( 16 );
    <span class="enscript-keyword">if</span>(!makeInactive || !waitingInactive) <span class="enscript-keyword">return</span>( false );

    victim = <span class="enscript-keyword">this</span>;
    victim-&gt;retain();

    <span class="enscript-keyword">while</span>( victim )
    {
	didInactive = victim-&gt;lockForArbitration( true );
        <span class="enscript-keyword">if</span>( didInactive)
        {
	    uint64_t regID1 = victim-&gt;getRegistryEntryID();
	    IOServiceTrace(IOSERVICE_TERM_SET_INACTIVE,
		(uintptr_t) regID1, 
		(uintptr_t) (regID1 &gt;&gt; 32),
		(uintptr_t) victim-&gt;__state[1], 
		(uintptr_t) 0);

	    <span class="enscript-type">enum</span> { kRP1 = kIOServiceRecursing | kIOServiceTermPhase1State };
            didInactive = (kRP1 == (victim-&gt;__state[1] &amp; kRP1))
                        || (0 == (victim-&gt;__state[0] &amp; kIOServiceInactiveState));

	    <span class="enscript-keyword">if</span> (!didInactive)
	    {
		<span class="enscript-comment">// a multiply attached IOService can be visited twice
</span>		<span class="enscript-keyword">if</span> (-1U == waitingInactive-&gt;getNextIndexOfObject(victim, 0)) <span class="enscript-keyword">do</span>
		{
		    IOLockLock(gIOServiceBusyLock);
		    wait = (victim-&gt;__state[1] &amp; kIOServiceTermPhase1State);
		    <span class="enscript-keyword">if</span>( wait) {
			TLOG(<span class="enscript-string">&quot;%s[0x%qx]::waitPhase1(%s[0x%qx])\n&quot;</span>, 
			    getName(), getRegistryEntryID(), victim-&gt;getName(), victim-&gt;getRegistryEntryID());
			victim-&gt;__state[1] |= kIOServiceTerm1WaiterState;
			victim-&gt;unlockForArbitration();
			assert_wait((event_t)&amp;victim-&gt;__state[1], THREAD_UNINT);
		    }
		    IOLockUnlock(gIOServiceBusyLock);
		    <span class="enscript-keyword">if</span>( wait) {
			waitResult = thread_block(THREAD_CONTINUE_NULL);
			TLOG(<span class="enscript-string">&quot;%s[0x%qx]::did waitPhase1(%s[0x%qx])\n&quot;</span>, 
			    getName(), getRegistryEntryID(), victim-&gt;getName(), victim-&gt;getRegistryEntryID());
			victim-&gt;lockForArbitration();
		    }
		}
		<span class="enscript-keyword">while</span> (wait &amp;&amp; (waitResult != THREAD_TIMED_OUT));
	    }
	    <span class="enscript-keyword">else</span>
	    {
		victim-&gt;__state[0] |= kIOServiceInactiveState;
		victim-&gt;__state[0] &amp;= ~(kIOServiceRegisteredState | kIOServiceMatchedState
					| kIOServiceFirstPublishState | kIOServiceFirstMatchState);
		victim-&gt;__state[1] &amp;= ~kIOServiceRecursing;
		victim-&gt;__state[1] |= kIOServiceTermPhase1State;
		waitingInactive-&gt;headQ(victim);
		<span class="enscript-keyword">if</span> (victim == <span class="enscript-keyword">this</span>)
		{
		    <span class="enscript-keyword">if</span> (kIOServiceTerminateNeedWillTerminate &amp; options)
		    {
			victim-&gt;__state[1] |= kIOServiceNeedWillTerminate;
		    }
		}
		victim-&gt;_adjustBusy( 1 );
	    }
	    victim-&gt;unlockForArbitration();
        }
        <span class="enscript-keyword">if</span>( victim == <span class="enscript-keyword">this</span>) startPhase2 = didInactive;
        <span class="enscript-keyword">if</span> (didInactive)
        {
            victim-&gt;deliverNotification( gIOTerminatedNotification, 0, 0xffffffff );
            <span class="enscript-reference">IOUserClient</span>::destroyUserReferences( victim );

            iter = victim-&gt;getClientIterator();
            <span class="enscript-keyword">if</span>( iter) {
                <span class="enscript-keyword">while</span>( (client = (IOService *) iter-&gt;getNextObject())) {
                    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::requestTerminate(%s[0x%qx], %08llx)\n&quot;</span>,
                            client-&gt;getName(), client-&gt;getRegistryEntryID(),
                            victim-&gt;getName(), victim-&gt;getRegistryEntryID(), (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
                    ok = client-&gt;requestTerminate( victim, options );
                    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::requestTerminate(%s[0x%qx], ok = %d)\n&quot;</span>,
                            client-&gt;getName(), client-&gt;getRegistryEntryID(),
                            victim-&gt;getName(), victim-&gt;getRegistryEntryID(), ok);

		    uint64_t regID1 = client-&gt;getRegistryEntryID();
		    uint64_t regID2 = victim-&gt;getRegistryEntryID();
		    IOServiceTrace(
			(ok ? IOSERVICE_TERMINATE_REQUEST_OK
			   : IOSERVICE_TERMINATE_REQUEST_FAIL),
			(uintptr_t) regID1, 
			(uintptr_t) (regID1 &gt;&gt; 32),
			(uintptr_t) regID2, 
			(uintptr_t) (regID2 &gt;&gt; 32));

                    <span class="enscript-keyword">if</span>( ok)
                        makeInactive-&gt;setObject( client );
                }
                iter-&gt;release();
            }
        }
        victim-&gt;release();
        victim = (IOService *) makeInactive-&gt;getObject(0);
        <span class="enscript-keyword">if</span>( victim) {
            victim-&gt;retain();
            makeInactive-&gt;removeObject(0);
        }
    }
    makeInactive-&gt;release();

    <span class="enscript-keyword">while</span> ((victim = (IOService *) waitingInactive-&gt;getObject(0)))
    {
	victim-&gt;retain();
	waitingInactive-&gt;removeObject(0);

	victim-&gt;lockForArbitration();
	victim-&gt;__state[1] &amp;= ~kIOServiceTermPhase1State;
	<span class="enscript-keyword">if</span> (kIOServiceTerm1WaiterState &amp; victim-&gt;__state[1])
	{
	    victim-&gt;__state[1] &amp;= ~kIOServiceTerm1WaiterState;
	    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::wakePhase1\n&quot;</span>, victim-&gt;getName(), victim-&gt;getRegistryEntryID());
	    IOLockLock( gIOServiceBusyLock );
	    thread_wakeup( (event_t) &amp;victim-&gt;__state[1]);
	    IOLockUnlock( gIOServiceBusyLock );
	}
	victim-&gt;unlockForArbitration();
        victim-&gt;release();
    }
    waitingInactive-&gt;release();

    <span class="enscript-keyword">if</span>( startPhase2)
    {
        retain();
	lockForArbitration();
	scheduleTerminatePhase2(options);
	unlockForArbitration();
        release();
    }

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setTerminateDefer</span>(IOService * provider, <span class="enscript-type">bool</span> defer)
{
    lockForArbitration();
    <span class="enscript-keyword">if</span> (defer)	__state[1] |= kIOServiceStartState;
    <span class="enscript-keyword">else</span>	__state[1] &amp;= ~kIOServiceStartState;
    unlockForArbitration();

    <span class="enscript-keyword">if</span> (provider &amp;&amp; !defer)
    {
    	provider-&gt;lockForArbitration();
	provider-&gt;scheduleTerminatePhase2();
        provider-&gt;unlockForArbitration();
    }
}

<span class="enscript-comment">// call with lockForArbitration
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IOService::scheduleTerminatePhase2</span>( IOOptionBits options )
{
    AbsoluteTime	deadline;
    uint64_t		regID1;
    <span class="enscript-type">int</span>			waitResult = THREAD_AWAKENED;
    <span class="enscript-type">bool</span>		wait, haveDeadline = false;

    <span class="enscript-keyword">if</span> (!(__state[0] &amp; kIOServiceInactiveState)) <span class="enscript-keyword">return</span>;

    regID1 = getRegistryEntryID();
    IOServiceTrace(
	IOSERVICE_TERM_SCHED_PHASE2,
	(uintptr_t) regID1,
	(uintptr_t) (regID1 &gt;&gt; 32),
	(uintptr_t) __state[1],
	(uintptr_t) options);

    <span class="enscript-keyword">if</span> (__state[1] &amp; kIOServiceTermPhase1State)		<span class="enscript-keyword">return</span>;

    retain();
    unlockForArbitration();
    options |= kIOServiceRequired;
    IOLockLock( gJobsLock );

    <span class="enscript-keyword">if</span>( (options &amp; kIOServiceSynchronous)
        &amp;&amp; (current_thread() != gIOTerminateThread)) {

        <span class="enscript-keyword">do</span> {
            wait = (gIOTerminateThread != 0);
            <span class="enscript-keyword">if</span>( wait) {
                <span class="enscript-comment">// wait to become the terminate thread
</span>                IOLockSleep( gJobsLock, &amp;gIOTerminateThread, THREAD_UNINT);
            }
        } <span class="enscript-keyword">while</span>( wait );

        gIOTerminateThread = current_thread();
        gIOTerminatePhase2List-&gt;setObject( <span class="enscript-keyword">this</span> );
        gIOTerminateWork++;

        <span class="enscript-keyword">do</span> {
	    <span class="enscript-keyword">while</span>( gIOTerminateWork )
		terminateWorker( options );
            wait = (0 != (__state[1] &amp; kIOServiceBusyStateMask));
            <span class="enscript-keyword">if</span>( wait) {
                <span class="enscript-comment">// wait for the victim to go non-busy
</span>                <span class="enscript-keyword">if</span>( !haveDeadline) {
                    clock_interval_to_deadline( 15, kSecondScale, &amp;deadline );
                    haveDeadline = true;
                }
                waitResult = IOLockSleepDeadline( gJobsLock, &amp;gIOTerminateWork,
                                                  deadline, THREAD_UNINT );
                <span class="enscript-keyword">if</span>( waitResult == THREAD_TIMED_OUT) {
                    IOLog(<span class="enscript-string">&quot;%s[0x%qx]::terminate(kIOServiceSynchronous) timeout\n&quot;</span>, getName(), getRegistryEntryID());
		}
            }
        } <span class="enscript-keyword">while</span>(gIOTerminateWork || (wait &amp;&amp; (waitResult != THREAD_TIMED_OUT)));

	gIOTerminateThread = 0;
	IOLockWakeup( gJobsLock, (event_t) &amp;gIOTerminateThread, <span class="enscript-comment">/* one-thread */</span> false);

    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">// ! kIOServiceSynchronous
</span>
        gIOTerminatePhase2List-&gt;setObject( <span class="enscript-keyword">this</span> );
        <span class="enscript-keyword">if</span>( 0 == gIOTerminateWork++) {
	    <span class="enscript-keyword">if</span>( !gIOTerminateThread)
		kernel_thread_start(&amp;terminateThread, (<span class="enscript-type">void</span> *)(uintptr_t) options, &amp;gIOTerminateThread);
	    <span class="enscript-keyword">else</span>
		IOLockWakeup(gJobsLock, (event_t) &amp;gIOTerminateWork, <span class="enscript-comment">/* one-thread */</span> false );
	}
    }

    IOLockUnlock( gJobsLock );
    lockForArbitration();
    release();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::terminateThread</span>( <span class="enscript-type">void</span> * arg, wait_result_t waitResult )
{
    IOLockLock( gJobsLock );

    <span class="enscript-keyword">while</span> (gIOTerminateWork)
	terminateWorker( (uintptr_t) arg );

    thread_deallocate(gIOTerminateThread);
    gIOTerminateThread = 0;
    IOLockWakeup( gJobsLock, (event_t) &amp;gIOTerminateThread, <span class="enscript-comment">/* one-thread */</span> false);

    IOLockUnlock( gJobsLock );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::scheduleStop</span>( IOService * provider )
{
    uint64_t regID1 = getRegistryEntryID();
    uint64_t regID2 = provider-&gt;getRegistryEntryID();

    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::scheduleStop(%s[0x%qx])\n&quot;</span>, getName(), regID1, provider-&gt;getName(), regID2);
    IOServiceTrace(
	IOSERVICE_TERMINATE_SCHEDULE_STOP,
	(uintptr_t) regID1, 
	(uintptr_t) (regID1 &gt;&gt; 32),
	(uintptr_t) regID2, 
	(uintptr_t) (regID2 &gt;&gt; 32));

    IOLockLock( gJobsLock );
    gIOStopList-&gt;tailQ( <span class="enscript-keyword">this</span> );
    gIOStopProviderList-&gt;tailQ( provider );

    <span class="enscript-keyword">if</span>( 0 == gIOTerminateWork++) {
        <span class="enscript-keyword">if</span>( !gIOTerminateThread)
	    kernel_thread_start(&amp;terminateThread, (<span class="enscript-type">void</span> *) 0, &amp;gIOTerminateThread);
        <span class="enscript-keyword">else</span>
            IOLockWakeup(gJobsLock, (event_t) &amp;gIOTerminateWork, <span class="enscript-comment">/* one-thread */</span> false );
    }

    IOLockUnlock( gJobsLock );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::scheduleFinalize</span>( <span class="enscript-type">void</span> )
{
    uint64_t regID1 = getRegistryEntryID();

    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::scheduleFinalize\n&quot;</span>, getName(), regID1);
    IOServiceTrace(
	IOSERVICE_TERMINATE_SCHEDULE_FINALIZE,
	(uintptr_t) regID1, 
	(uintptr_t) (regID1 &gt;&gt; 32),
	0, 0);

    IOLockLock( gJobsLock );
    gIOFinalizeList-&gt;tailQ( <span class="enscript-keyword">this</span> );

    <span class="enscript-keyword">if</span>( 0 == gIOTerminateWork++) {
        <span class="enscript-keyword">if</span>( !gIOTerminateThread)
	    kernel_thread_start(&amp;terminateThread, (<span class="enscript-type">void</span> *) 0, &amp;gIOTerminateThread);
        <span class="enscript-keyword">else</span>
            IOLockWakeup(gJobsLock, (event_t) &amp;gIOTerminateWork, <span class="enscript-comment">/* one-thread */</span> false );
    }

    IOLockUnlock( gJobsLock );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::willTerminate</span>( IOService * provider, IOOptionBits options )
{
    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::didTerminate</span>( IOService * provider, IOOptionBits options, <span class="enscript-type">bool</span> * defer )
{
    <span class="enscript-keyword">if</span>( false == *defer) {

        <span class="enscript-keyword">if</span>( lockForArbitration( true )) {
            <span class="enscript-keyword">if</span>( false == provider-&gt;handleIsOpen( <span class="enscript-keyword">this</span> ))
                scheduleStop( provider );
            <span class="enscript-comment">// -- compat
</span>            <span class="enscript-keyword">else</span> {
                message( kIOMessageServiceIsRequestingClose, provider, (<span class="enscript-type">void</span> *)(uintptr_t) options );
                <span class="enscript-keyword">if</span>( false == provider-&gt;handleIsOpen( <span class="enscript-keyword">this</span> ))
                    scheduleStop( provider );
            }
            <span class="enscript-comment">// --
</span>            unlockForArbitration();
        }
    }

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionWillTerminate</span>( IOService * victim, IOOptionBits options, 
				     OSArray * doPhase2List,
				     <span class="enscript-type">void</span> *unused2 __unused,
				     <span class="enscript-type">void</span> *unused3 __unused  )
{
    OSIterator * iter;
    IOService *	 client;
    <span class="enscript-type">bool</span>	 ok;
    uint64_t     regID1, regID2 = victim-&gt;getRegistryEntryID();

    iter = victim-&gt;getClientIterator();
    <span class="enscript-keyword">if</span>( iter) {
        <span class="enscript-keyword">while</span>( (client = (IOService *) iter-&gt;getNextObject())) {

	    regID1 = client-&gt;getRegistryEntryID();
            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::willTerminate(%s[0x%qx], %08llx)\n&quot;</span>,
                    client-&gt;getName(), regID1, 
                    victim-&gt;getName(), regID2, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
	    IOServiceTrace(
		IOSERVICE_TERMINATE_WILL,
		(uintptr_t) regID1, 
		(uintptr_t) (regID1 &gt;&gt; 32),
		(uintptr_t) regID2, 
		(uintptr_t) (regID2 &gt;&gt; 32));

            ok = client-&gt;willTerminate( victim, options );
            doPhase2List-&gt;tailQ( client );
        }
        iter-&gt;release();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionDidTerminate</span>( IOService * victim, IOOptionBits options,
			    <span class="enscript-type">void</span> *unused1 __unused, <span class="enscript-type">void</span> *unused2 __unused,
			    <span class="enscript-type">void</span> *unused3 __unused )
{
    OSIterator * iter;
    IOService *	 client;
    <span class="enscript-type">bool</span>         defer;
    uint64_t     regID1, regID2 = victim-&gt;getRegistryEntryID();

    victim-&gt;messageClients( kIOMessageServiceIsTerminated, (<span class="enscript-type">void</span> *)(uintptr_t) options );

    iter = victim-&gt;getClientIterator();
    <span class="enscript-keyword">if</span>( iter) {
        <span class="enscript-keyword">while</span>( (client = (IOService *) iter-&gt;getNextObject())) {

	    regID1 = client-&gt;getRegistryEntryID();
            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::didTerminate(%s[0x%qx], %08llx)\n&quot;</span>,
                    client-&gt;getName(), regID1, 
                    victim-&gt;getName(), regID2, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
            defer = false;
            client-&gt;didTerminate( victim, options, &amp;defer );

	    IOServiceTrace(
		(defer ? IOSERVICE_TERMINATE_DID_DEFER
		       : IOSERVICE_TERMINATE_DID),
		(uintptr_t) regID1, 
		(uintptr_t) (regID1 &gt;&gt; 32),
		(uintptr_t) regID2, 
		(uintptr_t) (regID2 &gt;&gt; 32));

            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::didTerminate(%s[0x%qx], defer %d)\n&quot;</span>,
                    client-&gt;getName(), regID1, 
                    victim-&gt;getName(), regID2, defer);
        }
        iter-&gt;release();
    }
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionWillStop</span>( IOService * victim, IOOptionBits options, 
			    <span class="enscript-type">void</span> *unused1 __unused, <span class="enscript-type">void</span> *unused2 __unused,
			    <span class="enscript-type">void</span> *unused3 __unused )
{
    OSIterator * iter;
    IOService *	 provider;
    <span class="enscript-type">bool</span>	 ok;
    uint64_t     regID1, regID2 = victim-&gt;getRegistryEntryID();

    iter = victim-&gt;getProviderIterator();
    <span class="enscript-keyword">if</span>( iter) {
        <span class="enscript-keyword">while</span>( (provider = (IOService *) iter-&gt;getNextObject())) {

	    regID1 = provider-&gt;getRegistryEntryID();
            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::willTerminate(%s[0x%qx], %08llx)\n&quot;</span>,
                    victim-&gt;getName(), regID2, 
                    provider-&gt;getName(), regID1, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
	    IOServiceTrace(
		IOSERVICE_TERMINATE_WILL,
		(uintptr_t) regID2, 
		(uintptr_t) (regID2 &gt;&gt; 32),
		(uintptr_t) regID1, 
		(uintptr_t) (regID1 &gt;&gt; 32));

            ok = victim-&gt;willTerminate( provider, options );
        }
        iter-&gt;release();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionDidStop</span>( IOService * victim, IOOptionBits options,
			    <span class="enscript-type">void</span> *unused1 __unused, <span class="enscript-type">void</span> *unused2 __unused,
			    <span class="enscript-type">void</span> *unused3 __unused )
{
    OSIterator * iter;
    IOService *	 provider;
    <span class="enscript-type">bool</span> defer = false;
    uint64_t     regID1, regID2 = victim-&gt;getRegistryEntryID();

    iter = victim-&gt;getProviderIterator();
    <span class="enscript-keyword">if</span>( iter) {
        <span class="enscript-keyword">while</span>( (provider = (IOService *) iter-&gt;getNextObject())) {

	    regID1 = provider-&gt;getRegistryEntryID();
            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::didTerminate(%s[0x%qx], %08llx)\n&quot;</span>,
                    victim-&gt;getName(), regID2, 
                    provider-&gt;getName(), regID1, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
            victim-&gt;didTerminate( provider, options, &amp;defer );

	    IOServiceTrace(
		(defer ? IOSERVICE_TERMINATE_DID_DEFER
		       : IOSERVICE_TERMINATE_DID),
		(uintptr_t) regID2, 
		(uintptr_t) (regID2 &gt;&gt; 32),
		(uintptr_t) regID1, 
		(uintptr_t) (regID1 &gt;&gt; 32));

            TLOG(<span class="enscript-string">&quot;%s[0x%qx]::didTerminate(%s[0x%qx], defer %d)\n&quot;</span>,
                    victim-&gt;getName(), regID2, 
                    provider-&gt;getName(), regID1, defer);
        }
        iter-&gt;release();
    }
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionFinalize</span>( IOService * victim, IOOptionBits options,
			    <span class="enscript-type">void</span> *unused1 __unused, <span class="enscript-type">void</span> *unused2 __unused,
			    <span class="enscript-type">void</span> *unused3 __unused )
{
    uint64_t regID1 = victim-&gt;getRegistryEntryID();
    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::finalize(%08llx)\n&quot;</span>,  victim-&gt;getName(), regID1, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>)options);
    IOServiceTrace(
	IOSERVICE_TERMINATE_FINALIZE,
	(uintptr_t) regID1, 
	(uintptr_t) (regID1 &gt;&gt; 32),
	0, 0);

    victim-&gt;finalize( options );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::actionStop</span>( IOService * provider, IOService * client,
			    <span class="enscript-type">void</span> *unused1 __unused, <span class="enscript-type">void</span> *unused2 __unused,
			    <span class="enscript-type">void</span> *unused3 __unused )
{
    uint64_t regID1 = provider-&gt;getRegistryEntryID();
    uint64_t regID2 = client-&gt;getRegistryEntryID();

    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::stop(%s[0x%qx])\n&quot;</span>, client-&gt;getName(), regID2, provider-&gt;getName(), regID1);
    IOServiceTrace(
	IOSERVICE_TERMINATE_STOP,
	(uintptr_t) regID1, 
	(uintptr_t) (regID1 &gt;&gt; 32),
	(uintptr_t) regID2, 
	(uintptr_t) (regID2 &gt;&gt; 32));

    client-&gt;stop( provider );
    <span class="enscript-keyword">if</span>( provider-&gt;isOpen( client ))
        provider-&gt;close( client );

    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::detach(%s[0x%qx])\n&quot;</span>, client-&gt;getName(), regID2, provider-&gt;getName(), regID1);
    client-&gt;detach( provider );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::terminateWorker</span>( IOOptionBits options )
{
    OSArray *		doPhase2List;
    OSArray *		didPhase2List;
    OSSet *		freeList;
    OSIterator *        iter;
    UInt32		workDone;
    IOService * 	victim;
    IOService * 	client;
    IOService * 	provider;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	idx;
    <span class="enscript-type">bool</span>		moreToDo;
    <span class="enscript-type">bool</span>		doPhase2;
    <span class="enscript-type">bool</span>		doPhase3;

    options |= kIOServiceRequired;

    doPhase2List  = OSArray::withCapacity( 16 );
    didPhase2List = OSArray::withCapacity( 16 );
    freeList	  = OSSet::withCapacity( 16 );
    <span class="enscript-keyword">if</span>( (0 == doPhase2List) || (0 == didPhase2List) || (0 == freeList))
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">do</span> {
        workDone = gIOTerminateWork;

        <span class="enscript-keyword">while</span>( (victim = (IOService *) gIOTerminatePhase2List-&gt;getObject(0) )) {
    
            victim-&gt;retain();
            gIOTerminatePhase2List-&gt;removeObject(0);
            IOLockUnlock( gJobsLock );

	    uint64_t regID1 = victim-&gt;getRegistryEntryID();
	    IOServiceTrace(
		IOSERVICE_TERM_START_PHASE2,
		(uintptr_t) regID1,
		(uintptr_t) (regID1 &gt;&gt; 32),
		(uintptr_t) 0,
		(uintptr_t) 0);

            <span class="enscript-keyword">while</span>( victim ) {
        
                doPhase2 = victim-&gt;lockForArbitration( true );
                <span class="enscript-keyword">if</span>( doPhase2) {
                    doPhase2 = (0 != (kIOServiceInactiveState &amp; victim-&gt;__state[0]));
                    <span class="enscript-keyword">if</span>( doPhase2) {

			uint64_t regID1 = victim-&gt;getRegistryEntryID();
			IOServiceTrace(
			    IOSERVICE_TERM_TRY_PHASE2,
			    (uintptr_t) regID1,
			    (uintptr_t) (regID1 &gt;&gt; 32),
			    (uintptr_t) victim-&gt;__state[1],
			    (uintptr_t) 0);

                        doPhase2 = (0 == (victim-&gt;__state[1] &amp; kIOServiceTermPhase2State))
                                &amp;&amp; (0 == (victim-&gt;__state[1] &amp; kIOServiceConfigState));

			<span class="enscript-keyword">if</span> (doPhase2 &amp;&amp; (iter = victim-&gt;getClientIterator())) {
			    <span class="enscript-keyword">while</span> (doPhase2 &amp;&amp; (client = (IOService *) iter-&gt;getNextObject())) {
				doPhase2 = (0 == (client-&gt;__state[1] &amp; kIOServiceStartState));
				<span class="enscript-keyword">if</span> (!doPhase2)
				{
				    uint64_t regID1 = client-&gt;getRegistryEntryID();
				    IOServiceTrace(
					IOSERVICE_TERM_UC_DEFER,
					(uintptr_t) regID1,
					(uintptr_t) (regID1 &gt;&gt; 32),
					(uintptr_t) client-&gt;__state[1],
					(uintptr_t) 0);
				    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::defer phase2(%s[0x%qx])\n&quot;</span>,
					   victim-&gt;getName(), victim-&gt;getRegistryEntryID(),
					   client-&gt;getName(), client-&gt;getRegistryEntryID());
				}
			    }
			    iter-&gt;release();
			}
                        <span class="enscript-keyword">if</span>( doPhase2)
                            victim-&gt;__state[1] |= kIOServiceTermPhase2State;
                    }
                    victim-&gt;unlockForArbitration();
                }
                <span class="enscript-keyword">if</span>( doPhase2) {

		    <span class="enscript-keyword">if</span> (kIOServiceNeedWillTerminate &amp; victim-&gt;__state[1]) {
                        _workLoopAction( (IOWorkLoop::Action) &amp;actionWillStop,
                                            victim, (<span class="enscript-type">void</span> *)(uintptr_t) options, NULL );
		    }

                    <span class="enscript-keyword">if</span>( 0 == victim-&gt;getClient()) {
                        <span class="enscript-comment">// no clients - will go to finalize
</span>                        IOLockLock( gJobsLock );
                        gIOFinalizeList-&gt;tailQ( victim );
                        IOLockUnlock( gJobsLock );
                    } <span class="enscript-keyword">else</span> {
                        _workLoopAction( (IOWorkLoop::Action) &amp;actionWillTerminate,
                                            victim, (<span class="enscript-type">void</span> *)(uintptr_t) options, (<span class="enscript-type">void</span> *)(uintptr_t) doPhase2List );
                    }
                    didPhase2List-&gt;headQ( victim );
                }
                victim-&gt;release();
                victim = (IOService *) doPhase2List-&gt;getObject(0);
                <span class="enscript-keyword">if</span>( victim) {
                    victim-&gt;retain();
                    doPhase2List-&gt;removeObject(0);
                }
            }
        
            <span class="enscript-keyword">while</span>( (victim = (IOService *) didPhase2List-&gt;getObject(0)) ) {
    
                <span class="enscript-keyword">if</span>( victim-&gt;lockForArbitration( true )) {
                    victim-&gt;__state[1] |= kIOServiceTermPhase3State;
                    victim-&gt;unlockForArbitration();
                }
                _workLoopAction( (IOWorkLoop::Action) &amp;actionDidTerminate,
                                    victim, (<span class="enscript-type">void</span> *)(uintptr_t) options );
		<span class="enscript-keyword">if</span> (kIOServiceNeedWillTerminate &amp; victim-&gt;__state[1]) {
		    _workLoopAction( (IOWorkLoop::Action) &amp;actionDidStop,
					victim, (<span class="enscript-type">void</span> *)(uintptr_t) options, NULL );
		}
                didPhase2List-&gt;removeObject(0);
            }
            IOLockLock( gJobsLock );
        }

        <span class="enscript-comment">// phase 3
</span>        <span class="enscript-keyword">do</span> {
            doPhase3 = false;
            <span class="enscript-comment">// finalize leaves
</span>            <span class="enscript-keyword">while</span>( (victim = (IOService *) gIOFinalizeList-&gt;getObject(0))) {
    
                IOLockUnlock( gJobsLock );
                _workLoopAction( (IOWorkLoop::Action) &amp;actionFinalize,
                                    victim, (<span class="enscript-type">void</span> *)(uintptr_t) options );
                IOLockLock( gJobsLock );
                <span class="enscript-comment">// hold off free
</span>                freeList-&gt;setObject( victim );
                <span class="enscript-comment">// safe if finalize list is append only
</span>                gIOFinalizeList-&gt;removeObject(0);
            }
        
            <span class="enscript-keyword">for</span>( idx = 0;
                 (!doPhase3) &amp;&amp; (client = (IOService *) gIOStopList-&gt;getObject(idx)); ) {
        
                provider = (IOService *) gIOStopProviderList-&gt;getObject(idx);
                assert( provider );

		uint64_t regID1 = provider-&gt;getRegistryEntryID();
		uint64_t regID2 = client-&gt;getRegistryEntryID();
        
                <span class="enscript-keyword">if</span>( !provider-&gt;isChild( client, gIOServicePlane )) {
                    <span class="enscript-comment">// may be multiply queued - nop it
</span>                    TLOG(<span class="enscript-string">&quot;%s[0x%qx]::nop stop(%s[0x%qx])\n&quot;</span>, client-&gt;getName(), regID2, provider-&gt;getName(), regID1);
		    IOServiceTrace(
			IOSERVICE_TERMINATE_STOP_NOP,
			(uintptr_t) regID1, 
			(uintptr_t) (regID1 &gt;&gt; 32),
			(uintptr_t) regID2, 
			(uintptr_t) (regID2 &gt;&gt; 32));

                } <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">// a terminated client is not ready for stop if it has clients, skip it
</span>                    <span class="enscript-keyword">if</span>( (kIOServiceInactiveState &amp; client-&gt;__state[0]) &amp;&amp; client-&gt;getClient()) {
                        TLOG(<span class="enscript-string">&quot;%s[0x%qx]::defer stop(%s[0x%qx])\n&quot;</span>, 
                        	client-&gt;getName(), regID2, 
                        	client-&gt;getClient()-&gt;getName(), client-&gt;getClient()-&gt;getRegistryEntryID());
			IOServiceTrace(
			    IOSERVICE_TERMINATE_STOP_DEFER,
			    (uintptr_t) regID1, 
			    (uintptr_t) (regID1 &gt;&gt; 32),
			    (uintptr_t) regID2, 
			    (uintptr_t) (regID2 &gt;&gt; 32));

                        idx++;
                        <span class="enscript-keyword">continue</span>;
                    }
        
                    IOLockUnlock( gJobsLock );
                    _workLoopAction( (IOWorkLoop::Action) &amp;actionStop,
                                     provider, (<span class="enscript-type">void</span> *) client );
                    IOLockLock( gJobsLock );
                    <span class="enscript-comment">// check the finalize list now
</span>                    doPhase3 = true;
                }
                <span class="enscript-comment">// hold off free
</span>                freeList-&gt;setObject( client );
                freeList-&gt;setObject( provider );

                <span class="enscript-comment">// safe if stop list is append only
</span>                gIOStopList-&gt;removeObject( idx );
                gIOStopProviderList-&gt;removeObject( idx );
                idx = 0;
            }

        } <span class="enscript-keyword">while</span>( doPhase3 );

        gIOTerminateWork -= workDone;
        moreToDo = (gIOTerminateWork != 0);

        <span class="enscript-keyword">if</span>( !moreToDo) {
            TLOG(<span class="enscript-string">&quot;iokit terminate done, %d stops remain\n&quot;</span>, gIOStopList-&gt;getCount());
	    IOServiceTrace(
		IOSERVICE_TERMINATE_DONE,
		(uintptr_t) gIOStopList-&gt;getCount(), 0, 0, 0);
        }

    } <span class="enscript-keyword">while</span>( moreToDo );

    IOLockUnlock( gJobsLock );

    freeList-&gt;release();
    doPhase2List-&gt;release();
    didPhase2List-&gt;release();

    IOLockLock( gJobsLock );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::finalize</span>( IOOptionBits options )
{
    OSIterator *  iter;
    IOService *	  provider;
    uint64_t      regID1, regID2 = getRegistryEntryID();

    iter = getProviderIterator();
    assert( iter );

    <span class="enscript-keyword">if</span>( iter) {
        <span class="enscript-keyword">while</span>( (provider = (IOService *) iter-&gt;getNextObject())) {

            <span class="enscript-comment">// -- compat
</span>            <span class="enscript-keyword">if</span>( 0 == (__state[1] &amp; kIOServiceTermPhase3State)) {
                <span class="enscript-comment">/* we come down here on programmatic terminate */</span>

		regID1 = provider-&gt;getRegistryEntryID();
		TLOG(<span class="enscript-string">&quot;%s[0x%qx]::stop1(%s[0x%qx])\n&quot;</span>, getName(), regID2, provider-&gt;getName(), regID1);
		IOServiceTrace(
		    IOSERVICE_TERMINATE_STOP,
		    (uintptr_t) regID1, 
		    (uintptr_t) (regID1 &gt;&gt; 32),
		    (uintptr_t) regID2, 
		    (uintptr_t) (regID2 &gt;&gt; 32));

                stop( provider );
                <span class="enscript-keyword">if</span>( provider-&gt;isOpen( <span class="enscript-keyword">this</span> ))
                    provider-&gt;close( <span class="enscript-keyword">this</span> );
                detach( provider );
            } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">//--
</span>                <span class="enscript-keyword">if</span>( provider-&gt;lockForArbitration( true )) {
                    <span class="enscript-keyword">if</span>( 0 == (provider-&gt;__state[1] &amp; kIOServiceTermPhase3State))
                        scheduleStop( provider );
                    provider-&gt;unlockForArbitration();
                }
            }
        }
        iter-&gt;release();
    }

    <span class="enscript-keyword">return</span>( true );
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">tailQ</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">headQ</span>

<span class="enscript-comment">/*
 * Terminate
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::doServiceTerminate</span>( IOOptionBits options )
{
}

<span class="enscript-comment">// a method in case someone needs to override it
</span><span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::terminateClient</span>( IOService * client, IOOptionBits options )
{
    <span class="enscript-type">bool</span> ok;

    <span class="enscript-keyword">if</span>( client-&gt;isParent( <span class="enscript-keyword">this</span>, gIOServicePlane, true))
        <span class="enscript-comment">// we are the clients only provider
</span>        ok = client-&gt;terminate( options );
    <span class="enscript-keyword">else</span>
	ok = true;

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::terminate</span>( IOOptionBits options )
{
    options |= kIOServiceTerminate;

    <span class="enscript-keyword">return</span>( terminatePhase1( options ));
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/*
 * Open &amp; close
 */</span>

<span class="enscript-type">struct</span> ServiceOpenMessageContext
{
    IOService *	 service;
    UInt32	 type;
    IOService *  excludeClient;
    IOOptionBits options;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">serviceOpenMessageApplier</span>( OSObject * object, <span class="enscript-type">void</span> * ctx )
{
    ServiceOpenMessageContext * context = (ServiceOpenMessageContext *) ctx;

    <span class="enscript-keyword">if</span>( object != context-&gt;excludeClient)
        context-&gt;service-&gt;messageClient( context-&gt;type, object, (<span class="enscript-type">void</span> *)(uintptr_t) context-&gt;options );    
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::open</span>( 	IOService *	forClient,
                        IOOptionBits	options,
                        <span class="enscript-type">void</span> *		arg )
{
    <span class="enscript-type">bool</span>			ok;
    ServiceOpenMessageContext	context;

    context.service		= <span class="enscript-keyword">this</span>;
    context.type		= kIOMessageServiceIsAttemptingOpen;
    context.excludeClient	= forClient;
    context.options		= options;

    applyToInterested( gIOGeneralInterest,
                        &amp;serviceOpenMessageApplier, &amp;context );

    <span class="enscript-keyword">if</span>( false == lockForArbitration(false) )
        <span class="enscript-keyword">return</span> false;

    ok = (0 == (__state[0] &amp; kIOServiceInactiveState));
    <span class="enscript-keyword">if</span>( ok)
        ok = handleOpen( forClient, options, arg );

    unlockForArbitration();

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::close</span>( 	IOService *	forClient,
                        IOOptionBits	options )
{
    <span class="enscript-type">bool</span>		wasClosed;
    <span class="enscript-type">bool</span>		last = false;

    lockForArbitration();

    wasClosed = handleIsOpen( forClient );
    <span class="enscript-keyword">if</span>( wasClosed) {
        handleClose( forClient, options );
	last = (__state[1] &amp; kIOServiceTermPhase3State);
    }

    unlockForArbitration();

    <span class="enscript-keyword">if</span>( last)
        forClient-&gt;scheduleStop( <span class="enscript-keyword">this</span> );

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( wasClosed) {

        ServiceOpenMessageContext context;
    
        context.service		= <span class="enscript-keyword">this</span>;
        context.type		= kIOMessageServiceWasClosed;
        context.excludeClient	= forClient;
        context.options		= options;

        applyToInterested( gIOGeneralInterest,
                            &amp;serviceOpenMessageApplier, &amp;context );
    }
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::isOpen</span>( <span class="enscript-type">const</span> IOService * forClient ) <span class="enscript-type">const</span>
{
    IOService *	self = (IOService *) <span class="enscript-keyword">this</span>;
    <span class="enscript-type">bool</span> ok;

    self-&gt;lockForArbitration();

    ok = handleIsOpen( forClient );

    self-&gt;unlockForArbitration();

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::handleOpen</span>( 	IOService *	forClient,
                                IOOptionBits	options,
                                <span class="enscript-type">void</span> *		arg )
{
    <span class="enscript-type">bool</span>	ok;

    ok = (0 == __owner);
    <span class="enscript-keyword">if</span>( ok )
        __owner = forClient;

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( options &amp; kIOServiceSeize ) {
        ok = (kIOReturnSuccess == messageClient( kIOMessageServiceIsRequestingClose,
                                __owner, (<span class="enscript-type">void</span> *)(uintptr_t) options ));
        <span class="enscript-keyword">if</span>( ok &amp;&amp; (0 == __owner ))
            __owner = forClient;
        <span class="enscript-keyword">else</span>
            ok = false;
    }
    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::handleClose</span>( 	IOService *	forClient,
                                IOOptionBits	options )
{
    <span class="enscript-keyword">if</span>( __owner == forClient)
        __owner = 0;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::handleIsOpen</span>( 	<span class="enscript-type">const</span> IOService * forClient ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">if</span>( forClient)
	<span class="enscript-keyword">return</span>( __owner == forClient );
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span>( __owner != forClient );
}

<span class="enscript-comment">/*
 * Probing &amp; starting
 */</span>
<span class="enscript-type">static</span> SInt32 <span class="enscript-function-name">IONotifyOrdering</span>( <span class="enscript-type">const</span> OSMetaClassBase * inObj1, <span class="enscript-type">const</span> OSMetaClassBase * inObj2, <span class="enscript-type">void</span> * ref )
{
    <span class="enscript-type">const</span> _IOServiceNotifier * obj1 = (<span class="enscript-type">const</span> _IOServiceNotifier *) inObj1;
    <span class="enscript-type">const</span> _IOServiceNotifier * obj2 = (<span class="enscript-type">const</span> _IOServiceNotifier *) inObj2;
    SInt32             val1;
    SInt32             val2;

    val1 = 0;
    val2 = 0;

    <span class="enscript-keyword">if</span> ( obj1 )
        val1 = obj1-&gt;priority;

    <span class="enscript-keyword">if</span> ( obj2 )
        val2 = obj2-&gt;priority;

    <span class="enscript-keyword">return</span> ( val1 - val2 );
}

<span class="enscript-type">static</span> SInt32 <span class="enscript-function-name">IOServiceObjectOrder</span>( <span class="enscript-type">const</span> OSObject * entry, <span class="enscript-type">void</span> * ref)
{
    OSDictionary *	dict;
    IOService *		service;
    _IOServiceNotifier * notify;
    OSSymbol *		key = (OSSymbol *) ref;
    OSNumber *		offset;

    <span class="enscript-keyword">if</span>( (dict = OSDynamicCast( OSDictionary, entry)))
        offset = OSDynamicCast(OSNumber, dict-&gt;getObject( key ));
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (notify = OSDynamicCast( _IOServiceNotifier, entry)))
	<span class="enscript-keyword">return</span>( notify-&gt;priority );

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (service = OSDynamicCast( IOService, entry)))
        offset = OSDynamicCast(OSNumber, service-&gt;getProperty( key ));
    <span class="enscript-keyword">else</span> {
	assert( false );
	offset = 0;
    }

    <span class="enscript-keyword">if</span>( offset)
        <span class="enscript-keyword">return</span>( (SInt32) offset-&gt;unsigned32BitValue());
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( kIODefaultProbeScore );
}

SInt32 <span class="enscript-function-name">IOServiceOrdering</span>( <span class="enscript-type">const</span> OSMetaClassBase * inObj1, <span class="enscript-type">const</span> OSMetaClassBase * inObj2, <span class="enscript-type">void</span> * ref )
{
    <span class="enscript-type">const</span> OSObject *	obj1 = (<span class="enscript-type">const</span> OSObject *) inObj1;
    <span class="enscript-type">const</span> OSObject *	obj2 = (<span class="enscript-type">const</span> OSObject *) inObj2;
    SInt32               val1;
    SInt32               val2;

    val1 = 0;
    val2 = 0;

    <span class="enscript-keyword">if</span> ( obj1 )
        val1 = IOServiceObjectOrder( obj1, ref );

    <span class="enscript-keyword">if</span> ( obj2 )
        val2 = IOServiceObjectOrder( obj2, ref );

    <span class="enscript-keyword">return</span> ( val1 - val2 );
}

IOService * <span class="enscript-function-name">IOService::copyClientWithCategory</span>( <span class="enscript-type">const</span> OSSymbol * category )
{
    IOService *		service = 0;
    OSIterator *	iter;
    <span class="enscript-type">const</span> OSSymbol *	nextCat;

    iter = getClientIterator();
    <span class="enscript-keyword">if</span>( iter) {
	<span class="enscript-keyword">while</span>( (service = (IOService *) iter-&gt;getNextObject())) {
	    <span class="enscript-keyword">if</span>( kIOServiceInactiveState &amp; service-&gt;__state[0])
		<span class="enscript-keyword">continue</span>;
            nextCat = (<span class="enscript-type">const</span> OSSymbol *) OSDynamicCast( OSSymbol,
			service-&gt;getProperty( gIOMatchCategoryKey ));
	    <span class="enscript-keyword">if</span>( category == nextCat)
	    {
		service-&gt;retain();
		<span class="enscript-keyword">break</span>;
	    }
	}
	iter-&gt;release();
    }
    <span class="enscript-keyword">return</span>( service );
}

IOService * <span class="enscript-function-name">IOService::getClientWithCategory</span>( <span class="enscript-type">const</span> OSSymbol * category )
{
    IOService *
    service = copyClientWithCategory(category);
    <span class="enscript-keyword">if</span> (service)
	service-&gt;release();
    <span class="enscript-keyword">return</span> (service);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::invokeNotifer</span>( _IOServiceNotifier * notify )
{
    _IOServiceNotifierInvocation invocation;
    <span class="enscript-type">bool</span>			 willNotify;
    <span class="enscript-type">bool</span>			 ret = true;

    invocation.thread = current_thread();

    LOCKWRITENOTIFY();
    willNotify = (0 != (kIOServiceNotifyEnable &amp; notify-&gt;state));

    <span class="enscript-keyword">if</span>( willNotify) {
        queue_enter( &amp;notify-&gt;handlerInvocations, &amp;invocation,
                        _IOServiceNotifierInvocation *, link );
    }
    UNLOCKNOTIFY();

    <span class="enscript-keyword">if</span>( willNotify) {

	ret = (*notify-&gt;handler)(notify-&gt;target, notify-&gt;ref, <span class="enscript-keyword">this</span>, notify);

        LOCKWRITENOTIFY();
        queue_remove( &amp;notify-&gt;handlerInvocations, &amp;invocation,
                        _IOServiceNotifierInvocation *, link );
        <span class="enscript-keyword">if</span>( kIOServiceNotifyWaiter &amp; notify-&gt;state) {
            notify-&gt;state &amp;= ~kIOServiceNotifyWaiter;
            WAKEUPNOTIFY( notify );
        }
        UNLOCKNOTIFY();
    }

    <span class="enscript-keyword">return</span>( ret );
}

<span class="enscript-comment">/*
 * Alloc and probe matching classes,
 * called on the provider instance
 */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::probeCandidates</span>( OSOrderedSet * matches )
{
    OSDictionary 	*	match = 0;
    OSSymbol 		*	symbol;
    IOService 		*	inst;
    IOService 		*	newInst;
    OSDictionary 	*	props;
    SInt32			score;
    OSNumber 		*	newPri;
    OSOrderedSet 	*	familyMatches = 0;
    OSOrderedSet 	*	startList;
    OSDictionary	*	startDict = 0;
    <span class="enscript-type">const</span> OSSymbol	* 	category;
    OSIterator		*	iter;
    _IOServiceNotifier 	*		notify;
    OSObject 		*	nextMatch = 0;
    <span class="enscript-type">bool</span>			started;
    <span class="enscript-type">bool</span>			needReloc = false;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
    SInt64			debugFlags;
#<span class="enscript-reference">endif</span>
    IOService * client = NULL;


    assert( matches );
    <span class="enscript-keyword">while</span>( !needReloc &amp;&amp; (nextMatch = matches-&gt;getFirstObject())) {

        nextMatch-&gt;retain();
        matches-&gt;removeObject(nextMatch);
        
        <span class="enscript-keyword">if</span>( (notify = OSDynamicCast( _IOServiceNotifier, nextMatch ))) {

            lockForArbitration();
            <span class="enscript-keyword">if</span>( 0 == (__state[0] &amp; kIOServiceInactiveState))
                invokeNotifer( notify );
            unlockForArbitration();
            nextMatch-&gt;release();
            nextMatch = 0;
            <span class="enscript-keyword">continue</span>;

        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( !(match = OSDynamicCast( OSDictionary, nextMatch ))) {
            nextMatch-&gt;release();
            nextMatch = 0;
            <span class="enscript-keyword">continue</span>;
	}

	props = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
        debugFlags = getDebugFlags( match );
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">do</span> {
            category = OSDynamicCast( OSSymbol,
			match-&gt;getObject( gIOMatchCategoryKey ));
	    <span class="enscript-keyword">if</span>( 0 == category)
		category = gIODefaultMatchCategoryKey;
	    
	    <span class="enscript-keyword">if</span>( (client = copyClientWithCategory(category)) ) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
		<span class="enscript-keyword">if</span>( (debugFlags &amp; kIOLogMatch) &amp;&amp; (<span class="enscript-keyword">this</span> != gIOResources))
		    LOG(<span class="enscript-string">&quot;%s: match category %s exists\n&quot;</span>, getName(),
				category-&gt;getCStringNoCopy());
#<span class="enscript-reference">endif</span>
                nextMatch-&gt;release();
                nextMatch = 0;

		client-&gt;release();
		client = NULL;

                <span class="enscript-keyword">continue</span>;
	    }

            <span class="enscript-comment">// create a copy now in case its modified during matching
</span>            props = OSDictionary::withDictionary( match, match-&gt;getCount());
            <span class="enscript-keyword">if</span>( 0 == props)
                <span class="enscript-keyword">continue</span>;
	    props-&gt;setCapacityIncrement(1);		

	    <span class="enscript-comment">// check the nub matches
</span>	    <span class="enscript-keyword">if</span>( false == matchPassive(props, kIOServiceChangesOK | kIOServiceClassDone))
		<span class="enscript-keyword">continue</span>;

            <span class="enscript-comment">// Check to see if driver reloc has been loaded.
</span>            needReloc = (false == gIOCatalogue-&gt;isModuleLoaded( match ));
            <span class="enscript-keyword">if</span>( needReloc) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
		<span class="enscript-keyword">if</span>( debugFlags &amp; kIOLogCatalogue)
		    LOG(<span class="enscript-string">&quot;%s: stalling for module\n&quot;</span>, getName());
#<span class="enscript-reference">endif</span>
                <span class="enscript-comment">// If reloc hasn't been loaded, exit;
</span>                <span class="enscript-comment">// reprobing will occur after reloc has been loaded.
</span>                <span class="enscript-keyword">continue</span>;
	    }

            <span class="enscript-comment">// reorder on family matchPropertyTable score.
</span>            <span class="enscript-keyword">if</span>( 0 == familyMatches)
                familyMatches = OSOrderedSet::withCapacity( 1,
                        IOServiceOrdering, (<span class="enscript-type">void</span> *) gIOProbeScoreKey );
            <span class="enscript-keyword">if</span>( familyMatches)
                familyMatches-&gt;setObject( props );

        } <span class="enscript-keyword">while</span>( false );

        <span class="enscript-keyword">if</span> (nextMatch) {
            nextMatch-&gt;release();
            nextMatch = 0;
        }
        <span class="enscript-keyword">if</span>( props)
            props-&gt;release();
    }
    matches-&gt;release();
    matches = 0;

    <span class="enscript-keyword">if</span>( familyMatches) {

        <span class="enscript-keyword">while</span>( !needReloc
             &amp;&amp; (props = (OSDictionary *) familyMatches-&gt;getFirstObject())) {

            props-&gt;retain();
            familyMatches-&gt;removeObject( props );
    
            inst = 0;
            newInst = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
            debugFlags = getDebugFlags( props );
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">do</span> {
                symbol = OSDynamicCast( OSSymbol,
                                props-&gt;getObject( gIOClassKey));
                <span class="enscript-keyword">if</span>( !symbol)
                    <span class="enscript-keyword">continue</span>;
    
                <span class="enscript-comment">//IOLog(&quot;%s alloc (symbol %p props %p)\n&quot;, symbol-&gt;getCStringNoCopy(), OBFUSCATE(symbol), OBFUSCATE(props));
</span>
                <span class="enscript-comment">// alloc the driver instance
</span>                inst = (IOService *) OSMetaClass::allocClassWithName( symbol);
    
                <span class="enscript-keyword">if</span>( !inst) {
                    IOLog(<span class="enscript-string">&quot;Couldn't alloc class \&quot;%s\&quot;\n&quot;</span>,
                        symbol-&gt;getCStringNoCopy());
                    <span class="enscript-keyword">continue</span>;
                }
    
                <span class="enscript-comment">// init driver instance
</span>                <span class="enscript-keyword">if</span>( !(inst-&gt;init( props ))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
                    <span class="enscript-keyword">if</span>( debugFlags &amp; kIOLogStart)
                        IOLog(<span class="enscript-string">&quot;%s::init fails\n&quot;</span>, symbol-&gt;getCStringNoCopy());
#<span class="enscript-reference">endif</span>
                    <span class="enscript-keyword">continue</span>;
                }
                <span class="enscript-keyword">if</span>( __state[1] &amp; kIOServiceSynchronousState)
                    inst-&gt;__state[1] |= kIOServiceSynchronousState;
    
                <span class="enscript-comment">// give the driver the default match category if not specified
</span>                category = OSDynamicCast( OSSymbol,
                            props-&gt;getObject( gIOMatchCategoryKey ));
                <span class="enscript-keyword">if</span>( 0 == category)
                    category = gIODefaultMatchCategoryKey;
                inst-&gt;setProperty( gIOMatchCategoryKey, (OSObject *) category );
                <span class="enscript-comment">// attach driver instance
</span>                <span class="enscript-keyword">if</span>( !(inst-&gt;attach( <span class="enscript-keyword">this</span> )))
                        <span class="enscript-keyword">continue</span>;
    
                <span class="enscript-comment">// pass in score from property table
</span>                score = familyMatches-&gt;orderObject( props );
    
                <span class="enscript-comment">// &amp; probe the new driver instance
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
                <span class="enscript-keyword">if</span>( debugFlags &amp; kIOLogProbe)
                    LOG(<span class="enscript-string">&quot;%s::probe(%s)\n&quot;</span>,
                        inst-&gt;getMetaClass()-&gt;getClassName(), getName());
#<span class="enscript-reference">endif</span>
    
                newInst = inst-&gt;probe( <span class="enscript-keyword">this</span>, &amp;score );
                inst-&gt;detach( <span class="enscript-keyword">this</span> );
                <span class="enscript-keyword">if</span>( 0 == newInst) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
                    <span class="enscript-keyword">if</span>( debugFlags &amp; kIOLogProbe)
                        IOLog(<span class="enscript-string">&quot;%s::probe fails\n&quot;</span>, symbol-&gt;getCStringNoCopy());
#<span class="enscript-reference">endif</span>
                    <span class="enscript-keyword">continue</span>;
                }
    
                <span class="enscript-comment">// save the score
</span>                newPri = OSNumber::withNumber( score, 32 );
                <span class="enscript-keyword">if</span>( newPri) {
                    newInst-&gt;setProperty( gIOProbeScoreKey, newPri );
                    newPri-&gt;release();
                }
    
                <span class="enscript-comment">// add to start list for the match category
</span>                <span class="enscript-keyword">if</span>( 0 == startDict)
                    startDict = OSDictionary::withCapacity( 1 );
                assert( startDict );
                startList = (OSOrderedSet *)
                                startDict-&gt;getObject( category );
                <span class="enscript-keyword">if</span>( 0 == startList) {
                    startList = OSOrderedSet::withCapacity( 1,
                            IOServiceOrdering, (<span class="enscript-type">void</span> *) gIOProbeScoreKey );
                    <span class="enscript-keyword">if</span>( startDict &amp;&amp; startList) {
                        startDict-&gt;setObject( category, startList );
                        startList-&gt;release();
                    }
                }
                assert( startList );
                <span class="enscript-keyword">if</span>( startList)
                    startList-&gt;setObject( newInst );
    
            } <span class="enscript-keyword">while</span>( false );

            props-&gt;release();
            <span class="enscript-keyword">if</span>( inst)
                inst-&gt;release();
        }
        familyMatches-&gt;release();
        familyMatches = 0;
    }

    <span class="enscript-comment">// start the best (until success) of each category
</span>
    iter = OSCollectionIterator::withCollection( startDict );
    <span class="enscript-keyword">if</span>( iter) {
	<span class="enscript-keyword">while</span>( (category = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject())) {

	    startList = (OSOrderedSet *) startDict-&gt;getObject( category );
	    assert( startList );
	    <span class="enscript-keyword">if</span>( !startList)
		<span class="enscript-keyword">continue</span>;

            started = false;
            <span class="enscript-keyword">while</span>( true <span class="enscript-comment">// (!started)
</span>		   &amp;&amp; (inst = (IOService *)startList-&gt;getFirstObject())) {

		inst-&gt;retain();
		startList-&gt;removeObject(inst);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
        	debugFlags = getDebugFlags( inst-&gt;getPropertyTable() );

                <span class="enscript-keyword">if</span>( debugFlags &amp; kIOLogStart) {
                    <span class="enscript-keyword">if</span>( started)
                        LOG( <span class="enscript-string">&quot;match category exists, skipping &quot;</span> );
                    LOG( <span class="enscript-string">&quot;%s::start(%s) &lt;%d&gt;\n&quot;</span>, inst-&gt;getName(),
                         getName(), inst-&gt;getRetainCount());
                }
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">if</span>( false == started)
                    started = startCandidate( inst );
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
                <span class="enscript-keyword">if</span>( (debugFlags &amp; kIOLogStart) &amp;&amp; (false == started))
                    LOG( <span class="enscript-string">&quot;%s::start(%s) &lt;%d&gt; failed\n&quot;</span>, inst-&gt;getName(), getName(),
                         inst-&gt;getRetainCount());
#<span class="enscript-reference">endif</span>
		inst-&gt;release();
            }
        }
	iter-&gt;release();
    }


    <span class="enscript-comment">// adjust the busy count by +1 if matching is stalled for a module,
</span>    <span class="enscript-comment">// or -1 if a previously stalled matching is complete.
</span>    lockForArbitration();
    SInt32 adjBusy = 0;
    uint64_t regID = getRegistryEntryID();

    <span class="enscript-keyword">if</span>( needReloc) {
        adjBusy = (__state[1] &amp; kIOServiceModuleStallState) ? 0 : 1;
        <span class="enscript-keyword">if</span>( adjBusy) {

	    IOServiceTrace(
		IOSERVICE_MODULESTALL,
		(uintptr_t) regID, 
		(uintptr_t) (regID &gt;&gt; 32),
		(uintptr_t) <span class="enscript-keyword">this</span>,
		0);

            __state[1] |= kIOServiceModuleStallState;
	}

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( __state[1] &amp; kIOServiceModuleStallState) {

	    IOServiceTrace(
	    IOSERVICE_MODULEUNSTALL,
	    (uintptr_t) regID, 
	    (uintptr_t) (regID &gt;&gt; 32),
	    (uintptr_t) <span class="enscript-keyword">this</span>,
	    0);

        __state[1] &amp;= ~kIOServiceModuleStallState;
        adjBusy = -1;
    }
    <span class="enscript-keyword">if</span>( adjBusy)
        _adjustBusy( adjBusy );
    unlockForArbitration();

    <span class="enscript-keyword">if</span>( startDict)
	startDict-&gt;release();
}

<span class="enscript-comment">/*
 * Start a previously attached &amp; probed instance,
 * called on exporting object instance
 */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::startCandidate</span>( IOService * service )
{
    <span class="enscript-type">bool</span>		ok;

    ok = service-&gt;attach( <span class="enscript-keyword">this</span> );

    <span class="enscript-keyword">if</span>( ok)
    {
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> != gIOResources)
	{
	    <span class="enscript-comment">// stall for any nub resources
</span>	    checkResources();
	    <span class="enscript-comment">// stall for any driver resources
</span>	    service-&gt;checkResources();
	}
	
	AbsoluteTime startTime;
	AbsoluteTime endTime;
	UInt64       nano;

	<span class="enscript-keyword">if</span> (kIOLogStart &amp; gIOKitDebug)
	    clock_get_uptime(&amp;startTime);

        ok = service-&gt;start(<span class="enscript-keyword">this</span>);

	<span class="enscript-keyword">if</span> (kIOLogStart &amp; gIOKitDebug)
	{
	    clock_get_uptime(&amp;endTime);
    
	    <span class="enscript-keyword">if</span> (CMP_ABSOLUTETIME(&amp;endTime, &amp;startTime) &gt; 0)
	    {
		SUB_ABSOLUTETIME(&amp;endTime, &amp;startTime);
		absolutetime_to_nanoseconds(endTime, &amp;nano);
		<span class="enscript-keyword">if</span> (nano &gt; 500000000ULL)
		    IOLog(<span class="enscript-string">&quot;%s::start took %ld ms\n&quot;</span>, service-&gt;getName(), (<span class="enscript-type">long</span>)(UInt32)(nano / 1000000ULL));
	    }
	}
        <span class="enscript-keyword">if</span>( !ok)
            service-&gt;detach( <span class="enscript-keyword">this</span> );
    }
    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::publishResource</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, OSObject * value )
{
    <span class="enscript-type">const</span> OSSymbol *	sym;

    <span class="enscript-keyword">if</span>( (sym = OSSymbol::withCString( key))) {
        publishResource( sym, value);
	sym-&gt;release();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::publishResource</span>( <span class="enscript-type">const</span> OSSymbol * key, OSObject * value )
{
    <span class="enscript-keyword">if</span>( 0 == value)
	value = (OSObject *) gIOServiceKey;

    gIOResources-&gt;setProperty( key, value);

    <span class="enscript-keyword">if</span>( IORecursiveLockHaveLock( gNotificationLock))
	<span class="enscript-keyword">return</span>;

    gIOResourceGenerationCount++;
    gIOResources-&gt;registerService();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::addNeededResource</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key )
{
    OSObject *	resourcesProp;
    OSSet *	set;
    OSString *	newKey;
    <span class="enscript-type">bool</span> ret;

    resourcesProp = getProperty( gIOResourceMatchKey );

    newKey = OSString::withCString( key );
    <span class="enscript-keyword">if</span>( (0 == resourcesProp) || (0 == newKey))
	<span class="enscript-keyword">return</span>( false);

    set = OSDynamicCast( OSSet, resourcesProp );
    <span class="enscript-keyword">if</span>( !set) {
	set = OSSet::withCapacity( 1 );
	<span class="enscript-keyword">if</span>( set)
            set-&gt;setObject( resourcesProp );
    }
    <span class="enscript-keyword">else</span>
        set-&gt;retain();

    set-&gt;setObject( newKey );
    newKey-&gt;release();
    ret = setProperty( gIOResourceMatchKey, set );
    set-&gt;release();

    <span class="enscript-keyword">return</span>( ret );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::checkResource</span>( OSObject * matching )
{
    OSString *		str;
    OSDictionary *	table;

    <span class="enscript-keyword">if</span>( (str = OSDynamicCast( OSString, matching ))) {
	<span class="enscript-keyword">if</span>( gIOResources-&gt;getProperty( str ))
	    <span class="enscript-keyword">return</span>( true );
    }

    <span class="enscript-keyword">if</span>( str)
	table = resourceMatching( str );
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (table = OSDynamicCast( OSDictionary, matching )))
	table-&gt;retain();
    <span class="enscript-keyword">else</span> {
	IOLog(<span class="enscript-string">&quot;%s: Can't match using: %s\n&quot;</span>, getName(),
		matching-&gt;getMetaClass()-&gt;getClassName());
	<span class="enscript-comment">/* false would stall forever */</span>
	<span class="enscript-keyword">return</span>( true );
    }

    <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogConfig)
        LOG(<span class="enscript-string">&quot;config(%p): stalling %s\n&quot;</span>, OBFUSCATE(IOThreadSelf()), getName());

    waitForService( table );

    <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogConfig)
        LOG(<span class="enscript-string">&quot;config(%p): waking\n&quot;</span>, OBFUSCATE(IOThreadSelf()) );

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::checkResources</span>( <span class="enscript-type">void</span> )
{
    OSObject * 		resourcesProp;
    OSSet *		set;
    OSIterator *	iter;
    <span class="enscript-type">bool</span>		ok;

    resourcesProp = getProperty( gIOResourceMatchKey );
    <span class="enscript-keyword">if</span>( 0 == resourcesProp)
        <span class="enscript-keyword">return</span>( true );

    <span class="enscript-keyword">if</span>( (set = OSDynamicCast( OSSet, resourcesProp ))) {

	iter = OSCollectionIterator::withCollection( set );
	ok = (0 != iter);
        <span class="enscript-keyword">while</span>( ok &amp;&amp; (resourcesProp = iter-&gt;getNextObject()) )
            ok = checkResource( resourcesProp );
	<span class="enscript-keyword">if</span>( iter)
	    iter-&gt;release();

    } <span class="enscript-keyword">else</span>
	ok = checkResource( resourcesProp );

    <span class="enscript-keyword">return</span>( ok );
}


<span class="enscript-type">void</span> <span class="enscript-function-name">_IOConfigThread::configThread</span>( <span class="enscript-type">void</span> )
{
    _IOConfigThread * 	inst;

    <span class="enscript-keyword">do</span> {
	<span class="enscript-keyword">if</span>( !(inst = <span class="enscript-keyword">new</span> _IOConfigThread))
	    <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">if</span>( !inst-&gt;init())
	    <span class="enscript-keyword">continue</span>;
	thread_t unused;
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kernel_thread_start(&amp;_IOConfigThread::main, inst, &amp;unused))
	    <span class="enscript-keyword">continue</span>;

	<span class="enscript-keyword">return</span>;

    } <span class="enscript-keyword">while</span>( false);

    <span class="enscript-keyword">if</span>( inst)
	inst-&gt;release();

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOConfigThread::free</span>( <span class="enscript-type">void</span> )
{
    thread_deallocate(current_thread());
    <span class="enscript-reference">OSObject</span>::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::doServiceMatch</span>( IOOptionBits options )
{
    _IOServiceNotifier * notify;
    OSIterator *	iter;
    OSOrderedSet *	matches;
    SInt32		catalogGeneration;
    <span class="enscript-type">bool</span>		keepGuessing = true;
    <span class="enscript-type">bool</span>		reRegistered = true;
    <span class="enscript-type">bool</span>		didRegister;

<span class="enscript-comment">//    job-&gt;nub-&gt;deliverNotification( gIOPublishNotification,
</span><span class="enscript-comment">//  				kIOServiceRegisteredState, 0xffffffff );
</span>
    <span class="enscript-keyword">while</span>( keepGuessing ) {

        matches = gIOCatalogue-&gt;findDrivers( <span class="enscript-keyword">this</span>, &amp;catalogGeneration );
	<span class="enscript-comment">// the matches list should always be created by findDrivers()
</span>        <span class="enscript-keyword">if</span>( matches) {

            lockForArbitration();
            <span class="enscript-keyword">if</span>( 0 == (__state[0] &amp; kIOServiceFirstPublishState)) {
		getMetaClass()-&gt;addInstance(<span class="enscript-keyword">this</span>);
                deliverNotification( gIOFirstPublishNotification,
                                     kIOServiceFirstPublishState, 0xffffffff );
            }
	    LOCKREADNOTIFY();
            __state[1] &amp;= ~kIOServiceNeedConfigState;
            __state[1] |= kIOServiceConfigState;
            didRegister = (0 == (kIOServiceRegisteredState &amp; __state[0]));
            __state[0] |= kIOServiceRegisteredState;

	    keepGuessing &amp;= (0 == (__state[0] &amp; kIOServiceInactiveState));
            <span class="enscript-keyword">if</span> (reRegistered &amp;&amp; keepGuessing) {
                iter = OSCollectionIterator::withCollection( (OSOrderedSet *)
                        gNotifications-&gt;getObject( gIOPublishNotification ) );
                <span class="enscript-keyword">if</span>( iter) {
                    <span class="enscript-keyword">while</span>((notify = (_IOServiceNotifier *)
                           iter-&gt;getNextObject())) {

                        <span class="enscript-keyword">if</span>( matchPassive(notify-&gt;matching, 0)
                         &amp;&amp; (kIOServiceNotifyEnable &amp; notify-&gt;state))
                            matches-&gt;setObject( notify );
                    }
                    iter-&gt;release();
                }
            }

	    UNLOCKNOTIFY();
            unlockForArbitration();

            <span class="enscript-keyword">if</span> (keepGuessing &amp;&amp; matches-&gt;getCount() &amp;&amp; (kIOReturnSuccess == getResources()))
                probeCandidates( matches );
            <span class="enscript-keyword">else</span>
                matches-&gt;release();
        }

        lockForArbitration();
	reRegistered = (0 != (__state[1] &amp; kIOServiceNeedConfigState));
	keepGuessing =
		   (reRegistered || (catalogGeneration !=
					gIOCatalogue-&gt;getGenerationCount()))
                &amp;&amp; (0 == (__state[0] &amp; kIOServiceInactiveState));

	<span class="enscript-keyword">if</span>( keepGuessing)
            unlockForArbitration();
    }

    <span class="enscript-keyword">if</span>( (0 == (__state[0] &amp; kIOServiceInactiveState))
     &amp;&amp; (0 == (__state[1] &amp; kIOServiceModuleStallState)) ) {
        deliverNotification( gIOMatchedNotification,
		kIOServiceMatchedState, 0xffffffff );
	<span class="enscript-keyword">if</span>( 0 == (__state[0] &amp; kIOServiceFirstMatchState))
	    deliverNotification( gIOFirstMatchNotification,
		kIOServiceFirstMatchState, 0xffffffff );
    }

    __state[1] &amp;= ~kIOServiceConfigState;
    scheduleTerminatePhase2();

    _adjustBusy( -1 );
    unlockForArbitration();
}

UInt32 <span class="enscript-function-name">IOService::_adjustBusy</span>( SInt32 delta )
{
    IOService * next;
    UInt32	count;
    UInt32	result;
    <span class="enscript-type">bool</span>	wasQuiet, nowQuiet, needWake;

    next = <span class="enscript-keyword">this</span>;
    result = __state[1] &amp; kIOServiceBusyStateMask;

    <span class="enscript-keyword">if</span>( delta) <span class="enscript-keyword">do</span> {
        <span class="enscript-keyword">if</span>( next != <span class="enscript-keyword">this</span>)
            next-&gt;lockForArbitration();
        count = next-&gt;__state[1] &amp; kIOServiceBusyStateMask;
        wasQuiet = (0 == count);
	<span class="enscript-keyword">if</span> (((delta &lt; 0) &amp;&amp; wasQuiet) || ((delta &gt; 0) &amp;&amp; (kIOServiceBusyMax == count)))
	    OSReportWithBacktrace(<span class="enscript-string">&quot;%s: bad busy count (%d,%d)\n&quot;</span>, next-&gt;getName(), count, delta);
	<span class="enscript-keyword">else</span>
	    count += delta;
	next-&gt;__state[1] = (next-&gt;__state[1] &amp; ~kIOServiceBusyStateMask) | count;
        nowQuiet = (0 == count);
	needWake = (0 != (kIOServiceBusyWaiterState &amp; next-&gt;__state[1]));

        <span class="enscript-keyword">if</span>( needWake) {
            next-&gt;__state[1] &amp;= ~kIOServiceBusyWaiterState;
            IOLockLock( gIOServiceBusyLock );
	    thread_wakeup( (event_t) next);
            IOLockUnlock( gIOServiceBusyLock );
        }
        <span class="enscript-keyword">if</span>( next != <span class="enscript-keyword">this</span>)
            next-&gt;unlockForArbitration();

        <span class="enscript-keyword">if</span>( (wasQuiet || nowQuiet) ) {

	    uint64_t regID = next-&gt;getRegistryEntryID();
	    IOServiceTrace(
		((wasQuiet<span class="enscript-comment">/*nowBusy*/</span>) ? IOSERVICE_BUSY : IOSERVICE_NONBUSY),
		(uintptr_t) regID, 
		(uintptr_t) (regID &gt;&gt; 32),
		(uintptr_t) next,
		0);

	    <span class="enscript-keyword">if</span> (wasQuiet)
	    {
		next-&gt;__timeBusy = mach_absolute_time();
	    }
	    <span class="enscript-keyword">else</span>
	    {
		next-&gt;__accumBusy += mach_absolute_time() - next-&gt;__timeBusy;
		next-&gt;__timeBusy = 0;
	    }

	    MessageClientsContext context;

	    context.service  = next;
	    context.type     = kIOMessageServiceBusyStateChange;
	    context.argument = (<span class="enscript-type">void</span> *) wasQuiet;	<span class="enscript-comment">/*nowBusy*/</span>
	    context.argSize  = 0;

	    applyToInterestNotifiers( next, gIOBusyInterest, 
				     &amp;messageClientsApplier, &amp;context );

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
            <span class="enscript-keyword">if</span>( nowQuiet &amp;&amp; (next == gIOServiceRoot)) {
                <span class="enscript-reference">OSKext</span>::considerUnloads();
                IOServiceTrace(IOSERVICE_REGISTRY_QUIET, 0, 0, 0, 0);
            }
#<span class="enscript-reference">endif</span>
        }

        delta = nowQuiet ? -1 : +1;

    } <span class="enscript-keyword">while</span>( (wasQuiet || nowQuiet) &amp;&amp; (next = next-&gt;getProvider()));

    <span class="enscript-keyword">return</span>( result );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::adjustBusy</span>( SInt32 delta )
{
    lockForArbitration();
    _adjustBusy( delta );
    unlockForArbitration();
}

uint64_t <span class="enscript-function-name">IOService::getAccumulatedBusyTime</span>( <span class="enscript-type">void</span> )
{
    uint64_t accumBusy = __accumBusy;
    uint64_t timeBusy = __timeBusy;
    uint64_t nano;

    <span class="enscript-keyword">do</span>
    {
	accumBusy = __accumBusy;
	timeBusy  = __timeBusy;
	<span class="enscript-keyword">if</span> (timeBusy)
	    accumBusy += mach_absolute_time() - timeBusy;
    }
    <span class="enscript-keyword">while</span> (timeBusy != __timeBusy);

    absolutetime_to_nanoseconds(*(AbsoluteTime *)&amp;accumBusy, &amp;nano);

    <span class="enscript-keyword">return</span> (nano);
}

UInt32 <span class="enscript-function-name">IOService::getBusyState</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( __state[1] &amp; kIOServiceBusyStateMask );
}

IOReturn <span class="enscript-function-name">IOService::waitForState</span>( UInt32 mask, UInt32 value,
				  mach_timespec_t * timeout )
{
    panic(<span class="enscript-string">&quot;waitForState&quot;</span>);
    <span class="enscript-keyword">return</span> (kIOReturnUnsupported);
}

IOReturn <span class="enscript-function-name">IOService::waitForState</span>( UInt32 mask, UInt32 value,
				   uint64_t timeout )
{
    <span class="enscript-type">bool</span>            wait;
    <span class="enscript-type">int</span>             waitResult = THREAD_AWAKENED;
    <span class="enscript-type">bool</span>            computeDeadline = true;
    AbsoluteTime    abstime;

    <span class="enscript-keyword">do</span> {
        lockForArbitration();
        IOLockLock( gIOServiceBusyLock );
        wait = (value != (__state[1] &amp; mask));
        <span class="enscript-keyword">if</span>( wait) {
            __state[1] |= kIOServiceBusyWaiterState;
            unlockForArbitration();
            <span class="enscript-keyword">if</span>( timeout != UINT64_MAX ) {
                <span class="enscript-keyword">if</span>( computeDeadline ) {
                    AbsoluteTime  nsinterval;
                    nanoseconds_to_absolutetime(timeout, &amp;nsinterval );
                    clock_absolutetime_interval_to_deadline(nsinterval, &amp;abstime);
                    computeDeadline = false;
                }
                assert_wait_deadline((event_t)<span class="enscript-keyword">this</span>, THREAD_UNINT, __OSAbsoluteTime(abstime));
            }
            <span class="enscript-keyword">else</span>
                assert_wait((event_t)<span class="enscript-keyword">this</span>, THREAD_UNINT );
        } <span class="enscript-keyword">else</span>
            unlockForArbitration();
        IOLockUnlock( gIOServiceBusyLock );
        <span class="enscript-keyword">if</span>( wait)
            waitResult = thread_block(THREAD_CONTINUE_NULL);

    } <span class="enscript-keyword">while</span>( wait &amp;&amp; (waitResult != THREAD_TIMED_OUT));

    <span class="enscript-keyword">if</span>( waitResult == THREAD_TIMED_OUT)
        <span class="enscript-keyword">return</span>( kIOReturnTimeout );
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

IOReturn <span class="enscript-function-name">IOService::waitQuiet</span>( uint64_t timeout )
{
    IOReturn ret;
    ret = waitForState( kIOServiceBusyStateMask, 0, timeout );
    <span class="enscript-keyword">if</span> ((kIOReturnTimeout == ret) &amp;&amp; (timeout &gt;= 41000000000) &amp;&amp; (kIOWaitQuietPanics &amp; gIOKitDebug))
    {
	IORegistryIterator * iter;
	OSOrderedSet       * set;
	OSOrderedSet       * leaves;
	IOService          * next;
	IOService          * nextParent;
	<span class="enscript-type">char</span>               * string;
	<span class="enscript-type">char</span>               * s;
	size_t               len, l;

	len = 256;
	string = IONew(<span class="enscript-type">char</span>, len);
	set = NULL;
        iter = IORegistryIterator::iterateOver(<span class="enscript-keyword">this</span>, gIOServicePlane, kIORegistryIterateRecursively);
        leaves = OSOrderedSet::withCapacity(4);
	<span class="enscript-keyword">if</span> (iter) set = iter-&gt;iterateAll();
	<span class="enscript-keyword">if</span> (string &amp;&amp; leaves &amp;&amp; set)
	{
	    <span class="enscript-keyword">while</span> ((next = (IOService *) set-&gt;getLastObject()))
	    {
		<span class="enscript-keyword">if</span> (next-&gt;getBusyState())
		{
		    leaves-&gt;setObject(next);
		    nextParent = next;
		    <span class="enscript-keyword">while</span> ((nextParent = nextParent-&gt;getProvider()))
		    {
			set-&gt;removeObject(nextParent);
			leaves-&gt;removeObject(nextParent);
		    }
		}
		set-&gt;removeObject(next);	    
	    }
	    s = string;
	    <span class="enscript-keyword">while</span> ((next = (IOService *) leaves-&gt;getLastObject()))
	    {
		l = snprintf(s, len, <span class="enscript-string">&quot;%s'%s'&quot;</span>, ((s == string) ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;, &quot;</span>), next-&gt;getName());
		<span class="enscript-keyword">if</span> (l &gt;= len) <span class="enscript-keyword">break</span>;
		s += l;
		len -= l;
		leaves-&gt;removeObject(next);	    
	    }
	}
        panic(<span class="enscript-string">&quot;busy timeout(%llds): %s&quot;</span>, timeout / 1000000000ULL, string ? string : <span class="enscript-string">&quot;&quot;</span>);
    }
    <span class="enscript-keyword">return</span> (ret);
}

IOReturn <span class="enscript-function-name">IOService::waitQuiet</span>( mach_timespec_t * timeout )
{
    uint64_t    timeoutNS;

    <span class="enscript-keyword">if</span> (timeout)
    {
	timeoutNS = timeout-&gt;tv_sec;
	timeoutNS *= kSecondScale;
	timeoutNS += timeout-&gt;tv_nsec;
    }
    <span class="enscript-keyword">else</span>
	timeoutNS = UINT64_MAX;

    <span class="enscript-keyword">return</span> (waitQuiet(timeoutNS));
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::serializeProperties</span>( OSSerialize * s ) <span class="enscript-type">const</span>
{
#<span class="enscript-reference">if</span> 0
    ((IOService *)<span class="enscript-keyword">this</span>)-&gt;setProperty( ((IOService *)<span class="enscript-keyword">this</span>)-&gt;__state,
		<span class="enscript-keyword">sizeof</span>( __state), <span class="enscript-string">&quot;__state&quot;</span>);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span>( super::serializeProperties(s) );
}


<span class="enscript-type">void</span> <span class="enscript-function-name">_IOConfigThread::main</span>(<span class="enscript-type">void</span> * arg, wait_result_t result)
{
    _IOConfigThread * self = (_IOConfigThread *) arg;
    _IOServiceJob * job;
    IOService 	*   nub;
    <span class="enscript-type">bool</span>	    alive = true;
    kern_return_t   kr;
    thread_precedence_policy_data_t precedence = { -1 };

    kr = thread_policy_set(current_thread(), 
			    THREAD_PRECEDENCE_POLICY, 
			    (thread_policy_t) &amp;precedence, 
			    THREAD_PRECEDENCE_POLICY_COUNT);
    <span class="enscript-keyword">if</span> (KERN_SUCCESS != kr)
	IOLog(<span class="enscript-string">&quot;thread_policy_set(%d)\n&quot;</span>, kr);

    <span class="enscript-keyword">do</span> {

<span class="enscript-comment">//	randomDelay();
</span>
        semaphore_wait( gJobsSemaphore );

	IOTakeLock( gJobsLock );
	job = (_IOServiceJob *) gJobs-&gt;getFirstObject();
        job-&gt;retain();
        gJobs-&gt;removeObject(job);
	<span class="enscript-keyword">if</span>( job) {
	    gOutstandingJobs--;
<span class="enscript-comment">//	    gNumConfigThreads--;	// we're out of service
</span>	    gNumWaitingThreads--;	<span class="enscript-comment">// we're out of service
</span>	}
	IOUnlock( gJobsLock );

	<span class="enscript-keyword">if</span>( job) {

	  nub = job-&gt;nub;

          <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogConfig)
            LOG(<span class="enscript-string">&quot;config(%p): starting on %s, %d\n&quot;</span>,
                        OBFUSCATE(IOThreadSelf()), job-&gt;nub-&gt;getName(), job-&gt;type);

	  <span class="enscript-keyword">switch</span>( job-&gt;type) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kMatchNubJob</span>:
		nub-&gt;doServiceMatch( job-&gt;options );
		<span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                LOG(<span class="enscript-string">&quot;config(%p): strange type (%d)\n&quot;</span>,
			OBFUSCATE(IOThreadSelf()), job-&gt;type );
		<span class="enscript-keyword">break</span>;
            }

	    nub-&gt;release();
            job-&gt;release();

            IOTakeLock( gJobsLock );
	    alive = (gOutstandingJobs &gt; gNumWaitingThreads);
	    <span class="enscript-keyword">if</span>( alive)
		gNumWaitingThreads++;	<span class="enscript-comment">// back in service
</span><span class="enscript-comment">//		gNumConfigThreads++;
</span>	    <span class="enscript-keyword">else</span> {
                <span class="enscript-keyword">if</span>( 0 == --gNumConfigThreads) {
<span class="enscript-comment">//                    IOLog(&quot;MATCH IDLE\n&quot;);
</span>                    IOLockWakeup( gJobsLock, (event_t) &amp;gNumConfigThreads, <span class="enscript-comment">/* one-thread */</span> false );
                }
            }
            IOUnlock( gJobsLock );
	}

    } <span class="enscript-keyword">while</span>( alive );

    <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogConfig)
        LOG(<span class="enscript-string">&quot;config(%p): terminating\n&quot;</span>, OBFUSCATE(IOThreadSelf()) );

    self-&gt;release();
}

IOReturn <span class="enscript-function-name">IOService::waitMatchIdle</span>( UInt32 msToWait )
{
    <span class="enscript-type">bool</span>            wait;
    <span class="enscript-type">int</span>             waitResult = THREAD_AWAKENED;
    <span class="enscript-type">bool</span>            computeDeadline = true;
    AbsoluteTime    deadline;

    IOLockLock( gJobsLock );
    <span class="enscript-keyword">do</span> {
        wait = (0 != gNumConfigThreads);
        <span class="enscript-keyword">if</span>( wait) {
            <span class="enscript-keyword">if</span>( msToWait) {
                <span class="enscript-keyword">if</span>( computeDeadline ) {
                    clock_interval_to_deadline(
                          msToWait, kMillisecondScale, &amp;deadline );
                    computeDeadline = false;
                }
			  waitResult = IOLockSleepDeadline( gJobsLock, &amp;gNumConfigThreads,
								deadline, THREAD_UNINT );
	    	   } <span class="enscript-keyword">else</span> {
			  waitResult = IOLockSleep( gJobsLock, &amp;gNumConfigThreads,
								THREAD_UNINT );
	        }
        }
    } <span class="enscript-keyword">while</span>( wait &amp;&amp; (waitResult != THREAD_TIMED_OUT));
	IOLockUnlock( gJobsLock );

    <span class="enscript-keyword">if</span>( waitResult == THREAD_TIMED_OUT)
        <span class="enscript-keyword">return</span>( kIOReturnTimeout );
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::cpusRunning</span>(<span class="enscript-type">void</span>)
{
    gCPUsRunning = true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceJob::pingConfig</span>( _IOServiceJob * job )
{
    <span class="enscript-type">int</span>		count;
    <span class="enscript-type">bool</span>	create;

    assert( job );

    IOTakeLock( gJobsLock );

    gOutstandingJobs++;
    gJobs-&gt;setLastObject( job );

    count = gNumWaitingThreads;
<span class="enscript-comment">//    if( gNumConfigThreads) count++;// assume we're called from a config thread
</span>
    create = (  (gOutstandingJobs &gt; count)
		&amp;&amp; ((gNumConfigThreads &lt; kMaxConfigThreads) 
            || (job-&gt;nub == gIOResources) 
            || !gCPUsRunning));
    <span class="enscript-keyword">if</span>( create) {
	gNumConfigThreads++;
	gNumWaitingThreads++;
    }

    IOUnlock( gJobsLock );

    job-&gt;release();

    <span class="enscript-keyword">if</span>( create) {
        <span class="enscript-keyword">if</span>( gIOKitDebug &amp; kIOLogConfig)
            LOG(<span class="enscript-string">&quot;config(%d): creating\n&quot;</span>, gNumConfigThreads - 1);
        <span class="enscript-reference">_IOConfigThread</span>::configThread();
    }

    semaphore_signal( gJobsSemaphore );
}

<span class="enscript-type">struct</span> IOServiceMatchContext
{
    OSDictionary * table;
    OSObject *     result;
    uint32_t	   options;
    uint32_t	   state;
    uint32_t	   count;
    uint32_t       done;
};

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::instanceMatch</span>(<span class="enscript-type">const</span> OSObject * entry, <span class="enscript-type">void</span> * context)
{
    IOServiceMatchContext * ctx = (typeof(ctx)) context;
    IOService *    service = (typeof(service)) entry;
    OSDictionary * table   = ctx-&gt;table;
    uint32_t	   options = ctx-&gt;options;
    uint32_t	   state   = ctx-&gt;state;
    uint32_t       done;
    <span class="enscript-type">bool</span>           match;

    done = 0;
    <span class="enscript-keyword">do</span>
    {
	match = ((state == (state &amp; service-&gt;__state[0]))
		&amp;&amp; (0 == (service-&gt;__state[0] &amp; kIOServiceInactiveState)));
	<span class="enscript-keyword">if</span> (!match) <span class="enscript-keyword">break</span>;
	ctx-&gt;count += table-&gt;getCount();
        match = service-&gt;matchInternal(table, options, &amp;done);
	ctx-&gt;done += done;
    }
    <span class="enscript-keyword">while</span> (false);
    <span class="enscript-keyword">if</span> (!match)
    	<span class="enscript-keyword">return</span> (false);

    <span class="enscript-keyword">if</span> ((kIONotifyOnce &amp; options) &amp;&amp; (ctx-&gt;done == ctx-&gt;count))
    {
	service-&gt;retain();
	ctx-&gt;result = service;
	<span class="enscript-keyword">return</span> (true);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ctx-&gt;result)
    {
	ctx-&gt;result = OSSet::withObjects((<span class="enscript-type">const</span> OSObject **) &amp;service, 1, 1);
    }
    <span class="enscript-keyword">else</span>
    {
    	((OSSet *)ctx-&gt;result)-&gt;setObject(service);
    }
    <span class="enscript-keyword">return</span> (false);
}

<span class="enscript-comment">// internal - call with gNotificationLock
</span>OSObject * <span class="enscript-function-name">IOService::copyExistingServices</span>( OSDictionary * matching,
		 IOOptionBits inState, IOOptionBits options )
{
    OSObject *	 current = 0;
    OSIterator * iter;
    IOService *	 service;
    OSObject *	 obj;
    OSString *   str;

    <span class="enscript-keyword">if</span>( !matching)
	<span class="enscript-keyword">return</span>( 0 );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MATCH_DEBUG</span>
    OSSerialize * s = OSSerialize::withCapacity(128);
    matching-&gt;serialize(s);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span>((obj = matching-&gt;getObject(gIOProviderClassKey))
      &amp;&amp; gIOResourcesKey
      &amp;&amp; gIOResourcesKey-&gt;isEqualTo(obj)
      &amp;&amp; (service = gIOResources))
    {
	<span class="enscript-keyword">if</span>( (inState == (service-&gt;__state[0] &amp; inState))
	  &amp;&amp; (0 == (service-&gt;__state[0] &amp; kIOServiceInactiveState))
	  &amp;&amp;  service-&gt;matchPassive(matching, options))
	{
	    <span class="enscript-keyword">if</span>( options &amp; kIONotifyOnce)
	    {
		service-&gt;retain();
		current = service;
	    }
	    <span class="enscript-keyword">else</span>
		current = OSSet::withObjects((<span class="enscript-type">const</span> OSObject **) &amp;service, 1, 1 );
	}
    }
    <span class="enscript-keyword">else</span>
    {
    	IOServiceMatchContext ctx;
	ctx.table   = matching;
	ctx.state   = inState;
	ctx.count   = 0;
	ctx.done    = 0;
	ctx.options = options;
	ctx.result  = 0;

	<span class="enscript-keyword">if</span> ((str = OSDynamicCast(OSString, obj)))
	{
	    <span class="enscript-type">const</span> OSSymbol * sym = OSSymbol::withString(str);
	    <span class="enscript-reference">OSMetaClass</span>::applyToInstancesOfClassName(sym, instanceMatch, &amp;ctx);
	    sym-&gt;release();
	}
	<span class="enscript-keyword">else</span>
	{
	    <span class="enscript-reference">IOService</span>::gMetaClass.applyToInstances(instanceMatch, &amp;ctx);
	}


	current = ctx.result;

	options |= kIOServiceInternalDone | kIOServiceClassDone;
	<span class="enscript-keyword">if</span> (current &amp;&amp; (ctx.done != ctx.count))
	{
	    OSSet *
	    source = OSDynamicCast(OSSet, current);
	    current = 0;
	    <span class="enscript-keyword">while</span> ((service = (IOService *) source-&gt;getAnyObject()))
	    {
		<span class="enscript-keyword">if</span> (service-&gt;matchPassive(matching, options))
		{
		    <span class="enscript-keyword">if</span>( options &amp; kIONotifyOnce)
		    {
			service-&gt;retain();
			current = service;
			<span class="enscript-keyword">break</span>;
		    }
		    <span class="enscript-keyword">if</span>( current)
		    {
			((OSSet *)current)-&gt;setObject( service );
		    }
		    <span class="enscript-keyword">else</span>
		    {
			current = OSSet::withObjects(
					(<span class="enscript-type">const</span> OSObject **) &amp;service, 1, 1 );
		    }
		}
		source-&gt;removeObject(service);	    
	    }
	    source-&gt;release();
	}
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MATCH_DEBUG</span>
    {
	OSObject * _current = 0;
    
	iter = IORegistryIterator::iterateOver( gIOServicePlane,
					    kIORegistryIterateRecursively );
	<span class="enscript-keyword">if</span>( iter) {
	    <span class="enscript-keyword">do</span> {
		iter-&gt;reset();
		<span class="enscript-keyword">while</span>( (service = (IOService *) iter-&gt;getNextObject())) {
		    <span class="enscript-keyword">if</span>( (inState == (service-&gt;__state[0] &amp; inState))
		    &amp;&amp; (0 == (service-&gt;__state[0] &amp; kIOServiceInactiveState))
		    &amp;&amp;  service-&gt;matchPassive(matching, 0)) {
    
			<span class="enscript-keyword">if</span>( options &amp; kIONotifyOnce) {
			    service-&gt;retain();
			    _current = service;
			    <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span>( _current)
			    ((OSSet *)_current)-&gt;setObject( service );
			<span class="enscript-keyword">else</span>
			    _current = OSSet::withObjects(
					    (<span class="enscript-type">const</span> OSObject **) &amp;service, 1, 1 );
		    }
		}
	    } <span class="enscript-keyword">while</span>( !service &amp;&amp; !iter-&gt;isValid());
	    iter-&gt;release();
	}


	<span class="enscript-keyword">if</span> ( ((current != 0) != (_current != 0)) 
	|| (current &amp;&amp; _current &amp;&amp; !current-&gt;isEqualTo(_current)))
	{
	    OSSerialize * s1 = OSSerialize::withCapacity(128);
	    OSSerialize * s2 = OSSerialize::withCapacity(128);
	    current-&gt;serialize(s1);
	    _current-&gt;serialize(s2);
	    kprintf(<span class="enscript-string">&quot;**mismatch** %p %p\n%s\n%s\n%s\n&quot;</span>, OBFUSCATE(current), 
                OBFUSCATE(_current), s-&gt;text(), s1-&gt;text(), s2-&gt;text());
	    s1-&gt;release();
	    s2-&gt;release();
	}

	<span class="enscript-keyword">if</span> (_current) _current-&gt;release();
    }    

    s-&gt;release();
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span>( current &amp;&amp; (0 == (options &amp; (kIONotifyOnce | kIOServiceExistingSet)))) {
	iter = OSCollectionIterator::withCollection( (OSSet *)current );
	current-&gt;release();
	current = iter;
    }

    <span class="enscript-keyword">return</span>( current );
}

<span class="enscript-comment">// public version
</span>OSIterator * <span class="enscript-function-name">IOService::getMatchingServices</span>( OSDictionary * matching )
{
    OSIterator *	iter;

    <span class="enscript-comment">// is a lock even needed?
</span>    LOCKWRITENOTIFY();

    iter = (OSIterator *) copyExistingServices( matching,
						kIOServiceMatchedState );
    
    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( iter );
}

IOService * <span class="enscript-function-name">IOService::copyMatchingService</span>( OSDictionary * matching )
{
    IOService *	service;

    <span class="enscript-comment">// is a lock even needed?
</span>    LOCKWRITENOTIFY();

    service = (IOService *) copyExistingServices( matching,
						kIOServiceMatchedState, kIONotifyOnce );
    
    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( service );
}

<span class="enscript-type">struct</span> _IOServiceMatchingNotificationHandlerRef
{
    IOServiceNotificationHandler handler;
    <span class="enscript-type">void</span> * ref;
};

<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">_IOServiceMatchingNotificationHandler</span>( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
						   IOService * newService,
						   IONotifier * notifier )
{
    <span class="enscript-keyword">return</span> ((*((_IOServiceNotifier *) notifier)-&gt;compatHandler)(target, refCon, newService));
}

<span class="enscript-comment">// internal - call with gNotificationLock
</span>IONotifier * <span class="enscript-function-name">IOService::setNotification</span>(
	    <span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
            IOServiceMatchingNotificationHandler handler, <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
            SInt32 priority )
{
    _IOServiceNotifier * notify = 0;
    OSOrderedSet *	set;

    <span class="enscript-keyword">if</span>( !matching)
	<span class="enscript-keyword">return</span>( 0 );

    notify = <span class="enscript-keyword">new</span> _IOServiceNotifier;
    <span class="enscript-keyword">if</span>( notify &amp;&amp; !notify-&gt;init()) {
        notify-&gt;release();
        notify = 0;
    }

    <span class="enscript-keyword">if</span>( notify) {
	notify-&gt;handler = handler;
        notify-&gt;target = target;
        notify-&gt;matching = matching;
	matching-&gt;retain();
	<span class="enscript-keyword">if</span> (handler == &amp;_IOServiceMatchingNotificationHandler)
	{
	    notify-&gt;compatHandler = ((_IOServiceMatchingNotificationHandlerRef *)ref)-&gt;handler;
	    notify-&gt;ref = ((_IOServiceMatchingNotificationHandlerRef *)ref)-&gt;ref;
	}
	<span class="enscript-keyword">else</span>
	    notify-&gt;ref = ref;
        notify-&gt;priority = priority;
	notify-&gt;state = kIOServiceNotifyEnable;
        queue_init( &amp;notify-&gt;handlerInvocations );

        <span class="enscript-comment">////// queue
</span>
        <span class="enscript-keyword">if</span>( 0 == (set = (OSOrderedSet *) gNotifications-&gt;getObject( type ))) {
            set = OSOrderedSet::withCapacity( 1,
			IONotifyOrdering, 0 );
            <span class="enscript-keyword">if</span>( set) {
                gNotifications-&gt;setObject( type, set );
                set-&gt;release();
            }
        }
        notify-&gt;whence = set;
        <span class="enscript-keyword">if</span>( set)
            set-&gt;setObject( notify );
    }

    <span class="enscript-keyword">return</span>( notify );
}

<span class="enscript-comment">// internal - call with gNotificationLock
</span>IONotifier * <span class="enscript-function-name">IOService::doInstallNotification</span>(
			<span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
			IOServiceMatchingNotificationHandler handler,
			<span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
			SInt32 priority, OSIterator ** existing )
{
    OSIterator *	exist;
    IONotifier *	notify;
    IOOptionBits	inState;

    <span class="enscript-keyword">if</span>( !matching)
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( type == gIOPublishNotification)
	inState = kIOServiceRegisteredState;

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( type == gIOFirstPublishNotification)
	inState = kIOServiceFirstPublishState;

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (type == gIOMatchedNotification)
	  || (type == gIOFirstMatchNotification))
	inState = kIOServiceMatchedState;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( type == gIOTerminatedNotification)
	inState = 0;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( 0 );

    notify = setNotification( type, matching, handler, target, ref, priority );
    
    <span class="enscript-keyword">if</span>( inState)
        <span class="enscript-comment">// get the current set
</span>        exist = (OSIterator *) copyExistingServices( matching, inState );
    <span class="enscript-keyword">else</span>
	exist = 0;

    *existing = exist;    

    <span class="enscript-keyword">return</span>( notify );
}

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
IONotifier * <span class="enscript-function-name">IOService::installNotification</span>(<span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
					IOServiceNotificationHandler handler,
					<span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
					SInt32 priority, OSIterator ** existing )
{
    IONotifier * result;
    _IOServiceMatchingNotificationHandlerRef ref;
    ref.handler = handler;
    ref.ref     = refCon;

    result = (_IOServiceNotifier *) installNotification( type, matching,
			 &amp;_IOServiceMatchingNotificationHandler, 
			target, &amp;ref, priority, existing );
    <span class="enscript-keyword">if</span> (result)
	matching-&gt;release();

    <span class="enscript-keyword">return</span> (result);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !defined(__LP64__) */</span>


IONotifier * <span class="enscript-function-name">IOService::installNotification</span>(
			<span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
			IOServiceMatchingNotificationHandler handler,
			<span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
			SInt32 priority, OSIterator ** existing )
{
    IONotifier * notify;

    LOCKWRITENOTIFY();

    notify = doInstallNotification( type, matching, handler, target, ref,
		priority, existing );

    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( notify );
}

IONotifier * <span class="enscript-function-name">IOService::addNotification</span>(
			<span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
			IOServiceNotificationHandler handler,
			<span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
			SInt32 priority )
{
    IONotifier * result;
    _IOServiceMatchingNotificationHandlerRef ref;
    
    ref.handler = handler;
    ref.ref     = refCon;
    
    result = addMatchingNotification(type, matching, &amp;_IOServiceMatchingNotificationHandler,
			    target, &amp;ref, priority);

    <span class="enscript-keyword">if</span> (result)
	matching-&gt;release();

    <span class="enscript-keyword">return</span> (result);
}

IONotifier * <span class="enscript-function-name">IOService::addMatchingNotification</span>(
			<span class="enscript-type">const</span> OSSymbol * type, OSDictionary * matching,
			IOServiceMatchingNotificationHandler handler,
			<span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
			SInt32 priority )
{
    OSIterator *		existing = NULL;
    _IOServiceNotifier *	notify;
    IOService *			next;

    notify = (_IOServiceNotifier *) installNotification( type, matching,
		handler, target, ref, priority, &amp;existing );

    <span class="enscript-comment">// send notifications for existing set
</span>    <span class="enscript-keyword">if</span>( existing) {

        notify-&gt;retain();		<span class="enscript-comment">// in case handler remove()s
</span>        <span class="enscript-keyword">while</span>( (next = (IOService *) existing-&gt;getNextObject())) {

	    next-&gt;lockForArbitration();
	    <span class="enscript-keyword">if</span>( 0 == (next-&gt;__state[0] &amp; kIOServiceInactiveState))
                next-&gt;invokeNotifer( notify );
	    next-&gt;unlockForArbitration();
	}
        notify-&gt;release();
	existing-&gt;release();
    }

    <span class="enscript-keyword">return</span>( notify );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::syncNotificationHandler</span>(
			<span class="enscript-type">void</span> * <span class="enscript-comment">/* target */</span>, <span class="enscript-type">void</span> * ref,
			IOService * newService,
			IONotifier * notifier )
{

    LOCKWRITENOTIFY();
    <span class="enscript-keyword">if</span> (!*((IOService **) ref))
    {
	newService-&gt;retain();
	(*(IOService **) ref) = newService;
	WAKEUPNOTIFY(ref);
    }
    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( false );
}

IOService * <span class="enscript-function-name">IOService::waitForMatchingService</span>( OSDictionary * matching,
						uint64_t timeout)
{
    IONotifier *	notify = 0;
    <span class="enscript-comment">// priority doesn't help us much since we need a thread wakeup
</span>    SInt32		priority = 0;
    IOService *  	result;

    <span class="enscript-keyword">if</span> (!matching)
        <span class="enscript-keyword">return</span>( 0 );

    result = NULL;

    LOCKWRITENOTIFY();
    <span class="enscript-keyword">do</span>
    {
        result = (IOService *) copyExistingServices( matching,
                            kIOServiceMatchedState, kIONotifyOnce );
	<span class="enscript-keyword">if</span> (result)
	    <span class="enscript-keyword">break</span>;
        notify = IOService::setNotification( gIOMatchedNotification, matching,
                    &amp;IOService::syncNotificationHandler, (<span class="enscript-type">void</span> *) 0,
                    &amp;result, priority );
	 <span class="enscript-keyword">if</span> (!notify)
	    <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">if</span> (UINT64_MAX != timeout)
	{
	    AbsoluteTime deadline;
	    nanoseconds_to_absolutetime(timeout, &amp;deadline);
	    clock_absolutetime_interval_to_deadline(deadline, &amp;deadline);
	    SLEEPNOTIFYTO(&amp;result, deadline);
	}
        <span class="enscript-keyword">else</span>
	{
	    SLEEPNOTIFY(&amp;result);
	}
    }
    <span class="enscript-keyword">while</span>( false );

    UNLOCKNOTIFY();

    <span class="enscript-keyword">if</span> (notify)
        notify-&gt;remove();	<span class="enscript-comment">// dequeues
</span>
    <span class="enscript-keyword">return</span>( result );
}

IOService * <span class="enscript-function-name">IOService::waitForService</span>( OSDictionary * matching,
					mach_timespec_t * timeout )
{
    IOService * result;
    uint64_t    timeoutNS;

    <span class="enscript-keyword">if</span> (timeout)
    {
	timeoutNS = timeout-&gt;tv_sec;
	timeoutNS *= kSecondScale;
	timeoutNS += timeout-&gt;tv_nsec;
    }
    <span class="enscript-keyword">else</span>
	timeoutNS = UINT64_MAX;

    result = waitForMatchingService(matching, timeoutNS);

    matching-&gt;release();
    <span class="enscript-keyword">if</span> (result)
	result-&gt;release();

    <span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::deliverNotification</span>( <span class="enscript-type">const</span> OSSymbol * type,
                            IOOptionBits orNewState, IOOptionBits andNewState )
{
    _IOServiceNotifier * notify;
    OSIterator *	 iter;
    OSArray *		 willSend = 0;

    lockForArbitration();

    <span class="enscript-keyword">if</span>( (0 == (__state[0] &amp; kIOServiceInactiveState))
     ||	(type == gIOTerminatedNotification)) {

	LOCKREADNOTIFY();

        iter = OSCollectionIterator::withCollection( (OSOrderedSet *)
                    gNotifications-&gt;getObject( type ) );

        <span class="enscript-keyword">if</span>( iter) {
            <span class="enscript-keyword">while</span>( (notify = (_IOServiceNotifier *) iter-&gt;getNextObject())) {

                <span class="enscript-keyword">if</span>( matchPassive(notify-&gt;matching, 0)
                  &amp;&amp; (kIOServiceNotifyEnable &amp; notify-&gt;state)) {
                    <span class="enscript-keyword">if</span>( 0 == willSend)
                        willSend = OSArray::withCapacity(8);
                    <span class="enscript-keyword">if</span>( willSend)
                        willSend-&gt;setObject( notify );
                }
            }
            iter-&gt;release();
        }

        __state[0] = (__state[0] | orNewState) &amp; andNewState;

        UNLOCKNOTIFY();
    }

    <span class="enscript-keyword">if</span>( willSend) {
        <span class="enscript-keyword">for</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx = 0;
             (notify = (_IOServiceNotifier *) willSend-&gt;getObject(idx));
             idx++) {
            invokeNotifer( notify );
        }
        willSend-&gt;release();
    }
    unlockForArbitration();
}

IOOptionBits <span class="enscript-function-name">IOService::getState</span>( <span class="enscript-type">void</span> ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( __state[0] );
}

<span class="enscript-comment">/*
 * Helpers to make matching objects for simple cases
 */</span>

OSDictionary * <span class="enscript-function-name">IOService::serviceMatching</span>( <span class="enscript-type">const</span> OSString * name,
			OSDictionary * table )
{

    <span class="enscript-type">const</span> OSString *	str;

    str = OSSymbol::withString(name);
    <span class="enscript-keyword">if</span>( !str)
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( !table)
	table = OSDictionary::withCapacity( 2 );
    <span class="enscript-keyword">if</span>( table)
        table-&gt;setObject(gIOProviderClassKey, (OSObject *)str );
    str-&gt;release();

    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::serviceMatching</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
			OSDictionary * table )
{
    <span class="enscript-type">const</span> OSString *	str;

    str = OSSymbol::withCString( name );
    <span class="enscript-keyword">if</span>( !str)
	<span class="enscript-keyword">return</span>( 0 );

    table = serviceMatching( str, table );
    str-&gt;release();
    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::nameMatching</span>( <span class="enscript-type">const</span> OSString * name,
			OSDictionary * table )
{
    <span class="enscript-keyword">if</span>( !table)
	table = OSDictionary::withCapacity( 2 );
    <span class="enscript-keyword">if</span>( table)
        table-&gt;setObject( gIONameMatchKey, (OSObject *)name );

    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::nameMatching</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
			OSDictionary * table )
{
    <span class="enscript-type">const</span> OSString *	str;

    str = OSSymbol::withCString( name );
    <span class="enscript-keyword">if</span>( !str)
	<span class="enscript-keyword">return</span>( 0 );

    table = nameMatching( str, table );
    str-&gt;release();
    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::resourceMatching</span>( <span class="enscript-type">const</span> OSString * str,
			OSDictionary * table )
{
    table = serviceMatching( gIOResourcesKey, table );
    <span class="enscript-keyword">if</span>( table)
        table-&gt;setObject( gIOResourceMatchKey, (OSObject *) str );

    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::resourceMatching</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
			OSDictionary * table )
{
    <span class="enscript-type">const</span> OSSymbol *	str;

    str = OSSymbol::withCString( name );
    <span class="enscript-keyword">if</span>( !str)
	<span class="enscript-keyword">return</span>( 0 );

    table = resourceMatching( str, table );
    str-&gt;release();

    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::propertyMatching</span>( <span class="enscript-type">const</span> OSSymbol * key, <span class="enscript-type">const</span> OSObject * value,
			OSDictionary * table )
{
    OSDictionary * properties;

    properties = OSDictionary::withCapacity( 2 );
    <span class="enscript-keyword">if</span>( !properties)
	<span class="enscript-keyword">return</span>( 0 );
    properties-&gt;setObject( key, value );

    <span class="enscript-keyword">if</span>( !table)
	table = OSDictionary::withCapacity( 2 );
    <span class="enscript-keyword">if</span>( table)
        table-&gt;setObject( gIOPropertyMatchKey, properties );

    properties-&gt;release();

    <span class="enscript-keyword">return</span>( table );
}

OSDictionary * <span class="enscript-function-name">IOService::registryEntryIDMatching</span>( uint64_t entryID,
			OSDictionary * table )
{
    OSNumber *     num;

    num = OSNumber::withNumber( entryID, 64 );
    <span class="enscript-keyword">if</span>( !num)
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( !table)
	table = OSDictionary::withCapacity( 2 );
    <span class="enscript-keyword">if</span>( table)
        table-&gt;setObject( gIORegistryEntryIDKey, num );
	
    <span class="enscript-keyword">if</span> (num)
	num-&gt;release();

    <span class="enscript-keyword">return</span>( table );
}


<span class="enscript-comment">/*
 * _IOServiceNotifier
 */</span>

<span class="enscript-comment">// wait for all threads, other than the current one,
</span><span class="enscript-comment">//  to exit the handler
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceNotifier::wait</span>()
{
    _IOServiceNotifierInvocation * next;
    <span class="enscript-type">bool</span> doWait;

    <span class="enscript-keyword">do</span> {
        doWait = false;
        queue_iterate( &amp;handlerInvocations, next,
                        _IOServiceNotifierInvocation *, link) {
            <span class="enscript-keyword">if</span>( next-&gt;thread != current_thread() ) {
                doWait = true;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">if</span>( doWait) {
            state |= kIOServiceNotifyWaiter;
            SLEEPNOTIFY(<span class="enscript-keyword">this</span>);
        }

    } <span class="enscript-keyword">while</span>( doWait );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceNotifier::free</span>()
{
    assert( queue_empty( &amp;handlerInvocations ));
    <span class="enscript-reference">OSObject</span>::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceNotifier::remove</span>()
{
    LOCKWRITENOTIFY();

    <span class="enscript-keyword">if</span>( whence) {
        whence-&gt;removeObject( (OSObject *) <span class="enscript-keyword">this</span> );
        whence = 0;
    }
    <span class="enscript-keyword">if</span>( matching) {
        matching-&gt;release();
        matching = 0;
    }

    state &amp;= ~kIOServiceNotifyEnable;

    wait();

    UNLOCKNOTIFY();
    
    release();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">_IOServiceNotifier::disable</span>()
{
    <span class="enscript-type">bool</span>	ret;

    LOCKWRITENOTIFY();

    ret = (0 != (kIOServiceNotifyEnable &amp; state));
    state &amp;= ~kIOServiceNotifyEnable;
    <span class="enscript-keyword">if</span>( ret)
        wait();

    UNLOCKNOTIFY();

    <span class="enscript-keyword">return</span>( ret );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_IOServiceNotifier::enable</span>( <span class="enscript-type">bool</span> was )
{
    LOCKWRITENOTIFY();
    <span class="enscript-keyword">if</span>( was)
        state |= kIOServiceNotifyEnable;
    <span class="enscript-keyword">else</span>
        state &amp;= ~kIOServiceNotifyEnable;
    UNLOCKNOTIFY();
}

<span class="enscript-comment">/*
 * IOResources
 */</span>

IOService * <span class="enscript-function-name">IOResources::resources</span>( <span class="enscript-type">void</span> )
{
    IOResources *	inst;

    inst = <span class="enscript-keyword">new</span> IOResources;
    <span class="enscript-keyword">if</span>( inst &amp;&amp; !inst-&gt;init()) {
	inst-&gt;release();
	inst = 0;
    }

    <span class="enscript-keyword">return</span>( inst );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOResources::init</span>( OSDictionary * dictionary )
{
    <span class="enscript-comment">// Do super init first
</span>    <span class="enscript-keyword">if</span> ( !super::init() )
        <span class="enscript-keyword">return</span> false;

    <span class="enscript-comment">// Allow PAL layer to publish a value
</span>    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *property_name;
    <span class="enscript-type">int</span> property_value;

    pal_get_resource_property( &amp;property_name, &amp;property_value );

    <span class="enscript-keyword">if</span>( property_name ) {
	OSNumber *num;
	<span class="enscript-type">const</span> OSSymbol *	sym;

	<span class="enscript-keyword">if</span>( (num = OSNumber::withNumber(property_value, 32)) != 0 ) {
	    <span class="enscript-keyword">if</span>( (sym = OSSymbol::withCString( property_name)) != 0 ) {
		<span class="enscript-keyword">this</span>-&gt;setProperty( sym, num );
		sym-&gt;release();
	    }
	    num-&gt;release();
	}
    }

    <span class="enscript-keyword">return</span> true;
}

IOReturn <span class="enscript-function-name">IOResources::newUserClient</span>(task_t owningTask, <span class="enscript-type">void</span> * securityID,
                                    UInt32 type,  OSDictionary * properties,
                                    IOUserClient ** handler)
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported );
}

IOWorkLoop * <span class="enscript-function-name">IOResources::getWorkLoop</span>() <span class="enscript-type">const</span>
{
    <span class="enscript-comment">// If we are the resource root
</span>    <span class="enscript-comment">// then use the platform's workloop
</span>    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> == (IOResources *) gIOResources)
	<span class="enscript-keyword">return</span> getPlatform()-&gt;getWorkLoop();
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span> IOService::getWorkLoop();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOResources::matchPropertyTable</span>( OSDictionary * table )
{
    OSObject *		prop;
    OSString *		str;
    OSSet *		set;
    OSIterator *	iter;
    <span class="enscript-type">bool</span>		ok = true;

    prop = table-&gt;getObject( gIOResourceMatchKey );
    str = OSDynamicCast( OSString, prop );
    <span class="enscript-keyword">if</span>( str)
	ok = (0 != getProperty( str ));

    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (set = OSDynamicCast( OSSet, prop))) {

	iter = OSCollectionIterator::withCollection( set );
	ok = (iter != 0);
        <span class="enscript-keyword">while</span>( ok &amp;&amp; (str = OSDynamicCast( OSString, iter-&gt;getNextObject()) ))
            ok = (0 != getProperty( str ));

        <span class="enscript-keyword">if</span>( iter)
	    iter-&gt;release();
    }

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::consoleLockTimer</span>(thread_call_param_t p0, thread_call_param_t p1)
{
    <span class="enscript-reference">IOService</span>::updateConsoleUsers(NULL, 0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::updateConsoleUsers</span>(OSArray * consoleUsers, IOMessage systemMessage)
{
    IORegistryEntry * regEntry;
    OSObject *        locked = kOSBooleanFalse;
    uint32_t          idx;
    <span class="enscript-type">bool</span>              publish;
    OSDictionary *    user;
    <span class="enscript-type">static</span> IOMessage  sSystemPower;

    regEntry = IORegistryEntry::getRegistryRoot();

    <span class="enscript-keyword">if</span> (!gIOChosenEntry)
	gIOChosenEntry = IORegistryEntry::fromPath(<span class="enscript-string">&quot;/chosen&quot;</span>, gIODTPlane);

    IOLockLock(gIOConsoleUsersLock);

    <span class="enscript-keyword">if</span> (systemMessage)
    {
        sSystemPower = systemMessage;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
	<span class="enscript-keyword">if</span> ((kIOMessageSystemHasPoweredOn == systemMessage) &amp;&amp; IOHibernateWasScreenLocked())
	{
	    locked = kOSBooleanTrue;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>
    }

    <span class="enscript-keyword">if</span> (consoleUsers)
    {
        OSNumber * num = 0;
	gIOConsoleLoggedIn = false;
	<span class="enscript-keyword">for</span> (idx = 0; 
	      (user = OSDynamicCast(OSDictionary, consoleUsers-&gt;getObject(idx))); 
	      idx++)
	{
	    gIOConsoleLoggedIn |= ((kOSBooleanTrue == user-&gt;getObject(gIOConsoleSessionOnConsoleKey))
	      		&amp;&amp; (kOSBooleanTrue == user-&gt;getObject(gIOConsoleSessionLoginDoneKey)));
	    <span class="enscript-keyword">if</span> (!num)
	    {
   	        num = OSDynamicCast(OSNumber, user-&gt;getObject(gIOConsoleSessionScreenLockedTimeKey));
	    }
	}
        gIOConsoleLockTime = num ? num-&gt;unsigned32BitValue() : 0;
    }

    <span class="enscript-keyword">if</span> (!gIOConsoleLoggedIn 
     || (kIOMessageSystemWillSleep == sSystemPower)
     || (kIOMessageSystemPagingOff == sSystemPower))
    {
	locked = kOSBooleanTrue;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gIOConsoleLockTime)
    {
	clock_sec_t  now;
	clock_usec_t microsecs;

	clock_get_calendar_microtime(&amp;now, &amp;microsecs);
	<span class="enscript-keyword">if</span> (gIOConsoleLockTime &gt; now)
	{
	    AbsoluteTime deadline;
	    clock_interval_to_deadline(gIOConsoleLockTime - now, kSecondScale, &amp;deadline);
	    thread_call_enter_delayed(gIOConsoleLockCallout, deadline);
	}
	<span class="enscript-keyword">else</span>
	{
	    locked = kOSBooleanTrue;
	}
    }

    publish = (consoleUsers || (locked != regEntry-&gt;getProperty(gIOConsoleLockedKey)));
    <span class="enscript-keyword">if</span> (publish)
    {
	regEntry-&gt;setProperty(gIOConsoleLockedKey, locked);
	<span class="enscript-keyword">if</span> (consoleUsers)
	{
	    regEntry-&gt;setProperty(gIOConsoleUsersKey, consoleUsers);
	}
	OSIncrementAtomic( &amp;gIOConsoleUsersSeed );
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-keyword">if</span> (gIOChosenEntry)
    {
	<span class="enscript-keyword">if</span> (locked == kOSBooleanTrue) gIOScreenLockState = kIOScreenLockLocked;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gIOConsoleLockTime)  gIOScreenLockState = kIOScreenLockUnlocked;
	<span class="enscript-keyword">else</span>                          gIOScreenLockState = kIOScreenLockNoLock;
	gIOChosenEntry-&gt;setProperty(kIOScreenLockStateKey, &amp;gIOScreenLockState, <span class="enscript-keyword">sizeof</span>(gIOScreenLockState));
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>

    IOLockUnlock(gIOConsoleUsersLock);

    <span class="enscript-keyword">if</span> (publish)
    {
	publishResource( gIOConsoleUsersSeedKey, gIOConsoleUsersSeedValue );

	MessageClientsContext context;
    
	context.service  = getServiceRoot();
	context.type     = kIOMessageConsoleSecurityChange;
	context.argument = (<span class="enscript-type">void</span> *) regEntry;
	context.argSize  = 0;
    
	applyToInterestNotifiers(getServiceRoot(), gIOConsoleSecurityInterest, 
				 &amp;messageClientsApplier, &amp;context );
    }
}

IOReturn <span class="enscript-function-name">IOResources::setProperties</span>( OSObject * properties )
{
    IOReturn			err;
    <span class="enscript-type">const</span> OSSymbol *		key;
    OSDictionary *		dict;
    OSCollectionIterator *	iter;

    err = IOUserClient::clientHasPrivilege(current_task(), kIOClientPrivilegeAdministrator);
    <span class="enscript-keyword">if</span> ( kIOReturnSuccess != err)
	<span class="enscript-keyword">return</span>( err );

    dict = OSDynamicCast(OSDictionary, properties);
    <span class="enscript-keyword">if</span>( 0 == dict)
	<span class="enscript-keyword">return</span>( kIOReturnBadArgument);

    iter = OSCollectionIterator::withCollection( dict);
    <span class="enscript-keyword">if</span>( 0 == iter)
	<span class="enscript-keyword">return</span>( kIOReturnBadArgument);

    <span class="enscript-keyword">while</span>( (key = OSDynamicCast(OSSymbol, iter-&gt;getNextObject())))
    {
	<span class="enscript-keyword">if</span> (gIOConsoleUsersKey == key) <span class="enscript-keyword">do</span>
	{
	    OSArray * consoleUsers;
	    consoleUsers = OSDynamicCast(OSArray, dict-&gt;getObject(key));
	    <span class="enscript-keyword">if</span> (!consoleUsers)
		<span class="enscript-keyword">continue</span>;
	    <span class="enscript-reference">IOService</span>::updateConsoleUsers(consoleUsers, 0);
	}
	<span class="enscript-keyword">while</span> (false);

	publishResource( key, dict-&gt;getObject(key) );
    }

    iter-&gt;release();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/*
 * Helpers for matching dictionaries.
 * Keys existing in matching are checked in properties.
 * Keys may be a string or OSCollection of IOStrings
 */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::compareProperty</span>( OSDictionary * matching,
                                 <span class="enscript-type">const</span> <span class="enscript-type">char</span> * 	key )
{
    OSObject *	value;
    <span class="enscript-type">bool</span>	ok;

    value = matching-&gt;getObject( key );
    <span class="enscript-keyword">if</span>( value)
        ok = value-&gt;isEqualTo( getProperty( key ));
    <span class="enscript-keyword">else</span>
	ok = true;

    <span class="enscript-keyword">return</span>( ok );
}


<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::compareProperty</span>( OSDictionary *   matching,
                                 <span class="enscript-type">const</span> OSString * key )
{
    OSObject *	value;
    <span class="enscript-type">bool</span>	ok;

    value = matching-&gt;getObject( key );
    <span class="enscript-keyword">if</span>( value)
        ok = value-&gt;isEqualTo( getProperty( key ));
    <span class="enscript-keyword">else</span>
	ok = true;

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::compareProperties</span>( OSDictionary * matching,
                                   OSCollection * keys )
{
    OSCollectionIterator *	iter;
    <span class="enscript-type">const</span> OSString *		key;
    <span class="enscript-type">bool</span>			ok = true;

    <span class="enscript-keyword">if</span>( !matching || !keys)
	<span class="enscript-keyword">return</span>( false );

    iter = OSCollectionIterator::withCollection( keys );

    <span class="enscript-keyword">if</span>( iter) {
	<span class="enscript-keyword">while</span>( ok &amp;&amp; (key = OSDynamicCast( OSString, iter-&gt;getNextObject())))
	    ok = compareProperty( matching, key );

	iter-&gt;release();
    }
    keys-&gt;release();	<span class="enscript-comment">// !! consume a ref !!
</span>
    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-comment">/* Helper to add a location matching dict to the table */</span>

OSDictionary * <span class="enscript-function-name">IOService::addLocation</span>( OSDictionary * table )
{
    OSDictionary * 	dict;

    <span class="enscript-keyword">if</span>( !table)
	<span class="enscript-keyword">return</span>( 0 );

    dict = OSDictionary::withCapacity( 1 );
    <span class="enscript-keyword">if</span>( dict) {
        table-&gt;setObject( gIOLocationMatchKey, dict );
        dict-&gt;release(); 
    }

    <span class="enscript-keyword">return</span>( dict );
}

<span class="enscript-comment">/*
 * Go looking for a provider to match a location dict.
 */</span>

IOService * <span class="enscript-function-name">IOService::matchLocation</span>( IOService * <span class="enscript-comment">/* client */</span> )
{
    IOService *	parent;

    parent = getProvider();

    <span class="enscript-keyword">if</span>( parent)
        parent = parent-&gt;matchLocation( <span class="enscript-keyword">this</span> );

    <span class="enscript-keyword">return</span>( parent );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::matchInternal</span>(OSDictionary * table, uint32_t options, uint32_t * did)
{
    OSString *		matched;
    OSObject *		obj;
    OSString *		str;
    IORegistryEntry *	entry;
    OSNumber *		num;
    <span class="enscript-type">bool</span>		match = true;
    <span class="enscript-type">bool</span>                changesOK = (0 != (kIOServiceChangesOK &amp; options));
    uint32_t            count;
    uint32_t            done;

    <span class="enscript-keyword">do</span>
    {
	count = table-&gt;getCount();
	done = 0;
	str = OSDynamicCast(OSString, table-&gt;getObject(gIOProviderClassKey));
	<span class="enscript-keyword">if</span> (str) {
	    done++;
	    match = ((kIOServiceClassDone &amp; options) || (0 != metaCast(str)));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MATCH_DEBUG</span>
	    match = (0 != metaCast( str ));
	    <span class="enscript-keyword">if</span> ((kIOServiceClassDone &amp; options) &amp;&amp; !match) panic(<span class="enscript-string">&quot;classDone&quot;</span>);
#<span class="enscript-reference">endif</span>
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

	obj = table-&gt;getObject( gIONameMatchKey );
	<span class="enscript-keyword">if</span>( obj) {
	    done++;
	    match = compareNames( obj, changesOK ? &amp;matched : 0 );
	    <span class="enscript-keyword">if</span> (!match)	<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">if</span>( changesOK &amp;&amp; matched) {
		<span class="enscript-comment">// leave a hint as to which name matched
</span>		table-&gt;setObject( gIONameMatchedKey, matched );
		matched-&gt;release();
	    }
	    <span class="enscript-keyword">if</span> (done == count) <span class="enscript-keyword">break</span>;
	}

	str = OSDynamicCast( OSString, table-&gt;getObject( gIOLocationMatchKey ));
	<span class="enscript-keyword">if</span> (str)
	{
    	    <span class="enscript-type">const</span> OSSymbol * sym;
	    done++;
	    match = false;
	    sym = copyLocation();
	    <span class="enscript-keyword">if</span> (sym) {
		match = sym-&gt;isEqualTo( str );
		sym-&gt;release();
	    }
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

	obj = table-&gt;getObject( gIOPropertyMatchKey );
	<span class="enscript-keyword">if</span>( obj)
	{
	    OSDictionary * dict;
	    OSDictionary * nextDict;
	    OSIterator *   iter;
	    done++;
	    match = false;
	    dict = dictionaryWithProperties();
	    <span class="enscript-keyword">if</span>( dict) {
		nextDict = OSDynamicCast( OSDictionary, obj);
		<span class="enscript-keyword">if</span>( nextDict)
		    iter = 0;
		<span class="enscript-keyword">else</span>
		    iter = OSCollectionIterator::withCollection(
				OSDynamicCast(OSCollection, obj));

		<span class="enscript-keyword">while</span>( nextDict
		    || (iter &amp;&amp; (0 != (nextDict = OSDynamicCast(OSDictionary,
					    iter-&gt;getNextObject()))))) {
		    match = dict-&gt;isEqualTo( nextDict, nextDict);
		    <span class="enscript-keyword">if</span>( match)
			<span class="enscript-keyword">break</span>;
		    nextDict = 0;
		}
		dict-&gt;release();
		<span class="enscript-keyword">if</span>( iter)
		    iter-&gt;release();
	    }
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

	str = OSDynamicCast( OSString, table-&gt;getObject( gIOPathMatchKey ));
	<span class="enscript-keyword">if</span>( str) {
	    done++;
	    entry = IORegistryEntry::fromPath( str-&gt;getCStringNoCopy() );
	    match = (<span class="enscript-keyword">this</span> == entry);
	    <span class="enscript-keyword">if</span>( entry)
		entry-&gt;release();
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

	num = OSDynamicCast( OSNumber, table-&gt;getObject( gIORegistryEntryIDKey ));
	<span class="enscript-keyword">if</span> (num) {
	    done++;
	    match = (getRegistryEntryID() == num-&gt;unsigned64BitValue());
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

	num = OSDynamicCast( OSNumber, table-&gt;getObject( gIOMatchedServiceCountKey ));
	<span class="enscript-keyword">if</span>( num)
	{
	    OSIterator *	iter;
	    IOService *		service = 0;
	    UInt32		serviceCount = 0;

	    done++;
	    iter = getClientIterator();
	    <span class="enscript-keyword">if</span>( iter) {
		<span class="enscript-keyword">while</span>( (service = (IOService *) iter-&gt;getNextObject())) {
		    <span class="enscript-keyword">if</span>( kIOServiceInactiveState &amp; service-&gt;__state[0])
			<span class="enscript-keyword">continue</span>;
		    <span class="enscript-keyword">if</span>( 0 == service-&gt;getProperty( gIOMatchCategoryKey ))
			<span class="enscript-keyword">continue</span>;
		    ++serviceCount;
		}
		iter-&gt;release();
	    }
	    match = (serviceCount == num-&gt;unsigned32BitValue());
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">propMatch</span>(key)					\
	obj = table-&gt;getObject(key);			\
	<span class="enscript-keyword">if</span> (obj)					\
	{						\
	    OSObject * prop;				\
	    done++;					\
	    prop = copyProperty(key);			\
	    match = obj-&gt;isEqualTo(prop);		\
            <span class="enscript-keyword">if</span> (prop) prop-&gt;release();			\
	    <span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;	\
	}
	propMatch(kIOBSDNameKey)
	propMatch(kIOBSDMajorKey)
	propMatch(kIOBSDMinorKey)
	propMatch(kIOBSDUnitKey)
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">propMatch</span>
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (did) *did = done;
    <span class="enscript-keyword">return</span> (match);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::passiveMatch</span>( OSDictionary * table, <span class="enscript-type">bool</span> changesOK )
{
    <span class="enscript-keyword">return</span> (matchPassive(table, changesOK ? kIOServiceChangesOK : 0));
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOService::matchPassive</span>(OSDictionary * table, uint32_t options)
{
    IOService *		where;
    OSDictionary *      nextTable;
    SInt32		score;
    OSNumber *		newPri;
    <span class="enscript-type">bool</span>		match = true;
    <span class="enscript-type">bool</span>		matchParent = false;
    uint32_t		count;
    uint32_t		done;

    assert( table );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MATCH_DEBUG</span> 
    OSDictionary * root = table;
#<span class="enscript-reference">endif</span>

    where = <span class="enscript-keyword">this</span>;
    <span class="enscript-keyword">do</span>
    {
        <span class="enscript-keyword">do</span>
        {
	    count = table-&gt;getCount();
	    <span class="enscript-keyword">if</span> (!(kIOServiceInternalDone &amp; options))
	    {
		match = where-&gt;matchInternal(table, options, &amp;done);
		<span class="enscript-comment">// don't call family if we've done all the entries in the table
</span>		<span class="enscript-keyword">if</span> ((!match) || (done == count)) <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-comment">// pass in score from property table
</span>            score = IOServiceObjectOrder( table, (<span class="enscript-type">void</span> *) gIOProbeScoreKey);

            <span class="enscript-comment">// do family specific matching
</span>            match = where-&gt;matchPropertyTable( table, &amp;score );

            <span class="enscript-keyword">if</span>( !match) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMATCHDEBUG</span>
                <span class="enscript-keyword">if</span>( kIOLogMatch &amp; getDebugFlags( table ))
                    LOG(<span class="enscript-string">&quot;%s: family specific matching fails\n&quot;</span>, where-&gt;getName());
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">if</span> (kIOServiceChangesOK &amp; options) {
                <span class="enscript-comment">// save the score
</span>                newPri = OSNumber::withNumber( score, 32 );
                <span class="enscript-keyword">if</span>( newPri) {
                    table-&gt;setObject( gIOProbeScoreKey, newPri );
                    newPri-&gt;release();
                }
            }

	    options = 0;
            matchParent = false;

            nextTable = OSDynamicCast(OSDictionary,
                  table-&gt;getObject( gIOParentMatchKey ));
            <span class="enscript-keyword">if</span>( nextTable) {
		<span class="enscript-comment">// look for a matching entry anywhere up to root
</span>                match = false;
                matchParent = true;
		table = nextTable;
                <span class="enscript-keyword">break</span>;
            }

            table = OSDynamicCast(OSDictionary,
                    table-&gt;getObject( gIOLocationMatchKey ));
            <span class="enscript-keyword">if</span> (table) {
		<span class="enscript-comment">// look for a matching entry at matchLocation()
</span>                match = false;
                where = where-&gt;getProvider();
                <span class="enscript-keyword">if</span> (where &amp;&amp; (where = where-&gt;matchLocation(where))) <span class="enscript-keyword">continue</span>;
            }
            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">while</span> (true);
    }
    <span class="enscript-keyword">while</span>( matchParent &amp;&amp; (!match) &amp;&amp; (where = where-&gt;getProvider()) );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MATCH_DEBUG</span>
    <span class="enscript-keyword">if</span> (where != <span class="enscript-keyword">this</span>) 
    {
	OSSerialize * s = OSSerialize::withCapacity(128);
	root-&gt;serialize(s);
	kprintf(<span class="enscript-string">&quot;parent match 0x%llx, %d,\n%s\n&quot;</span>, getRegistryEntryID(), match, s-&gt;text());
	s-&gt;release();
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span>( match );
}


IOReturn <span class="enscript-function-name">IOService::newUserClient</span>( task_t owningTask, <span class="enscript-type">void</span> * securityID,
                                    UInt32 type,  OSDictionary * properties,
                                    IOUserClient ** handler )
{
    <span class="enscript-type">const</span> OSSymbol *userClientClass = 0;
    IOUserClient *client;
    OSObject *temp;

    <span class="enscript-keyword">if</span> (kIOReturnSuccess == newUserClient( owningTask, securityID, type, handler ))
	<span class="enscript-keyword">return</span> kIOReturnSuccess;

    <span class="enscript-comment">// First try my own properties for a user client class name
</span>    temp = getProperty(gIOUserClientClassKey);
    <span class="enscript-keyword">if</span> (temp) {
	<span class="enscript-keyword">if</span> (OSDynamicCast(OSSymbol, temp))
	    userClientClass = (<span class="enscript-type">const</span> OSSymbol *) temp;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (OSDynamicCast(OSString, temp)) {
	    userClientClass = OSSymbol::withString((OSString *) temp);
	    <span class="enscript-keyword">if</span> (userClientClass)
		setProperty(kIOUserClientClassKey,
			    (OSObject *) userClientClass);
	}
    }

    <span class="enscript-comment">// Didn't find one so lets just bomb out now without further ado.
</span>    <span class="enscript-keyword">if</span> (!userClientClass)
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-comment">// This reference is consumed by the IOServiceOpen call
</span>    temp = OSMetaClass::allocClassWithName(userClientClass);
    <span class="enscript-keyword">if</span> (!temp)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    <span class="enscript-keyword">if</span> (OSDynamicCast(IOUserClient, temp))
        client = (IOUserClient *) temp;
    <span class="enscript-keyword">else</span> {
        temp-&gt;release();
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    }

    <span class="enscript-keyword">if</span> ( !client-&gt;initWithTask(owningTask, securityID, type, properties) ) {
        client-&gt;release();
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    <span class="enscript-keyword">if</span> ( !client-&gt;attach(<span class="enscript-keyword">this</span>) ) {
        client-&gt;release();
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    }

    <span class="enscript-keyword">if</span> ( !client-&gt;start(<span class="enscript-keyword">this</span>) ) {
        client-&gt;detach(<span class="enscript-keyword">this</span>);
        client-&gt;release();
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    }

    *handler = client;
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::newUserClient</span>( task_t owningTask, <span class="enscript-type">void</span> * securityID,
                                    UInt32 type, IOUserClient ** handler )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported );
}

IOReturn <span class="enscript-function-name">IOService::requestProbe</span>( IOOptionBits options )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported);
}

<span class="enscript-comment">/*
 * Convert an IOReturn to text. Subclasses which add additional
 * IOReturn's should override this method and call 
 * super::stringFromReturn if the desired value is not found.
 */</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * <span class="enscript-function-name">IOService::stringFromReturn</span>( IOReturn rtn )
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> IONamedValue IOReturn_values[] = { 
        {kIOReturnSuccess,          <span class="enscript-string">&quot;success&quot;</span>                           },
        {kIOReturnError,            <span class="enscript-string">&quot;general error&quot;</span>                     },
        {kIOReturnNoMemory,         <span class="enscript-string">&quot;memory allocation error&quot;</span>           },
        {kIOReturnNoResources,      <span class="enscript-string">&quot;resource shortage&quot;</span>                 },
        {kIOReturnIPCError,         <span class="enscript-string">&quot;Mach IPC failure&quot;</span>                  },
        {kIOReturnNoDevice,         <span class="enscript-string">&quot;no such device&quot;</span>                    },
        {kIOReturnNotPrivileged,    <span class="enscript-string">&quot;privilege violation&quot;</span>               },
        {kIOReturnBadArgument,      <span class="enscript-string">&quot;invalid argument&quot;</span>                  },
        {kIOReturnLockedRead,       <span class="enscript-string">&quot;device is read locked&quot;</span>             },
        {kIOReturnLockedWrite,      <span class="enscript-string">&quot;device is write locked&quot;</span>            },
        {kIOReturnExclusiveAccess,  <span class="enscript-string">&quot;device is exclusive access&quot;</span>        },
        {kIOReturnBadMessageID,     <span class="enscript-string">&quot;bad IPC message ID&quot;</span>                },
        {kIOReturnUnsupported,      <span class="enscript-string">&quot;unsupported function&quot;</span>              },
        {kIOReturnVMError,          <span class="enscript-string">&quot;virtual memory error&quot;</span>              },
        {kIOReturnInternalError,    <span class="enscript-string">&quot;internal driver error&quot;</span>             },
        {kIOReturnIOError,          <span class="enscript-string">&quot;I/O error&quot;</span>                         },
        {kIOReturnCannotLock,       <span class="enscript-string">&quot;cannot acquire lock&quot;</span>               },
        {kIOReturnNotOpen,          <span class="enscript-string">&quot;device is not open&quot;</span>                },
        {kIOReturnNotReadable,      <span class="enscript-string">&quot;device is not readable&quot;</span>            },
        {kIOReturnNotWritable,      <span class="enscript-string">&quot;device is not writeable&quot;</span>           },
        {kIOReturnNotAligned,       <span class="enscript-string">&quot;alignment error&quot;</span>                   },
        {kIOReturnBadMedia,         <span class="enscript-string">&quot;media error&quot;</span>                       },
        {kIOReturnStillOpen,        <span class="enscript-string">&quot;device is still open&quot;</span>              },
        {kIOReturnRLDError,         <span class="enscript-string">&quot;rld failure&quot;</span>                       },
        {kIOReturnDMAError,         <span class="enscript-string">&quot;DMA failure&quot;</span>                       },
        {kIOReturnBusy,             <span class="enscript-string">&quot;device is busy&quot;</span>                    },
        {kIOReturnTimeout,          <span class="enscript-string">&quot;I/O timeout&quot;</span>                       },
        {kIOReturnOffline,          <span class="enscript-string">&quot;device is offline&quot;</span>                 },
        {kIOReturnNotReady,         <span class="enscript-string">&quot;device is not ready&quot;</span>               },
        {kIOReturnNotAttached,      <span class="enscript-string">&quot;device/channel is not attached&quot;</span>    },
        {kIOReturnNoChannels,       <span class="enscript-string">&quot;no DMA channels available&quot;</span>         },
        {kIOReturnNoSpace,          <span class="enscript-string">&quot;no space for data&quot;</span>                 },
        {kIOReturnPortExists,       <span class="enscript-string">&quot;device port already exists&quot;</span>        },
        {kIOReturnCannotWire,       <span class="enscript-string">&quot;cannot wire physical memory&quot;</span>       },
        {kIOReturnNoInterrupt,      <span class="enscript-string">&quot;no interrupt attached&quot;</span>             },
        {kIOReturnNoFrames,         <span class="enscript-string">&quot;no DMA frames enqueued&quot;</span>            },
        {kIOReturnMessageTooLarge,  <span class="enscript-string">&quot;message is too large&quot;</span>              },
        {kIOReturnNotPermitted,     <span class="enscript-string">&quot;operation is not permitted&quot;</span>        },
        {kIOReturnNoPower,          <span class="enscript-string">&quot;device is without power&quot;</span>           },
        {kIOReturnNoMedia,          <span class="enscript-string">&quot;media is not present&quot;</span>              },
        {kIOReturnUnformattedMedia, <span class="enscript-string">&quot;media is not formatted&quot;</span>            },
        {kIOReturnUnsupportedMode,  <span class="enscript-string">&quot;unsupported mode&quot;</span>                  },
        {kIOReturnUnderrun,         <span class="enscript-string">&quot;data underrun&quot;</span>                     },
        {kIOReturnOverrun,          <span class="enscript-string">&quot;data overrun&quot;</span>                      },
        {kIOReturnDeviceError,      <span class="enscript-string">&quot;device error&quot;</span>                      },
        {kIOReturnNoCompletion,     <span class="enscript-string">&quot;no completion routine&quot;</span>             },
        {kIOReturnAborted,          <span class="enscript-string">&quot;operation was aborted&quot;</span>             },
        {kIOReturnNoBandwidth,      <span class="enscript-string">&quot;bus bandwidth would be exceeded&quot;</span>   },
        {kIOReturnNotResponding,    <span class="enscript-string">&quot;device is not responding&quot;</span>          },
        {kIOReturnInvalid,          <span class="enscript-string">&quot;unanticipated driver error&quot;</span>        },
        {0,                         NULL                                }
    };

    <span class="enscript-keyword">return</span> IOFindNameForValue(rtn, IOReturn_values);
}

<span class="enscript-comment">/*
 * Convert an IOReturn to an errno.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">IOService::errnoFromReturn</span>( IOReturn rtn )
{
    <span class="enscript-keyword">if</span> (unix_err(err_get_code(rtn)) == rtn)
        <span class="enscript-keyword">return</span> err_get_code(rtn);

    <span class="enscript-keyword">switch</span>(rtn) {
        <span class="enscript-comment">// (obvious match)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnSuccess</span>:
            <span class="enscript-keyword">return</span>(0);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoMemory</span>:
            <span class="enscript-keyword">return</span>(ENOMEM);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoDevice</span>:
            <span class="enscript-keyword">return</span>(ENXIO);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnVMError</span>:
            <span class="enscript-keyword">return</span>(EFAULT);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotPermitted</span>:
            <span class="enscript-keyword">return</span>(EPERM);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotPrivileged</span>:
            <span class="enscript-keyword">return</span>(EACCES);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnIOError</span>:
            <span class="enscript-keyword">return</span>(EIO);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotWritable</span>:
            <span class="enscript-keyword">return</span>(EROFS);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnBadArgument</span>:
            <span class="enscript-keyword">return</span>(EINVAL);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnUnsupported</span>:
            <span class="enscript-keyword">return</span>(ENOTSUP);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnBusy</span>:
            <span class="enscript-keyword">return</span>(EBUSY);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoPower</span>:
            <span class="enscript-keyword">return</span>(EPWROFF);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnDeviceError</span>:
            <span class="enscript-keyword">return</span>(EDEVERR);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnTimeout</span>: 
            <span class="enscript-keyword">return</span>(ETIMEDOUT);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnMessageTooLarge</span>:
            <span class="enscript-keyword">return</span>(EMSGSIZE);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoSpace</span>:
            <span class="enscript-keyword">return</span>(ENOSPC);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnCannotLock</span>:
            <span class="enscript-keyword">return</span>(ENOLCK);

        <span class="enscript-comment">// (best match)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnBadMessageID</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoCompletion</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotAligned</span>:
            <span class="enscript-keyword">return</span>(EINVAL);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotReady</span>:
            <span class="enscript-keyword">return</span>(EBUSY);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnRLDError</span>:
            <span class="enscript-keyword">return</span>(EBADMACHO);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnPortExists</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnStillOpen</span>:
            <span class="enscript-keyword">return</span>(EEXIST);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnExclusiveAccess</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnLockedRead</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnLockedWrite</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotOpen</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotReadable</span>:
            <span class="enscript-keyword">return</span>(EACCES);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnCannotWire</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoResources</span>:
            <span class="enscript-keyword">return</span>(ENOMEM);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnAborted</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnOffline</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotResponding</span>:
            <span class="enscript-keyword">return</span>(EBUSY);
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnBadMedia</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoMedia</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNotAttached</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnUnformattedMedia</span>:
            <span class="enscript-keyword">return</span>(ENXIO); <span class="enscript-comment">// (media error)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnDMAError</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnOverrun</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnUnderrun</span>:
            <span class="enscript-keyword">return</span>(EIO); <span class="enscript-comment">// (transfer error)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoBandwidth</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoChannels</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoFrames</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnNoInterrupt</span>:
            <span class="enscript-keyword">return</span>(EIO); <span class="enscript-comment">// (hardware error)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnError</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnInternalError</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnInvalid</span>:
            <span class="enscript-keyword">return</span>(EIO); <span class="enscript-comment">// (generic error)
</span>        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReturnIPCError</span>:
            <span class="enscript-keyword">return</span>(EIO); <span class="enscript-comment">// (ipc error)
</span>        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span>(EIO); <span class="enscript-comment">// (all other errors)
</span>    }
}

IOReturn <span class="enscript-function-name">IOService::message</span>( UInt32 type, IOService * provider,
				<span class="enscript-type">void</span> * argument )
{
    <span class="enscript-comment">/*
     * Generic entry point for calls from the provider.  A return value of
     * kIOReturnSuccess indicates that the message was received, and where
     * applicable, that it was successful.
     */</span>

    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">/*
 * Device memory
 */</span>

IOItemCount <span class="enscript-function-name">IOService::getDeviceMemoryCount</span>( <span class="enscript-type">void</span> )
{
    OSArray *		array;
    IOItemCount		count;

    array = OSDynamicCast( OSArray, getProperty( gIODeviceMemoryKey));
    <span class="enscript-keyword">if</span>( array)
	count = array-&gt;getCount();
    <span class="enscript-keyword">else</span>
	count = 0;

    <span class="enscript-keyword">return</span>( count);
}

IODeviceMemory * <span class="enscript-function-name">IOService::getDeviceMemoryWithIndex</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index )
{
    OSArray *		array;
    IODeviceMemory *	range;

    array = OSDynamicCast( OSArray, getProperty( gIODeviceMemoryKey));
    <span class="enscript-keyword">if</span>( array)
	range = (IODeviceMemory *) array-&gt;getObject( index );
    <span class="enscript-keyword">else</span>
	range = 0;

    <span class="enscript-keyword">return</span>( range);
}

IOMemoryMap * <span class="enscript-function-name">IOService::mapDeviceMemoryWithIndex</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index,
						IOOptionBits options )
{
    IODeviceMemory *	range;
    IOMemoryMap *	map;

    range = getDeviceMemoryWithIndex( index );
    <span class="enscript-keyword">if</span>( range)
	map = range-&gt;map( options );
    <span class="enscript-keyword">else</span>
	map = 0;

    <span class="enscript-keyword">return</span>( map );
}

OSArray * <span class="enscript-function-name">IOService::getDeviceMemory</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( OSDynamicCast( OSArray, getProperty( gIODeviceMemoryKey)));
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOService::setDeviceMemory</span>( OSArray * array )
{
    setProperty( gIODeviceMemoryKey, array);
}

<span class="enscript-comment">/*
 * For machines where the transfers on an I/O bus can stall because
 * the CPU is in an idle mode, These APIs allow a driver to specify
 * the maximum bus stall that they can handle.  0 indicates no limit.
 */</span>
<span class="enscript-type">void</span> IOService::
<span class="enscript-function-name">setCPUSnoopDelay</span>(UInt32 __unused ns)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    ml_set_maxsnoop(ns); 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>
}

UInt32 IOService::
<span class="enscript-function-name">getCPUSnoopDelay</span>()
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-keyword">return</span> ml_get_maxsnoop(); 
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">requireMaxCpuDelay</span>(IOService * service, UInt32 ns, UInt32 delayType)
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> UInt kNoReplace = -1U;	<span class="enscript-comment">// Must be an illegal index
</span>    UInt replace = kNoReplace;
    <span class="enscript-type">bool</span> setCpuDelay = false;

    IORecursiveLockLock(sCpuDelayLock);

    UInt count = sCpuDelayData-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(CpuDelayEntry);
    CpuDelayEntry *entries = (CpuDelayEntry *) sCpuDelayData-&gt;getBytesNoCopy();
    IOService * holder = NULL;

    <span class="enscript-keyword">if</span> (ns) {
        <span class="enscript-type">const</span> CpuDelayEntry ne = {service, ns, delayType};
	holder = service;
        <span class="enscript-comment">// Set maximum delay.
</span>        <span class="enscript-keyword">for</span> (UInt i = 0; i &lt; count; i++) {
            IOService *thisService = entries[i].fService;
            <span class="enscript-type">bool</span> sameType = (delayType == entries[i].fDelayType);            
            <span class="enscript-keyword">if</span> ((service == thisService) &amp;&amp; sameType)
                replace = i;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!thisService) {
                <span class="enscript-keyword">if</span> (kNoReplace == replace)
                    replace = i;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sameType) {
                <span class="enscript-type">const</span> UInt32 thisMax = entries[i].fMaxDelay;
                <span class="enscript-keyword">if</span> (thisMax &lt; ns)
		{
                    ns = thisMax;
		    holder = thisService;
		}
            }
        }
        
        setCpuDelay = true;
        <span class="enscript-keyword">if</span> (kNoReplace == replace)
            sCpuDelayData-&gt;appendBytes(&amp;ne, <span class="enscript-keyword">sizeof</span>(ne));
        <span class="enscript-keyword">else</span>
            entries[replace] = ne;
    }
    <span class="enscript-keyword">else</span> {
        ns = -1U;	<span class="enscript-comment">// Set to max unsigned, i.e. no restriction
</span>
        <span class="enscript-keyword">for</span> (UInt i = 0; i &lt; count; i++) {
            <span class="enscript-comment">// Clear a maximum delay.
</span>            IOService *thisService = entries[i].fService;
            <span class="enscript-keyword">if</span> (thisService &amp;&amp; (delayType == entries[i].fDelayType)) {
                UInt32 thisMax = entries[i].fMaxDelay;
                <span class="enscript-keyword">if</span> (service == thisService)
                    replace = i;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (thisMax &lt; ns) {
                    ns = thisMax;
		    holder = thisService;
		}
            }
        }

        <span class="enscript-comment">// Check if entry found
</span>        <span class="enscript-keyword">if</span> (kNoReplace != replace) {
            entries[replace].fService = 0;	<span class="enscript-comment">// Null the entry
</span>            setCpuDelay = true;
        }
    }

    <span class="enscript-keyword">if</span> (setCpuDelay)
    {
        <span class="enscript-keyword">if</span> (holder &amp;&amp; debug_boot_arg) {
            strlcpy(sCPULatencyHolderName[delayType], holder-&gt;getName(), <span class="enscript-keyword">sizeof</span>(sCPULatencyHolderName[delayType]));
        }

        <span class="enscript-comment">// Must be safe to call from locked context
</span>        <span class="enscript-keyword">if</span> (delayType == kCpuDelayBusStall)
        {
            ml_set_maxbusdelay(ns);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (delayType == kCpuDelayInterrupt)
        {
            ml_set_maxintdelay(ns);
        }
	sCPULatencyHolder[delayType]-&gt;setValue(holder ? holder-&gt;getRegistryEntryID() : 0); 
	sCPULatencySet   [delayType]-&gt;setValue(ns);

	OSArray * handlers = sCpuLatencyHandlers[delayType];
	IOService * target;
	<span class="enscript-keyword">if</span> (handlers) <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx = 0; 
			    (target = (IOService *) handlers-&gt;getObject(idx));
			    idx++)
	{
	    target-&gt;callPlatformFunction(sCPULatencyFunctionName[delayType], false,
					    (<span class="enscript-type">void</span> *) (uintptr_t) ns, holder,
					    NULL, NULL);
	}
    }

    IORecursiveLockUnlock(sCpuDelayLock);
}

<span class="enscript-type">static</span> IOReturn
<span class="enscript-function-name">setLatencyHandler</span>(UInt32 delayType, IOService * target, <span class="enscript-type">bool</span> enable)
{
    IOReturn result = kIOReturnNotFound;
    OSArray * array;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx;

    IORecursiveLockLock(sCpuDelayLock);

    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-keyword">if</span> (enable &amp;&amp; !sCpuLatencyHandlers[delayType])
	    sCpuLatencyHandlers[delayType] = OSArray::withCapacity(4);
	array = sCpuLatencyHandlers[delayType];
	<span class="enscript-keyword">if</span> (!array)
	    <span class="enscript-keyword">break</span>;
	idx = array-&gt;getNextIndexOfObject(target, 0);
	<span class="enscript-keyword">if</span> (!enable)
	{
	    <span class="enscript-keyword">if</span> (-1U != idx)
	    {
		array-&gt;removeObject(idx);
		result = kIOReturnSuccess;
	    }
	}
	<span class="enscript-keyword">else</span>
	{
	    <span class="enscript-keyword">if</span> (-1U != idx) {
		result = kIOReturnExclusiveAccess;
		<span class="enscript-keyword">break</span>;
	    }
	    array-&gt;setObject(target);
	    
	    UInt count = sCpuDelayData-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(CpuDelayEntry);
	    CpuDelayEntry *entries = (CpuDelayEntry *) sCpuDelayData-&gt;getBytesNoCopy();
	    UInt32 ns = -1U;	<span class="enscript-comment">// Set to max unsigned, i.e. no restriction
</span>	    IOService * holder = NULL;

	    <span class="enscript-keyword">for</span> (UInt i = 0; i &lt; count; i++) {
		<span class="enscript-keyword">if</span> (entries[i].fService 
		  &amp;&amp; (delayType == entries[i].fDelayType) 
		  &amp;&amp; (entries[i].fMaxDelay &lt; ns)) {
		    ns = entries[i].fMaxDelay;
		    holder = entries[i].fService;
		}
	    }
	    target-&gt;callPlatformFunction(sCPULatencyFunctionName[delayType], false,
					    (<span class="enscript-type">void</span> *) (uintptr_t) ns, holder,
					    NULL, NULL);
	    result = kIOReturnSuccess;
	}
    }
    <span class="enscript-keyword">while</span> (false);

    IORecursiveLockUnlock(sCpuDelayLock);

    <span class="enscript-keyword">return</span> (result);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>

<span class="enscript-type">void</span> IOService::
<span class="enscript-function-name">requireMaxBusStall</span>(UInt32 __unused ns)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    requireMaxCpuDelay(<span class="enscript-keyword">this</span>, ns, kCpuDelayBusStall);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span> IOService::
<span class="enscript-function-name">requireMaxInterruptDelay</span>(uint32_t __unused ns)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    requireMaxCpuDelay(<span class="enscript-keyword">this</span>, ns, kCpuDelayInterrupt);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Device interrupts
 */</span>

IOReturn <span class="enscript-function-name">IOService::resolveInterrupt</span>(IOService *nub, <span class="enscript-type">int</span> source)
{
  IOInterruptController *interruptController;
  OSArray               *array;
  OSData                *data;
  OSSymbol              *interruptControllerName;
  <span class="enscript-type">long</span>                  numSources;
  IOInterruptSource     *interruptSources;
  
  <span class="enscript-comment">// Get the parents list from the nub.
</span>  array = OSDynamicCast(OSArray, nub-&gt;getProperty(gIOInterruptControllersKey));
  <span class="enscript-keyword">if</span> (array == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  <span class="enscript-comment">// Allocate space for the IOInterruptSources if needed... then return early.
</span>  <span class="enscript-keyword">if</span> (nub-&gt;_interruptSources == 0) {
    numSources = array-&gt;getCount();
    interruptSources = (IOInterruptSource *)IOMalloc(numSources * <span class="enscript-keyword">sizeof</span>(IOInterruptSource));
    <span class="enscript-keyword">if</span> (interruptSources == 0) <span class="enscript-keyword">return</span> kIOReturnNoMemory;
    
    bzero(interruptSources, numSources * <span class="enscript-keyword">sizeof</span>(IOInterruptSource));
    
    nub-&gt;_numInterruptSources = numSources;
    nub-&gt;_interruptSources = interruptSources;
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
  }
  
  interruptControllerName = OSDynamicCast(OSSymbol,array-&gt;getObject(source));
  <span class="enscript-keyword">if</span> (interruptControllerName == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  interruptController = getPlatform()-&gt;lookUpInterruptController(interruptControllerName);
  <span class="enscript-keyword">if</span> (interruptController == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  <span class="enscript-comment">// Get the interrupt numbers from the nub.
</span>  array = OSDynamicCast(OSArray, nub-&gt;getProperty(gIOInterruptSpecifiersKey));
  <span class="enscript-keyword">if</span> (array == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  data = OSDynamicCast(OSData, array-&gt;getObject(source));
  <span class="enscript-keyword">if</span> (data == 0) <span class="enscript-keyword">return</span> kIOReturnNoResources;
  
  <span class="enscript-comment">// Set the interruptController and interruptSource in the nub's table.
</span>  interruptSources = nub-&gt;_interruptSources;
  interruptSources[source].interruptController = interruptController;
  interruptSources[source].vectorData = data;
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::lookupInterrupt</span>(<span class="enscript-type">int</span> source, <span class="enscript-type">bool</span> resolve, IOInterruptController **interruptController)
{
  IOReturn ret;
  
  <span class="enscript-comment">/* Make sure the _interruptSources are set */</span>
  <span class="enscript-keyword">if</span> (_interruptSources == 0) {
    ret = resolveInterrupt(<span class="enscript-keyword">this</span>, source);
    <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  }
  
  <span class="enscript-comment">/* Make sure the local source number is valid */</span>
  <span class="enscript-keyword">if</span> ((source &lt; 0) || (source &gt;= _numInterruptSources))
    <span class="enscript-keyword">return</span> kIOReturnNoInterrupt;
  
  <span class="enscript-comment">/* Look up the contoller for the local source */</span>
  *interruptController = _interruptSources[source].interruptController;
  
  <span class="enscript-keyword">if</span> (*interruptController == NULL) {
    <span class="enscript-keyword">if</span> (!resolve) <span class="enscript-keyword">return</span> kIOReturnNoInterrupt;
    
    <span class="enscript-comment">/* Try to reslove the interrupt */</span>
    ret = resolveInterrupt(<span class="enscript-keyword">this</span>, source);
    <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;    
    
    *interruptController = _interruptSources[source].interruptController;
  }
  
  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::registerInterrupt</span>(<span class="enscript-type">int</span> source, OSObject *target,
				      IOInterruptAction handler,
				      <span class="enscript-type">void</span> *refCon)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, true, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  
  <span class="enscript-comment">/* Register the source */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;registerInterrupt(<span class="enscript-keyword">this</span>, source, target,
						(IOInterruptHandler)handler,
						refCon);
}

IOReturn <span class="enscript-function-name">IOService::unregisterInterrupt</span>(<span class="enscript-type">int</span> source)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, false, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  
  <span class="enscript-comment">/* Unregister the source */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;unregisterInterrupt(<span class="enscript-keyword">this</span>, source);
}

IOReturn <span class="enscript-function-name">IOService::addInterruptStatistics</span>(IOInterruptAccountingData * statistics, <span class="enscript-type">int</span> source)
{
  IOReportLegend * legend = NULL;
  IOInterruptAccountingData * oldValue = NULL;
  IOInterruptAccountingReporter * newArray = NULL;
  <span class="enscript-type">char</span> subgroupName[64];
  <span class="enscript-type">int</span> newArraySize = 0;
  <span class="enscript-type">int</span> i = 0;

  <span class="enscript-keyword">if</span> (source &lt; 0) {
    <span class="enscript-keyword">return</span> kIOReturnBadArgument;
  }

  <span class="enscript-comment">/*
   * We support statistics on a maximum of 256 interrupts per nub; if a nub
   * has more than 256 interrupt specifiers associated with it, and tries
   * to register a high interrupt index with interrupt accounting, panic.
   * Having more than 256 interrupts associated with a single nub is
   * probably a sign that something fishy is going on.
   */</span>
  <span class="enscript-keyword">if</span> (source &gt; IA_INDEX_MAX) {
    panic(<span class="enscript-string">&quot;addInterruptStatistics called for an excessively large index (%d)&quot;</span>, source);
  }

  <span class="enscript-comment">/*
   * TODO: This is ugly (wrapping a lock around an allocation).  I'm only
   * leaving it as is because the likelihood of contention where we are
   * actually growing the array is minimal (we would realistically need
   * to be starting a driver for the first time, with an IOReporting
   * client already in place).  Nonetheless, cleanup that can be done
   * to adhere to best practices; it'll make the code more complicated,
   * unfortunately.
   */</span>
  IOLockLock(reserved-&gt;interruptStatisticsLock);

  <span class="enscript-comment">/*
   * Lazily allocate the statistics array.
   */</span>
  <span class="enscript-keyword">if</span> (!reserved-&gt;interruptStatisticsArray) {
    reserved-&gt;interruptStatisticsArray = IONew(IOInterruptAccountingReporter, 1);
    assert(reserved-&gt;interruptStatisticsArray);
    reserved-&gt;interruptStatisticsArrayCount = 1;
    bzero(reserved-&gt;interruptStatisticsArray, <span class="enscript-keyword">sizeof</span>(*reserved-&gt;interruptStatisticsArray));
  }

  <span class="enscript-keyword">if</span> (source &gt;= reserved-&gt;interruptStatisticsArrayCount) {
    <span class="enscript-comment">/*
     * We're still within the range of supported indices, but we are out
     * of space in the current array.  Do a nasty realloc (because
     * IORealloc isn't a thing) here.  We'll double the size with each
     * reallocation.
     *
     * Yes, the &quot;next power of 2&quot; could be more efficient; but this will
     * be invoked incredibly rarely.  Who cares.
     */</span>
    newArraySize = (reserved-&gt;interruptStatisticsArrayCount &lt;&lt; 1);

    <span class="enscript-keyword">while</span> (newArraySize &lt;= source)
      newArraySize = (newArraySize &lt;&lt; 1);
    newArray = IONew(IOInterruptAccountingReporter, newArraySize);

    assert(newArray);

    <span class="enscript-comment">/*
     * TODO: This even zeroes the memory it is about to overwrite.
     * Shameful; fix it.  Not particularly high impact, however.
     */</span>
    bzero(newArray, newArraySize * <span class="enscript-keyword">sizeof</span>(*newArray));
    memcpy(newArray, reserved-&gt;interruptStatisticsArray, reserved-&gt;interruptStatisticsArrayCount * <span class="enscript-keyword">sizeof</span>(*newArray));
    IODelete(reserved-&gt;interruptStatisticsArray, IOInterruptAccountingReporter, reserved-&gt;interruptStatisticsArrayCount);
    reserved-&gt;interruptStatisticsArray = newArray;
    reserved-&gt;interruptStatisticsArrayCount = newArraySize;
  }

  <span class="enscript-keyword">if</span> (!reserved-&gt;interruptStatisticsArray[source].reporter) {
    <span class="enscript-comment">/*
     * We don't have a reporter associated with this index yet, so we
     * need to create one.
     */</span>
    <span class="enscript-comment">/*
     * TODO: Some statistics do in fact have common units (time); should this be
     * split into separate reporters to communicate this?
     */</span>
     reserved-&gt;interruptStatisticsArray[source].reporter = IOSimpleReporter::with(<span class="enscript-keyword">this</span>, kIOReportCategoryPower, kIOReportUnitNone);

    <span class="enscript-comment">/*
     * Each statistic is given an identifier based on the interrupt index (which
     * should be unique relative to any single nub) and the statistic involved.
     * We should now have a sane (small and positive) index, so start
     * constructing the channels for statistics.
     */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; IA_NUM_INTERRUPT_ACCOUNTING_STATISTICS; i++) {
      <span class="enscript-comment">/*
       * TODO: Currently, this does not add channels for disabled statistics.
       * Will this be confusing for clients?  If so, we should just add the
       * channels; we can avoid updating the channels even if they exist.
       */</span>
      <span class="enscript-keyword">if</span> (IA_GET_STATISTIC_ENABLED(i))
        reserved-&gt;interruptStatisticsArray[source].reporter-&gt;addChannel(IA_GET_CHANNEL_ID(source, i), kInterruptAccountingStatisticNameArray[i]);
    }

    <span class="enscript-comment">/*
     * We now need to add the legend for this reporter to the registry.
     */</span>
    legend = IOReportLegend::with(OSDynamicCast(OSArray, getProperty(kIOReportLegendKey)));

    <span class="enscript-comment">/*
     * Note that while we compose the subgroup name, we do not need to
     * manage its lifecycle (the reporter will handle this).
     */</span>
    snprintf(subgroupName, <span class="enscript-keyword">sizeof</span>(subgroupName), <span class="enscript-string">&quot;%s %d&quot;</span>, getName(), source);
    subgroupName[<span class="enscript-keyword">sizeof</span>(subgroupName) - 1] = 0;
    legend-&gt;addReporterLegend(reserved-&gt;interruptStatisticsArray[source].reporter, kInterruptAccountingGroupName, subgroupName);
    setProperty(kIOReportLegendKey, legend-&gt;getLegend());
    legend-&gt;release();

    <span class="enscript-comment">/*
     * TODO: Is this a good idea?  Probably not; my assumption is it opts
     * all entities who register interrupts into public disclosure of all
     * IOReporting channels.  Unfortunately, this appears to be as fine
     * grain as it gets.
     */</span>
    setProperty(kIOReportLegendPublicKey, true);
  }

  <span class="enscript-comment">/*
   * Don't stomp existing entries.  If we are about to, panic; this
   * probably means we failed to tear down our old interrupt source
   * correctly.
   */</span>
  oldValue = reserved-&gt;interruptStatisticsArray[source].statistics;

  <span class="enscript-keyword">if</span> (oldValue) {
    panic(<span class="enscript-string">&quot;addInterruptStatistics call for index %d would have clobbered existing statistics&quot;</span>, source);
  }

  reserved-&gt;interruptStatisticsArray[source].statistics = statistics;

  <span class="enscript-comment">/*
   * Inherit the reporter values for each statistic.  The target may
   * be torn down as part of the runtime of the service (especially
   * for sleep/wake), so we inherit in order to avoid having values
   * reset for no apparent reason.  Our statistics are ultimately
   * tied to the index and the sevice, not to an individual target,
   * so we should maintain them accordingly.
   */</span>
  interruptAccountingDataInheritChannels(reserved-&gt;interruptStatisticsArray[source].statistics, reserved-&gt;interruptStatisticsArray[source].reporter);

  IOLockUnlock(reserved-&gt;interruptStatisticsLock);

  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::removeInterruptStatistics</span>(<span class="enscript-type">int</span> source)
{
  IOInterruptAccountingData * value = NULL;

  <span class="enscript-keyword">if</span> (source &lt; 0) {
    <span class="enscript-keyword">return</span> kIOReturnBadArgument;
  }

  IOLockLock(reserved-&gt;interruptStatisticsLock);

  <span class="enscript-comment">/*
   * We dynamically grow the statistics array, so an excessively
   * large index value has NEVER been registered.  This either
   * means our cap on the array size is too small (unlikely), or
   * that we have been passed a corrupt index (this must be passed
   * the plain index into the interrupt specifier list).
   */</span>
  <span class="enscript-keyword">if</span> (source &gt;= reserved-&gt;interruptStatisticsArrayCount) {
    panic(<span class="enscript-string">&quot;removeInterruptStatistics called for index %d, which was never registered&quot;</span>, source);
  }

  assert(reserved-&gt;interruptStatisticsArray);

  <span class="enscript-comment">/*
   * If there is no existing entry, we are most likely trying to
   * free an interrupt owner twice, or we have corrupted the
   * index value.
   */</span>
  value = reserved-&gt;interruptStatisticsArray[source].statistics;

  <span class="enscript-keyword">if</span> (!value) {
    panic(<span class="enscript-string">&quot;removeInterruptStatistics called for empty index %d&quot;</span>, source);
  }

  <span class="enscript-comment">/*
   * We update the statistics, so that any delta with the reporter
   * state is not lost.
   */</span>
  interruptAccountingDataUpdateChannels(reserved-&gt;interruptStatisticsArray[source].statistics, reserved-&gt;interruptStatisticsArray[source].reporter);
  reserved-&gt;interruptStatisticsArray[source].statistics = NULL;
  IOLockUnlock(reserved-&gt;interruptStatisticsLock);

  <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::getInterruptType</span>(<span class="enscript-type">int</span> source, <span class="enscript-type">int</span> *interruptType)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, true, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
    
  <span class="enscript-comment">/* Return the type */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;getInterruptType(<span class="enscript-keyword">this</span>, source, interruptType);
}

IOReturn <span class="enscript-function-name">IOService::enableInterrupt</span>(<span class="enscript-type">int</span> source)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, false, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  
  <span class="enscript-comment">/* Enable the source */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;enableInterrupt(<span class="enscript-keyword">this</span>, source);
}

IOReturn <span class="enscript-function-name">IOService::disableInterrupt</span>(<span class="enscript-type">int</span> source)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, false, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  
  <span class="enscript-comment">/* Disable the source */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;disableInterrupt(<span class="enscript-keyword">this</span>, source);
}

IOReturn <span class="enscript-function-name">IOService::causeInterrupt</span>(<span class="enscript-type">int</span> source)
{
  IOInterruptController *interruptController;
  IOReturn              ret;
  
  ret = lookupInterrupt(source, false, &amp;interruptController);
  <span class="enscript-keyword">if</span> (ret != kIOReturnSuccess) <span class="enscript-keyword">return</span> ret;
  
  <span class="enscript-comment">/* Cause an interrupt for the source */</span>
  <span class="enscript-keyword">return</span> interruptController-&gt;causeInterrupt(<span class="enscript-keyword">this</span>, source);
}

IOReturn <span class="enscript-function-name">IOService::configureReport</span>(IOReportChannelList    *channelList,
                                    IOReportConfigureAction action,
                                    <span class="enscript-type">void</span>                   *result,
                                    <span class="enscript-type">void</span>                   *destination)
{
    <span class="enscript-type">unsigned</span> cnt;

    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; channelList-&gt;nchannels; cnt++) {
        <span class="enscript-keyword">if</span> ( channelList-&gt;channels[cnt].channel_id == kPMPowerStatesChID ) {
            <span class="enscript-keyword">if</span> (pwrMgt) configurePowerStatesReport(action, result);
            <span class="enscript-keyword">else</span>  <span class="enscript-keyword">return</span> kIOReturnUnsupported;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( channelList-&gt;channels[cnt].channel_id == kPMCurrStateChID ) {
            <span class="enscript-keyword">if</span> (pwrMgt) configureSimplePowerReport(action, result);
            <span class="enscript-keyword">else</span>  <span class="enscript-keyword">return</span> kIOReturnUnsupported;
        }
    }

    IOLockLock(reserved-&gt;interruptStatisticsLock);

    <span class="enscript-comment">/* The array count is signed (because the interrupt indices are signed), hence the cast */</span>
    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; (<span class="enscript-type">unsigned</span>) reserved-&gt;interruptStatisticsArrayCount; cnt++) {
        <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray[cnt].reporter) {
            <span class="enscript-comment">/*
             * If the reporter is currently associated with the statistics
             * for an event source, we may need to update the reporter.
             */</span>
            <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray[cnt].statistics)
                interruptAccountingDataUpdateChannels(reserved-&gt;interruptStatisticsArray[cnt].statistics, reserved-&gt;interruptStatisticsArray[cnt].reporter);

            reserved-&gt;interruptStatisticsArray[cnt].reporter-&gt;configureReport(channelList, action, result, destination);
        }        
    }

    IOLockUnlock(reserved-&gt;interruptStatisticsLock);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOService::updateReport</span>(IOReportChannelList      *channelList,
                                 IOReportUpdateAction      action,
                                 <span class="enscript-type">void</span>                     *result,
                                 <span class="enscript-type">void</span>                     *destination)
{
    <span class="enscript-type">unsigned</span> cnt;

    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; channelList-&gt;nchannels; cnt++) {
        <span class="enscript-keyword">if</span> ( channelList-&gt;channels[cnt].channel_id == kPMPowerStatesChID ) {
            <span class="enscript-keyword">if</span> (pwrMgt) updatePowerStatesReport(action, result, destination);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> kIOReturnUnsupported;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( channelList-&gt;channels[cnt].channel_id == kPMCurrStateChID ) {
            <span class="enscript-keyword">if</span> (pwrMgt) updateSimplePowerReport(action, result, destination);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> kIOReturnUnsupported;
        }
    }

    IOLockLock(reserved-&gt;interruptStatisticsLock);

    <span class="enscript-comment">/* The array count is signed (because the interrupt indices are signed), hence the cast */</span>
    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; (<span class="enscript-type">unsigned</span>) reserved-&gt;interruptStatisticsArrayCount; cnt++) {
        <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray[cnt].reporter) {
            <span class="enscript-comment">/*
             * If the reporter is currently associated with the statistics
             * for an event source, we need to update the reporter.
             */</span>
            <span class="enscript-keyword">if</span> (reserved-&gt;interruptStatisticsArray[cnt].statistics)
                interruptAccountingDataUpdateChannels(reserved-&gt;interruptStatisticsArray[cnt].statistics, reserved-&gt;interruptStatisticsArray[cnt].reporter);

            reserved-&gt;interruptStatisticsArray[cnt].reporter-&gt;updateReport(channelList, action, result, destination);
        }
    }

    IOLockUnlock(reserved-&gt;interruptStatisticsLock);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

uint64_t <span class="enscript-function-name">IOService::getAuthorizationID</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> reserved-&gt;authorizationID;
}

IOReturn <span class="enscript-function-name">IOService::setAuthorizationID</span>( uint64_t authorizationID )
{
    OSObject * entitlement;
    IOReturn status;

    entitlement = IOUserClient::copyClientEntitlement( current_task( ), <span class="enscript-string">&quot;com.apple.private.iokit.IOServiceSetAuthorizationID&quot;</span> );

    <span class="enscript-keyword">if</span> ( entitlement )
    {
        <span class="enscript-keyword">if</span> ( entitlement == kOSBooleanTrue )
        {
            reserved-&gt;authorizationID = authorizationID;

            status = kIOReturnSuccess;
        }
        <span class="enscript-keyword">else</span>
        {
            status = kIOReturnNotPrivileged;
        }

        entitlement-&gt;release( );
    }
    <span class="enscript-keyword">else</span>
    {
        status = kIOReturnNotPrivileged;
    }

    <span class="enscript-keyword">return</span> status;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 7);
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOService, 7);
#<span class="enscript-reference">endif</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 8);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 9);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 10);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 11);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 12);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 13);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 14);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 15);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 16);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 17);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 18);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 19);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 20);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 21);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 22);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 23);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 24);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 25);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 26);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 27);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 28);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 29);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 30);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 31);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 32);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 33);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 34);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 35);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 36);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 37);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 38);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 39);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 40);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 41);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 42);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 43);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 44);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 45);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 46);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOService, 47);
</pre>
<hr />
</body></html>