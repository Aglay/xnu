<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IODataQueue.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IODataQueue.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DISABLE_DATAQUEUE_WARNING</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODataQueue.h&gt;</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">DISABLE_DATAQUEUE_WARNING</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODataQueueShared.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

<span class="enscript-type">struct</span> IODataQueueInternal
{
    mach_msg_header_t msg;
    UInt32            queueSize;
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">enqueue</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">enqueue</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">dequeue</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">dequeue</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IODataQueue, OSObject)

IODataQueue *<span class="enscript-function-name">IODataQueue::withCapacity</span>(UInt32 size)
{
    IODataQueue *dataQueue = <span class="enscript-keyword">new</span> IODataQueue;

    <span class="enscript-keyword">if</span> (dataQueue) {
        <span class="enscript-keyword">if</span>  (!dataQueue-&gt;initWithCapacity(size)) {
            dataQueue-&gt;release();
            dataQueue = 0;
        }
    }

    <span class="enscript-keyword">return</span> dataQueue;
}

IODataQueue *<span class="enscript-function-name">IODataQueue::withEntries</span>(UInt32 numEntries, UInt32 entrySize)
{
    IODataQueue *dataQueue = <span class="enscript-keyword">new</span> IODataQueue;

    <span class="enscript-keyword">if</span> (dataQueue) {
        <span class="enscript-keyword">if</span> (!dataQueue-&gt;initWithEntries(numEntries, entrySize)) {
            dataQueue-&gt;release();
            dataQueue = 0;
        }
    }

    <span class="enscript-keyword">return</span> dataQueue;
}

Boolean <span class="enscript-function-name">IODataQueue::initWithCapacity</span>(UInt32 size)
{
    vm_size_t allocSize = 0;

    <span class="enscript-keyword">if</span> (!super::init()) {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> (size &gt; UINT32_MAX - DATA_QUEUE_MEMORY_HEADER_SIZE) {
        <span class="enscript-keyword">return</span> false;
    }
    
    allocSize = round_page(size + DATA_QUEUE_MEMORY_HEADER_SIZE);

    <span class="enscript-keyword">if</span> (allocSize &lt; size) {
        <span class="enscript-keyword">return</span> false;
    }

    assert(!notifyMsg);
    notifyMsg = IONew(IODataQueueInternal, 1);
	<span class="enscript-keyword">if</span> (!notifyMsg) {
		<span class="enscript-keyword">return</span> false;
	}
    bzero(notifyMsg, <span class="enscript-keyword">sizeof</span>(IODataQueueInternal));
    ((IODataQueueInternal *)notifyMsg)-&gt;queueSize = size;

    dataQueue = (IODataQueueMemory *)IOMallocAligned(allocSize, PAGE_SIZE);
    <span class="enscript-keyword">if</span> (dataQueue == 0) {
        <span class="enscript-keyword">return</span> false;
    }
    bzero(dataQueue, allocSize);

    dataQueue-&gt;queueSize    = size;
<span class="enscript-comment">//  dataQueue-&gt;head         = 0;
</span><span class="enscript-comment">//  dataQueue-&gt;tail         = 0;
</span>
    <span class="enscript-keyword">return</span> true;
}

Boolean <span class="enscript-function-name">IODataQueue::initWithEntries</span>(UInt32 numEntries, UInt32 entrySize)
{
    <span class="enscript-comment">// Checking overflow for (numEntries + 1)*(entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE):
</span>    <span class="enscript-comment">//  check (entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE)
</span>    <span class="enscript-keyword">if</span> ((entrySize &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) ||
        <span class="enscript-comment">//  check (numEntries + 1)
</span>        (numEntries &gt; UINT32_MAX-1) ||
        <span class="enscript-comment">//  check (numEntries + 1)*(entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE)
</span>        (entrySize + DATA_QUEUE_ENTRY_HEADER_SIZE &gt; UINT32_MAX/(numEntries+1))) {
        <span class="enscript-keyword">return</span> false;
    }
    
    <span class="enscript-keyword">return</span> (initWithCapacity((numEntries + 1) * (DATA_QUEUE_ENTRY_HEADER_SIZE + entrySize)));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IODataQueue::free</span>()
{
	<span class="enscript-keyword">if</span> (notifyMsg) {
		<span class="enscript-keyword">if</span> (dataQueue) {
			IOFreeAligned(dataQueue, round_page(((IODataQueueInternal *)notifyMsg)-&gt;queueSize + DATA_QUEUE_MEMORY_HEADER_SIZE));
			dataQueue = NULL;
		}

		IODelete(notifyMsg, IODataQueueInternal, 1);
		notifyMsg = NULL;
    }

    <span class="enscript-reference">super</span>::free();

    <span class="enscript-keyword">return</span>;
}

Boolean <span class="enscript-function-name">IODataQueue::enqueue</span>(<span class="enscript-type">void</span> * data, UInt32 dataSize)
{
    <span class="enscript-type">const</span> UInt32       head      = dataQueue-&gt;head;  <span class="enscript-comment">// volatile
</span>    <span class="enscript-type">const</span> UInt32       tail      = dataQueue-&gt;tail;
    <span class="enscript-type">const</span> UInt32       entrySize = dataSize + DATA_QUEUE_ENTRY_HEADER_SIZE;
    UInt32             queueSize;
    IODataQueueEntry * entry;

    <span class="enscript-comment">// Check for overflow of entrySize
</span>    <span class="enscript-keyword">if</span> (dataSize &gt; UINT32_MAX - DATA_QUEUE_ENTRY_HEADER_SIZE) {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-comment">// Check for underflow of (dataQueue-&gt;queueSize - tail)
</span>    queueSize = ((IODataQueueInternal *) notifyMsg)-&gt;queueSize;
    <span class="enscript-keyword">if</span> ((queueSize &lt; tail) || (queueSize &lt; head)) {
        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> ( tail &gt;= head )
    {
        <span class="enscript-comment">// Is there enough room at the end for the entry?
</span>        <span class="enscript-keyword">if</span> ((entrySize &lt;= UINT32_MAX - tail) &amp;&amp;
            ((tail + entrySize) &lt;= queueSize) )
        {
            entry = (IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail);

            entry-&gt;size = dataSize;
            memcpy(&amp;entry-&gt;data, data, dataSize);

            <span class="enscript-comment">// The tail can be out of bound when the size of the new entry
</span>            <span class="enscript-comment">// exactly matches the available space at the end of the queue.
</span>            <span class="enscript-comment">// The tail can range from 0 to dataQueue-&gt;queueSize inclusive.
</span>            
            OSAddAtomic(entrySize, (SInt32 *)&amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( head &gt; entrySize )     <span class="enscript-comment">// Is there enough room at the beginning?
</span>        {
            <span class="enscript-comment">// Wrap around to the beginning, but do not allow the tail to catch
</span>            <span class="enscript-comment">// up to the head.
</span>
            dataQueue-&gt;queue-&gt;size = dataSize;

            <span class="enscript-comment">// We need to make sure that there is enough room to set the size before
</span>            <span class="enscript-comment">// doing this. The user client checks for this and will look for the size
</span>            <span class="enscript-comment">// at the beginning if there isn't room for it at the end.
</span>
            <span class="enscript-keyword">if</span> ( ( queueSize - tail ) &gt;= DATA_QUEUE_ENTRY_HEADER_SIZE )
            {
                ((IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail))-&gt;size = dataSize;
            }

            memcpy(&amp;dataQueue-&gt;queue-&gt;data, data, dataSize);
            OSCompareAndSwap(dataQueue-&gt;tail, entrySize, &amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> false;    <span class="enscript-comment">// queue is full
</span>        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Do not allow the tail to catch up to the head when the queue is full.
</span>        <span class="enscript-comment">// That's why the comparison uses a '&gt;' rather than '&gt;='.
</span>
        <span class="enscript-keyword">if</span> ( (head - tail) &gt; entrySize )
        {
            entry = (IODataQueueEntry *)((UInt8 *)dataQueue-&gt;queue + tail);

            entry-&gt;size = dataSize;
            memcpy(&amp;entry-&gt;data, data, dataSize);
            OSAddAtomic(entrySize, (SInt32 *)&amp;dataQueue-&gt;tail);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-keyword">return</span> false;    <span class="enscript-comment">// queue is full
</span>        }
    }

    <span class="enscript-comment">// Send notification (via mach message) that data is available.
</span>
    <span class="enscript-keyword">if</span> ( ( head == tail )                                                   <span class="enscript-comment">/* queue was empty prior to enqueue() */</span>
    ||   ( dataQueue-&gt;head == tail ) )   <span class="enscript-comment">/* queue was emptied during enqueue() */</span>
    {
        sendDataAvailableNotification();
    }

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IODataQueue::setNotificationPort</span>(mach_port_t port)
{
    mach_msg_header_t * msgh;

    msgh = &amp;((IODataQueueInternal *) notifyMsg)-&gt;msg;
	bzero(msgh, <span class="enscript-keyword">sizeof</span>(mach_msg_header_t));
	msgh-&gt;msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
	msgh-&gt;msgh_size = <span class="enscript-keyword">sizeof</span>(mach_msg_header_t);
	msgh-&gt;msgh_remote_port = port;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IODataQueue::sendDataAvailableNotification</span>()
{
    kern_return_t       kr;
    mach_msg_header_t * msgh;

    msgh = &amp;((IODataQueueInternal *) notifyMsg)-&gt;msg;
    <span class="enscript-keyword">if</span> (msgh-&gt;msgh_remote_port) {
        kr = mach_msg_send_from_kernel_with_options(msgh, msgh-&gt;msgh_size, MACH_SEND_TIMEOUT, MACH_MSG_TIMEOUT_NONE);
        <span class="enscript-keyword">switch</span>(kr) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_SEND_TIMED_OUT</span>:    <span class="enscript-comment">// Notification already sent
</span>            <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_SUCCESS</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_SEND_NO_BUFFER</span>:
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                IOLog(<span class="enscript-string">&quot;%s: dataAvailableNotification failed - msg_send returned: %d\n&quot;</span>, <span class="enscript-comment">/*getName()*/</span><span class="enscript-string">&quot;IODataQueue&quot;</span>, kr);
                <span class="enscript-keyword">break</span>;
        }
    }
}

IOMemoryDescriptor *<span class="enscript-function-name">IODataQueue::getMemoryDescriptor</span>()
{
    IOMemoryDescriptor *descriptor = 0;
    UInt32              queueSize;

    queueSize = ((IODataQueueInternal *) notifyMsg)-&gt;queueSize;
    <span class="enscript-keyword">if</span> (dataQueue != 0) {
        descriptor = IOMemoryDescriptor::withAddress(dataQueue, queueSize + DATA_QUEUE_MEMORY_HEADER_SIZE, kIODirectionOutIn);
    }

    <span class="enscript-keyword">return</span> descriptor;
}


</pre>
<hr />
</body></html>