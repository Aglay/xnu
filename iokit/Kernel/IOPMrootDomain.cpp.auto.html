<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOPMrootDomain.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOPMrootDomain.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSMetaClass.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOWorkLoop.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCommandGate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCPU.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTimeStamp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMlog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/RootDomain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/pwr_mgt/IOPMPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMessage.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReturn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IONVRAM.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;RootDomainUserClient.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKit/pwr_mgt/IOPowerConnection.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOPMPowerStateQueue.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOReportMacros.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/video_console.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePrivate.h&quot;</span>   // _IOServiceInterestNotifier
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePMPrivate.h&quot;</span>

__BEGIN_DECLS
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/shared_region.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
__END_DECLS

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
__BEGIN_DECLS
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOPMrootDomainInternal.h&quot;</span>
__END_DECLS
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMrootDomainClass</span>    <span class="enscript-string">&quot;IOPMrootDomain&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_PREFIX</span>              <span class="enscript-string">&quot;PMRD: &quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">MSG</span>(x...) \
    <span class="enscript-keyword">do</span> { kprintf(LOG_PREFIX x); IOLog(x); } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOG</span>(x...)    \
    <span class="enscript-keyword">do</span> { kprintf(LOG_PREFIX x); } <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DLOG</span>(x...)  do { \
    <span class="enscript-keyword">if</span> (kIOLogPMRootDomain &amp; gIOKitDebug) \
        kprintf(LOG_PREFIX x); \
} <span class="enscript-keyword">while</span> (false)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DMSG</span>(x...)  do { \
    <span class="enscript-keyword">if</span> (kIOLogPMRootDomain &amp; gIOKitDebug) { \
        kprintf(LOG_PREFIX x); IOLog(x); \
    } \
} <span class="enscript-keyword">while</span> (false)


#<span class="enscript-reference">define</span> <span class="enscript-function-name">_LOG</span>(x...)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHECK_THREAD_CONTEXT</span>
#<span class="enscript-reference">ifdef</span>  <span class="enscript-variable-name">CHECK_THREAD_CONTEXT</span>
<span class="enscript-type">static</span> IOWorkLoop * gIOPMWorkLoop = 0;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_GATED</span>()                                      \
<span class="enscript-keyword">do</span> {                                                        \
    <span class="enscript-keyword">if</span> (gIOPMWorkLoop &amp;&amp; gIOPMWorkLoop-&gt;inGate() != true) { \
        panic(<span class="enscript-string">&quot;RootDomain: not inside PM gate&quot;</span>);            \
    }                                                       \
} <span class="enscript-keyword">while</span>(false)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT_GATED</span>()
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CHECK_THREAD_CONTEXT */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAP_LOSS</span>(c)  \
        (((_pendingCapability &amp; (c)) == 0) &amp;&amp; \
         ((_currentCapability &amp; (c)) != 0))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAP_GAIN</span>(c)  \
        (((_currentCapability &amp; (c)) == 0) &amp;&amp; \
         ((_pendingCapability &amp; (c)) != 0))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAP_CHANGE</span>(c)    \
        (((_currentCapability ^ _pendingCapability) &amp; (c)) != 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAP_CURRENT</span>(c)  \
        ((_currentCapability &amp; (c)) != 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CAP_HIGHEST</span>(c)  \
        ((_highestCapability &amp; (c)) != 0)

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DARK_TO_FULL_EVALUATE_CLAMSHELL</span>     1
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// Event types for IOPMPowerStateQueue::submitPowerEvent()
</span><span class="enscript-type">enum</span> {
    kPowerEventFeatureChanged = 1,              <span class="enscript-comment">// 1
</span>    kPowerEventReceivedPowerNotification,       <span class="enscript-comment">// 2
</span>    kPowerEventSystemBootCompleted,             <span class="enscript-comment">// 3
</span>    kPowerEventSystemShutdown,                  <span class="enscript-comment">// 4
</span>    kPowerEventUserDisabledSleep,               <span class="enscript-comment">// 5
</span>    kPowerEventRegisterSystemCapabilityClient,  <span class="enscript-comment">// 6
</span>    kPowerEventRegisterKernelCapabilityClient,  <span class="enscript-comment">// 7
</span>    kPowerEventPolicyStimulus,                  <span class="enscript-comment">// 8
</span>    kPowerEventAssertionCreate,                 <span class="enscript-comment">// 9
</span>    kPowerEventAssertionRelease,                <span class="enscript-comment">// 10
</span>    kPowerEventAssertionSetLevel,               <span class="enscript-comment">// 11
</span>    kPowerEventQueueSleepWakeUUID,              <span class="enscript-comment">// 12
</span>    kPowerEventPublishSleepWakeUUID,            <span class="enscript-comment">// 13
</span>    kPowerEventSetDisplayPowerOn                <span class="enscript-comment">// 14
</span>};

<span class="enscript-comment">// For evaluatePolicy()
</span><span class="enscript-comment">// List of stimuli that affects the root domain policy.
</span><span class="enscript-type">enum</span> {
    kStimulusDisplayWranglerSleep,      <span class="enscript-comment">// 0
</span>    kStimulusDisplayWranglerWake,       <span class="enscript-comment">// 1
</span>    kStimulusAggressivenessChanged,     <span class="enscript-comment">// 2
</span>    kStimulusDemandSystemSleep,         <span class="enscript-comment">// 3
</span>    kStimulusAllowSystemSleepChanged,   <span class="enscript-comment">// 4
</span>    kStimulusDarkWakeActivityTickle,    <span class="enscript-comment">// 5
</span>    kStimulusDarkWakeEntry,             <span class="enscript-comment">// 6
</span>    kStimulusDarkWakeReentry,           <span class="enscript-comment">// 7
</span>    kStimulusDarkWakeEvaluate,          <span class="enscript-comment">// 8
</span>    kStimulusNoIdleSleepPreventers,     <span class="enscript-comment">// 9
</span>    kStimulusEnterUserActiveState,      <span class="enscript-comment">// 10
</span>    kStimulusLeaveUserActiveState       <span class="enscript-comment">// 11
</span>};

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
IOReturn <span class="enscript-function-name">OSKextSystemSleepOrWake</span>( UInt32 );
}
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> ppnum_t      pmap_find_phys(pmap_t pmap, addr64_t va);
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> addr64_t     kvtophys(vm_offset_t va);
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">int</span>  stack_snapshot_from_kernel(pid_t pid, <span class="enscript-type">void</span> *buf, uint32_t size, uint32_t flags, <span class="enscript-type">unsigned</span> *bytesTraced);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">idleSleepTimerExpired</span>( thread_call_param_t, thread_call_param_t );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">notifySystemShutdown</span>( IOService * root, uint32_t messageType );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">handleAggressivesFunction</span>( thread_call_param_t, thread_call_param_t );
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pmEventTimeStamp</span>(uint64_t *recordTS);

<span class="enscript-comment">// &quot;IOPMSetSleepSupported&quot;  callPlatformFunction name
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol *sleepSupportedPEFunction = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol *sleepMessagePEFunction   = NULL;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOSleepSupportedKey</span>        <span class="enscript-string">&quot;IOSleepSupported&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMSystemCapabilitiesKey</span>  <span class="enscript-string">&quot;System Capabilities&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIORequestWranglerIdleKey</span>   <span class="enscript-string">&quot;IORequestIdle&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kDefaultWranglerIdlePeriod</span>  25 // in milliseconds

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOSleepWakeDebugKey</span>        <span class="enscript-string">&quot;Persistent-memory-note&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kRD_AllPowerSources</span> (kIOPMSupportedOnAC \
                           | kIOPMSupportedOnBatt \
                           | kIOPMSupportedOnUPS)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLocalEvalClamshellCommand</span>  (1 &lt;&lt; 15)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIdleSleepRetryInterval</span>     (3 * 60)

<span class="enscript-type">enum</span> {
    kWranglerPowerStateMin   = 0,
    kWranglerPowerStateSleep = 2,
    kWranglerPowerStateDim   = 3,
    kWranglerPowerStateMax   = 4
};

<span class="enscript-type">enum</span> {
    OFF_STATE           = 0,
    RESTART_STATE       = 1,
    SLEEP_STATE         = 2,
    ON_STATE            = 3,
    NUM_POWER_STATES
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ON_POWER</span>        kIOPMPowerOn
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RESTART_POWER</span>   kIOPMRestart
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLEEP_POWER</span>     kIOPMAuxPowerOn

<span class="enscript-type">static</span> IOPMPowerState ourPowerStates[NUM_POWER_STATES] =
{
    {1, 0,                      0,              0,             0,0,0,0,0,0,0,0},
    {1, kIOPMRestartCapability, kIOPMRestart,   RESTART_POWER, 0,0,0,0,0,0,0,0},
    {1, kIOPMSleepCapability,   kIOPMSleep,     SLEEP_POWER,   0,0,0,0,0,0,0,0},
    {1, kIOPMPowerOn,           kIOPMPowerOn,   ON_POWER,      0,0,0,0,0,0,0,0}
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeSleepService</span>     <span class="enscript-string">&quot;SleepService&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeMaintenance</span>      <span class="enscript-string">&quot;Maintenance&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeSleepTimer</span>       <span class="enscript-string">&quot;SleepTimer&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMrootDomainWakeTypeLowBattery</span>       <span class="enscript-string">&quot;LowBattery&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeUser</span>             <span class="enscript-string">&quot;User&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeAlarm</span>            <span class="enscript-string">&quot;Alarm&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeNetwork</span>          <span class="enscript-string">&quot;Network&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeHIDActivity</span>      <span class="enscript-string">&quot;HID Activity&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeNotification</span>     <span class="enscript-string">&quot;Notification&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRootDomainWakeTypeHibernateError</span>   <span class="enscript-string">&quot;HibernateError&quot;</span>

<span class="enscript-comment">// Special interest that entitles the interested client from receiving
</span><span class="enscript-comment">// all system messages. Only used by powerd.
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMSystemCapabilityInterest</span>       <span class="enscript-string">&quot;IOPMSystemCapabilityInterest&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">WAKEEVENT_LOCK</span>()        IOLockLock(wakeEventLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">WAKEEVENT_UNLOCK</span>()      IOLockUnlock(wakeEventLock)

<span class="enscript-comment">/*
 * Aggressiveness
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AGGRESSIVES_LOCK</span>()      IOLockLock(featuresDictLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">AGGRESSIVES_UNLOCK</span>()    IOLockUnlock(featuresDictLock)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kAggressivesMinValue</span>    1

<span class="enscript-type">enum</span> {
    kAggressivesStateBusy           = 0x01,
    kAggressivesStateQuickSpindown  = 0x02
};

<span class="enscript-type">struct</span> AggressivesRecord {
    uint32_t    flags;
    uint32_t    type;
    uint32_t    value;
};

<span class="enscript-type">struct</span> AggressivesRequest {
    queue_chain_t           chain;
    uint32_t                options;
    uint32_t                dataType;
    <span class="enscript-type">union</span> {
        IOService *         service;
        AggressivesRecord   record;
    } data;
};

<span class="enscript-type">enum</span> {
    kAggressivesRequestTypeService  = 1,
    kAggressivesRequestTypeRecord
};

<span class="enscript-type">enum</span> {
    kAggressivesOptionSynchronous          = 0x00000001,
    kAggressivesOptionQuickSpindownEnable  = 0x00000100,
    kAggressivesOptionQuickSpindownDisable = 0x00000200,
    kAggressivesOptionQuickSpindownMask    = 0x00000300
};

<span class="enscript-type">enum</span> {
    kAggressivesRecordFlagModified         = 0x00000001,
    kAggressivesRecordFlagMinValue         = 0x00000002
};

<span class="enscript-comment">// gDarkWakeFlags
</span><span class="enscript-type">enum</span> {
    kDarkWakeFlagHIDTickleEarly      = 0x01, <span class="enscript-comment">// hid tickle before gfx suppression
</span>    kDarkWakeFlagHIDTickleLate       = 0x02, <span class="enscript-comment">// hid tickle after gfx suppression
</span>    kDarkWakeFlagHIDTickleNone       = 0x03, <span class="enscript-comment">// hid tickle is not posted
</span>    kDarkWakeFlagHIDTickleMask       = 0x03,
    kDarkWakeFlagAlarmIsDark         = 0x0100,
    kDarkWakeFlagGraphicsPowerState1 = 0x0200,
    kDarkWakeFlagAudioNotSuppressed  = 0x0400
};

<span class="enscript-type">static</span> IOPMrootDomain * gRootDomain;
<span class="enscript-type">static</span> IONotifier *     gSysPowerDownNotifier = 0;
<span class="enscript-type">static</span> UInt32           gSleepOrShutdownPending = 0;
<span class="enscript-type">static</span> UInt32           gWillShutdown = 0;
<span class="enscript-type">static</span> UInt32           gPagingOff = 0;
<span class="enscript-type">static</span> UInt32           gSleepWakeUUIDIsSet = false;
<span class="enscript-type">static</span> uint32_t         gAggressivesState = 0;

uuid_string_t bootsessionuuid_string;

<span class="enscript-type">static</span> uint32_t         gDarkWakeFlags = kDarkWakeFlagHIDTickleNone;
<span class="enscript-type">static</span> uint32_t         gNoIdleFlag = 0;
<span class="enscript-type">static</span> PMStatsStruct    gPMStats;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
<span class="enscript-type">static</span> IOPMSystemSleepPolicyHandler     gSleepPolicyHandler = 0;
<span class="enscript-type">static</span> IOPMSystemSleepPolicyVariables * gSleepPolicyVars = 0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *                           gSleepPolicyTarget;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> timeval gIOLastSleepTime;
<span class="enscript-type">struct</span> timeval gIOLastWakeTime;

<span class="enscript-type">static</span> <span class="enscript-type">char</span> gWakeReasonString[128];
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> gWakeReasonSysctlRegistered = false;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> gSpinDumpBufferFull = false;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     gPMHaltBusyCount;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     gPMHaltIdleCount;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>              gPMHaltDepth;
<span class="enscript-type">static</span> uint32_t         gPMHaltMessageType;
<span class="enscript-type">static</span> IOLock *         gPMHaltLock  = 0;
<span class="enscript-type">static</span> OSArray *        gPMHaltArray = 0;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gPMHaltClientAcknowledgeKey = 0;
<span class="enscript-type">static</span> <span class="enscript-type">bool</span>             gPMQuiesced;

<span class="enscript-comment">// Constants used as arguments to IOPMrootDomain::informCPUStateChange
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kCPUUnknownIndex</span>    9999999
<span class="enscript-type">enum</span> {
    kInformAC = 0,
    kInformLid = 1,
    kInformableCount = 2
};

<span class="enscript-type">const</span> OSSymbol *gIOPMStatsApplicationResponseTimedOut;
<span class="enscript-type">const</span> OSSymbol *gIOPMStatsApplicationResponseCancel;
<span class="enscript-type">const</span> OSSymbol *gIOPMStatsApplicationResponseSlow;
<span class="enscript-type">const</span> OSSymbol *gIOPMStatsApplicationResponsePrompt;
<span class="enscript-type">const</span> OSSymbol *gIOPMStatsDriverPSChangeSlow;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kBadPMFeatureID</span>     0

<span class="enscript-comment">/*
 * PMSettingHandle
 * Opaque handle passed to clients of registerPMSettingController()
 */</span>
<span class="enscript-type">class</span> PMSettingHandle : <span class="enscript-type">public</span> OSObject
{
    OSDeclareFinalStructors( PMSettingHandle )
    <span class="enscript-type">friend</span> <span class="enscript-type">class</span> PMSettingObject;

<span class="enscript-type">private</span>:
    PMSettingObject *pmso;
    <span class="enscript-type">void</span> free(<span class="enscript-type">void</span>) APPLE_KEXT_OVERRIDE;
};

<span class="enscript-comment">/*
 * PMSettingObject
 * Internal object to track each PM setting controller
 */</span>
<span class="enscript-type">class</span> PMSettingObject : <span class="enscript-type">public</span> OSObject
{
    OSDeclareFinalStructors( PMSettingObject )
    <span class="enscript-type">friend</span> <span class="enscript-type">class</span> IOPMrootDomain;

<span class="enscript-type">private</span>:
    queue_head_t                    calloutQueue;
    thread_t                        waitThread;
    IOPMrootDomain                  *parent;
    PMSettingHandle                 *pmsh;
    IOPMSettingControllerCallback   func;
    OSObject                        *target;
    uintptr_t                       refcon;
    uint32_t                        *publishedFeatureID;
    uint32_t                        settingCount;
    <span class="enscript-type">bool</span>                            disabled;

    <span class="enscript-type">void</span> free(<span class="enscript-type">void</span>) APPLE_KEXT_OVERRIDE;

<span class="enscript-type">public</span>:
    <span class="enscript-type">static</span> PMSettingObject *pmSettingObject(
                IOPMrootDomain                  *parent_arg,
                IOPMSettingControllerCallback   handler_arg,
                OSObject                        *target_arg,
                uintptr_t                       refcon_arg,
                uint32_t                        supportedPowerSources,
                <span class="enscript-type">const</span> OSSymbol                  *settings[],
                OSObject                        **handle_obj);

    <span class="enscript-type">void</span> dispatchPMSetting(<span class="enscript-type">const</span> OSSymbol *type, OSObject *object);
    <span class="enscript-type">void</span> clientHandleFreed(<span class="enscript-type">void</span>);
};

<span class="enscript-type">struct</span> PMSettingCallEntry {
    queue_chain_t   link;
    thread_t        thread;
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMSETTING_LOCK</span>()    IOLockLock(settingsCtrlLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMSETTING_UNLOCK</span>()  IOLockUnlock(settingsCtrlLock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMSETTING_WAIT</span>(p)   IOLockSleep(settingsCtrlLock, p, THREAD_UNINT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PMSETTING_WAKEUP</span>(p) IOLockWakeup(settingsCtrlLock, p, true)

<span class="enscript-comment">/*
 * PMTraceWorker
 * Internal helper object for logging trace points to RTC
 * IOPMrootDomain and only IOPMrootDomain should instantiate
 * exactly one of these.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-function-name">void</span> (*IOPMTracePointHandler)(
        <span class="enscript-type">void</span> * target, uint32_t code, uint32_t data );

<span class="enscript-type">class</span> PMTraceWorker : <span class="enscript-type">public</span> OSObject
{
    OSDeclareDefaultStructors(PMTraceWorker)
<span class="enscript-type">public</span>:
    <span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> { kPowerChangeStart, kPowerChangeCompleted } change_t;

    <span class="enscript-type">static</span> PMTraceWorker        *tracer( IOPMrootDomain * );
    <span class="enscript-type">void</span>                        tracePCIPowerChange(change_t, IOService *, uint32_t, uint32_t);
    <span class="enscript-type">void</span>                        tracePoint(uint8_t phase);
    <span class="enscript-type">void</span>                        tracePoint(uint8_t phase, uint8_t data8);
    <span class="enscript-type">void</span>                        traceDetail(uint32_t detail);
    <span class="enscript-type">void</span>                        traceLoginWindowPhase(uint8_t phase);
    <span class="enscript-type">int</span>                         recordTopLevelPCIDevice(IOService *);
    <span class="enscript-type">void</span>                        RTC_TRACE(<span class="enscript-type">void</span>);
    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span>                serialize(OSSerialize *s) <span class="enscript-type">const</span> APPLE_KEXT_OVERRIDE;

    IOPMTracePointHandler       tracePointHandler;
    <span class="enscript-type">void</span> *                      tracePointTarget;
    uint64_t                    getPMStatusCode();
<span class="enscript-type">private</span>:
    IOPMrootDomain              *owner;
    IOLock                      *pciMappingLock;
    OSArray                     *pciDeviceBitMappings;

    uint8_t                     addedToRegistry;
    uint8_t                     tracePhase;
    uint8_t                     loginWindowPhase;
    uint8_t                     traceData8;
    uint32_t                    traceData32;
};

<span class="enscript-comment">/*
 * PMAssertionsTracker
 * Tracks kernel and user space PM assertions
 */</span>
<span class="enscript-type">class</span> PMAssertionsTracker : <span class="enscript-type">public</span> OSObject
{
    OSDeclareFinalStructors(PMAssertionsTracker)
<span class="enscript-type">public</span>:
    <span class="enscript-type">static</span> PMAssertionsTracker  *pmAssertionsTracker( IOPMrootDomain * );

    IOReturn                    createAssertion(IOPMDriverAssertionType, IOPMDriverAssertionLevel, IOService *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, IOPMDriverAssertionID *);
    IOReturn                    releaseAssertion(IOPMDriverAssertionID);
    IOReturn                    setAssertionLevel(IOPMDriverAssertionID, IOPMDriverAssertionLevel);
    IOReturn                    setUserAssertionLevels(IOPMDriverAssertionType);

    OSArray                     *copyAssertionsArray(<span class="enscript-type">void</span>);
    IOPMDriverAssertionType     getActivatedAssertions(<span class="enscript-type">void</span>);
    IOPMDriverAssertionLevel    getAssertionLevel(IOPMDriverAssertionType);

    IOReturn                    handleCreateAssertion(OSData *);
    IOReturn                    handleReleaseAssertion(IOPMDriverAssertionID);
    IOReturn                    handleSetAssertionLevel(IOPMDriverAssertionID, IOPMDriverAssertionLevel);
    IOReturn                    handleSetUserAssertionLevels(<span class="enscript-type">void</span> * arg0);
    <span class="enscript-type">void</span>                        publishProperties(<span class="enscript-type">void</span>);

<span class="enscript-type">private</span>:
    <span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
        IOPMDriverAssertionID       id;
        IOPMDriverAssertionType     assertionBits;
        uint64_t                    createdTime;
        uint64_t                    modifiedTime;
        <span class="enscript-type">const</span> OSSymbol              *ownerString;
        IOService                   *ownerService;
        uint64_t                    registryEntryID;
        IOPMDriverAssertionLevel    level;
    } PMAssertStruct;

    uint32_t                    tabulateProducerCount;
    uint32_t                    tabulateConsumerCount;

    PMAssertStruct              *detailsForID(IOPMDriverAssertionID, <span class="enscript-type">int</span> *);
    <span class="enscript-type">void</span>                        tabulate(<span class="enscript-type">void</span>);

    IOPMrootDomain              *owner;
    OSArray                     *assertionsArray;
    IOLock                      *assertionsArrayLock;
    IOPMDriverAssertionID       issuingUniqueID __attribute__((aligned(8))); <span class="enscript-comment">/* aligned for atomic access */</span>
    IOPMDriverAssertionType     assertionsKernel;
    IOPMDriverAssertionType     assertionsUser;
    IOPMDriverAssertionType     assertionsCombined;
};

<span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>(PMAssertionsTracker, OSObject);

<span class="enscript-comment">/*
 * PMHaltWorker
 * Internal helper object for Shutdown/Restart notifications.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kPMHaltMaxWorkers</span>   8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kPMHaltTimeoutMS</span>    100

<span class="enscript-type">class</span> PMHaltWorker : <span class="enscript-type">public</span> OSObject
{
    OSDeclareFinalStructors( PMHaltWorker )

<span class="enscript-type">public</span>:
    IOService *  service;    <span class="enscript-comment">// service being worked on
</span>    AbsoluteTime startTime;  <span class="enscript-comment">// time when work started
</span>    <span class="enscript-type">int</span>          depth;      <span class="enscript-comment">// work on nubs at this PM-tree depth
</span>    <span class="enscript-type">int</span>          visits;     <span class="enscript-comment">// number of nodes visited (debug)
</span>    IOLock *     lock;
    <span class="enscript-type">bool</span>         timeout;    <span class="enscript-comment">// service took too long
</span>
    <span class="enscript-type">static</span>  PMHaltWorker * worker( <span class="enscript-type">void</span> );
    <span class="enscript-type">static</span>  <span class="enscript-type">void</span> main( <span class="enscript-type">void</span> * arg, wait_result_t waitResult );
    <span class="enscript-type">static</span>  <span class="enscript-type">void</span> work( PMHaltWorker * me );
    <span class="enscript-type">static</span>  <span class="enscript-type">void</span> checkTimeout( PMHaltWorker * me, AbsoluteTime * now );
    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> free( <span class="enscript-type">void</span> ) APPLE_KEXT_OVERRIDE;
};

<span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>( PMHaltWorker, OSObject )


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOService
<span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>(IOPMrootDomain, IOService)

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOPMRootDomainWillShutdown</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;gWillShutdown))
    {
    <span class="enscript-reference">OSKext</span>::willShutdown();
    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; 100; i++)
    {
        <span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;gSleepOrShutdownPending)) <span class="enscript-keyword">break</span>;
        IOSleep( 100 );
    }
    }
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span>
{
    IONotifier * registerSleepWakeInterest(IOServiceInterestHandler handler, <span class="enscript-type">void</span> * self, <span class="enscript-type">void</span> * ref)
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;registerInterest( gIOGeneralInterest, handler, self, ref );
    }

    IONotifier * registerPrioritySleepWakeInterest(IOServiceInterestHandler handler, <span class="enscript-type">void</span> * self, <span class="enscript-type">void</span> * ref)
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;registerInterest( gIOPriorityPowerStateInterest, handler, self, ref );
    }

    IOReturn acknowledgeSleepWakeNotification(<span class="enscript-type">void</span> * PMrefcon)
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;allowPowerChange ( (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)PMrefcon );
    }

    IOReturn vetoSleepWakeNotification(<span class="enscript-type">void</span> * PMrefcon)
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;cancelPowerChange ( (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)PMrefcon );
    }

    IOReturn rootDomainRestart ( <span class="enscript-type">void</span> )
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;restartSystem();
    }

    IOReturn rootDomainShutdown ( <span class="enscript-type">void</span> )
    {
        <span class="enscript-keyword">return</span> gRootDomain-&gt;shutdownSystem();
    }

    <span class="enscript-type">void</span> IOSystemShutdownNotification(<span class="enscript-type">void</span>)
    {
        IOPMRootDomainWillShutdown();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
        IOHibernateSystemPostWake();
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;gPagingOff))
        {
            gRootDomain-&gt;handlePlatformHaltRestart(kPEPagingOff);
        }
    }

    <span class="enscript-type">int</span> sync_internal(<span class="enscript-type">void</span>);
}

<span class="enscript-comment">/*
A device is always in the highest power state which satisfies its driver,
its policy-maker, and any power children it has, but within the constraint
of the power state provided by its parent.  The driver expresses its desire by
calling changePowerStateTo(), the policy-maker expresses its desire by calling
changePowerStateToPriv(), and the children express their desires by calling
requestPowerDomainState().

The Root Power Domain owns the policy for idle and demand sleep for the system.
It is a power-managed IOService just like the others in the system.
It implements several power states which map to what we see as Sleep and On.

The sleep policy is as follows:
1. Sleep is prevented if the case is open so that nobody will think the machine
   is off and plug/unplug cards.
2. Sleep is prevented if the sleep timeout slider in the prefs panel is zero.
3. System cannot Sleep if some object in the tree is in a power state marked
   kIOPMPreventSystemSleep.

These three conditions are enforced using the &quot;driver clamp&quot; by calling
changePowerStateTo(). For example, if the case is opened,
changePowerStateTo(ON_STATE) is called to hold the system on regardless
of the desires of the children of the root or the state of the other clamp.

Demand Sleep is initiated by pressing the front panel power button, closing
the clamshell, or selecting the menu item. In this case the root's parent
actually initiates the power state change so that the root domain has no
choice and does not give applications the opportunity to veto the change.

Idle Sleep occurs if no objects in the tree are in a state marked
kIOPMPreventIdleSleep.  When this is true, the root's children are not holding
the root on, so it sets the &quot;policy-maker clamp&quot; by calling
changePowerStateToPriv(ON_STATE) to hold itself on until the sleep timer expires.
This timer is set for the difference between the sleep timeout slider and the
display dim timeout slider. When the timer expires, it releases its clamp and
now nothing is holding it awake, so it falls asleep.

Demand sleep is prevented when the system is booting.  When preferences are
transmitted by the loginwindow at the end of boot, a flag is cleared,
and this allows subsequent Demand Sleep.
*/</span>

<span class="enscript-comment">//******************************************************************************
</span>
IOPMrootDomain * <span class="enscript-function-name">IOPMrootDomain::construct</span>( <span class="enscript-type">void</span> )
{
    IOPMrootDomain  *root;

    root = <span class="enscript-keyword">new</span> IOPMrootDomain;
    <span class="enscript-keyword">if</span>( root)
        root-&gt;init();

    <span class="enscript-keyword">return</span>( root );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// updateConsoleUsersCallout
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">updateConsoleUsersCallout</span>(thread_call_param_t p0, thread_call_param_t p1)
{
    <span class="enscript-reference">IOService</span>::updateConsoleUsers(NULL, kIOMessageSystemHasPoweredOn);
}

<span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">disk_sync_callout</span>( thread_call_param_t p0, thread_call_param_t p1 )
{
    IOService * rootDomain = (IOService *) p0;
    uint32_t    notifyRef  = (uint32_t)(uintptr_t) p1;
    uint32_t    powerState = rootDomain-&gt;getPowerState();

    DLOG(<span class="enscript-string">&quot;disk_sync_callout ps=%u\n&quot;</span>, powerState);

    <span class="enscript-keyword">if</span> (ON_STATE == powerState)
    {
        sync_internal();
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-keyword">else</span>
    {
        IOHibernateSystemPostWake();

        <span class="enscript-keyword">if</span> (gRootDomain)
            gRootDomain-&gt;sleepWakeDebugSaveSpinDumpFile();
    }
#<span class="enscript-reference">endif</span>

    rootDomain-&gt;allowPowerChange(notifyRef);
    DLOG(<span class="enscript-string">&quot;disk_sync_callout finish\n&quot;</span>);
}

<span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hib_debugSetup_callout</span>( thread_call_param_t p0, thread_call_param_t p1 )
{
    IOService * rootDomain = (IOService *) p0;
    uint32_t    notifyRef  = (uint32_t)(uintptr_t) p1;

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">HIBERNATION</span>
    IOOpenDebugDataFile(kSleepWakeStackBinFilename, SWD_BUF_SIZE);
#<span class="enscript-reference">endif</span>

    rootDomain-&gt;allowPowerChange(notifyRef);
    DLOG(<span class="enscript-string">&quot;hib_debugSetup_callout finish\n&quot;</span>);
}
<span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> UInt32 <span class="enscript-function-name">computeDeltaTimeMS</span>( <span class="enscript-type">const</span> AbsoluteTime * startTime )
{
    AbsoluteTime    endTime;
    UInt64          nano = 0;

    clock_get_uptime(&amp;endTime);
    <span class="enscript-keyword">if</span> (CMP_ABSOLUTETIME(&amp;endTime, startTime) &gt; 0)
    {
        SUB_ABSOLUTETIME(&amp;endTime, startTime);
        absolutetime_to_nanoseconds(endTime, &amp;nano);
    }

    <span class="enscript-keyword">return</span> (UInt32)(nano / 1000000ULL);
}

<span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_sleepwaketime SYSCTL_HANDLER_ARGS
{
  <span class="enscript-type">struct</span> timeval *swt = (<span class="enscript-type">struct</span> timeval *)arg1;
  <span class="enscript-type">struct</span> proc *p = req-&gt;p;

  <span class="enscript-keyword">if</span> (p == kernproc) {
    <span class="enscript-keyword">return</span> sysctl_io_opaque(req, swt, <span class="enscript-keyword">sizeof</span>(*swt), NULL);
  } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(proc_is64bit(p)) {
    <span class="enscript-type">struct</span> user64_timeval t;
    t.tv_sec = swt-&gt;tv_sec;
    t.tv_usec = swt-&gt;tv_usec;
    <span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;t, <span class="enscript-keyword">sizeof</span>(t), NULL);
  } <span class="enscript-keyword">else</span> {
    <span class="enscript-type">struct</span> user32_timeval t;
    t.tv_sec = swt-&gt;tv_sec;
    t.tv_usec = swt-&gt;tv_usec;
    <span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;t, <span class="enscript-keyword">sizeof</span>(t), NULL);
  }
}

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, sleeptime,
        CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        &amp;gIOLastSleepTime, 0, sysctl_sleepwaketime, <span class="enscript-string">&quot;S,timeval&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, waketime,
        CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        &amp;gIOLastWakeTime, 0, sysctl_sleepwaketime, <span class="enscript-string">&quot;S,timeval&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_willshutdown
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
    <span class="enscript-type">int</span> new_value, changed;
    <span class="enscript-type">int</span> error = sysctl_io_number(req, gWillShutdown, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
    <span class="enscript-keyword">if</span> (changed) {
    <span class="enscript-keyword">if</span> (!gWillShutdown &amp;&amp; (new_value == 1)) {
        IOPMRootDomainWillShutdown();
    } <span class="enscript-keyword">else</span>
        error = EINVAL;
    }
    <span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, willshutdown,
        CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        0, 0, sysctl_willshutdown, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> sysctl_oid sysctl__kern_iokittest;


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_progressmeterenable
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
    <span class="enscript-type">int</span> error;
    <span class="enscript-type">int</span> new_value, changed;

    error = sysctl_io_number(req, vc_progressmeter_enable, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

    <span class="enscript-keyword">if</span> (changed) vc_enable_progressmeter(new_value);

    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_progressmeter
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
    <span class="enscript-type">int</span> error;
    <span class="enscript-type">int</span> new_value, changed;

    error = sysctl_io_number(req, vc_progressmeter_value, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

    <span class="enscript-keyword">if</span> (changed) vc_set_progressmeter(new_value);

    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, progressmeterenable,
        CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        0, 0, sysctl_progressmeterenable, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, progressmeter,
        CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        0, 0, sysctl_progressmeter, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);




<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_consoleoptions
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
    <span class="enscript-type">int</span> error;
    <span class="enscript-type">int</span> new_value, changed;

    error = sysctl_io_number(req, vc_user_options, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

    <span class="enscript-keyword">if</span> (changed) vc_set_options(new_value);

    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, consoleoptions,
        CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
        0, 0, sysctl_consoleoptions, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_wakereason SYSCTL_HANDLER_ARGS
{
    <span class="enscript-type">char</span> wr[ <span class="enscript-keyword">sizeof</span>(gWakeReasonString) ];

    wr[0] = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">if</span> (gRootDomain)
        gRootDomain-&gt;copyWakeReasonString(wr, <span class="enscript-keyword">sizeof</span>(wr));

    <span class="enscript-keyword">return</span> sysctl_io_string(req, wr, 0, 0, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, wakereason,
    CTLTYPE_STRING| CTLFLAG_RD | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
    NULL, 0, sysctl_wakereason, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;wakereason&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_targettype SYSCTL_HANDLER_ARGS
{
    IOService * root;
    OSObject *  obj;
    OSData *    data;
    <span class="enscript-type">char</span>        tt[32];

    tt[0] = <span class="enscript-string">'\0'</span>;
    root = IOService::getServiceRoot();
    <span class="enscript-keyword">if</span> (root &amp;&amp; (obj = root-&gt;copyProperty(gIODTTargetTypeKey)))
    {
	<span class="enscript-keyword">if</span> ((data = OSDynamicCast(OSData, obj)))
	{
	    strlcpy(tt, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) data-&gt;getBytesNoCopy(), <span class="enscript-keyword">sizeof</span>(tt));
	}
	obj-&gt;release();
    }
    <span class="enscript-keyword">return</span> sysctl_io_string(req, tt, 0, 0, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_hw, OID_AUTO, targettype,
    CTLTYPE_STRING| CTLFLAG_RD | CTLFLAG_NOAUTO | CTLFLAG_KERN | CTLFLAG_LOCKED,
    NULL, 0, sysctl_targettype, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;targettype&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, darkwake, CTLFLAG_RW, &amp;gDarkWakeFlags, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, noidle, CTLFLAG_RW, &amp;gNoIdleFlag, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingAutoWakeCalendarKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingAutoWakeSecondsKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingDebugWakeRelativeKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingMaintenanceWakeCalendarKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingSleepServiceWakeCalendarKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMSettingSilentRunningKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMUserTriggeredFullWakeKey;
<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSSymbol * gIOPMUserIsActiveKey;

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// start
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kRootDomainSettingsCount</span>        17

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::start</span>( IOService * nub )
{
    OSIterator      *psIterator;
    OSDictionary    *tmpDict;
    IORootParent *   patriarch;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    IONotifier   *   notifier;
#<span class="enscript-reference">endif</span>

    <span class="enscript-reference">super</span>::start(nub);

    gRootDomain = <span class="enscript-keyword">this</span>;
    gIOPMSettingAutoWakeCalendarKey = OSSymbol::withCString(kIOPMSettingAutoWakeCalendarKey);
    gIOPMSettingAutoWakeSecondsKey = OSSymbol::withCString(kIOPMSettingAutoWakeSecondsKey);
    gIOPMSettingDebugWakeRelativeKey = OSSymbol::withCString(kIOPMSettingDebugWakeRelativeKey);
    gIOPMSettingMaintenanceWakeCalendarKey = OSSymbol::withCString(kIOPMSettingMaintenanceWakeCalendarKey);
    gIOPMSettingSleepServiceWakeCalendarKey = OSSymbol::withCString(kIOPMSettingSleepServiceWakeCalendarKey);
    gIOPMSettingSilentRunningKey = OSSymbol::withCStringNoCopy(kIOPMSettingSilentRunningKey);
    gIOPMUserTriggeredFullWakeKey = OSSymbol::withCStringNoCopy(kIOPMUserTriggeredFullWakeKey);
    gIOPMUserIsActiveKey = OSSymbol::withCStringNoCopy(kIOPMUserIsActiveKey);

    gIOPMStatsApplicationResponseTimedOut = OSSymbol::withCString(kIOPMStatsResponseTimedOut);
    gIOPMStatsApplicationResponseCancel = OSSymbol::withCString(kIOPMStatsResponseCancel);
    gIOPMStatsApplicationResponseSlow = OSSymbol::withCString(kIOPMStatsResponseSlow);
    gIOPMStatsApplicationResponsePrompt = OSSymbol::withCString(kIOPMStatsResponsePrompt);
    gIOPMStatsDriverPSChangeSlow = OSSymbol::withCString(kIOPMStatsDriverPSChangeSlow);

    sleepSupportedPEFunction = OSSymbol::withCString(<span class="enscript-string">&quot;IOPMSetSleepSupported&quot;</span>);
    sleepMessagePEFunction = OSSymbol::withCString(<span class="enscript-string">&quot;IOPMSystemSleepMessage&quot;</span>);

    <span class="enscript-type">const</span> OSSymbol  *settingsArr[kRootDomainSettingsCount] =
        {
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingSleepOnPowerButtonKey),
            gIOPMSettingAutoWakeSecondsKey,
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingAutoPowerSecondsKey),
            gIOPMSettingAutoWakeCalendarKey,
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingAutoPowerCalendarKey),
            gIOPMSettingDebugWakeRelativeKey,
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingDebugPowerRelativeKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingWakeOnRingKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingRestartOnPowerLossKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingWakeOnClamshellKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingWakeOnACChangeKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingTimeZoneOffsetKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingDisplaySleepUsesDimKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingMobileMotionModuleKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMSettingGraphicsSwitchKey),
            <span class="enscript-reference">OSSymbol</span>::withCString(kIOPMStateConsoleShutdown),
            gIOPMSettingSilentRunningKey
        };

    PE_parse_boot_argn(<span class="enscript-string">&quot;darkwake&quot;</span>, &amp;gDarkWakeFlags, <span class="enscript-keyword">sizeof</span>(gDarkWakeFlags));
    PE_parse_boot_argn(<span class="enscript-string">&quot;noidle&quot;</span>, &amp;gNoIdleFlag, <span class="enscript-keyword">sizeof</span>(gNoIdleFlag));

    queue_init(&amp;aggressivesQueue);
    aggressivesThreadCall = thread_call_allocate(handleAggressivesFunction, <span class="enscript-keyword">this</span>);
    aggressivesData = OSData::withCapacity(
                        <span class="enscript-keyword">sizeof</span>(AggressivesRecord) * (kPMLastAggressivenessType + 4));

    featuresDictLock = IOLockAlloc();
    settingsCtrlLock = IOLockAlloc();
    wakeEventLock = IOLockAlloc();
    setPMRootDomain(<span class="enscript-keyword">this</span>);

    extraSleepTimer = thread_call_allocate(
                        idleSleepTimerExpired,
                        (thread_call_param_t) <span class="enscript-keyword">this</span>);

    diskSyncCalloutEntry = thread_call_allocate(
                        &amp;disk_sync_callout,
                        (thread_call_param_t) <span class="enscript-keyword">this</span>);
    hibDebugSetupEntry = thread_call_allocate(
                        &amp;hib_debugSetup_callout,
                        (thread_call_param_t) <span class="enscript-keyword">this</span>);

    updateConsoleUsersEntry = thread_call_allocate(
                        &amp;updateConsoleUsersCallout,
                        (thread_call_param_t) <span class="enscript-keyword">this</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DARK_TO_FULL_EVALUATE_CLAMSHELL</span>
    fullWakeThreadCall = thread_call_allocate(
                            OSMemberFunctionCast(thread_call_func_t, <span class="enscript-keyword">this</span>,
                                &amp;IOPMrootDomain::fullWakeDelayedWork),
                            (thread_call_param_t) <span class="enscript-keyword">this</span>);
#<span class="enscript-reference">endif</span>

    setProperty(kIOSleepSupportedKey, true);

    bzero(&amp;gPMStats, <span class="enscript-keyword">sizeof</span>(gPMStats));

    pmTracer = PMTraceWorker::tracer(<span class="enscript-keyword">this</span>);

    pmAssertions = PMAssertionsTracker::pmAssertionsTracker(<span class="enscript-keyword">this</span>);

    userDisabledAllSleep = false;
    systemBooting = true;
    sleepSlider = 0;
    idleSleepTimerPending = false;
    wrangler = NULL;
    clamshellClosed    = false;
    clamshellExists    = false;
    clamshellDisabled  = true;
    acAdaptorConnected = true;
    clamshellSleepDisabled = false;
    gWakeReasonString[0] = <span class="enscript-string">'\0'</span>;

    <span class="enscript-comment">// Initialize to user active.
</span>    <span class="enscript-comment">// Will never transition to user inactive w/o wrangler.
</span>    fullWakeReason = kFullWakeReasonLocalUser;
    userIsActive = userWasActive = true;
    setProperty(gIOPMUserIsActiveKey, kOSBooleanTrue);

    <span class="enscript-comment">// Set the default system capabilities at boot.
</span>    _currentCapability = kIOPMSystemCapabilityCPU      |
                         kIOPMSystemCapabilityGraphics |
                         kIOPMSystemCapabilityAudio    |
                         kIOPMSystemCapabilityNetwork;

    _pendingCapability = _currentCapability;
    _desiredCapability = _currentCapability;
    _highestCapability = _currentCapability;
    setProperty(kIOPMSystemCapabilitiesKey, _currentCapability, 64);

    queuedSleepWakeUUIDString = NULL;
    initializeBootSessionUUID();
    pmStatsAppResponses     = OSArray::withCapacity(5);
    _statsNameKey           = OSSymbol::withCString(kIOPMStatsNameKey);
    _statsPIDKey            = OSSymbol::withCString(kIOPMStatsPIDKey);
    _statsTimeMSKey         = OSSymbol::withCString(kIOPMStatsTimeMSKey);
    _statsResponseTypeKey   = OSSymbol::withCString(kIOPMStatsApplicationResponseTypeKey);
    _statsMessageTypeKey    = OSSymbol::withCString(kIOPMStatsMessageTypeKey);
    _statsPowerCapsKey      = OSSymbol::withCString(kIOPMStatsPowerCapabilityKey);
    assertOnWakeSecs        = -1;  <span class="enscript-comment">// Invalid value to prevent updates
</span>
    pmStatsLock = IOLockAlloc();
    idxPMCPUClamshell = kCPUUnknownIndex;
    idxPMCPULimitedPower = kCPUUnknownIndex;

    tmpDict = OSDictionary::withCapacity(1);
    setProperty(kRootDomainSupportedFeatures, tmpDict);
    tmpDict-&gt;release();

    settingsCallbacks = OSDictionary::withCapacity(1);

    <span class="enscript-comment">// Create a list of the valid PM settings that we'll relay to
</span>    <span class="enscript-comment">// interested clients in setProperties() =&gt; setPMSetting()
</span>    allowedPMSettings = OSArray::withObjects(
                    (<span class="enscript-type">const</span> OSObject **)settingsArr,
                    kRootDomainSettingsCount,
                    0);

    <span class="enscript-comment">// List of PM settings that should not automatically publish itself
</span>    <span class="enscript-comment">// as a feature when registered by a listener.
</span>    noPublishPMSettings = OSArray::withObjects(
                    (<span class="enscript-type">const</span> OSObject **) &amp;gIOPMSettingSilentRunningKey, 1, 0);

    fPMSettingsDict = OSDictionary::withCapacity(5);
    preventIdleSleepList = OSSet::withCapacity(8);
    preventSystemSleepList = OSSet::withCapacity(2);

    PMinit();   <span class="enscript-comment">// creates gIOPMWorkLoop
</span>
    <span class="enscript-comment">// Create IOPMPowerStateQueue used to queue external power
</span>    <span class="enscript-comment">// events, and to handle those events on the PM work loop.
</span>    pmPowerStateQueue = IOPMPowerStateQueue::PMPowerStateQueue(
        <span class="enscript-keyword">this</span>, OSMemberFunctionCast(IOEventSource::Action, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::dispatchPowerEvent));
    getPMworkloop()-&gt;addEventSource(pmPowerStateQueue);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CHECK_THREAD_CONTEXT</span>
    gIOPMWorkLoop = getPMworkloop();
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// create our power parent
</span>    patriarch = <span class="enscript-keyword">new</span> IORootParent;
    patriarch-&gt;init();
    patriarch-&gt;attach(<span class="enscript-keyword">this</span>);
    patriarch-&gt;start(<span class="enscript-keyword">this</span>);
    patriarch-&gt;addPowerChild(<span class="enscript-keyword">this</span>);

    registerPowerDriver(<span class="enscript-keyword">this</span>, ourPowerStates, NUM_POWER_STATES);
    changePowerStateToPriv(ON_STATE);

    <span class="enscript-comment">// install power change handler
</span>    gSysPowerDownNotifier = registerPrioritySleepWakeInterest( &amp;sysPowerDownHandler, <span class="enscript-keyword">this</span>, 0);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-comment">// Register for a notification when IODisplayWrangler is published
</span>    <span class="enscript-keyword">if</span> ((tmpDict = serviceMatching(<span class="enscript-string">&quot;IODisplayWrangler&quot;</span>)))
    {
        _displayWranglerNotifier = addMatchingNotification(
                gIOPublishNotification, tmpDict,
                (IOServiceMatchingNotificationHandler) &amp;displayWranglerMatchPublished,
                <span class="enscript-keyword">this</span>, 0);
        tmpDict-&gt;release();
    }
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

    <span class="enscript-keyword">if</span> ((tmpDict = serviceMatching(<span class="enscript-string">&quot;IODTNVRAM&quot;</span>)))
    {
        notifier = addMatchingNotification(
                gIOFirstPublishNotification, tmpDict,
                (IOServiceMatchingNotificationHandler) &amp;IONVRAMMatchPublished,
                <span class="enscript-keyword">this</span>, 0);
        tmpDict-&gt;release();
    }

    wranglerIdleSettings = NULL;
    OSNumber * wranglerIdlePeriod = NULL;
    wranglerIdleSettings = OSDictionary::withCapacity(1);
    wranglerIdlePeriod  = OSNumber::withNumber(kDefaultWranglerIdlePeriod, 32);

    <span class="enscript-keyword">if</span>(wranglerIdleSettings &amp;&amp; wranglerIdlePeriod)
        wranglerIdleSettings-&gt;setObject(kIORequestWranglerIdleKey,
                                        wranglerIdlePeriod);

    <span class="enscript-keyword">if</span>(wranglerIdlePeriod)
        wranglerIdlePeriod-&gt;release();
#<span class="enscript-reference">endif</span>

    <span class="enscript-type">const</span> OSSymbol *ucClassName = OSSymbol::withCStringNoCopy(<span class="enscript-string">&quot;RootDomainUserClient&quot;</span>);
    setProperty(gIOUserClientClassKey, (OSObject *) ucClassName);
    ucClassName-&gt;release();

    <span class="enscript-comment">// IOBacklightDisplay can take a long time to load at boot, or it may
</span>    <span class="enscript-comment">// not load at all if you're booting with clamshell closed. We publish
</span>    <span class="enscript-comment">// 'DisplayDims' here redundantly to get it published early and at all.
</span>    OSDictionary * matching;
    matching = serviceMatching(<span class="enscript-string">&quot;IOPMPowerSource&quot;</span>);
    psIterator = getMatchingServices( matching );
    <span class="enscript-keyword">if</span> (matching) matching-&gt;release();
    <span class="enscript-keyword">if</span>( psIterator &amp;&amp; psIterator-&gt;getNextObject() )
    {
        <span class="enscript-comment">// There's at least one battery on the system, so we publish
</span>        <span class="enscript-comment">// 'DisplayDims' support for the LCD.
</span>        publishFeature(<span class="enscript-string">&quot;DisplayDims&quot;</span>);
    }
    <span class="enscript-keyword">if</span>(psIterator) {
        psIterator-&gt;release();
    }

    sysctl_register_oid(&amp;sysctl__kern_sleeptime);
    sysctl_register_oid(&amp;sysctl__kern_waketime);
    sysctl_register_oid(&amp;sysctl__kern_willshutdown);
    sysctl_register_oid(&amp;sysctl__kern_iokittest);
    sysctl_register_oid(&amp;sysctl__hw_targettype);

    sysctl_register_oid(&amp;sysctl__kern_progressmeterenable);
    sysctl_register_oid(&amp;sysctl__kern_progressmeter);
    sysctl_register_oid(&amp;sysctl__kern_wakereason);
    sysctl_register_oid(&amp;sysctl__kern_consoleoptions);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    IOHibernateSystemInit(<span class="enscript-keyword">this</span>);
#<span class="enscript-reference">endif</span>

    registerService();                      <span class="enscript-comment">// let clients find us
</span>
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setProperties
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Receive a setProperty call
</span><span class="enscript-comment">// The &quot;System Boot&quot; property means the system is completely booted.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::setProperties</span>( OSObject * props_obj )
{
    IOReturn        return_value = kIOReturnSuccess;
    OSDictionary    *dict = OSDynamicCast(OSDictionary, props_obj);
    OSBoolean       *b;
    OSNumber        *n;
    <span class="enscript-type">const</span> OSSymbol  *key;
    OSObject        *obj;
    OSCollectionIterator * iter = 0;

    <span class="enscript-type">const</span> OSSymbol *publish_simulated_battery_string    = OSSymbol::withCString(<span class="enscript-string">&quot;SoftwareSimulatedBatteries&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *boot_complete_string                = OSSymbol::withCString(<span class="enscript-string">&quot;System Boot Complete&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *sys_shutdown_string                 = OSSymbol::withCString(<span class="enscript-string">&quot;System Shutdown&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *stall_halt_string                   = OSSymbol::withCString(<span class="enscript-string">&quot;StallSystemAtHalt&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *battery_warning_disabled_string     = OSSymbol::withCString(<span class="enscript-string">&quot;BatteryWarningsDisabled&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *idle_seconds_string                 = OSSymbol::withCString(<span class="enscript-string">&quot;System Idle Seconds&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *sleepdisabled_string                = OSSymbol::withCString(<span class="enscript-string">&quot;SleepDisabled&quot;</span>);
    <span class="enscript-type">const</span> OSSymbol *ondeck_sleepwake_uuid_string        = OSSymbol::withCString(kIOPMSleepWakeUUIDKey);
    <span class="enscript-type">const</span> OSSymbol *loginwindow_tracepoint_string       = OSSymbol::withCString(kIOPMLoginWindowSecurityDebugKey);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-type">const</span> OSSymbol *hibernatemode_string                = OSSymbol::withCString(kIOHibernateModeKey);
    <span class="enscript-type">const</span> OSSymbol *hibernatefile_string                = OSSymbol::withCString(kIOHibernateFileKey);
    <span class="enscript-type">const</span> OSSymbol *hibernatefilemin_string            = OSSymbol::withCString(kIOHibernateFileMinSizeKey);
    <span class="enscript-type">const</span> OSSymbol *hibernatefilemax_string            = OSSymbol::withCString(kIOHibernateFileMaxSizeKey);
    <span class="enscript-type">const</span> OSSymbol *hibernatefreeratio_string           = OSSymbol::withCString(kIOHibernateFreeRatioKey);
    <span class="enscript-type">const</span> OSSymbol *hibernatefreetime_string            = OSSymbol::withCString(kIOHibernateFreeTimeKey);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (!dict)
    {
        return_value = kIOReturnBadArgument;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    iter = OSCollectionIterator::withCollection(dict);
    <span class="enscript-keyword">if</span> (!iter)
    {
        return_value = kIOReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()) &amp;&amp;
           (obj = dict-&gt;getObject(key)))
    {
        <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(publish_simulated_battery_string))
        {
            <span class="enscript-keyword">if</span> (OSDynamicCast(OSBoolean, obj))
                publishResource(key, kOSBooleanTrue);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(idle_seconds_string))
        {
            <span class="enscript-keyword">if</span> ((n = OSDynamicCast(OSNumber, obj)))
            {
                setProperty(key, n);
                idleSeconds = n-&gt;unsigned32BitValue();
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(boot_complete_string))
        {
            pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventSystemBootCompleted);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(sys_shutdown_string))
        {
            <span class="enscript-keyword">if</span> ((b = OSDynamicCast(OSBoolean, obj)))
                pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventSystemShutdown, (<span class="enscript-type">void</span> *) b);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(battery_warning_disabled_string))
        {
            setProperty(key, obj);
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(hibernatemode_string) ||
                 key-&gt;isEqualTo(hibernatefilemin_string) ||
                 key-&gt;isEqualTo(hibernatefilemax_string) ||
                 key-&gt;isEqualTo(hibernatefreeratio_string) ||
                 key-&gt;isEqualTo(hibernatefreetime_string))
        {
            <span class="enscript-keyword">if</span> ((n = OSDynamicCast(OSNumber, obj)))
                setProperty(key, n);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(hibernatefile_string))
        {
            OSString * str = OSDynamicCast(OSString, obj);
            <span class="enscript-keyword">if</span> (str) setProperty(key, str);
        }
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(sleepdisabled_string))
        {
            <span class="enscript-keyword">if</span> ((b = OSDynamicCast(OSBoolean, obj)))
            {
                setProperty(key, b);
                pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventUserDisabledSleep, (<span class="enscript-type">void</span> *) b);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(ondeck_sleepwake_uuid_string))
        {
            obj-&gt;retain();
            pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventQueueSleepWakeUUID, (<span class="enscript-type">void</span> *)obj);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(loginwindow_tracepoint_string))
        {
            <span class="enscript-keyword">if</span> (pmTracer &amp;&amp; (n = OSDynamicCast(OSNumber, obj)))
                pmTracer-&gt;traceLoginWindowPhase(n-&gt;unsigned8BitValue());
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(kIOPMDeepSleepEnabledKey)       ||
                 key-&gt;isEqualTo(kIOPMDestroyFVKeyOnStandbyKey)  ||
                 key-&gt;isEqualTo(kIOPMAutoPowerOffEnabledKey)    ||
                 key-&gt;isEqualTo(stall_halt_string))
        {
            <span class="enscript-keyword">if</span> ((b = OSDynamicCast(OSBoolean, obj)))
                setProperty(key, b);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(kIOPMDeepSleepDelayKey) ||
                 key-&gt;isEqualTo(kIOPMAutoPowerOffDelayKey) ||
                 key-&gt;isEqualTo(kIOPMAutoPowerOffTimerKey))
        {
            <span class="enscript-keyword">if</span> ((n = OSDynamicCast(OSNumber, obj)))
                setProperty(key, n);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (key-&gt;isEqualTo(kIOPMUserWakeAlarmScheduledKey))
        {
            <span class="enscript-keyword">if</span> (kOSBooleanTrue == obj)
                OSBitOrAtomic(kIOPMAlarmBitCalendarWake, &amp;_userScheduledAlarm);
            <span class="enscript-keyword">else</span>
                OSBitAndAtomic(~kIOPMAlarmBitCalendarWake, &amp;_userScheduledAlarm);
            DLOG(<span class="enscript-string">&quot;_userScheduledAlarm = 0x%x\n&quot;</span>, (uint32_t) _userScheduledAlarm);
        }

        <span class="enscript-comment">// Relay our allowed PM settings onto our registered PM clients
</span>        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((allowedPMSettings-&gt;getNextIndexOfObject(key, 0) != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1))
        {
            return_value = setPMSetting(key, obj);
            <span class="enscript-keyword">if</span> (kIOReturnSuccess != return_value)
                <span class="enscript-keyword">break</span>;

            <span class="enscript-keyword">if</span> (gIOPMSettingDebugWakeRelativeKey == key)
            {
                <span class="enscript-keyword">if</span> ((n = OSDynamicCast(OSNumber, obj)) &amp;&amp;
                    (_debugWakeSeconds = n-&gt;unsigned32BitValue()))
                {
                    OSBitOrAtomic(kIOPMAlarmBitDebugWake, &amp;_scheduledAlarms);
                }
                <span class="enscript-keyword">else</span>
                {
                    _debugWakeSeconds = 0;
                    OSBitAndAtomic(~kIOPMAlarmBitDebugWake, &amp;_scheduledAlarms);
                }
                DLOG(<span class="enscript-string">&quot;_scheduledAlarms = 0x%x\n&quot;</span>, (uint32_t) _scheduledAlarms);
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gIOPMSettingAutoWakeCalendarKey == key)
            {
                OSData * data;
                <span class="enscript-keyword">if</span> ((data = OSDynamicCast(OSData, obj)) &amp;&amp;
                    (data-&gt;getLength() == <span class="enscript-keyword">sizeof</span>(IOPMCalendarStruct)))
                {
                    <span class="enscript-type">const</span> IOPMCalendarStruct * cs =
                        (<span class="enscript-type">const</span> IOPMCalendarStruct *) data-&gt;getBytesNoCopy();

                    <span class="enscript-keyword">if</span> (cs-&gt;year)
                        OSBitOrAtomic(kIOPMAlarmBitCalendarWake, &amp;_scheduledAlarms);
                    <span class="enscript-keyword">else</span>
                        OSBitAndAtomic(~kIOPMAlarmBitCalendarWake, &amp;_scheduledAlarms);
                    DLOG(<span class="enscript-string">&quot;_scheduledAlarms = 0x%x\n&quot;</span>, (uint32_t) _scheduledAlarms);
                }
            }
        }
        <span class="enscript-keyword">else</span>
        {
            DLOG(<span class="enscript-string">&quot;setProperties(%s) not handled\n&quot;</span>, key-&gt;getCStringNoCopy());
        }
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span>(publish_simulated_battery_string) publish_simulated_battery_string-&gt;release();
    <span class="enscript-keyword">if</span>(boot_complete_string) boot_complete_string-&gt;release();
    <span class="enscript-keyword">if</span>(sys_shutdown_string) sys_shutdown_string-&gt;release();
    <span class="enscript-keyword">if</span>(stall_halt_string) stall_halt_string-&gt;release();
    <span class="enscript-keyword">if</span>(battery_warning_disabled_string) battery_warning_disabled_string-&gt;release();
    <span class="enscript-keyword">if</span>(idle_seconds_string) idle_seconds_string-&gt;release();
    <span class="enscript-keyword">if</span>(sleepdisabled_string) sleepdisabled_string-&gt;release();
    <span class="enscript-keyword">if</span>(ondeck_sleepwake_uuid_string) ondeck_sleepwake_uuid_string-&gt;release();
    <span class="enscript-keyword">if</span>(loginwindow_tracepoint_string) loginwindow_tracepoint_string-&gt;release();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-keyword">if</span>(hibernatemode_string) hibernatemode_string-&gt;release();
    <span class="enscript-keyword">if</span>(hibernatefile_string) hibernatefile_string-&gt;release();
    <span class="enscript-keyword">if</span>(hibernatefreeratio_string) hibernatefreeratio_string-&gt;release();
    <span class="enscript-keyword">if</span>(hibernatefreetime_string) hibernatefreetime_string-&gt;release();
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (iter) iter-&gt;release();
    <span class="enscript-keyword">return</span> return_value;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Aggressiveness
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setAggressiveness
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override IOService::setAggressiveness()
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::setAggressiveness</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   type,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   value )
{
    <span class="enscript-keyword">return</span> setAggressiveness( type, value, 0 );
}

<span class="enscript-comment">/*
 * Private setAggressiveness() with an internal options argument.
 */</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::setAggressiveness</span>(
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   type,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   value,
    IOOptionBits    options )
{
    AggressivesRequest *    entry;
    AggressivesRequest *    request;
    <span class="enscript-type">bool</span>                    found = false;

    DLOG(<span class="enscript-string">&quot;setAggressiveness(%x) 0x%x = %u\n&quot;</span>,
        (uint32_t) options, (uint32_t) type, (uint32_t) value);

    request = IONew(AggressivesRequest, 1);
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    memset(request, 0, <span class="enscript-keyword">sizeof</span>(*request));
    request-&gt;options  = options;
    request-&gt;dataType = kAggressivesRequestTypeRecord;
    request-&gt;data.record.type  = (uint32_t) type;
    request-&gt;data.record.value = (uint32_t) value;

    AGGRESSIVES_LOCK();

    <span class="enscript-comment">// Update disk quick spindown flag used by getAggressiveness().
</span>    <span class="enscript-comment">// Never merge requests with quick spindown flags set.
</span>
    <span class="enscript-keyword">if</span> (options &amp; kAggressivesOptionQuickSpindownEnable)
        gAggressivesState |= kAggressivesStateQuickSpindown;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (options &amp; kAggressivesOptionQuickSpindownDisable)
        gAggressivesState &amp;= ~kAggressivesStateQuickSpindown;
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Coalesce requests with identical aggressives types.
</span>        <span class="enscript-comment">// Deal with callers that calls us too &quot;aggressively&quot;.
</span>
        queue_iterate(&amp;aggressivesQueue, entry, AggressivesRequest *, chain)
        {
            <span class="enscript-keyword">if</span> ((entry-&gt;dataType == kAggressivesRequestTypeRecord) &amp;&amp;
                (entry-&gt;data.record.type == type) &amp;&amp;
                ((entry-&gt;options &amp; kAggressivesOptionQuickSpindownMask) == 0))
            {
                entry-&gt;data.record.value = value;
                found = true;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    <span class="enscript-keyword">if</span> (!found)
    {
        queue_enter(&amp;aggressivesQueue, request, AggressivesRequest *, chain);
    }

    AGGRESSIVES_UNLOCK();

    <span class="enscript-keyword">if</span> (found)
        IODelete(request, AggressivesRequest, 1);

    <span class="enscript-keyword">if</span> (options &amp; kAggressivesOptionSynchronous)
        handleAggressivesRequests();   <span class="enscript-comment">// not truly synchronous
</span>    <span class="enscript-keyword">else</span>
        thread_call_enter(aggressivesThreadCall);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// getAggressiveness
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override IOService::setAggressiveness()
</span><span class="enscript-comment">// Fetch the aggressiveness factor with the given type.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::getAggressiveness</span> (
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   type,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> * outLevel )
{
    uint32_t    value  = 0;
    <span class="enscript-type">int</span>         source = 0;

    <span class="enscript-keyword">if</span> (!outLevel)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    AGGRESSIVES_LOCK();

    <span class="enscript-comment">// Disk quick spindown in effect, report value = 1
</span>
    <span class="enscript-keyword">if</span> ((gAggressivesState &amp; kAggressivesStateQuickSpindown) &amp;&amp;
        (type == kPMMinutesToSpinDown))
    {
        value  = kAggressivesMinValue;
        source = 1;
    }

    <span class="enscript-comment">// Consult the pending request queue.
</span>
    <span class="enscript-keyword">if</span> (!source)
    {
        AggressivesRequest * entry;

        queue_iterate(&amp;aggressivesQueue, entry, AggressivesRequest *, chain)
        {
            <span class="enscript-keyword">if</span> ((entry-&gt;dataType == kAggressivesRequestTypeRecord) &amp;&amp;
                (entry-&gt;data.record.type == type) &amp;&amp;
                ((entry-&gt;options &amp; kAggressivesOptionQuickSpindownMask) == 0))
            {
                value  = entry-&gt;data.record.value;
                source = 2;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    <span class="enscript-comment">// Consult the backend records.
</span>
    <span class="enscript-keyword">if</span> (!source &amp;&amp; aggressivesData)
    {
        AggressivesRecord * record;
        <span class="enscript-type">int</span>                 i, count;

        count  = aggressivesData-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(AggressivesRecord);
        record = (AggressivesRecord *) aggressivesData-&gt;getBytesNoCopy();

        <span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++, record++)
        {
            <span class="enscript-keyword">if</span> (record-&gt;type == type)
            {
                value  = record-&gt;value;
                source = 3;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    AGGRESSIVES_UNLOCK();

    <span class="enscript-keyword">if</span> (source)
    {
        DLOG(<span class="enscript-string">&quot;getAggressiveness(%d) 0x%x = %u\n&quot;</span>,
            source, (uint32_t) type, value);
        *outLevel = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) value;
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
    <span class="enscript-keyword">else</span>
    {
        DLOG(<span class="enscript-string">&quot;getAggressiveness type 0x%x not found\n&quot;</span>, (uint32_t) type);
        *outLevel = 0;  <span class="enscript-comment">// default return = 0, driver may not check for error
</span>        <span class="enscript-keyword">return</span> kIOReturnInvalid;
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// joinAggressiveness
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Request from IOService to join future aggressiveness broadcasts.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::joinAggressiveness</span>(
    IOService * service )
{
    AggressivesRequest *    request;

    <span class="enscript-keyword">if</span> (!service || (service == <span class="enscript-keyword">this</span>))
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    DLOG(<span class="enscript-string">&quot;joinAggressiveness %s %p\n&quot;</span>, service-&gt;getName(), OBFUSCATE(service));

    request = IONew(AggressivesRequest, 1);
    <span class="enscript-keyword">if</span> (!request)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    service-&gt;retain();  <span class="enscript-comment">// released by synchronizeAggressives()
</span>
    memset(request, 0, <span class="enscript-keyword">sizeof</span>(*request));
    request-&gt;dataType = kAggressivesRequestTypeService;
    request-&gt;data.service = service;

    AGGRESSIVES_LOCK();
    queue_enter(&amp;aggressivesQueue, request, AggressivesRequest *, chain);
    AGGRESSIVES_UNLOCK();

    thread_call_enter(aggressivesThreadCall);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// handleAggressivesRequests
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Backend thread processes all incoming aggressiveness requests in the queue.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">handleAggressivesFunction</span>(
    thread_call_param_t param1,
    thread_call_param_t param2 )
{
    <span class="enscript-keyword">if</span> (param1)
    {
        ((IOPMrootDomain *) param1)-&gt;handleAggressivesRequests();
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleAggressivesRequests</span>( <span class="enscript-type">void</span> )
{
    AggressivesRecord *     start;
    AggressivesRecord *     record;
    AggressivesRequest *    request;
    queue_head_t            joinedQueue;
    <span class="enscript-type">int</span>                     i, count;
    <span class="enscript-type">bool</span>                    broadcast;
    <span class="enscript-type">bool</span>                    found;
    <span class="enscript-type">bool</span>                    pingSelf = false;

    AGGRESSIVES_LOCK();

    <span class="enscript-keyword">if</span> ((gAggressivesState &amp; kAggressivesStateBusy) || !aggressivesData ||
        queue_empty(&amp;aggressivesQueue))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_done</span>;

    gAggressivesState |= kAggressivesStateBusy;
    count = aggressivesData-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(AggressivesRecord);
    start = (AggressivesRecord *) aggressivesData-&gt;getBytesNoCopy();

    <span class="enscript-keyword">do</span>
    {
        broadcast = false;
        queue_init(&amp;joinedQueue);

        <span class="enscript-keyword">do</span>
        {
            <span class="enscript-comment">// Remove request from the incoming queue in FIFO order.
</span>            queue_remove_first(&amp;aggressivesQueue, request, AggressivesRequest *, chain);
            <span class="enscript-keyword">switch</span> (request-&gt;dataType)
            {
                <span class="enscript-keyword">case</span> <span class="enscript-reference">kAggressivesRequestTypeRecord</span>:
                    <span class="enscript-comment">// Update existing record if found.
</span>                    found = false;
                    <span class="enscript-keyword">for</span> (i = 0, record = start; i &lt; count; i++, record++)
                    {
                        <span class="enscript-keyword">if</span> (record-&gt;type == request-&gt;data.record.type)
                        {
                            found = true;

                            <span class="enscript-keyword">if</span> (request-&gt;options &amp; kAggressivesOptionQuickSpindownEnable)
                            {
                                <span class="enscript-keyword">if</span> ((record-&gt;flags &amp; kAggressivesRecordFlagMinValue) == 0)
                                {
                                    broadcast = true;
                                    record-&gt;flags |= (kAggressivesRecordFlagMinValue |
                                                      kAggressivesRecordFlagModified);
                                    DLOG(<span class="enscript-string">&quot;disk spindown accelerated, was %u min\n&quot;</span>,
                                        record-&gt;value);
                                }
                            }
                            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (request-&gt;options &amp; kAggressivesOptionQuickSpindownDisable)
                            {
                                <span class="enscript-keyword">if</span> (record-&gt;flags &amp; kAggressivesRecordFlagMinValue)
                                {
                                    broadcast = true;
                                    record-&gt;flags |= kAggressivesRecordFlagModified;
                                    record-&gt;flags &amp;= ~kAggressivesRecordFlagMinValue;
                                    DLOG(<span class="enscript-string">&quot;disk spindown restored to %u min\n&quot;</span>,
                                        record-&gt;value);
                                }
                            }
                            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (record-&gt;value != request-&gt;data.record.value)
                            {
                                record-&gt;value = request-&gt;data.record.value;
                                <span class="enscript-keyword">if</span> ((record-&gt;flags &amp; kAggressivesRecordFlagMinValue) == 0)
                                {
                                    broadcast = true;
                                    record-&gt;flags |= kAggressivesRecordFlagModified;
                                }
                            }
                            <span class="enscript-keyword">break</span>;
                        }
                    }

                    <span class="enscript-comment">// No matching record, append a new record.
</span>                    <span class="enscript-keyword">if</span> (!found &amp;&amp;
                        ((request-&gt;options &amp; kAggressivesOptionQuickSpindownDisable) == 0))
                    {
                        AggressivesRecord   newRecord;

                        newRecord.flags = kAggressivesRecordFlagModified;
                        newRecord.type  = request-&gt;data.record.type;
                        newRecord.value = request-&gt;data.record.value;
                        <span class="enscript-keyword">if</span> (request-&gt;options &amp; kAggressivesOptionQuickSpindownEnable)
                        {
                            newRecord.flags |= kAggressivesRecordFlagMinValue;
                            DLOG(<span class="enscript-string">&quot;disk spindown accelerated\n&quot;</span>);
                        }

                        aggressivesData-&gt;appendBytes(&amp;newRecord, <span class="enscript-keyword">sizeof</span>(newRecord));

                        <span class="enscript-comment">// OSData may have switched to another (larger) buffer.
</span>                        count = aggressivesData-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(AggressivesRecord);
                        start = (AggressivesRecord *) aggressivesData-&gt;getBytesNoCopy();
                        broadcast = true;
                    }

                    <span class="enscript-comment">// Finished processing the request, release it.
</span>                    IODelete(request, AggressivesRequest, 1);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">case</span> <span class="enscript-reference">kAggressivesRequestTypeService</span>:
                    <span class="enscript-comment">// synchronizeAggressives() will free request.
</span>                    queue_enter(&amp;joinedQueue, request, AggressivesRequest *, chain);
                    <span class="enscript-keyword">break</span>;

                <span class="enscript-reference">default</span>:
                    panic(<span class="enscript-string">&quot;bad aggressives request type %x\n&quot;</span>, request-&gt;dataType);
                    <span class="enscript-keyword">break</span>;
            }
        } <span class="enscript-keyword">while</span> (!queue_empty(&amp;aggressivesQueue));

        <span class="enscript-comment">// Release the lock to perform work, with busy flag set.
</span>        <span class="enscript-keyword">if</span> (!queue_empty(&amp;joinedQueue) || broadcast)
        {
            AGGRESSIVES_UNLOCK();
            <span class="enscript-keyword">if</span> (!queue_empty(&amp;joinedQueue))
                synchronizeAggressives(&amp;joinedQueue, start, count);
            <span class="enscript-keyword">if</span> (broadcast)
                broadcastAggressives(start, count);
            AGGRESSIVES_LOCK();
        }

        <span class="enscript-comment">// Remove the modified flag from all records.
</span>        <span class="enscript-keyword">for</span> (i = 0, record = start; i &lt; count; i++, record++)
        {
            <span class="enscript-keyword">if</span> ((record-&gt;flags &amp; kAggressivesRecordFlagModified) &amp;&amp;
                ((record-&gt;type == kPMMinutesToDim) ||
                 (record-&gt;type == kPMMinutesToSleep)))
                pingSelf = true;

            record-&gt;flags &amp;= ~kAggressivesRecordFlagModified;
        }

        <span class="enscript-comment">// Check the incoming queue again since new entries may have been
</span>        <span class="enscript-comment">// added while lock was released above.
</span>
    } <span class="enscript-keyword">while</span> (!queue_empty(&amp;aggressivesQueue));

    gAggressivesState &amp;= ~kAggressivesStateBusy;

<span class="enscript-reference">unlock_done</span>:
    AGGRESSIVES_UNLOCK();

    <span class="enscript-comment">// Root domain is interested in system and display sleep slider changes.
</span>    <span class="enscript-comment">// Submit a power event to handle those changes on the PM work loop.
</span>
    <span class="enscript-keyword">if</span> (pingSelf &amp;&amp; pmPowerStateQueue) {
        pmPowerStateQueue-&gt;submitPowerEvent(
            kPowerEventPolicyStimulus,
            (<span class="enscript-type">void</span> *) kStimulusAggressivenessChanged );
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// synchronizeAggressives
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Push all known aggressiveness records to one or more IOService.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::synchronizeAggressives</span>(
    queue_head_t *              joinedQueue,
    <span class="enscript-type">const</span> AggressivesRecord *   array,
    <span class="enscript-type">int</span>                         count )
{
    IOService *                 service;
    AggressivesRequest *        request;
    <span class="enscript-type">const</span> AggressivesRecord *   record;
    IOPMDriverCallEntry         callEntry;
    uint32_t                    value;
    <span class="enscript-type">int</span>                         i;

    <span class="enscript-keyword">while</span> (!queue_empty(joinedQueue))
    {
        queue_remove_first(joinedQueue, request, AggressivesRequest *, chain);
        <span class="enscript-keyword">if</span> (request-&gt;dataType == kAggressivesRequestTypeService)
            service = request-&gt;data.service;
        <span class="enscript-keyword">else</span>
            service = 0;

        IODelete(request, AggressivesRequest, 1);
        request = 0;

        <span class="enscript-keyword">if</span> (service)
        {
            <span class="enscript-keyword">if</span> (service-&gt;assertPMDriverCall(&amp;callEntry))
            {
                <span class="enscript-keyword">for</span> (i = 0, record = array; i &lt; count; i++, record++)
                {
                    value = record-&gt;value;
                    <span class="enscript-keyword">if</span> (record-&gt;flags &amp; kAggressivesRecordFlagMinValue)
                        value = kAggressivesMinValue;

                    _LOG(<span class="enscript-string">&quot;synchronizeAggressives 0x%x = %u to %s\n&quot;</span>,
                        record-&gt;type, value, service-&gt;getName());
                    service-&gt;setAggressiveness(record-&gt;type, value);
                }
                service-&gt;deassertPMDriverCall(&amp;callEntry);
            }
            service-&gt;release();     <span class="enscript-comment">// retained by joinAggressiveness()
</span>        }
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// broadcastAggressives
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Traverse PM tree and call setAggressiveness() for records that have changed.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::broadcastAggressives</span>(
    <span class="enscript-type">const</span> AggressivesRecord *   array,
    <span class="enscript-type">int</span>                         count )
{
    IORegistryIterator *        iter;
    IORegistryEntry *           entry;
    IOPowerConnection *         connect;
    IOService *                 service;
    <span class="enscript-type">const</span> AggressivesRecord *   record;
    IOPMDriverCallEntry         callEntry;
    uint32_t                    value;
    <span class="enscript-type">int</span>                         i;

    iter = IORegistryIterator::iterateOver(
            <span class="enscript-keyword">this</span>, gIOPowerPlane, kIORegistryIterateRecursively);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">do</span>
        {
            iter-&gt;reset();
            <span class="enscript-keyword">while</span> ((entry = iter-&gt;getNextObject()))
            {
                connect = OSDynamicCast(IOPowerConnection, entry);
                <span class="enscript-keyword">if</span> (!connect || !connect-&gt;getReadyFlag())
                    <span class="enscript-keyword">continue</span>;

                <span class="enscript-keyword">if</span> ((service = (IOService *) connect-&gt;copyChildEntry(gIOPowerPlane)))
                {
                    <span class="enscript-keyword">if</span> (service-&gt;assertPMDriverCall(&amp;callEntry))
                    {
                        <span class="enscript-keyword">for</span> (i = 0, record = array; i &lt; count; i++, record++)
                        {
                            <span class="enscript-keyword">if</span> (record-&gt;flags &amp; kAggressivesRecordFlagModified)
                            {
                                value = record-&gt;value;
                                <span class="enscript-keyword">if</span> (record-&gt;flags &amp; kAggressivesRecordFlagMinValue)
                                    value = kAggressivesMinValue;
                                _LOG(<span class="enscript-string">&quot;broadcastAggressives %x = %u to %s\n&quot;</span>,
                                    record-&gt;type, value, service-&gt;getName());
                                service-&gt;setAggressiveness(record-&gt;type, value);
                            }
                        }
                        service-&gt;deassertPMDriverCall(&amp;callEntry);
                    }
                    service-&gt;release();
                }
            }
        }
        <span class="enscript-keyword">while</span> (!entry &amp;&amp; !iter-&gt;isValid());
        iter-&gt;release();
    }
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: System Sleep
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// startIdleSleepTimer
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::startIdleSleepTimer</span>( uint32_t inSeconds )
{
    AbsoluteTime deadline;

    ASSERT_GATED();
    <span class="enscript-keyword">if</span> (gNoIdleFlag) {
        DLOG(<span class="enscript-string">&quot;idle timer not set (noidle=%d)\n&quot;</span>, gNoIdleFlag);
        <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (inSeconds)
    {
        clock_interval_to_deadline(inSeconds, kSecondScale, &amp;deadline);
        thread_call_enter_delayed(extraSleepTimer, deadline);
        idleSleepTimerPending = true;
    }
    <span class="enscript-keyword">else</span>
    {
        thread_call_enter(extraSleepTimer);
    }
    DLOG(<span class="enscript-string">&quot;idle timer set for %u seconds\n&quot;</span>, inSeconds);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// cancelIdleSleepTimer
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::cancelIdleSleepTimer</span>( <span class="enscript-type">void</span> )
{
    ASSERT_GATED();
    <span class="enscript-keyword">if</span> (idleSleepTimerPending)
    {
        DLOG(<span class="enscript-string">&quot;idle timer cancelled\n&quot;</span>);
        thread_call_cancel(extraSleepTimer);
        idleSleepTimerPending = false;

        <span class="enscript-keyword">if</span> (!assertOnWakeSecs &amp;&amp; systemWakeTime) {
                AbsoluteTime    now;
                clock_usec_t    microsecs;
                clock_get_uptime(&amp;now);
                SUB_ABSOLUTETIME(&amp;now, &amp;systemWakeTime);
                absolutetime_to_microtime(now, &amp;assertOnWakeSecs, &amp;microsecs);
                <span class="enscript-keyword">if</span> (assertOnWakeReport)  {
                    HISTREPORT_TALLYVALUE(assertOnWakeReport, (int64_t)assertOnWakeSecs);
                    DLOG(<span class="enscript-string">&quot;Updated assertOnWake %lu\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)assertOnWakeSecs);
                }
        }
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// idleSleepTimerExpired
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">idleSleepTimerExpired</span>(
    thread_call_param_t us, thread_call_param_t )
{
    ((IOPMrootDomain *)us)-&gt;handleSleepTimerExpiration();
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// handleSleepTimerExpiration
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The time between the sleep idle timeout and the next longest one has elapsed.
</span><span class="enscript-comment">// It's time to sleep. Start that by removing the clamp that's holding us awake.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleSleepTimerExpiration</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!getPMworkloop()-&gt;inGate())
    {
        getPMworkloop()-&gt;runAction(
            OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::handleSleepTimerExpiration),
            <span class="enscript-keyword">this</span>);
        <span class="enscript-keyword">return</span>;
    }

    AbsoluteTime time;

    DLOG(<span class="enscript-string">&quot;sleep timer expired\n&quot;</span>);
    ASSERT_GATED();

    idleSleepTimerPending = false;

    clock_get_uptime(&amp;time);
    setQuickSpinDownTimeout();
    adjustPowerState(true);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// getTimeToIdleSleep
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Returns number of seconds left before going into idle sleep.
</span><span class="enscript-comment">// Caller has to make sure that idle sleep is allowed at the time of calling
</span><span class="enscript-comment">// this function
</span><span class="enscript-comment">//******************************************************************************
</span>
uint32_t <span class="enscript-function-name">IOPMrootDomain::getTimeToIdleSleep</span>( <span class="enscript-type">void</span> )
{

    AbsoluteTime    now, lastActivityTime;
    uint64_t        nanos;
    uint32_t        minutesSinceUserInactive = 0;
    uint32_t         sleepDelay = 0;

    <span class="enscript-keyword">if</span> (sleepSlider == 0)
        <span class="enscript-keyword">return</span> 0xffffffff;

    <span class="enscript-keyword">if</span> (userActivityTime)
        lastActivityTime = userActivityTime;
    <span class="enscript-keyword">else</span>
        lastActivityTime = userBecameInactiveTime;

    clock_get_uptime(&amp;now);
    <span class="enscript-keyword">if</span> (CMP_ABSOLUTETIME(&amp;now, &amp;lastActivityTime) &gt; 0)
    {
        SUB_ABSOLUTETIME(&amp;now, &amp;lastActivityTime);
        absolutetime_to_nanoseconds(now, &amp;nanos);
        minutesSinceUserInactive = nanos / (60000000000ULL);

        <span class="enscript-keyword">if</span> (minutesSinceUserInactive &gt;= sleepSlider)
            sleepDelay = 0;
        <span class="enscript-keyword">else</span>
            sleepDelay = sleepSlider - minutesSinceUserInactive;
    }
    <span class="enscript-keyword">else</span>
    {
        sleepDelay = sleepSlider;
    }

    DLOG(<span class="enscript-string">&quot;user inactive %u min, time to idle sleep %u min\n&quot;</span>,
        minutesSinceUserInactive, sleepDelay);

    <span class="enscript-keyword">return</span> (sleepDelay * 60);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setQuickSpinDownTimeout
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::setQuickSpinDownTimeout</span>( <span class="enscript-type">void</span> )
{
    ASSERT_GATED();
    setAggressiveness(
        kPMMinutesToSpinDown, 0, kAggressivesOptionQuickSpindownEnable );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// restoreUserSpinDownTimeout
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::restoreUserSpinDownTimeout</span>( <span class="enscript-type">void</span> )
{
    ASSERT_GATED();
    setAggressiveness(
        kPMMinutesToSpinDown, 0, kAggressivesOptionQuickSpindownDisable );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// sleepSystem
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-comment">/* public */</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::sleepSystem</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> sleepSystemOptions(NULL);
}

<span class="enscript-comment">/* private */</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::sleepSystemOptions</span>( OSDictionary *options )
{
    OSObject *obj = NULL;
    OSString *reason = NULL;
    <span class="enscript-comment">/* sleepSystem is a public function, and may be called by any kernel driver.
     * And that's bad - drivers should sleep the system by calling
     * receivePowerNotification() instead. Drivers should not use sleepSystem.
     *
     * Note that user space app calls to IOPMSleepSystem() will also travel
     * this code path and thus be correctly identified as software sleeps.
     */</span>

    <span class="enscript-keyword">if</span> (options &amp;&amp; options-&gt;getObject(<span class="enscript-string">&quot;OSSwitch&quot;</span>))
    {
        <span class="enscript-comment">// Log specific sleep cause for OS Switch hibernation
</span>        <span class="enscript-keyword">return</span> privateSleepSystem( kIOPMSleepReasonOSSwitchHibernate);
    }

    <span class="enscript-keyword">if</span> (options &amp;&amp; (obj = options-&gt;getObject(<span class="enscript-string">&quot;Sleep Reason&quot;</span>)))
    {
        reason = OSDynamicCast(OSString, obj);
        <span class="enscript-keyword">if</span> (reason &amp;&amp; reason-&gt;isEqualTo(kIOPMDarkWakeThermalEmergencyKey))
            <span class="enscript-keyword">return</span> privateSleepSystem(kIOPMSleepReasonDarkWakeThermalEmergency);
    }

    <span class="enscript-keyword">return</span> privateSleepSystem( kIOPMSleepReasonSoftware);
}

<span class="enscript-comment">/* private */</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::privateSleepSystem</span>( uint32_t sleepReason )
{
    <span class="enscript-comment">/* Called from both gated and non-gated context */</span>

    <span class="enscript-keyword">if</span> (!checkSystemSleepEnabled() || !pmPowerStateQueue)
    {
        <span class="enscript-keyword">return</span> kIOReturnNotPermitted;
    }

    pmPowerStateQueue-&gt;submitPowerEvent(
                            kPowerEventPolicyStimulus,
                            (<span class="enscript-type">void</span> *) kStimulusDemandSystemSleep,
                            sleepReason);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// powerChangeDone
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This overrides powerChangeDone in IOService.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::powerChangeDone</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> previousPowerState )
{
    uint64_t    now;
    ASSERT_GATED();
    DLOG(<span class="enscript-string">&quot;PowerChangeDone: %u-&gt;%u\n&quot;</span>,
        (uint32_t) previousPowerState, (uint32_t) getPowerState());

    <span class="enscript-keyword">switch</span> ( getPowerState() )
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">SLEEP_STATE</span>: {
            <span class="enscript-keyword">if</span> (previousPowerState != ON_STATE)
                <span class="enscript-keyword">break</span>;

            acceptSystemWakeEvents(true);

            <span class="enscript-comment">// re-enable this timer for next sleep
</span>            cancelIdleSleepTimer();

            clock_sec_t     secs;
            clock_usec_t    microsecs;
            clock_get_calendar_absolute_and_microtime(&amp;secs, &amp;microsecs, &amp;now);
            logtime(secs);
            gIOLastSleepTime.tv_sec  = secs;
            gIOLastSleepTime.tv_usec = microsecs;
            gIOLastWakeTime.tv_sec = 0;
            gIOLastWakeTime.tv_usec = 0;

            <span class="enscript-keyword">if</span> (wake2DarkwakeDelay &amp;&amp; sleepDelaysReport) {
                clock_usec_t    microsecs;
                clock_sec_t     wake2DarkwakeSecs, darkwake2SleepSecs;
                <span class="enscript-comment">// Update 'wake2DarkwakeDelay' histogram if this is a fullwake-&gt;sleep transition
</span>
                SUB_ABSOLUTETIME(&amp;now, &amp;ts_sleepStart);
                absolutetime_to_microtime(now, &amp;darkwake2SleepSecs, &amp;microsecs);
                absolutetime_to_microtime(wake2DarkwakeDelay, &amp;wake2DarkwakeSecs, &amp;microsecs);
                HISTREPORT_TALLYVALUE(sleepDelaysReport, 
                                           (int64_t)(wake2DarkwakeSecs+darkwake2SleepSecs));

                DLOG(<span class="enscript-string">&quot;Updated sleepDelaysReport %lu %lu\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)wake2DarkwakeSecs, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)darkwake2SleepSecs);
                wake2DarkwakeDelay = 0;
            }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            LOG(<span class="enscript-string">&quot;System %sSleep\n&quot;</span>, gIOHibernateState ? <span class="enscript-string">&quot;Safe&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

            IOHibernateSystemHasSlept();

            evaluateSystemSleepPolicyFinal();
#<span class="enscript-reference">else</span>
            LOG(<span class="enscript-string">&quot;System Sleep\n&quot;</span>);
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">if</span> (thermalWarningState) {
                <span class="enscript-type">const</span> OSSymbol *event = OSSymbol::withCString(kIOPMThermalLevelWarningKey);
                <span class="enscript-keyword">if</span> (event) {
                    systemPowerEventOccurred(event, kIOPMThermalLevelUnknown);
                    event-&gt;release();
                }
            }
            assertOnWakeSecs = 0;
            ((IOService *)<span class="enscript-keyword">this</span>)-&gt;stop_watchdog_timer(); <span class="enscript-comment">//14456299
</span>            getPlatform()-&gt;sleepKernel();

            <span class="enscript-comment">// The CPU(s) are off at this point,
</span>            <span class="enscript-comment">// Code will resume execution here upon wake.
</span>
            clock_get_uptime(&amp;systemWakeTime);
            _highestCapability = 0;

            ((IOService *)<span class="enscript-keyword">this</span>)-&gt;start_watchdog_timer(); <span class="enscript-comment">//14456299
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            IOHibernateSystemWake();
#<span class="enscript-reference">endif</span>

            <span class="enscript-comment">// sleep transition complete
</span>            gSleepOrShutdownPending = 0;

			<span class="enscript-comment">// trip the reset of the calendar clock
</span>			{
				clock_sec_t  wakeSecs;
				clock_usec_t wakeMicrosecs;

				clock_initialize_calendar();

				clock_get_calendar_microtime(&amp;wakeSecs, &amp;wakeMicrosecs);
				gIOLastWakeTime.tv_sec  = wakeSecs;
				gIOLastWakeTime.tv_usec = wakeMicrosecs;
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            LOG(<span class="enscript-string">&quot;System %sWake\n&quot;</span>, gIOHibernateState ? <span class="enscript-string">&quot;SafeSleep &quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

            <span class="enscript-comment">// log system wake
</span>            PMDebug(kPMLogSystemWake, 0, 0);
            lowBatteryCondition = false;
            lastSleepReason = 0;

            _lastDebugWakeSeconds = _debugWakeSeconds;
            _debugWakeSeconds = 0;
            _scheduledAlarms = 0;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
            systemWake();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
            wranglerTickled         = false;
            graphicsSuppressed      = false;
            darkWakePostTickle      = false;
            darkWakeHibernateError  = false;
            darkWakeToSleepASAP     = true;
            logGraphicsClamp        = true;
            sleepTimerMaintenance   = false;
            sleepToStandby          = false;
            wranglerTickleLatched   = false;
            userWasActive           = false;
            fullWakeReason = kFullWakeReasonNone;

            OSString * wakeType = OSDynamicCast(
                OSString, getProperty(kIOPMRootDomainWakeTypeKey));
            OSString * wakeReason = OSDynamicCast(
                OSString, getProperty(kIOPMRootDomainWakeReasonKey));

            <span class="enscript-keyword">if</span> (wakeReason &amp;&amp; (wakeReason-&gt;getLength() &gt;= 2) &amp;&amp;
                gWakeReasonString[0] == <span class="enscript-string">'\0'</span>)
            {
                <span class="enscript-comment">// Until the platform driver can claim its wake reasons
</span>                strlcat(gWakeReasonString, wakeReason-&gt;getCStringNoCopy(),
                        <span class="enscript-keyword">sizeof</span>(gWakeReasonString));
            }

            <span class="enscript-keyword">if</span> (wakeType &amp;&amp; wakeType-&gt;isEqualTo(kIOPMrootDomainWakeTypeLowBattery))
            {
                lowBatteryCondition = true;
                darkWakeMaintenance = true;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) != 0)
            {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
                OSNumber * hibOptions = OSDynamicCast(
                    OSNumber, getProperty(kIOHibernateOptionsKey));
                <span class="enscript-keyword">if</span> (hibernateAborted || ((hibOptions &amp;&amp;
                    !(hibOptions-&gt;unsigned32BitValue() &amp; kIOHibernateOptionDarkWake))))
                {
                    <span class="enscript-comment">// Hibernate aborted, or EFI brought up graphics
</span>                    wranglerTickled = true;
                    DLOG(<span class="enscript-string">&quot;hibernation aborted %d, options 0x%x\n&quot;</span>,
                        hibernateAborted,
                        hibOptions ? hibOptions-&gt;unsigned32BitValue() : 0);
                }
                <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp; (
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeUser) ||
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeAlarm)))
                {
                    <span class="enscript-comment">// User wake or RTC alarm
</span>                    wranglerTickled = true;
                }
                <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp;
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeSleepTimer))
                {
                    <span class="enscript-comment">// SMC standby timer trumps SleepX
</span>                    darkWakeMaintenance = true;
                    sleepTimerMaintenance = true;
                }
                <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">if</span> ((_lastDebugWakeSeconds != 0) &amp;&amp;
                    ((gDarkWakeFlags &amp; kDarkWakeFlagAlarmIsDark) == 0))
                {
                    <span class="enscript-comment">// SleepX before maintenance
</span>                    wranglerTickled = true;
                }
                <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp;
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeMaintenance))
                {
                    darkWakeMaintenance = true;
                }
                <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp;
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeSleepService))
                {
                    darkWakeMaintenance = true;
                    darkWakeSleepService = true;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
                    <span class="enscript-keyword">if</span> (kIOHibernateStateWakingFromHibernate == gIOHibernateState) {
                        sleepToStandby = true;
                    }
#<span class="enscript-reference">endif</span>
                }
                <span class="enscript-keyword">else</span>
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp;
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeHibernateError))
                {
                    darkWakeMaintenance = true;
                    darkWakeHibernateError = true;
                }
                <span class="enscript-keyword">else</span>
                {
                    <span class="enscript-comment">// Unidentified wake source, resume to full wake if debug
</span>                    <span class="enscript-comment">// alarm is pending.
</span>
                    <span class="enscript-keyword">if</span> (_lastDebugWakeSeconds &amp;&amp;
                        (!wakeReason || wakeReason-&gt;isEqualTo(<span class="enscript-string">&quot;&quot;</span>)))
                        wranglerTickled = true;
                }
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-keyword">if</span> (wakeType &amp;&amp;
                    wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeSleepTimer))
                {
                    darkWakeMaintenance = true;
                    sleepTimerMaintenance = true;
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hibernateAborted || !wakeType ||
                    !wakeType-&gt;isEqualTo(kIOPMRootDomainWakeTypeMaintenance) ||
                    !wakeReason || !wakeReason-&gt;isEqualTo(<span class="enscript-string">&quot;RTC&quot;</span>))
                {
                    <span class="enscript-comment">// Post a HID tickle immediately - except for RTC maintenance wake.
</span>                    wranglerTickled = true;
                }
                <span class="enscript-keyword">else</span>
                {
                    darkWakeMaintenance = true;
                }
            }

            <span class="enscript-keyword">if</span> (wranglerTickled)
            {
                darkWakeToSleepASAP = false;
                fullWakeReason = kFullWakeReasonLocalUser;
                reportUserInput();
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (displayPowerOnRequested &amp;&amp; checkSystemCanSustainFullWake())
            {
                handleDisplayPowerOn();
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!darkWakeMaintenance)
            {
                <span class="enscript-comment">// Early/late tickle for non-maintenance wake.
</span>                <span class="enscript-keyword">if</span> (((gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) ==
                     kDarkWakeFlagHIDTickleEarly) ||
                    ((gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) ==
                     kDarkWakeFlagHIDTickleLate))
                {
                    darkWakePostTickle = true;
                }
            }
#<span class="enscript-reference">else</span>   <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>
            <span class="enscript-comment">// stay awake for at least 30 seconds
</span>            wranglerTickled = true;
            fullWakeReason = kFullWakeReasonLocalUser;
            startIdleSleepTimer(30);
#<span class="enscript-reference">endif</span>
            sleepCnt++;

	    thread_call_enter(updateConsoleUsersEntry);

            changePowerStateToPriv(ON_STATE);
        }   <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__i386__</span> &amp;&amp; !<span class="enscript-variable-name">__x86_64__</span>
        <span class="enscript-keyword">case</span> <span class="enscript-reference">ON_STATE</span>: {
            <span class="enscript-keyword">if</span> (previousPowerState != ON_STATE)
            {
                DLOG(<span class="enscript-string">&quot;Force re-evaluating aggressiveness\n&quot;</span>);
                <span class="enscript-comment">/* Force re-evaluate the aggressiveness values to set appropriate idle sleep timer */</span>
                pmPowerStateQueue-&gt;submitPowerEvent(
                    kPowerEventPolicyStimulus,
                    (<span class="enscript-type">void</span> *) kStimulusNoIdleSleepPreventers );
          }
          <span class="enscript-keyword">break</span>;
        }

#<span class="enscript-reference">endif</span>

    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// requestPowerDomainState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Extend implementation in IOService. Running on PM work loop thread.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::requestPowerDomainState</span> (
    IOPMPowerFlags      childDesire,
    IOPowerConnection * childConnection,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       specification )
{
    <span class="enscript-comment">// Idle and system sleep prevention flags affects driver desire.
</span>    <span class="enscript-comment">// Children desire are irrelevant so they are cleared.
</span>
    <span class="enscript-keyword">return</span> super::requestPowerDomainState(0, childConnection, specification);
}


<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// updatePreventIdleSleepList
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by IOService on PM work loop.
</span><span class="enscript-comment">// Returns true if PM policy recognized the driver's desire to prevent idle
</span><span class="enscript-comment">// sleep and updated the list of idle sleep preventers. Returns false otherwise
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::updatePreventIdleSleepList</span>(
        IOService * service, <span class="enscript-type">bool</span> addNotRemove )
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> oldCount, newCount;

    ASSERT_GATED();

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-comment">// Disregard disk I/O (besides the display wrangler) as a factor preventing
</span>    <span class="enscript-comment">// idle sleep, except in the case of legacy disk I/O
</span>    <span class="enscript-keyword">if</span> ((service != wrangler) &amp;&amp; (service != <span class="enscript-keyword">this</span>))
    {
        <span class="enscript-keyword">return</span> false;
    }
#<span class="enscript-reference">endif</span>

    oldCount = preventIdleSleepList-&gt;getCount();
    <span class="enscript-keyword">if</span> (addNotRemove)
    {
        preventIdleSleepList-&gt;setObject(service);
        DLOG(<span class="enscript-string">&quot;prevent idle sleep list: %s+ (%u)\n&quot;</span>,
            service-&gt;getName(), preventIdleSleepList-&gt;getCount());
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (preventIdleSleepList-&gt;member(service))
    {
        preventIdleSleepList-&gt;removeObject(service);
        DLOG(<span class="enscript-string">&quot;prevent idle sleep list: %s- (%u)\n&quot;</span>,
            service-&gt;getName(), preventIdleSleepList-&gt;getCount());
    }
    newCount = preventIdleSleepList-&gt;getCount();

    <span class="enscript-keyword">if</span> ((oldCount == 0) &amp;&amp; (newCount != 0))
    {
        <span class="enscript-comment">// Driver added to empty prevent list.
</span>        <span class="enscript-comment">// Update the driver desire to prevent idle sleep.
</span>        <span class="enscript-comment">// Driver desire does not prevent demand sleep.
</span>
        changePowerStateTo(ON_STATE);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((oldCount != 0) &amp;&amp; (newCount == 0))
    {
        <span class="enscript-comment">// Last driver removed from prevent list.
</span>        <span class="enscript-comment">// Drop the driver clamp to allow idle sleep.
</span>
        changePowerStateTo(SLEEP_STATE);
        evaluatePolicy( kStimulusNoIdleSleepPreventers );
    }
    messageClient(kIOPMMessageIdleSleepPreventers, systemCapabilityNotifier,
        &amp;newCount, <span class="enscript-keyword">sizeof</span>(newCount));

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-keyword">if</span> (addNotRemove &amp;&amp; (service == wrangler) &amp;&amp; !checkSystemCanSustainFullWake())
    {
        <span class="enscript-keyword">return</span> false;   <span class="enscript-comment">// do not idle-cancel
</span>    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// preventSystemSleepListUpdate
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called by IOService on PM work loop.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::updatePreventSystemSleepList</span>(
        IOService * service, <span class="enscript-type">bool</span> addNotRemove )
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> oldCount, newCount;

    ASSERT_GATED();
    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> == service)
        <span class="enscript-keyword">return</span>;

    oldCount = preventSystemSleepList-&gt;getCount();
    <span class="enscript-keyword">if</span> (addNotRemove)
    {
        preventSystemSleepList-&gt;setObject(service);
        DLOG(<span class="enscript-string">&quot;prevent system sleep list: %s+ (%u)\n&quot;</span>,
            service-&gt;getName(), preventSystemSleepList-&gt;getCount());
        <span class="enscript-keyword">if</span> (!assertOnWakeSecs &amp;&amp; systemWakeTime) {
                AbsoluteTime    now;
                clock_usec_t    microsecs;
                clock_get_uptime(&amp;now);
                SUB_ABSOLUTETIME(&amp;now, &amp;systemWakeTime);
                absolutetime_to_microtime(now, &amp;assertOnWakeSecs, &amp;microsecs);
                <span class="enscript-keyword">if</span> (assertOnWakeReport)  {
                    HISTREPORT_TALLYVALUE(assertOnWakeReport, (int64_t)assertOnWakeSecs);
                    DLOG(<span class="enscript-string">&quot;Updated assertOnWake %lu\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)assertOnWakeSecs);
                }
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (preventSystemSleepList-&gt;member(service))
    {
        preventSystemSleepList-&gt;removeObject(service);
        DLOG(<span class="enscript-string">&quot;prevent system sleep list: %s- (%u)\n&quot;</span>,
            service-&gt;getName(), preventSystemSleepList-&gt;getCount());

        <span class="enscript-keyword">if</span> ((oldCount != 0) &amp;&amp; (preventSystemSleepList-&gt;getCount() == 0))
        {
            <span class="enscript-comment">// Lost all system sleep preventers.
</span>            <span class="enscript-comment">// Send stimulus if system sleep was blocked, and is in dark wake.
</span>            evaluatePolicy( kStimulusDarkWakeEvaluate );
        }
    }
    newCount = preventSystemSleepList-&gt;getCount();
    messageClient(kIOPMMessageSystemSleepPreventers, systemCapabilityNotifier,
        &amp;newCount, <span class="enscript-keyword">sizeof</span>(newCount));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::copySleepPreventersList</span>(OSArray **idleSleepList, OSArray **systemSleepList)
{

    OSCollectionIterator *iterator = NULL;
    OSObject    *object = NULL;
    OSArray     *array = NULL;

    <span class="enscript-keyword">if</span> (!getPMworkloop()-&gt;inGate())
    {
        getPMworkloop()-&gt;runAction(
            OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::IOPMrootDomain::copySleepPreventersList),
            <span class="enscript-keyword">this</span>, (<span class="enscript-type">void</span> *)idleSleepList, (<span class="enscript-type">void</span> *)systemSleepList);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (idleSleepList &amp;&amp; preventIdleSleepList &amp;&amp; (preventIdleSleepList-&gt;getCount() != 0))
    {
        iterator = OSCollectionIterator::withCollection(preventIdleSleepList);
        array = OSArray::withCapacity(5);

        <span class="enscript-keyword">while</span> ((object = iterator-&gt;getNextObject()))
        {
            IOService *service = OSDynamicCast(IOService, object);
            <span class="enscript-keyword">if</span> (object)
            {
                array-&gt;setObject(OSSymbol::withCString(service-&gt;getName()));
            }
        }

        iterator-&gt;release();
        *idleSleepList = array;
    }

    <span class="enscript-keyword">if</span> (systemSleepList &amp;&amp; preventSystemSleepList &amp;&amp; (preventSystemSleepList-&gt;getCount() != 0))
    {
        iterator = OSCollectionIterator::withCollection(preventSystemSleepList);
        array = OSArray::withCapacity(5);

        <span class="enscript-keyword">while</span> ((object = iterator-&gt;getNextObject()))
        {
            IOService *service = OSDynamicCast(IOService, object);
            <span class="enscript-keyword">if</span> (object)
            {
                array-&gt;setObject(OSSymbol::withCString(service-&gt;getName()));
            }
        }

        iterator-&gt;release();
        *systemSleepList = array;
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// tellChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override the superclass implementation to send a different message type.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::tellChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    DLOG(<span class="enscript-string">&quot;tellChangeDown %u-&gt;%u\n&quot;</span>,
        (uint32_t) getPowerState(), (uint32_t) stateNum);

    <span class="enscript-keyword">if</span> (SLEEP_STATE == stateNum)
    {
        <span class="enscript-comment">// Legacy apps were already told in the full-&gt;dark transition
</span>        <span class="enscript-keyword">if</span> (!ignoreTellChangeDown)
            tracePoint( kIOPMTracePointSleepApplications );
        <span class="enscript-keyword">else</span>
            tracePoint( kIOPMTracePointSleepPriorityClients );
    }

    <span class="enscript-keyword">if</span> ((SLEEP_STATE == stateNum) &amp;&amp; !ignoreTellChangeDown)
    {
        userActivityAtSleep = userActivityCount;
        hibernateAborted = false;
        DLOG(<span class="enscript-string">&quot;tellChangeDown::userActivityAtSleep %d\n&quot;</span>, userActivityAtSleep);

        <span class="enscript-comment">// Direct callout into OSKext so it can disable kext unloads
</span>        <span class="enscript-comment">// during sleep/wake to prevent deadlocks.
</span>        OSKextSystemSleepOrWake( kIOMessageSystemWillSleep );

        <span class="enscript-reference">IOService</span>::updateConsoleUsers(NULL, kIOMessageSystemWillSleep);

        <span class="enscript-comment">// Two change downs are sent by IOServicePM. Ignore the 2nd.
</span>        <span class="enscript-comment">// But tellClientsWithResponse() must be called for both.
</span>        ignoreTellChangeDown = true;
    }

    <span class="enscript-keyword">return</span> super::tellClientsWithResponse( kIOMessageSystemWillSleep );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// askChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override the superclass implementation to send a different message type.
</span><span class="enscript-comment">// This must be idle sleep since we don't ask during any other power change.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::askChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    DLOG(<span class="enscript-string">&quot;askChangeDown %u-&gt;%u\n&quot;</span>,
        (uint32_t) getPowerState(), (uint32_t) stateNum);

    <span class="enscript-comment">// Don't log for dark wake entry
</span>    <span class="enscript-keyword">if</span> (kSystemTransitionSleep == _systemTransitionType)
        tracePoint( kIOPMTracePointSleepApplications );

    <span class="enscript-keyword">return</span> super::tellClientsWithResponse( kIOMessageCanSystemSleep );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// askChangeDownDone
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// An opportunity for root domain to cancel the power transition,
</span><span class="enscript-comment">// possibily due to an assertion created by powerd in response to
</span><span class="enscript-comment">// kIOMessageCanSystemSleep.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Idle sleep:
</span><span class="enscript-comment">//   full -&gt; dark wake transition
</span><span class="enscript-comment">//     1. Notify apps and powerd with kIOMessageCanSystemSleep
</span><span class="enscript-comment">//     2. askChangeDownDone()
</span><span class="enscript-comment">//   dark -&gt; sleep transition
</span><span class="enscript-comment">//     1. Notify powerd with kIOMessageCanSystemSleep
</span><span class="enscript-comment">//     2. askChangeDownDone()
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Demand sleep:
</span><span class="enscript-comment">//   full -&gt; dark wake transition
</span><span class="enscript-comment">//     1. Notify powerd with kIOMessageCanSystemSleep
</span><span class="enscript-comment">//     2. askChangeDownDone()
</span><span class="enscript-comment">//   dark -&gt; sleep transition
</span><span class="enscript-comment">//     1. Notify powerd with kIOMessageCanSystemSleep
</span><span class="enscript-comment">//     2. askChangeDownDone()
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::askChangeDownDone</span>(
        IOPMPowerChangeFlags * inOutChangeFlags, <span class="enscript-type">bool</span> * cancel )
{
    DLOG(<span class="enscript-string">&quot;askChangeDownDone(0x%x, %u) type %x, cap %x-&gt;%x\n&quot;</span>,
        *inOutChangeFlags, *cancel,
        _systemTransitionType,
        _currentCapability, _pendingCapability);

    <span class="enscript-keyword">if</span> ((false == *cancel) &amp;&amp; (kSystemTransitionSleep == _systemTransitionType))
    {
        <span class="enscript-comment">// Dark-&gt;Sleep transition.
</span>        <span class="enscript-comment">// Check if there are any deny sleep assertions.
</span>        <span class="enscript-comment">// lastSleepReason already set by handleOurPowerChangeStart()
</span>
        <span class="enscript-keyword">if</span> (!checkSystemCanSleep(lastSleepReason))
        {
            <span class="enscript-comment">// Cancel dark wake to sleep transition.
</span>            <span class="enscript-comment">// Must re-scan assertions upon entering dark wake.
</span>
            *cancel = true;
            DLOG(<span class="enscript-string">&quot;cancel dark-&gt;sleep\n&quot;</span>);
        }
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// systemDidNotSleep
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Work common to both canceled or aborted sleep.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::systemDidNotSleep</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">// reset console lock state
</span>    thread_call_enter(updateConsoleUsersEntry);

    <span class="enscript-keyword">if</span> (!wrangler)
    {
        <span class="enscript-keyword">if</span> (idleSeconds)
        {
            <span class="enscript-comment">// stay awake for at least idleSeconds
</span>            startIdleSleepTimer(idleSeconds);
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> (sleepSlider &amp;&amp; !userIsActive)
        {
            <span class="enscript-comment">// Manually start the idle sleep timer besides waiting for
</span>            <span class="enscript-comment">// the user to become inactive.
</span>            startIdleSleepTimer( kIdleSleepRetryInterval );
        }
    }

    preventTransitionToUserActive(false);
    <span class="enscript-reference">IOService</span>::setAdvisoryTickleEnable( true );

    <span class="enscript-comment">// After idle revert and cancel, send a did-change message to powerd
</span>    <span class="enscript-comment">// to balance the previous will-change message. Kernel clients do not
</span>    <span class="enscript-comment">// need this since sleep cannot be canceled once they are notified.
</span>
    <span class="enscript-keyword">if</span> (toldPowerdCapWillChange &amp;&amp; systemCapabilityNotifier &amp;&amp;
        (_pendingCapability != _currentCapability) &amp;&amp;
        ((_systemMessageClientMask &amp; kSystemMessageClientPowerd) != 0))
    {
        <span class="enscript-comment">// Differs from a real capability gain change where notifyRef != 0,
</span>        <span class="enscript-comment">// but it is zero here since no response is expected.
</span>
        IOPMSystemCapabilityChangeParameters params;

        bzero(&amp;params, <span class="enscript-keyword">sizeof</span>(params));
        params.fromCapabilities = _pendingCapability;
        params.toCapabilities = _currentCapability;
        params.changeFlags = kIOPMSystemCapabilityDidChange;

        DLOG(<span class="enscript-string">&quot;MESG cap %x-&gt;%x did change\n&quot;</span>,
            params.fromCapabilities, params.toCapabilities);
        messageClient(kIOMessageSystemCapabilityChange, systemCapabilityNotifier,
            &amp;params, <span class="enscript-keyword">sizeof</span>(params));
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// tellNoChangeDown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are not dropping
</span><span class="enscript-comment">// power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We override the superclass implementation so we can send a different message
</span><span class="enscript-comment">// type to the client or application being notified.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This must be a vetoed idle sleep, since no other power change can be vetoed.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::tellNoChangeDown</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    DLOG(<span class="enscript-string">&quot;tellNoChangeDown %u-&gt;%u\n&quot;</span>,
        (uint32_t) getPowerState(), (uint32_t) stateNum);

    <span class="enscript-comment">// Sleep canceled, clear the sleep trace point.
</span>    tracePoint(kIOPMTracePointSystemUp);

    systemDidNotSleep();
    <span class="enscript-keyword">return</span> tellClients( kIOMessageSystemWillNotSleep );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// tellChangeUp
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify registered applications and kernel clients that we are raising power.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We override the superclass implementation so we can send a different message
</span><span class="enscript-comment">// type to the client or application being notified.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::tellChangeUp</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> stateNum )
{
    DLOG(<span class="enscript-string">&quot;tellChangeUp %u-&gt;%u\n&quot;</span>,
        (uint32_t) getPowerState(), (uint32_t) stateNum);

    ignoreTellChangeDown = false;

    <span class="enscript-keyword">if</span> ( stateNum == ON_STATE )
    {
        <span class="enscript-comment">// Direct callout into OSKext so it can disable kext unloads
</span>        <span class="enscript-comment">// during sleep/wake to prevent deadlocks.
</span>        OSKextSystemSleepOrWake( kIOMessageSystemHasPoweredOn );

        <span class="enscript-comment">// Notify platform that sleep was cancelled or resumed.
</span>        getPlatform()-&gt;callPlatformFunction(
                        sleepMessagePEFunction, false,
                        (<span class="enscript-type">void</span> *)(uintptr_t) kIOMessageSystemHasPoweredOn,
                        NULL, NULL, NULL);

        <span class="enscript-keyword">if</span> (getPowerState() == ON_STATE)
        {
            <span class="enscript-comment">// this is a quick wake from aborted sleep
</span>            systemDidNotSleep();
            tellClients( kIOMessageSystemWillPowerOn );
        }

        tracePoint( kIOPMTracePointWakeApplications );
        tellClients( kIOMessageSystemHasPoweredOn );
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// sysPowerDownHandler
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Perform a vfs sync before system sleep.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::sysPowerDownHandler</span>(
    <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
    UInt32 messageType, IOService * service,
    <span class="enscript-type">void</span> * messageArgs, vm_size_t argSize )
{
    IOReturn    ret = 0;

    DLOG(<span class="enscript-string">&quot;sysPowerDownHandler message %s\n&quot;</span>, getIOMessageString(messageType));

    <span class="enscript-keyword">if</span> (!gRootDomain)
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">if</span> (messageType == kIOMessageSystemWillSleep)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
        <span class="enscript-type">static</span> int32_t mem_only = -1;
        IOPowerStateChangeNotification *notify =
                    (IOPowerStateChangeNotification *)messageArgs;

       <span class="enscript-keyword">if</span> ((mem_only == -1) &amp;&amp;
           (PE_parse_boot_argn(<span class="enscript-string">&quot;swd_mem_only&quot;</span>, &amp;mem_only, <span class="enscript-keyword">sizeof</span>(mem_only)) == false)) {
           mem_only = 0;
       }
       <span class="enscript-keyword">if</span> ((mem_only != 1) &amp;&amp; (gRootDomain-&gt;sleepWakeDebugIsWdogEnabled()))
       {
           notify-&gt;returnValue = 30 * 1000 * 1000;
           thread_call_enter1(
                              gRootDomain-&gt;hibDebugSetupEntry,
                              (thread_call_param_t)(uintptr_t) notify-&gt;powerRef);
       }
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (messageType == kIOMessageSystemCapabilityChange)
    {
        IOPMSystemCapabilityChangeParameters * params =
            (IOPMSystemCapabilityChangeParameters *) messageArgs;

        <span class="enscript-comment">// Interested applications have been notified of an impending power
</span>        <span class="enscript-comment">// change and have acked (when applicable).
</span>        <span class="enscript-comment">// This is our chance to save whatever state we can before powering
</span>        <span class="enscript-comment">// down.
</span>        <span class="enscript-comment">// We call sync_internal defined in xnu/bsd/vfs/vfs_syscalls.c,
</span>        <span class="enscript-comment">// via callout
</span>
        DLOG(<span class="enscript-string">&quot;sysPowerDownHandler cap %x -&gt; %x (flags %x)\n&quot;</span>,
            params-&gt;fromCapabilities, params-&gt;toCapabilities,
            params-&gt;changeFlags);

        <span class="enscript-keyword">if</span> ((params-&gt;changeFlags &amp; kIOPMSystemCapabilityWillChange) &amp;&amp;
            (params-&gt;fromCapabilities &amp; kIOPMSystemCapabilityCPU) &amp;&amp;
            (params-&gt;toCapabilities &amp; kIOPMSystemCapabilityCPU) == 0)
        {
            <span class="enscript-comment">// We will ack within 20 seconds
</span>            params-&gt;maxWaitForReply = 20 * 1000 * 1000;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            gRootDomain-&gt;evaluateSystemSleepPolicyEarly();

            <span class="enscript-comment">// add in time we could spend freeing pages
</span>            <span class="enscript-keyword">if</span> (gRootDomain-&gt;hibernateMode &amp;&amp; !gRootDomain-&gt;hibernateDisabled)
            {
                params-&gt;maxWaitForReply = kCapabilityClientMaxWait;
            }
            DLOG(<span class="enscript-string">&quot;sysPowerDownHandler max wait %d s\n&quot;</span>,
                (<span class="enscript-type">int</span>) (params-&gt;maxWaitForReply / 1000 / 1000));
#<span class="enscript-reference">endif</span>

            <span class="enscript-comment">// Notify platform that sleep has begun, after the early
</span>            <span class="enscript-comment">// sleep policy evaluation.
</span>            getPlatform()-&gt;callPlatformFunction(
                            sleepMessagePEFunction, false,
                            (<span class="enscript-type">void</span> *)(uintptr_t) kIOMessageSystemWillSleep,
                            NULL, NULL, NULL);

            <span class="enscript-keyword">if</span> ( !OSCompareAndSwap( 0, 1, &amp;gSleepOrShutdownPending ) )
            {
                <span class="enscript-comment">// Purposely delay the ack and hope that shutdown occurs quickly.
</span>                <span class="enscript-comment">// Another option is not to schedule the thread and wait for
</span>                <span class="enscript-comment">// ack timeout...
</span>                AbsoluteTime deadline;
                clock_interval_to_deadline( 30, kSecondScale, &amp;deadline );
                thread_call_enter1_delayed(
                    gRootDomain-&gt;diskSyncCalloutEntry,
                    (thread_call_param_t)(uintptr_t) params-&gt;notifyRef,
                    deadline );
            }
            <span class="enscript-keyword">else</span>
                thread_call_enter1(
                    gRootDomain-&gt;diskSyncCalloutEntry,
                    (thread_call_param_t)(uintptr_t) params-&gt;notifyRef);
        }
        <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">if</span> ((params-&gt;changeFlags &amp; kIOPMSystemCapabilityDidChange) &amp;&amp;
            (params-&gt;toCapabilities &amp; kIOPMSystemCapabilityCPU) &amp;&amp;
            (params-&gt;fromCapabilities &amp; kIOPMSystemCapabilityCPU) == 0)
        {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            <span class="enscript-comment">// We will ack within 110 seconds
</span>            params-&gt;maxWaitForReply = 110 * 1000 * 1000;

            thread_call_enter1(
                gRootDomain-&gt;diskSyncCalloutEntry,
                (thread_call_param_t)(uintptr_t) params-&gt;notifyRef);
#<span class="enscript-reference">endif</span>
        }
        ret = kIOReturnSuccess;
    }

    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// handleQueueSleepWakeUUID
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called from IOPMrootDomain when we're initiating a sleep,
</span><span class="enscript-comment">// or indirectly from PM configd when PM decides to clear the UUID.
</span><span class="enscript-comment">// PM clears the UUID several minutes after successful wake from sleep,
</span><span class="enscript-comment">// so that we might associate App spindumps with the immediately previous
</span><span class="enscript-comment">// sleep/wake.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// @param   obj has a retain on it. We're responsible for releasing that retain.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleQueueSleepWakeUUID</span>(OSObject *obj)
{
    OSString    *str = NULL;

    <span class="enscript-keyword">if</span> (kOSBooleanFalse == obj)
    {
        handlePublishSleepWakeUUID(NULL);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((str = OSDynamicCast(OSString, obj)))
    {
        <span class="enscript-comment">// This branch caches the UUID for an upcoming sleep/wake
</span>        <span class="enscript-keyword">if</span> (queuedSleepWakeUUIDString) {
            queuedSleepWakeUUIDString-&gt;release();
            queuedSleepWakeUUIDString = NULL;
        }
        queuedSleepWakeUUIDString = str;
        queuedSleepWakeUUIDString-&gt;retain();

        DLOG(<span class="enscript-string">&quot;SleepWake UUID queued: %s\n&quot;</span>, queuedSleepWakeUUIDString-&gt;getCStringNoCopy());
    }

    <span class="enscript-keyword">if</span> (obj) {
        obj-&gt;release();
    }
    <span class="enscript-keyword">return</span>;

}
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// handlePublishSleepWakeUUID
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called from IOPMrootDomain when we're initiating a sleep,
</span><span class="enscript-comment">// or indirectly from PM configd when PM decides to clear the UUID.
</span><span class="enscript-comment">// PM clears the UUID several minutes after successful wake from sleep,
</span><span class="enscript-comment">// so that we might associate App spindumps with the immediately previous
</span><span class="enscript-comment">// sleep/wake.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handlePublishSleepWakeUUID</span>( <span class="enscript-type">bool</span> shouldPublish )
{
   ASSERT_GATED();

   <span class="enscript-comment">/*
    * Clear the current UUID
    */</span>
   <span class="enscript-keyword">if</span> (gSleepWakeUUIDIsSet)
   {
        DLOG(<span class="enscript-string">&quot;SleepWake UUID cleared\n&quot;</span>);

        gSleepWakeUUIDIsSet = false;

        removeProperty(kIOPMSleepWakeUUIDKey);
        messageClients(kIOPMMessageSleepWakeUUIDChange, kIOPMMessageSleepWakeUUIDCleared);
    }

    <span class="enscript-comment">/*
     * Optionally, publish a new UUID
     */</span>
    <span class="enscript-keyword">if</span> (queuedSleepWakeUUIDString &amp;&amp; shouldPublish) {

        OSString  *publishThisUUID = NULL;

        publishThisUUID = queuedSleepWakeUUIDString;
        publishThisUUID-&gt;retain();

        <span class="enscript-keyword">if</span> (publishThisUUID)
        {
            setProperty(kIOPMSleepWakeUUIDKey, publishThisUUID);
            publishThisUUID-&gt;release();
        }

        gSleepWakeUUIDIsSet = true;
        messageClients(kIOPMMessageSleepWakeUUIDChange, kIOPMMessageSleepWakeUUIDSet);

        queuedSleepWakeUUIDString-&gt;release();
        queuedSleepWakeUUIDString = NULL;
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// initializeBootSessionUUID
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Initialize the boot session uuid at boot up and sets it into registry.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::initializeBootSessionUUID</span>(<span class="enscript-type">void</span>)
{
    uuid_t          new_uuid;
    uuid_string_t   new_uuid_string;

    uuid_generate(new_uuid);
    uuid_unparse_upper(new_uuid, new_uuid_string);
    memcpy(bootsessionuuid_string, new_uuid_string, <span class="enscript-keyword">sizeof</span>(uuid_string_t));

    setProperty(kIOPMBootSessionUUIDKey, new_uuid_string);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// changePowerStateTo &amp; changePowerStateToPriv
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override of these methods for logging purposes.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::changePowerStateTo</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal )
{
    DLOG(<span class="enscript-string">&quot;changePowerStateTo(%lu)\n&quot;</span>, ordinal);

    <span class="enscript-keyword">if</span> ((ordinal != ON_STATE) &amp;&amp; (ordinal != SLEEP_STATE))
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">return</span> super::changePowerStateTo(ordinal);
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::changePowerStateToPriv</span>( <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ordinal )
{
    DLOG(<span class="enscript-string">&quot;changePowerStateToPriv(%lu)\n&quot;</span>, ordinal);

    <span class="enscript-keyword">if</span> ((ordinal != ON_STATE) &amp;&amp; (ordinal != SLEEP_STATE))
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">return</span> super::changePowerStateToPriv(ordinal);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// activity detect
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::activitySinceSleep</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (userActivityCount != userActivityAtSleep);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::abortHibernation</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">bool</span> ret = activitySinceSleep();

    <span class="enscript-keyword">if</span> (ret &amp;&amp; !hibernateAborted &amp;&amp; checkSystemCanSustainFullWake())
    {
        DLOG(<span class="enscript-string">&quot;activitySinceSleep ABORT [%d, %d]\n&quot;</span>, userActivityCount, userActivityAtSleep);
        hibernateAborted = true;
    }
    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hibernate_should_abort</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (gRootDomain)
        <span class="enscript-keyword">return</span> (gRootDomain-&gt;abortHibernation());
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// willNotifyPowerChildren
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Called after all interested drivers have all acknowledged the power change,
</span><span class="enscript-comment">// but before any power children is informed. Dispatched though a thread call,
</span><span class="enscript-comment">// so it is safe to perform work that might block on a sleeping disk. PM state
</span><span class="enscript-comment">// machine (not thread) will block w/o timeout until this function returns.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::willNotifyPowerChildren</span>( IOPMPowerStateIndex newPowerState )
{
    OSDictionary *dict;
    OSNumber *secs;

    <span class="enscript-keyword">if</span> (SLEEP_STATE == newPowerState)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
        IOHibernateSystemSleep();
        IOHibernateIOKitSleep();
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (gRootDomain-&gt;activitySinceSleep()) {
            dict = OSDictionary::withCapacity(1);
            secs = OSNumber::withNumber(1, 32);

            <span class="enscript-keyword">if</span> (dict &amp;&amp; secs) {
                dict-&gt;setObject(gIOPMSettingDebugWakeRelativeKey, secs);
                gRootDomain-&gt;setProperties(dict);
                MSG(<span class="enscript-string">&quot;Reverting sleep with relative wake\n&quot;</span>);
            }
            <span class="enscript-keyword">if</span> (dict) dict-&gt;release();
            <span class="enscript-keyword">if</span> (secs) secs-&gt;release();
        }

    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// sleepOnClamshellClosed
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// contains the logic to determine if the system should sleep when the clamshell
</span><span class="enscript-comment">// is closed.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::shouldSleepOnClamshellClosed</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!clamshellExists)
        <span class="enscript-keyword">return</span> false;

    DLOG(<span class="enscript-string">&quot;clamshell closed %d, disabled %d, desktopMode %d, ac %d sleepDisabled %d\n&quot;</span>,
        clamshellClosed, clamshellDisabled, desktopMode, acAdaptorConnected, clamshellSleepDisabled);

    <span class="enscript-keyword">return</span> ( !clamshellDisabled &amp;&amp; !(desktopMode &amp;&amp; acAdaptorConnected) &amp;&amp; !clamshellSleepDisabled );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sendClientClamshellNotification</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">/* Only broadcast clamshell alert if clamshell exists. */</span>
    <span class="enscript-keyword">if</span> (!clamshellExists)
        <span class="enscript-keyword">return</span>;

    setProperty(kAppleClamshellStateKey,
        clamshellClosed ? kOSBooleanTrue : kOSBooleanFalse);

    setProperty(kAppleClamshellCausesSleepKey,
        shouldSleepOnClamshellClosed() ? kOSBooleanTrue : kOSBooleanFalse);

    <span class="enscript-comment">/* Argument to message is a bitfiel of
     *      ( kClamshellStateBit | kClamshellSleepBit )
     */</span>
    messageClients(kIOPMMessageClamshellStateChange,
        (<span class="enscript-type">void</span> *)(uintptr_t) ( (clamshellClosed ? kClamshellStateBit : 0)
             | ( shouldSleepOnClamshellClosed() ? kClamshellSleepBit : 0)) );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// getSleepSupported
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Deprecated
</span><span class="enscript-comment">//******************************************************************************
</span>
IOOptionBits <span class="enscript-function-name">IOPMrootDomain::getSleepSupported</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( platformSleepSupport );
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setSleepSupported
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Deprecated
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::setSleepSupported</span>( IOOptionBits flags )
{
    DLOG(<span class="enscript-string">&quot;setSleepSupported(%x)\n&quot;</span>, (uint32_t) flags);
    OSBitOrAtomic(flags, &amp;platformSleepSupport);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setDisableClamShellSleep
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::setDisableClamShellSleep</span>( <span class="enscript-type">bool</span> val )
{
    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate() == false) {

       gIOPMWorkLoop-&gt;runAction(
               OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>, &amp;IOPMrootDomain::setDisableClamShellSleep),
               (OSObject *)<span class="enscript-keyword">this</span>,
               (<span class="enscript-type">void</span> *)val);

       <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">else</span> {
       DLOG(<span class="enscript-string">&quot;setDisableClamShellSleep(%x)\n&quot;</span>, (uint32_t) val);
       <span class="enscript-keyword">if</span> ( clamshellSleepDisabled != val )
       {
           clamshellSleepDisabled = val;
           <span class="enscript-comment">// If clamshellSleepDisabled is reset to 0, reevaluate if
</span>           <span class="enscript-comment">// system need to go to sleep due to clamshell state
</span>           <span class="enscript-keyword">if</span> ( !clamshellSleepDisabled &amp;&amp; clamshellClosed)
              handlePowerNotification(kLocalEvalClamshellCommand);
       }
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// wakeFromDoze
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Deprecated.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::wakeFromDoze</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">// Preserve symbol for familes (IOUSBFamily and IOGraphics)
</span>}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Features
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// publishFeature
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Adds a new feature to the supported features dictionary
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::publishFeature</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * feature )
{
    publishFeature(feature, kRD_AllPowerSources, NULL);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// publishFeature (with supported power source specified)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Adds a new feature to the supported features dictionary
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::publishFeature</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *feature,
    uint32_t supportedWhere,
    uint32_t *uniqueFeatureID)
{
    <span class="enscript-type">static</span> uint16_t     next_feature_id = 500;

    OSNumber            *new_feature_data = NULL;
    OSNumber            *existing_feature = NULL;
    OSArray             *existing_feature_arr = NULL;
    OSObject            *osObj = NULL;
    uint32_t            feature_value = 0;

    supportedWhere &amp;= kRD_AllPowerSources; <span class="enscript-comment">// mask off any craziness!
</span>
    <span class="enscript-keyword">if</span>(!supportedWhere) {
        <span class="enscript-comment">// Feature isn't supported anywhere!
</span>        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span>(next_feature_id &gt; 5000) {
        <span class="enscript-comment">// Far, far too many features!
</span>        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span>(featuresDictLock) IOLockLock(featuresDictLock);

    OSDictionary *features =
        (OSDictionary *) getProperty(kRootDomainSupportedFeatures);

    <span class="enscript-comment">// Create new features dict if necessary
</span>    <span class="enscript-keyword">if</span> ( features &amp;&amp; OSDynamicCast(OSDictionary, features)) {
        features = OSDictionary::withDictionary(features);
    } <span class="enscript-keyword">else</span> {
        features = OSDictionary::withCapacity(1);
    }

    <span class="enscript-comment">// Create OSNumber to track new feature
</span>
    next_feature_id += 1;
    <span class="enscript-keyword">if</span>( uniqueFeatureID ) {
        <span class="enscript-comment">// We don't really mind if the calling kext didn't give us a place
</span>        <span class="enscript-comment">// to stash their unique id. Many kexts don't plan to unload, and thus
</span>        <span class="enscript-comment">// have no need to remove themselves later.
</span>        *uniqueFeatureID = next_feature_id;
    }

    feature_value = (uint32_t)next_feature_id;
    feature_value &lt;&lt;= 16;
    feature_value += supportedWhere;

    new_feature_data = OSNumber::withNumber(
                                (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>)feature_value, 32);

    <span class="enscript-comment">// Does features object already exist?
</span>    <span class="enscript-keyword">if</span>( (osObj = features-&gt;getObject(feature)) )
    {
        <span class="enscript-keyword">if</span>(( existing_feature = OSDynamicCast(OSNumber, osObj) ))
        {
            <span class="enscript-comment">// We need to create an OSArray to hold the now 2 elements.
</span>            existing_feature_arr = OSArray::withObjects(
                            (<span class="enscript-type">const</span> OSObject **)&amp;existing_feature, 1, 2);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>(( existing_feature_arr = OSDynamicCast(OSArray, osObj) ))
        {
            <span class="enscript-comment">// Add object to existing array
</span>            existing_feature_arr = OSArray::withArray(
                            existing_feature_arr,
                            existing_feature_arr-&gt;getCount() + 1);
        }

        <span class="enscript-keyword">if</span> (existing_feature_arr)
        {
            existing_feature_arr-&gt;setObject(new_feature_data);
            features-&gt;setObject(feature, existing_feature_arr);
            existing_feature_arr-&gt;release();
            existing_feature_arr = 0;
        }
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">// The easy case: no previously existing features listed. We simply
</span>        <span class="enscript-comment">// set the OSNumber at key 'feature' and we're on our way.
</span>        features-&gt;setObject(feature, new_feature_data);
    }

    new_feature_data-&gt;release();

    setProperty(kRootDomainSupportedFeatures, features);

    features-&gt;release();

    <span class="enscript-keyword">if</span>(featuresDictLock) IOLockUnlock(featuresDictLock);

    <span class="enscript-comment">// Notify EnergySaver and all those in user space so they might
</span>    <span class="enscript-comment">// re-populate their feature specific UI
</span>    <span class="enscript-keyword">if</span>(pmPowerStateQueue) {
        pmPowerStateQueue-&gt;submitPowerEvent( kPowerEventFeatureChanged );
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// removePublishedFeature
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Removes previously published feature
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::removePublishedFeature</span>( uint32_t removeFeatureID )
{
    IOReturn                ret = kIOReturnError;
    uint32_t                feature_value = 0;
    uint16_t                feature_id = 0;
    <span class="enscript-type">bool</span>                    madeAChange = false;

    OSSymbol                *dictKey = NULL;
    OSCollectionIterator    *dictIterator = NULL;
    OSArray                 *arrayMember  = NULL;
    OSNumber                *numberMember = NULL;
    OSObject                *osObj        = NULL;
    OSNumber                *osNum        = NULL;
    OSArray                 *arrayMemberCopy;

    <span class="enscript-keyword">if</span> (kBadPMFeatureID == removeFeatureID)
        <span class="enscript-keyword">return</span> kIOReturnNotFound;

    <span class="enscript-keyword">if</span>(featuresDictLock) IOLockLock(featuresDictLock);

    OSDictionary *features =
        (OSDictionary *) getProperty(kRootDomainSupportedFeatures);

    <span class="enscript-keyword">if</span> ( features &amp;&amp; OSDynamicCast(OSDictionary, features) )
    {
        <span class="enscript-comment">// Any modifications to the dictionary are made to the copy to prevent
</span>        <span class="enscript-comment">// races &amp; crashes with userland clients. Dictionary updated
</span>        <span class="enscript-comment">// automically later.
</span>        features = OSDictionary::withDictionary(features);
    } <span class="enscript-keyword">else</span> {
        features = NULL;
        ret = kIOReturnNotFound;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// We iterate 'features' dictionary looking for an entry tagged
</span>    <span class="enscript-comment">// with 'removeFeatureID'. If found, we remove it from our tracking
</span>    <span class="enscript-comment">// structures and notify the OS via a general interest message.
</span>
    dictIterator = OSCollectionIterator::withCollection(features);
    <span class="enscript-keyword">if</span>(!dictIterator) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">while</span>( (dictKey = OSDynamicCast(OSSymbol, dictIterator-&gt;getNextObject())) )
    {
        osObj = features-&gt;getObject(dictKey);

        <span class="enscript-comment">// Each Feature is either tracked by an OSNumber
</span>        <span class="enscript-keyword">if</span>( osObj &amp;&amp; (numberMember = OSDynamicCast(OSNumber, osObj)) )
        {
            feature_value = numberMember-&gt;unsigned32BitValue();
            feature_id = (uint16_t)(feature_value &gt;&gt; 16);

            <span class="enscript-keyword">if</span>( feature_id == (uint16_t)removeFeatureID )
            {
                <span class="enscript-comment">// Remove this node
</span>                features-&gt;removeObject(dictKey);
                madeAChange = true;
                <span class="enscript-keyword">break</span>;
            }

        <span class="enscript-comment">// Or tracked by an OSArray of OSNumbers
</span>        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( osObj &amp;&amp; (arrayMember = OSDynamicCast(OSArray, osObj)) )
        {
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> arrayCount = arrayMember-&gt;getCount();

            <span class="enscript-keyword">for</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i=0; i&lt;arrayCount; i++)
            {
                osNum = OSDynamicCast(OSNumber, arrayMember-&gt;getObject(i));
                <span class="enscript-keyword">if</span>(!osNum) {
                    <span class="enscript-keyword">continue</span>;
                }

                feature_value = osNum-&gt;unsigned32BitValue();
                feature_id = (uint16_t)(feature_value &gt;&gt; 16);

                <span class="enscript-keyword">if</span>( feature_id == (uint16_t)removeFeatureID )
                {
                    <span class="enscript-comment">// Remove this node
</span>                    <span class="enscript-keyword">if</span>( 1 == arrayCount ) {
                        <span class="enscript-comment">// If the array only contains one element, remove
</span>                        <span class="enscript-comment">// the whole thing.
</span>                        features-&gt;removeObject(dictKey);
                    } <span class="enscript-keyword">else</span> {
                        <span class="enscript-comment">// Otherwise remove the element from a copy of the array.
</span>                        arrayMemberCopy = OSArray::withArray(arrayMember);
                        <span class="enscript-keyword">if</span> (arrayMemberCopy)
                        {
                            arrayMemberCopy-&gt;removeObject(i);
                            features-&gt;setObject(dictKey, arrayMemberCopy);
                            arrayMemberCopy-&gt;release();
                        }
                    }

                    madeAChange = true;
                    <span class="enscript-keyword">break</span>;
                }
            }
        }
    }

    dictIterator-&gt;release();

    <span class="enscript-keyword">if</span>( madeAChange )
    {
        ret = kIOReturnSuccess;

        setProperty(kRootDomainSupportedFeatures, features);

        <span class="enscript-comment">// Notify EnergySaver and all those in user space so they might
</span>        <span class="enscript-comment">// re-populate their feature specific UI
</span>        <span class="enscript-keyword">if</span>(pmPowerStateQueue) {
            pmPowerStateQueue-&gt;submitPowerEvent( kPowerEventFeatureChanged );
        }
    } <span class="enscript-keyword">else</span> {
        ret = kIOReturnNotFound;
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span>(features)    features-&gt;release();
    <span class="enscript-keyword">if</span>(featuresDictLock) IOLockUnlock(featuresDictLock);
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// publishPMSetting (private)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Should only be called by PMSettingObject to publish a PM Setting as a
</span><span class="enscript-comment">// supported feature.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::publishPMSetting</span>(
    <span class="enscript-type">const</span> OSSymbol * feature, uint32_t where, uint32_t * featureID )
{
    <span class="enscript-keyword">if</span> (noPublishPMSettings &amp;&amp;
        (noPublishPMSettings-&gt;getNextIndexOfObject(feature, 0) != (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1))
    {
        <span class="enscript-comment">// Setting found in noPublishPMSettings array
</span>        *featureID = kBadPMFeatureID;
        <span class="enscript-keyword">return</span>;
    }

    publishFeature(
        feature-&gt;getCStringNoCopy(), where, featureID);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setPMSetting (private)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Internal helper to relay PM settings changes from user space to individual
</span><span class="enscript-comment">// drivers. Should be called only by IOPMrootDomain::setProperties.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::setPMSetting</span>(
    <span class="enscript-type">const</span> OSSymbol  *type,
    OSObject        *object )
{
    PMSettingCallEntry  *entries = 0;
    OSArray             *chosen  = 0;
    <span class="enscript-type">const</span> OSArray       *array;
    PMSettingObject     *pmso;
    thread_t            thisThread;
    <span class="enscript-type">int</span>                 i, j, count, capacity;

    <span class="enscript-keyword">if</span> (NULL == type)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    PMSETTING_LOCK();

    <span class="enscript-comment">// Update settings dict so changes are visible from copyPMSetting().
</span>    fPMSettingsDict-&gt;setObject(type, object);

    <span class="enscript-comment">// Prep all PMSetting objects with the given 'type' for callout.
</span>    array = (<span class="enscript-type">const</span> OSArray *) settingsCallbacks-&gt;getObject(type);
    <span class="enscript-keyword">if</span> (!array || ((capacity = array-&gt;getCount()) == 0))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_exit</span>;

    <span class="enscript-comment">// Array to retain PMSetting objects targeted for callout.
</span>    chosen = OSArray::withCapacity(capacity);
    <span class="enscript-keyword">if</span> (!chosen)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_exit</span>;   <span class="enscript-comment">// error
</span>
    entries = IONew(PMSettingCallEntry, capacity);
    <span class="enscript-keyword">if</span> (!entries)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_exit</span>;   <span class="enscript-comment">// error
</span>    memset(entries, 0, <span class="enscript-keyword">sizeof</span>(PMSettingCallEntry) * capacity);

    thisThread = current_thread();

    <span class="enscript-keyword">for</span> (i = 0, j = 0; i&lt;capacity; i++)
    {
        pmso = (PMSettingObject *) array-&gt;getObject(i);
        <span class="enscript-keyword">if</span> (pmso-&gt;disabled)
            <span class="enscript-keyword">continue</span>;
        entries[j].thread = thisThread;
        queue_enter(&amp;pmso-&gt;calloutQueue, &amp;entries[j], PMSettingCallEntry *, link);
        chosen-&gt;setObject(pmso);
        j++;
    }
    count = j;
    <span class="enscript-keyword">if</span> (!count)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_exit</span>;

    PMSETTING_UNLOCK();

    <span class="enscript-comment">// Call each pmso in the chosen array.
</span>    <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
    {
        pmso = (PMSettingObject *) chosen-&gt;getObject(i);
        pmso-&gt;dispatchPMSetting(type, object);
    }

    PMSETTING_LOCK();
    <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
    {
        pmso = (PMSettingObject *) chosen-&gt;getObject(i);
        queue_remove(&amp;pmso-&gt;calloutQueue, &amp;entries[i], PMSettingCallEntry *, link);
        <span class="enscript-keyword">if</span> (pmso-&gt;waitThread)
        {
            PMSETTING_WAKEUP(pmso);
        }
    }
<span class="enscript-reference">unlock_exit</span>:
    PMSETTING_UNLOCK();

    <span class="enscript-keyword">if</span> (chosen)  chosen-&gt;release();
    <span class="enscript-keyword">if</span> (entries) IODelete(entries, PMSettingCallEntry, capacity);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// copyPMSetting (public)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Allows kexts to safely read setting values, without being subscribed to
</span><span class="enscript-comment">// notifications.
</span><span class="enscript-comment">//******************************************************************************
</span>
OSObject * <span class="enscript-function-name">IOPMrootDomain::copyPMSetting</span>(
    OSSymbol *whichSetting)
{
    OSObject *obj = NULL;

    <span class="enscript-keyword">if</span>(!whichSetting) <span class="enscript-keyword">return</span> NULL;

    PMSETTING_LOCK();
    obj = fPMSettingsDict-&gt;getObject(whichSetting);
    <span class="enscript-keyword">if</span>(obj) {
        obj-&gt;retain();
    }
    PMSETTING_UNLOCK();

    <span class="enscript-keyword">return</span> obj;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// registerPMSettingController (public)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// direct wrapper to registerPMSettingController with uint32_t power source arg
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::registerPMSettingController</span>(
    <span class="enscript-type">const</span> OSSymbol *                settings[],
    IOPMSettingControllerCallback   func,
    OSObject                        *target,
    uintptr_t                       refcon,
    OSObject                        **handle)
{
    <span class="enscript-keyword">return</span> registerPMSettingController(
            settings,
            (kIOPMSupportedOnAC | kIOPMSupportedOnBatt | kIOPMSupportedOnUPS),
            func, target, refcon, handle);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// registerPMSettingController (public)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Kexts may register for notifications when a particular setting is changed.
</span><span class="enscript-comment">// A list of settings is available in IOPM.h.
</span><span class="enscript-comment">// Arguments:
</span><span class="enscript-comment">//  * settings - An OSArray containing OSSymbols. Caller should populate this
</span><span class="enscript-comment">//          array with a list of settings caller wants notifications from.
</span><span class="enscript-comment">//  * func - A C function callback of the type IOPMSettingControllerCallback
</span><span class="enscript-comment">//  * target - caller may provide an OSObject *, which PM will pass as an
</span><span class="enscript-comment">//          target to calls to &quot;func&quot;
</span><span class="enscript-comment">//  * refcon - caller may provide an void *, which PM will pass as an
</span><span class="enscript-comment">//          argument to calls to &quot;func&quot;
</span><span class="enscript-comment">//  * handle - This is a return argument. We will populate this pointer upon
</span><span class="enscript-comment">//          call success. Hold onto this and pass this argument to
</span><span class="enscript-comment">//          IOPMrootDomain::deRegisterPMSettingCallback when unloading your kext
</span><span class="enscript-comment">// Returns:
</span><span class="enscript-comment">//      kIOReturnSuccess on success
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::registerPMSettingController</span>(
    <span class="enscript-type">const</span> OSSymbol *                settings[],
    uint32_t                        supportedPowerSources,
    IOPMSettingControllerCallback   func,
    OSObject                        *target,
    uintptr_t                       refcon,
    OSObject                        **handle)
{
    PMSettingObject *pmso = NULL;
    OSObject        *pmsh = NULL;
    OSArray         *list = NULL;
    <span class="enscript-type">int</span>             i;

    <span class="enscript-keyword">if</span> (NULL == settings ||
        NULL == func     ||
        NULL == handle)
    {
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    pmso = PMSettingObject::pmSettingObject(
                (IOPMrootDomain *) <span class="enscript-keyword">this</span>, func, target,
                refcon, supportedPowerSources, settings, &amp;pmsh);

    <span class="enscript-keyword">if</span> (!pmso) {
        *handle = NULL;
        <span class="enscript-keyword">return</span> kIOReturnInternalError;
    }

    PMSETTING_LOCK();
    <span class="enscript-keyword">for</span> (i=0; settings[i]; i++)
    {
        list = (OSArray *) settingsCallbacks-&gt;getObject(settings[i]);
        <span class="enscript-keyword">if</span> (!list) {
            <span class="enscript-comment">// New array of callbacks for this setting
</span>            list = OSArray::withCapacity(1);
            settingsCallbacks-&gt;setObject(settings[i], list);
            list-&gt;release();
        }

        <span class="enscript-comment">// Add caller to the callback list
</span>        list-&gt;setObject(pmso);
    }
    PMSETTING_UNLOCK();

    <span class="enscript-comment">// Return handle to the caller, the setting object is private.
</span>    *handle = pmsh;

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// deregisterPMSettingObject (private)
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Only called from PMSettingObject.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::deregisterPMSettingObject</span>( PMSettingObject * pmso )
{
    thread_t                thisThread = current_thread();
    PMSettingCallEntry      *callEntry;
    OSCollectionIterator    *iter;
    OSSymbol                *sym;
    OSArray                 *array;
    <span class="enscript-type">int</span>                     index;
    <span class="enscript-type">bool</span>                    wait;

    PMSETTING_LOCK();

    pmso-&gt;disabled = true;

    <span class="enscript-comment">// Wait for all callout threads to finish.
</span>    <span class="enscript-keyword">do</span> {
        wait = false;
        queue_iterate(&amp;pmso-&gt;calloutQueue, callEntry, PMSettingCallEntry *, link)
        {
            <span class="enscript-keyword">if</span> (callEntry-&gt;thread != thisThread)
            {
                wait = true;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">if</span> (wait)
        {
            assert(0 == pmso-&gt;waitThread);
            pmso-&gt;waitThread = thisThread;
            PMSETTING_WAIT(pmso);
            pmso-&gt;waitThread = 0;
        }
    } <span class="enscript-keyword">while</span> (wait);

    <span class="enscript-comment">// Search each PM settings array in the kernel.
</span>    iter = OSCollectionIterator::withCollection(settingsCallbacks);
    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">while</span> ((sym = OSDynamicCast(OSSymbol, iter-&gt;getNextObject())))
        {
            array = (OSArray *) settingsCallbacks-&gt;getObject(sym);
            index = array-&gt;getNextIndexOfObject(pmso, 0);
            <span class="enscript-keyword">if</span> (-1 != index) {
                array-&gt;removeObject(index);
            }
        }
        iter-&gt;release();
    }

    PMSETTING_UNLOCK();

    pmso-&gt;release();
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// informCPUStateChange
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Call into PM CPU code so that CPU power savings may dynamically adjust for
</span><span class="enscript-comment">// running on battery, with the lid closed, etc.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// informCPUStateChange is a no-op on non x86 systems
</span><span class="enscript-comment">// only x86 has explicit support in the IntelCPUPowerManagement kext
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::informCPUStateChange</span>(
    uint32_t type,
    uint32_t value )
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

    pmioctlVariableInfo_t varInfoStruct;
    <span class="enscript-type">int</span>                 pmCPUret = 0;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          *varNameStr = NULL;
    int32_t             *varIndex   = NULL;

    <span class="enscript-keyword">if</span> (kInformAC == type) {
        varNameStr = kIOPMRootDomainBatPowerCString;
        varIndex = &amp;idxPMCPULimitedPower;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kInformLid == type) {
        varNameStr = kIOPMRootDomainLidCloseCString;
        varIndex = &amp;idxPMCPUClamshell;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Set the new value!
</span>    <span class="enscript-comment">// pmCPUControl will assign us a new ID if one doesn't exist yet
</span>    bzero(&amp;varInfoStruct, <span class="enscript-keyword">sizeof</span>(pmioctlVariableInfo_t));
    varInfoStruct.varID         = *varIndex;
    varInfoStruct.varType       = vBool;
    varInfoStruct.varInitValue  = value;
    varInfoStruct.varCurValue   = value;
    strncpy( (<span class="enscript-type">char</span> *)varInfoStruct.varName,
             (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)varNameStr,
             strlen(varNameStr) + 1 );

    <span class="enscript-comment">// Set!
</span>    pmCPUret = pmCPUControl( PMIOCSETVARINFO, (<span class="enscript-type">void</span> *)&amp;varInfoStruct );

    <span class="enscript-comment">// pmCPU only assigns numerical id's when a new varName is specified
</span>    <span class="enscript-keyword">if</span> ((0 == pmCPUret)
        &amp;&amp; (*varIndex == kCPUUnknownIndex))
    {
        <span class="enscript-comment">// pmCPUControl has assigned us a new variable ID.
</span>        <span class="enscript-comment">// Let's re-read the structure we just SET to learn that ID.
</span>        pmCPUret = pmCPUControl( PMIOCGETVARNAMEINFO, (<span class="enscript-type">void</span> *)&amp;varInfoStruct );

        <span class="enscript-keyword">if</span> (0 == pmCPUret)
        {
            <span class="enscript-comment">// Store it in idxPMCPUClamshell or idxPMCPULimitedPower
</span>            *varIndex = varInfoStruct.varID;
        }
    }

    <span class="enscript-keyword">return</span>;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __i386__ || __x86_64__ */</span>
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Deep Sleep Policy
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// evaluateSystemSleepPolicy
</span><span class="enscript-comment">//******************************************************************************
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPlatformSystemSleepPolicyKey</span>     <span class="enscript-string">&quot;IOPlatformSystemSleepPolicy&quot;</span>

<span class="enscript-comment">// Sleep flags
</span><span class="enscript-type">enum</span> {
    kIOPMSleepFlagHibernate         = 0x00000001,
    kIOPMSleepFlagSleepTimerEnable  = 0x00000002
};

<span class="enscript-type">struct</span> IOPMSystemSleepPolicyEntry
{
    uint32_t    factorMask;
    uint32_t    factorBits;
    uint32_t    sleepFlags;
    uint32_t    wakeEvents;
} __attribute__((packed));

<span class="enscript-type">struct</span> IOPMSystemSleepPolicyTable
{
    uint32_t    signature;
    uint16_t    version;
    uint16_t    entryCount;
    IOPMSystemSleepPolicyEntry  entries[];
} __attribute__((packed));

<span class="enscript-type">enum</span> {
    kIOPMSleepAttributeHibernateSetup   = 0x00000001,
    kIOPMSleepAttributeHibernateSleep   = 0x00000002
};

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">getSleepTypeAttributes</span>( uint32_t sleepType )
{
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t sleepTypeAttributes[ kIOPMSleepTypeLast ] =
    {
    <span class="enscript-comment">/* invalid   */</span> 0,
    <span class="enscript-comment">/* abort     */</span> 0,
    <span class="enscript-comment">/* normal    */</span> 0,
    <span class="enscript-comment">/* safesleep */</span> kIOPMSleepAttributeHibernateSetup,
    <span class="enscript-comment">/* hibernate */</span> kIOPMSleepAttributeHibernateSetup | kIOPMSleepAttributeHibernateSleep,
    <span class="enscript-comment">/* standby   */</span> kIOPMSleepAttributeHibernateSetup | kIOPMSleepAttributeHibernateSleep,
    <span class="enscript-comment">/* poweroff  */</span> kIOPMSleepAttributeHibernateSetup | kIOPMSleepAttributeHibernateSleep,
    <span class="enscript-comment">/* deepidle  */</span> 0
    };

    <span class="enscript-keyword">if</span> (sleepType &gt;= kIOPMSleepTypeLast)
        <span class="enscript-keyword">return</span> 0;

    <span class="enscript-keyword">return</span> sleepTypeAttributes[sleepType];
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::evaluateSystemSleepPolicy</span>(
    IOPMSystemSleepParameters * params, <span class="enscript-type">int</span> sleepPhase, uint32_t * hibMode )
{
    <span class="enscript-type">const</span> IOPMSystemSleepPolicyTable * pt;
    OSObject *  prop = 0;
    OSData *    policyData;
    uint64_t    currentFactors = 0;
    uint32_t    standbyDelay   = 0;
    uint32_t    powerOffDelay  = 0;
    uint32_t    powerOffTimer  = 0;
    uint32_t    mismatch;
    <span class="enscript-type">bool</span>        standbyEnabled;
    <span class="enscript-type">bool</span>        powerOffEnabled;
    <span class="enscript-type">bool</span>        found = false;

    <span class="enscript-comment">// Get platform's sleep policy table
</span>    <span class="enscript-keyword">if</span> (!gSleepPolicyHandler)
    {
        prop = getServiceRoot()-&gt;copyProperty(kIOPlatformSystemSleepPolicyKey);
        <span class="enscript-keyword">if</span> (!prop) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-comment">// Fetch additional settings
</span>    standbyEnabled = (getSleepOption(kIOPMDeepSleepDelayKey, &amp;standbyDelay)
        &amp;&amp; (getProperty(kIOPMDeepSleepEnabledKey) == kOSBooleanTrue));
    powerOffEnabled = (getSleepOption(kIOPMAutoPowerOffDelayKey, &amp;powerOffDelay)
        &amp;&amp; (getProperty(kIOPMAutoPowerOffEnabledKey) == kOSBooleanTrue));
    <span class="enscript-keyword">if</span> (!getSleepOption(kIOPMAutoPowerOffTimerKey, &amp;powerOffTimer))
        powerOffTimer = powerOffDelay;

    DLOG(<span class="enscript-string">&quot;phase %d, standby %d delay %u, poweroff %d delay %u timer %u, hibernate 0x%x\n&quot;</span>,
        sleepPhase, standbyEnabled, standbyDelay,
        powerOffEnabled, powerOffDelay, powerOffTimer, *hibMode);

    <span class="enscript-comment">// pmset level overrides
</span>    <span class="enscript-keyword">if</span> ((*hibMode &amp; kIOHibernateModeOn) == 0)
    {
        <span class="enscript-keyword">if</span> (!gSleepPolicyHandler)
        {
            standbyEnabled  = false;
            powerOffEnabled = false;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(*hibMode &amp; kIOHibernateModeSleep))
    {
        <span class="enscript-comment">// Force hibernate (i.e. mode 25)
</span>        <span class="enscript-comment">// If standby is enabled, force standy.
</span>        <span class="enscript-comment">// If poweroff is enabled, force poweroff.
</span>        <span class="enscript-keyword">if</span> (standbyEnabled)
            currentFactors |= kIOPMSleepFactorStandbyForced;
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (powerOffEnabled)
            currentFactors |= kIOPMSleepFactorAutoPowerOffForced;
        <span class="enscript-keyword">else</span>
            currentFactors |= kIOPMSleepFactorHibernateForced;
    }

    <span class="enscript-comment">// Current factors based on environment and assertions
</span>    <span class="enscript-keyword">if</span> (sleepTimerMaintenance)
        currentFactors |= kIOPMSleepFactorSleepTimerWake;
    <span class="enscript-keyword">if</span> (standbyEnabled &amp;&amp; sleepToStandby &amp;&amp; !gSleepPolicyHandler)
        currentFactors |= kIOPMSleepFactorSleepTimerWake;
    <span class="enscript-keyword">if</span> (!clamshellClosed)
        currentFactors |= kIOPMSleepFactorLidOpen;
    <span class="enscript-keyword">if</span> (acAdaptorConnected)
        currentFactors |= kIOPMSleepFactorACPower;
    <span class="enscript-keyword">if</span> (lowBatteryCondition)
        currentFactors |= kIOPMSleepFactorBatteryLow;
    <span class="enscript-keyword">if</span> (!standbyDelay)
        currentFactors |= kIOPMSleepFactorStandbyNoDelay;
    <span class="enscript-keyword">if</span> (!standbyEnabled)
        currentFactors |= kIOPMSleepFactorStandbyDisabled;
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionUSBExternalDeviceBit) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorUSBExternalDevice;
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionBluetoothHIDDevicePairedBit) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorBluetoothHIDDevice;
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionExternalMediaMountedBit) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorExternalMediaMounted;
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionReservedBit5) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorThunderboltDevice;
    <span class="enscript-keyword">if</span> (_scheduledAlarms != 0)
        currentFactors |= kIOPMSleepFactorRTCAlarmScheduled;
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionMagicPacketWakeEnabledBit) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorMagicPacketWakeEnabled;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCPKEEPALIVE</span> 1
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPKEEPALIVE</span>
    <span class="enscript-keyword">if</span> (getPMAssertionLevel(kIOPMDriverAssertionNetworkKeepAliveActiveBit) !=
        kIOPMDriverAssertionLevelOff)
        currentFactors |= kIOPMSleepFactorNetworkKeepAliveActive;
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!powerOffEnabled)
        currentFactors |= kIOPMSleepFactorAutoPowerOffDisabled;
    <span class="enscript-keyword">if</span> (desktopMode)
        currentFactors |= kIOPMSleepFactorExternalDisplay;
    <span class="enscript-keyword">if</span> (userWasActive)
        currentFactors |= kIOPMSleepFactorLocalUserActivity;
    <span class="enscript-keyword">if</span> (darkWakeHibernateError &amp;&amp; !CAP_HIGHEST(kIOPMSystemCapabilityGraphics))
        currentFactors |= kIOPMSleepFactorHibernateFailed;
    <span class="enscript-keyword">if</span> (thermalWarningState)
        currentFactors |= kIOPMSleepFactorThermalWarning;

    DLOG(<span class="enscript-string">&quot;sleep factors 0x%llx\n&quot;</span>, currentFactors);

    <span class="enscript-keyword">if</span> (gSleepPolicyHandler)
    {
        uint32_t    savedHibernateMode;
        IOReturn    result;

        <span class="enscript-keyword">if</span> (!gSleepPolicyVars)
        {
            gSleepPolicyVars = IONew(IOPMSystemSleepPolicyVariables, 1);
            <span class="enscript-keyword">if</span> (!gSleepPolicyVars)
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
            bzero(gSleepPolicyVars, <span class="enscript-keyword">sizeof</span>(*gSleepPolicyVars));
        }
        gSleepPolicyVars-&gt;signature = kIOPMSystemSleepPolicySignature;
        gSleepPolicyVars-&gt;version   = kIOPMSystemSleepPolicyVersion;
        gSleepPolicyVars-&gt;currentCapability = _currentCapability;
        gSleepPolicyVars-&gt;highestCapability = _highestCapability;
        gSleepPolicyVars-&gt;sleepFactors      = currentFactors;
        gSleepPolicyVars-&gt;sleepReason       = lastSleepReason;
        gSleepPolicyVars-&gt;sleepPhase        = sleepPhase;
        gSleepPolicyVars-&gt;standbyDelay      = standbyDelay;
        gSleepPolicyVars-&gt;poweroffDelay     = powerOffDelay;
        gSleepPolicyVars-&gt;scheduledAlarms   = _scheduledAlarms | _userScheduledAlarm;
        gSleepPolicyVars-&gt;poweroffTimer     = powerOffTimer;

        <span class="enscript-keyword">if</span> (kIOPMSleepPhase0 == sleepPhase)
        {
            <span class="enscript-comment">// preserve hibernateMode
</span>            savedHibernateMode = gSleepPolicyVars-&gt;hibernateMode;
            gSleepPolicyVars-&gt;hibernateMode = *hibMode;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOPMSleepPhase1 == sleepPhase)
        {
            <span class="enscript-comment">// use original hibernateMode for phase2
</span>            gSleepPolicyVars-&gt;hibernateMode = *hibMode;
        }

        result = gSleepPolicyHandler(gSleepPolicyTarget, gSleepPolicyVars, params);

        <span class="enscript-keyword">if</span> (kIOPMSleepPhase0 == sleepPhase)
        {
            <span class="enscript-comment">// restore hibernateMode
</span>            gSleepPolicyVars-&gt;hibernateMode = savedHibernateMode;
        }

        <span class="enscript-keyword">if</span> ((result != kIOReturnSuccess) ||
             (kIOPMSleepTypeInvalid == params-&gt;sleepType) ||
             (params-&gt;sleepType &gt;= kIOPMSleepTypeLast) ||
             (kIOPMSystemSleepParametersVersion != params-&gt;version))
        {
            MSG(<span class="enscript-string">&quot;sleep policy handler error\n&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }

        <span class="enscript-keyword">if</span> ((getSleepTypeAttributes(params-&gt;sleepType) &amp;
             kIOPMSleepAttributeHibernateSetup) &amp;&amp;
            ((*hibMode &amp; kIOHibernateModeOn) == 0))
        {
            *hibMode |= (kIOHibernateModeOn | kIOHibernateModeSleep);
        }

        DLOG(<span class="enscript-string">&quot;sleep params v%u, type %u, flags 0x%x, wake 0x%x, timer %u, poweroff %u\n&quot;</span>,
            params-&gt;version, params-&gt;sleepType, params-&gt;sleepFlags,
            params-&gt;ecWakeEvents, params-&gt;ecWakeTimer, params-&gt;ecPoweroffTimer);
        found = true;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-comment">// Policy table is meaningless without standby enabled
</span>    <span class="enscript-keyword">if</span> (!standbyEnabled)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    <span class="enscript-comment">// Validate the sleep policy table
</span>    policyData = OSDynamicCast(OSData, prop);
    <span class="enscript-keyword">if</span> (!policyData || (policyData-&gt;getLength() &lt;= <span class="enscript-keyword">sizeof</span>(IOPMSystemSleepPolicyTable)))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    pt = (<span class="enscript-type">const</span> IOPMSystemSleepPolicyTable *) policyData-&gt;getBytesNoCopy();
    <span class="enscript-keyword">if</span> ((pt-&gt;signature != kIOPMSystemSleepPolicySignature) ||
        (pt-&gt;version != 1) || (0 == pt-&gt;entryCount))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    <span class="enscript-keyword">if</span> (((policyData-&gt;getLength() - <span class="enscript-keyword">sizeof</span>(IOPMSystemSleepPolicyTable)) !=
         (<span class="enscript-keyword">sizeof</span>(IOPMSystemSleepPolicyEntry) * pt-&gt;entryCount)))
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    <span class="enscript-keyword">for</span> (uint32_t i = 0; i &lt; pt-&gt;entryCount; i++)
    {
        <span class="enscript-type">const</span> IOPMSystemSleepPolicyEntry * entry = &amp;pt-&gt;entries[i];
        mismatch = (((uint32_t)currentFactors ^ entry-&gt;factorBits) &amp; entry-&gt;factorMask);

        DLOG(<span class="enscript-string">&quot;mask 0x%08x, bits 0x%08x, flags 0x%08x, wake 0x%08x, mismatch 0x%08x\n&quot;</span>,
            entry-&gt;factorMask, entry-&gt;factorBits,
            entry-&gt;sleepFlags, entry-&gt;wakeEvents, mismatch);
        <span class="enscript-keyword">if</span> (mismatch)
            <span class="enscript-keyword">continue</span>;

        DLOG(<span class="enscript-string">&quot;^ found match\n&quot;</span>);
        found = true;

        params-&gt;version = kIOPMSystemSleepParametersVersion;
        params-&gt;reserved1 = 1;
        <span class="enscript-keyword">if</span> (entry-&gt;sleepFlags &amp; kIOPMSleepFlagHibernate)
            params-&gt;sleepType = kIOPMSleepTypeStandby;
        <span class="enscript-keyword">else</span>
            params-&gt;sleepType = kIOPMSleepTypeNormalSleep;

        params-&gt;ecWakeEvents = entry-&gt;wakeEvents;
        <span class="enscript-keyword">if</span> (entry-&gt;sleepFlags &amp; kIOPMSleepFlagSleepTimerEnable)
        {
            <span class="enscript-keyword">if</span> (kIOPMSleepPhase2 == sleepPhase)
            {
                clock_sec_t now_secs = gIOLastSleepTime.tv_sec;

                <span class="enscript-keyword">if</span> (!_standbyTimerResetSeconds ||
                    (now_secs &lt;= _standbyTimerResetSeconds))
                {
                    <span class="enscript-comment">// Reset standby timer adjustment
</span>                    _standbyTimerResetSeconds = now_secs;
                    DLOG(<span class="enscript-string">&quot;standby delay %u, reset %u\n&quot;</span>,
                        standbyDelay, (uint32_t) _standbyTimerResetSeconds);
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (standbyDelay)
                {
                    <span class="enscript-comment">// Shorten the standby delay timer
</span>                    clock_sec_t elapsed = now_secs - _standbyTimerResetSeconds;
                    <span class="enscript-keyword">if</span> (standbyDelay &gt; elapsed)
                        standbyDelay -= elapsed;
                    <span class="enscript-keyword">else</span>
                        standbyDelay = 1; <span class="enscript-comment">// must be &gt; 0
</span>
                    DLOG(<span class="enscript-string">&quot;standby delay %u, elapsed %u\n&quot;</span>,
                        standbyDelay, (uint32_t) elapsed);
                }
            }
            params-&gt;ecWakeTimer = standbyDelay;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOPMSleepPhase2 == sleepPhase)
        {
            <span class="enscript-comment">// A sleep that does not enable the sleep timer will reset
</span>            <span class="enscript-comment">// the standby delay adjustment.
</span>            _standbyTimerResetSeconds = 0;
        }
        <span class="enscript-keyword">break</span>;
    }

<span class="enscript-reference">done</span>:
    <span class="enscript-keyword">if</span> (prop)
        prop-&gt;release();

    <span class="enscript-keyword">return</span> found;
}

<span class="enscript-type">static</span> IOPMSystemSleepParameters gEarlySystemSleepParams;

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::evaluateSystemSleepPolicyEarly</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">// Evaluate early (priority interest phase), before drivers sleep.
</span>
    DLOG(<span class="enscript-string">&quot;%s\n&quot;</span>, __FUNCTION__);
    removeProperty(kIOPMSystemSleepParametersKey);

    <span class="enscript-comment">// Full wake resets the standby timer delay adjustment
</span>    <span class="enscript-keyword">if</span> (_highestCapability &amp; kIOPMSystemCapabilityGraphics)
        _standbyTimerResetSeconds = 0;

    hibernateDisabled = false;
    hibernateMode = 0;
    getSleepOption(kIOHibernateModeKey, &amp;hibernateMode);

    <span class="enscript-comment">// Save for late evaluation if sleep is aborted
</span>    bzero(&amp;gEarlySystemSleepParams, <span class="enscript-keyword">sizeof</span>(gEarlySystemSleepParams));

    <span class="enscript-keyword">if</span> (evaluateSystemSleepPolicy(&amp;gEarlySystemSleepParams, kIOPMSleepPhase1,
                                  &amp;hibernateMode))
    {
        <span class="enscript-keyword">if</span> (!hibernateRetry &amp;&amp;
            ((getSleepTypeAttributes(gEarlySystemSleepParams.sleepType) &amp;
              kIOPMSleepAttributeHibernateSetup) == 0))
        {
            <span class="enscript-comment">// skip hibernate setup
</span>            hibernateDisabled = true;
        }
    }

    <span class="enscript-comment">// Publish IOPMSystemSleepType
</span>    uint32_t sleepType = gEarlySystemSleepParams.sleepType;
    <span class="enscript-keyword">if</span> (sleepType == kIOPMSleepTypeInvalid)
    {
        <span class="enscript-comment">// no sleep policy
</span>        sleepType = kIOPMSleepTypeNormalSleep;
        <span class="enscript-keyword">if</span> (hibernateMode &amp; kIOHibernateModeOn)
            sleepType = (hibernateMode &amp; kIOHibernateModeSleep) ?
                        kIOPMSleepTypeSafeSleep : kIOPMSleepTypeHibernate;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((sleepType == kIOPMSleepTypeStandby) &amp;&amp;
             (gEarlySystemSleepParams.ecPoweroffTimer))
    {
        <span class="enscript-comment">// report the lowest possible sleep state
</span>        sleepType = kIOPMSleepTypePowerOff;
    }

    setProperty(kIOPMSystemSleepTypeKey, sleepType, 32);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::evaluateSystemSleepPolicyFinal</span>( <span class="enscript-type">void</span> )
{
    IOPMSystemSleepParameters   params;
    OSData *                    paramsData;

    <span class="enscript-comment">// Evaluate sleep policy after sleeping drivers but before platform sleep.
</span>
    DLOG(<span class="enscript-string">&quot;%s\n&quot;</span>, __FUNCTION__);

    bzero(&amp;params, <span class="enscript-keyword">sizeof</span>(params));
    <span class="enscript-keyword">if</span> (evaluateSystemSleepPolicy(&amp;params, kIOPMSleepPhase2, &amp;hibernateMode))
    {
        <span class="enscript-keyword">if</span> ((hibernateDisabled || hibernateAborted) &amp;&amp;
            (getSleepTypeAttributes(params.sleepType) &amp;
             kIOPMSleepAttributeHibernateSetup))
        {
            <span class="enscript-comment">// Final evaluation picked a state requiring hibernation,
</span>            <span class="enscript-comment">// but hibernate setup was skipped. Arm a short sleep using
</span>            <span class="enscript-comment">// the early non-hibernate sleep parameters.
</span>            <span class="enscript-comment">// Set hibernateRetry flag to force hibernate setup on the
</span>            <span class="enscript-comment">// next sleep.
</span>
            bcopy(&amp;gEarlySystemSleepParams, &amp;params, <span class="enscript-keyword">sizeof</span>(params));
            params.sleepType = kIOPMSleepTypeAbortedSleep;
            params.ecWakeTimer = 1;
            hibernateRetry = true;
            DLOG(<span class="enscript-string">&quot;wake in %u secs for hibernateDisabled %d, hibernateAborted %d\n&quot;</span>,
                params.ecWakeTimer, hibernateDisabled, hibernateAborted);
        }
        <span class="enscript-keyword">else</span>
        {
            hibernateRetry = false;
        }

        paramsData = OSData::withBytes(&amp;params, <span class="enscript-keyword">sizeof</span>(params));
        <span class="enscript-keyword">if</span> (paramsData)
        {
            setProperty(kIOPMSystemSleepParametersKey, paramsData);
            paramsData-&gt;release();
        }

        <span class="enscript-keyword">if</span> (getSleepTypeAttributes(params.sleepType) &amp;
            kIOPMSleepAttributeHibernateSleep)
        {
            <span class="enscript-comment">// Disable sleep to force hibernation
</span>            gIOHibernateMode &amp;= ~kIOHibernateModeSleep;
        }
    }
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::getHibernateSettings</span>(
    uint32_t *  hibernateModePtr,
    uint32_t *  hibernateFreeRatio,
    uint32_t *  hibernateFreeTime )
{
    <span class="enscript-comment">// Called by IOHibernateSystemSleep() after evaluateSystemSleepPolicyEarly()
</span>    <span class="enscript-comment">// has updated the hibernateDisabled flag.
</span>
    <span class="enscript-type">bool</span> ok = getSleepOption(kIOHibernateModeKey, hibernateModePtr);
    getSleepOption(kIOHibernateFreeRatioKey, hibernateFreeRatio);
    getSleepOption(kIOHibernateFreeTimeKey, hibernateFreeTime);
    <span class="enscript-keyword">if</span> (hibernateDisabled)
        *hibernateModePtr = 0;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gSleepPolicyHandler)
        *hibernateModePtr = hibernateMode;
    DLOG(<span class="enscript-string">&quot;hibernateMode 0x%x\n&quot;</span>, *hibernateModePtr);
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::getSleepOption</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * key, uint32_t * option )
{
    OSObject *      optionsProp;
    OSDictionary *  optionsDict;
    OSObject *      obj = 0;
    OSNumber *      num;
    <span class="enscript-type">bool</span>            ok = false;

    optionsProp = copyProperty(kRootDomainSleepOptionsKey);
    optionsDict = OSDynamicCast(OSDictionary, optionsProp);

    <span class="enscript-keyword">if</span> (optionsDict)
    {
        obj = optionsDict-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (obj) obj-&gt;retain();
    }
    <span class="enscript-keyword">if</span> (!obj)
    {
        obj = copyProperty(key);
    }
    <span class="enscript-keyword">if</span> (obj) 
    {
        <span class="enscript-keyword">if</span> ((num = OSDynamicCast(OSNumber, obj)))
        {
            *option = num-&gt;unsigned32BitValue();
            ok = true;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (OSDynamicCast(OSBoolean, obj))
        {
            *option = (obj == kOSBooleanTrue) ? 1 : 0;
            ok = true;
        }
    }

    <span class="enscript-keyword">if</span> (obj)
        obj-&gt;release();
    <span class="enscript-keyword">if</span> (optionsProp)
        optionsProp-&gt;release();

    <span class="enscript-keyword">return</span> true;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>

IOReturn <span class="enscript-function-name">IOPMrootDomain::getSystemSleepType</span>( uint32_t * sleepType )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    IOPMSystemSleepParameters   params;
    uint32_t                    hibMode = 0;
    <span class="enscript-type">bool</span>                        ok;

    <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate() == false)
    {
        IOReturn ret = gIOPMWorkLoop-&gt;runAction(
                        OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>,
                            &amp;IOPMrootDomain::getSystemSleepType),
                        (OSObject *) <span class="enscript-keyword">this</span>,
                        (<span class="enscript-type">void</span> *) sleepType);
        <span class="enscript-keyword">return</span> ret;
    }

    getSleepOption(kIOHibernateModeKey, &amp;hibMode);
    bzero(&amp;params, <span class="enscript-keyword">sizeof</span>(params));

    ok = evaluateSystemSleepPolicy(&amp;params, kIOPMSleepPhase0, &amp;hibMode);
    <span class="enscript-keyword">if</span> (ok)
    {
        *sleepType = params.sleepType;
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Shutdown and Restart
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// handlePlatformHaltRestart
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">struct</span> HaltRestartApplierContext {
    IOPMrootDomain *    RootDomain;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>       PowerState;
    IOPMPowerFlags      PowerFlags;
    UInt32              MessageType;
    UInt32              Counter;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *        LogString;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">platformHaltRestartApplier</span>( OSObject * object, <span class="enscript-type">void</span> * context )
{
    IOPowerStateChangeNotification  notify;
    HaltRestartApplierContext *     ctx;
    AbsoluteTime                    startTime;
    uint32_t                        deltaTime;

    ctx = (HaltRestartApplierContext *) context;

    memset(&amp;notify, 0, <span class="enscript-keyword">sizeof</span>(notify));
    notify.powerRef    = (<span class="enscript-type">void</span> *)(uintptr_t)ctx-&gt;Counter;
    notify.returnValue = 0;
    notify.stateNumber = ctx-&gt;PowerState;
    notify.stateFlags  = ctx-&gt;PowerFlags;

    clock_get_uptime(&amp;startTime);
    ctx-&gt;RootDomain-&gt;messageClient( ctx-&gt;MessageType, object, (<span class="enscript-type">void</span> *)&amp;notify );
    deltaTime = computeDeltaTimeMS(&amp;startTime);

    <span class="enscript-keyword">if</span> ((deltaTime &gt; kPMHaltTimeoutMS) ||
        (gIOKitDebug &amp; kIOLogPMRootDomain))
    {
        _IOServiceInterestNotifier * notifier;
        notifier = OSDynamicCast(_IOServiceInterestNotifier, object);

        <span class="enscript-comment">// IOService children of IOPMrootDomain are not instrumented.
</span>        <span class="enscript-comment">// Only IORootParent currently falls under that group.
</span>
        <span class="enscript-keyword">if</span> (notifier)
        {
            LOG(<span class="enscript-string">&quot;%s handler %p took %u ms\n&quot;</span>,
                ctx-&gt;LogString, OBFUSCATE(notifier-&gt;handler), deltaTime);
        }
    }

    ctx-&gt;Counter++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">quiescePowerTreeCallback</span>( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * param )
{
    IOLockLock(gPMHaltLock);
    gPMQuiesced = true;
    thread_wakeup(param);
    IOLockUnlock(gPMHaltLock);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handlePlatformHaltRestart</span>( UInt32 pe_type )
{
    HaltRestartApplierContext   ctx;
    AbsoluteTime                startTime;
    uint32_t                    deltaTime;

    memset(&amp;ctx, 0, <span class="enscript-keyword">sizeof</span>(ctx));
    ctx.RootDomain = <span class="enscript-keyword">this</span>;

    clock_get_uptime(&amp;startTime);
    <span class="enscript-keyword">switch</span> (pe_type)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPEHaltCPU</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPEUPSDelayHaltCPU</span>:
            ctx.PowerState  = OFF_STATE;
            ctx.MessageType = kIOMessageSystemWillPowerOff;
            ctx.LogString   = <span class="enscript-string">&quot;PowerOff&quot;</span>;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPERestartCPU</span>:
            ctx.PowerState  = RESTART_STATE;
            ctx.MessageType = kIOMessageSystemWillRestart;
            ctx.LogString   = <span class="enscript-string">&quot;Restart&quot;</span>;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPEPagingOff</span>:
            ctx.PowerState  = ON_STATE;
            ctx.MessageType = kIOMessageSystemPagingOff;
            ctx.LogString   = <span class="enscript-string">&quot;PagingOff&quot;</span>;
            <span class="enscript-reference">IOService</span>::updateConsoleUsers(NULL, kIOMessageSystemPagingOff);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
            IOHibernateSystemRestart();
#<span class="enscript-reference">endif</span>
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Notify legacy clients
</span>    applyToInterested(gIOPriorityPowerStateInterest, platformHaltRestartApplier, &amp;ctx);

    <span class="enscript-comment">// For normal shutdown, turn off File Server Mode.
</span>    <span class="enscript-keyword">if</span> (kPEHaltCPU == pe_type)
    {
        <span class="enscript-type">const</span> OSSymbol * setting = OSSymbol::withCString(kIOPMSettingRestartOnPowerLossKey);
        OSNumber * num = OSNumber::withNumber((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">long</span>) 0, 32);
        <span class="enscript-keyword">if</span> (setting &amp;&amp; num)
        {
            setPMSetting(setting, num);
            setting-&gt;release();
            num-&gt;release();
        }
    }

    <span class="enscript-keyword">if</span> (kPEPagingOff != pe_type)
    {
        <span class="enscript-comment">// Notify in power tree order
</span>        notifySystemShutdown(<span class="enscript-keyword">this</span>, ctx.MessageType);
    }

    IOCPURunPlatformHaltRestartActions(pe_type);

    <span class="enscript-comment">// Wait for PM to quiesce
</span>    <span class="enscript-keyword">if</span> ((kPEPagingOff != pe_type) &amp;&amp; gPMHaltLock)
    {
        AbsoluteTime quiesceTime = mach_absolute_time();

        IOLockLock(gPMHaltLock);
        gPMQuiesced = false;
        <span class="enscript-keyword">if</span> (quiescePowerTree(<span class="enscript-keyword">this</span>, &amp;quiescePowerTreeCallback, &amp;gPMQuiesced) ==
            kIOReturnSuccess)
        {
            <span class="enscript-keyword">while</span> (!gPMQuiesced)
            {
                IOLockSleep(gPMHaltLock, &amp;gPMQuiesced, THREAD_UNINT);
            }
        }
        IOLockUnlock(gPMHaltLock);

        deltaTime = computeDeltaTimeMS(&amp;quiesceTime);
        DLOG(<span class="enscript-string">&quot;PM quiesce took %u ms\n&quot;</span>, deltaTime);
    }

    deltaTime = computeDeltaTimeMS(&amp;startTime);
    LOG(<span class="enscript-string">&quot;%s all drivers took %u ms\n&quot;</span>, ctx.LogString, deltaTime);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// shutdownSystem
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::shutdownSystem</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// restartSystem
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::restartSystem</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: System Capability
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// tagPowerPlaneService
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Running on PM work loop thread.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::tagPowerPlaneService</span>(
        IOService *     service,
        IOPMActions *   actions )
{
    uint32_t    flags = 0;
    <span class="enscript-type">bool</span>        isDisplayWrangler;

    memset(actions, 0, <span class="enscript-keyword">sizeof</span>(*actions));
    actions-&gt;target = <span class="enscript-keyword">this</span>;

    <span class="enscript-keyword">if</span> (service == <span class="enscript-keyword">this</span>)
    {
        actions-&gt;actionPowerChangeStart =
            OSMemberFunctionCast(
                IOPMActionPowerChangeStart, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::handleOurPowerChangeStart);

        actions-&gt;actionPowerChangeDone =
            OSMemberFunctionCast(
                IOPMActionPowerChangeDone, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::handleOurPowerChangeDone);

        actions-&gt;actionPowerChangeOverride =
            OSMemberFunctionCast(
                IOPMActionPowerChangeOverride, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::overrideOurPowerChange);
        <span class="enscript-keyword">return</span>;
    }

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    isDisplayWrangler = (0 != service-&gt;metaCast(<span class="enscript-string">&quot;IODisplayWrangler&quot;</span>));
    <span class="enscript-keyword">if</span> (isDisplayWrangler)
    {
        wrangler = service;
    }
#<span class="enscript-reference">else</span>
    isDisplayWrangler = false;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-keyword">if</span> (isDisplayWrangler)
        flags |= kPMActionsFlagIsDisplayWrangler;
    <span class="enscript-keyword">if</span> (service-&gt;getProperty(<span class="enscript-string">&quot;IOPMStrictTreeOrder&quot;</span>))
        flags |= kPMActionsFlagIsGraphicsDevice;
    <span class="enscript-keyword">if</span> (service-&gt;getProperty(<span class="enscript-string">&quot;IOPMUnattendedWakePowerState&quot;</span>))
        flags |= kPMActionsFlagIsAudioDevice;
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">// Find the power connection object that is a child of the PCI host
</span>    <span class="enscript-comment">// bridge, and has a graphics/audio device attached below. Mark the
</span>    <span class="enscript-comment">// power branch for delayed child notifications.
</span>
    <span class="enscript-keyword">if</span> (flags)
    {
        IORegistryEntry * child  = service;
        IORegistryEntry * parent = child-&gt;getParentEntry(gIOPowerPlane);

        <span class="enscript-keyword">while</span> (child != <span class="enscript-keyword">this</span>)
        {
            <span class="enscript-keyword">if</span> ((parent == pciHostBridgeDriver) ||
                (parent == <span class="enscript-keyword">this</span>))
            {
                <span class="enscript-keyword">if</span> (OSDynamicCast(IOPowerConnection, child))
                {
                    IOPowerConnection * conn = (IOPowerConnection *) child;
                    conn-&gt;delayChildNotification = true;
                }
                <span class="enscript-keyword">break</span>;
            }
            child = parent;
            parent = child-&gt;getParentEntry(gIOPowerPlane);
        }
    }

    <span class="enscript-keyword">if</span> (flags)
    {
        DLOG(<span class="enscript-string">&quot;%s tag flags %x\n&quot;</span>, service-&gt;getName(), flags);
        actions-&gt;parameter |= flags;
        actions-&gt;actionPowerChangeOverride =
            OSMemberFunctionCast(
                IOPMActionPowerChangeOverride, <span class="enscript-keyword">this</span>,
                &amp;IOPMrootDomain::overridePowerChangeForUIService);

        <span class="enscript-keyword">if</span> (flags &amp; kPMActionsFlagIsDisplayWrangler)
        {
            actions-&gt;actionActivityTickle =
                OSMemberFunctionCast(
                    IOPMActionActivityTickle, <span class="enscript-keyword">this</span>,
                    &amp;IOPMrootDomain::handleActivityTickleForDisplayWrangler);

            actions-&gt;actionUpdatePowerClient =
                OSMemberFunctionCast(
                    IOPMActionUpdatePowerClient, <span class="enscript-keyword">this</span>,
                    &amp;IOPMrootDomain::handleUpdatePowerClientForDisplayWrangler);
        }
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Locate the first PCI host bridge for PMTrace.
</span>    <span class="enscript-keyword">if</span> (!pciHostBridgeDevice &amp;&amp; service-&gt;metaCast(<span class="enscript-string">&quot;IOPCIBridge&quot;</span>))
    {
        IOService * provider = service-&gt;getProvider();
        <span class="enscript-keyword">if</span> (OSDynamicCast(IOPlatformDevice, provider) &amp;&amp;
            provider-&gt;inPlane(gIODTPlane))
        {
            pciHostBridgeDevice = provider;
            pciHostBridgeDriver = service;
            DLOG(<span class="enscript-string">&quot;PMTrace found PCI host bridge %s-&gt;%s\n&quot;</span>,
                provider-&gt;getName(), service-&gt;getName());
        }
    }

    <span class="enscript-comment">// Tag top-level PCI devices. The order of PMinit() call does not
</span>    <span class="enscript-comment">// change across boots and is used as the PCI bit number.
</span>    <span class="enscript-keyword">if</span> (pciHostBridgeDevice &amp;&amp; service-&gt;metaCast(<span class="enscript-string">&quot;IOPCIDevice&quot;</span>))
    {
        <span class="enscript-comment">// Would prefer to check built-in property, but tagPowerPlaneService()
</span>        <span class="enscript-comment">// is called before pciDevice-&gt;registerService().
</span>        IORegistryEntry * parent = service-&gt;getParentEntry(gIODTPlane);
        <span class="enscript-keyword">if</span> ((parent == pciHostBridgeDevice) &amp;&amp; service-&gt;getProperty(<span class="enscript-string">&quot;acpi-device&quot;</span>))
        {
            <span class="enscript-type">int</span> bit = pmTracer-&gt;recordTopLevelPCIDevice( service );
            <span class="enscript-keyword">if</span> (bit &gt;= 0)
            {
                <span class="enscript-comment">// Save the assigned bit for fast lookup.
</span>                actions-&gt;parameter |= (bit &amp; kPMActionsPCIBitNumberMask);

                actions-&gt;actionPowerChangeStart =
                    OSMemberFunctionCast(
                        IOPMActionPowerChangeStart, <span class="enscript-keyword">this</span>,
                        &amp;IOPMrootDomain::handlePowerChangeStartForPCIDevice);

                actions-&gt;actionPowerChangeDone =
                    OSMemberFunctionCast(
                        IOPMActionPowerChangeDone, <span class="enscript-keyword">this</span>,
                        &amp;IOPMrootDomain::handlePowerChangeDoneForPCIDevice);
            }
        }
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// PM actions for root domain
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::overrideOurPowerChange</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex *   inOutPowerState,
    IOPMPowerChangeFlags *  inOutChangeFlags,
    IOPMRequestTag          requestTag )
{
    uint32_t powerState  = (uint32_t) *inOutPowerState;
    uint32_t changeFlags = *inOutChangeFlags;
    uint32_t currentPowerState = (uint32_t) getPowerState();

    <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMParentInitiated)
    {
        <span class="enscript-comment">// Root parent is permanently pegged at max power,
</span>        <span class="enscript-comment">// a parent initiated power change is unexpected.
</span>        *inOutChangeFlags |= kIOPMNotDone;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (powerState &lt; currentPowerState)
    {
        <span class="enscript-keyword">if</span> (CAP_CURRENT(kIOPMSystemCapabilityGraphics))
        {
            <span class="enscript-comment">// Root domain is dropping power state ON-&gt;SLEEP.
</span>            <span class="enscript-comment">// If system is in full wake, first enter dark wake by
</span>            <span class="enscript-comment">// converting the power drop to a capability change.
</span>            <span class="enscript-comment">// Once in dark wake, transition to sleep state ASAP.
</span>
            darkWakeToSleepASAP = true;

            <span class="enscript-comment">// Drop graphics and audio capability
</span>            _desiredCapability &amp;= ~(
                kIOPMSystemCapabilityGraphics |
                kIOPMSystemCapabilityAudio    );

            <span class="enscript-comment">// Convert to capability change (ON-&gt;ON)
</span>            *inOutPowerState = ON_STATE;
            *inOutChangeFlags |= kIOPMSynchronize;

            <span class="enscript-comment">// Revert device desire from SLEEP to ON
</span>            changePowerStateToPriv(ON_STATE);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// System is in dark wake, ok to drop power state.
</span>            <span class="enscript-comment">// Broadcast root powering down to entire tree.
</span>            *inOutChangeFlags |= kIOPMRootChangeDown;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (powerState &gt; currentPowerState)
    {
        <span class="enscript-keyword">if</span> ((_currentCapability &amp; kIOPMSystemCapabilityCPU) == 0)
        {
            <span class="enscript-comment">// Broadcast power up when waking from sleep, but not for the
</span>            <span class="enscript-comment">// initial power change at boot by checking for cpu capability.
</span>            *inOutChangeFlags |= kIOPMRootChangeUp;
        }
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleOurPowerChangeStart</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex     powerState,
    IOPMPowerChangeFlags *  inOutChangeFlags,
    IOPMRequestTag          requestTag )
{
    uint32_t changeFlags        = *inOutChangeFlags;
    uint32_t currentPowerState  = (uint32_t) getPowerState();
    uint32_t sleepReason        = requestTag ? requestTag : kIOPMSleepReasonIdle;
    <span class="enscript-type">bool</span>     publishSleepReason = false;

    _systemTransitionType    = kSystemTransitionNone;
    _systemMessageClientMask = 0;
    capabilityLoss           = false;
    toldPowerdCapWillChange  = false;

    <span class="enscript-keyword">if</span> (lowBatteryCondition)
    {
        <span class="enscript-comment">// Low battery notification may arrive after the initial sleep request
</span>        <span class="enscript-comment">// has been queued. Override the sleep reason so powerd and others can
</span>        <span class="enscript-comment">// treat this as an emergency sleep.
</span>        sleepReason = kIOPMSleepReasonLowPower;
    }

    <span class="enscript-comment">// 1. Explicit capability change.
</span>
    <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMSynchronize)
    {
        <span class="enscript-keyword">if</span> (powerState == ON_STATE)
        {
            <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMSyncNoChildNotify)
                _systemTransitionType = kSystemTransitionNewCapClient;
            <span class="enscript-keyword">else</span>
                _systemTransitionType = kSystemTransitionCapability;
        }
    }

    <span class="enscript-comment">// 2. Going to sleep (cancellation still possible).
</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (powerState &lt; currentPowerState)
        _systemTransitionType = kSystemTransitionSleep;

    <span class="enscript-comment">// 3. Woke from (idle or demand) sleep.
</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!systemBooting &amp;&amp;
             (changeFlags &amp; kIOPMSelfInitiated) &amp;&amp;
             (powerState &gt; currentPowerState))
    {
        _systemTransitionType = kSystemTransitionWake;
        _desiredCapability = kIOPMSystemCapabilityCPU |
                             kIOPMSystemCapabilityNetwork;

        <span class="enscript-comment">// Early exit from dark wake to full (e.g. LID open)
</span>        <span class="enscript-keyword">if</span> (kFullWakeReasonNone != fullWakeReason)
        {
            _desiredCapability |= (
                kIOPMSystemCapabilityGraphics |
                kIOPMSystemCapabilityAudio );
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    IOHibernateSetWakeCapabilities(_desiredCapability);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-comment">// Update pending wake capability at the beginning of every
</span>    <span class="enscript-comment">// state transition (including synchronize). This will become
</span>    <span class="enscript-comment">// the current capability at the end of the transition.
</span>
    <span class="enscript-keyword">if</span> (kSystemTransitionSleep == _systemTransitionType)
    {
        _pendingCapability = 0;
        capabilityLoss = true;

        <span class="enscript-comment">// Clear previous stats
</span>        IOLockLock(pmStatsLock);
        <span class="enscript-keyword">if</span> (pmStatsAppResponses)
        {
            pmStatsAppResponses-&gt;release();
            pmStatsAppResponses = OSArray::withCapacity(5);
        }
        IOLockUnlock(pmStatsLock);

    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kSystemTransitionNewCapClient != _systemTransitionType)
    {
        _pendingCapability = _desiredCapability |
                             kIOPMSystemCapabilityCPU |
                             kIOPMSystemCapabilityNetwork;

        <span class="enscript-keyword">if</span> (_pendingCapability &amp; kIOPMSystemCapabilityGraphics)
            _pendingCapability |= kIOPMSystemCapabilityAudio;

        <span class="enscript-keyword">if</span> ((kSystemTransitionCapability == _systemTransitionType) &amp;&amp;
            (_pendingCapability == _currentCapability))
        {
            <span class="enscript-comment">// Cancel the PM state change.
</span>            _systemTransitionType = kSystemTransitionNone;
            *inOutChangeFlags |= kIOPMNotDone;
        }
        <span class="enscript-keyword">if</span> (__builtin_popcount(_pendingCapability) &lt;
            __builtin_popcount(_currentCapability))
            capabilityLoss = true;
    }

    <span class="enscript-comment">// 1. Capability change.
</span>
    <span class="enscript-keyword">if</span> (kSystemTransitionCapability == _systemTransitionType)
    {
        <span class="enscript-comment">// Dark to Full transition.
</span>        <span class="enscript-keyword">if</span> (CAP_GAIN(kIOPMSystemCapabilityGraphics))
        {
            tracePoint( kIOPMTracePointDarkWakeExit );

            willEnterFullWake();
        }

        <span class="enscript-comment">// Full to Dark transition.
</span>        <span class="enscript-keyword">if</span> (CAP_LOSS(kIOPMSystemCapabilityGraphics))
        {
            tracePoint( kIOPMTracePointDarkWakeEntry );
            *inOutChangeFlags |= kIOPMSyncTellPowerDown;
            _systemMessageClientMask = kSystemMessageClientPowerd |
                                       kSystemMessageClientLegacyApp;


            <span class="enscript-comment">// rdar://15971327
</span>            <span class="enscript-comment">// Prevent user active transitions before notifying clients
</span>            <span class="enscript-comment">// that system will sleep.
</span>            preventTransitionToUserActive(true);

            <span class="enscript-reference">IOService</span>::setAdvisoryTickleEnable( false );

            <span class="enscript-comment">// Publish the sleep reason for full to dark wake
</span>            publishSleepReason = true;
            lastSleepReason = fullToDarkReason = sleepReason;

            <span class="enscript-comment">// Publish a UUID for the Sleep --&gt; Wake cycle
</span>            handlePublishSleepWakeUUID(true);
            <span class="enscript-keyword">if</span> (sleepDelaysReport) {
                clock_get_uptime(&amp;ts_sleepStart);
                DLOG(<span class="enscript-string">&quot;sleepDelaysReport f-&gt;9 start at 0x%llx\n&quot;</span>, ts_sleepStart);
            }
        }
    }

    <span class="enscript-comment">// 2. System sleep.
</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kSystemTransitionSleep == _systemTransitionType)
    {
        <span class="enscript-comment">// Beginning of a system sleep transition.
</span>        <span class="enscript-comment">// Cancellation is still possible.
</span>        tracePoint( kIOPMTracePointSleepStarted, sleepReason );

        _systemMessageClientMask = kSystemMessageClientAll;
        <span class="enscript-keyword">if</span> ((_currentCapability &amp; kIOPMSystemCapabilityGraphics) == 0)
            _systemMessageClientMask &amp;= ~kSystemMessageClientLegacyApp;
        <span class="enscript-keyword">if</span> ((_highestCapability &amp; kIOPMSystemCapabilityGraphics) == 0)
            _systemMessageClientMask &amp;= ~kSystemMessageClientKernel;

        <span class="enscript-comment">// Record the reason for dark wake back to sleep
</span>        <span class="enscript-comment">// System may not have ever achieved full wake
</span>
        publishSleepReason = true;
        lastSleepReason = sleepReason;
        <span class="enscript-keyword">if</span> (sleepDelaysReport) {
            clock_get_uptime(&amp;ts_sleepStart);
                DLOG(<span class="enscript-string">&quot;sleepDelaysReport 9-&gt;0 start at 0x%llx\n&quot;</span>, ts_sleepStart);
        }
    }

    <span class="enscript-comment">// 3. System wake.
</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kSystemTransitionWake == _systemTransitionType)
    {
        tracePoint( kIOPMTracePointWakeWillPowerOnClients );
        <span class="enscript-comment">// Clear stats about sleep 
</span>
        <span class="enscript-keyword">if</span> (_pendingCapability &amp; kIOPMSystemCapabilityGraphics)
        {
            willEnterFullWake();
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Message powerd only
</span>            _systemMessageClientMask = kSystemMessageClientPowerd;
            tellClients(kIOMessageSystemWillPowerOn);
        }
    }

    <span class="enscript-comment">// The only location where the sleep reason is published. At this point
</span>    <span class="enscript-comment">// sleep can still be cancelled, but sleep reason should be published
</span>    <span class="enscript-comment">// early for logging purposes.
</span>
    <span class="enscript-keyword">if</span> (publishSleepReason)
    {
        <span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * IOPMSleepReasons[] =
        {
            kIOPMClamshellSleepKey,
            kIOPMPowerButtonSleepKey,
            kIOPMSoftwareSleepKey,
            kIOPMOSSwitchHibernationKey,
            kIOPMIdleSleepKey,
            kIOPMLowPowerSleepKey,
            kIOPMThermalEmergencySleepKey,
            kIOPMMaintenanceSleepKey,
            kIOPMSleepServiceExitKey,
            kIOPMDarkWakeThermalEmergencyKey
        };

        <span class="enscript-comment">// Record sleep cause in IORegistry
</span>        uint32_t reasonIndex = sleepReason - kIOPMSleepReasonClamshell;
        <span class="enscript-keyword">if</span> (reasonIndex &lt; <span class="enscript-keyword">sizeof</span>(IOPMSleepReasons)/<span class="enscript-keyword">sizeof</span>(IOPMSleepReasons[0])) {
            DLOG(<span class="enscript-string">&quot;sleep reason %s\n&quot;</span>, IOPMSleepReasons[reasonIndex]);
            setProperty(kRootDomainSleepReasonKey, IOPMSleepReasons[reasonIndex]);
        }
    }

    <span class="enscript-keyword">if</span> ((kSystemTransitionNone != _systemTransitionType) &amp;&amp;
        (kSystemTransitionNewCapClient != _systemTransitionType))
    {
        _systemStateGeneration++;
        systemDarkWake = false;

        DLOG(<span class="enscript-string">&quot;=== START (%u-&gt;%u, 0x%x) type %u, gen %u, msg %x, &quot;</span>
             <span class="enscript-string">&quot;dcp %x:%x:%x\n&quot;</span>,
            currentPowerState, (uint32_t) powerState, *inOutChangeFlags,
            _systemTransitionType, _systemStateGeneration,
            _systemMessageClientMask,
            _desiredCapability, _currentCapability, _pendingCapability);
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleOurPowerChangeDone</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex     powerState,
    IOPMPowerChangeFlags    changeFlags,
    IOPMRequestTag          requestTag __unused )
{
    <span class="enscript-keyword">if</span> (kSystemTransitionNewCapClient == _systemTransitionType)
    {
        _systemTransitionType = kSystemTransitionNone;
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-keyword">if</span> (_systemTransitionType != kSystemTransitionNone)
    {
        uint32_t currentPowerState = (uint32_t) getPowerState();

        <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMNotDone)
        {
            <span class="enscript-comment">// Power down was cancelled or vetoed.
</span>            _pendingCapability = _currentCapability;
            lastSleepReason = 0;

            <span class="enscript-keyword">if</span> (!CAP_CURRENT(kIOPMSystemCapabilityGraphics) &amp;&amp;
                 CAP_CURRENT(kIOPMSystemCapabilityCPU))
            {
                pmPowerStateQueue-&gt;submitPowerEvent(
                    kPowerEventPolicyStimulus,
                    (<span class="enscript-type">void</span> *) kStimulusDarkWakeReentry,
                    _systemStateGeneration );
            }

            <span class="enscript-comment">// Revert device desire to max.
</span>            changePowerStateToPriv(ON_STATE);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Send message on dark wake to full wake promotion.
</span>            <span class="enscript-comment">// tellChangeUp() handles the normal SLEEP-&gt;ON case.
</span>
            <span class="enscript-keyword">if</span> (kSystemTransitionCapability == _systemTransitionType)
            {
                <span class="enscript-keyword">if</span> (CAP_GAIN(kIOPMSystemCapabilityGraphics))
                {
                    lastSleepReason = 0; <span class="enscript-comment">// stop logging wrangler tickles
</span>                    tellClients(kIOMessageSystemHasPoweredOn);
                }
                <span class="enscript-keyword">if</span> (CAP_LOSS(kIOPMSystemCapabilityGraphics))
                {
                    <span class="enscript-comment">// Going dark, reset full wake state
</span>                    <span class="enscript-comment">// userIsActive will be cleared by wrangler powering down
</span>                    wranglerTickled = false;
                    fullWakeReason = kFullWakeReasonNone;

                    <span class="enscript-keyword">if</span> (ts_sleepStart) {
                        clock_get_uptime(&amp;wake2DarkwakeDelay);
                        SUB_ABSOLUTETIME(&amp;wake2DarkwakeDelay, &amp;ts_sleepStart);
                        DLOG(<span class="enscript-string">&quot;sleepDelaysReport f-&gt;9 end 0x%llx\n&quot;</span>, wake2DarkwakeDelay);
                        ts_sleepStart = 0;
                    }
                }
            }

            <span class="enscript-comment">// Reset state after exiting from dark wake.
</span>
            <span class="enscript-keyword">if</span> (CAP_GAIN(kIOPMSystemCapabilityGraphics) ||
                CAP_LOSS(kIOPMSystemCapabilityCPU))
            {
                darkWakeMaintenance = false;
                darkWakeToSleepASAP = false;
                pciCantSleepValid   = false;
                darkWakeSleepService = false;

                <span class="enscript-keyword">if</span> (CAP_LOSS(kIOPMSystemCapabilityCPU))
                {
                    <span class="enscript-comment">// Remove the influence of display power assertion
</span>                    <span class="enscript-comment">// before next system wake.
</span>                    <span class="enscript-keyword">if</span> (wrangler) wrangler-&gt;changePowerStateForRootDomain(
                                                kWranglerPowerStateMin );
                    removeProperty(gIOPMUserTriggeredFullWakeKey);
                }
            }

            <span class="enscript-comment">// Entered dark mode.
</span>
            <span class="enscript-keyword">if</span> (((_pendingCapability &amp; kIOPMSystemCapabilityGraphics) == 0) &amp;&amp;
                 (_pendingCapability &amp; kIOPMSystemCapabilityCPU))
            {
                <span class="enscript-comment">// Queue an evaluation of whether to remain in dark wake,
</span>                <span class="enscript-comment">// and for how long. This serves the purpose of draining
</span>                <span class="enscript-comment">// any assertions from the queue.
</span>
                pmPowerStateQueue-&gt;submitPowerEvent(
                    kPowerEventPolicyStimulus,
                    (<span class="enscript-type">void</span> *) kStimulusDarkWakeEntry,
                    _systemStateGeneration );
            }
        }

        DLOG(<span class="enscript-string">&quot;=== FINISH (%u-&gt;%u, 0x%x) type %u, gen %u, msg %x, &quot;</span>
             <span class="enscript-string">&quot;dcp %x:%x:%x, dbgtimer %u\n&quot;</span>,
            currentPowerState, (uint32_t) powerState, changeFlags,
            _systemTransitionType, _systemStateGeneration,
            _systemMessageClientMask,
            _desiredCapability, _currentCapability, _pendingCapability,
            _lastDebugWakeSeconds);

        <span class="enscript-keyword">if</span> (_pendingCapability &amp; kIOPMSystemCapabilityGraphics)
        {
            displayWakeCnt++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DARK_TO_FULL_EVALUATE_CLAMSHELL</span>
            <span class="enscript-keyword">if</span> (clamshellExists &amp;&amp; fullWakeThreadCall &amp;&amp;
                CAP_HIGHEST(kIOPMSystemCapabilityGraphics))
            {
                <span class="enscript-comment">// Not the initial graphics full power, graphics won't
</span>                <span class="enscript-comment">// send a power notification to trigger a lid state
</span>                <span class="enscript-comment">// evaluation.
</span>
                AbsoluteTime deadline;
                clock_interval_to_deadline(45, kSecondScale, &amp;deadline);
                thread_call_enter_delayed(fullWakeThreadCall, deadline);
            }
#<span class="enscript-reference">endif</span>
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CAP_GAIN(kIOPMSystemCapabilityCPU))
            darkWakeCnt++;

        <span class="enscript-comment">// Update current system capability.
</span>        <span class="enscript-keyword">if</span> (_currentCapability != _pendingCapability)
            _currentCapability = _pendingCapability;

        <span class="enscript-comment">// Update highest system capability.
</span>
        _highestCapability |= _currentCapability;

        <span class="enscript-keyword">if</span> (darkWakePostTickle &amp;&amp;
            (kSystemTransitionWake == _systemTransitionType) &amp;&amp;
            (gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) ==
             kDarkWakeFlagHIDTickleLate)
        {
            darkWakePostTickle = false;
            reportUserInput();
        }

        <span class="enscript-comment">// Reset tracepoint at completion of capability change,
</span>        <span class="enscript-comment">// completion of wake transition, and aborted sleep transition.
</span>
        <span class="enscript-keyword">if</span> ((_systemTransitionType == kSystemTransitionCapability) ||
            (_systemTransitionType == kSystemTransitionWake) ||
            ((_systemTransitionType == kSystemTransitionSleep) &amp;&amp;
             (changeFlags &amp; kIOPMNotDone)))
        {
            setProperty(kIOPMSystemCapabilitiesKey, _currentCapability, 64);
            tracePoint( kIOPMTracePointSystemUp, 0 );
        }

        _systemTransitionType = kSystemTransitionNone;
        _systemMessageClientMask = 0;
        toldPowerdCapWillChange  = false;

        logGraphicsClamp = false;
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// PM actions for graphics and audio.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::overridePowerChangeForUIService</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex *   inOutPowerState,
    IOPMPowerChangeFlags *  inOutChangeFlags )
{
    uint32_t powerState  = (uint32_t) *inOutPowerState;
    uint32_t changeFlags = (uint32_t) *inOutChangeFlags;

    <span class="enscript-keyword">if</span> (kSystemTransitionNone == _systemTransitionType)
    {
        <span class="enscript-comment">// Not in midst of a system transition.
</span>        <span class="enscript-comment">// Do not modify power limit enable state.
</span>    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagLimitPower) == 0)
    {
        <span class="enscript-comment">// Activate power limiter.
</span>
        <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagIsDisplayWrangler) &amp;&amp;
            ((_pendingCapability &amp; kIOPMSystemCapabilityGraphics) == 0) &amp;&amp;
            (changeFlags &amp; kIOPMSynchronize))
        {
            actions-&gt;parameter |= kPMActionsFlagLimitPower;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagIsAudioDevice) &amp;&amp;
                 ((gDarkWakeFlags &amp; kDarkWakeFlagAudioNotSuppressed) == 0) &amp;&amp;
                 ((_pendingCapability &amp; kIOPMSystemCapabilityAudio) == 0) &amp;&amp;
                 (changeFlags &amp; kIOPMSynchronize))
        {
            actions-&gt;parameter |= kPMActionsFlagLimitPower;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagIsGraphicsDevice) &amp;&amp;
                 (_systemTransitionType == kSystemTransitionSleep))
        {
            <span class="enscript-comment">// For graphics devices, arm the limiter when entering
</span>            <span class="enscript-comment">// system sleep. Not when dropping to dark wake.
</span>            actions-&gt;parameter |= kPMActionsFlagLimitPower;
        }

        <span class="enscript-keyword">if</span> (actions-&gt;parameter &amp; kPMActionsFlagLimitPower)
        {
            DLOG(<span class="enscript-string">&quot;+ plimit %s %p\n&quot;</span>,
                service-&gt;getName(), OBFUSCATE(service));
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Remove power limit.
</span>
        <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; (
            kPMActionsFlagIsDisplayWrangler |
            kPMActionsFlagIsGraphicsDevice )) &amp;&amp;
            (_pendingCapability &amp; kIOPMSystemCapabilityGraphics))
        {
            actions-&gt;parameter &amp;= ~kPMActionsFlagLimitPower;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagIsAudioDevice) &amp;&amp;
                 (_pendingCapability &amp; kIOPMSystemCapabilityAudio))
        {
            actions-&gt;parameter &amp;= ~kPMActionsFlagLimitPower;
        }

        <span class="enscript-keyword">if</span> ((actions-&gt;parameter &amp; kPMActionsFlagLimitPower) == 0)
        {
            DLOG(<span class="enscript-string">&quot;- plimit %s %p\n&quot;</span>,
                service-&gt;getName(), OBFUSCATE(service));
        }
    }

    <span class="enscript-keyword">if</span> (actions-&gt;parameter &amp; kPMActionsFlagLimitPower)
    {
        uint32_t maxPowerState = (uint32_t)(-1);

        <span class="enscript-keyword">if</span> (changeFlags &amp; (kIOPMDomainDidChange | kIOPMDomainWillChange))
        {
            <span class="enscript-comment">// Enforce limit for system power/cap transitions.
</span>
            maxPowerState = 0;
            <span class="enscript-keyword">if</span> ((service-&gt;getPowerState() &gt; maxPowerState) &amp;&amp;
                (actions-&gt;parameter &amp; kPMActionsFlagIsDisplayWrangler))
            {
                maxPowerState++;

                <span class="enscript-comment">// Remove lingering effects of any tickle before entering
</span>                <span class="enscript-comment">// dark wake. It will take a new tickle to return to full
</span>                <span class="enscript-comment">// wake, so the existing tickle state is useless.
</span>
                <span class="enscript-keyword">if</span> (changeFlags &amp; kIOPMDomainDidChange)
                    *inOutChangeFlags |= kIOPMExpireIdleTimer;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (actions-&gt;parameter &amp; kPMActionsFlagIsGraphicsDevice)
            {
                maxPowerState++;
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Deny all self-initiated changes when power is limited.
</span>            <span class="enscript-comment">// Wrangler tickle should never defeat the limiter.
</span>
            maxPowerState = service-&gt;getPowerState();
        }

        <span class="enscript-keyword">if</span> (powerState &gt; maxPowerState)
        {
            DLOG(<span class="enscript-string">&quot;&gt; plimit %s %p (%u-&gt;%u, 0x%x)\n&quot;</span>,
                service-&gt;getName(), OBFUSCATE(service), powerState, maxPowerState,
                changeFlags);
            *inOutPowerState = maxPowerState;

            <span class="enscript-keyword">if</span> (darkWakePostTickle &amp;&amp;
                (actions-&gt;parameter &amp; kPMActionsFlagIsDisplayWrangler) &amp;&amp;
                (changeFlags &amp; kIOPMDomainWillChange) &amp;&amp;
                ((gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) ==
                 kDarkWakeFlagHIDTickleEarly))
            {
                darkWakePostTickle = false;
                reportUserInput();
            }
        }

        <span class="enscript-keyword">if</span> (!graphicsSuppressed &amp;&amp; (changeFlags &amp; kIOPMDomainDidChange))
        {
            <span class="enscript-keyword">if</span> (logGraphicsClamp)
            {
                AbsoluteTime    now;
                uint64_t        nsec;

                clock_get_uptime(&amp;now);
                SUB_ABSOLUTETIME(&amp;now, &amp;systemWakeTime);
                absolutetime_to_nanoseconds(now, &amp;nsec);
                <span class="enscript-keyword">if</span> (kIOLogPMRootDomain &amp; gIOKitDebug)
                    MSG(<span class="enscript-string">&quot;Graphics suppressed %u ms\n&quot;</span>,
                        ((<span class="enscript-type">int</span>)((nsec) / 1000000ULL)));
            }
            graphicsSuppressed = true;
        }
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleActivityTickleForDisplayWrangler</span>(
    IOService *     service,
    IOPMActions *   actions )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-comment">// Warning: Not running in PM work loop context - don't modify state !!!
</span>    <span class="enscript-comment">// Trap tickle directed to IODisplayWrangler while running with graphics
</span>    <span class="enscript-comment">// capability suppressed.
</span>
    assert(service == wrangler);

    clock_get_uptime(&amp;userActivityTime);
    <span class="enscript-type">bool</span> aborting = ((lastSleepReason == kIOPMSleepReasonIdle)
                  || (lastSleepReason == kIOPMSleepReasonMaintenance)
                  || (lastSleepReason == kIOPMSleepReasonSoftware));
    <span class="enscript-keyword">if</span> (aborting) {
        userActivityCount++;
        DLOG(<span class="enscript-string">&quot;display wrangler tickled1 %d lastSleepReason %d\n&quot;</span>,
            userActivityCount, lastSleepReason);
    }

    <span class="enscript-keyword">if</span> (!wranglerTickled &amp;&amp;
        ((_pendingCapability &amp; kIOPMSystemCapabilityGraphics) == 0))
    {
        DLOG(<span class="enscript-string">&quot;display wrangler tickled\n&quot;</span>);
        <span class="enscript-keyword">if</span> (kIOLogPMRootDomain &amp; gIOKitDebug)
            OSReportWithBacktrace(<span class="enscript-string">&quot;Dark wake display tickle&quot;</span>);
        <span class="enscript-keyword">if</span> (pmPowerStateQueue)
        {
            pmPowerStateQueue-&gt;submitPowerEvent(
                kPowerEventPolicyStimulus,
                (<span class="enscript-type">void</span> *) kStimulusDarkWakeActivityTickle,
                true <span class="enscript-comment">/* set wake type */</span> );
        }
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleUpdatePowerClientForDisplayWrangler</span>(
    IOService *             service,
    IOPMActions *           actions,
    <span class="enscript-type">const</span> OSSymbol *        powerClient,
    IOPMPowerStateIndex     oldPowerState,
    IOPMPowerStateIndex     newPowerState )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    assert(service == wrangler);

    <span class="enscript-comment">// This function implements half of the user active detection
</span>    <span class="enscript-comment">// by monitoring changes to the display wrangler's device desire.
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// User becomes active when either:
</span>    <span class="enscript-comment">// 1. Wrangler's DeviceDesire increases to max, but wrangler is already
</span>    <span class="enscript-comment">//    in max power state. This desire change in absence of a power state
</span>    <span class="enscript-comment">//    change is detected within. This handles the case when user becomes
</span>    <span class="enscript-comment">//    active while the display is already lit by setDisplayPowerOn().
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// 2. Power state change to max, and DeviceDesire is also at max.
</span>    <span class="enscript-comment">//    Handled by displayWranglerNotification().
</span>    <span class="enscript-comment">//
</span>    <span class="enscript-comment">// User becomes inactive when DeviceDesire drops to sleep state or below.
</span>
    DLOG(<span class="enscript-string">&quot;wrangler %s (ps %u, %u-&gt;%u)\n&quot;</span>,
        powerClient-&gt;getCStringNoCopy(),
        (uint32_t) service-&gt;getPowerState(),
        (uint32_t) oldPowerState, (uint32_t) newPowerState);

    <span class="enscript-keyword">if</span> (powerClient == gIOPMPowerClientDevice)
    {
        <span class="enscript-keyword">if</span> ((newPowerState &gt; oldPowerState) &amp;&amp;
            (newPowerState == kWranglerPowerStateMax) &amp;&amp;
            (service-&gt;getPowerState() == kWranglerPowerStateMax))
        {
            evaluatePolicy( kStimulusEnterUserActiveState );
        }
        <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">if</span> ((newPowerState &lt; oldPowerState) &amp;&amp;
            (newPowerState &lt;= kWranglerPowerStateSleep))
        {
            evaluatePolicy( kStimulusLeaveUserActiveState );
        }
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// User active state management
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::preventTransitionToUserActive</span>( <span class="enscript-type">bool</span> prevent )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    _preventUserActive = prevent;
    <span class="enscript-keyword">if</span> (wrangler &amp;&amp; !_preventUserActive)
    {
        <span class="enscript-comment">// Allowing transition to user active, but the wrangler may have
</span>        <span class="enscript-comment">// already powered ON in case of sleep cancel/revert. Poll the
</span>        <span class="enscript-comment">// same conditions checked for in displayWranglerNotification()
</span>        <span class="enscript-comment">// to bring the user active state up to date.
</span>
        <span class="enscript-keyword">if</span> ((wrangler-&gt;getPowerState() == kWranglerPowerStateMax) &amp;&amp;
            (wrangler-&gt;getPowerStateForClient(gIOPMPowerClientDevice) ==
             kWranglerPowerStateMax))
        {
            evaluatePolicy( kStimulusEnterUserActiveState );
        }
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// Approve usage of delayed child notification by PM.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::shouldDelayChildNotification</span>(
    IOService * service )
{
    <span class="enscript-keyword">if</span> (((gDarkWakeFlags &amp; kDarkWakeFlagHIDTickleMask) != 0) &amp;&amp;
        (kFullWakeReasonNone == fullWakeReason) &amp;&amp;
        (kSystemTransitionWake == _systemTransitionType))
    {
        DLOG(<span class="enscript-string">&quot;%s: delay child notify\n&quot;</span>, service-&gt;getName());
        <span class="enscript-keyword">return</span> true;
    }
    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// PM actions for PCI device.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handlePowerChangeStartForPCIDevice</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex     powerState,
    IOPMPowerChangeFlags *  inOutChangeFlags )
{
    pmTracer-&gt;tracePCIPowerChange(
        <span class="enscript-reference">PMTraceWorker</span>::kPowerChangeStart,
        service, *inOutChangeFlags,
        (actions-&gt;parameter &amp; kPMActionsPCIBitNumberMask));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handlePowerChangeDoneForPCIDevice</span>(
    IOService *             service,
    IOPMActions *           actions,
    IOPMPowerStateIndex     powerState,
    IOPMPowerChangeFlags    changeFlags )
{
    pmTracer-&gt;tracePCIPowerChange(
        <span class="enscript-reference">PMTraceWorker</span>::kPowerChangeCompleted,
        service, changeFlags,
        (actions-&gt;parameter &amp; kPMActionsPCIBitNumberMask));
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// registerInterest
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Override IOService::registerInterest() to intercept special clients.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">class</span> IOPMServiceInterestNotifier: <span class="enscript-type">public</span> _IOServiceInterestNotifier
{

    <span class="enscript-type">friend</span> <span class="enscript-type">class</span> IOPMrootDomain;
    OSDeclareDefaultStructors(IOPMServiceInterestNotifier)

<span class="enscript-type">protected</span>:
    uint32_t    ackTimeoutCnt;

};

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOPMServiceInterestNotifier, _IOServiceInterestNotifier)

IONotifier * <span class="enscript-function-name">IOPMrootDomain::registerInterest</span>(
                <span class="enscript-type">const</span> OSSymbol * typeOfInterest,
                IOServiceInterestHandler handler,
                <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref )
{
    IOPMServiceInterestNotifier *notifier = 0;
    <span class="enscript-type">bool</span>            isSystemCapabilityClient;
    <span class="enscript-type">bool</span>            isKernelCapabilityClient;
    IOReturn        rc = kIOReturnError;;

    isSystemCapabilityClient =
        typeOfInterest &amp;&amp;
        typeOfInterest-&gt;isEqualTo(kIOPMSystemCapabilityInterest);

    isKernelCapabilityClient =
        typeOfInterest &amp;&amp;
        typeOfInterest-&gt;isEqualTo(gIOPriorityPowerStateInterest);

    <span class="enscript-keyword">if</span> (isSystemCapabilityClient)
        typeOfInterest = gIOAppPowerStateInterest;

    notifier = <span class="enscript-keyword">new</span> IOPMServiceInterestNotifier;
    <span class="enscript-keyword">if</span> (!notifier) <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-keyword">if</span> (notifier-&gt;init()) {
        rc  = super::registerInterestForNotifer(notifier, typeOfInterest, handler, target, ref);
    }
    <span class="enscript-keyword">if</span> (rc != kIOReturnSuccess) {
        notifier-&gt;release();
        notifier = 0;
    }
    <span class="enscript-keyword">if</span> (pmPowerStateQueue)
    {
        notifier-&gt;ackTimeoutCnt = 0;
        <span class="enscript-keyword">if</span> (isSystemCapabilityClient)
        {
            notifier-&gt;retain();
            <span class="enscript-keyword">if</span> (pmPowerStateQueue-&gt;submitPowerEvent(
                kPowerEventRegisterSystemCapabilityClient, notifier) == false)
                notifier-&gt;release();
        }

        <span class="enscript-keyword">if</span> (isKernelCapabilityClient)
        {
            notifier-&gt;retain();
            <span class="enscript-keyword">if</span> (pmPowerStateQueue-&gt;submitPowerEvent(
                kPowerEventRegisterKernelCapabilityClient, notifier) == false)
                notifier-&gt;release();
        }
    }

    <span class="enscript-keyword">return</span> notifier;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// systemMessageFilter
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::systemMessageFilter</span>(
    <span class="enscript-type">void</span> * object, <span class="enscript-type">void</span> * arg1, <span class="enscript-type">void</span> * arg2, <span class="enscript-type">void</span> * arg3 )
{
    <span class="enscript-type">const</span> IOPMInterestContext * context = (<span class="enscript-type">const</span> IOPMInterestContext *) arg1;
    <span class="enscript-type">bool</span>  isCapMsg = (context-&gt;messageType == kIOMessageSystemCapabilityChange);
    <span class="enscript-type">bool</span>  isCapClient = false;
    <span class="enscript-type">bool</span>  allow = false;

    <span class="enscript-keyword">do</span> {
        <span class="enscript-keyword">if</span> ((kSystemTransitionNewCapClient == _systemTransitionType) &amp;&amp;
            (!isCapMsg || !_joinedCapabilityClients ||
             !_joinedCapabilityClients-&gt;containsObject((OSObject *) object)))
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Capability change message for app and kernel clients.
</span>
        <span class="enscript-keyword">if</span> (isCapMsg)
        {
            <span class="enscript-keyword">if</span> ((context-&gt;notifyType == kNotifyPriority) ||
                (context-&gt;notifyType == kNotifyCapabilityChangePriority))
                isCapClient = true;

            <span class="enscript-keyword">if</span> ((context-&gt;notifyType == kNotifyCapabilityChangeApps) &amp;&amp;
                (object == (<span class="enscript-type">void</span> *) systemCapabilityNotifier))
                isCapClient = true;
        }

        <span class="enscript-keyword">if</span> (isCapClient)
        {
            IOPMSystemCapabilityChangeParameters * capArgs =
                (IOPMSystemCapabilityChangeParameters *) arg2;

            <span class="enscript-keyword">if</span> (kSystemTransitionNewCapClient == _systemTransitionType)
            {
                capArgs-&gt;fromCapabilities = 0;
                capArgs-&gt;toCapabilities = _currentCapability;
                capArgs-&gt;changeFlags = 0;
            }
            <span class="enscript-keyword">else</span>
            {
                capArgs-&gt;fromCapabilities = _currentCapability;
                capArgs-&gt;toCapabilities = _pendingCapability;

                <span class="enscript-keyword">if</span> (context-&gt;isPreChange)
                    capArgs-&gt;changeFlags = kIOPMSystemCapabilityWillChange;
                <span class="enscript-keyword">else</span>
                    capArgs-&gt;changeFlags = kIOPMSystemCapabilityDidChange;

                <span class="enscript-keyword">if</span> ((object == (<span class="enscript-type">void</span> *) systemCapabilityNotifier) &amp;&amp;
                    context-&gt;isPreChange)
                {
                    toldPowerdCapWillChange = true;
                }
            }

            <span class="enscript-comment">// Capability change messages only go to the PM configd plugin.
</span>            <span class="enscript-comment">// Wait for response post-change if capabilitiy is increasing.
</span>            <span class="enscript-comment">// Wait for response pre-change if capability is decreasing.
</span>
            <span class="enscript-keyword">if</span> ((context-&gt;notifyType == kNotifyCapabilityChangeApps) &amp;&amp; arg3 &amp;&amp;
                ( (capabilityLoss &amp;&amp; context-&gt;isPreChange) ||
                  (!capabilityLoss &amp;&amp; !context-&gt;isPreChange) ) )
            {
                <span class="enscript-comment">// app has not replied yet, wait for it
</span>                *((OSObject **) arg3) = kOSBooleanFalse;
            }

            allow = true;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Capability client will always see kIOMessageCanSystemSleep,
</span>        <span class="enscript-comment">// even for demand sleep. It will also have a chance to veto
</span>        <span class="enscript-comment">// sleep one last time after all clients have responded to
</span>        <span class="enscript-comment">// kIOMessageSystemWillSleep
</span>
        <span class="enscript-keyword">if</span> ((kIOMessageCanSystemSleep == context-&gt;messageType) ||
            (kIOMessageSystemWillNotSleep == context-&gt;messageType))
        {
            <span class="enscript-keyword">if</span> (object == (OSObject *) systemCapabilityNotifier)
            {
                allow = true;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-comment">// Not idle sleep, don't ask apps.
</span>            <span class="enscript-keyword">if</span> (context-&gt;changeFlags &amp; kIOPMSkipAskPowerDown)
            {
                <span class="enscript-keyword">break</span>;
            }
        }

        <span class="enscript-keyword">if</span> (kIOPMMessageLastCallBeforeSleep == context-&gt;messageType)
        {
            <span class="enscript-keyword">if</span> ((object == (OSObject *) systemCapabilityNotifier) &amp;&amp;
                CAP_HIGHEST(kIOPMSystemCapabilityGraphics) &amp;&amp;
                (fullToDarkReason == kIOPMSleepReasonIdle))
                allow = true;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Reject capability change messages for legacy clients.
</span>        <span class="enscript-comment">// Reject legacy system sleep messages for capability client.
</span>
        <span class="enscript-keyword">if</span> (isCapMsg || (object == (OSObject *) systemCapabilityNotifier))
        {
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">// Filter system sleep messages.
</span>
        <span class="enscript-keyword">if</span> ((context-&gt;notifyType == kNotifyApps) &amp;&amp;
            (_systemMessageClientMask &amp; kSystemMessageClientLegacyApp))
        {
            IOPMServiceInterestNotifier *notify;
            allow = true;

            <span class="enscript-keyword">if</span> ((notify = OSDynamicCast(IOPMServiceInterestNotifier, (OSObject *)object))
                &amp;&amp; arg3) {

                <span class="enscript-keyword">if</span> (notify-&gt;ackTimeoutCnt &gt;= 3)
                    *((OSObject **) arg3) = kOSBooleanFalse;
                <span class="enscript-keyword">else</span>
                    *((OSObject **) arg3) = kOSBooleanTrue;
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((context-&gt;notifyType == kNotifyPriority) &amp;&amp;
                 (_systemMessageClientMask &amp; kSystemMessageClientKernel))
        {
            allow = true;
        }
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (allow &amp;&amp; isCapMsg &amp;&amp; _joinedCapabilityClients)
    {
        _joinedCapabilityClients-&gt;removeObject((OSObject *) object);
        <span class="enscript-keyword">if</span> (_joinedCapabilityClients-&gt;getCount() == 0)
        {
            DLOG(<span class="enscript-string">&quot;destroyed capability client set %p\n&quot;</span>,
                OBFUSCATE(_joinedCapabilityClients));
            _joinedCapabilityClients-&gt;release();
            _joinedCapabilityClients = 0;
        }
    }

    <span class="enscript-keyword">return</span> allow;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setMaintenanceWakeCalendar
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::setMaintenanceWakeCalendar</span>(
    <span class="enscript-type">const</span> IOPMCalendarStruct * calendar )
{
    OSData * data;
    IOReturn ret = 0;

    <span class="enscript-keyword">if</span> (!calendar)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    data = OSData::withBytesNoCopy((<span class="enscript-type">void</span> *) calendar, <span class="enscript-keyword">sizeof</span>(*calendar));
    <span class="enscript-keyword">if</span> (!data)
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    <span class="enscript-keyword">if</span> (kPMCalendarTypeMaintenance == calendar-&gt;selector) {
        ret = setPMSetting(gIOPMSettingMaintenanceWakeCalendarKey, data);
        <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
            OSBitOrAtomic(kIOPMAlarmBitMaintenanceWake, &amp;_scheduledAlarms);
    } <span class="enscript-keyword">else</span>
    <span class="enscript-keyword">if</span> (kPMCalendarTypeSleepService == calendar-&gt;selector)
    {
        ret = setPMSetting(gIOPMSettingSleepServiceWakeCalendarKey, data);
        <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
            OSBitOrAtomic(kIOPMAlarmBitSleepServiceWake, &amp;_scheduledAlarms);
    }
    DLOG(<span class="enscript-string">&quot;_scheduledAlarms = 0x%x\n&quot;</span>, (uint32_t) _scheduledAlarms);

    data-&gt;release();
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Display Wrangler
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// displayWranglerNotification
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Handle the notification when the IODisplayWrangler changes power state.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::displayWranglerNotification</span>(
    <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * refCon,
    UInt32 messageType, IOService * service,
    <span class="enscript-type">void</span> * messageArgument, vm_size_t argSize )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-type">int</span>                                 displayPowerState;
    IOPowerStateChangeNotification *    params =
            (IOPowerStateChangeNotification *) messageArgument;

    <span class="enscript-keyword">if</span> ((messageType != kIOMessageDeviceWillPowerOff) &amp;&amp;
        (messageType != kIOMessageDeviceHasPoweredOn))
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    ASSERT_GATED();
    <span class="enscript-keyword">if</span> (!gRootDomain)
        <span class="enscript-keyword">return</span> kIOReturnUnsupported;

    displayPowerState = params-&gt;stateNumber;
    DLOG(<span class="enscript-string">&quot;wrangler %s ps %d\n&quot;</span>,
         getIOMessageString(messageType), displayPowerState);

    <span class="enscript-keyword">switch</span> (messageType) {
       <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageDeviceWillPowerOff</span>:
            <span class="enscript-comment">// Display wrangler has dropped power due to display idle
</span>            <span class="enscript-comment">// or force system sleep.
</span>            <span class="enscript-comment">//
</span>            <span class="enscript-comment">// 4 Display ON             kWranglerPowerStateMax
</span>            <span class="enscript-comment">// 3 Display Dim            kWranglerPowerStateDim
</span>            <span class="enscript-comment">// 2 Display Sleep          kWranglerPowerStateSleep
</span>            <span class="enscript-comment">// 1 Not visible to user
</span>            <span class="enscript-comment">// 0 Not visible to user    kWranglerPowerStateMin
</span>
            <span class="enscript-keyword">if</span> (displayPowerState &lt;= kWranglerPowerStateSleep)
                gRootDomain-&gt;evaluatePolicy( kStimulusDisplayWranglerSleep );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMessageDeviceHasPoweredOn</span>:
            <span class="enscript-comment">// Display wrangler has powered on due to user activity
</span>            <span class="enscript-comment">// or wake from sleep.
</span>
            <span class="enscript-keyword">if</span> (kWranglerPowerStateMax == displayPowerState)
            {
                gRootDomain-&gt;evaluatePolicy( kStimulusDisplayWranglerWake );

                <span class="enscript-comment">// See comment in handleUpdatePowerClientForDisplayWrangler
</span>                <span class="enscript-keyword">if</span> (service-&gt;getPowerStateForClient(gIOPMPowerClientDevice) ==
                    kWranglerPowerStateMax)
                {
                    gRootDomain-&gt;evaluatePolicy( kStimulusEnterUserActiveState );
                }
            }
            <span class="enscript-keyword">break</span>;
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> kIOReturnUnsupported;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// displayWranglerMatchPublished
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Receives a notification when the IODisplayWrangler is published.
</span><span class="enscript-comment">// When it's published we install a power state change handler.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::displayWranglerMatchPublished</span>(
    <span class="enscript-type">void</span> * target,
    <span class="enscript-type">void</span> * refCon,
    IOService * newService,
    IONotifier * notifier __unused)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-comment">// found the display wrangler, now install a handler
</span>    <span class="enscript-keyword">if</span>( !newService-&gt;registerInterest( gIOGeneralInterest,
                            &amp;displayWranglerNotification, target, 0) )
    {
        <span class="enscript-keyword">return</span> false;
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> true;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::IONVRAMMatchPublished</span>(
    <span class="enscript-type">void</span> * target,
    <span class="enscript-type">void</span> * refCon,
    IOService * newService,
    IONotifier * notifier)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>     len = 0;
    IOPMrootDomain *rd = (IOPMrootDomain *)target;
    OSNumber    *statusCode = NULL;

    <span class="enscript-keyword">if</span> (PEReadNVRAMProperty(kIOSleepWakeDebugKey, NULL, &amp;len))
    {
        statusCode = OSDynamicCast(OSNumber, rd-&gt;getProperty(kIOPMSleepWakeFailureCodeKey));
        <span class="enscript-keyword">if</span> (statusCode != NULL) {
            <span class="enscript-keyword">if</span> (statusCode-&gt;unsigned64BitValue() != 0) {
                rd-&gt;swd_flags |= SWD_BOOT_BY_SW_WDOG;
                MSG(<span class="enscript-string">&quot;System was rebooted due to Sleep/Wake failure\n&quot;</span>);
            }
            <span class="enscript-keyword">else</span> {
                rd-&gt;swd_flags |= SWD_BOOT_BY_OSX_WDOG;
                MSG(<span class="enscript-string">&quot;System was non-responsive and was rebooted by watchdog\n&quot;</span>);
            }
        }

        rd-&gt;swd_logBufMap = rd-&gt;sleepWakeDebugRetrieve();
    }
    <span class="enscript-keyword">if</span> (notifier) notifier-&gt;remove();
    <span class="enscript-keyword">return</span> true;
}

#<span class="enscript-reference">else</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::IONVRAMMatchPublished</span>(
    <span class="enscript-type">void</span> * target,
    <span class="enscript-type">void</span> * refCon,
    IOService * newService,
    IONotifier * notifier __unused)
{
    <span class="enscript-keyword">return</span> false;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// reportUserInput
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::reportUserInput</span>( <span class="enscript-type">void</span> )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    OSIterator * iter;
    OSDictionary * matching;

    <span class="enscript-keyword">if</span>(!wrangler)
    {
        matching = serviceMatching(<span class="enscript-string">&quot;IODisplayWrangler&quot;</span>);
        iter = getMatchingServices(matching);
        <span class="enscript-keyword">if</span> (matching) matching-&gt;release();
        <span class="enscript-keyword">if</span>(iter)
        {
            wrangler = (IOService *) iter-&gt;getNextObject();
            iter-&gt;release();
        }
    }

    <span class="enscript-keyword">if</span>(wrangler)
        wrangler-&gt;activityTickle(0,0);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// latchDisplayWranglerTickle
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::latchDisplayWranglerTickle</span>( <span class="enscript-type">bool</span> latch )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-keyword">if</span> (latch)
    {
        <span class="enscript-keyword">if</span> (!(_currentCapability &amp; kIOPMSystemCapabilityGraphics) &amp;&amp;
            !(_pendingCapability &amp; kIOPMSystemCapabilityGraphics) &amp;&amp;
            !checkSystemCanSustainFullWake())
        {
            <span class="enscript-comment">// Currently in dark wake, and not transitioning to full wake.
</span>            <span class="enscript-comment">// Full wake is unsustainable, so latch the tickle to prevent
</span>            <span class="enscript-comment">// the display from lighting up momentarily.
</span>            wranglerTickleLatched = true;
        }
        <span class="enscript-keyword">else</span>
        {
            wranglerTickleLatched = false;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wranglerTickleLatched &amp;&amp; checkSystemCanSustainFullWake())
    {
        wranglerTickleLatched = false;

        pmPowerStateQueue-&gt;submitPowerEvent(
            kPowerEventPolicyStimulus,
            (<span class="enscript-type">void</span> *) kStimulusDarkWakeActivityTickle );
    }

    <span class="enscript-keyword">return</span> wranglerTickleLatched;
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">return</span> false;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// setDisplayPowerOn
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For root domain user client
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::setDisplayPowerOn</span>( uint32_t options )
{
    pmPowerStateQueue-&gt;submitPowerEvent( kPowerEventSetDisplayPowerOn,
                                         (<span class="enscript-type">void</span> *) 0, options );
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Battery
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// batteryPublished
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notification on battery class IOPowerSource appearance
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::batteryPublished</span>(
    <span class="enscript-type">void</span> * target,
    <span class="enscript-type">void</span> * root_domain,
    IOService * resourceService,
    IONotifier * notifier __unused )
{
    <span class="enscript-comment">// rdar://2936060&amp;4435589
</span>    <span class="enscript-comment">// All laptops have dimmable LCD displays
</span>    <span class="enscript-comment">// All laptops have batteries
</span>    <span class="enscript-comment">// So if this machine has a battery, publish the fact that the backlight
</span>    <span class="enscript-comment">// supports dimming.
</span>    ((IOPMrootDomain *)root_domain)-&gt;publishFeature(<span class="enscript-string">&quot;DisplayDims&quot;</span>);

    <span class="enscript-keyword">return</span> (true);
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: System PM Policy
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// checkSystemSleepAllowed
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::checkSystemSleepAllowed</span>( IOOptionBits options,
                                              uint32_t     sleepReason )
{
    <span class="enscript-type">int</span> err = 0;

    <span class="enscript-comment">// Conditions that prevent idle and demand system sleep.
</span>
    <span class="enscript-keyword">do</span> {
        <span class="enscript-keyword">if</span> (userDisabledAllSleep)
        {
            err = 1;        <span class="enscript-comment">// 1. user-space sleep kill switch
</span>            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (systemBooting || systemShutdown || gWillShutdown)
        {
            err = 2;        <span class="enscript-comment">// 2. restart or shutdown in progress
</span>            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (options == 0)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Conditions above pegs the system at full wake.
</span>        <span class="enscript-comment">// Conditions below prevent system sleep but does not prevent
</span>        <span class="enscript-comment">// dark wake, and must be called from gated context.
</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_SLEEP</span>
        err = 3;            <span class="enscript-comment">// 3. config does not support sleep
</span>        <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

        <span class="enscript-keyword">if</span> (lowBatteryCondition || thermalWarningState)
        {
            <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// always sleep on low battery or when in thermal warning state
</span>        }

        <span class="enscript-keyword">if</span> (sleepReason == kIOPMSleepReasonDarkWakeThermalEmergency)
        {
            <span class="enscript-keyword">break</span>;          <span class="enscript-comment">// always sleep on dark wake thermal emergencies
</span>        }

        <span class="enscript-keyword">if</span> (preventSystemSleepList-&gt;getCount() != 0)
        {
            err = 4;        <span class="enscript-comment">// 4. child prevent system sleep clamp
</span>            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (getPMAssertionLevel( kIOPMDriverAssertionCPUBit ) ==
            kIOPMDriverAssertionLevelOn)
        {
            err = 5;        <span class="enscript-comment">// 5. CPU assertion
</span>            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-keyword">if</span> (pciCantSleepValid)
        {
            <span class="enscript-keyword">if</span> (pciCantSleepFlag)
                err = 6;    <span class="enscript-comment">// 6. PCI card does not support PM (cached)
</span>            <span class="enscript-keyword">break</span>;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sleepSupportedPEFunction &amp;&amp;
                 CAP_HIGHEST(kIOPMSystemCapabilityGraphics))
        {
            IOReturn ret;
            OSBitAndAtomic(~kPCICantSleep, &amp;platformSleepSupport);
            ret = getPlatform()-&gt;callPlatformFunction(
                                    sleepSupportedPEFunction, false,
                                    NULL, NULL, NULL, NULL);
            pciCantSleepValid = true;
            pciCantSleepFlag  = false;
            <span class="enscript-keyword">if</span> ((platformSleepSupport &amp; kPCICantSleep) ||
                ((ret != kIOReturnSuccess) &amp;&amp; (ret != kIOReturnUnsupported)))
            {
                err = 6;    <span class="enscript-comment">// 6. PCI card does not support PM
</span>                pciCantSleepFlag = true;
                <span class="enscript-keyword">break</span>;
            }
        }
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (err)
    {
        DLOG(<span class="enscript-string">&quot;System sleep prevented by %d\n&quot;</span>, err);
        <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::checkSystemSleepEnabled</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span> checkSystemSleepAllowed(0, 0);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::checkSystemCanSleep</span>( uint32_t sleepReason )
{
    ASSERT_GATED();
    <span class="enscript-keyword">return</span> checkSystemSleepAllowed(1, sleepReason);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// checkSystemCanSustainFullWake
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::checkSystemCanSustainFullWake</span>( <span class="enscript-type">void</span> )
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KERNEL_HID</span>
    <span class="enscript-keyword">if</span> (lowBatteryCondition || thermalWarningState)
    {
        <span class="enscript-comment">// Low battery wake, or received a low battery notification
</span>        <span class="enscript-comment">// while system is awake. This condition will persist until
</span>        <span class="enscript-comment">// the following wake.
</span>        <span class="enscript-keyword">return</span> false;
    }

    <span class="enscript-keyword">if</span> (clamshellExists &amp;&amp; clamshellClosed &amp;&amp; !clamshellSleepDisabled)
    {
        <span class="enscript-comment">// Graphics state is unknown and external display might not be probed.
</span>        <span class="enscript-comment">// Do not incorporate state that requires graphics to be in max power
</span>        <span class="enscript-comment">// such as desktopMode or clamshellDisabled.
</span>
        <span class="enscript-keyword">if</span> (!acAdaptorConnected)
        {
            DLOG(<span class="enscript-string">&quot;full wake check: no AC\n&quot;</span>);
            <span class="enscript-keyword">return</span> false;
        }
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// adjustPowerState
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Conditions that affect our wake/sleep decision has changed.
</span><span class="enscript-comment">// If conditions dictate that the system must remain awake, clamp power
</span><span class="enscript-comment">// state to max with changePowerStateToPriv(ON). Otherwise if sleepASAP
</span><span class="enscript-comment">// is TRUE, then remove the power clamp and allow the power state to drop
</span><span class="enscript-comment">// to SLEEP_STATE.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::adjustPowerState</span>( <span class="enscript-type">bool</span> sleepASAP )
{
    DLOG(<span class="enscript-string">&quot;adjustPowerState ps %u, asap %d, slider %ld\n&quot;</span>,
        (uint32_t) getPowerState(), sleepASAP, sleepSlider);

    ASSERT_GATED();

    <span class="enscript-keyword">if</span> ((sleepSlider == 0) || !checkSystemSleepEnabled())
    {
        changePowerStateToPriv(ON_STATE);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( sleepASAP )
    {
        changePowerStateToPriv(SLEEP_STATE);
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handleDisplayPowerOn</span>( )
{
    <span class="enscript-keyword">if</span> (!wrangler) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (displayPowerOnRequested)
    {
        <span class="enscript-keyword">if</span> (!checkSystemCanSustainFullWake()) <span class="enscript-keyword">return</span>;

        <span class="enscript-comment">// Force wrangler to max power state. If system is in dark wake
</span>        <span class="enscript-comment">// this alone won't raise the wrangler's power state.
</span>
        wrangler-&gt;changePowerStateForRootDomain(kWranglerPowerStateMax);

        <span class="enscript-comment">// System in dark wake, always requesting full wake should
</span>        <span class="enscript-comment">// not have any bad side-effects, even if the request fails.
</span>
        <span class="enscript-keyword">if</span> (!CAP_CURRENT(kIOPMSystemCapabilityGraphics))
        {
            setProperty(kIOPMRootDomainWakeTypeKey, kIOPMRootDomainWakeTypeNotification);
            requestFullWake( kFullWakeReasonDisplayOn );
        }
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// Relenquish desire to power up display.
</span>        <span class="enscript-comment">// Must first transition to state 1 since wrangler doesn't
</span>        <span class="enscript-comment">// power off the displays at state 0. At state 0 the root
</span>        <span class="enscript-comment">// domain is removed from the wrangler's power client list.
</span>
        wrangler-&gt;changePowerStateForRootDomain(kWranglerPowerStateMin + 1);
        wrangler-&gt;changePowerStateForRootDomain(kWranglerPowerStateMin);

    }

}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// dispatchPowerEvent
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// IOPMPowerStateQueue callback function. Running on PM work loop thread.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::dispatchPowerEvent</span>(
    uint32_t event, <span class="enscript-type">void</span> * arg0, uint64_t arg1 )
{
    DLOG(<span class="enscript-string">&quot;power event %u args %p 0x%llx\n&quot;</span>, event, OBFUSCATE(arg0), arg1);
    ASSERT_GATED();

    <span class="enscript-keyword">switch</span> (event)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventFeatureChanged</span>:
            messageClients(kIOPMMessageFeatureChange, <span class="enscript-keyword">this</span>);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventReceivedPowerNotification</span>:
            handlePowerNotification( (UInt32)(uintptr_t) arg0 );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventSystemBootCompleted</span>:
            <span class="enscript-keyword">if</span> (systemBooting)
            {
                systemBooting = false;

                <span class="enscript-keyword">if</span> (lowBatteryCondition)
                {
                    privateSleepSystem (kIOPMSleepReasonLowPower);

                    <span class="enscript-comment">// The rest is unnecessary since the system is expected
</span>                    <span class="enscript-comment">// to sleep immediately. The following wake will update
</span>                    <span class="enscript-comment">// everything.
</span>                    <span class="enscript-keyword">break</span>;
                }

                <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_VALID_LOGS) {
                    <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_LOGS_IN_MEM) {
                        sleepWakeDebugDumpFromMem(swd_logBufMap);
                        swd_logBufMap-&gt;release();
                        swd_logBufMap = 0;
                    }
                    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_LOGS_IN_FILE) 
                        sleepWakeDebugDumpFromFile();
                }
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (swd_flags &amp; (SWD_BOOT_BY_SW_WDOG|SWD_BOOT_BY_OSX_WDOG)) {
                    <span class="enscript-comment">// If logs are invalid, write the failure code
</span>                    sleepWakeDebugDumpFromMem(NULL);
                }
                <span class="enscript-comment">// If lid is closed, re-send lid closed notification
</span>                <span class="enscript-comment">// now that booting is complete.
</span>                <span class="enscript-keyword">if</span> ( clamshellClosed )
                {
                    handlePowerNotification(kLocalEvalClamshellCommand);
                }
                evaluatePolicy( kStimulusAllowSystemSleepChanged );

            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventSystemShutdown</span>:
            <span class="enscript-keyword">if</span> (kOSBooleanTrue == (OSBoolean *) arg0)
            {
                <span class="enscript-comment">/* We set systemShutdown = true during shutdown
                   to prevent sleep at unexpected times while loginwindow is trying
                   to shutdown apps and while the OS is trying to transition to
                   complete power of.

                   Set to true during shutdown, as soon as loginwindow shows
                   the &quot;shutdown countdown dialog&quot;, through individual app
                   termination, and through black screen kernel shutdown.
                 */</span>
                systemShutdown = true;
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">/*
                 A shutdown was initiated, but then the shutdown
                 was cancelled, clearing systemShutdown to false here.
                */</span>
                systemShutdown = false;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventUserDisabledSleep</span>:
            userDisabledAllSleep = (kOSBooleanTrue == (OSBoolean *) arg0);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventRegisterSystemCapabilityClient</span>:
            <span class="enscript-keyword">if</span> (systemCapabilityNotifier)
            {
                systemCapabilityNotifier-&gt;release();
                systemCapabilityNotifier = 0;
            }
            <span class="enscript-keyword">if</span> (arg0)
            {
                systemCapabilityNotifier = (IONotifier *) arg0;
                systemCapabilityNotifier-&gt;retain();
            }
            <span class="enscript-comment">/* intentional fall-through */</span>

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventRegisterKernelCapabilityClient</span>:
            <span class="enscript-keyword">if</span> (!_joinedCapabilityClients)
                _joinedCapabilityClients = OSSet::withCapacity(8);
            <span class="enscript-keyword">if</span> (arg0)
            {
                IONotifier * notify = (IONotifier *) arg0;
                <span class="enscript-keyword">if</span> (_joinedCapabilityClients)
                {
                    _joinedCapabilityClients-&gt;setObject(notify);
                    synchronizePowerTree( kIOPMSyncNoChildNotify );
                }
                notify-&gt;release();
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventPolicyStimulus</span>:
            <span class="enscript-keyword">if</span> (arg0)
            {
                <span class="enscript-type">int</span> stimulus = (uintptr_t) arg0;
                evaluatePolicy( stimulus, (uint32_t) arg1 );
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventAssertionCreate</span>:
            <span class="enscript-keyword">if</span> (pmAssertions) {
                pmAssertions-&gt;handleCreateAssertion((OSData *)arg0);
            }
            <span class="enscript-keyword">break</span>;


        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventAssertionRelease</span>:
            <span class="enscript-keyword">if</span> (pmAssertions) {
                pmAssertions-&gt;handleReleaseAssertion(arg1);
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventAssertionSetLevel</span>:
            <span class="enscript-keyword">if</span> (pmAssertions) {
                pmAssertions-&gt;handleSetAssertionLevel(arg1, (IOPMDriverAssertionLevel)(uintptr_t)arg0);
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventQueueSleepWakeUUID</span>:
            handleQueueSleepWakeUUID((OSObject *)arg0);
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventPublishSleepWakeUUID</span>:
            handlePublishSleepWakeUUID((<span class="enscript-type">bool</span>)arg0);
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kPowerEventSetDisplayPowerOn</span>:
            <span class="enscript-keyword">if</span> (!wrangler) <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">if</span> (arg1 != 0)
            {
                displayPowerOnRequested = true;
            }
            <span class="enscript-keyword">else</span>
            {
                displayPowerOnRequested = false;
            }
            handleDisplayPowerOn();
            <span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// systemPowerEventOccurred
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The power controller is notifying us of a hardware-related power management
</span><span class="enscript-comment">// event that we must handle.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// systemPowerEventOccurred covers the same functionality that
</span><span class="enscript-comment">// receivePowerNotification does; it simply provides a richer API for conveying
</span><span class="enscript-comment">// more information.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::systemPowerEventOccurred</span>(
    <span class="enscript-type">const</span> OSSymbol *event,
    uint32_t intValue)
{
    IOReturn        attempt = kIOReturnSuccess;
    OSNumber        *newNumber = NULL;

    <span class="enscript-keyword">if</span> (!event)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    newNumber = OSNumber::withNumber(intValue, 8*<span class="enscript-keyword">sizeof</span>(intValue));
    <span class="enscript-keyword">if</span> (!newNumber)
        <span class="enscript-keyword">return</span> kIOReturnInternalError;

    attempt = systemPowerEventOccurred(event, (OSObject *)newNumber);

    newNumber-&gt;release();

    <span class="enscript-keyword">return</span> attempt;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::setThermalState</span>(OSObject *value)
{
   OSNumber * num;

   <span class="enscript-keyword">if</span> (gIOPMWorkLoop-&gt;inGate() == false) {
       gIOPMWorkLoop-&gt;runAction(
               OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>, &amp;IOPMrootDomain::setThermalState),
               (OSObject *)<span class="enscript-keyword">this</span>,
               (<span class="enscript-type">void</span> *)value);

       <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (value &amp;&amp; (num = OSDynamicCast(OSNumber, value))) {
        thermalWarningState = ((num-&gt;unsigned32BitValue() == kIOPMThermalLevelWarning) || 
                               (num-&gt;unsigned32BitValue() == kIOPMThermalLevelTrap)) ? 1 : 0; 
    }
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::systemPowerEventOccurred</span>(
    <span class="enscript-type">const</span> OSSymbol *event,
    OSObject *value)
{
    OSDictionary *thermalsDict = NULL;
    <span class="enscript-type">bool</span> shouldUpdate = true;

    <span class="enscript-keyword">if</span> (!event || !value)
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    <span class="enscript-comment">// LOCK
</span>    <span class="enscript-comment">// We reuse featuresDict Lock because it already exists and guards
</span>    <span class="enscript-comment">// the very infrequently used publish/remove feature mechanism; so there's zero rsk
</span>    <span class="enscript-comment">// of stepping on that lock.
</span>    <span class="enscript-keyword">if</span> (featuresDictLock) IOLockLock(featuresDictLock);

    thermalsDict = (OSDictionary *)getProperty(kIOPMRootDomainPowerStatusKey);

    <span class="enscript-keyword">if</span> (thermalsDict &amp;&amp; OSDynamicCast(OSDictionary, thermalsDict)) {
        thermalsDict = OSDictionary::withDictionary(thermalsDict);
    } <span class="enscript-keyword">else</span> {
        thermalsDict = OSDictionary::withCapacity(1);
    }

    <span class="enscript-keyword">if</span> (!thermalsDict) {
        shouldUpdate = false;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    thermalsDict-&gt;setObject (event, value);

    setProperty (kIOPMRootDomainPowerStatusKey, thermalsDict);

    thermalsDict-&gt;release();

<span class="enscript-reference">exit</span>:
    <span class="enscript-comment">// UNLOCK
</span>    <span class="enscript-keyword">if</span> (featuresDictLock) IOLockUnlock(featuresDictLock);

    <span class="enscript-keyword">if</span> (shouldUpdate) {
        <span class="enscript-keyword">if</span> (event &amp;&amp; 
             event-&gt;isEqualTo(kIOPMThermalLevelWarningKey)) {
             setThermalState(value);
        }
        messageClients (kIOPMMessageSystemPowerEventOccurred, (<span class="enscript-type">void</span> *)NULL);
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// receivePowerNotification
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The power controller is notifying us of a hardware-related power management
</span><span class="enscript-comment">// event that we must handle. This may be a result of an 'environment' interrupt
</span><span class="enscript-comment">// from the power mgt micro.
</span><span class="enscript-comment">//******************************************************************************
</span>
IOReturn <span class="enscript-function-name">IOPMrootDomain::receivePowerNotification</span>( UInt32 msg )
{
    pmPowerStateQueue-&gt;submitPowerEvent(
        kPowerEventReceivedPowerNotification, (<span class="enscript-type">void</span> *)(uintptr_t) msg );
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::handlePowerNotification</span>( UInt32 msg )
{
    <span class="enscript-type">bool</span>        eval_clamshell = false;

    ASSERT_GATED();

    <span class="enscript-comment">/*
     * Local (IOPMrootDomain only) eval clamshell command
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kLocalEvalClamshellCommand)
    {
        eval_clamshell = true;
    }

    <span class="enscript-comment">/*
     * Overtemp
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMOverTemp)
    {
        MSG(<span class="enscript-string">&quot;PowerManagement emergency overtemp signal. Going to sleep!&quot;</span>);
        privateSleepSystem (kIOPMSleepReasonThermalEmergency);
    }

    <span class="enscript-comment">/*
     * Forward DW thermal notification to client, if system is not going to sleep
     */</span>
    <span class="enscript-keyword">if</span> ((msg &amp; kIOPMDWOverTemp) &amp;&amp; (_systemTransitionType != kSystemTransitionSleep))
    {
        DLOG(<span class="enscript-string">&quot;DarkWake thermal limits message received!\n&quot;</span>);

        messageClients(kIOPMMessageDarkWakeThermalEmergency);
    }

    <span class="enscript-comment">/*
     * Sleep Now!
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMSleepNow)
    {
        privateSleepSystem (kIOPMSleepReasonSoftware);
    }

    <span class="enscript-comment">/*
     * Power Emergency
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMPowerEmergency)
    {
        lowBatteryCondition = true;
        privateSleepSystem (kIOPMSleepReasonLowPower);
    }

    <span class="enscript-comment">/*
     * Clamshell OPEN
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMClamshellOpened)
    {
        <span class="enscript-comment">// Received clamshel open message from clamshell controlling driver
</span>        <span class="enscript-comment">// Update our internal state and tell general interest clients
</span>        clamshellClosed = false;
        clamshellExists = true;

        <span class="enscript-comment">// Don't issue a hid tickle when lid is open and polled on wake
</span>        <span class="enscript-keyword">if</span> (msg &amp; kIOPMSetValue)
        {
            setProperty(kIOPMRootDomainWakeTypeKey, <span class="enscript-string">&quot;Lid Open&quot;</span>);
            reportUserInput();
        }

        <span class="enscript-comment">// Tell PMCPU
</span>        informCPUStateChange(kInformLid, 0);

        <span class="enscript-comment">// Tell general interest clients
</span>        sendClientClamshellNotification();

        <span class="enscript-type">bool</span> aborting =  ((lastSleepReason == kIOPMSleepReasonClamshell)
                       || (lastSleepReason == kIOPMSleepReasonIdle)
                       || (lastSleepReason == kIOPMSleepReasonMaintenance));
        <span class="enscript-keyword">if</span> (aborting) userActivityCount++;
        DLOG(<span class="enscript-string">&quot;clamshell tickled %d lastSleepReason %d\n&quot;</span>, userActivityCount, lastSleepReason);
    }

    <span class="enscript-comment">/*
     * Clamshell CLOSED
     * Send the clamshell interest notification since the lid is closing.
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMClamshellClosed)
    {
        <span class="enscript-comment">// Received clamshel open message from clamshell controlling driver
</span>        <span class="enscript-comment">// Update our internal state and tell general interest clients
</span>        clamshellClosed = true;
        clamshellExists = true;

        <span class="enscript-comment">// Tell PMCPU
</span>        informCPUStateChange(kInformLid, 1);

        <span class="enscript-comment">// Tell general interest clients
</span>        sendClientClamshellNotification();

        <span class="enscript-comment">// And set eval_clamshell = so we can attempt
</span>        eval_clamshell = true;
    }

    <span class="enscript-comment">/*
     * Set Desktop mode (sent from graphics)
     *
     *  -&gt; reevaluate lid state
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMSetDesktopMode)
    {
        desktopMode = (0 != (msg &amp; kIOPMSetValue));
        msg &amp;= ~(kIOPMSetDesktopMode | kIOPMSetValue);

        sendClientClamshellNotification();

        <span class="enscript-comment">// Re-evaluate the lid state
</span>        eval_clamshell = true;
    }

    <span class="enscript-comment">/*
     * AC Adaptor connected
     *
     *  -&gt; reevaluate lid state
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMSetACAdaptorConnected)
    {
        acAdaptorConnected = (0 != (msg &amp; kIOPMSetValue));
        msg &amp;= ~(kIOPMSetACAdaptorConnected | kIOPMSetValue);

        <span class="enscript-comment">// Tell CPU PM
</span>        informCPUStateChange(kInformAC, !acAdaptorConnected);

        <span class="enscript-comment">// Tell BSD if AC is connected
</span>        <span class="enscript-comment">//      0 == external power source; 1 == on battery
</span>        post_sys_powersource(acAdaptorConnected ? 0:1);

        sendClientClamshellNotification();

        <span class="enscript-comment">// Re-evaluate the lid state
</span>        eval_clamshell = true;

        <span class="enscript-comment">// Lack of AC may have latched a display wrangler tickle.
</span>        <span class="enscript-comment">// This mirrors the hardware's USB wake event latch, where a latched
</span>        <span class="enscript-comment">// USB wake event followed by an AC attach will trigger a full wake.
</span>        latchDisplayWranglerTickle( false );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
        <span class="enscript-comment">// AC presence will reset the standy timer delay adjustment.
</span>        _standbyTimerResetSeconds = 0;
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (!userIsActive) {
            <span class="enscript-comment">// Reset userActivityTime when power supply is changed(rdr 13789330)
</span>            clock_get_uptime(&amp;userActivityTime);
        }
    }

    <span class="enscript-comment">/*
     * Enable Clamshell (external display disappear)
     *
     *  -&gt; reevaluate lid state
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMEnableClamshell)
    {
        <span class="enscript-comment">// Re-evaluate the lid state
</span>        <span class="enscript-comment">// System should sleep on external display disappearance
</span>        <span class="enscript-comment">// in lid closed operation.
</span>        <span class="enscript-keyword">if</span> (true == clamshellDisabled)
        {
            eval_clamshell = true;
        }

        clamshellDisabled = false;
        sendClientClamshellNotification();
    }

    <span class="enscript-comment">/*
     * Disable Clamshell (external display appeared)
     * We don't bother re-evaluating clamshell state. If the system is awake,
     * the lid is probably open.
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMDisableClamshell)
    {
        clamshellDisabled = true;
        sendClientClamshellNotification();
    }

    <span class="enscript-comment">/*
     * Evaluate clamshell and SLEEP if appropiate
     */</span>
    <span class="enscript-keyword">if</span> (eval_clamshell &amp;&amp; clamshellClosed)
    {
        <span class="enscript-keyword">if</span> (shouldSleepOnClamshellClosed())
            privateSleepSystem (kIOPMSleepReasonClamshell);
        <span class="enscript-keyword">else</span>
            evaluatePolicy( kStimulusDarkWakeEvaluate );
    }

    <span class="enscript-comment">/*
     * Power Button
     */</span>
    <span class="enscript-keyword">if</span> (msg &amp; kIOPMPowerButton)
    {
        <span class="enscript-keyword">if</span> (!wranglerAsleep)
        {
            OSString *pbs = OSString::withCString(<span class="enscript-string">&quot;DisablePowerButtonSleep&quot;</span>);
            <span class="enscript-comment">// Check that power button sleep is enabled
</span>            <span class="enscript-keyword">if</span>( pbs ) {
                <span class="enscript-keyword">if</span>( kOSBooleanTrue != getProperty(pbs))
                    privateSleepSystem (kIOPMSleepReasonPowerButton);
            }
        }
        <span class="enscript-keyword">else</span>
            reportUserInput();
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// evaluatePolicy
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Evaluate root-domain policy in response to external changes.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::evaluatePolicy</span>( <span class="enscript-type">int</span> stimulus, uint32_t arg )
{
    <span class="enscript-type">union</span> {
        <span class="enscript-type">struct</span> {
            <span class="enscript-type">int</span> idleSleepEnabled    : 1;
            <span class="enscript-type">int</span> idleSleepDisabled   : 1;
            <span class="enscript-type">int</span> displaySleep        : 1;
            <span class="enscript-type">int</span> sleepDelayChanged   : 1;
            <span class="enscript-type">int</span> evaluateDarkWake    : 1;
            <span class="enscript-type">int</span> adjustPowerState    : 1;
            <span class="enscript-type">int</span> userBecameInactive  : 1;
        } bit;
        uint32_t u32;
    } flags;

    DLOG(<span class="enscript-string">&quot;evaluatePolicy( %d, 0x%x )\n&quot;</span>, stimulus, arg);

    ASSERT_GATED();
    flags.u32 = 0;

    <span class="enscript-keyword">switch</span> (stimulus)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDisplayWranglerSleep</span>:
            <span class="enscript-keyword">if</span> (!wranglerAsleep)
            {
                <span class="enscript-comment">// first transition to wrangler sleep or lower
</span>                wranglerAsleep = true;
                flags.bit.displaySleep = true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDisplayWranglerWake</span>:
            displayIdleForDemandSleep = false;
            wranglerAsleep = false;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusEnterUserActiveState</span>:
            <span class="enscript-keyword">if</span> (_preventUserActive)
            {
                DLOG(<span class="enscript-string">&quot;user active dropped\n&quot;</span>);
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">if</span> (!userIsActive)
            {
                userIsActive = true;
                userWasActive = true;

                <span class="enscript-comment">// Stay awake after dropping demand for display power on
</span>                <span class="enscript-keyword">if</span> (kFullWakeReasonDisplayOn == fullWakeReason)
                    fullWakeReason = fFullWakeReasonDisplayOnAndLocalUser;

                setProperty(gIOPMUserIsActiveKey, kOSBooleanTrue);
                messageClients(kIOPMMessageUserIsActiveChanged);
            }
            flags.bit.idleSleepDisabled = true;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusLeaveUserActiveState</span>:
            <span class="enscript-keyword">if</span> (userIsActive)
            {
                userIsActive = false;
                clock_get_uptime(&amp;userBecameInactiveTime);
                flags.bit.userBecameInactive = true;

                setProperty(gIOPMUserIsActiveKey, kOSBooleanFalse);
                messageClients(kIOPMMessageUserIsActiveChanged);
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusAggressivenessChanged</span>:
        {
            <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   minutesToIdleSleep  = 0;
            <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   minutesToDisplayDim = 0;
            <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   minutesDelta        = 0;

            <span class="enscript-comment">// Fetch latest display and system sleep slider values.
</span>            getAggressiveness(kPMMinutesToSleep, &amp;minutesToIdleSleep);
            getAggressiveness(kPMMinutesToDim,   &amp;minutesToDisplayDim);
            DLOG(<span class="enscript-string">&quot;aggressiveness changed: system %u-&gt;%u, display %u\n&quot;</span>,
                (uint32_t) sleepSlider,
                (uint32_t) minutesToIdleSleep,
                (uint32_t) minutesToDisplayDim);

            DLOG(<span class="enscript-string">&quot;idle time -&gt; %ld secs (ena %d)\n&quot;</span>,
                idleSeconds, (minutesToIdleSleep != 0));

            <span class="enscript-keyword">if</span> (0x7fffffff == minutesToIdleSleep)
                minutesToIdleSleep = idleSeconds;

            <span class="enscript-comment">// How long to wait before sleeping the system once
</span>            <span class="enscript-comment">// the displays turns off is indicated by 'extraSleepDelay'.
</span>
            <span class="enscript-keyword">if</span> ( minutesToIdleSleep &gt; minutesToDisplayDim )
                minutesDelta = minutesToIdleSleep - minutesToDisplayDim;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( minutesToIdleSleep == minutesToDisplayDim )
                minutesDelta = 1;

            <span class="enscript-keyword">if</span> ((sleepSlider == 0) &amp;&amp; (minutesToIdleSleep != 0))
                flags.bit.idleSleepEnabled = true;

            <span class="enscript-keyword">if</span> ((sleepSlider != 0) &amp;&amp; (minutesToIdleSleep == 0))
                flags.bit.idleSleepDisabled = true;

            <span class="enscript-keyword">if</span> (((minutesDelta != extraSleepDelay) ||
                        (userActivityTime != userActivityTime_prev)) &amp;&amp;
                !flags.bit.idleSleepEnabled &amp;&amp; !flags.bit.idleSleepDisabled)
                flags.bit.sleepDelayChanged = true;

            <span class="enscript-keyword">if</span> (systemDarkWake &amp;&amp; !darkWakeToSleepASAP &amp;&amp;
                (flags.bit.idleSleepEnabled || flags.bit.idleSleepDisabled))
            {
                <span class="enscript-comment">// Reconsider decision to remain in dark wake
</span>                flags.bit.evaluateDarkWake = true;
            }

            sleepSlider = minutesToIdleSleep;
            extraSleepDelay = minutesDelta;
            userActivityTime_prev = userActivityTime;
        }   <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDemandSystemSleep</span>:
            displayIdleForDemandSleep = true;
            <span class="enscript-keyword">if</span> (wrangler &amp;&amp; wranglerIdleSettings)
            {
                <span class="enscript-comment">// Request wrangler idle only when demand sleep is triggered
</span>                <span class="enscript-comment">// from full wake.
</span>                <span class="enscript-keyword">if</span>(CAP_CURRENT(kIOPMSystemCapabilityGraphics))
                {
                    wrangler-&gt;setProperties(wranglerIdleSettings);
                    DLOG(<span class="enscript-string">&quot;Requested wrangler idle\n&quot;</span>);
                }
            }
            <span class="enscript-comment">// arg = sleepReason
</span>            changePowerStateWithOverrideTo( SLEEP_STATE, arg );
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusAllowSystemSleepChanged</span>:
            flags.bit.adjustPowerState = true;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDarkWakeActivityTickle</span>:
            <span class="enscript-comment">// arg == true implies real and not self generated wrangler tickle.
</span>            <span class="enscript-comment">// Update wake type on PM work loop instead of the tickle thread to
</span>            <span class="enscript-comment">// eliminate the possibility of an early tickle clobbering the wake
</span>            <span class="enscript-comment">// type set by the platform driver.
</span>            <span class="enscript-keyword">if</span> (arg == true)
                setProperty(kIOPMRootDomainWakeTypeKey, kIOPMRootDomainWakeTypeHIDActivity);
            
            <span class="enscript-keyword">if</span> (false == wranglerTickled)
            {
                <span class="enscript-keyword">if</span> (latchDisplayWranglerTickle(true))
                {
                    DLOG(<span class="enscript-string">&quot;latched tickle\n&quot;</span>);
                    <span class="enscript-keyword">break</span>;
                }

                wranglerTickled = true;
                DLOG(<span class="enscript-string">&quot;Requesting full wake after dark wake activity tickle\n&quot;</span>);
                requestFullWake( kFullWakeReasonLocalUser );
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDarkWakeEntry</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDarkWakeReentry</span>:
            <span class="enscript-comment">// Any system transitions since the last dark wake transition
</span>            <span class="enscript-comment">// will invalid the stimulus.
</span>
            <span class="enscript-keyword">if</span> (arg == _systemStateGeneration)
            {
                DLOG(<span class="enscript-string">&quot;dark wake entry\n&quot;</span>);
                systemDarkWake = true;

                <span class="enscript-comment">// Keep wranglerAsleep an invariant when wrangler is absent
</span>                <span class="enscript-keyword">if</span> (wrangler)
                    wranglerAsleep = true;

                <span class="enscript-keyword">if</span> (kStimulusDarkWakeEntry == stimulus)
                {
                    clock_get_uptime(&amp;userBecameInactiveTime);
                    flags.bit.evaluateDarkWake = true;
                }

                <span class="enscript-comment">// Always accelerate disk spindown while in dark wake,
</span>                <span class="enscript-comment">// even if system does not support/allow sleep.
</span>
                cancelIdleSleepTimer();
                setQuickSpinDownTimeout();
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusDarkWakeEvaluate</span>:
            <span class="enscript-keyword">if</span> (systemDarkWake)
            {
                flags.bit.evaluateDarkWake = true;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kStimulusNoIdleSleepPreventers</span>:
            flags.bit.adjustPowerState = true;
            <span class="enscript-keyword">break</span>;

    } <span class="enscript-comment">/* switch(stimulus) */</span>

    <span class="enscript-keyword">if</span> (flags.bit.evaluateDarkWake &amp;&amp; (kFullWakeReasonNone == fullWakeReason))
    {
        <span class="enscript-keyword">if</span> (darkWakeToSleepASAP ||
            (clamshellClosed &amp;&amp; !(desktopMode &amp;&amp; acAdaptorConnected)))
        {
            uint32_t newSleepReason;

            <span class="enscript-keyword">if</span> (CAP_HIGHEST(kIOPMSystemCapabilityGraphics))
            {
                <span class="enscript-comment">// System was previously in full wake. Sleep reason from
</span>                <span class="enscript-comment">// full to dark already recorded in fullToDarkReason.
</span>
                <span class="enscript-keyword">if</span> (lowBatteryCondition)
                    newSleepReason = kIOPMSleepReasonLowPower;
                <span class="enscript-keyword">else</span>
                    newSleepReason = fullToDarkReason;
            }
            <span class="enscript-keyword">else</span>
            {
                <span class="enscript-comment">// In dark wake from system sleep.
</span>
                <span class="enscript-keyword">if</span> (darkWakeSleepService)
                    newSleepReason = kIOPMSleepReasonSleepServiceExit;
                <span class="enscript-keyword">else</span>
                    newSleepReason = kIOPMSleepReasonMaintenance;
            }

            <span class="enscript-keyword">if</span> (checkSystemCanSleep(newSleepReason))
            {
                privateSleepSystem(newSleepReason);
            }
        }
        <span class="enscript-keyword">else</span> <span class="enscript-comment">// non-maintenance (network) dark wake
</span>        {
            <span class="enscript-keyword">if</span> (checkSystemCanSleep(kIOPMSleepReasonIdle))
            {
                <span class="enscript-comment">// Release power clamp, and wait for children idle.
</span>                adjustPowerState(true);
            }
            <span class="enscript-keyword">else</span>
            {
                changePowerStateToPriv(ON_STATE);
            }
        }
    }

    <span class="enscript-keyword">if</span> (systemDarkWake)
    {
        <span class="enscript-comment">// The rest are irrelevant while system is in dark wake.
</span>        flags.u32 = 0;
    }

    <span class="enscript-keyword">if</span> ((flags.bit.displaySleep) &amp;&amp;
        (kFullWakeReasonDisplayOn == fullWakeReason))
    {
        <span class="enscript-comment">// kIOPMSleepReasonMaintenance?
</span>        changePowerStateWithOverrideTo( SLEEP_STATE, kIOPMSleepReasonMaintenance );
    }

    <span class="enscript-keyword">if</span> (flags.bit.userBecameInactive || flags.bit.sleepDelayChanged)
    {
        <span class="enscript-type">bool</span> cancelQuickSpindown = false;

        <span class="enscript-keyword">if</span> (flags.bit.sleepDelayChanged)
        {
            <span class="enscript-comment">// Cancel existing idle sleep timer and quick disk spindown.
</span>            <span class="enscript-comment">// New settings will be applied by the idleSleepEnabled flag
</span>            <span class="enscript-comment">// handler below if idle sleep is enabled.
</span>
            DLOG(<span class="enscript-string">&quot;extra sleep timer changed\n&quot;</span>);
            cancelIdleSleepTimer();
            cancelQuickSpindown = true;
        }
        <span class="enscript-keyword">else</span>
        {
            DLOG(<span class="enscript-string">&quot;user inactive\n&quot;</span>);
        }

        <span class="enscript-keyword">if</span> (!userIsActive &amp;&amp; sleepSlider)
        {
            startIdleSleepTimer(getTimeToIdleSleep());
        }

        <span class="enscript-keyword">if</span> (cancelQuickSpindown)
            restoreUserSpinDownTimeout();
    }

    <span class="enscript-keyword">if</span> (flags.bit.idleSleepEnabled)
    {
        DLOG(<span class="enscript-string">&quot;idle sleep timer enabled\n&quot;</span>);
        <span class="enscript-keyword">if</span> (!wrangler)
        {
            changePowerStateToPriv(ON_STATE);
            <span class="enscript-keyword">if</span> (idleSeconds)
            {
                startIdleSleepTimer( idleSeconds );
            }
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// Start idle timer if prefs now allow system sleep
</span>            <span class="enscript-comment">// and user is already inactive. Disk spindown is
</span>            <span class="enscript-comment">// accelerated upon timer expiration.
</span>
            <span class="enscript-keyword">if</span> (!userIsActive)
            {
                startIdleSleepTimer(getTimeToIdleSleep());
            }
        }
    }

    <span class="enscript-keyword">if</span> (flags.bit.idleSleepDisabled)
    {
        DLOG(<span class="enscript-string">&quot;idle sleep timer disabled\n&quot;</span>);
        cancelIdleSleepTimer();
        restoreUserSpinDownTimeout();
        adjustPowerState();
    }

    <span class="enscript-keyword">if</span> (flags.bit.adjustPowerState)
    {
        <span class="enscript-type">bool</span> sleepASAP = false;

        <span class="enscript-keyword">if</span> (!systemBooting &amp;&amp; (preventIdleSleepList-&gt;getCount() == 0))
        {
            <span class="enscript-keyword">if</span> (!wrangler)
            {
                changePowerStateToPriv(ON_STATE);
                <span class="enscript-keyword">if</span> (idleSeconds)
                {
                    <span class="enscript-comment">// stay awake for at least idleSeconds
</span>                    startIdleSleepTimer(idleSeconds);
                }
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!extraSleepDelay &amp;&amp; !idleSleepTimerPending &amp;&amp; !systemDarkWake)
            {
                sleepASAP = true;
            }
        }

        adjustPowerState(sleepASAP);
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// requestFullWake
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Request transition from dark wake to full wake
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::requestFullWake</span>( FullWakeReason reason )
{
    uint32_t        options = 0;
    IOService *     pciRoot = 0;
    <span class="enscript-type">bool</span>            promotion = false;

    <span class="enscript-comment">// System must be in dark wake and a valid reason for entering full wake
</span>    <span class="enscript-keyword">if</span> ((kFullWakeReasonNone == reason) ||
        (kFullWakeReasonNone != fullWakeReason) ||
        (CAP_CURRENT(kIOPMSystemCapabilityGraphics)))
    {
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">// Will clear reason upon exit from full wake
</span>    fullWakeReason = reason;

    _desiredCapability |= (kIOPMSystemCapabilityGraphics |
                           kIOPMSystemCapabilityAudio);

    <span class="enscript-keyword">if</span> ((kSystemTransitionWake == _systemTransitionType) &amp;&amp;
        !(_pendingCapability &amp; kIOPMSystemCapabilityGraphics) &amp;&amp;
        !graphicsSuppressed)
    {
        <span class="enscript-comment">// Promote to full wake while waking up to dark wake due to tickle.
</span>        <span class="enscript-comment">// PM will hold off notifying the graphics subsystem about system wake
</span>        <span class="enscript-comment">// as late as possible, so if a HID tickle does arrive, graphics can
</span>        <span class="enscript-comment">// power up on this same wake cycle. The latency to power up graphics
</span>        <span class="enscript-comment">// on the next cycle can be huge on some systems. However, once any
</span>        <span class="enscript-comment">// graphics suppression has taken effect, it is too late. All other
</span>        <span class="enscript-comment">// graphics devices must be similarly suppressed. But the delay till
</span>        <span class="enscript-comment">// the following cycle should be short.
</span>
        _pendingCapability |= (kIOPMSystemCapabilityGraphics |
                               kIOPMSystemCapabilityAudio);

        <span class="enscript-comment">// Immediately bring up audio and graphics
</span>        pciRoot = pciHostBridgeDriver;
        willEnterFullWake();
        promotion = true;
    }

    <span class="enscript-comment">// Unsafe to cancel once graphics was powered.
</span>    <span class="enscript-comment">// If system woke from dark wake, the return to sleep can
</span>    <span class="enscript-comment">// be cancelled. &quot;awake -&gt; dark -&gt; sleep&quot; transition
</span>    <span class="enscript-comment">// can be canceled also, during the &quot;dark --&gt; sleep&quot; phase
</span>    <span class="enscript-comment">// *prior* to driver power down.
</span>    <span class="enscript-keyword">if</span> (!CAP_HIGHEST(kIOPMSystemCapabilityGraphics) ||
        _pendingCapability == 0) {
        options |= kIOPMSyncCancelPowerDown;
    }

    synchronizePowerTree(options, pciRoot);
    <span class="enscript-keyword">if</span> (kFullWakeReasonLocalUser == fullWakeReason)
    {
        <span class="enscript-comment">// IOGraphics doesn't light the display even though graphics is
</span>        <span class="enscript-comment">// enabled in kIOMessageSystemCapabilityChange message(radar 9502104)
</span>        <span class="enscript-comment">// So, do an explicit activity tickle
</span>        <span class="enscript-keyword">if</span> (wrangler)
            wrangler-&gt;activityTickle(0,0);
    }

    <span class="enscript-comment">// Log a timestamp for the initial full wake request.
</span>    <span class="enscript-comment">// System may not always honor this full wake request.
</span>    <span class="enscript-keyword">if</span> (!CAP_HIGHEST(kIOPMSystemCapabilityGraphics))
    {
        AbsoluteTime    now;
        uint64_t        nsec;

        clock_get_uptime(&amp;now);
        SUB_ABSOLUTETIME(&amp;now, &amp;systemWakeTime);
        absolutetime_to_nanoseconds(now, &amp;nsec);
        MSG(<span class="enscript-string">&quot;full wake %s (reason %u) %u ms\n&quot;</span>,
            promotion ? <span class="enscript-string">&quot;promotion&quot;</span> : <span class="enscript-string">&quot;request&quot;</span>,
            fullWakeReason, ((<span class="enscript-type">int</span>)((nsec) / 1000000ULL)));
    }
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// willEnterFullWake
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// System will enter full wake from sleep, from dark wake, or from dark
</span><span class="enscript-comment">// wake promotion. This function aggregate things that are in common to
</span><span class="enscript-comment">// all three full wake transitions.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Assumptions: fullWakeReason was updated
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::willEnterFullWake</span>( <span class="enscript-type">void</span> )
{
    hibernateRetry = false;
    sleepToStandby = false;
    sleepTimerMaintenance = false;

    _systemMessageClientMask = kSystemMessageClientPowerd |
                               kSystemMessageClientLegacyApp;

    <span class="enscript-keyword">if</span> ((_highestCapability &amp; kIOPMSystemCapabilityGraphics) == 0)
    {
        <span class="enscript-comment">// Initial graphics full power
</span>        _systemMessageClientMask |= kSystemMessageClientKernel;

        <span class="enscript-comment">// Set kIOPMUserTriggeredFullWakeKey before full wake for IOGraphics
</span>        setProperty(gIOPMUserTriggeredFullWakeKey,
            (kFullWakeReasonLocalUser == fullWakeReason) ?
                kOSBooleanTrue : kOSBooleanFalse);
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    IOHibernateSetWakeCapabilities(_pendingCapability);
#<span class="enscript-reference">endif</span>

    <span class="enscript-reference">IOService</span>::setAdvisoryTickleEnable( true );
    tellClients(kIOMessageSystemWillPowerOn);
    preventTransitionToUserActive(false);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// fullWakeDelayedWork
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// System has already entered full wake. Invoked by a delayed thread call.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::fullWakeDelayedWork</span>( <span class="enscript-type">void</span> )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DARK_TO_FULL_EVALUATE_CLAMSHELL</span>
    <span class="enscript-comment">// Not gated, don't modify state
</span>    <span class="enscript-keyword">if</span> ((kSystemTransitionNone == _systemTransitionType) &amp;&amp;
        CAP_CURRENT(kIOPMSystemCapabilityGraphics))
    {
        receivePowerNotification( kLocalEvalClamshellCommand );
    }
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// evaluateAssertions
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::evaluateAssertions</span>(IOPMDriverAssertionType newAssertions, IOPMDriverAssertionType oldAssertions)
{
    IOPMDriverAssertionType changedBits = newAssertions ^ oldAssertions;

    messageClients(kIOPMMessageDriverAssertionsChanged);

    <span class="enscript-keyword">if</span> (changedBits &amp; kIOPMDriverAssertionPreventDisplaySleepBit) {

        <span class="enscript-keyword">if</span> (wrangler) {
            <span class="enscript-type">bool</span> value = (newAssertions &amp; kIOPMDriverAssertionPreventDisplaySleepBit) ? true : false;

            DLOG(<span class="enscript-string">&quot;wrangler-&gt;setIgnoreIdleTimer\(%d)\n&quot;</span>, value);
            wrangler-&gt;setIgnoreIdleTimer( value );
        }
    }

    <span class="enscript-keyword">if</span> (changedBits &amp; kIOPMDriverAssertionCPUBit) {
        evaluatePolicy(kStimulusDarkWakeEvaluate);
        <span class="enscript-keyword">if</span> (!assertOnWakeSecs &amp;&amp; systemWakeTime) {
                AbsoluteTime    now;
                clock_usec_t    microsecs;
                clock_get_uptime(&amp;now);
                SUB_ABSOLUTETIME(&amp;now, &amp;systemWakeTime);
                absolutetime_to_microtime(now, &amp;assertOnWakeSecs, &amp;microsecs);
                <span class="enscript-keyword">if</span> (assertOnWakeReport)  {
                    HISTREPORT_TALLYVALUE(assertOnWakeReport, (int64_t)assertOnWakeSecs);
                    DLOG(<span class="enscript-string">&quot;Updated assertOnWake %lu\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)assertOnWakeSecs);
                }
        }
    }

    <span class="enscript-keyword">if</span> (changedBits &amp; kIOPMDriverAssertionReservedBit7) {
        <span class="enscript-type">bool</span> value = (newAssertions &amp; kIOPMDriverAssertionReservedBit7) ? true : false;
        <span class="enscript-keyword">if</span> (value) {
            DLOG(<span class="enscript-string">&quot;Driver assertion ReservedBit7 raised. Legacy IO preventing sleep\n&quot;</span>);
            updatePreventIdleSleepList(<span class="enscript-keyword">this</span>, true);
        }
        <span class="enscript-keyword">else</span> {
            DLOG(<span class="enscript-string">&quot;Driver assertion ReservedBit7 dropped\n&quot;</span>);
            updatePreventIdleSleepList(<span class="enscript-keyword">this</span>, false);
        }
    }
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Statistics
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// pmStats
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::pmStatsRecordEvent</span>(
    <span class="enscript-type">int</span>                 eventIndex,
    AbsoluteTime        timestamp)
{
    <span class="enscript-type">bool</span>        starting = eventIndex &amp; kIOPMStatsEventStartFlag ? true:false;
    <span class="enscript-type">bool</span>        stopping = eventIndex &amp; kIOPMStatsEventStopFlag ? true:false;
    uint64_t    delta;
    uint64_t    nsec;
    OSData *publishPMStats = NULL;

    eventIndex &amp;= ~(kIOPMStatsEventStartFlag | kIOPMStatsEventStopFlag);

    absolutetime_to_nanoseconds(timestamp, &amp;nsec);

    <span class="enscript-keyword">switch</span> (eventIndex) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMStatsHibernateImageWrite</span>:
            <span class="enscript-keyword">if</span> (starting)
                gPMStats.hibWrite.start = nsec;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (stopping)
                gPMStats.hibWrite.stop = nsec;

            <span class="enscript-keyword">if</span> (stopping) {
                delta = gPMStats.hibWrite.stop - gPMStats.hibWrite.start;
                IOLog(<span class="enscript-string">&quot;PMStats: Hibernate write took %qd ms\n&quot;</span>, delta/1000000ULL);
            }
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOPMStatsHibernateImageRead</span>:
            <span class="enscript-keyword">if</span> (starting)
                gPMStats.hibRead.start = nsec;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (stopping)
                gPMStats.hibRead.stop = nsec;

            <span class="enscript-keyword">if</span> (stopping) {
                delta = gPMStats.hibRead.stop - gPMStats.hibRead.start;
                IOLog(<span class="enscript-string">&quot;PMStats: Hibernate read took %qd ms\n&quot;</span>, delta/1000000ULL);

                publishPMStats = OSData::withBytes(&amp;gPMStats, <span class="enscript-keyword">sizeof</span>(gPMStats));
                setProperty(kIOPMSleepStatisticsKey, publishPMStats);
                publishPMStats-&gt;release();
                bzero(&amp;gPMStats, <span class="enscript-keyword">sizeof</span>(gPMStats));
            }
            <span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-comment">/*
 * Appends a record of the application response to
 * IOPMrootDomain::pmStatsAppResponses
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::pmStatsRecordApplicationResponse</span>(
    <span class="enscript-type">const</span> OSSymbol      *response,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span>          *name,
    <span class="enscript-type">int</span>                 messageType,
    uint32_t            delay_ms,
    <span class="enscript-type">int</span>                 app_pid,
    OSObject            *object,
    IOPMPowerStateIndex powerState)
{
    OSDictionary    *responseDescription    = NULL;
    OSNumber        *delayNum               = NULL;
    OSNumber        *powerCaps              = NULL;
    OSNumber        *pidNum                 = NULL;
    OSNumber        *msgNum                 = NULL;
    <span class="enscript-type">const</span> OSSymbol  *appname;
    <span class="enscript-type">const</span> OSSymbol  *sleep = NULL, *wake = NULL;
    IOPMServiceInterestNotifier *notify = 0;

    <span class="enscript-keyword">if</span> (object &amp;&amp; (notify = OSDynamicCast(IOPMServiceInterestNotifier, object)))
    {
        <span class="enscript-keyword">if</span> (response-&gt;isEqualTo(gIOPMStatsApplicationResponseTimedOut)) 
            notify-&gt;ackTimeoutCnt++;
        <span class="enscript-keyword">else</span>
            notify-&gt;ackTimeoutCnt = 0;

    }

    <span class="enscript-keyword">if</span> (response-&gt;isEqualTo(gIOPMStatsApplicationResponsePrompt) || 
         (_systemTransitionType == kSystemTransitionNone) || (_systemTransitionType == kSystemTransitionNewCapClient))
        <span class="enscript-keyword">return</span>;


    responseDescription = OSDictionary::withCapacity(5);
    <span class="enscript-keyword">if</span> (responseDescription)
    {
        <span class="enscript-keyword">if</span> (response) {
            responseDescription-&gt;setObject(_statsResponseTypeKey, response);
        }

        msgNum = OSNumber::withNumber(messageType, 32);
        <span class="enscript-keyword">if</span> (msgNum) {
            responseDescription-&gt;setObject(_statsMessageTypeKey, msgNum);
            msgNum-&gt;release();
        }

        <span class="enscript-keyword">if</span> (name &amp;&amp; (strlen(name) &gt; 0))
        {
            appname = OSSymbol::withCString(name);
            <span class="enscript-keyword">if</span> (appname) {
                responseDescription-&gt;setObject(_statsNameKey, appname);
                appname-&gt;release();
            }
        }

        <span class="enscript-keyword">if</span> (app_pid != -1) {
            pidNum = OSNumber::withNumber(app_pid, 32);
            <span class="enscript-keyword">if</span> (pidNum) {
                responseDescription-&gt;setObject(_statsPIDKey, pidNum);
                pidNum-&gt;release();
            }
        }

        delayNum = OSNumber::withNumber(delay_ms, 32);
        <span class="enscript-keyword">if</span> (delayNum) {
            responseDescription-&gt;setObject(_statsTimeMSKey, delayNum);
            delayNum-&gt;release();
        }

        <span class="enscript-keyword">if</span> (response-&gt;isEqualTo(gIOPMStatsDriverPSChangeSlow)) {
            powerCaps = OSNumber::withNumber(powerState, 32);

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>) &amp;&amp; (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
            IOLog(<span class="enscript-string">&quot;%s::powerStateChange type(%d) to(%lu) async took %d ms\n&quot;</span>,
                  name, messageType,
                  powerState, delay_ms);
#<span class="enscript-reference">endif</span>

        }
        <span class="enscript-keyword">else</span> {
            powerCaps = OSNumber::withNumber(_pendingCapability, 32);
        }
        <span class="enscript-keyword">if</span> (powerCaps) {
            responseDescription-&gt;setObject(_statsPowerCapsKey, powerCaps);
            powerCaps-&gt;release();
        }

        sleep = OSSymbol::withCString(<span class="enscript-string">&quot;Sleep&quot;</span>);
        wake = OSSymbol::withCString(<span class="enscript-string">&quot;Wake&quot;</span>);
        <span class="enscript-keyword">if</span> (_systemTransitionType == kSystemTransitionSleep)  {
            responseDescription-&gt;setObject(kIOPMStatsSystemTransitionKey, sleep);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_systemTransitionType == kSystemTransitionWake) {
            responseDescription-&gt;setObject(kIOPMStatsSystemTransitionKey, wake);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_systemTransitionType == kSystemTransitionCapability) {
            <span class="enscript-keyword">if</span> (CAP_LOSS(kIOPMSystemCapabilityGraphics))
                responseDescription-&gt;setObject(kIOPMStatsSystemTransitionKey, sleep);
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CAP_GAIN(kIOPMSystemCapabilityGraphics))
                responseDescription-&gt;setObject(kIOPMStatsSystemTransitionKey, wake);
        }
        <span class="enscript-keyword">if</span> (sleep) sleep-&gt;release();
        <span class="enscript-keyword">if</span> (wake) wake-&gt;release();



        IOLockLock(pmStatsLock);
        <span class="enscript-keyword">if</span> (pmStatsAppResponses &amp;&amp; pmStatsAppResponses-&gt;getCount() &lt; 50) {
            pmStatsAppResponses-&gt;setObject(responseDescription);
        }
        IOLockUnlock(pmStatsLock);

        responseDescription-&gt;release();
    }

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PMTraceWorker
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// TracePoint support
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOPMRegisterNVRAMTracePointHandlerKey</span>  \
        <span class="enscript-string">&quot;IOPMRegisterNVRAMTracePointHandler&quot;</span>

IOReturn <span class="enscript-function-name">IOPMrootDomain::callPlatformFunction</span>(
    <span class="enscript-type">const</span> OSSymbol * functionName,
    <span class="enscript-type">bool</span> waitForFunction,
    <span class="enscript-type">void</span> * param1, <span class="enscript-type">void</span> * param2,
    <span class="enscript-type">void</span> * param3, <span class="enscript-type">void</span> * param4 )
{
    <span class="enscript-keyword">if</span> (pmTracer &amp;&amp; functionName &amp;&amp;
        functionName-&gt;isEqualTo(kIOPMRegisterNVRAMTracePointHandlerKey) &amp;&amp;
        !pmTracer-&gt;tracePointHandler &amp;&amp; !pmTracer-&gt;tracePointTarget)
    {
        uint32_t    tracePointPhases, tracePointPCI;
        uint64_t    statusCode;

        pmTracer-&gt;tracePointHandler = (IOPMTracePointHandler) param1;
        pmTracer-&gt;tracePointTarget  = (<span class="enscript-type">void</span> *) param2;
        tracePointPCI               = (uint32_t)(uintptr_t) param3;
        tracePointPhases            = (uint32_t)(uintptr_t) param4;
        statusCode = (((uint64_t)tracePointPCI) &lt;&lt; 32) | tracePointPhases;
        <span class="enscript-keyword">if</span> ((tracePointPhases &gt;&gt; 24) != kIOPMTracePointSystemUp)
        {
            MSG(<span class="enscript-string">&quot;Sleep failure code 0x%08x 0x%08x\n&quot;</span>,
                tracePointPCI, tracePointPhases);
        }
        setProperty(kIOPMSleepWakeFailureCodeKey, statusCode, 64);
        pmTracer-&gt;tracePointHandler( pmTracer-&gt;tracePointTarget, 0, 0 );

        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (functionName &amp;&amp;
             functionName-&gt;isEqualTo(kIOPMInstallSystemSleepPolicyHandlerKey))
    {
        <span class="enscript-keyword">if</span> (gSleepPolicyHandler)
            <span class="enscript-keyword">return</span> kIOReturnExclusiveAccess;
        <span class="enscript-keyword">if</span> (!param1)
            <span class="enscript-keyword">return</span> kIOReturnBadArgument;
        gSleepPolicyHandler = (IOPMSystemSleepPolicyHandler) param1;
        gSleepPolicyTarget  = (<span class="enscript-type">void</span> *) param2;
        setProperty(<span class="enscript-string">&quot;IOPMSystemSleepPolicyHandler&quot;</span>, kOSBooleanTrue);
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> super::callPlatformFunction(
        functionName, waitForFunction, param1, param2, param3, param4);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::tracePoint</span>( uint8_t point )
{
    <span class="enscript-keyword">if</span> (systemBooting) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (kIOPMTracePointWakeCapabilityClients == point)
        acceptSystemWakeEvents(false);

    PMDebug(kPMLogSleepWakeTracePoint, point, 0);
    pmTracer-&gt;tracePoint(point);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::tracePoint</span>( uint8_t point, uint8_t data )
{
    <span class="enscript-keyword">if</span> (systemBooting) <span class="enscript-keyword">return</span>;

    PMDebug(kPMLogSleepWakeTracePoint, point, data);
    pmTracer-&gt;tracePoint(point, data);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::traceDetail</span>( uint32_t detail )
{
    <span class="enscript-keyword">if</span> (!systemBooting)
        pmTracer-&gt;traceDetail( detail );
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::configureReportGated</span>(uint64_t channel_id, uint64_t action, <span class="enscript-type">void</span> *result)
{
    size_t      reportSize;
    <span class="enscript-type">void</span>        **report = NULL;
    uint32_t    bktCnt;
    uint32_t    bktSize;
    uint32_t    *clientCnt;

    ASSERT_GATED();

    report = NULL;
    <span class="enscript-keyword">if</span> (channel_id == kAssertDelayChID) {
        report = &amp;assertOnWakeReport;
        bktCnt = kAssertDelayBcktCnt;
        bktSize = kAssertDelayBcktSize;
        clientCnt = &amp;assertOnWakeClientCnt;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (channel_id == kSleepDelaysChID) {
        report = &amp;sleepDelaysReport;
        bktCnt = kSleepDelaysBcktCnt;
        bktSize = kSleepDelaysBcktSize;
        clientCnt = &amp;sleepDelaysClientCnt;
    }

    <span class="enscript-keyword">switch</span> (action)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportEnable</span>:

            <span class="enscript-keyword">if</span> (*report) {
                (*clientCnt)++;
                <span class="enscript-keyword">break</span>;
            }

            reportSize = HISTREPORT_BUFSIZE(bktCnt);
            *report = IOMalloc(reportSize);
            <span class="enscript-keyword">if</span> (*report == NULL) {
                <span class="enscript-keyword">break</span>;
            }
            bzero(*report, reportSize);
            HISTREPORT_INIT(bktCnt, bktSize, *report, reportSize,
                                 getRegistryEntryID(), channel_id,  kIOReportCategoryPower);

            <span class="enscript-keyword">if</span> (channel_id == kAssertDelayChID)
                assertOnWakeSecs = 0;

            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportDisable</span>:
            <span class="enscript-keyword">if</span> (*clientCnt == 0) {
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">if</span> (*clientCnt == 1)
            {
                IOFree(*report, HISTREPORT_BUFSIZE(bktCnt));
                *report = NULL;
            }
            (*clientCnt)--;

            <span class="enscript-keyword">if</span> (channel_id == kAssertDelayChID)
                assertOnWakeSecs = -1;  <span class="enscript-comment">// Invalid value to prevent updates
</span>
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOReportGetDimensions</span>:
            <span class="enscript-keyword">if</span> (*report) {
                HISTREPORT_UPDATERES(*report, kIOReportGetDimensions, result);
            }
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span>;
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::configureReport</span>(IOReportChannelList    *channelList,
                                    IOReportConfigureAction action,
                                    <span class="enscript-type">void</span>                   *result,
                                    <span class="enscript-type">void</span>                   *destination)
{
    <span class="enscript-type">unsigned</span> cnt;
    uint64_t configAction = (uint64_t)action;

    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; channelList-&gt;nchannels; cnt++) {
        <span class="enscript-keyword">if</span> ( (channelList-&gt;channels[cnt].channel_id == kSleepCntChID) ||
               (channelList-&gt;channels[cnt].channel_id == kDarkWkCntChID) ||
               (channelList-&gt;channels[cnt].channel_id == kUserWkCntChID) ) {
            <span class="enscript-keyword">if</span> (action != kIOReportGetDimensions) <span class="enscript-keyword">continue</span>;
            SIMPLEREPORT_UPDATERES(kIOReportGetDimensions, result);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((channelList-&gt;channels[cnt].channel_id == kAssertDelayChID) ||
                 (channelList-&gt;channels[cnt].channel_id == kSleepDelaysChID)) {
            gIOPMWorkLoop-&gt;runAction(
                     OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>, &amp;IOPMrootDomain::configureReportGated),
                     (OSObject *)<span class="enscript-keyword">this</span>, (<span class="enscript-type">void</span> *)channelList-&gt;channels[cnt].channel_id,
                     (<span class="enscript-type">void</span> *)configAction, (<span class="enscript-type">void</span> *)result);
        }
    }

    <span class="enscript-keyword">return</span> super::configureReport(channelList, action, result, destination);
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::updateReportGated</span>(uint64_t ch_id, <span class="enscript-type">void</span> *result, IOBufferMemoryDescriptor *dest)
{

    uint32_t    size2cpy;
    <span class="enscript-type">void</span>        *data2cpy;
    <span class="enscript-type">void</span>        **report;

    ASSERT_GATED();

    report = NULL;
    <span class="enscript-keyword">if</span> (ch_id == kAssertDelayChID) {
        report = &amp;assertOnWakeReport;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ch_id == kSleepDelaysChID) {
        report = &amp;sleepDelaysReport;
    }

    <span class="enscript-keyword">if</span> (*report == NULL) {
        <span class="enscript-keyword">return</span> kIOReturnNotOpen;
    }

    HISTREPORT_UPDATEPREP(*report, data2cpy, size2cpy);
    <span class="enscript-keyword">if</span> (size2cpy &gt; (dest-&gt;getCapacity() - dest-&gt;getLength()) ) {
        <span class="enscript-keyword">return</span> kIOReturnOverrun;
    }

    HISTREPORT_UPDATERES(*report, kIOReportCopyChannelData, result);
    dest-&gt;appendBytes(data2cpy, size2cpy);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::updateReport</span>(IOReportChannelList      *channelList,
                                 IOReportUpdateAction      action,
                                 <span class="enscript-type">void</span>                     *result,
                                 <span class="enscript-type">void</span>                     *destination)
{
    uint32_t size2cpy;
    <span class="enscript-type">void</span> *data2cpy;
    uint8_t buf[SIMPLEREPORT_BUFSIZE];
    IOBufferMemoryDescriptor *dest = OSDynamicCast(IOBufferMemoryDescriptor, (OSObject *)destination);
    <span class="enscript-type">unsigned</span> cnt;
    uint64_t ch_id;

    <span class="enscript-keyword">if</span> (action != kIOReportCopyChannelData) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; channelList-&gt;nchannels; cnt++) {
        ch_id = channelList-&gt;channels[cnt].channel_id ;

        <span class="enscript-keyword">if</span> ((ch_id == kAssertDelayChID) || (ch_id == kSleepDelaysChID)) {
            gIOPMWorkLoop-&gt;runAction(
                     OSMemberFunctionCast(IOWorkLoop::Action, <span class="enscript-keyword">this</span>, &amp;IOPMrootDomain::updateReportGated),
                     (OSObject *)<span class="enscript-keyword">this</span>, (<span class="enscript-type">void</span> *)ch_id,
                     (<span class="enscript-type">void</span> *)result, (<span class="enscript-type">void</span> *)dest);
            <span class="enscript-keyword">continue</span>;

        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ch_id == kSleepCntChID) ||
                (ch_id == kDarkWkCntChID) || (ch_id == kUserWkCntChID)) {
            SIMPLEREPORT_INIT(buf, <span class="enscript-keyword">sizeof</span>(buf), getRegistryEntryID(), ch_id, kIOReportCategoryPower);
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span> (ch_id == kSleepCntChID)
            SIMPLEREPORT_SETVALUE(buf, sleepCnt);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ch_id == kDarkWkCntChID)
            SIMPLEREPORT_SETVALUE(buf, darkWakeCnt);
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ch_id == kUserWkCntChID)
            SIMPLEREPORT_SETVALUE(buf, displayWakeCnt);

        SIMPLEREPORT_UPDATEPREP(buf, data2cpy, size2cpy);
        SIMPLEREPORT_UPDATERES(kIOReportCopyChannelData, result);
        dest-&gt;appendBytes(data2cpy, size2cpy);
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span> super::updateReport(channelList, action, result, destination);
}


<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// PMTraceWorker Class
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(PMTraceWorker, OSObject)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kPMBestGuessPCIDevicesCount</span>     25
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kPMMaxRTCBitfieldSize</span>           32

PMTraceWorker *<span class="enscript-function-name">PMTraceWorker::tracer</span>(IOPMrootDomain *owner)
{
    PMTraceWorker           *me;

    me = OSTypeAlloc( PMTraceWorker );
    <span class="enscript-keyword">if</span> (!me || !me-&gt;init())
    {
        <span class="enscript-keyword">return</span> NULL;
    }

    DLOG(<span class="enscript-string">&quot;PMTraceWorker %p\n&quot;</span>, OBFUSCATE(me));

    <span class="enscript-comment">// Note that we cannot instantiate the PCI device -&gt; bit mappings here, since
</span>    <span class="enscript-comment">// the IODeviceTree has not yet been created by IOPlatformExpert. We create
</span>    <span class="enscript-comment">// this dictionary lazily.
</span>    me-&gt;owner = owner;
    me-&gt;pciDeviceBitMappings = NULL;
    me-&gt;pciMappingLock = IOLockAlloc();
    me-&gt;tracePhase = kIOPMTracePointSystemUp;
    me-&gt;loginWindowPhase = 0;
    me-&gt;traceData32 = 0;
    <span class="enscript-keyword">return</span> me;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::RTC_TRACE</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (tracePointHandler &amp;&amp; tracePointTarget)
    {
        uint32_t    wordA;

        wordA = (tracePhase &lt;&lt; 24) | (loginWindowPhase &lt;&lt; 16) |
                (traceData8 &lt;&lt; 8);

        tracePointHandler( tracePointTarget, traceData32, wordA );
        _LOG(<span class="enscript-string">&quot;RTC_TRACE wrote 0x%08x 0x%08x\n&quot;</span>, traceData32, wordA);
    }
}

<span class="enscript-type">int</span> <span class="enscript-function-name">PMTraceWorker::recordTopLevelPCIDevice</span>(IOService * pciDevice)
{
    <span class="enscript-type">const</span> OSSymbol *    deviceName;
    <span class="enscript-type">int</span>                 index = -1;

    IOLockLock(pciMappingLock);

    <span class="enscript-keyword">if</span> (!pciDeviceBitMappings)
    {
        pciDeviceBitMappings = OSArray::withCapacity(kPMBestGuessPCIDevicesCount);
        <span class="enscript-keyword">if</span> (!pciDeviceBitMappings)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-comment">// Check for bitmask overflow.
</span>    <span class="enscript-keyword">if</span> (pciDeviceBitMappings-&gt;getCount() &gt;= kPMMaxRTCBitfieldSize)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    <span class="enscript-keyword">if</span> ((deviceName = pciDevice-&gt;copyName()) &amp;&amp;
        (pciDeviceBitMappings-&gt;getNextIndexOfObject(deviceName, 0) == (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1) &amp;&amp;
        pciDeviceBitMappings-&gt;setObject(deviceName))
    {
        index = pciDeviceBitMappings-&gt;getCount() - 1;
        _LOG(<span class="enscript-string">&quot;PMTrace PCI array: set object %s =&gt; %d\n&quot;</span>,
            deviceName-&gt;getCStringNoCopy(), index);
    }
    <span class="enscript-keyword">if</span> (deviceName)
        deviceName-&gt;release();
    <span class="enscript-keyword">if</span> (!addedToRegistry &amp;&amp; (index &gt;= 0))
        addedToRegistry = owner-&gt;setProperty(<span class="enscript-string">&quot;PCITopLevel&quot;</span>, <span class="enscript-keyword">this</span>);

<span class="enscript-reference">exit</span>:
    IOLockUnlock(pciMappingLock);
    <span class="enscript-keyword">return</span> index;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">PMTraceWorker::serialize</span>(OSSerialize *s) <span class="enscript-type">const</span>
{
    <span class="enscript-type">bool</span> ok = false;
    <span class="enscript-keyword">if</span> (pciDeviceBitMappings)
    {
        IOLockLock(pciMappingLock);
        ok = pciDeviceBitMappings-&gt;serialize(s);
        IOLockUnlock(pciMappingLock);
    }
    <span class="enscript-keyword">return</span> ok;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::tracePoint</span>(uint8_t phase)
{
    <span class="enscript-comment">// clear trace detail when phase begins
</span>    <span class="enscript-keyword">if</span> (tracePhase != phase)
        traceData32 = 0;

    tracePhase = phase;

    DLOG(<span class="enscript-string">&quot;trace point 0x%02x\n&quot;</span>, tracePhase);
    RTC_TRACE();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::tracePoint</span>(uint8_t phase, uint8_t data8)
{
    <span class="enscript-comment">// clear trace detail when phase begins
</span>    <span class="enscript-keyword">if</span> (tracePhase != phase)
        traceData32 = 0;

    tracePhase = phase;
    traceData8 = data8;

    DLOG(<span class="enscript-string">&quot;trace point 0x%02x 0x%02x\n&quot;</span>, tracePhase, traceData8);
    RTC_TRACE();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::traceDetail</span>(uint32_t detail)
{
    <span class="enscript-keyword">if</span> (kIOPMTracePointSleepPriorityClients != tracePhase)
        <span class="enscript-keyword">return</span>;

    traceData32 = detail;
    DLOG(<span class="enscript-string">&quot;trace point 0x%02x detail 0x%08x\n&quot;</span>, tracePhase, traceData32);

    RTC_TRACE();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::traceLoginWindowPhase</span>(uint8_t phase)
{
    loginWindowPhase = phase;

    DLOG(<span class="enscript-string">&quot;loginwindow tracepoint 0x%02x\n&quot;</span>, loginWindowPhase);
    RTC_TRACE();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMTraceWorker::tracePCIPowerChange</span>(
    change_t type, IOService *service, uint32_t changeFlags, uint32_t bitNum)
{
    uint32_t    bitMask;
    uint32_t    expectedFlag;

    <span class="enscript-comment">// Ignore PCI changes outside of system sleep/wake.
</span>    <span class="enscript-keyword">if</span> ((kIOPMTracePointSleepPowerPlaneDrivers != tracePhase) &amp;&amp;
        (kIOPMTracePointWakePowerPlaneDrivers  != tracePhase))
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// Only record the WillChange transition when going to sleep,
</span>    <span class="enscript-comment">// and the DidChange on the way up.
</span>    changeFlags &amp;= (kIOPMDomainWillChange | kIOPMDomainDidChange);
    expectedFlag = (kIOPMTracePointSleepPowerPlaneDrivers == tracePhase) ?
                    kIOPMDomainWillChange : kIOPMDomainDidChange;
    <span class="enscript-keyword">if</span> (changeFlags != expectedFlag)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// Mark this device off in our bitfield
</span>    <span class="enscript-keyword">if</span> (bitNum &lt; kPMMaxRTCBitfieldSize)
    {
        bitMask = (1 &lt;&lt; bitNum);

        <span class="enscript-keyword">if</span> (kPowerChangeStart == type)
        {
            traceData32 |= bitMask;
            _LOG(<span class="enscript-string">&quot;PMTrace: Device %s started  - bit %2d mask 0x%08x =&gt; 0x%08x\n&quot;</span>,
                service-&gt;getName(), bitNum, bitMask, traceData32);
        }
        <span class="enscript-keyword">else</span>
        {
            traceData32 &amp;= ~bitMask;
            _LOG(<span class="enscript-string">&quot;PMTrace: Device %s finished - bit %2d mask 0x%08x =&gt; 0x%08x\n&quot;</span>,
                service-&gt;getName(), bitNum, bitMask, traceData32);
        }

        DLOG(<span class="enscript-string">&quot;trace point 0x%02x detail 0x%08x\n&quot;</span>, tracePhase, traceData32);
        RTC_TRACE();
    }
}

uint64_t  <span class="enscript-function-name">PMTraceWorker::getPMStatusCode</span>( )
{
    <span class="enscript-keyword">return</span> (((uint64_t)traceData32 &lt;&lt; 32) | ((uint64_t)tracePhase &lt;&lt; 24) |
            (loginWindowPhase &lt;&lt; 16) | (traceData8 &lt;&lt; 8));

}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PMHaltWorker
</span>
<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// PMHaltWorker Class
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//******************************************************************************
</span>
PMHaltWorker * <span class="enscript-function-name">PMHaltWorker::worker</span>( <span class="enscript-type">void</span> )
{
    PMHaltWorker *  me;
    IOThread        thread;

    <span class="enscript-keyword">do</span> {
        me = OSTypeAlloc( PMHaltWorker );
        <span class="enscript-keyword">if</span> (!me || !me-&gt;init())
            <span class="enscript-keyword">break</span>;

        me-&gt;lock = IOLockAlloc();
        <span class="enscript-keyword">if</span> (!me-&gt;lock)
            <span class="enscript-keyword">break</span>;

        DLOG(<span class="enscript-string">&quot;PMHaltWorker %p\n&quot;</span>, OBFUSCATE(me));
        me-&gt;retain();   <span class="enscript-comment">// thread holds extra retain
</span>        <span class="enscript-keyword">if</span> (KERN_SUCCESS != kernel_thread_start(&amp;PMHaltWorker::main, (<span class="enscript-type">void</span> *) me, &amp;thread))
        {
            me-&gt;release();
            <span class="enscript-keyword">break</span>;
        }
        thread_deallocate(thread);
        <span class="enscript-keyword">return</span> me;

    } <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">if</span> (me) me-&gt;release();
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMHaltWorker::free</span>( <span class="enscript-type">void</span> )
{
    DLOG(<span class="enscript-string">&quot;PMHaltWorker free %p\n&quot;</span>, OBFUSCATE(<span class="enscript-keyword">this</span>));
    <span class="enscript-keyword">if</span> (lock)
    {
        IOLockFree(lock);
        lock = 0;
    }
    <span class="enscript-keyword">return</span> OSObject::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMHaltWorker::main</span>( <span class="enscript-type">void</span> * arg, wait_result_t waitResult )
{
    PMHaltWorker * me = (PMHaltWorker *) arg;

    IOLockLock( gPMHaltLock );
    gPMHaltBusyCount++;
    me-&gt;depth = gPMHaltDepth;
    IOLockUnlock( gPMHaltLock );

    <span class="enscript-keyword">while</span> (me-&gt;depth &gt;= 0)
    {
        <span class="enscript-reference">PMHaltWorker</span>::work( me );

        IOLockLock( gPMHaltLock );
        <span class="enscript-keyword">if</span> (++gPMHaltIdleCount &gt;= gPMHaltBusyCount)
        {
            <span class="enscript-comment">// This is the last thread to finish work on this level,
</span>            <span class="enscript-comment">// inform everyone to start working on next lower level.
</span>            gPMHaltDepth--;
            me-&gt;depth = gPMHaltDepth;
            gPMHaltIdleCount = 0;
            thread_wakeup((event_t) &amp;gPMHaltIdleCount);
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">// One or more threads are still working on this level,
</span>            <span class="enscript-comment">// this thread must wait.
</span>            me-&gt;depth = gPMHaltDepth - 1;
            <span class="enscript-keyword">do</span> {
                IOLockSleep(gPMHaltLock, &amp;gPMHaltIdleCount, THREAD_UNINT);
            } <span class="enscript-keyword">while</span> (me-&gt;depth != gPMHaltDepth);
        }
        IOLockUnlock( gPMHaltLock );
    }

    <span class="enscript-comment">// No more work to do, terminate thread
</span>    DLOG(<span class="enscript-string">&quot;All done for worker: %p (visits = %u)\n&quot;</span>, OBFUSCATE(me), me-&gt;visits);
    thread_wakeup( &amp;gPMHaltDepth );
    me-&gt;release();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMHaltWorker::work</span>( PMHaltWorker * me )
{
    IOService *     service;
    OSSet *         inner;
    AbsoluteTime    startTime;
    UInt32          deltaTime;
    <span class="enscript-type">bool</span>            timeout;

    <span class="enscript-keyword">while</span> (true)
    {
        service = 0;
        timeout = false;

        <span class="enscript-comment">// Claim an unit of work from the shared pool
</span>        IOLockLock( gPMHaltLock );
        inner = (OSSet *)gPMHaltArray-&gt;getObject(me-&gt;depth);
        <span class="enscript-keyword">if</span> (inner)
        {
            service = (IOService *)inner-&gt;getAnyObject();
            <span class="enscript-keyword">if</span> (service)
            {
                service-&gt;retain();
                inner-&gt;removeObject(service);
            }
        }
        IOLockUnlock( gPMHaltLock );
        <span class="enscript-keyword">if</span> (!service)
            <span class="enscript-keyword">break</span>;  <span class="enscript-comment">// no more work at this depth
</span>
        clock_get_uptime(&amp;startTime);

        <span class="enscript-keyword">if</span> (!service-&gt;isInactive() &amp;&amp;
            service-&gt;setProperty(gPMHaltClientAcknowledgeKey, me))
        {
            IOLockLock(me-&gt;lock);
            me-&gt;startTime = startTime;
            me-&gt;service   = service;
            me-&gt;timeout   = false;
            IOLockUnlock(me-&gt;lock);

            service-&gt;systemWillShutdown( gPMHaltMessageType );

            <span class="enscript-comment">// Wait for driver acknowledgement
</span>            IOLockLock(me-&gt;lock);
            <span class="enscript-keyword">while</span> (service-&gt;getProperty(gPMHaltClientAcknowledgeKey))
            {
                IOLockSleep(me-&gt;lock, me, THREAD_UNINT);
            }
            me-&gt;service = 0;
            timeout = me-&gt;timeout;
            IOLockUnlock(me-&gt;lock);
        }

        deltaTime = computeDeltaTimeMS(&amp;startTime);
        <span class="enscript-keyword">if</span> ((deltaTime &gt; kPMHaltTimeoutMS) || timeout ||
            (gIOKitDebug &amp; kIOLogPMRootDomain))
        {
            LOG(<span class="enscript-string">&quot;%s driver %s (0x%llx) took %u ms\n&quot;</span>,
                (gPMHaltMessageType == kIOMessageSystemWillPowerOff) ?
                    <span class="enscript-string">&quot;PowerOff&quot;</span> : <span class="enscript-string">&quot;Restart&quot;</span>,
                service-&gt;getName(), service-&gt;getRegistryEntryID(),
                (uint32_t) deltaTime );
        }

        service-&gt;release();
        me-&gt;visits++;
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMHaltWorker::checkTimeout</span>( PMHaltWorker * me, AbsoluteTime * now )
{
    UInt64          nano;
    AbsoluteTime    startTime;
    AbsoluteTime    endTime;

    endTime = *now;

    IOLockLock(me-&gt;lock);
    <span class="enscript-keyword">if</span> (me-&gt;service &amp;&amp; !me-&gt;timeout)
    {
        startTime = me-&gt;startTime;
        nano = 0;
        <span class="enscript-keyword">if</span> (CMP_ABSOLUTETIME(&amp;endTime, &amp;startTime) &gt; 0)
        {
            SUB_ABSOLUTETIME(&amp;endTime, &amp;startTime);
            absolutetime_to_nanoseconds(endTime, &amp;nano);
        }
        <span class="enscript-keyword">if</span> (nano &gt; 3000000000ULL)
        {
            me-&gt;timeout = true;
            MSG(<span class="enscript-string">&quot;%s still waiting on %s\n&quot;</span>,
                (gPMHaltMessageType == kIOMessageSystemWillPowerOff) ?
                    <span class="enscript-string">&quot;PowerOff&quot;</span> : <span class="enscript-string">&quot;Restart&quot;</span>,
                me-&gt;service-&gt;getName());
        }
    }
    IOLockUnlock(me-&gt;lock);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// acknowledgeSystemWillShutdown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Acknowledgement from drivers that they have prepared for shutdown/restart.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::acknowledgeSystemWillShutdown</span>( IOService * from )
{
    PMHaltWorker *  worker;
    OSObject *      prop;

    <span class="enscript-keyword">if</span> (!from)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">//DLOG(&quot;%s acknowledged\n&quot;, from-&gt;getName());
</span>    prop = from-&gt;copyProperty( gPMHaltClientAcknowledgeKey );
    <span class="enscript-keyword">if</span> (prop)
    {
        worker = (PMHaltWorker *) prop;
        IOLockLock(worker-&gt;lock);
        from-&gt;removeProperty( gPMHaltClientAcknowledgeKey );
        thread_wakeup((event_t) worker);
        IOLockUnlock(worker-&gt;lock);
        worker-&gt;release();
    }
    <span class="enscript-keyword">else</span>
    {
        DLOG(<span class="enscript-string">&quot;%s acknowledged without worker property\n&quot;</span>,
            from-&gt;getName());
    }
}


<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// notifySystemShutdown
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Notify all objects in PM tree that system will shutdown or restart
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">notifySystemShutdown</span>( IOService * root, uint32_t messageType )
{
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PLACEHOLDER</span> ((OSSet *)gPMHaltArray)
    IORegistryIterator *    iter;
    IORegistryEntry *       entry;
    IOService *             node;
    OSSet *                 inner;
    PMHaltWorker *          workers[kPMHaltMaxWorkers];
    AbsoluteTime            deadline;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            totalNodes = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            depth;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            rootDepth;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            numWorkers;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            count;
    <span class="enscript-type">int</span>                     waitResult;
    <span class="enscript-type">void</span> *                  baseFunc;
    <span class="enscript-type">bool</span>                    ok;

    DLOG(<span class="enscript-string">&quot;%s msgType = 0x%x\n&quot;</span>, __FUNCTION__, messageType);

    baseFunc = OSMemberFunctionCast(<span class="enscript-type">void</span> *, root, &amp;IOService::systemWillShutdown);

    <span class="enscript-comment">// Iterate the entire PM tree starting from root
</span>
    rootDepth = root-&gt;getDepth( gIOPowerPlane );
    <span class="enscript-keyword">if</span> (!rootDepth) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    <span class="enscript-comment">// debug - for repeated test runs
</span>    <span class="enscript-keyword">while</span> (PMHaltWorker::metaClass-&gt;getInstanceCount())
        IOSleep(1);

    <span class="enscript-keyword">if</span> (!gPMHaltArray)
    {
        gPMHaltArray = OSArray::withCapacity(40);
        <span class="enscript-keyword">if</span> (!gPMHaltArray) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-comment">// debug
</span>        gPMHaltArray-&gt;flushCollection();

    <span class="enscript-keyword">if</span> (!gPMHaltLock)
    {
        gPMHaltLock = IOLockAlloc();
        <span class="enscript-keyword">if</span> (!gPMHaltLock) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    <span class="enscript-keyword">if</span> (!gPMHaltClientAcknowledgeKey)
    {
        gPMHaltClientAcknowledgeKey =
            <span class="enscript-reference">OSSymbol</span>::withCStringNoCopy(<span class="enscript-string">&quot;PMShutdown&quot;</span>);
        <span class="enscript-keyword">if</span> (!gPMHaltClientAcknowledgeKey) <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }

    gPMHaltMessageType = messageType;

    <span class="enscript-comment">// Depth-first walk of PM plane
</span>
    iter = IORegistryIterator::iterateOver(
        root, gIOPowerPlane, kIORegistryIterateRecursively);

    <span class="enscript-keyword">if</span> (iter)
    {
        <span class="enscript-keyword">while</span> ((entry = iter-&gt;getNextObject()))
        {
            node = OSDynamicCast(IOService, entry);
            <span class="enscript-keyword">if</span> (!node)
                <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> (baseFunc ==
                OSMemberFunctionCast(<span class="enscript-type">void</span> *, node, &amp;IOService::systemWillShutdown))
                <span class="enscript-keyword">continue</span>;

            depth = node-&gt;getDepth( gIOPowerPlane );
            <span class="enscript-keyword">if</span> (depth &lt;= rootDepth)
                <span class="enscript-keyword">continue</span>;

            ok = false;

            <span class="enscript-comment">// adjust to zero based depth
</span>            depth -= (rootDepth + 1);

            <span class="enscript-comment">// gPMHaltArray is an array of containers, each container
</span>            <span class="enscript-comment">// refers to nodes with the same depth.
</span>
            count = gPMHaltArray-&gt;getCount();
            <span class="enscript-keyword">while</span> (depth &gt;= count)
            {
                <span class="enscript-comment">// expand array and insert placeholders
</span>                gPMHaltArray-&gt;setObject(PLACEHOLDER);
                count++;
            }
            count = gPMHaltArray-&gt;getCount();
            <span class="enscript-keyword">if</span> (depth &lt; count)
            {
                inner = (OSSet *)gPMHaltArray-&gt;getObject(depth);
                <span class="enscript-keyword">if</span> (inner == PLACEHOLDER)
                {
                    inner = OSSet::withCapacity(40);
                    <span class="enscript-keyword">if</span> (inner)
                    {
                        gPMHaltArray-&gt;replaceObject(depth, inner);
                        inner-&gt;release();
                    }
                }

                <span class="enscript-comment">// PM nodes that appear more than once in the tree will have
</span>                <span class="enscript-comment">// the same depth, OSSet will refuse to add the node twice.
</span>                <span class="enscript-keyword">if</span> (inner)
                    ok = inner-&gt;setObject(node);
            }
            <span class="enscript-keyword">if</span> (!ok)
                DLOG(<span class="enscript-string">&quot;Skipped PM node %s\n&quot;</span>, node-&gt;getName());
        }
        iter-&gt;release();
    }

    <span class="enscript-comment">// debug only
</span>    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; (inner = (OSSet *)gPMHaltArray-&gt;getObject(i)); i++)
    {
        count = 0;
        <span class="enscript-keyword">if</span> (inner != PLACEHOLDER)
            count = inner-&gt;getCount();
        DLOG(<span class="enscript-string">&quot;Nodes at depth %u = %u\n&quot;</span>, i, count);
    }

    <span class="enscript-comment">// strip placeholders (not all depths are populated)
</span>    numWorkers = 0;
    <span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; (inner = (OSSet *)gPMHaltArray-&gt;getObject(i)); )
    {
        <span class="enscript-keyword">if</span> (inner == PLACEHOLDER)
        {
            gPMHaltArray-&gt;removeObject(i);
            <span class="enscript-keyword">continue</span>;
        }
        count = inner-&gt;getCount();
        <span class="enscript-keyword">if</span> (count &gt; numWorkers)
            numWorkers = count;
        totalNodes += count;
        i++;
    }

    <span class="enscript-keyword">if</span> (gPMHaltArray-&gt;getCount() == 0 || !numWorkers)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    gPMHaltBusyCount = 0;
    gPMHaltIdleCount = 0;
    gPMHaltDepth = gPMHaltArray-&gt;getCount() - 1;

    <span class="enscript-comment">// Create multiple workers (and threads)
</span>
    <span class="enscript-keyword">if</span> (numWorkers &gt; kPMHaltMaxWorkers)
        numWorkers = kPMHaltMaxWorkers;

    DLOG(<span class="enscript-string">&quot;PM nodes %u, maxDepth %u, workers %u\n&quot;</span>,
        totalNodes, gPMHaltArray-&gt;getCount(), numWorkers);

    <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0; i &lt; numWorkers; i++)
        workers[i] = PMHaltWorker::worker();

    <span class="enscript-comment">// Wait for workers to exhaust all available work
</span>
    IOLockLock(gPMHaltLock);
    <span class="enscript-keyword">while</span> (gPMHaltDepth &gt;= 0)
    {
        clock_interval_to_deadline(1000, kMillisecondScale, &amp;deadline);

        waitResult = IOLockSleepDeadline(
            gPMHaltLock, &amp;gPMHaltDepth, deadline, THREAD_UNINT);
        <span class="enscript-keyword">if</span> (THREAD_TIMED_OUT == waitResult)
        {
            AbsoluteTime now;
            clock_get_uptime(&amp;now);

            IOLockUnlock(gPMHaltLock);
            <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0 ; i &lt; numWorkers; i++)
            {
                <span class="enscript-keyword">if</span> (workers[i])
                    <span class="enscript-reference">PMHaltWorker</span>::checkTimeout(workers[i], &amp;now);
            }
            IOLockLock(gPMHaltLock);
        }
    }
    IOLockUnlock(gPMHaltLock);

    <span class="enscript-comment">// Release all workers
</span>
    <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0; i &lt; numWorkers; i++)
    {
        <span class="enscript-keyword">if</span> (workers[i])
            workers[i]-&gt;release();
        <span class="enscript-comment">// worker also retained by it's own thread
</span>    }

<span class="enscript-reference">done</span>:
    DLOG(<span class="enscript-string">&quot;%s done\n&quot;</span>, __FUNCTION__);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Kernel Assertion
</span>
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOPMDriverAssertionID <span class="enscript-function-name">IOPMrootDomain::createPMAssertion</span>(
    IOPMDriverAssertionType whichAssertionBits,
    IOPMDriverAssertionLevel assertionLevel,
    IOService *ownerService,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ownerDescription)
{
    IOReturn            ret;
    IOPMDriverAssertionID     newAssertion;

    <span class="enscript-keyword">if</span> (!pmAssertions)
        <span class="enscript-keyword">return</span> 0;

    ret = pmAssertions-&gt;createAssertion(whichAssertionBits, assertionLevel, ownerService, ownerDescription, &amp;newAssertion);

    <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
        <span class="enscript-keyword">return</span> newAssertion;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> 0;
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::releasePMAssertion</span>(IOPMDriverAssertionID releaseAssertion)
{
    <span class="enscript-keyword">if</span> (!pmAssertions)
        <span class="enscript-keyword">return</span> kIOReturnInternalError;

    <span class="enscript-keyword">return</span> pmAssertions-&gt;releaseAssertion(releaseAssertion);
}


IOReturn <span class="enscript-function-name">IOPMrootDomain::setPMAssertionLevel</span>(
    IOPMDriverAssertionID assertionID,
    IOPMDriverAssertionLevel assertionLevel)
{
    <span class="enscript-keyword">return</span> pmAssertions-&gt;setAssertionLevel(assertionID, assertionLevel);
}

IOPMDriverAssertionLevel <span class="enscript-function-name">IOPMrootDomain::getPMAssertionLevel</span>(IOPMDriverAssertionType whichAssertion)
{
    IOPMDriverAssertionType       sysLevels;

    <span class="enscript-keyword">if</span> (!pmAssertions || whichAssertion == 0)
        <span class="enscript-keyword">return</span> kIOPMDriverAssertionLevelOff;

    sysLevels = pmAssertions-&gt;getActivatedAssertions();

    <span class="enscript-comment">// Check that every bit set in argument 'whichAssertion' is asserted
</span>    <span class="enscript-comment">// in the aggregate bits.
</span>    <span class="enscript-keyword">if</span> ((sysLevels &amp; whichAssertion) == whichAssertion)
        <span class="enscript-keyword">return</span> kIOPMDriverAssertionLevelOn;
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> kIOPMDriverAssertionLevelOff;
}

IOReturn <span class="enscript-function-name">IOPMrootDomain::setPMAssertionUserLevels</span>(IOPMDriverAssertionType inLevels)
{
    <span class="enscript-keyword">if</span> (!pmAssertions)
        <span class="enscript-keyword">return</span> kIOReturnNotFound;

    <span class="enscript-keyword">return</span> pmAssertions-&gt;setUserAssertionLevels(inLevels);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::serializeProperties</span>( OSSerialize * s ) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">if</span> (pmAssertions)
    {
        pmAssertions-&gt;publishProperties();
    }
    <span class="enscript-keyword">return</span>( IOService::serializeProperties(s) );
}

OSObject * <span class="enscript-function-name">IOPMrootDomain::copyProperty</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * aKey) <span class="enscript-type">const</span>
{
    OSObject *obj = NULL;
    obj = IOService::copyProperty(aKey);

    <span class="enscript-keyword">if</span> (obj)  <span class="enscript-keyword">return</span> obj;

    <span class="enscript-keyword">if</span> (!strncmp(aKey, kIOPMSleepWakeWdogRebootKey,
                        <span class="enscript-keyword">sizeof</span>(kIOPMSleepWakeWdogRebootKey))) {
        <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_BOOT_BY_SW_WDOG)
            <span class="enscript-keyword">return</span> kOSBooleanTrue;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">return</span> kOSBooleanFalse;

    }

    <span class="enscript-keyword">if</span> (!strncmp(aKey, kIOPMSleepWakeWdogLogsValidKey,
                        <span class="enscript-keyword">sizeof</span>(kIOPMSleepWakeWdogLogsValidKey))) {
        <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_VALID_LOGS)
            <span class="enscript-keyword">return</span> kOSBooleanTrue;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">return</span> kOSBooleanFalse;

    }

    <span class="enscript-comment">/*
     * XXX: We should get rid of &quot;DesktopMode&quot; property  when 'kAppleClamshellCausesSleepKey'
     * is set properly in darwake from sleep. For that, kIOPMEnableClamshell msg has to be
     * issued by DisplayWrangler on darkwake.
     */</span>
    <span class="enscript-keyword">if</span> (!strcmp(aKey, <span class="enscript-string">&quot;DesktopMode&quot;</span>)) {
        <span class="enscript-keyword">if</span> (desktopMode)
            <span class="enscript-keyword">return</span> kOSBooleanTrue;
        <span class="enscript-keyword">else</span>
            <span class="enscript-keyword">return</span> kOSBooleanFalse;
    }
    <span class="enscript-keyword">if</span> (!strcmp(aKey, <span class="enscript-string">&quot;DisplayIdleForDemandSleep&quot;</span>)) {
        <span class="enscript-keyword">if</span> (displayIdleForDemandSleep) {
            <span class="enscript-keyword">return</span> kOSBooleanTrue;
        }
        <span class="enscript-keyword">else</span>  {
            <span class="enscript-keyword">return</span> kOSBooleanFalse;
        }
    }

    <span class="enscript-keyword">if</span> (!strcmp(aKey, kIOPMDriverWakeEventsKey))
    {
        OSArray * array = 0;
        WAKEEVENT_LOCK();
        <span class="enscript-keyword">if</span> (_systemWakeEventsArray &amp;&amp; _systemWakeEventsArray-&gt;getCount()) {
            OSCollection *collection = _systemWakeEventsArray-&gt;copyCollection();
            <span class="enscript-keyword">if</span> (collection &amp;&amp; !(array = OSDynamicCast(OSArray, collection))) {
                collection-&gt;release();
            }
        }
        WAKEEVENT_UNLOCK();
        <span class="enscript-keyword">return</span> array;
    }

    <span class="enscript-keyword">if</span> (!strcmp(aKey, kIOPMSleepStatisticsAppsKey))
    {
        OSArray * array = 0;
        IOLockLock(pmStatsLock);
        <span class="enscript-keyword">if</span> (pmStatsAppResponses &amp;&amp; pmStatsAppResponses-&gt;getCount()) {
            OSCollection *collection = pmStatsAppResponses-&gt;copyCollection();
            <span class="enscript-keyword">if</span> (collection &amp;&amp; !(array = OSDynamicCast(OSArray, collection))) {
                collection-&gt;release();
            }
            pmStatsAppResponses-&gt;flushCollection();
        }
        IOLockUnlock(pmStatsLock);
        <span class="enscript-keyword">return</span> array;
    }

    <span class="enscript-keyword">if</span> (!strcmp(aKey, kIOPMIdleSleepPreventersKey))
    {
        OSArray *idleSleepList = NULL;
        gRootDomain-&gt;copySleepPreventersList(&amp;idleSleepList, NULL);
        <span class="enscript-keyword">return</span> idleSleepList;
    }

    <span class="enscript-keyword">if</span> (!strcmp(aKey, kIOPMSystemSleepPreventersKey))
    {
        OSArray *systemSleepList = NULL;
        gRootDomain-&gt;copySleepPreventersList(NULL, &amp;systemSleepList);
        <span class="enscript-keyword">return</span> systemSleepList;
    }

    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: Wake Event Reporting
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::copyWakeReasonString</span>( <span class="enscript-type">char</span> * outBuf, size_t bufSize )
{
    WAKEEVENT_LOCK();
    strlcpy(outBuf, gWakeReasonString, bufSize);
    WAKEEVENT_UNLOCK();
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// acceptSystemWakeEvents
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Private control for the acceptance of driver wake event claims.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::acceptSystemWakeEvents</span>( <span class="enscript-type">bool</span> accept )
{
    <span class="enscript-type">bool</span> logWakeReason = false;

    WAKEEVENT_LOCK();
    <span class="enscript-keyword">if</span> (accept)
    {
        gWakeReasonString[0] = <span class="enscript-string">'\0'</span>;
        <span class="enscript-keyword">if</span> (!_systemWakeEventsArray)
            _systemWakeEventsArray = OSArray::withCapacity(4);
        <span class="enscript-keyword">if</span> ((_acceptSystemWakeEvents = (_systemWakeEventsArray != 0)))
            _systemWakeEventsArray-&gt;flushCollection();
    }
    <span class="enscript-keyword">else</span>
    {
        _acceptSystemWakeEvents = false;
    }
    WAKEEVENT_UNLOCK();

    <span class="enscript-keyword">if</span> (logWakeReason)
        MSG(<span class="enscript-string">&quot;system wake events:%s\n&quot;</span>, gWakeReasonString);
}

<span class="enscript-comment">//******************************************************************************
</span><span class="enscript-comment">// claimSystemWakeEvent
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// For a driver to claim a device is the source/conduit of a system wake event.
</span><span class="enscript-comment">//******************************************************************************
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::claimSystemWakeEvent</span>(
    IOService *     device,
    IOOptionBits    flags,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *    reason,
    OSObject *      details )
{
    <span class="enscript-type">const</span> OSSymbol *    deviceName   = 0;
    OSNumber *          deviceRegId  = 0;
    OSNumber *          claimTime    = 0;
    OSData *            flagsData    = 0;
    OSString *          reasonString = 0;
    OSDictionary *      d = 0;
    uint64_t            timestamp;
    <span class="enscript-type">bool</span>                ok = false;

    pmEventTimeStamp(&amp;timestamp);

    <span class="enscript-keyword">if</span> (!device || !reason) <span class="enscript-keyword">return</span>;

    deviceName   = device-&gt;copyName(gIOServicePlane);
    deviceRegId  = OSNumber::withNumber(device-&gt;getRegistryEntryID(), 64);
    claimTime    = OSNumber::withNumber(timestamp, 64);
    flagsData    = OSData::withBytes(&amp;flags, <span class="enscript-keyword">sizeof</span>(flags));
    reasonString = OSString::withCString(reason);
    d = OSDictionary::withCapacity(5 + (details ? 1 : 0));
    <span class="enscript-keyword">if</span> (!deviceName || !deviceRegId || !claimTime || !flagsData || !reasonString)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

    d-&gt;setObject(gIONameKey, deviceName);
    d-&gt;setObject(gIORegistryEntryIDKey, deviceRegId);
    d-&gt;setObject(kIOPMWakeEventTimeKey, claimTime);
    d-&gt;setObject(kIOPMWakeEventFlagsKey, flagsData);
    d-&gt;setObject(kIOPMWakeEventReasonKey, reasonString);
    <span class="enscript-keyword">if</span> (details)
        d-&gt;setObject(kIOPMWakeEventDetailsKey, details);

    WAKEEVENT_LOCK();
    <span class="enscript-keyword">if</span> (!gWakeReasonSysctlRegistered)
    {
        <span class="enscript-comment">// Lazy registration until the platform driver stops registering
</span>        <span class="enscript-comment">// the same name.
</span>        gWakeReasonSysctlRegistered = true;
    }
    <span class="enscript-keyword">if</span> (_acceptSystemWakeEvents)
    {
        ok = _systemWakeEventsArray-&gt;setObject(d);
        <span class="enscript-keyword">if</span> (gWakeReasonString[0] != <span class="enscript-string">'\0'</span>)
            strlcat(gWakeReasonString, <span class="enscript-string">&quot; &quot;</span>, <span class="enscript-keyword">sizeof</span>(gWakeReasonString));
        strlcat(gWakeReasonString, reason, <span class="enscript-keyword">sizeof</span>(gWakeReasonString));
    }
    WAKEEVENT_UNLOCK();

<span class="enscript-reference">done</span>:
    <span class="enscript-keyword">if</span> (deviceName)   deviceName-&gt;release();
    <span class="enscript-keyword">if</span> (deviceRegId)  deviceRegId-&gt;release();
    <span class="enscript-keyword">if</span> (claimTime)    claimTime-&gt;release();
    <span class="enscript-keyword">if</span> (flagsData)    flagsData-&gt;release();
    <span class="enscript-keyword">if</span> (reasonString) reasonString-&gt;release();
    <span class="enscript-keyword">if</span> (d) d-&gt;release();
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PMSettingHandle
</span>
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( PMSettingHandle, OSObject )

<span class="enscript-type">void</span> <span class="enscript-function-name">PMSettingHandle::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (pmso)
    {
        pmso-&gt;clientHandleFreed();
        pmso-&gt;release();
        pmso = 0;
    }

    <span class="enscript-reference">OSObject</span>::free();
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PMSettingObject
</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>( PMSettingObject, OSObject )

<span class="enscript-comment">/*
 * Static constructor/initializer for PMSettingObject
 */</span>
PMSettingObject *<span class="enscript-function-name">PMSettingObject::pmSettingObject</span>(
    IOPMrootDomain                      *parent_arg,
    IOPMSettingControllerCallback       handler_arg,
    OSObject                            *target_arg,
    uintptr_t                           refcon_arg,
    uint32_t                            supportedPowerSources,
    <span class="enscript-type">const</span> OSSymbol *                    settings[],
    OSObject                            **handle_obj)
{
    uint32_t                            settingCount = 0;
    PMSettingObject                     *pmso = 0;
    PMSettingHandle                     *pmsh = 0;

    <span class="enscript-keyword">if</span> ( !parent_arg || !handler_arg || !settings || !handle_obj )
        <span class="enscript-keyword">return</span> NULL;

    <span class="enscript-comment">// count OSSymbol entries in NULL terminated settings array
</span>    <span class="enscript-keyword">while</span> (settings[settingCount]) {
        settingCount++;
    }
    <span class="enscript-keyword">if</span> (0 == settingCount)
        <span class="enscript-keyword">return</span> NULL;

    pmso = <span class="enscript-keyword">new</span> PMSettingObject;
    <span class="enscript-keyword">if</span> (!pmso || !pmso-&gt;init())
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

    pmsh = <span class="enscript-keyword">new</span> PMSettingHandle;
    <span class="enscript-keyword">if</span> (!pmsh || !pmsh-&gt;init())
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

    queue_init(&amp;pmso-&gt;calloutQueue);
    pmso-&gt;parent       = parent_arg;
    pmso-&gt;func         = handler_arg;
    pmso-&gt;target       = target_arg;
    pmso-&gt;refcon       = refcon_arg;
    pmso-&gt;settingCount = settingCount;

    pmso-&gt;retain();     <span class="enscript-comment">// handle holds a retain on pmso
</span>    pmsh-&gt;pmso = pmso;
    pmso-&gt;pmsh = pmsh;

    pmso-&gt;publishedFeatureID = (uint32_t *)IOMalloc(<span class="enscript-keyword">sizeof</span>(uint32_t)*settingCount);
    <span class="enscript-keyword">if</span> (pmso-&gt;publishedFeatureID) {
        <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i=0; i&lt;settingCount; i++) {
            <span class="enscript-comment">// Since there is now at least one listener to this setting, publish
</span>            <span class="enscript-comment">// PM root domain support for it.
</span>            parent_arg-&gt;publishPMSetting( settings[i],
                    supportedPowerSources, &amp;pmso-&gt;publishedFeatureID[i] );
        }
    }

    *handle_obj = pmsh;
    <span class="enscript-keyword">return</span> pmso;

<span class="enscript-reference">fail</span>:
    <span class="enscript-keyword">if</span> (pmso) pmso-&gt;release();
    <span class="enscript-keyword">if</span> (pmsh) pmsh-&gt;release();
    <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMSettingObject::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (publishedFeatureID) {
        <span class="enscript-keyword">for</span> (uint32_t i=0; i&lt;settingCount; i++) {
            <span class="enscript-keyword">if</span> (publishedFeatureID[i]) {
                parent-&gt;removePublishedFeature( publishedFeatureID[i] );
            }
        }

        IOFree(publishedFeatureID, <span class="enscript-keyword">sizeof</span>(uint32_t) * settingCount);
    }

    <span class="enscript-reference">super</span>::free();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMSettingObject::dispatchPMSetting</span>( <span class="enscript-type">const</span> OSSymbol * type, OSObject * object )
{
    (*func)(target, type, object, refcon);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMSettingObject::clientHandleFreed</span>( <span class="enscript-type">void</span> )
{
    parent-&gt;deregisterPMSettingObject(<span class="enscript-keyword">this</span>);
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: PMAssertionsTracker
</span>
<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">// class PMAssertionsTracker Implementation
</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kAssertUniqueIDStart</span>    500

PMAssertionsTracker *<span class="enscript-function-name">PMAssertionsTracker::pmAssertionsTracker</span>( IOPMrootDomain *rootDomain )
{
    PMAssertionsTracker    *myself;

    myself = <span class="enscript-keyword">new</span> PMAssertionsTracker;

    <span class="enscript-keyword">if</span> (myself) {
        myself-&gt;init();
        myself-&gt;owner = rootDomain;
        myself-&gt;issuingUniqueID = kAssertUniqueIDStart;
        myself-&gt;assertionsArray = OSArray::withCapacity(5);
        myself-&gt;assertionsKernel = 0;
        myself-&gt;assertionsUser = 0;
        myself-&gt;assertionsCombined = 0;
        myself-&gt;assertionsArrayLock = IOLockAlloc();
        myself-&gt;tabulateProducerCount = myself-&gt;tabulateConsumerCount = 0;

        <span class="enscript-keyword">if</span> (!myself-&gt;assertionsArray || !myself-&gt;assertionsArrayLock)
            myself = NULL;
    }

    <span class="enscript-keyword">return</span> myself;
}

<span class="enscript-comment">/* tabulate
 * - Update assertionsKernel to reflect the state of all
 * assertions in the kernel.
 * - Update assertionsCombined to reflect both kernel &amp; user space.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">PMAssertionsTracker::tabulate</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> count;
    PMAssertStruct      *_a = NULL;
    OSData              *_d = NULL;

    IOPMDriverAssertionType oldKernel = assertionsKernel;
    IOPMDriverAssertionType oldCombined = assertionsCombined;

    ASSERT_GATED();

    assertionsKernel = 0;
    assertionsCombined = 0;

    <span class="enscript-keyword">if</span> (!assertionsArray)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> ((count = assertionsArray-&gt;getCount()))
    {
        <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
        {
            _d = OSDynamicCast(OSData, assertionsArray-&gt;getObject(i));
            <span class="enscript-keyword">if</span> (_d)
            {
                _a = (PMAssertStruct *)_d-&gt;getBytesNoCopy();
                <span class="enscript-keyword">if</span> (_a &amp;&amp; (kIOPMDriverAssertionLevelOn == _a-&gt;level))
                    assertionsKernel |= _a-&gt;assertionBits;
            }
        }
    }

    tabulateProducerCount++;
    assertionsCombined = assertionsKernel | assertionsUser;

    <span class="enscript-keyword">if</span> ((assertionsKernel != oldKernel) ||
        (assertionsCombined != oldCombined))
    {
        owner-&gt;evaluateAssertions(assertionsCombined, oldCombined);
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">PMAssertionsTracker::publishProperties</span>( <span class="enscript-type">void</span> )
{
    OSArray             *assertionsSummary = NULL;

    <span class="enscript-keyword">if</span> (tabulateConsumerCount != tabulateProducerCount)
    {
        IOLockLock(assertionsArrayLock);

        tabulateConsumerCount = tabulateProducerCount;

        <span class="enscript-comment">/* Publish the IOPMrootDomain property &quot;DriverPMAssertionsDetailed&quot;
         */</span>
        assertionsSummary = copyAssertionsArray();
        <span class="enscript-keyword">if</span> (assertionsSummary)
        {
            owner-&gt;setProperty(kIOPMAssertionsDriverDetailedKey, assertionsSummary);
            assertionsSummary-&gt;release();
        }
        <span class="enscript-keyword">else</span>
        {
            owner-&gt;removeProperty(kIOPMAssertionsDriverDetailedKey);
        }

        <span class="enscript-comment">/* Publish the IOPMrootDomain property &quot;DriverPMAssertions&quot;
         */</span>
        owner-&gt;setProperty(kIOPMAssertionsDriverKey, assertionsKernel, 64);

        IOLockUnlock(assertionsArrayLock);
    }
}

PMAssertionsTracker::PMAssertStruct *PMAssertionsTracker::detailsForID(IOPMDriverAssertionID _id, <span class="enscript-type">int</span> *index)
{
    PMAssertStruct      *_a = NULL;
    OSData              *_d = NULL;
    <span class="enscript-type">int</span>                 found = -1;
    <span class="enscript-type">int</span>                 count = 0;
    <span class="enscript-type">int</span>                 i = 0;

    <span class="enscript-keyword">if</span> (assertionsArray
        &amp;&amp; (count = assertionsArray-&gt;getCount()))
    {
        <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
        {
            _d = OSDynamicCast(OSData, assertionsArray-&gt;getObject(i));
            <span class="enscript-keyword">if</span> (_d)
            {
                _a = (PMAssertStruct *)_d-&gt;getBytesNoCopy();
                <span class="enscript-keyword">if</span> (_a &amp;&amp; (_id == _a-&gt;id)) {
                    found = i;
                    <span class="enscript-keyword">break</span>;
                }
            }
        }
    }

    <span class="enscript-keyword">if</span> (-1 == found) {
        <span class="enscript-keyword">return</span> NULL;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (index)
            *index = found;
        <span class="enscript-keyword">return</span> _a;
    }
}

<span class="enscript-comment">/* PMAssertionsTracker::handleCreateAssertion
 * Perform assertion work on the PM workloop. Do not call directly.
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::handleCreateAssertion</span>(OSData *newAssertion)
{
    ASSERT_GATED();

    <span class="enscript-keyword">if</span> (newAssertion)
    {
        IOLockLock(assertionsArrayLock);
        assertionsArray-&gt;setObject(newAssertion);
        IOLockUnlock(assertionsArrayLock);
        newAssertion-&gt;release();

        tabulate();
    }
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* PMAssertionsTracker::createAssertion
 * createAssertion allocates memory for a new PM assertion, and affects system behavior, if
 * appropiate.
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::createAssertion</span>(
    IOPMDriverAssertionType which,
    IOPMDriverAssertionLevel level,
    IOService *serviceID,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *whoItIs,
    IOPMDriverAssertionID *outID)
{
    OSData          *dataStore = NULL;
    PMAssertStruct  track;

    <span class="enscript-comment">// Warning: trillions and trillions of created assertions may overflow the unique ID.
</span>    track.id = OSIncrementAtomic64((SInt64*) &amp;issuingUniqueID);
    track.level = level;
    track.assertionBits = which;
    track.ownerString = whoItIs ? OSSymbol::withCString(whoItIs):0;
    track.ownerService = serviceID;
    track.registryEntryID = serviceID ? serviceID-&gt;getRegistryEntryID():0;
    track.modifiedTime = 0;
    pmEventTimeStamp(&amp;track.createdTime);

    dataStore = OSData::withBytes(&amp;track, <span class="enscript-keyword">sizeof</span>(PMAssertStruct));
    <span class="enscript-keyword">if</span> (!dataStore)
    {
        <span class="enscript-keyword">if</span> (track.ownerString)
            track.ownerString-&gt;release();
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;
    }

    *outID = track.id;

    <span class="enscript-keyword">if</span> (owner &amp;&amp; owner-&gt;pmPowerStateQueue) {
        owner-&gt;pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventAssertionCreate, (<span class="enscript-type">void</span> *)dataStore);
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* PMAssertionsTracker::handleReleaseAssertion
 * Runs in PM workloop. Do not call directly.
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::handleReleaseAssertion</span>(
    IOPMDriverAssertionID _id)
{
    ASSERT_GATED();

    <span class="enscript-type">int</span>             index;
    PMAssertStruct  *assertStruct = detailsForID(_id, &amp;index);

    <span class="enscript-keyword">if</span> (!assertStruct)
        <span class="enscript-keyword">return</span> kIOReturnNotFound;

    IOLockLock(assertionsArrayLock);
    <span class="enscript-keyword">if</span> (assertStruct-&gt;ownerString)
        assertStruct-&gt;ownerString-&gt;release();

    assertionsArray-&gt;removeObject(index);
    IOLockUnlock(assertionsArrayLock);

    tabulate();
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* PMAssertionsTracker::releaseAssertion
 * Releases an assertion and affects system behavior if appropiate.
 * Actual work happens on PM workloop.
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::releaseAssertion</span>(
    IOPMDriverAssertionID _id)
{
    <span class="enscript-keyword">if</span> (owner &amp;&amp; owner-&gt;pmPowerStateQueue) {
        owner-&gt;pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventAssertionRelease, 0, _id);
    }
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* PMAssertionsTracker::handleSetAssertionLevel
 * Runs in PM workloop. Do not call directly.
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::handleSetAssertionLevel</span>(
    IOPMDriverAssertionID    _id,
    IOPMDriverAssertionLevel _level)
{
    PMAssertStruct      *assertStruct = detailsForID(_id, NULL);

    ASSERT_GATED();

    <span class="enscript-keyword">if</span> (!assertStruct) {
        <span class="enscript-keyword">return</span> kIOReturnNotFound;
    }

    IOLockLock(assertionsArrayLock);
    pmEventTimeStamp(&amp;assertStruct-&gt;modifiedTime);
    assertStruct-&gt;level = _level;
    IOLockUnlock(assertionsArrayLock);

    tabulate();
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* PMAssertionsTracker::setAssertionLevel
 */</span>
IOReturn <span class="enscript-function-name">PMAssertionsTracker::setAssertionLevel</span>(
    IOPMDriverAssertionID    _id,
    IOPMDriverAssertionLevel _level)
{
    <span class="enscript-keyword">if</span> (owner &amp;&amp; owner-&gt;pmPowerStateQueue) {
        owner-&gt;pmPowerStateQueue-&gt;submitPowerEvent(kPowerEventAssertionSetLevel,
                (<span class="enscript-type">void</span> *)(uintptr_t)_level, _id);
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">PMAssertionsTracker::handleSetUserAssertionLevels</span>(<span class="enscript-type">void</span> * arg0)
{
    IOPMDriverAssertionType new_user_levels = *(IOPMDriverAssertionType *) arg0;

    ASSERT_GATED();

    <span class="enscript-keyword">if</span> (new_user_levels != assertionsUser)
    {
        assertionsUser = new_user_levels;
        DLOG(<span class="enscript-string">&quot;assertionsUser 0x%llx\n&quot;</span>, assertionsUser);
    }

    tabulate();
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">PMAssertionsTracker::setUserAssertionLevels</span>(
    IOPMDriverAssertionType new_user_levels)
{
    <span class="enscript-keyword">if</span> (gIOPMWorkLoop) {
        gIOPMWorkLoop-&gt;runAction(
            OSMemberFunctionCast(
                <span class="enscript-reference">IOWorkLoop</span>::Action,
                <span class="enscript-keyword">this</span>,
                &amp;PMAssertionsTracker::handleSetUserAssertionLevels),
            <span class="enscript-keyword">this</span>,
            (<span class="enscript-type">void</span> *) &amp;new_user_levels, 0, 0, 0);
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}


OSArray *<span class="enscript-function-name">PMAssertionsTracker::copyAssertionsArray</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> count;
    <span class="enscript-type">int</span> i;
    OSArray     *outArray = NULL;

    <span class="enscript-keyword">if</span> (!assertionsArray ||
        (0 == (count = assertionsArray-&gt;getCount())) ||
        (NULL == (outArray = OSArray::withCapacity(count))))
    {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">for</span> (i=0; i&lt;count; i++)
    {
        PMAssertStruct  *_a = NULL;
        OSData          *_d = NULL;
        OSDictionary    *details = NULL;

        _d = OSDynamicCast(OSData, assertionsArray-&gt;getObject(i));
        <span class="enscript-keyword">if</span> (_d &amp;&amp; (_a = (PMAssertStruct *)_d-&gt;getBytesNoCopy()))
        {
            OSNumber        *_n = NULL;

            details = OSDictionary::withCapacity(7);
            <span class="enscript-keyword">if</span> (!details)
                <span class="enscript-keyword">continue</span>;

            outArray-&gt;setObject(details);
            details-&gt;release();

            _n = OSNumber::withNumber(_a-&gt;id, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionIDKey, _n);
                _n-&gt;release();
            }
            _n = OSNumber::withNumber(_a-&gt;createdTime, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionCreatedTimeKey, _n);
                _n-&gt;release();
            }
            _n = OSNumber::withNumber(_a-&gt;modifiedTime, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionModifiedTimeKey, _n);
                _n-&gt;release();
            }
            _n = OSNumber::withNumber((uintptr_t)_a-&gt;registryEntryID, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionRegistryEntryIDKey, _n);
                _n-&gt;release();
            }
            _n = OSNumber::withNumber(_a-&gt;level, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionLevelKey, _n);
                _n-&gt;release();
            }
            _n = OSNumber::withNumber(_a-&gt;assertionBits, 64);
            <span class="enscript-keyword">if</span> (_n) {
                details-&gt;setObject(kIOPMDriverAssertionAssertedKey, _n);
                _n-&gt;release();
            }

            <span class="enscript-keyword">if</span> (_a-&gt;ownerString) {
                details-&gt;setObject(kIOPMDriverAssertionOwnerStringKey, _a-&gt;ownerString);
            }
        }
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span> outArray;
}

IOPMDriverAssertionType <span class="enscript-function-name">PMAssertionsTracker::getActivatedAssertions</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> assertionsCombined;
}

IOPMDriverAssertionLevel <span class="enscript-function-name">PMAssertionsTracker::getAssertionLevel</span>(
    IOPMDriverAssertionType type)
{
    <span class="enscript-keyword">if</span> (type &amp;&amp; ((type &amp; assertionsKernel) == assertionsKernel))
    {
        <span class="enscript-keyword">return</span> kIOPMDriverAssertionLevelOn;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">return</span> kIOPMDriverAssertionLevelOff;
    }
}

<span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//*********************************************************************************
</span><span class="enscript-comment">//*********************************************************************************
</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pmEventTimeStamp</span>(uint64_t *recordTS)
{
    clock_sec_t     tsec;
    clock_usec_t    tusec;

    <span class="enscript-keyword">if</span> (!recordTS)
        <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// We assume tsec fits into 32 bits; 32 bits holds enough
</span>    <span class="enscript-comment">// seconds for 136 years since the epoch in 1970.
</span>    clock_get_calendar_microtime(&amp;tsec, &amp;tusec);


    <span class="enscript-comment">// Pack the sec &amp; microsec calendar time into a uint64_t, for fun.
</span>    *recordTS = 0;
    *recordTS |= (uint32_t)tusec;
    *recordTS |= ((uint64_t)tsec &lt;&lt; 32);

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">// MARK: -
</span><span class="enscript-comment">// MARK: IORootParent
</span>
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-function-name">OSDefineMetaClassAndFinalStructors</span>(IORootParent, IOService)

<span class="enscript-comment">// The reason that root domain needs a root parent is to facilitate demand
</span><span class="enscript-comment">// sleep, since a power change from the root parent cannot be vetoed.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// The above statement is no longer true since root domain now performs
</span><span class="enscript-comment">// demand sleep using overrides. But root parent remains to avoid changing
</span><span class="enscript-comment">// the power tree stacking. Root parent is parked at the max power state.
</span>

<span class="enscript-type">static</span> IOPMPowerState patriarchPowerStates[2] =
{
    {1,0,ON_POWER,0,0,0,0,0,0,0,0,0},
    {1,0,ON_POWER,0,0,0,0,0,0,0,0,0},
};

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::initialize</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IORootParent::start</span>( IOService * nub )
{
    <span class="enscript-reference">IOService</span>::start(nub);
    attachToParent( getRegistryRoot(), gIOPowerPlane );
    PMinit();
    registerPowerDriver(<span class="enscript-keyword">this</span>, patriarchPowerStates, 2);
    makeUsable();
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::shutDownSystem</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::restartSystem</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::sleepSystem</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::dozeSystem</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::sleepToDoze</span>( <span class="enscript-type">void</span> )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORootParent::wakeSystem</span>( <span class="enscript-type">void</span> )
{
}

OSObject * <span class="enscript-function-name">IORootParent::copyProperty</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * aKey) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span> (IOService::copyProperty(aKey));
}


#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
IOReturn <span class="enscript-function-name">IOPMrootDomain::restartWithStackshot</span>()
{
    <span class="enscript-keyword">if</span> ((swd_flags &amp; SWD_WDOG_ENABLED) == 0)
        <span class="enscript-keyword">return</span> kIOReturnError;

    takeStackshot(true, true, false);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugTrig</span>(<span class="enscript-type">bool</span> wdogTrigger)
{
    takeStackshot(wdogTrigger, false, false);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::takeStackshot</span>(<span class="enscript-type">bool</span> wdogTrigger, <span class="enscript-type">bool</span> isOSXWatchdog, <span class="enscript-type">bool</span> isSpinDump)
{
   swd_hdr *         hdr = NULL;
   addr64_t          data[3];
   uint32_t          wdog_panic = 0;
   <span class="enscript-type">int</span>               cnt = 0;
   pid_t             pid = 0;
   uint32_t          flags;

   <span class="enscript-type">char</span> *            dstAddr;
   uint32_t          size;
   uint32_t          bytesRemaining;
   <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>      len;
   OSString *        UUIDstring = NULL;
   uint64_t          code;
   IOMemoryMap *     logBufMap = NULL;

   swd_stackshot_hdr *stackshotHdr = NULL;

   uint32_t          bufSize;
   uint32_t          initialStackSize;

   <span class="enscript-keyword">if</span> (isSpinDump) {
       <span class="enscript-keyword">if</span> (_systemTransitionType != kSystemTransitionSleep &amp;&amp;
           _systemTransitionType != kSystemTransitionWake)
           <span class="enscript-keyword">return</span>;
   } <span class="enscript-keyword">else</span> {
       <span class="enscript-keyword">if</span> ( kIOSleepWakeWdogOff &amp; gIOKitDebug )
           <span class="enscript-keyword">return</span>;
   }

   <span class="enscript-keyword">if</span> (wdogTrigger) {
       <span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;swd_panic&quot;</span>, &amp;wdog_panic, <span class="enscript-keyword">sizeof</span>(wdog_panic)) &amp;&amp;
                  (wdog_panic == 1)) {
           <span class="enscript-comment">// If boot-arg is set to panic on sleep/wake hang, call panic
</span>           panic(<span class="enscript-string">&quot;Sleep/Wake hang detected\n&quot;</span>);
           <span class="enscript-keyword">return</span>;
       }
       <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_BOOT_BY_SW_WDOG) {
           <span class="enscript-comment">// If current boot is due to this watch dog trigger restart in previous boot,
</span>           <span class="enscript-comment">// then don't trigger again until at least 1 successful sleep &amp; wake.
</span>           <span class="enscript-keyword">if</span> (!(sleepCnt &amp;&amp; (displayWakeCnt || darkWakeCnt))) {
               IOLog(<span class="enscript-string">&quot;Shutting down due to repeated Sleep/Wake failures\n&quot;</span>);
               PEHaltRestart(kPEHaltCPU);
               <span class="enscript-keyword">return</span>;
           }
       }

   }

   <span class="enscript-keyword">if</span> (isSpinDump) {
      <span class="enscript-keyword">if</span> (gSpinDumpBufferFull)
         <span class="enscript-keyword">return</span>;
      <span class="enscript-keyword">if</span> (swd_spindump_buffer == NULL) {
         sleepWakeDebugSpinDumpMemAlloc();
         <span class="enscript-keyword">if</span> (swd_spindump_buffer == NULL) <span class="enscript-keyword">return</span>;
      }

      bufSize = SWD_SPINDUMP_SIZE;
      initialStackSize = SWD_INITIAL_SPINDUMP_SIZE;
   } <span class="enscript-keyword">else</span> {
      <span class="enscript-keyword">if</span> (sleepWakeDebugIsWdogEnabled() == false)
         <span class="enscript-keyword">return</span>;

      <span class="enscript-keyword">if</span> (swd_buffer == NULL) {
         sleepWakeDebugMemAlloc();
         <span class="enscript-keyword">if</span> (swd_buffer == NULL) <span class="enscript-keyword">return</span>;
      }

      bufSize = SWD_BUF_SIZE;
      initialStackSize = SWD_INITIAL_STACK_SIZE;
   }

   <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
       <span class="enscript-keyword">return</span>;

   <span class="enscript-keyword">if</span> (isSpinDump)
      hdr = (swd_hdr *)swd_spindump_buffer;
   <span class="enscript-keyword">else</span>
      hdr = (swd_hdr *)swd_buffer;
   memset(hdr-&gt;UUID, 0x20, <span class="enscript-keyword">sizeof</span>(hdr-&gt;UUID));
   <span class="enscript-keyword">if</span> ((UUIDstring = OSDynamicCast(OSString, getProperty(kIOPMSleepWakeUUIDKey))) != NULL ) {

      <span class="enscript-keyword">if</span> (wdogTrigger || (!UUIDstring-&gt;isEqualTo(hdr-&gt;UUID))) {
         <span class="enscript-type">const</span> <span class="enscript-type">char</span> *str = UUIDstring-&gt;getCStringNoCopy();
         snprintf(hdr-&gt;UUID, <span class="enscript-keyword">sizeof</span>(hdr-&gt;UUID), <span class="enscript-string">&quot;UUID: %s&quot;</span>, str);
      }
      <span class="enscript-keyword">else</span> {
         DLOG(<span class="enscript-string">&quot;Data for current UUID already exists\n&quot;</span>);
         <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
      }
   }

   dstAddr = (<span class="enscript-type">char</span>*)hdr + hdr-&gt;spindump_offset;
   bytesRemaining = bufSize - hdr-&gt;spindump_offset;

   <span class="enscript-comment">/* if AppleOSXWatchdog triggered the stackshot, set the flag in the heaer */</span>
   hdr-&gt;is_osx_watchdog = isOSXWatchdog;

   DLOG(<span class="enscript-string">&quot;Taking snapshot. bytesRemaining: %d\n&quot;</span>, bytesRemaining);

   <span class="enscript-keyword">while</span> (bytesRemaining &gt; <span class="enscript-keyword">sizeof</span>(swd_stackshot_hdr)) {

       stackshotHdr = (swd_stackshot_hdr *)dstAddr;
       stackshotHdr-&gt;magic = SWD_STACKSHOTHDR_MAGIC;
       stackshotHdr-&gt;size = 0;
       bytesRemaining -= <span class="enscript-keyword">sizeof</span>(swd_stackshot_hdr);
       dstAddr += <span class="enscript-keyword">sizeof</span>(swd_stackshot_hdr);

       <span class="enscript-keyword">if</span> (isOSXWatchdog) {
           pid = -1;
           size = bytesRemaining;
           flags = STACKSHOT_SAVE_LOADINFO | STACKSHOT_SAVE_KEXT_LOADINFO;
       }
       <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cnt == 0) {
           <span class="enscript-comment">/* 
            * Take stackshot of all process on first sample. Size is restricted
            * to SWD_INITIAL_STACK_SIZE
            */</span>
           pid = -1;
           size = (bytesRemaining &gt; initialStackSize) ? initialStackSize : bytesRemaining;
           flags = STACKSHOT_SAVE_LOADINFO | STACKSHOT_SAVE_KEXT_LOADINFO|STACKSHOT_SAVE_KERNEL_FRAMES_ONLY;
       }
       <span class="enscript-keyword">else</span> {
           <span class="enscript-comment">/* Take sample of kernel threads only */</span>
           pid = 0;
           size = bytesRemaining;
           flags = 0;
       }

       stack_snapshot_from_kernel(pid, dstAddr, size, flags, &amp;stackshotHdr-&gt;size);

       dstAddr += stackshotHdr-&gt;size;
       bytesRemaining -= stackshotHdr-&gt;size;

       DLOG(<span class="enscript-string">&quot;Sample: %d size: %d bytesRemaining: %d\n&quot;</span>, cnt, stackshotHdr-&gt;size, bytesRemaining);
       <span class="enscript-keyword">if</span> ((stackshotHdr-&gt;size == 0) || (++cnt == 10))
           <span class="enscript-keyword">break</span>;
       IOSleep(10); <span class="enscript-comment">// 10 ms
</span>   }

   hdr-&gt;spindump_size = (bufSize - bytesRemaining - hdr-&gt;spindump_offset);


   memset(hdr-&gt;cps, 0x20, <span class="enscript-keyword">sizeof</span>(hdr-&gt;cps));
   snprintf(hdr-&gt;cps, <span class="enscript-keyword">sizeof</span>(hdr-&gt;cps), <span class="enscript-string">&quot;\ncps: %d&quot;</span>, ((IOService*)<span class="enscript-keyword">this</span>)-&gt;getPowerState());
   code = pmTracer-&gt;getPMStatusCode();
   memset(hdr-&gt;PMStatusCode, 0x20, <span class="enscript-keyword">sizeof</span>(hdr-&gt;PMStatusCode));
   snprintf(hdr-&gt;PMStatusCode, <span class="enscript-keyword">sizeof</span>(hdr-&gt;PMStatusCode), <span class="enscript-string">&quot;\nCode: %08x %08x&quot;</span>,
           (uint32_t)((code &gt;&gt; 32) &amp; 0xffffffff), (uint32_t)(code &amp; 0xffffffff));
   memset(hdr-&gt;reason, 0x20, <span class="enscript-keyword">sizeof</span>(hdr-&gt;reason));
   <span class="enscript-keyword">if</span> (isSpinDump) {
      snprintf(hdr-&gt;reason, <span class="enscript-keyword">sizeof</span>(hdr-&gt;reason), <span class="enscript-string">&quot;\nStackshot reason: PSC Delay\n\n&quot;</span>);
      gRootDomain-&gt;swd_lock = 0;
      gSpinDumpBufferFull = true;
      <span class="enscript-keyword">return</span>;
   }
   snprintf(hdr-&gt;reason, <span class="enscript-keyword">sizeof</span>(hdr-&gt;reason), <span class="enscript-string">&quot;\nStackshot reason: Watchdog\n\n&quot;</span>);


   data[0] = round_page(<span class="enscript-keyword">sizeof</span>(swd_hdr) + hdr-&gt;spindump_size);
   <span class="enscript-comment">/* Header &amp; rootdomain log is constantly changing and  is not covered by CRC */</span>
   data[1] = hdr-&gt;crc = crc32(0, ((<span class="enscript-type">char</span>*)swd_buffer+hdr-&gt;spindump_offset), hdr-&gt;spindump_size);
   data[2] = kvtophys((vm_offset_t)swd_buffer);
   len = <span class="enscript-keyword">sizeof</span>(addr64_t)*3;
   DLOG(<span class="enscript-string">&quot;bytes: 0x%llx crc:0x%llx paddr:0x%llx\n&quot;</span>,
         data[0], data[1], data[2]);

   <span class="enscript-keyword">if</span> (PEWriteNVRAMProperty(kIOSleepWakeDebugKey, data, len) == false)
   {
      DLOG(<span class="enscript-string">&quot;Failed to update nvram boot-args\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

<span class="enscript-reference">exit</span>:

   gRootDomain-&gt;swd_lock = 0;

   <span class="enscript-keyword">if</span> (wdogTrigger) {
      IOLog(<span class="enscript-string">&quot;Restarting to collect Sleep wake debug logs\n&quot;</span>);
      PEHaltRestart(kPERestartCPU);
   }
   <span class="enscript-keyword">else</span> {
     logBufMap = sleepWakeDebugRetrieve();
      <span class="enscript-keyword">if</span> (logBufMap) {
          sleepWakeDebugDumpFromMem(logBufMap);
          logBufMap-&gt;release();
          logBufMap = 0;
      }
   }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugMemAlloc</span>( )
{
    vm_size_t    size = SWD_BUF_SIZE;

    swd_hdr      *hdr = NULL;

    IOBufferMemoryDescriptor  *memDesc = NULL;


    <span class="enscript-keyword">if</span> ( kIOSleepWakeWdogOff &amp; gIOKitDebug )
      <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
       <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// Try allocating above 4GB. If that fails, try at 2GB
</span>    memDesc = IOBufferMemoryDescriptor::inTaskWithPhysicalMask(
                            kernel_task, kIOMemoryPhysicallyContiguous|kIOMemoryMapperNone,
                            size, 0xFFFFFFFF00000000ULL);
    <span class="enscript-keyword">if</span> (!memDesc) {
       memDesc = IOBufferMemoryDescriptor::inTaskWithPhysicalMask(
                            kernel_task, kIOMemoryPhysicallyContiguous|kIOMemoryMapperNone,
                            size, 0xFFFFFFFF10000000ULL);
    }

    <span class="enscript-keyword">if</span> (memDesc == NULL)
    {
      DLOG(<span class="enscript-string">&quot;Failed to allocate Memory descriptor for sleepWake debug\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }


    hdr = (swd_hdr *)memDesc-&gt;getBytesNoCopy();
    memset(hdr, 0, <span class="enscript-keyword">sizeof</span>(swd_hdr));

    hdr-&gt;signature = SWD_HDR_SIGNATURE;
    hdr-&gt;alloc_size = size;

    hdr-&gt;spindump_offset = <span class="enscript-keyword">sizeof</span>(swd_hdr);
    swd_buffer = (<span class="enscript-type">void</span> *)hdr;
    DLOG(<span class="enscript-string">&quot;SleepWake debug buffer size:0x%x spindump offset:0x%x\n&quot;</span>, hdr-&gt;alloc_size, hdr-&gt;spindump_offset);

<span class="enscript-reference">exit</span>:
    gRootDomain-&gt;swd_lock = 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugSpinDumpMemAlloc</span>( )
{
    vm_size_t    size = SWD_SPINDUMP_SIZE;

    swd_hdr      *hdr = NULL;

    IOBufferMemoryDescriptor  *memDesc = NULL;

    <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
        <span class="enscript-keyword">return</span>;

    memDesc = IOBufferMemoryDescriptor::inTaskWithOptions(
                            kernel_task, kIODirectionIn|kIOMemoryMapperNone,
                            SWD_SPINDUMP_SIZE);

    <span class="enscript-keyword">if</span> (memDesc == NULL)
    {
        DLOG(<span class="enscript-string">&quot;Failed to allocate Memory descriptor for sleepWake debug spindump\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }


    hdr = (swd_hdr *)memDesc-&gt;getBytesNoCopy();
    memset(hdr, 0, <span class="enscript-keyword">sizeof</span>(swd_hdr));

    hdr-&gt;signature = SWD_HDR_SIGNATURE;
    hdr-&gt;alloc_size = size;

    hdr-&gt;spindump_offset = <span class="enscript-keyword">sizeof</span>(swd_hdr);
    swd_spindump_buffer = (<span class="enscript-type">void</span> *)hdr;

<span class="enscript-reference">exit</span>:
    gRootDomain-&gt;swd_lock = 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugEnableWdog</span>()
{
    swd_flags |= SWD_WDOG_ENABLED;
    <span class="enscript-keyword">if</span> (!swd_buffer)
        sleepWakeDebugMemAlloc();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugIsWdogEnabled</span>()
{
    <span class="enscript-keyword">return</span> ((swd_flags &amp; SWD_WDOG_ENABLED) &amp;&amp;
            !systemBooting &amp;&amp; !systemShutdown &amp;&amp; !gWillShutdown);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugSaveSpinDumpFile</span>()
{
    swd_hdr *hdr = NULL;
    errno_t error = EIO;

    <span class="enscript-keyword">if</span> (swd_spindump_buffer &amp;&amp; gSpinDumpBufferFull) {
        hdr = (swd_hdr *)swd_spindump_buffer;

        error = sleepWakeDebugSaveFile(<span class="enscript-string">&quot;/var/tmp/SleepWakeDelayStacks.dump&quot;</span>,
                        (<span class="enscript-type">char</span>*)hdr+hdr-&gt;spindump_offset, hdr-&gt;spindump_size);

        <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">return</span>;

        sleepWakeDebugSaveFile(<span class="enscript-string">&quot;/var/tmp/SleepWakeDelayLog.dump&quot;</span>,
                         (<span class="enscript-type">char</span>*)hdr+offsetof(swd_hdr, UUID),
                         <span class="enscript-keyword">sizeof</span>(swd_hdr)-offsetof(swd_hdr, UUID));

        gSpinDumpBufferFull = false;
    }
}

errno_t <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugSaveFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> len)
{
   <span class="enscript-type">struct</span> vnode         *vp = NULL;
   vfs_context_t        ctx = vfs_context_create(vfs_context_current());
   kauth_cred_t         cred = vfs_context_ucred(ctx);
   <span class="enscript-type">struct</span> vnode_attr    va;
   errno_t      error = EIO;

   <span class="enscript-keyword">if</span> (vnode_open(name, (O_CREAT | FWRITE | O_NOFOLLOW),
                        S_IRUSR|S_IRGRP|S_IROTH, VNODE_LOOKUP_NOFOLLOW, &amp;vp, ctx) != 0)
   {
      IOLog(<span class="enscript-string">&quot;Failed to open the file %s\n&quot;</span>, name);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }
   VATTR_INIT(&amp;va);
   VATTR_WANTED(&amp;va, va_nlink);
   <span class="enscript-comment">/* Don't dump to non-regular files or files with links. */</span>
   <span class="enscript-keyword">if</span> (vp-&gt;v_type != VREG ||
        vnode_getattr(vp, &amp;va, ctx) || va.va_nlink != 1) {
        IOLog(<span class="enscript-string">&quot;Bailing as this is not a regular file\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    VATTR_INIT(&amp;va);
    VATTR_SET(&amp;va, va_data_size, 0);
    vnode_setattr(vp, &amp;va, ctx);


    error = vn_rdwr(UIO_WRITE, vp, buf, len, 0,
        UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, (<span class="enscript-type">int</span> *) 0,  vfs_context_proc(ctx));
    <span class="enscript-keyword">if</span> (error != 0)
       IOLog(<span class="enscript-string">&quot;Failed to save sleep wake log. err 0x%x\n&quot;</span>, error);
    <span class="enscript-keyword">else</span>
       DLOG(<span class="enscript-string">&quot;Saved %d bytes to file %s\n&quot;</span>,len, name);

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (vp) vnode_close(vp, FWRITE, ctx);
    <span class="enscript-keyword">if</span> (ctx) vfs_context_rele(ctx);

    <span class="enscript-keyword">return</span> error;

}

errno_t <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugCopyFile</span>(
                               <span class="enscript-type">struct</span> vnode *srcVp, 
                               vfs_context_t srcCtx,
                               <span class="enscript-type">char</span> *tmpBuf, uint64_t tmpBufSize,
                               uint64_t srcOffset, 
                               <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dstFname, 
                               uint64_t numBytes,
                               uint32_t crc)
{
   <span class="enscript-type">struct</span> vnode         *vp = NULL;
   vfs_context_t        ctx = vfs_context_create(vfs_context_current());
   <span class="enscript-type">struct</span> vnode_attr    va;
   errno_t      error = EIO;
   uint64_t bytesToRead, bytesToWrite;
   uint64_t readFileOffset, writeFileOffset, srcDataOffset; 
   uint32_t newcrc = 0;

   <span class="enscript-keyword">if</span> (vnode_open(dstFname, (O_CREAT | FWRITE | O_NOFOLLOW), 
                        S_IRUSR|S_IRGRP|S_IROTH, VNODE_LOOKUP_NOFOLLOW, &amp;vp, ctx) != 0) 
   {
      DLOG(<span class="enscript-string">&quot;Failed to open the file %s\n&quot;</span>, dstFname);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }
   VATTR_INIT(&amp;va);
   VATTR_WANTED(&amp;va, va_nlink);
   <span class="enscript-comment">/* Don't dump to non-regular files or files with links. */</span>
   <span class="enscript-keyword">if</span> (vp-&gt;v_type != VREG ||
        vnode_getattr(vp, &amp;va, ctx) || va.va_nlink != 1) {
        DLOG(<span class="enscript-string">&quot;Bailing as this is not a regular file\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
    VATTR_INIT(&amp;va);	
    VATTR_SET(&amp;va, va_data_size, 0);
    vnode_setattr(vp, &amp;va, ctx);
   
    writeFileOffset = 0;
    <span class="enscript-keyword">while</span>(numBytes) {
        bytesToRead = (round_page(numBytes) &gt; tmpBufSize) ? tmpBufSize : round_page(numBytes);
        readFileOffset = trunc_page(srcOffset);

       DLOG(<span class="enscript-string">&quot;Read file (numBytes:0x%llx offset:0x%llx)\n&quot;</span>, bytesToRead, readFileOffset);
       error = vn_rdwr(UIO_READ, srcVp, tmpBuf, bytesToRead, readFileOffset,
               UIO_SYSSPACE, IO_SKIP_ENCRYPTION|IO_SYNC|IO_NODELOCKED|IO_UNIT|IO_NOCACHE, 
               vfs_context_ucred(srcCtx), (<span class="enscript-type">int</span> *) 0,
               vfs_context_proc(srcCtx));
       <span class="enscript-keyword">if</span> (error) {
           DLOG(<span class="enscript-string">&quot;Failed to read file(numBytes:0x%llx)\n&quot;</span>, bytesToRead);
           <span class="enscript-keyword">break</span>;
       }

       srcDataOffset = (uint64_t)tmpBuf + (srcOffset - readFileOffset);
       bytesToWrite = bytesToRead - (srcOffset - readFileOffset);
       <span class="enscript-keyword">if</span> (bytesToWrite &gt; numBytes) bytesToWrite = numBytes;

       <span class="enscript-keyword">if</span> (crc) {
           newcrc = crc32(newcrc, (<span class="enscript-type">void</span> *)srcDataOffset, bytesToWrite);
       }
       DLOG(<span class="enscript-string">&quot;Write file (numBytes:0x%llx offset:0x%llx)\n&quot;</span>, bytesToWrite, writeFileOffset);
       error = vn_rdwr(UIO_WRITE, vp, (<span class="enscript-type">char</span> *)srcDataOffset, bytesToWrite, writeFileOffset,
               UIO_SYSSPACE, IO_SYNC|IO_NODELOCKED|IO_UNIT, 
               vfs_context_ucred(ctx), (<span class="enscript-type">int</span> *) 0,
               vfs_context_proc(ctx));
       <span class="enscript-keyword">if</span> (error) {
           DLOG(<span class="enscript-string">&quot;Failed to write file(numBytes:0x%llx)\n&quot;</span>, bytesToWrite);
           <span class="enscript-keyword">break</span>;
       }

       writeFileOffset += bytesToWrite;
       numBytes -= bytesToWrite;
       srcOffset += bytesToWrite;

    }
    <span class="enscript-keyword">if</span> (crc != newcrc) {
        swd_stackshot_hdr *shdr = (swd_stackshot_hdr *)tmpBuf;;

        <span class="enscript-comment">/* Set statckshot size to 0 if crc doesn't match */</span>
        shdr-&gt;magic = SWD_STACKSHOTHDR_MAGIC;
        shdr-&gt;size = 0;

        assert(tmpBufSize &gt; <span class="enscript-keyword">sizeof</span>(swd_stackshot_hdr));
        bytesToWrite = round_page(<span class="enscript-keyword">sizeof</span>(swd_stackshot_hdr));
        vn_rdwr(UIO_WRITE, vp, (<span class="enscript-type">char</span> *)tmpBuf, bytesToWrite, 0,
               UIO_SYSSPACE, IO_SYNC|IO_NODELOCKED|IO_UNIT, 
               vfs_context_ucred(ctx), (<span class="enscript-type">int</span> *) 0,
               vfs_context_proc(ctx));

        DLOG(<span class="enscript-string">&quot;CRC check failed. expected:0x%x actual:0x%x\n&quot;</span>, crc, newcrc);
        error = EFAULT;
    }
<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (vp) { 
        error = vnode_close(vp, FWRITE, ctx);
        DLOG(<span class="enscript-string">&quot;vnode_close returned 0x%x\n&quot;</span>, error);
    }
    <span class="enscript-keyword">if</span> (ctx) vfs_context_rele(ctx);

    <span class="enscript-keyword">return</span> error;



}
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::checkForValidDebugData</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fname, vfs_context_t *ctx, 
                                            <span class="enscript-type">void</span> *tmpBuf, <span class="enscript-type">struct</span> vnode **vp)
{
    <span class="enscript-type">int</span>             rc;
    uint64_t        hdrOffset;

    <span class="enscript-type">struct</span> vnode_attr           va;
    IOHibernateImageHeader      *imageHdr;

    *vp = NULL;
    <span class="enscript-keyword">if</span> (vnode_open(fname, (FREAD | O_NOFOLLOW), 0,
                   VNODE_LOOKUP_NOFOLLOW, vp, *ctx) != 0) 
    {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Failed to open the file %s\n&quot;</span>, fname);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }
    VATTR_INIT(&amp;va);
    VATTR_WANTED(&amp;va, va_nlink);
    VATTR_WANTED(&amp;va, va_data_alloc);
    <span class="enscript-keyword">if</span> ((*vp)-&gt;v_type != VREG ||
        vnode_getattr((*vp), &amp;va, *ctx) || va.va_nlink != 1) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Bailing as %s is not a regular file\n&quot;</span>, fname);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }

    <span class="enscript-comment">/* Read the sleepimage file header */</span>
    rc = vn_rdwr(UIO_READ, *vp, (<span class="enscript-type">char</span> *)tmpBuf, round_page(<span class="enscript-keyword">sizeof</span>(IOHibernateImageHeader)), 0,
                UIO_SYSSPACE, IO_SKIP_ENCRYPTION|IO_SYNC|IO_NODELOCKED|IO_UNIT|IO_NOCACHE, 
                vfs_context_ucred(*ctx), (<span class="enscript-type">int</span> *) 0,
                vfs_context_proc(*ctx));
    <span class="enscript-keyword">if</span> (rc != 0) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Failed to read header size %lu(rc=%d) from %s\n&quot;</span>, 
             round_page(<span class="enscript-keyword">sizeof</span>(IOHibernateImageHeader)), rc, fname);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }

    imageHdr = ((IOHibernateImageHeader *)tmpBuf);
    <span class="enscript-keyword">if</span> (imageHdr-&gt;signature != kIOHibernateHeaderDebugDataSignature) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: File %s header has unexpected value 0x%x\n&quot;</span>, 
             fname, imageHdr-&gt;signature);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }

    <span class="enscript-comment">/* Sleep/Wake debug header(swd_hdr) is at the beggining of the second block */</span>
    hdrOffset = imageHdr-&gt;deviceBlockSize;
    <span class="enscript-keyword">if</span> (hdrOffset + <span class="enscript-keyword">sizeof</span>(swd_hdr) &gt;= va.va_data_alloc) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: header is crossing file size(0x%llx) in file %s\n&quot;</span>,  
             va.va_data_alloc, fname);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
    }

    <span class="enscript-keyword">return</span>; 

<span class="enscript-reference">err</span>:
    <span class="enscript-keyword">if</span> (*vp) vnode_close(*vp, FREAD, *ctx);
    *vp = NULL;

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugDumpFromFile</span>( )
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBERNATION</span>
    <span class="enscript-type">int</span>             rc;
    <span class="enscript-type">char</span>			hibernateFilename[MAXPATHLEN+1];
    <span class="enscript-type">char</span>            PMStatusCode[100];
    <span class="enscript-type">void</span>            *tmpBuf;
    swd_hdr         *hdr = NULL;
    uint32_t        stacksSize, logSize;
    uint64_t        tmpBufSize;
    uint64_t        hdrOffset, stacksOffset, logOffset;
    errno_t         error = EIO;
    OSObject        *obj = NULL;
    OSString        *str = NULL;
    OSNumber        *failStat = NULL;
    <span class="enscript-type">struct</span> vnode    *vp = NULL;
    vfs_context_t   ctx = NULL;

    IOBufferMemoryDescriptor    *tmpBufDesc = NULL;

    DLOG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile\n&quot;</span>);
    <span class="enscript-keyword">if</span> ((swd_flags &amp; SWD_LOGS_IN_FILE) == 0)
        <span class="enscript-keyword">return</span>;

   <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
       <span class="enscript-keyword">return</span>;


    <span class="enscript-comment">/* Allocate a temp buffer to copy data between files */</span>
    tmpBufSize = 2*4096;
    tmpBufDesc = IOBufferMemoryDescriptor::
        inTaskWithOptions(kernel_task, kIODirectionOutIn | kIOMemoryMapperNone, 
                          tmpBufSize, PAGE_SIZE);

    <span class="enscript-keyword">if</span> (!tmpBufDesc) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Fail to allocate temp buf\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    tmpBuf = tmpBufDesc-&gt;getBytesNoCopy();

   ctx = vfs_context_create(vfs_context_current());

    <span class="enscript-comment">/* First check if 'kSleepWakeStackBinFilename' has valid data */</span>
    checkForValidDebugData(kSleepWakeStackBinFilename, &amp;ctx, tmpBuf, &amp;vp);
    <span class="enscript-keyword">if</span> (vp == NULL) {
        <span class="enscript-comment">/* Check if the debug data is saved to hibernation file */</span>
        hibernateFilename[0] = 0;
        <span class="enscript-keyword">if</span> ((obj = copyProperty(kIOHibernateFileKey)))
        {
            <span class="enscript-keyword">if</span> ((str = OSDynamicCast(OSString, obj)))
                strlcpy(hibernateFilename, str-&gt;getCStringNoCopy(),
                        <span class="enscript-keyword">sizeof</span>(hibernateFilename));
            obj-&gt;release();
        }
        <span class="enscript-keyword">if</span> (!hibernateFilename[0]) {
            DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Failed to get hibernation file name\n&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }

        checkForValidDebugData(hibernateFilename, &amp;ctx, tmpBuf, &amp;vp);
        <span class="enscript-keyword">if</span> (vp == NULL) {
            DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: No valid debug data is found\n&quot;</span>);
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
        }
        DLOG(<span class="enscript-string">&quot;Getting SW Stacks image from file %s\n&quot;</span>, hibernateFilename);
    }
    <span class="enscript-keyword">else</span> {
        DLOG(<span class="enscript-string">&quot;Getting SW Stacks image from file %s\n&quot;</span>, kSleepWakeStackBinFilename);
    }

    hdrOffset = ((IOHibernateImageHeader *)tmpBuf)-&gt;deviceBlockSize;

    DLOG(<span class="enscript-string">&quot;Reading swd_hdr len 0x%lx offset 0x%lx\n&quot;</span>, round_page(<span class="enscript-keyword">sizeof</span>(swd_hdr)), trunc_page(hdrOffset));
    <span class="enscript-comment">/* Read the sleep/wake debug header(swd_hdr) */</span>
    rc = vn_rdwr(UIO_READ, vp, (<span class="enscript-type">char</span> *)tmpBuf, round_page(<span class="enscript-keyword">sizeof</span>(swd_hdr)), trunc_page(hdrOffset),
                UIO_SYSSPACE, IO_SKIP_ENCRYPTION|IO_SYNC|IO_NODELOCKED|IO_UNIT|IO_NOCACHE, 
                vfs_context_ucred(ctx), (<span class="enscript-type">int</span> *) 0,
                vfs_context_proc(ctx));
    <span class="enscript-keyword">if</span> (rc != 0) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Failed to debug read header size %lu. rc=%d\n&quot;</span>,
             round_page(<span class="enscript-keyword">sizeof</span>(swd_hdr)), rc);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    hdr = (swd_hdr *)((<span class="enscript-type">char</span> *)tmpBuf + (hdrOffset - trunc_page(hdrOffset)));
    <span class="enscript-keyword">if</span> ((hdr-&gt;signature != SWD_HDR_SIGNATURE) || (hdr-&gt;alloc_size &gt; SWD_BUF_SIZE) ||
        (hdr-&gt;spindump_offset &gt; SWD_BUF_SIZE) || (hdr-&gt;spindump_size &gt; SWD_BUF_SIZE)) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Invalid data in debug header. sign:0x%x size:0x%x spindump_offset:0x%x spindump_size:0x%x\n&quot;</span>,
             hdr-&gt;signature, hdr-&gt;alloc_size, hdr-&gt;spindump_offset, hdr-&gt;spindump_size);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    stacksSize = hdr-&gt;spindump_size;

    <span class="enscript-comment">/* Get stacks &amp; log offsets in the image file */</span>
    stacksOffset = hdrOffset + hdr-&gt;spindump_offset;
    logOffset = hdrOffset + offsetof(swd_hdr, UUID);
    logSize = <span class="enscript-keyword">sizeof</span>(swd_hdr)-offsetof(swd_hdr, UUID); 

    error = sleepWakeDebugCopyFile(vp, ctx, (<span class="enscript-type">char</span> *)tmpBuf, tmpBufSize, stacksOffset,
                                   getDumpStackFilename(hdr), stacksSize, hdr-&gt;crc);
    <span class="enscript-keyword">if</span> (error == EFAULT) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Stackshot CRC doesn't match\n&quot;</span>);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
    error = sleepWakeDebugCopyFile(vp, ctx, (<span class="enscript-type">char</span> *)tmpBuf, tmpBufSize, logOffset, 
                                   getDumpLogFilename(hdr), logSize, 0);
    <span class="enscript-keyword">if</span> (error) {
        DMSG(<span class="enscript-string">&quot;sleepWakeDebugDumpFromFile: Failed to write the log file(0x%x)\n&quot;</span>, error);
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }
<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (error) {
      <span class="enscript-comment">// Write just the SleepWakeLog.dump with failure code
</span>      uint64_t fcode = 0;
      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fname;
      <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_BOOT_BY_SW_WDOG) {
          failStat = OSDynamicCast(OSNumber, getProperty(kIOPMSleepWakeFailureCodeKey));
          fcode = failStat-&gt;unsigned64BitValue();
          fname = kSleepWakeLogFilename;
      }
      <span class="enscript-keyword">else</span> {
          fname = kAppleOSXWatchdogLogFilename;
      }
      memset(PMStatusCode, 0x20, <span class="enscript-keyword">sizeof</span>(PMStatusCode)); <span class="enscript-comment">// Fill with spaces
</span>      PMStatusCode[<span class="enscript-keyword">sizeof</span>(PMStatusCode)-1] = 0xa; <span class="enscript-comment">// And an end-of-line at the end
</span>      snprintf(PMStatusCode, <span class="enscript-keyword">sizeof</span>(PMStatusCode)-1, <span class="enscript-string">&quot;Code: 0x%llx&quot;</span>, fcode);
      sleepWakeDebugSaveFile(fname, PMStatusCode, <span class="enscript-keyword">sizeof</span>(PMStatusCode));
    }
    gRootDomain-&gt;swd_lock = 0;

    <span class="enscript-keyword">if</span> (vp) vnode_close(vp, FREAD, ctx);
    <span class="enscript-keyword">if</span> (ctx) vfs_context_rele(ctx);
    <span class="enscript-keyword">if</span> (tmpBufDesc) tmpBufDesc-&gt;release();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIBERNATION */</span>
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugDumpFromMem</span>(IOMemoryMap *logBufMap)
{
   IOVirtualAddress     srcBuf = NULL;
   <span class="enscript-type">char</span>                 *stackBuf = NULL, *logOffset = NULL;
   <span class="enscript-type">int</span>                  logSize = 0;

   errno_t      error = EIO;
   uint64_t     bufSize = 0;
   swd_hdr      *hdr = NULL;
   <span class="enscript-type">char</span> PMStatusCode[100];
   OSNumber  *failStat = NULL;

   <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
       <span class="enscript-keyword">return</span>;

   <span class="enscript-keyword">if</span> ((logBufMap == 0) || ( (srcBuf = logBufMap-&gt;getVirtualAddress()) == 0) )
   {
      DLOG(<span class="enscript-string">&quot;Nothing saved to dump to file\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   hdr = (swd_hdr *)srcBuf;
   bufSize = logBufMap-&gt;getLength();
   <span class="enscript-keyword">if</span> (bufSize &lt;= <span class="enscript-keyword">sizeof</span>(swd_hdr))
   {
      IOLog(<span class="enscript-string">&quot;SleepWake log buffer contents are invalid\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   stackBuf = (<span class="enscript-type">char</span>*)hdr+hdr-&gt;spindump_offset;

   error = sleepWakeDebugSaveFile(getDumpStackFilename(hdr), stackBuf, hdr-&gt;spindump_size);
   <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

   logOffset = (<span class="enscript-type">char</span>*)hdr+offsetof(swd_hdr, UUID);
   logSize = <span class="enscript-keyword">sizeof</span>(swd_hdr)-offsetof(swd_hdr, UUID);

   error = sleepWakeDebugSaveFile(getDumpLogFilename(hdr), logOffset, logSize);
   <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

    hdr-&gt;spindump_size = 0;
    error = 0;

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">if</span> (error) {
      <span class="enscript-comment">// Write just the SleepWakeLog.dump with failure code
</span>      uint64_t fcode = 0;
      <span class="enscript-type">const</span> <span class="enscript-type">char</span> *sname, *lname;
      swd_stackshot_hdr shdr;

        <span class="enscript-comment">/* Try writing an empty stacks file */</span>
        shdr.magic = SWD_STACKSHOTHDR_MAGIC;
        shdr.size = 0;


      <span class="enscript-keyword">if</span> (swd_flags &amp; SWD_BOOT_BY_SW_WDOG) {
          failStat = OSDynamicCast(OSNumber, getProperty(kIOPMSleepWakeFailureCodeKey));
          fcode = failStat-&gt;unsigned64BitValue();
          lname = kSleepWakeLogFilename;
          sname = kSleepWakeStackFilename;
      }
      <span class="enscript-keyword">else</span> {
          lname = kAppleOSXWatchdogLogFilename;
          sname= kAppleOSXWatchdogStackFilename;
      }

      sleepWakeDebugSaveFile(sname, (<span class="enscript-type">char</span>*)(&amp;shdr), <span class="enscript-keyword">sizeof</span>(shdr));
      memset(PMStatusCode, 0x20, <span class="enscript-keyword">sizeof</span>(PMStatusCode)); <span class="enscript-comment">// Fill with spaces
</span>      PMStatusCode[<span class="enscript-keyword">sizeof</span>(PMStatusCode)-1] = 0xa; <span class="enscript-comment">// And an end-of-line at the end
</span>      snprintf(PMStatusCode, <span class="enscript-keyword">sizeof</span>(PMStatusCode)-1, <span class="enscript-string">&quot;Code: 0x%llx&quot;</span>, fcode);
      sleepWakeDebugSaveFile(lname, PMStatusCode, <span class="enscript-keyword">sizeof</span>(PMStatusCode));
    }
    gRootDomain-&gt;swd_lock = 0;
}

IOMemoryMap *<span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugRetrieve</span>( )
{
   IOVirtualAddress     vaddr = NULL;
   IOMemoryDescriptor * desc = NULL;
   IOMemoryMap *        logBufMap = NULL;

   uint32_t          len;
   addr64_t          data[3];
   uint64_t          bufSize = 0;
   uint64_t          crc = 0;
   uint64_t          newcrc = 0;
   uint64_t          paddr = 0;
   swd_hdr           *hdr = NULL;
   <span class="enscript-type">bool</span>              ret = false;
   <span class="enscript-type">char</span>              str[20];


   <span class="enscript-keyword">if</span> (!OSCompareAndSwap(0, 1, &amp;gRootDomain-&gt;swd_lock))
       <span class="enscript-keyword">return</span> NULL;

   <span class="enscript-keyword">if</span> (!PEReadNVRAMProperty(kIOSleepWakeDebugKey, 0, &amp;len)) {
      DLOG(<span class="enscript-string">&quot;No sleepWakeDebug note to read\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   <span class="enscript-keyword">if</span> (len == strlen(<span class="enscript-string">&quot;sleepimage&quot;</span>)) {
       str[0] = 0;
       PEReadNVRAMProperty(kIOSleepWakeDebugKey, str, &amp;len);

       <span class="enscript-keyword">if</span> (!strncmp((<span class="enscript-type">char</span>*)str, <span class="enscript-string">&quot;sleepimage&quot;</span>, strlen(<span class="enscript-string">&quot;sleepimage&quot;</span>))) {
           DLOG(<span class="enscript-string">&quot;sleepWakeDebugRetrieve: in file logs\n&quot;</span>);
           swd_flags |= SWD_LOGS_IN_FILE|SWD_VALID_LOGS;
           <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
       }
   }
   <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len == <span class="enscript-keyword">sizeof</span>(addr64_t)*3)
       PEReadNVRAMProperty(kIOSleepWakeDebugKey, data, &amp;len);
   <span class="enscript-keyword">else</span> {
      DLOG(<span class="enscript-string">&quot;Invalid sleepWakeDebug note length(%d)\n&quot;</span>, len);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }



   DLOG(<span class="enscript-string">&quot;sleepWakeDebugRetrieve: data[0]:0x%llx data[1]:0x%llx data[2]:0x%llx\n&quot;</span>,
        data[0], data[1], data[2]);
   DLOG(<span class="enscript-string">&quot;sleepWakeDebugRetrieve: in mem logs\n&quot;</span>);
   bufSize = data[0];
   crc = data[1];
   paddr = data[2];
   <span class="enscript-keyword">if</span> ( (bufSize &lt;= <span class="enscript-keyword">sizeof</span>(swd_hdr)) ||(bufSize &gt; SWD_BUF_SIZE) || (crc == 0) )
   {
      IOLog(<span class="enscript-string">&quot;SleepWake log buffer contents are invalid\n&quot;</span>);
      <span class="enscript-keyword">return</span> NULL;
   }

   DLOG(<span class="enscript-string">&quot;size:0x%llx crc:0x%llx paddr:0x%llx\n&quot;</span>,
         bufSize, crc, paddr);


   desc = IOMemoryDescriptor::withAddressRange( paddr, bufSize,
                          kIODirectionOutIn | kIOMemoryMapperNone, NULL);
   <span class="enscript-keyword">if</span> (desc == NULL)
   {
      IOLog(<span class="enscript-string">&quot;Fail to map SleepWake log buffer\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   logBufMap = desc-&gt;map();

   vaddr = logBufMap-&gt;getVirtualAddress();


   <span class="enscript-keyword">if</span> ( (logBufMap-&gt;getLength() &lt;= <span class="enscript-keyword">sizeof</span>(swd_hdr)) || (vaddr == NULL) ) {
      IOLog(<span class="enscript-string">&quot;Fail to map SleepWake log buffer\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   hdr = (swd_hdr *)vaddr;
   <span class="enscript-keyword">if</span> (hdr-&gt;spindump_offset+hdr-&gt;spindump_size &gt; bufSize)
   {
      IOLog(<span class="enscript-string">&quot;SleepWake log buffer contents are invalid\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   hdr-&gt;crc = crc;
   newcrc = crc32(0, (<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span>*)vaddr+hdr-&gt;spindump_offset),
            hdr-&gt;spindump_size);
   <span class="enscript-keyword">if</span> (newcrc != crc) {
      IOLog(<span class="enscript-string">&quot;SleepWake log buffer contents are invalid\n&quot;</span>);
      <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
   }

   ret = true;
   swd_flags |= SWD_LOGS_IN_MEM | SWD_VALID_LOGS;


<span class="enscript-reference">exit</span>:
   PERemoveNVRAMProperty(kIOSleepWakeDebugKey);
   <span class="enscript-keyword">if</span> (!ret) {
      <span class="enscript-keyword">if</span> (logBufMap) logBufMap-&gt;release();
      logBufMap = 0;
   }
   <span class="enscript-keyword">if</span> (desc) desc-&gt;release();
    gRootDomain-&gt;swd_lock = 0;

   <span class="enscript-keyword">return</span> logBufMap;
}

#<span class="enscript-reference">else</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugTrig</span>(<span class="enscript-type">bool</span> restart)
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::takeStackshot</span>(<span class="enscript-type">bool</span> restart, <span class="enscript-type">bool</span> isOSXWatchdog, <span class="enscript-type">bool</span> isSpinDump)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">restart</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">isOSXWatchdog</span>)
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugMemAlloc</span>( )
{
}
<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugDumpFromMem</span>(IOMemoryMap *map)
{
}
errno_t <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugCopyFile</span>(
                               <span class="enscript-type">struct</span> vnode *srcVp, 
                               vfs_context_t srcCtx,
                               <span class="enscript-type">char</span> *tmpBuf, uint64_t tmpBufSize,
                               uint64_t srcOffset, 
                               <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dstFname, 
                               uint64_t numBytes,
                               uint32_t crc)
{
    <span class="enscript-keyword">return</span> EIO;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugDumpFromFile</span>()
{
}

IOMemoryMap *<span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugRetrieve</span>( )
{
   <span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugEnableWdog</span>()
{
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugIsWdogEnabled</span>()
{
    <span class="enscript-keyword">return</span> false;
}

errno_t <span class="enscript-function-name">IOPMrootDomain::sleepWakeDebugSaveFile</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> len)
{
    <span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span>

</pre>
<hr />
</body></html>