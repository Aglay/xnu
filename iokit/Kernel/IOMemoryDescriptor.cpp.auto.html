<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOMemoryDescriptor.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOMemoryDescriptor.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMapper.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODMACommand.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitKeysPrivate.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOSubMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMultiMemoryDescriptor.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSDictionary.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSArray.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSSymbol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSNumber.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>

__BEGIN_DECLS
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;device/device_port.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

<span class="enscript-type">extern</span> ppnum_t <span class="enscript-function-name">pmap_find_phys</span>(pmap_t pmap, addr64_t va);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t port);

<span class="enscript-comment">// osfmk/device/iokit_rpc.c
</span><span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">IODefaultCacheBits</span>(addr64_t pa);
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">IOTranslateCacheBits</span>(<span class="enscript-type">struct</span> phys_entry *pp);

__END_DECLS

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIOMapperWaitSystem</span>	((IOMapper *) 1)

<span class="enscript-type">static</span> IOMapper * gIOSystemMapper = NULL;

ppnum_t		  gIOLastPage;

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-function-name">OSDefineMetaClassAndAbstractStructors</span>( IOMemoryDescriptor, OSObject )

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOMemoryDescriptor

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOGeneralMemoryDescriptor, IOMemoryDescriptor)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> IORecursiveLock * gIOMemoryLock;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOCK</span>	IORecursiveLockLock( gIOMemoryLock)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UNLOCK</span>	IORecursiveLockUnlock( gIOMemoryLock)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLEEP</span>	IORecursiveLockSleep( gIOMemoryLock, (void *)this, THREAD_UNINT)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">WAKEUP</span>	\
    IORecursiveLockWakeup( gIOMemoryLock, (<span class="enscript-type">void</span> *)<span class="enscript-keyword">this</span>, <span class="enscript-comment">/* one-thread */</span> false)

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEBG</span>(fmt, args...)  	{ kprintf(fmt, ## args); }
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEBG</span>(fmt, args...)  	{}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOMD_DEBUG_DMAACTIVE</span>	1

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// Some data structures and accessor macros used by the initWithOptions
</span><span class="enscript-comment">// Function
</span>
<span class="enscript-type">enum</span> ioPLBlockFlags {
    kIOPLOnDevice  = 0x00000001,
    kIOPLExternUPL = 0x00000002,
};

<span class="enscript-type">struct</span> IOMDPersistentInitData
{
    <span class="enscript-type">const</span> IOGeneralMemoryDescriptor * fMD;
    IOMemoryReference               * fMemRef;
};

<span class="enscript-type">struct</span> ioPLBlock {
    upl_t fIOPL;
    vm_address_t fPageInfo;   <span class="enscript-comment">// Pointer to page list or index into it
</span>    uint32_t fIOMDOffset;	    <span class="enscript-comment">// The offset of this iopl in descriptor
</span>    ppnum_t fMappedPage;	    <span class="enscript-comment">// Page number of first page in this iopl
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fPageOffset;	    <span class="enscript-comment">// Offset within first page of iopl
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fFlags;	    <span class="enscript-comment">// Flags
</span>};

<span class="enscript-type">struct</span> ioGMDData {
    IOMapper *  fMapper;
    uint8_t	fDMAMapNumAddressBits;
    uint64_t    fDMAMapAlignment;
    uint64_t    fMappedBase;
    uint64_t    fMappedLength;
    uint64_t    fPreparationID;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    IOTracking  fWireTracking;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> fPageCnt;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> fDiscontig:1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> fCompletionError:1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> _resv:6;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-comment">// align arrays to 8 bytes so following macros work
</span>    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> fPad[3];
#<span class="enscript-reference">endif</span>
    upl_page_info_t fPageList[1]; <span class="enscript-comment">/* variable length */</span>
    ioPLBlock fBlocks[1]; <span class="enscript-comment">/* variable length */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">getDataP</span>(osd)	((ioGMDData *) (osd)-&gt;getBytesNoCopy())
#<span class="enscript-reference">define</span> <span class="enscript-function-name">getIOPLList</span>(d)	((ioPLBlock *) (void *)&amp;(d-&gt;fPageList[d-&gt;fPageCnt]))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">getNumIOPL</span>(osd, d)	\
    (((osd)-&gt;getLength() - ((<span class="enscript-type">char</span> *) getIOPLList(d) - (<span class="enscript-type">char</span> *) d)) / <span class="enscript-keyword">sizeof</span>(ioPLBlock))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">getPageList</span>(d)	(&amp;(d-&gt;fPageList[0]))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">computeDataSize</span>(p, u) \
    (offsetof(ioGMDData, fPageList) + p * <span class="enscript-keyword">sizeof</span>(upl_page_info_t) + u * <span class="enscript-keyword">sizeof</span>(ioPLBlock))

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">next_page</span>(a) ( trunc_page(a) + PAGE_SIZE )

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

kern_return_t <span class="enscript-function-name">device_data_action</span>(
               uintptr_t               device_handle, 
               ipc_port_t              device_pager,
               vm_prot_t               protection, 
               vm_object_offset_t      offset, 
               vm_size_t               size)
{
    kern_return_t	 kr;
    IOMemoryDescriptorReserved * ref = (IOMemoryDescriptorReserved *) device_handle;
    IOMemoryDescriptor * memDesc;

    LOCK;
    memDesc = ref-&gt;dp.memory;
    <span class="enscript-keyword">if</span>( memDesc)
    {
	memDesc-&gt;retain();
	kr = memDesc-&gt;handleFault(device_pager, offset, size);
	memDesc-&gt;release();
    }
    <span class="enscript-keyword">else</span>
	kr = KERN_ABORTED;
    UNLOCK;

    <span class="enscript-keyword">return</span>( kr );
}

kern_return_t <span class="enscript-function-name">device_close</span>(
               uintptr_t     device_handle)
{
    IOMemoryDescriptorReserved * ref = (IOMemoryDescriptorReserved *) device_handle;

    IODelete( ref, IOMemoryDescriptorReserved, 1 );

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}
};	<span class="enscript-comment">// end extern &quot;C&quot;
</span>
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// Note this inline function uses C++ reference arguments to return values
</span><span class="enscript-comment">// This means that pointers are not passed and NULLs don't have to be
</span><span class="enscript-comment">// checked for as a NULL reference is illegal.
</span><span class="enscript-type">static</span> <span class="enscript-type">inline</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">getAddrLenForInd</span>(mach_vm_address_t &amp;addr, mach_vm_size_t &amp;len, <span class="enscript-comment">// Output variables
</span>     UInt32 type, IOGeneralMemoryDescriptor::Ranges r, UInt32 ind)
{
    assert(kIOMemoryTypeUIO       == type
	|| kIOMemoryTypeVirtual   == type || kIOMemoryTypeVirtual64 == type
	|| kIOMemoryTypePhysical  == type || kIOMemoryTypePhysical64 == type);
    <span class="enscript-keyword">if</span> (kIOMemoryTypeUIO == type) {
	user_size_t us;
	user_addr_t ad;
	uio_getiov((uio_t) r.uio, ind, &amp;ad, &amp;us); addr = ad; len = us;
    }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kIOMemoryTypeVirtual64 == type) || (kIOMemoryTypePhysical64 == type)) {
	IOAddressRange cur = r.v64[ind];
	addr = cur.address;
	len  = cur.length;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    <span class="enscript-keyword">else</span> {
	IOVirtualRange cur = r.v[ind];
	addr = cur.address;
	len  = cur.length;
    }
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> IOReturn 
<span class="enscript-function-name">purgeableControlBits</span>(IOOptionBits newState, vm_purgable_t * control, <span class="enscript-type">int</span> * state)
{
    IOReturn err = kIOReturnSuccess;

    *control = VM_PURGABLE_SET_STATE;

    <span class="enscript-type">enum</span> { kIOMemoryPurgeableControlMask = 15 };

    <span class="enscript-keyword">switch</span> (kIOMemoryPurgeableControlMask &amp; newState)
    {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryPurgeableKeepCurrent</span>:
	    *control = VM_PURGABLE_GET_STATE;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryPurgeableNonVolatile</span>:
	    *state = VM_PURGABLE_NONVOLATILE;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryPurgeableVolatile</span>:
	    *state = VM_PURGABLE_VOLATILE | (newState &amp; ~kIOMemoryPurgeableControlMask);
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryPurgeableEmpty</span>:
	    *state = VM_PURGABLE_EMPTY;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    err = kIOReturnBadArgument;
	    <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> IOReturn 
<span class="enscript-function-name">purgeableStateBits</span>(<span class="enscript-type">int</span> * state)
{
    IOReturn err = kIOReturnSuccess;

    <span class="enscript-keyword">switch</span> (VM_PURGABLE_STATE_MASK &amp; *state)
    {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_NONVOLATILE</span>:
	    *state = kIOMemoryPurgeableNonVolatile;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_VOLATILE</span>:
	    *state = kIOMemoryPurgeableVolatile;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VM_PURGABLE_EMPTY</span>:
	    *state = kIOMemoryPurgeableEmpty;
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    *state = kIOMemoryPurgeableNonVolatile;
	    err = kIOReturnNotReady;
	    <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> (err);
}


<span class="enscript-type">static</span> vm_prot_t 
<span class="enscript-function-name">vmProtForCacheMode</span>(IOOptionBits cacheMode)
{
    vm_prot_t prot = 0;
    <span class="enscript-keyword">switch</span> (cacheMode)
    {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOInhibitCache</span>:
	    SET_MAP_MEM(MAP_MEM_IO, prot);
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOWriteThruCache</span>:
	    SET_MAP_MEM(MAP_MEM_WTHRU, prot);
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOWriteCombineCache</span>:
	    SET_MAP_MEM(MAP_MEM_WCOMB, prot);
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCopybackCache</span>:
	    SET_MAP_MEM(MAP_MEM_COPYBACK, prot);
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCopybackInnerCache</span>:
	    SET_MAP_MEM(MAP_MEM_INNERWBACK, prot);
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIODefaultCache</span>:
	<span class="enscript-reference">default</span>:
	    SET_MAP_MEM(MAP_MEM_NOOP, prot);
	    <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> (prot);
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pagerFlagsForCacheMode</span>(IOOptionBits cacheMode)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pagerFlags = 0;
    <span class="enscript-keyword">switch</span> (cacheMode)
    {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOInhibitCache</span>:
	    pagerFlags = DEVICE_PAGER_CACHE_INHIB |  DEVICE_PAGER_COHERENT | DEVICE_PAGER_GUARDED;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOWriteThruCache</span>:
	    pagerFlags = DEVICE_PAGER_WRITE_THROUGH | DEVICE_PAGER_COHERENT | DEVICE_PAGER_GUARDED;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOWriteCombineCache</span>:
	    pagerFlags = DEVICE_PAGER_CACHE_INHIB | DEVICE_PAGER_COHERENT;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCopybackCache</span>:
	    pagerFlags = DEVICE_PAGER_COHERENT;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCopybackInnerCache</span>:
	    pagerFlags = DEVICE_PAGER_COHERENT;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIODefaultCache</span>:
	<span class="enscript-reference">default</span>:
	    pagerFlags = -1U;
	    <span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">return</span> (pagerFlags);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">struct</span> IOMemoryEntry
{
    ipc_port_t entry;
    int64_t    offset;
    uint64_t   size;
};

<span class="enscript-type">struct</span> IOMemoryReference
{
    <span class="enscript-type">volatile</span> SInt32 refCount;
    vm_prot_t       prot;
    uint32_t        capacity;
    uint32_t        count;
    IOMemoryEntry   entries[0];
};

<span class="enscript-type">enum</span>
{
    kIOMemoryReferenceReuse = 0x00000001,
    kIOMemoryReferenceWrite = 0x00000002,
};

SInt32 gIOMemoryReferenceCount;

IOMemoryReference *
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceAlloc</span>(uint32_t capacity, IOMemoryReference * realloc)
{
    IOMemoryReference * ref;
    size_t              newSize, oldSize, copySize;

    newSize = (<span class="enscript-keyword">sizeof</span>(IOMemoryReference) 
                 - <span class="enscript-keyword">sizeof</span>(ref-&gt;entries) 
                 + capacity * <span class="enscript-keyword">sizeof</span>(ref-&gt;entries[0]));
    ref = (typeof(ref)) IOMalloc(newSize);
    <span class="enscript-keyword">if</span> (realloc)
    {
	oldSize = (<span class="enscript-keyword">sizeof</span>(IOMemoryReference) 
		        - <span class="enscript-keyword">sizeof</span>(realloc-&gt;entries) 
		        + realloc-&gt;capacity * <span class="enscript-keyword">sizeof</span>(realloc-&gt;entries[0]));
	copySize = oldSize;
        <span class="enscript-keyword">if</span> (copySize &gt; newSize) copySize = newSize;
	<span class="enscript-keyword">if</span> (ref) bcopy(realloc, ref, copySize);
	IOFree(realloc, oldSize);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ref)
    {
	bzero(ref, <span class="enscript-keyword">sizeof</span>(*ref));
	ref-&gt;refCount = 1;
	OSIncrementAtomic(&amp;gIOMemoryReferenceCount);
    }
    <span class="enscript-keyword">if</span> (!ref) <span class="enscript-keyword">return</span> (0);
    ref-&gt;capacity = capacity;
    <span class="enscript-keyword">return</span> (ref);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceFree</span>(IOMemoryReference * ref)
{
    IOMemoryEntry * entries;
    size_t          size;

    entries = ref-&gt;entries + ref-&gt;count;
    <span class="enscript-keyword">while</span> (entries &gt; &amp;ref-&gt;entries[0])
    {
        entries--;
        ipc_port_release_send(entries-&gt;entry);
    }
    size = (<span class="enscript-keyword">sizeof</span>(IOMemoryReference) 
                 - <span class="enscript-keyword">sizeof</span>(ref-&gt;entries) 
                 + ref-&gt;capacity * <span class="enscript-keyword">sizeof</span>(ref-&gt;entries[0]));
    IOFree(ref, size);

    OSDecrementAtomic(&amp;gIOMemoryReferenceCount);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceRelease</span>(IOMemoryReference * ref)
{
    <span class="enscript-keyword">if</span> (1 == OSDecrementAtomic(&amp;ref-&gt;refCount)) memoryReferenceFree(ref);
}


IOReturn
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceCreate</span>(
                        IOOptionBits         options,
                        IOMemoryReference ** reference)
{
    <span class="enscript-type">enum</span> { kCapacity = 4, kCapacityInc = 4 };

    kern_return_t        err;
    IOMemoryReference *  ref;
    IOMemoryEntry *      entries;
    IOMemoryEntry *      cloneEntries;
    vm_map_t             map;
    ipc_port_t           entry, cloneEntry;
    vm_prot_t            prot;
    memory_object_size_t actualSize;
    uint32_t             rangeIdx;
    uint32_t             count;
    mach_vm_address_t    entryAddr, endAddr, entrySize;
    mach_vm_size_t       srcAddr, srcLen;
    mach_vm_size_t       nextAddr, nextLen;
    mach_vm_size_t       offset, remain;
    IOByteCount          physLen;
    IOOptionBits         type = (_flags &amp; kIOMemoryTypeMask);
    IOOptionBits         cacheMode;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    	 pagerFlags;
    vm_tag_t             tag;

    ref = memoryReferenceAlloc(kCapacity, NULL);
    <span class="enscript-keyword">if</span> (!ref) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

    tag = IOMemoryTag(kernel_map);
    entries = &amp;ref-&gt;entries[0];
    count = 0;

    offset = 0;
    rangeIdx = 0;
    <span class="enscript-keyword">if</span> (_task) getAddrLenForInd(nextAddr, nextLen, type, _ranges, rangeIdx);
    <span class="enscript-keyword">else</span>
    {
        nextAddr = getPhysicalSegment(offset, &amp;physLen, kIOMemoryMapperNone);
        nextLen = physLen;

	<span class="enscript-comment">// default cache mode for physical
</span>	<span class="enscript-keyword">if</span> (kIODefaultCache == ((_flags &amp; kIOMemoryBufferCacheMask) &gt;&gt; kIOMemoryBufferCacheShift))
	{
	    IOOptionBits mode;
	    pagerFlags = IODefaultCacheBits(nextAddr);
	    <span class="enscript-keyword">if</span> (DEVICE_PAGER_CACHE_INHIB &amp; pagerFlags)
	    {
		<span class="enscript-keyword">if</span> (DEVICE_PAGER_GUARDED &amp; pagerFlags)
		    mode = kIOInhibitCache;
		<span class="enscript-keyword">else</span>
		    mode = kIOWriteCombineCache;
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (DEVICE_PAGER_WRITE_THROUGH &amp; pagerFlags)
		mode = kIOWriteThruCache;
	    <span class="enscript-keyword">else</span>
		mode = kIOCopybackCache;
	    _flags |= (mode &lt;&lt; kIOMemoryBufferCacheShift);
	}
    }

    <span class="enscript-comment">// cache mode &amp; vm_prot
</span>    prot = VM_PROT_READ;
    cacheMode = ((_flags &amp; kIOMemoryBufferCacheMask) &gt;&gt; kIOMemoryBufferCacheShift);
    prot |= vmProtForCacheMode(cacheMode);
    <span class="enscript-comment">// VM system requires write access to change cache mode
</span>    <span class="enscript-keyword">if</span> (kIODefaultCache != cacheMode)                    prot |= VM_PROT_WRITE;
    <span class="enscript-keyword">if</span> (kIODirectionOut != (kIODirectionOutIn &amp; _flags)) prot |= VM_PROT_WRITE;
    <span class="enscript-keyword">if</span> (kIOMemoryReferenceWrite &amp; options)               prot |= VM_PROT_WRITE;

    <span class="enscript-keyword">if</span> ((kIOMemoryReferenceReuse &amp; options) &amp;&amp; _memRef)
    {
        cloneEntries = &amp;_memRef-&gt;entries[0];
	prot |= MAP_MEM_NAMED_REUSE;
    }

    <span class="enscript-keyword">if</span> (_task)
    {
	<span class="enscript-comment">// virtual ranges
</span>
	<span class="enscript-keyword">if</span> (kIOMemoryBufferPageable &amp; _flags)
	{
	    <span class="enscript-comment">// IOBufferMemoryDescriptor alloc - set flags for entry + object create
</span>	    prot |= MAP_MEM_NAMED_CREATE;
	    <span class="enscript-keyword">if</span> (kIOMemoryBufferPurgeable &amp; _flags) prot |= MAP_MEM_PURGABLE;
	    prot |= VM_PROT_WRITE;
	    map = NULL;
	}
	<span class="enscript-keyword">else</span> map = get_task_map(_task);

	remain = _length;
	<span class="enscript-keyword">while</span> (remain)
	{
	    srcAddr  = nextAddr;
	    srcLen   = nextLen;
	    nextAddr = 0;
	    nextLen  = 0;
	    <span class="enscript-comment">// coalesce addr range
</span>	    <span class="enscript-keyword">for</span> (++rangeIdx; rangeIdx &lt; _rangesCount; rangeIdx++)
	    {
		getAddrLenForInd(nextAddr, nextLen, type, _ranges, rangeIdx);
		<span class="enscript-keyword">if</span> ((srcAddr + srcLen) != nextAddr) <span class="enscript-keyword">break</span>;
		srcLen += nextLen;
	    }
	    entryAddr = trunc_page_64(srcAddr);
	    endAddr   = round_page_64(srcAddr + srcLen);
	    <span class="enscript-keyword">do</span>
	    {
		entrySize = (endAddr - entryAddr);
		<span class="enscript-keyword">if</span> (!entrySize) <span class="enscript-keyword">break</span>;
		actualSize = entrySize;

		cloneEntry = MACH_PORT_NULL;
		<span class="enscript-keyword">if</span> (MAP_MEM_NAMED_REUSE &amp; prot)
		{
		    <span class="enscript-keyword">if</span> (cloneEntries &lt; &amp;_memRef-&gt;entries[_memRef-&gt;count]) cloneEntry = cloneEntries-&gt;entry;
		    <span class="enscript-keyword">else</span>                                                  prot &amp;= ~MAP_MEM_NAMED_REUSE;
		}

		err = mach_make_memory_entry_64(map,
			&amp;actualSize, entryAddr, prot, &amp;entry, cloneEntry);

		<span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (actualSize &gt; entrySize) panic(<span class="enscript-string">&quot;mach_make_memory_entry_64 actualSize&quot;</span>);

		<span class="enscript-keyword">if</span> (count &gt;= ref-&gt;capacity)
		{
		    ref = memoryReferenceAlloc(ref-&gt;capacity + kCapacityInc, ref);
		    entries = &amp;ref-&gt;entries[count];
		}
		entries-&gt;entry  = entry;
		entries-&gt;size   = actualSize;
		entries-&gt;offset = offset + (entryAddr - srcAddr);
		entryAddr += actualSize;
		<span class="enscript-keyword">if</span> (MAP_MEM_NAMED_REUSE &amp; prot)
		{
		    <span class="enscript-keyword">if</span> ((cloneEntries-&gt;entry  == entries-&gt;entry)
		     &amp;&amp; (cloneEntries-&gt;size   == entries-&gt;size)
		     &amp;&amp; (cloneEntries-&gt;offset == entries-&gt;offset))         cloneEntries++;
		     <span class="enscript-keyword">else</span>                                    prot &amp;= ~MAP_MEM_NAMED_REUSE;
		}
		entries++;
		count++;
	    }
	    <span class="enscript-keyword">while</span> (true);
	    offset += srcLen;
	    remain -= srcLen;
	}
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-comment">// _task == 0, physical or kIOMemoryTypeUPL
</span>	memory_object_t pager;
        vm_size_t       size = ptoa_32(_pages);

	<span class="enscript-keyword">if</span> (!getKernelReserved()) panic(<span class="enscript-string">&quot;getKernelReserved&quot;</span>);

	reserved-&gt;dp.pagerContig = (1 == _rangesCount);
	reserved-&gt;dp.memory      = <span class="enscript-keyword">this</span>;

	pagerFlags = pagerFlagsForCacheMode(cacheMode);
	<span class="enscript-keyword">if</span> (-1U == pagerFlags) panic(<span class="enscript-string">&quot;phys is kIODefaultCache&quot;</span>);
	<span class="enscript-keyword">if</span> (reserved-&gt;dp.pagerContig) pagerFlags |= DEVICE_PAGER_CONTIGUOUS;

	pager = device_pager_setup((memory_object_t) 0, (uintptr_t) reserved, 
							    size, pagerFlags);
	assert (pager);
	<span class="enscript-keyword">if</span> (!pager) err = kIOReturnVMError;
	<span class="enscript-keyword">else</span>
	{
	    srcAddr  = nextAddr;
	    entryAddr = trunc_page_64(srcAddr);
	    err = mach_memory_object_memory_entry_64((host_t) 1, false <span class="enscript-comment">/*internal*/</span>, 
			size, VM_PROT_READ | VM_PROT_WRITE, pager, &amp;entry);
	    assert (KERN_SUCCESS == err);
	    <span class="enscript-keyword">if</span> (KERN_SUCCESS != err) device_pager_deallocate(pager);
	    <span class="enscript-keyword">else</span>
	    {
		reserved-&gt;dp.devicePager = pager;
		entries-&gt;entry  = entry;
		entries-&gt;size   = size;
		entries-&gt;offset = offset + (entryAddr - srcAddr);
		entries++;
		count++;
	    }
	}
    }
    
    ref-&gt;count = count;
    ref-&gt;prot  = prot;

    <span class="enscript-keyword">if</span> (KERN_SUCCESS == err)
    {
	<span class="enscript-keyword">if</span> (MAP_MEM_NAMED_REUSE &amp; prot)
	{
	    memoryReferenceFree(ref);
	    OSIncrementAtomic(&amp;_memRef-&gt;refCount);
	    ref = _memRef;
	}
    }
    <span class="enscript-keyword">else</span>
    {
        memoryReferenceFree(ref);
        ref = NULL;    
    }

    *reference = ref;

    <span class="enscript-keyword">return</span> (err);
}

kern_return_t 
<span class="enscript-function-name">IOMemoryDescriptorMapAlloc</span>(vm_map_t map, <span class="enscript-type">void</span> * _ref)
{
    IOMemoryDescriptorMapAllocRef * ref = (typeof(ref))_ref;
    IOReturn			    err;
    vm_map_offset_t		    addr;

    addr = ref-&gt;mapped;

    err = vm_map_enter_mem_object(map, &amp;addr, ref-&gt;size,
				  (vm_map_offset_t) 0,
				  (((ref-&gt;options &amp; kIOMapAnywhere)
				    ? VM_FLAGS_ANYWHERE
				    : VM_FLAGS_FIXED)
				   | VM_MAKE_TAG(ref-&gt;tag)
				   | VM_FLAGS_IOKIT_ACCT), <span class="enscript-comment">/* iokit accounting */</span>
				  IPC_PORT_NULL,
				  (memory_object_offset_t) 0,
				  false, <span class="enscript-comment">/* copy */</span>
				  ref-&gt;prot,
				  ref-&gt;prot,
				  VM_INHERIT_NONE);
    <span class="enscript-keyword">if</span> (KERN_SUCCESS == err)
    {
	ref-&gt;mapped = (mach_vm_address_t) addr;
	ref-&gt;map = map;
    }

    <span class="enscript-keyword">return</span>( err );
}

IOReturn 
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceMap</span>(
		     IOMemoryReference * ref,
                     vm_map_t            map,
                     mach_vm_size_t      inoffset,
                     mach_vm_size_t      size,
                     IOOptionBits        options,
                     mach_vm_address_t * inaddr)
{
    IOReturn        err;
    int64_t         offset = inoffset;
    uint32_t        rangeIdx, entryIdx;
    vm_map_offset_t addr, mapAddr;
    vm_map_offset_t pageOffset, entryOffset, remain, chunk;

    mach_vm_address_t nextAddr;
    mach_vm_size_t    nextLen;
    IOByteCount       physLen;
    IOMemoryEntry   * entry;
    vm_prot_t         prot, memEntryCacheMode;
    IOOptionBits      type;
    IOOptionBits      cacheMode;
    vm_tag_t          tag;

    <span class="enscript-comment">/*
     * For the kIOMapPrefault option.
     */</span>
    upl_page_info_t *pageList = NULL;
    UInt currentPageIndex = 0;

    type = _flags &amp; kIOMemoryTypeMask;
    prot = VM_PROT_READ;
    <span class="enscript-keyword">if</span> (!(kIOMapReadOnly &amp; options)) prot |= VM_PROT_WRITE;
    prot &amp;= ref-&gt;prot;

    cacheMode = ((options &amp; kIOMapCacheMask) &gt;&gt; kIOMapCacheShift);
    <span class="enscript-keyword">if</span> (kIODefaultCache != cacheMode)
    {
	<span class="enscript-comment">// VM system requires write access to update named entry cache mode
</span>	memEntryCacheMode = (MAP_MEM_ONLY | VM_PROT_WRITE | prot | vmProtForCacheMode(cacheMode));
    }

    tag = IOMemoryTag(map);

    <span class="enscript-keyword">if</span> (_task)
    {
	<span class="enscript-comment">// Find first range for offset
</span>	<span class="enscript-keyword">for</span> (remain = offset, rangeIdx = 0; rangeIdx &lt; _rangesCount; rangeIdx++)
	{
	    getAddrLenForInd(nextAddr, nextLen, type, _ranges, rangeIdx);
	    <span class="enscript-keyword">if</span> (remain &lt; nextLen) <span class="enscript-keyword">break</span>;
	    remain -= nextLen;
	} 
    }
    <span class="enscript-keyword">else</span>
    {
        rangeIdx = 0;
        remain   = 0;
        nextAddr = getPhysicalSegment(offset, &amp;physLen, kIOMemoryMapperNone);
        nextLen  = size;
    }

    assert(remain &lt; nextLen);
    <span class="enscript-keyword">if</span> (remain &gt;= nextLen) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    nextAddr  += remain;
    nextLen   -= remain;
    pageOffset = (page_mask &amp; nextAddr);
    addr = 0;
    <span class="enscript-keyword">if</span> (!(options &amp; kIOMapAnywhere))
    {
        addr = *inaddr;
        <span class="enscript-keyword">if</span> (pageOffset != (page_mask &amp; addr)) <span class="enscript-keyword">return</span> (kIOReturnNotAligned);
        addr -= pageOffset;
    }

    <span class="enscript-comment">// find first entry for offset
</span>    <span class="enscript-keyword">for</span> (entryIdx = 0; 
    	(entryIdx &lt; ref-&gt;count) &amp;&amp; (offset &gt;= ref-&gt;entries[entryIdx].offset);
    	entryIdx++) {}
    entryIdx--;
    entry = &amp;ref-&gt;entries[entryIdx];

    <span class="enscript-comment">// allocate VM
</span>    size = round_page_64(size + pageOffset);
    <span class="enscript-keyword">if</span> (kIOMapOverwrite &amp; options)
    {
        <span class="enscript-keyword">if</span> ((map == kernel_map) &amp;&amp; (kIOMemoryBufferPageable &amp; _flags))
        {
            map = IOPageableMapForAddress(addr);
        }
        err = KERN_SUCCESS;
    }
    <span class="enscript-keyword">else</span>
    {
	IOMemoryDescriptorMapAllocRef ref;
	ref.map     = map;
	ref.tag     = tag;
	ref.options = options;
	ref.size    = size;
	ref.prot    = prot;
	<span class="enscript-keyword">if</span> (options &amp; kIOMapAnywhere)
	    <span class="enscript-comment">// vm_map looks for addresses above here, even when VM_FLAGS_ANYWHERE
</span>	    ref.mapped = 0;
	<span class="enscript-keyword">else</span>
	    ref.mapped = addr;
	<span class="enscript-keyword">if</span> ((ref.map == kernel_map) &amp;&amp; (kIOMemoryBufferPageable &amp; _flags))
	    err = IOIteratePageableMaps( ref.size, &amp;IOMemoryDescriptorMapAlloc, &amp;ref );
	<span class="enscript-keyword">else</span>
	    err = IOMemoryDescriptorMapAlloc(ref.map, &amp;ref);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == err)
	{
	    addr = ref.mapped;
	    map  = ref.map;
	}
    }

    <span class="enscript-comment">/*
     * Prefaulting is only possible if we wired the memory earlier. Check the
     * memory type, and the underlying data.
     */</span>
    <span class="enscript-keyword">if</span> (options &amp; kIOMapPrefault)
    {
        <span class="enscript-comment">/*
         * The memory must have been wired by calling ::prepare(), otherwise
         * we don't have the UPL. Without UPLs, pages cannot be pre-faulted
         */</span>
        assert(map != kernel_map);
        assert(_wireCount != 0);
        assert(_memoryEntries != NULL);
        <span class="enscript-keyword">if</span> ((map == kernel_map) ||
            (_wireCount == 0) ||
            (_memoryEntries == NULL))
        {
            <span class="enscript-keyword">return</span> kIOReturnBadArgument;
        }

        <span class="enscript-comment">// Get the page list.
</span>        ioGMDData* dataP = getDataP(_memoryEntries);
        ioPLBlock <span class="enscript-type">const</span>* ioplList = getIOPLList(dataP);
        pageList = getPageList(dataP);
        
        <span class="enscript-comment">// Get the number of IOPLs.
</span>        UInt numIOPLs = getNumIOPL(_memoryEntries, dataP);
        
        <span class="enscript-comment">/*
         * Scan through the IOPL Info Blocks, looking for the first block containing
         * the offset. The research will go past it, so we'll need to go back to the
         * right range at the end.
         */</span>
        UInt ioplIndex = 0;
        <span class="enscript-keyword">while</span> (ioplIndex &lt; numIOPLs &amp;&amp; offset &gt;= ioplList[ioplIndex].fIOMDOffset)
            ioplIndex++;
        ioplIndex--;
        
        <span class="enscript-comment">// Retrieve the IOPL info block.
</span>        ioPLBlock ioplInfo = ioplList[ioplIndex];
            
        <span class="enscript-comment">/*
         * For external UPLs, the fPageInfo points directly to the UPL's page_info_t
         * array.
         */</span>
        <span class="enscript-keyword">if</span> (ioplInfo.fFlags &amp; kIOPLExternUPL)
            pageList = (upl_page_info_t*) ioplInfo.fPageInfo;
        <span class="enscript-keyword">else</span>
            pageList = &amp;pageList[ioplInfo.fPageInfo];
        
        <span class="enscript-comment">// Rebase [offset] into the IOPL in order to looks for the first page index.
</span>        mach_vm_size_t offsetInIOPL = offset - ioplInfo.fIOMDOffset + ioplInfo.fPageOffset;
        
        <span class="enscript-comment">// Retrieve the index of the first page corresponding to the offset.
</span>        currentPageIndex = atop_32(offsetInIOPL);
    }

    <span class="enscript-comment">// enter mappings
</span>    remain  = size;
    mapAddr = addr;
    addr    += pageOffset;

    <span class="enscript-keyword">while</span> (remain &amp;&amp; (KERN_SUCCESS == err))
    {
            entryOffset = offset - entry-&gt;offset;
            <span class="enscript-keyword">if</span> ((page_mask &amp; entryOffset) != pageOffset) 
            {
                err = kIOReturnNotAligned;
                <span class="enscript-keyword">break</span>;
            }

	    <span class="enscript-keyword">if</span> (kIODefaultCache != cacheMode)
	    {
		vm_size_t unused = 0;
		err = mach_make_memory_entry(NULL <span class="enscript-comment">/*unused*/</span>, &amp;unused, 0 <span class="enscript-comment">/*unused*/</span>, 
					     memEntryCacheMode, NULL, entry-&gt;entry);
		assert (KERN_SUCCESS == err);
	    }

            entryOffset -= pageOffset;
            <span class="enscript-keyword">if</span> (entryOffset &gt;= entry-&gt;size) panic(<span class="enscript-string">&quot;entryOffset&quot;</span>);
            chunk = entry-&gt;size - entryOffset;
            <span class="enscript-keyword">if</span> (chunk)
            {
                <span class="enscript-keyword">if</span> (chunk &gt; remain) chunk = remain;
		<span class="enscript-keyword">if</span> (options &amp; kIOMapPrefault) 
		{
                    UInt nb_pages = round_page(chunk) / PAGE_SIZE;
                    err = vm_map_enter_mem_object_prefault(map,
                                                           &amp;mapAddr,
                                                           chunk, 0 <span class="enscript-comment">/* mask */</span>, 
                                                            (VM_FLAGS_FIXED
                                                           | VM_FLAGS_OVERWRITE
                                                           | VM_MAKE_TAG(tag)
                                                           | VM_FLAGS_IOKIT_ACCT), <span class="enscript-comment">/* iokit accounting */</span>
                                                           entry-&gt;entry,
                                                           entryOffset,
                                                           prot, <span class="enscript-comment">// cur
</span>                                                           prot, <span class="enscript-comment">// max
</span>                                                           &amp;pageList[currentPageIndex],
						           nb_pages);

                    <span class="enscript-comment">// Compute the next index in the page list.
</span>                    currentPageIndex += nb_pages;
                    assert(currentPageIndex &lt;= _pages);
		} 
		<span class="enscript-keyword">else</span> 
		{
                    err = vm_map_enter_mem_object(map,
                                                  &amp;mapAddr,
                                                  chunk, 0 <span class="enscript-comment">/* mask */</span>, 
                                                   (VM_FLAGS_FIXED
                                                  | VM_FLAGS_OVERWRITE
                                                  | VM_MAKE_TAG(tag)
                                                  | VM_FLAGS_IOKIT_ACCT), <span class="enscript-comment">/* iokit accounting */</span>
                                                  entry-&gt;entry,
                                                  entryOffset,
                                                  false, <span class="enscript-comment">// copy
</span>                                                  prot, <span class="enscript-comment">// cur
</span>                                                  prot, <span class="enscript-comment">// max
</span>                                                  VM_INHERIT_NONE);
                }
                <span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;
                remain -= chunk;
                <span class="enscript-keyword">if</span> (!remain) <span class="enscript-keyword">break</span>;
                mapAddr  += chunk;
                offset   += chunk - pageOffset;
            }
            pageOffset = 0;
            entry++;
            entryIdx++;
            <span class="enscript-keyword">if</span> (entryIdx &gt;= ref-&gt;count) 
            {
                err = kIOReturnOverrun;
                <span class="enscript-keyword">break</span>;
            }
        }

    <span class="enscript-keyword">if</span> ((KERN_SUCCESS != err) &amp;&amp; addr &amp;&amp; !(kIOMapOverwrite &amp; options))
    {
        (<span class="enscript-type">void</span>) mach_vm_deallocate(map, trunc_page_64(addr), size);
        addr = 0;
    }
    *inaddr = addr;

    <span class="enscript-keyword">return</span> (err);
}

IOReturn 
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceGetPageCounts</span>(
			       IOMemoryReference * ref,
                               IOByteCount       * residentPageCount,
                               IOByteCount       * dirtyPageCount)
{
    IOReturn        err;
    IOMemoryEntry * entries;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> resident, dirty;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> totalResident, totalDirty;

    totalResident = totalDirty = 0;
    entries = ref-&gt;entries + ref-&gt;count;
    <span class="enscript-keyword">while</span> (entries &gt; &amp;ref-&gt;entries[0])
    {
        entries--;
	err = mach_memory_entry_get_page_counts(entries-&gt;entry, &amp;resident, &amp;dirty);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;
	totalResident += resident;
	totalDirty    += dirty;
    }

    <span class="enscript-keyword">if</span> (residentPageCount) *residentPageCount = totalResident;
    <span class="enscript-keyword">if</span> (dirtyPageCount)    *dirtyPageCount    = totalDirty;
    <span class="enscript-keyword">return</span> (err);
}

IOReturn
<span class="enscript-function-name">IOGeneralMemoryDescriptor::memoryReferenceSetPurgeable</span>(
				IOMemoryReference * ref,
				IOOptionBits        newState,
				IOOptionBits      * oldState)
{
    IOReturn        err;
    IOMemoryEntry * entries;
    vm_purgable_t   control;
    <span class="enscript-type">int</span>             totalState, state;

    entries = ref-&gt;entries + ref-&gt;count;
    totalState = kIOMemoryPurgeableNonVolatile;
    <span class="enscript-keyword">while</span> (entries &gt; &amp;ref-&gt;entries[0])
    {
        entries--;

	err = purgeableControlBits(newState, &amp;control, &amp;state);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;
	err = mach_memory_entry_purgable_control(entries-&gt;entry, control, &amp;state);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;
	err = purgeableStateBits(&amp;state);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != err) <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">if</span> (kIOMemoryPurgeableEmpty == state)              totalState = kIOMemoryPurgeableEmpty;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMemoryPurgeableEmpty == totalState)    <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMemoryPurgeableVolatile == totalState) <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMemoryPurgeableVolatile == state)      totalState = kIOMemoryPurgeableVolatile;
	<span class="enscript-keyword">else</span> totalState = kIOMemoryPurgeableNonVolatile;
    }

    <span class="enscript-keyword">if</span> (oldState) *oldState = totalState;
    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withAddress</span>(<span class="enscript-type">void</span> *      address,
                                IOByteCount   length,
                                IODirection direction)
{
    <span class="enscript-keyword">return</span> IOMemoryDescriptor::
        withAddressRange((IOVirtualAddress) address, length, direction | kIOMemoryAutoPrepare, kernel_task);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withAddress</span>(IOVirtualAddress address,
                                IOByteCount  length,
                                IODirection  direction,
                                task_t       task)
{
    IOGeneralMemoryDescriptor * that = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;
    <span class="enscript-keyword">if</span> (that)
    {
	<span class="enscript-keyword">if</span> (that-&gt;initWithAddress(address, length, direction, task))
	    <span class="enscript-keyword">return</span> that;

        that-&gt;release();
    }
    <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withPhysicalAddress</span>(
				IOPhysicalAddress	address,
				IOByteCount		length,
				IODirection      	direction )
{
    <span class="enscript-keyword">return</span> (IOMemoryDescriptor::withAddressRange(address, length, direction, TASK_NULL));
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withRanges</span>(	IOVirtualRange * ranges,
				UInt32           withCount,
				IODirection      direction,
				task_t           task,
				<span class="enscript-type">bool</span>             asReference)
{
    IOGeneralMemoryDescriptor * that = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;
    <span class="enscript-keyword">if</span> (that)
    {
	<span class="enscript-keyword">if</span> (that-&gt;initWithRanges(ranges, withCount, direction, task, asReference))
	    <span class="enscript-keyword">return</span> that;

        that-&gt;release();
    }
    <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withAddressRange</span>(mach_vm_address_t address,
					mach_vm_size_t length,
					IOOptionBits   options,
					task_t         task)
{
    IOAddressRange range = { address, length };
    <span class="enscript-keyword">return</span> (IOMemoryDescriptor::withAddressRanges(&amp;range, 1, options, task));
}

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withAddressRanges</span>(IOAddressRange *   ranges,
					UInt32           rangeCount,
					IOOptionBits     options,
					task_t           task)
{
    IOGeneralMemoryDescriptor * that = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;
    <span class="enscript-keyword">if</span> (that)
    {
	<span class="enscript-keyword">if</span> (task)
	    options |= kIOMemoryTypeVirtual64;
	<span class="enscript-keyword">else</span>
	    options |= kIOMemoryTypePhysical64;

	<span class="enscript-keyword">if</span> (that-&gt;initWithOptions(ranges, rangeCount, 0, task, options, <span class="enscript-comment">/* mapper */</span> 0))
	    <span class="enscript-keyword">return</span> that;

	that-&gt;release();
    }

    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * withOptions:
 *
 * Create a new IOMemoryDescriptor. The buffer is made up of several
 * virtual address ranges, from a given task.
 *
 * Passing the ranges as a reference will avoid an extra allocation.
 */</span>
IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withOptions</span>(<span class="enscript-type">void</span> *		buffers,
                                UInt32		count,
                                UInt32		offset,
                                task_t		task,
                                IOOptionBits	opts,
                                IOMapper *	mapper)
{
    IOGeneralMemoryDescriptor *self = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;

    <span class="enscript-keyword">if</span> (self
    &amp;&amp; !self-&gt;initWithOptions(buffers, count, offset, task, opts, mapper))
    {
        self-&gt;release();
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">return</span> self;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOMemoryDescriptor::initWithOptions</span>(<span class="enscript-type">void</span> *		buffers,
                                         UInt32		count,
                                         UInt32		offset,
                                         task_t		task,
                                         IOOptionBits	options,
                                         IOMapper *	mapper)
{
    <span class="enscript-keyword">return</span>( false );
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withPhysicalRanges</span>(	IOPhysicalRange * ranges,
                                        UInt32          withCount,
                                        IODirection     direction,
                                        <span class="enscript-type">bool</span>            asReference)
{
    IOGeneralMemoryDescriptor * that = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;
    <span class="enscript-keyword">if</span> (that)
    {
	<span class="enscript-keyword">if</span> (that-&gt;initWithPhysicalRanges(ranges, withCount, direction, asReference))
	    <span class="enscript-keyword">return</span> that;

        that-&gt;release();
    }
    <span class="enscript-keyword">return</span> 0;
}

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withSubRange</span>(IOMemoryDescriptor *	of,
				IOByteCount		offset,
				IOByteCount		length,
				IODirection		direction)
{
    <span class="enscript-keyword">return</span> (IOSubMemoryDescriptor::withSubRange(of, offset, length, direction));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOMemoryDescriptor *
<span class="enscript-function-name">IOMemoryDescriptor::withPersistentMemoryDescriptor</span>(IOMemoryDescriptor *originalMD)
{
    IOGeneralMemoryDescriptor *origGenMD = 
	OSDynamicCast(IOGeneralMemoryDescriptor, originalMD);

    <span class="enscript-keyword">if</span> (origGenMD)
	<span class="enscript-keyword">return</span> IOGeneralMemoryDescriptor::
	    withPersistentMemoryDescriptor(origGenMD);
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span> 0;
}

IOMemoryDescriptor *
<span class="enscript-function-name">IOGeneralMemoryDescriptor::withPersistentMemoryDescriptor</span>(IOGeneralMemoryDescriptor *originalMD)
{
    IOMemoryReference * memRef;
    
    <span class="enscript-keyword">if</span> (kIOReturnSuccess != originalMD-&gt;memoryReferenceCreate(kIOMemoryReferenceReuse, &amp;memRef)) <span class="enscript-keyword">return</span> (0);

    <span class="enscript-keyword">if</span> (memRef == originalMD-&gt;_memRef)
    {
	originalMD-&gt;retain();		    <span class="enscript-comment">// Add a new reference to ourselves
</span>        originalMD-&gt;memoryReferenceRelease(memRef);
	<span class="enscript-keyword">return</span> originalMD;
    }

    IOGeneralMemoryDescriptor * self = <span class="enscript-keyword">new</span> IOGeneralMemoryDescriptor;
    IOMDPersistentInitData initData = { originalMD, memRef };

    <span class="enscript-keyword">if</span> (self
    &amp;&amp; !self-&gt;initWithOptions(&amp;initData, 1, 0, 0, kIOMemoryTypePersistentMD, 0)) {
        self-&gt;release();
	self = 0;
    }
    <span class="enscript-keyword">return</span> self;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithAddress</span>(<span class="enscript-type">void</span> *      address,
                                    IOByteCount   withLength,
                                    IODirection withDirection)
{
    _singleRange.v.address = (vm_offset_t) address;
    _singleRange.v.length  = withLength;

    <span class="enscript-keyword">return</span> initWithRanges(&amp;_singleRange.v, 1, withDirection, kernel_task, true);
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithAddress</span>(IOVirtualAddress address,
                                    IOByteCount    withLength,
                                    IODirection  withDirection,
                                    task_t       withTask)
{
    _singleRange.v.address = address;
    _singleRange.v.length  = withLength;

    <span class="enscript-keyword">return</span> initWithRanges(&amp;_singleRange.v, 1, withDirection, withTask, true);
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithPhysicalAddress</span>(
				 IOPhysicalAddress	address,
				 IOByteCount		withLength,
				 IODirection      	withDirection )
{
    _singleRange.p.address = address;
    _singleRange.p.length  = withLength;

    <span class="enscript-keyword">return</span> initWithPhysicalRanges( &amp;_singleRange.p, 1, withDirection, true);
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithPhysicalRanges</span>(
                                IOPhysicalRange * ranges,
                                UInt32            count,
                                IODirection       direction,
                                <span class="enscript-type">bool</span>              reference)
{
    IOOptionBits mdOpts = direction | kIOMemoryTypePhysical;

    <span class="enscript-keyword">if</span> (reference)
        mdOpts |= kIOMemoryAsReference;

    <span class="enscript-keyword">return</span> initWithOptions(ranges, count, 0, 0, mdOpts, <span class="enscript-comment">/* mapper */</span> 0);
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithRanges</span>(
                                   IOVirtualRange * ranges,
                                   UInt32           count,
                                   IODirection      direction,
                                   task_t           task,
                                   <span class="enscript-type">bool</span>             reference)
{
    IOOptionBits mdOpts = direction;

    <span class="enscript-keyword">if</span> (reference)
        mdOpts |= kIOMemoryAsReference;

    <span class="enscript-keyword">if</span> (task) {
        mdOpts |= kIOMemoryTypeVirtual;

	<span class="enscript-comment">// Auto-prepare if this is a kernel memory descriptor as very few
</span>	<span class="enscript-comment">// clients bother to prepare() kernel memory.
</span>	<span class="enscript-comment">// But it was not enforced so what are you going to do?
</span>        <span class="enscript-keyword">if</span> (task == kernel_task)
            mdOpts |= kIOMemoryAutoPrepare;
    }
    <span class="enscript-keyword">else</span>
        mdOpts |= kIOMemoryTypePhysical;
    
    <span class="enscript-keyword">return</span> initWithOptions(ranges, count, 0, task, mdOpts, <span class="enscript-comment">/* mapper */</span> 0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*
 * initWithOptions:
 *
 *  IOMemoryDescriptor. The buffer is made up of several virtual address ranges,
 * from a given task, several physical ranges, an UPL from the ubc
 * system or a uio (may be 64bit) from the BSD subsystem.
 *
 * Passing the ranges as a reference will avoid an extra allocation.
 *
 * An IOMemoryDescriptor can be re-used by calling initWithOptions again on an
 * existing instance -- note this behavior is not commonly supported in other
 * I/O Kit classes, although it is supported here.
 */</span>

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOGeneralMemoryDescriptor::initWithOptions</span>(<span class="enscript-type">void</span> *	buffers,
                                           UInt32	count,
                                           UInt32	offset,
                                           task_t	task,
                                           IOOptionBits	options,
                                           IOMapper *	mapper)
{
    IOOptionBits type = options &amp; kIOMemoryTypeMask;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (task
        &amp;&amp; (kIOMemoryTypeVirtual == type)
        &amp;&amp; vm_map_is_64bit(get_task_map(task)) 
        &amp;&amp; ((IOVirtualRange *) buffers)-&gt;address)
    {
        OSReportWithBacktrace(<span class="enscript-string">&quot;IOMemoryDescriptor: attempt to create 32b virtual in 64b task, use ::withAddressRange()&quot;</span>);
        <span class="enscript-keyword">return</span> false;
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-comment">// Grab the original MD's configuation data to initialse the
</span>    <span class="enscript-comment">// arguments to this function.
</span>    <span class="enscript-keyword">if</span> (kIOMemoryTypePersistentMD == type) {

	IOMDPersistentInitData *initData = (typeof(initData)) buffers;
	<span class="enscript-type">const</span> IOGeneralMemoryDescriptor *orig = initData-&gt;fMD;
	ioGMDData *dataP = getDataP(orig-&gt;_memoryEntries);

	<span class="enscript-comment">// Only accept persistent memory descriptors with valid dataP data.
</span>	assert(orig-&gt;_rangesCount == 1);
	<span class="enscript-keyword">if</span> ( !(orig-&gt;_flags &amp; kIOMemoryPersistent) || !dataP)
	    <span class="enscript-keyword">return</span> false;

	_memRef = initData-&gt;fMemRef;	<span class="enscript-comment">// Grab the new named entry
</span>	options = orig-&gt;_flags &amp; ~kIOMemoryAsReference; 
        type = options &amp; kIOMemoryTypeMask;
	buffers = orig-&gt;_ranges.v;
	count = orig-&gt;_rangesCount;

	<span class="enscript-comment">// Now grab the original task and whatever mapper was previously used
</span>	task = orig-&gt;_task;
	mapper = dataP-&gt;fMapper;

	<span class="enscript-comment">// We are ready to go through the original initialisation now
</span>    }

    <span class="enscript-keyword">switch</span> (type) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeUIO</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeVirtual</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeVirtual64</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
        assert(task);
        <span class="enscript-keyword">if</span> (!task)
            <span class="enscript-keyword">return</span> false;
	<span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypePhysical</span>:		<span class="enscript-comment">// Neither Physical nor UPL should have a task
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypePhysical64</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeUPL</span>:
        assert(!task);
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        <span class="enscript-keyword">return</span> false;	<span class="enscript-comment">/* bad argument */</span>
    }

    assert(buffers);
    assert(count);

    <span class="enscript-comment">/*
     * We can check the _initialized  instance variable before having ever set
     * it to an initial value because I/O Kit guarantees that all our instance
     * variables are zeroed on an object's allocation.
     */</span>

    <span class="enscript-keyword">if</span> (_initialized) {
        <span class="enscript-comment">/*
         * An existing memory descriptor is being retargeted to point to
         * somewhere else.  Clean up our present state.
         */</span>
	IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
	<span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical != type) &amp;&amp; (kIOMemoryTypePhysical64 != type))
	{
	    <span class="enscript-keyword">while</span> (_wireCount)
		complete();
	}
        <span class="enscript-keyword">if</span> (_ranges.v &amp;&amp; !(kIOMemoryAsReference &amp; _flags))
	{
	    <span class="enscript-keyword">if</span> (kIOMemoryTypeUIO == type)
		uio_free((uio_t) _ranges.v);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kIOMemoryTypeVirtual64 == type) || (kIOMemoryTypePhysical64 == type))
		IODelete(_ranges.v64, IOAddressRange, _rangesCount);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	    <span class="enscript-keyword">else</span>
		IODelete(_ranges.v, IOVirtualRange, _rangesCount);
	}

	options |= (kIOMemoryRedirected &amp; _flags);
	<span class="enscript-keyword">if</span> (!(kIOMemoryRedirected &amp; options))
	{
	    <span class="enscript-keyword">if</span> (_memRef)
	    {
		memoryReferenceRelease(_memRef);
		_memRef = 0;
	    }
	    <span class="enscript-keyword">if</span> (_mappings)
		_mappings-&gt;flushCollection();
	}
    }
    <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (!super::init())
            <span class="enscript-keyword">return</span> false;
        _initialized = true;
    }

    <span class="enscript-comment">// Grab the appropriate mapper
</span>    <span class="enscript-keyword">if</span> (kIOMemoryHostOnly &amp; options) options |= kIOMemoryMapperNone;
    <span class="enscript-keyword">if</span> (kIOMemoryMapperNone &amp; options)
        mapper = 0;	<span class="enscript-comment">// No Mapper
</span>    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mapper == kIOMapperSystem) {
        <span class="enscript-reference">IOMapper</span>::checkForSystemMapper();
        gIOSystemMapper = mapper = IOMapper::gSystem;
    }

    <span class="enscript-comment">// Temp binary compatibility for kIOMemoryThreadSafe
</span>    <span class="enscript-keyword">if</span> (kIOMemoryReserved6156215 &amp; options)
    {
	options &amp;= ~kIOMemoryReserved6156215;
	options |= kIOMemoryThreadSafe;
    }
    <span class="enscript-comment">// Remove the dynamic internal use flags from the initial setting
</span>    options 		  &amp;= ~(kIOMemoryPreparedReadOnly);
    _flags		   = options;
    _task                  = task;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    _direction             = (IODirection) (_flags &amp; kIOMemoryDirectionMask);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    __iomd_reservedA = 0;
    __iomd_reservedB = 0;
    _highestPage = 0;

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; options)
    {
	<span class="enscript-keyword">if</span> (!_prepareLock)
	    _prepareLock = IOLockAlloc();
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_prepareLock)
    {
	IOLockFree(_prepareLock);
	_prepareLock = NULL;
    }
	
    <span class="enscript-keyword">if</span> (kIOMemoryTypeUPL == type) {

        ioGMDData *dataP;
        <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dataSize = computeDataSize(<span class="enscript-comment">/* pages */</span> 0, <span class="enscript-comment">/* upls */</span> 1);

        <span class="enscript-keyword">if</span> (!initMemoryEntries(dataSize, mapper)) <span class="enscript-keyword">return</span> (false);
        dataP = getDataP(_memoryEntries);
        dataP-&gt;fPageCnt = 0;

 <span class="enscript-comment">//       _wireCount++;	// UPLs start out life wired
</span>
        _length    = count;
        _pages    += atop_32(offset + count + PAGE_MASK) - atop_32(offset);

        ioPLBlock iopl;
        iopl.fIOPL = (upl_t) buffers;
        upl_set_referenced(iopl.fIOPL, true);
        upl_page_info_t *pageList = UPL_GET_INTERNAL_PAGE_LIST(iopl.fIOPL);

	<span class="enscript-keyword">if</span> (upl_get_size(iopl.fIOPL) &lt; (count + offset))
	    panic(<span class="enscript-string">&quot;short external upl&quot;</span>);

        _highestPage = upl_get_highest_page(iopl.fIOPL);

        <span class="enscript-comment">// Set the flag kIOPLOnDevice convieniently equal to 1
</span>        iopl.fFlags  = pageList-&gt;device | kIOPLExternUPL;
        <span class="enscript-keyword">if</span> (!pageList-&gt;device) {
            <span class="enscript-comment">// Pre-compute the offset into the UPL's page list
</span>            pageList = &amp;pageList[atop_32(offset)];
            offset &amp;= PAGE_MASK;
        }
        iopl.fIOMDOffset = 0;
        iopl.fMappedPage = 0;
        iopl.fPageInfo = (vm_address_t) pageList;
        iopl.fPageOffset = offset;
        _memoryEntries-&gt;appendBytes(&amp;iopl, <span class="enscript-keyword">sizeof</span>(iopl));
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// kIOMemoryTypeVirtual  | kIOMemoryTypeVirtual64 | kIOMemoryTypeUIO 
</span>	<span class="enscript-comment">// kIOMemoryTypePhysical | kIOMemoryTypePhysical64
</span>	
	<span class="enscript-comment">// Initialize the memory descriptor
</span>	<span class="enscript-keyword">if</span> (options &amp; kIOMemoryAsReference) {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	    _rangesIsAllocated = false;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

	    <span class="enscript-comment">// Hack assignment to get the buffer arg into _ranges.
</span>	    <span class="enscript-comment">// I'd prefer to do _ranges = (Ranges) buffers, but that doesn't
</span>	    <span class="enscript-comment">// work, C++ sigh.
</span>	    <span class="enscript-comment">// This also initialises the uio &amp; physical ranges.
</span>	    _ranges.v = (IOVirtualRange *) buffers;
	}
	<span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	    _rangesIsAllocated = true;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	    <span class="enscript-keyword">switch</span> (type)
	    {
	      <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeUIO</span>:
		_ranges.v = (IOVirtualRange *) uio_duplicate((uio_t) buffers);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	      <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeVirtual64</span>:
	      <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypePhysical64</span>:
		<span class="enscript-keyword">if</span> (count == 1
		    &amp;&amp; (((IOAddressRange *) buffers)-&gt;address + ((IOAddressRange *) buffers)-&gt;length) &lt;= 0x100000000ULL
		    ) {
		    <span class="enscript-keyword">if</span> (kIOMemoryTypeVirtual64 == type)
			type = kIOMemoryTypeVirtual;
		    <span class="enscript-keyword">else</span>
			type = kIOMemoryTypePhysical;
		    _flags = (_flags &amp; ~kIOMemoryTypeMask) | type | kIOMemoryAsReference;
		    _rangesIsAllocated = false;
		    _ranges.v = &amp;_singleRange.v;
		    _singleRange.v.address = ((IOAddressRange *) buffers)-&gt;address;
		    _singleRange.v.length  = ((IOAddressRange *) buffers)-&gt;length;
		    <span class="enscript-keyword">break</span>;
		}
		_ranges.v64 = IONew(IOAddressRange, count);
		<span class="enscript-keyword">if</span> (!_ranges.v64)
		    <span class="enscript-keyword">return</span> false;
		bcopy(buffers, _ranges.v, count * <span class="enscript-keyword">sizeof</span>(IOAddressRange));
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	      <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypeVirtual</span>:
	      <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryTypePhysical</span>:
		<span class="enscript-keyword">if</span> (count == 1) {
		    _flags |= kIOMemoryAsReference;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
		    _rangesIsAllocated = false;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
		    _ranges.v = &amp;_singleRange.v;
		} <span class="enscript-keyword">else</span> {
		    _ranges.v = IONew(IOVirtualRange, count);
		    <span class="enscript-keyword">if</span> (!_ranges.v)
			<span class="enscript-keyword">return</span> false;
		}
		bcopy(buffers, _ranges.v, count * <span class="enscript-keyword">sizeof</span>(IOVirtualRange));
		<span class="enscript-keyword">break</span>;
	    }
	} 

	<span class="enscript-comment">// Find starting address within the vector of ranges
</span>	Ranges vec = _ranges;
	UInt32 length = 0;
	UInt32 pages = 0;
	<span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> ind = 0; ind &lt; count;  ind++) {
	    mach_vm_address_t addr;
	    mach_vm_size_t len;

	    <span class="enscript-comment">// addr &amp; len are returned by this function
</span>	    getAddrLenForInd(addr, len, type, vec, ind);
	    pages += (atop_64(addr + len + PAGE_MASK) - atop_64(addr));
	    len += length;
	    assert(len &gt;= length);	<span class="enscript-comment">// Check for 32 bit wrap around
</span>	    length = len;

	    <span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type))
	    {
		ppnum_t highPage = atop_64(addr + len - 1);
		<span class="enscript-keyword">if</span> (highPage &gt; _highestPage)
		    _highestPage = highPage;
	    }
	} 
	_length      = length;
	_pages       = pages;
	_rangesCount = count;

        <span class="enscript-comment">// Auto-prepare memory at creation time.
</span>        <span class="enscript-comment">// Implied completion when descriptor is free-ed
</span>        <span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type))
            _wireCount++;	<span class="enscript-comment">// Physical MDs are, by definition, wired
</span>        <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* kIOMemoryTypeVirtual | kIOMemoryTypeVirtual64 | kIOMemoryTypeUIO */</span>
            ioGMDData *dataP;
            <span class="enscript-type">unsigned</span> dataSize = computeDataSize(_pages, <span class="enscript-comment">/* upls */</span> count * 2);

            <span class="enscript-keyword">if</span> (!initMemoryEntries(dataSize, mapper)) <span class="enscript-keyword">return</span> false;
            dataP = getDataP(_memoryEntries);
            dataP-&gt;fPageCnt = _pages;

	    <span class="enscript-keyword">if</span> ( (kIOMemoryPersistent &amp; _flags) &amp;&amp; !_memRef)
	    {
		IOReturn 
		err = memoryReferenceCreate(0, &amp;_memRef);
		<span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">return</span> false;
	    }

            <span class="enscript-keyword">if</span> ((_flags &amp; kIOMemoryAutoPrepare)
             &amp;&amp; prepare() != kIOReturnSuccess)
                <span class="enscript-keyword">return</span> false;
        }
    }

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">/*
 * free
 *
 * Free resources.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::free</span>()
{
    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;

    <span class="enscript-keyword">if</span>( reserved)
    {
	LOCK;
	reserved-&gt;dp.memory = 0;
	UNLOCK;
    }
    <span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type))
    {
	ioGMDData * dataP;
	<span class="enscript-keyword">if</span> (_memoryEntries &amp;&amp; (dataP = getDataP(_memoryEntries)) &amp;&amp; dataP-&gt;fMappedBase)
	{
	    dataP-&gt;fMapper-&gt;iovmUnmapMemory(<span class="enscript-keyword">this</span>, NULL, dataP-&gt;fMappedBase, dataP-&gt;fMappedLength);
	    dataP-&gt;fMappedBase = 0;
	}
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-keyword">while</span> (_wireCount) complete();
    }

    <span class="enscript-keyword">if</span> (_memoryEntries) _memoryEntries-&gt;release();

    <span class="enscript-keyword">if</span> (_ranges.v &amp;&amp; !(kIOMemoryAsReference &amp; _flags))
    {
	<span class="enscript-keyword">if</span> (kIOMemoryTypeUIO == type)
	    uio_free((uio_t) _ranges.v);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kIOMemoryTypeVirtual64 == type) || (kIOMemoryTypePhysical64 == type))
	    IODelete(_ranges.v64, IOAddressRange, _rangesCount);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	<span class="enscript-keyword">else</span>
	    IODelete(_ranges.v, IOVirtualRange, _rangesCount);

	_ranges.v = NULL;
    }

    <span class="enscript-keyword">if</span> (reserved)
    {
        <span class="enscript-keyword">if</span> (reserved-&gt;dp.devicePager)
        {
            <span class="enscript-comment">// memEntry holds a ref on the device pager which owns reserved
</span>            <span class="enscript-comment">// (IOMemoryDescriptorReserved) so no reserved access after this point
</span>            device_pager_deallocate( (memory_object_t) reserved-&gt;dp.devicePager );
        }
        <span class="enscript-keyword">else</span>
            IODelete(reserved, IOMemoryDescriptorReserved, 1);
        reserved = NULL;
    }

    <span class="enscript-keyword">if</span> (_memRef)      memoryReferenceRelease(_memRef);
    <span class="enscript-keyword">if</span> (_prepareLock) IOLockFree(_prepareLock);

    <span class="enscript-reference">super</span>::free();
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::unmapFromKernel</span>()
{
    panic(<span class="enscript-string">&quot;IOGMD::unmapFromKernel deprecated&quot;</span>);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::mapIntoKernel</span>(<span class="enscript-type">unsigned</span> rangeIndex)
{
    panic(<span class="enscript-string">&quot;IOGMD::mapIntoKernel deprecated&quot;</span>);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/*
 * getDirection:
 *
 * Get the direction of the transfer.
 */</span>
IODirection <span class="enscript-function-name">IOMemoryDescriptor::getDirection</span>() <span class="enscript-type">const</span>
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (_direction)
	<span class="enscript-keyword">return</span> _direction;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    <span class="enscript-keyword">return</span> (IODirection) (_flags &amp; kIOMemoryDirectionMask);
}

<span class="enscript-comment">/*
 * getLength:
 *
 * Get the length of the transfer (over all ranges).
 */</span>
IOByteCount <span class="enscript-function-name">IOMemoryDescriptor::getLength</span>() <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span> _length;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::setTag</span>( IOOptionBits tag )
{
    _tag = tag;    
}

IOOptionBits <span class="enscript-function-name">IOMemoryDescriptor::getTag</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( _tag);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">// @@@ gvdl: who is using this API?  Seems like a wierd thing to implement.
</span>IOPhysicalAddress
<span class="enscript-function-name">IOMemoryDescriptor::getSourceSegment</span>( IOByteCount   offset, IOByteCount * length )
{
    addr64_t physAddr = 0;

    <span class="enscript-keyword">if</span>( prepare() == kIOReturnSuccess) {
        physAddr = getPhysicalSegment64( offset, length );
        complete();
    }

    <span class="enscript-keyword">return</span>( (IOPhysicalAddress) physAddr ); <span class="enscript-comment">// truncated but only page offset is used
</span>}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOByteCount IOMemoryDescriptor::readBytes
                (IOByteCount offset, <span class="enscript-type">void</span> *bytes, IOByteCount length)
{
    addr64_t dstAddr = CAST_DOWN(addr64_t, bytes);
    IOByteCount remaining;

    <span class="enscript-comment">// Assert that this entire I/O is withing the available range
</span>    assert(offset &lt;= _length);
    assert(offset + length &lt;= _length);
    <span class="enscript-keyword">if</span> (offset &gt;= _length) {
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	LOCK;

    remaining = length = min(length, _length - offset);
    <span class="enscript-keyword">while</span> (remaining) {	<span class="enscript-comment">// (process another target segment?)
</span>        addr64_t	srcAddr64;
        IOByteCount	srcLen;

        srcAddr64 = getPhysicalSegment(offset, &amp;srcLen, kIOMemoryMapperNone);
        <span class="enscript-keyword">if</span> (!srcAddr64)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Clip segment length to remaining
</span>        <span class="enscript-keyword">if</span> (srcLen &gt; remaining)
            srcLen = remaining;

        copypv(srcAddr64, dstAddr, srcLen,
                            cppvPsrc | cppvNoRefSrc | cppvFsnk | cppvKmap);

        dstAddr   += srcLen;
        offset    += srcLen;
        remaining -= srcLen;
    }

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	UNLOCK;

    assert(!remaining);

    <span class="enscript-keyword">return</span> length - remaining;
}

IOByteCount IOMemoryDescriptor::writeBytes
                (IOByteCount inoffset, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *bytes, IOByteCount length)
{
    addr64_t srcAddr = CAST_DOWN(addr64_t, bytes);
    IOByteCount remaining;
    IOByteCount offset = inoffset;

    <span class="enscript-comment">// Assert that this entire I/O is withing the available range
</span>    assert(offset &lt;= _length);
    assert(offset + length &lt;= _length);

    assert( !(kIOMemoryPreparedReadOnly &amp; _flags) );

    <span class="enscript-keyword">if</span> ( (kIOMemoryPreparedReadOnly &amp; _flags) || offset &gt;= _length) {
        <span class="enscript-keyword">return</span> 0;
    }

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	LOCK;

    remaining = length = min(length, _length - offset);
    <span class="enscript-keyword">while</span> (remaining) {	<span class="enscript-comment">// (process another target segment?)
</span>        addr64_t    dstAddr64;
        IOByteCount dstLen;

        dstAddr64 = getPhysicalSegment(offset, &amp;dstLen, kIOMemoryMapperNone);
        <span class="enscript-keyword">if</span> (!dstAddr64)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Clip segment length to remaining
</span>        <span class="enscript-keyword">if</span> (dstLen &gt; remaining)
            dstLen = remaining;

	<span class="enscript-keyword">if</span> (!srcAddr) bzero_phys(dstAddr64, dstLen);
	<span class="enscript-keyword">else</span>
	{
	    copypv(srcAddr, (addr64_t) dstAddr64, dstLen,
		    cppvPsnk | cppvFsnk | cppvNoRefSrc | cppvNoModSnk | cppvKmap);
	    srcAddr   += dstLen;
	}
        offset    += dstLen;
        remaining -= dstLen;
    }

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	UNLOCK;

    assert(!remaining);

    <span class="enscript-keyword">if</span> (!srcAddr) performOperation(kIOMemoryIncoherentIOFlush, inoffset, length);

    <span class="enscript-keyword">return</span> length - remaining;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::setPosition</span>(IOByteCount position)
{
    panic(<span class="enscript-string">&quot;IOGMD::setPosition deprecated&quot;</span>);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> SInt64 gIOMDPreparationID <span class="enscript-function-name">__attribute__</span>((aligned(8))) = (1ULL &lt;&lt; 32);

uint64_t
<span class="enscript-function-name">IOGeneralMemoryDescriptor::getPreparationID</span>( <span class="enscript-type">void</span> )
{
    ioGMDData *dataP;

    <span class="enscript-keyword">if</span> (!_wireCount)
	<span class="enscript-keyword">return</span> (kIOPreparationIDUnprepared);

    <span class="enscript-keyword">if</span> (((kIOMemoryTypeMask &amp; _flags) == kIOMemoryTypePhysical)
      || ((kIOMemoryTypeMask &amp; _flags) == kIOMemoryTypePhysical64))
    {
        <span class="enscript-reference">IOMemoryDescriptor</span>::setPreparationID();
        <span class="enscript-keyword">return</span> (IOMemoryDescriptor::getPreparationID());
    }

    <span class="enscript-keyword">if</span> (!_memoryEntries || !(dataP = getDataP(_memoryEntries)))
	<span class="enscript-keyword">return</span> (kIOPreparationIDUnprepared);

    <span class="enscript-keyword">if</span> (kIOPreparationIDUnprepared == dataP-&gt;fPreparationID)
    {
	dataP-&gt;fPreparationID = OSIncrementAtomic64(&amp;gIOMDPreparationID);
    }
    <span class="enscript-keyword">return</span> (dataP-&gt;fPreparationID);
}

IOMemoryDescriptorReserved * <span class="enscript-function-name">IOMemoryDescriptor::getKernelReserved</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (!reserved)
    {
        reserved = IONew(IOMemoryDescriptorReserved, 1);
        <span class="enscript-keyword">if</span> (reserved)
            bzero(reserved, <span class="enscript-keyword">sizeof</span>(IOMemoryDescriptorReserved));
    }
    <span class="enscript-keyword">return</span> (reserved);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::setPreparationID</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (getKernelReserved() &amp;&amp; (kIOPreparationIDUnprepared == reserved-&gt;preparationID))
    {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__ppc__ </span>)
        reserved-&gt;preparationID = gIOMDPreparationID++;
#<span class="enscript-reference">else</span>
        reserved-&gt;preparationID = OSIncrementAtomic64(&amp;gIOMDPreparationID);
#<span class="enscript-reference">endif</span>
    }
}

uint64_t <span class="enscript-function-name">IOMemoryDescriptor::getPreparationID</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span> (reserved)
        <span class="enscript-keyword">return</span> (reserved-&gt;preparationID);    
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span> (kIOPreparationIDUnsupported);    
}

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::dmaCommandOperation</span>(DMACommandOps op, <span class="enscript-type">void</span> *vData, UInt dataSize) <span class="enscript-type">const</span>
{
    IOReturn err = kIOReturnSuccess;
    DMACommandOps params;
    IOGeneralMemoryDescriptor * md = const_cast&lt;IOGeneralMemoryDescriptor *&gt;(<span class="enscript-keyword">this</span>);
    ioGMDData *dataP;

    params = (op &amp; ~kIOMDDMACommandOperationMask &amp; op);
    op &amp;= kIOMDDMACommandOperationMask;

    <span class="enscript-keyword">if</span> (kIOMDDMAMap == op)
    {
	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IOMDDMAMapArgs))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;

	IOMDDMAMapArgs * data = (IOMDDMAMapArgs *) vData;

	<span class="enscript-keyword">if</span> (!_memoryEntries 
	    &amp;&amp; !md-&gt;initMemoryEntries(computeDataSize(0, 0), kIOMapperWaitSystem)) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

	<span class="enscript-keyword">if</span> (_memoryEntries &amp;&amp; data-&gt;fMapper)
	{
	    <span class="enscript-type">bool</span> remap, keepMap;
	    dataP = getDataP(_memoryEntries);

	    <span class="enscript-keyword">if</span> (data-&gt;fMapSpec.numAddressBits &lt; dataP-&gt;fDMAMapNumAddressBits) dataP-&gt;fDMAMapNumAddressBits = data-&gt;fMapSpec.numAddressBits;
	    <span class="enscript-keyword">if</span> (data-&gt;fMapSpec.alignment      &gt; dataP-&gt;fDMAMapAlignment)      dataP-&gt;fDMAMapAlignment      = data-&gt;fMapSpec.alignment;

	    keepMap = (data-&gt;fMapper == gIOSystemMapper);
	    keepMap &amp;= ((data-&gt;fOffset == 0) &amp;&amp; (data-&gt;fLength == _length));

	    remap = (!keepMap);
	    remap |= (dataP-&gt;fDMAMapNumAddressBits &lt; 64)
	    	  &amp;&amp; ((dataP-&gt;fMappedBase + _length) &gt; (1ULL &lt;&lt; dataP-&gt;fDMAMapNumAddressBits));
	    remap |= (dataP-&gt;fDMAMapAlignment &gt; page_size);

	    <span class="enscript-keyword">if</span> (remap || !dataP-&gt;fMappedBase)
	    {
<span class="enscript-comment">//		if (dataP-&gt;fMappedBase) OSReportWithBacktrace(&quot;kIOMDDMAMap whole %d remap %d params %d\n&quot;, whole, remap, params);
</span>	    	err = md-&gt;dmaMap(data-&gt;fMapper, data-&gt;fCommand, &amp;data-&gt;fMapSpec, data-&gt;fOffset, data-&gt;fLength, &amp;data-&gt;fAlloc, &amp;data-&gt;fAllocLength);
		<span class="enscript-keyword">if</span> (keepMap &amp;&amp; (kIOReturnSuccess == err) &amp;&amp; !dataP-&gt;fMappedBase)
		{
		    dataP-&gt;fMappedBase   = data-&gt;fAlloc;
		    dataP-&gt;fMappedLength = data-&gt;fAllocLength;
		    data-&gt;fAllocLength   = 0; 			<span class="enscript-comment">// IOMD owns the alloc now
</span>		}
	    }
	    <span class="enscript-keyword">else</span>
	    {
	    	data-&gt;fAlloc = dataP-&gt;fMappedBase;
		data-&gt;fAllocLength = 0; 			<span class="enscript-comment">// give out IOMD map
</span>	    }
	    data-&gt;fMapContig = !dataP-&gt;fDiscontig;
	}

	<span class="enscript-keyword">return</span> (err);				
    }

    <span class="enscript-keyword">if</span> (kIOMDAddDMAMapSpec == op)
    {
	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IODMAMapSpecification))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;

	IODMAMapSpecification * data = (IODMAMapSpecification *) vData;

	<span class="enscript-keyword">if</span> (!_memoryEntries 
	    &amp;&amp; !md-&gt;initMemoryEntries(computeDataSize(0, 0), kIOMapperWaitSystem)) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

	<span class="enscript-keyword">if</span> (_memoryEntries)
	{
	    dataP = getDataP(_memoryEntries);
	    <span class="enscript-keyword">if</span> (data-&gt;numAddressBits &lt; dataP-&gt;fDMAMapNumAddressBits)
	     	dataP-&gt;fDMAMapNumAddressBits = data-&gt;numAddressBits;
	    <span class="enscript-keyword">if</span> (data-&gt;alignment &gt; dataP-&gt;fDMAMapAlignment)
	     	dataP-&gt;fDMAMapAlignment = data-&gt;alignment;
	}
	<span class="enscript-keyword">return</span> kIOReturnSuccess;
    }

    <span class="enscript-keyword">if</span> (kIOMDGetCharacteristics == op) {

	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IOMDDMACharacteristics))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;

	IOMDDMACharacteristics *data = (IOMDDMACharacteristics *) vData;
	data-&gt;fLength = _length;
	data-&gt;fSGCount = _rangesCount;
	data-&gt;fPages = _pages;
	data-&gt;fDirection = getDirection();
	<span class="enscript-keyword">if</span> (!_wireCount)
	    data-&gt;fIsPrepared = false;
	<span class="enscript-keyword">else</span> {
	    data-&gt;fIsPrepared = true;
	    data-&gt;fHighestPage = _highestPage;
	    <span class="enscript-keyword">if</span> (_memoryEntries)
	    {
		dataP = getDataP(_memoryEntries);
		ioPLBlock *ioplList = getIOPLList(dataP);
		UInt count = getNumIOPL(_memoryEntries, dataP);
		<span class="enscript-keyword">if</span> (count == 1)
		    data-&gt;fPageAlign = (ioplList[0].fPageOffset &amp; PAGE_MASK) | ~PAGE_MASK;
	    }
	}

	<span class="enscript-keyword">return</span> kIOReturnSuccess;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMD_DEBUG_DMAACTIVE</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMDDMAActive == op) {
	<span class="enscript-keyword">if</span> (params) OSIncrementAtomic(&amp;md-&gt;__iomd_reservedA);
	<span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">if</span> (md-&gt;__iomd_reservedA)
		OSDecrementAtomic(&amp;md-&gt;__iomd_reservedA);
	    <span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;kIOMDSetDMAInactive&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOMD_DEBUG_DMAACTIVE */</span>

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMDWalkSegments != op)
	<span class="enscript-keyword">return</span> kIOReturnBadArgument;

    <span class="enscript-comment">// Get the next segment
</span>    <span class="enscript-type">struct</span> InternalState {
	IOMDDMAWalkSegmentArgs fIO;
	UInt fOffset2Index;
	UInt fIndex;
	UInt fNextOffset;
    } *isP;

    <span class="enscript-comment">// Find the next segment
</span>    <span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(*isP))
	<span class="enscript-keyword">return</span> kIOReturnUnderrun;

    isP = (InternalState *) vData;
    UInt offset = isP-&gt;fIO.fOffset;
    <span class="enscript-type">bool</span> mapped = isP-&gt;fIO.fMapped;

    <span class="enscript-keyword">if</span> (IOMapper::gSystem &amp;&amp; mapped
        &amp;&amp; (!(kIOMemoryHostOnly &amp; _flags))
	&amp;&amp; (!_memoryEntries || !getDataP(_memoryEntries)-&gt;fMappedBase))
<span class="enscript-comment">//	&amp;&amp; (_memoryEntries &amp;&amp; !getDataP(_memoryEntries)-&gt;fMappedBase))
</span>    {
	<span class="enscript-keyword">if</span> (!_memoryEntries 
	    &amp;&amp; !md-&gt;initMemoryEntries(computeDataSize(0, 0), kIOMapperWaitSystem)) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

	dataP = getDataP(_memoryEntries);
	<span class="enscript-keyword">if</span> (dataP-&gt;fMapper)
	{
	    IODMAMapSpecification mapSpec;
	    bzero(&amp;mapSpec, <span class="enscript-keyword">sizeof</span>(mapSpec));
	    mapSpec.numAddressBits = dataP-&gt;fDMAMapNumAddressBits;
	    mapSpec.alignment = dataP-&gt;fDMAMapAlignment;
	    err = md-&gt;dmaMap(dataP-&gt;fMapper, NULL, &amp;mapSpec, 0, _length, &amp;dataP-&gt;fMappedBase, &amp;dataP-&gt;fMappedLength);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">return</span> (err);
	}
    }

    <span class="enscript-keyword">if</span> (offset &gt;= _length)
	<span class="enscript-keyword">return</span> (offset == _length)? kIOReturnOverrun : kIOReturnInternalError;

    <span class="enscript-comment">// Validate the previous offset
</span>    UInt ind, off2Ind = isP-&gt;fOffset2Index;
    <span class="enscript-keyword">if</span> (!params
	&amp;&amp; offset 
	&amp;&amp; (offset == isP-&gt;fNextOffset || off2Ind &lt;= offset))
	ind = isP-&gt;fIndex;
    <span class="enscript-keyword">else</span>
	ind = off2Ind = 0;	<span class="enscript-comment">// Start from beginning
</span>
    UInt length;
    UInt64 address;


    <span class="enscript-keyword">if</span> ( (_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical) {

	<span class="enscript-comment">// Physical address based memory descriptor
</span>	<span class="enscript-type">const</span> IOPhysicalRange *physP = (IOPhysicalRange *) &amp;_ranges.p[0];

	<span class="enscript-comment">// Find the range after the one that contains the offset
</span>	mach_vm_size_t len;
	<span class="enscript-keyword">for</span> (len = 0; off2Ind &lt;= offset; ind++) {
	    len = physP[ind].length;
	    off2Ind += len;
	}

	<span class="enscript-comment">// Calculate length within range and starting address
</span>	length   = off2Ind - offset;
	address  = physP[ind - 1].address + len - length;

	<span class="enscript-keyword">if</span> (true &amp;&amp; mapped &amp;&amp; _memoryEntries 
		&amp;&amp; (dataP = getDataP(_memoryEntries)) &amp;&amp; dataP-&gt;fMappedBase)
	{
	    address = dataP-&gt;fMappedBase + offset;
	}
	<span class="enscript-keyword">else</span>
	{
	    <span class="enscript-comment">// see how far we can coalesce ranges
</span>	    <span class="enscript-keyword">while</span> (ind &lt; _rangesCount &amp;&amp; address + length == physP[ind].address) {
		len = physP[ind].length;
		length += len;
		off2Ind += len;
		ind++;
	    }
	}

	<span class="enscript-comment">// correct contiguous check overshoot
</span>	ind--;
	off2Ind -= len;
    }
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical64) {

	<span class="enscript-comment">// Physical address based memory descriptor
</span>	<span class="enscript-type">const</span> IOAddressRange *physP = (IOAddressRange *) &amp;_ranges.v64[0];

	<span class="enscript-comment">// Find the range after the one that contains the offset
</span>	mach_vm_size_t len;
	<span class="enscript-keyword">for</span> (len = 0; off2Ind &lt;= offset; ind++) {
	    len = physP[ind].length;
	    off2Ind += len;
	}

	<span class="enscript-comment">// Calculate length within range and starting address
</span>	length   = off2Ind - offset;
	address  = physP[ind - 1].address + len - length;

	<span class="enscript-keyword">if</span> (true &amp;&amp; mapped &amp;&amp; _memoryEntries 
		&amp;&amp; (dataP = getDataP(_memoryEntries)) &amp;&amp; dataP-&gt;fMappedBase)
	{
	    address = dataP-&gt;fMappedBase + offset;
	}
	<span class="enscript-keyword">else</span>
	{
	    <span class="enscript-comment">// see how far we can coalesce ranges
</span>	    <span class="enscript-keyword">while</span> (ind &lt; _rangesCount &amp;&amp; address + length == physP[ind].address) {
		len = physP[ind].length;
		length += len;
		off2Ind += len;
		ind++;
	    }
	}
	<span class="enscript-comment">// correct contiguous check overshoot
</span>	ind--;
	off2Ind -= len;
    } 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">do</span> {
	<span class="enscript-keyword">if</span> (!_wireCount)
	    panic(<span class="enscript-string">&quot;IOGMD: not wired for the IODMACommand&quot;</span>);

	assert(_memoryEntries);

	dataP = getDataP(_memoryEntries);
	<span class="enscript-type">const</span> ioPLBlock *ioplList = getIOPLList(dataP);
	UInt numIOPLs = getNumIOPL(_memoryEntries, dataP);
	upl_page_info_t *pageList = getPageList(dataP);

	assert(numIOPLs &gt; 0);

	<span class="enscript-comment">// Scan through iopl info blocks looking for block containing offset
</span>	<span class="enscript-keyword">while</span> (ind &lt; numIOPLs &amp;&amp; offset &gt;= ioplList[ind].fIOMDOffset)
	    ind++;

	<span class="enscript-comment">// Go back to actual range as search goes past it
</span>	ioPLBlock ioplInfo = ioplList[ind - 1];
	off2Ind = ioplInfo.fIOMDOffset;

	<span class="enscript-keyword">if</span> (ind &lt; numIOPLs)
	    length = ioplList[ind].fIOMDOffset;
	<span class="enscript-keyword">else</span>
	    length = _length;
	length -= offset;			<span class="enscript-comment">// Remainder within iopl
</span>
	<span class="enscript-comment">// Subtract offset till this iopl in total list
</span>	offset -= off2Ind;

	<span class="enscript-comment">// If a mapped address is requested and this is a pre-mapped IOPL
</span>	<span class="enscript-comment">// then just need to compute an offset relative to the mapped base.
</span>	<span class="enscript-keyword">if</span> (mapped &amp;&amp; dataP-&gt;fMappedBase) {
	    offset += (ioplInfo.fPageOffset &amp; PAGE_MASK);
	    address = trunc_page_64(dataP-&gt;fMappedBase) + ptoa_64(ioplInfo.fMappedPage) + offset;
	    <span class="enscript-keyword">continue</span>;	<span class="enscript-comment">// Done leave do/while(false) now
</span>	}

	<span class="enscript-comment">// The offset is rebased into the current iopl.
</span>	<span class="enscript-comment">// Now add the iopl 1st page offset.
</span>	offset += ioplInfo.fPageOffset;

	<span class="enscript-comment">// For external UPLs the fPageInfo field points directly to
</span>	<span class="enscript-comment">// the upl's upl_page_info_t array.
</span>	<span class="enscript-keyword">if</span> (ioplInfo.fFlags &amp; kIOPLExternUPL)
	    pageList = (upl_page_info_t *) ioplInfo.fPageInfo;
	<span class="enscript-keyword">else</span>
	    pageList = &amp;pageList[ioplInfo.fPageInfo];

	<span class="enscript-comment">// Check for direct device non-paged memory
</span>	<span class="enscript-keyword">if</span> ( ioplInfo.fFlags &amp; kIOPLOnDevice ) {
	    address = ptoa_64(pageList-&gt;phys_addr) + offset;
	    <span class="enscript-keyword">continue</span>;	<span class="enscript-comment">// Done leave do/while(false) now
</span>	}

	<span class="enscript-comment">// Now we need compute the index into the pageList
</span>	UInt pageInd = atop_32(offset);
	offset &amp;= PAGE_MASK;

	<span class="enscript-comment">// Compute the starting address of this segment
</span>	IOPhysicalAddress pageAddr = pageList[pageInd].phys_addr;
	<span class="enscript-keyword">if</span> (!pageAddr) {
	    panic(<span class="enscript-string">&quot;!pageList phys_addr&quot;</span>);
	}

	address = ptoa_64(pageAddr) + offset;

	<span class="enscript-comment">// length is currently set to the length of the remainider of the iopl.
</span>	<span class="enscript-comment">// We need to check that the remainder of the iopl is contiguous.
</span>	<span class="enscript-comment">// This is indicated by pageList[ind].phys_addr being sequential.
</span>	IOByteCount contigLength = PAGE_SIZE - offset;
	<span class="enscript-keyword">while</span> (contigLength &lt; length
		&amp;&amp; ++pageAddr == pageList[++pageInd].phys_addr)
	{
	    contigLength += PAGE_SIZE;
	}

	<span class="enscript-keyword">if</span> (contigLength &lt; length)
	    length = contigLength;
	

	assert(address);
	assert(length);

    } <span class="enscript-keyword">while</span> (false);

    <span class="enscript-comment">// Update return values and state
</span>    isP-&gt;fIO.fIOVMAddr = address;
    isP-&gt;fIO.fLength   = length;
    isP-&gt;fIndex        = ind;
    isP-&gt;fOffset2Index = off2Ind;
    isP-&gt;fNextOffset   = isP-&gt;fIO.fOffset + length;

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

addr64_t
<span class="enscript-function-name">IOGeneralMemoryDescriptor::getPhysicalSegment</span>(IOByteCount offset, IOByteCount *lengthOfSegment, IOOptionBits options)
{
    IOReturn          ret;
    mach_vm_address_t address = 0;
    mach_vm_size_t    length  = 0;
    IOMapper *        mapper  = gIOSystemMapper;
    IOOptionBits      type    = _flags &amp; kIOMemoryTypeMask;

    <span class="enscript-keyword">if</span> (lengthOfSegment)
        *lengthOfSegment = 0;

    <span class="enscript-keyword">if</span> (offset &gt;= _length)
        <span class="enscript-keyword">return</span> 0;

    <span class="enscript-comment">// IOMemoryDescriptor::doMap() cannot use getPhysicalSegment() to obtain the page offset, since it must
</span>    <span class="enscript-comment">// support the unwired memory case in IOGeneralMemoryDescriptor, and hibernate_write_image() cannot use
</span>    <span class="enscript-comment">// map()-&gt;getVirtualAddress() to obtain the kernel pointer, since it must prevent the memory allocation
</span>    <span class="enscript-comment">// due to IOMemoryMap, so _kIOMemorySourceSegment is a necessary evil until all of this gets cleaned up
</span>
    <span class="enscript-keyword">if</span> ((options &amp; _kIOMemorySourceSegment) &amp;&amp; (kIOMemoryTypeUPL != type))
    {
        <span class="enscript-type">unsigned</span> rangesIndex = 0;
	Ranges vec = _ranges;
	mach_vm_address_t addr;

	<span class="enscript-comment">// Find starting address within the vector of ranges
</span>	<span class="enscript-keyword">for</span> (;;) {
	    getAddrLenForInd(addr, length, type, vec, rangesIndex);
	    <span class="enscript-keyword">if</span> (offset &lt; length)
		<span class="enscript-keyword">break</span>;
	    offset -= length; <span class="enscript-comment">// (make offset relative)
</span>	    rangesIndex++;
	} 

	<span class="enscript-comment">// Now that we have the starting range,
</span>	<span class="enscript-comment">// lets find the last contiguous range
</span>        addr   += offset;
        length -= offset;

        <span class="enscript-keyword">for</span> ( ++rangesIndex; rangesIndex &lt; _rangesCount; rangesIndex++ ) {
	    mach_vm_address_t newAddr;
	    mach_vm_size_t    newLen;

	    getAddrLenForInd(newAddr, newLen, type, vec, rangesIndex);
	    <span class="enscript-keyword">if</span> (addr + length != newAddr)
		<span class="enscript-keyword">break</span>;
	    length += newLen;
	} 
        <span class="enscript-keyword">if</span> (addr)
	    address = (IOPhysicalAddress) addr;	<span class="enscript-comment">// Truncate address to 32bit
</span>    }
    <span class="enscript-keyword">else</span>
    {
	IOMDDMAWalkSegmentState _state;
	IOMDDMAWalkSegmentArgs * state = (IOMDDMAWalkSegmentArgs *) (<span class="enscript-type">void</span> *)&amp;_state;

	state-&gt;fOffset = offset;
	state-&gt;fLength = _length - offset;
	state-&gt;fMapped = (0 == (options &amp; kIOMemoryMapperNone)) &amp;&amp; !(_flags &amp; kIOMemoryHostOnly);

	ret = dmaCommandOperation(kIOMDFirstSegment, _state, <span class="enscript-keyword">sizeof</span>(_state));

	<span class="enscript-keyword">if</span> ((kIOReturnSuccess != ret) &amp;&amp; (kIOReturnOverrun != ret))
		DEBG(<span class="enscript-string">&quot;getPhysicalSegment dmaCommandOperation(%lx), %p, offset %qx, addr %qx, len %qx\n&quot;</span>, 
					ret, <span class="enscript-keyword">this</span>, state-&gt;fOffset,
					state-&gt;fIOVMAddr, state-&gt;fLength);
	<span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
	{
	    address = state-&gt;fIOVMAddr;
	    length  = state-&gt;fLength;
	}

	<span class="enscript-comment">// dmaCommandOperation() does not distinguish between &quot;mapped&quot; and &quot;unmapped&quot; physical memory, even
</span>	<span class="enscript-comment">// with fMapped set correctly, so we must handle the transformation here until this gets cleaned up
</span>
	<span class="enscript-keyword">if</span> (mapper &amp;&amp; ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type)))
	{
	    <span class="enscript-keyword">if</span> ((options &amp; kIOMemoryMapperNone) &amp;&amp; !(_flags &amp; kIOMemoryMapperNone))
	    {
		addr64_t    origAddr = address;
		IOByteCount origLen  = length;

		address = mapper-&gt;mapToPhysicalAddress(origAddr);
		length = page_size - (address &amp; (page_size - 1));
		<span class="enscript-keyword">while</span> ((length &lt; origLen)
		    &amp;&amp; ((address + length) == mapper-&gt;mapToPhysicalAddress(origAddr + length)))
		    length += page_size;
		<span class="enscript-keyword">if</span> (length &gt; origLen)
		    length = origLen;
	    }
	}
    }

    <span class="enscript-keyword">if</span> (!address)
        length = 0;

    <span class="enscript-keyword">if</span> (lengthOfSegment)
        *lengthOfSegment = length;

    <span class="enscript-keyword">return</span> (address);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
addr64_t
<span class="enscript-function-name">IOMemoryDescriptor::getPhysicalSegment</span>(IOByteCount offset, IOByteCount *lengthOfSegment, IOOptionBits options)
{
    addr64_t address = 0;

    <span class="enscript-keyword">if</span> (options &amp; _kIOMemorySourceSegment)
    {
        address = getSourceSegment(offset, lengthOfSegment);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (options &amp; kIOMemoryMapperNone)
    {
        address = getPhysicalSegment64(offset, lengthOfSegment);
    }
    <span class="enscript-keyword">else</span>
    {
        address = getPhysicalSegment(offset, lengthOfSegment);
    }

    <span class="enscript-keyword">return</span> (address);
}

addr64_t
<span class="enscript-function-name">IOGeneralMemoryDescriptor::getPhysicalSegment64</span>(IOByteCount offset, IOByteCount *lengthOfSegment)
{
    <span class="enscript-keyword">return</span> (getPhysicalSegment(offset, lengthOfSegment, kIOMemoryMapperNone));
}

IOPhysicalAddress
<span class="enscript-function-name">IOGeneralMemoryDescriptor::getPhysicalSegment</span>(IOByteCount offset, IOByteCount *lengthOfSegment)
{
    addr64_t    address = 0;
    IOByteCount length  = 0;

    address = getPhysicalSegment(offset, lengthOfSegment, 0);

    <span class="enscript-keyword">if</span> (lengthOfSegment)
	length = *lengthOfSegment;

    <span class="enscript-keyword">if</span> ((address + length) &gt; 0x100000000ULL)
    {
	panic(<span class="enscript-string">&quot;getPhysicalSegment() out of 32b range 0x%qx, len 0x%lx, class %s&quot;</span>,
		    address, (<span class="enscript-type">long</span>) length, (getMetaClass())-&gt;getClassName());
    }

    <span class="enscript-keyword">return</span> ((IOPhysicalAddress) address);
}

addr64_t
<span class="enscript-function-name">IOMemoryDescriptor::getPhysicalSegment64</span>(IOByteCount offset, IOByteCount *lengthOfSegment)
{
    IOPhysicalAddress phys32;
    IOByteCount	      length;
    addr64_t 	      phys64;
    IOMapper *        mapper = 0;

    phys32 = getPhysicalSegment(offset, lengthOfSegment);
    <span class="enscript-keyword">if</span> (!phys32)
	<span class="enscript-keyword">return</span> 0;

    <span class="enscript-keyword">if</span> (gIOSystemMapper)
	mapper = gIOSystemMapper;

    <span class="enscript-keyword">if</span> (mapper)
    {
	IOByteCount origLen;

	phys64 = mapper-&gt;mapToPhysicalAddress(phys32);
	origLen = *lengthOfSegment;
	length = page_size - (phys64 &amp; (page_size - 1));
	<span class="enscript-keyword">while</span> ((length &lt; origLen)
	    &amp;&amp; ((phys64 + length) == mapper-&gt;mapToPhysicalAddress(phys32 + length)))
	    length += page_size;
	<span class="enscript-keyword">if</span> (length &gt; origLen)
	    length = origLen;

	*lengthOfSegment = length;
    }
    <span class="enscript-keyword">else</span>
	phys64 = (addr64_t) phys32;

    <span class="enscript-keyword">return</span> phys64;
}

IOPhysicalAddress
<span class="enscript-function-name">IOMemoryDescriptor::getPhysicalSegment</span>(IOByteCount offset, IOByteCount *lengthOfSegment)
{
    <span class="enscript-keyword">return</span> ((IOPhysicalAddress) getPhysicalSegment(offset, lengthOfSegment, 0));
}

IOPhysicalAddress
<span class="enscript-function-name">IOGeneralMemoryDescriptor::getSourceSegment</span>(IOByteCount offset, IOByteCount *lengthOfSegment)
{
    <span class="enscript-keyword">return</span> ((IOPhysicalAddress) getPhysicalSegment(offset, lengthOfSegment, _kIOMemorySourceSegment));
}

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOGeneralMemoryDescriptor::getVirtualSegment</span>(IOByteCount offset,
							IOByteCount * lengthOfSegment)
{
    <span class="enscript-keyword">if</span> (_task == kernel_task)
        <span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *) getSourceSegment(offset, lengthOfSegment);
    <span class="enscript-keyword">else</span>
        panic(<span class="enscript-string">&quot;IOGMD::getVirtualSegment deprecated&quot;</span>);

    <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOReturn 
<span class="enscript-function-name">IOMemoryDescriptor::dmaCommandOperation</span>(DMACommandOps op, <span class="enscript-type">void</span> *vData, UInt dataSize) <span class="enscript-type">const</span>
{
    IOMemoryDescriptor *md = const_cast&lt;IOMemoryDescriptor *&gt;(<span class="enscript-keyword">this</span>);
    DMACommandOps params;
    IOReturn err;

    params = (op &amp; ~kIOMDDMACommandOperationMask &amp; op);
    op &amp;= kIOMDDMACommandOperationMask;

    <span class="enscript-keyword">if</span> (kIOMDGetCharacteristics == op) {
	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IOMDDMACharacteristics))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;

	IOMDDMACharacteristics *data = (IOMDDMACharacteristics *) vData;
	data-&gt;fLength = getLength();
	data-&gt;fSGCount = 0;
	data-&gt;fDirection = getDirection();
	data-&gt;fIsPrepared = true;	<span class="enscript-comment">// Assume prepared - fails safe
</span>    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMDWalkSegments == op) {
	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IOMDDMAWalkSegmentArgs))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;

	IOMDDMAWalkSegmentArgs *data = (IOMDDMAWalkSegmentArgs *) vData;
	IOByteCount offset  = (IOByteCount) data-&gt;fOffset;

	IOPhysicalLength length;
	<span class="enscript-keyword">if</span> (data-&gt;fMapped &amp;&amp; IOMapper::gSystem)
	    data-&gt;fIOVMAddr = md-&gt;getPhysicalSegment(offset, &amp;length);
	<span class="enscript-keyword">else</span>
	    data-&gt;fIOVMAddr = md-&gt;getPhysicalSegment(offset, &amp;length, kIOMemoryMapperNone);
	data-&gt;fLength = length;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMDAddDMAMapSpec == op) <span class="enscript-keyword">return</span> kIOReturnUnsupported;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMDDMAMap == op)
    {
	<span class="enscript-keyword">if</span> (dataSize &lt; <span class="enscript-keyword">sizeof</span>(IOMDDMAMapArgs))
	    <span class="enscript-keyword">return</span> kIOReturnUnderrun;
	IOMDDMAMapArgs * data = (IOMDDMAMapArgs *) vData;

	<span class="enscript-keyword">if</span> (params) panic(<span class="enscript-string">&quot;class %s does not support IODMACommand::kIterateOnly&quot;</span>, getMetaClass()-&gt;getClassName());

	data-&gt;fMapContig = true;
	err = md-&gt;dmaMap(data-&gt;fMapper, data-&gt;fCommand, &amp;data-&gt;fMapSpec, data-&gt;fOffset, data-&gt;fLength, &amp;data-&gt;fAlloc, &amp;data-&gt;fAllocLength);
	<span class="enscript-keyword">return</span> (err);				
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn 
<span class="enscript-function-name">IOGeneralMemoryDescriptor::setPurgeable</span>( IOOptionBits newState,
						   IOOptionBits * oldState )
{
    IOReturn	  err = kIOReturnSuccess;

    vm_purgable_t control;
    <span class="enscript-type">int</span>           state;

    <span class="enscript-keyword">if</span> (_memRef)
    {
	err = super::setPurgeable(newState, oldState);
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	    LOCK;
	<span class="enscript-keyword">do</span>
	{
	    <span class="enscript-comment">// Find the appropriate vm_map for the given task
</span>	    vm_map_t curMap;
	    <span class="enscript-keyword">if</span> (_task == kernel_task &amp;&amp; (kIOMemoryBufferPageable &amp; _flags))
	    {
		err = kIOReturnNotReady;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!_task)
	    {
		err = kIOReturnUnsupported;
		<span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">else</span>
		curMap = get_task_map(_task);

	    <span class="enscript-comment">// can only do one range
</span>	    Ranges vec = _ranges;
	    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
	    mach_vm_address_t addr; 
	    mach_vm_size_t    len;
	    getAddrLenForInd(addr, len, type, vec, 0);

	    err = purgeableControlBits(newState, &amp;control, &amp;state);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err)
		<span class="enscript-keyword">break</span>;
	    err = mach_vm_purgable_control(curMap, addr, control, &amp;state);
	    <span class="enscript-keyword">if</span> (oldState)
	    {
		<span class="enscript-keyword">if</span> (kIOReturnSuccess == err)
		{
		    err = purgeableStateBits(&amp;state);
		    *oldState = state;
		}
	    }
	}
	<span class="enscript-keyword">while</span> (false);
	<span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	    UNLOCK;
    }

    <span class="enscript-keyword">return</span> (err);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::setPurgeable</span>( IOOptionBits newState,
                                           IOOptionBits * oldState )
{
    IOReturn err = kIOReturnNotReady;

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags) LOCK;
    <span class="enscript-keyword">if</span> (_memRef) err = IOGeneralMemoryDescriptor::memoryReferenceSetPurgeable(_memRef, newState, oldState);
    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags) UNLOCK;

    <span class="enscript-keyword">return</span> (err);
}
 
IOReturn <span class="enscript-function-name">IOMemoryDescriptor::getPageCounts</span>( IOByteCount * residentPageCount,
                                     	    IOByteCount * dirtyPageCount )
{
    IOReturn err = kIOReturnNotReady;

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags) LOCK;
    <span class="enscript-keyword">if</span> (_memRef) err = IOGeneralMemoryDescriptor::memoryReferenceGetPageCounts(_memRef, residentPageCount, dirtyPageCount);
    <span class="enscript-keyword">else</span>
    {
	IOMultiMemoryDescriptor * mmd;
	IOSubMemoryDescriptor   * smd;
    	<span class="enscript-keyword">if</span> ((smd = OSDynamicCast(IOSubMemoryDescriptor, <span class="enscript-keyword">this</span>)))
    	{
	    err = smd-&gt;getPageCounts(residentPageCount, dirtyPageCount);
	}
    	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mmd = OSDynamicCast(IOMultiMemoryDescriptor, <span class="enscript-keyword">this</span>)))
    	{
	    err = mmd-&gt;getPageCounts(residentPageCount, dirtyPageCount);
	}
    }
    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags) UNLOCK;

    <span class="enscript-keyword">return</span> (err);
}
 

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">void</span> dcache_incoherent_io_flush64(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count);
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">void</span> dcache_incoherent_io_store64(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">SetEncryptOp</span>(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count)
{
    ppnum_t page, end;

    page = atop_64(round_page_64(pa));
    end  = atop_64(trunc_page_64(pa + count));
    <span class="enscript-keyword">for</span> (; page &lt; end; page++)
    {
        pmap_clear_noencrypt(page);    
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ClearEncryptOp</span>(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count)
{
    ppnum_t page, end;

    page = atop_64(round_page_64(pa));
    end  = atop_64(trunc_page_64(pa + count));
    <span class="enscript-keyword">for</span> (; page &lt; end; page++)
    {
        pmap_set_noencrypt(page);    
    }
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::performOperation</span>( IOOptionBits options,
                                                IOByteCount offset, IOByteCount length )
{
    IOByteCount remaining;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> res;
    <span class="enscript-type">void</span> (*func)(addr64_t pa, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> count) = 0;

    <span class="enscript-keyword">switch</span> (options)
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryIncoherentIOFlush</span>:
            func = &amp;dcache_incoherent_io_flush64;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryIncoherentIOStore</span>:
            func = &amp;dcache_incoherent_io_store64;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemorySetEncrypted</span>:
            func = &amp;SetEncryptOp;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOMemoryClearEncrypted</span>:
            func = &amp;ClearEncryptOp;
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (!func)
        <span class="enscript-keyword">return</span> (kIOReturnUnsupported);

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	LOCK;

    res = 0x0UL;
    remaining = length = min(length, getLength() - offset);
    <span class="enscript-keyword">while</span> (remaining)
    <span class="enscript-comment">// (process another target segment?)
</span>    {
        addr64_t    dstAddr64;
        IOByteCount dstLen;

        dstAddr64 = getPhysicalSegment(offset, &amp;dstLen, kIOMemoryMapperNone);
        <span class="enscript-keyword">if</span> (!dstAddr64)
            <span class="enscript-keyword">break</span>;

        <span class="enscript-comment">// Clip segment length to remaining
</span>        <span class="enscript-keyword">if</span> (dstLen &gt; remaining)
            dstLen = remaining;

	(*func)(dstAddr64, dstLen);

        offset    += dstLen;
        remaining -= dstLen;
    }

    <span class="enscript-keyword">if</span> (kIOMemoryThreadSafe &amp; _flags)
	UNLOCK;

    <span class="enscript-keyword">return</span> (remaining ? kIOReturnUnderrun : kIOReturnSuccess);
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">io_kernel_static_start</span>	vm_kernel_stext
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">io_kernel_static_end</span>	vm_kernel_etext

#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">io_kernel_static_end</span> <span class="enscript-variable-name">is</span> <span class="enscript-variable-name">undefined</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">this</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">io_get_kernel_static_upl</span>(
	vm_map_t		<span class="enscript-comment">/* map */</span>,
	uintptr_t		offset,
	upl_size_t		*upl_size,
	upl_t			*upl,
	upl_page_info_array_t	page_list,
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		*count,
	ppnum_t			*highest_page)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pageCount, page;
    ppnum_t phys;
    ppnum_t highestPage = 0;

    pageCount = atop_32(*upl_size);
    <span class="enscript-keyword">if</span> (pageCount &gt; *count)
	pageCount = *count;

    *upl = NULL;

    <span class="enscript-keyword">for</span> (page = 0; page &lt; pageCount; page++)
    {
	phys = pmap_find_phys(kernel_pmap, ((addr64_t)offset) + ptoa_64(page));
	<span class="enscript-keyword">if</span> (!phys)
	    <span class="enscript-keyword">break</span>;
	page_list[page].phys_addr = phys;
	page_list[page].pageout	  = 0;
	page_list[page].absent	  = 0;
	page_list[page].dirty	  = 0;
	page_list[page].precious  = 0;
	page_list[page].device	  = 0;
	<span class="enscript-keyword">if</span> (phys &gt; highestPage)
	    highestPage = phys;
    }

    *highest_page = highestPage;

    <span class="enscript-keyword">return</span> ((page &gt;= pageCount) ? kIOReturnSuccess : kIOReturnVMError);
}

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::wireVirtual</span>(IODirection forDirection)
{
    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
    IOReturn error = kIOReturnCannotWire;
    ioGMDData *dataP;
    upl_page_info_array_t pageInfo;
    ppnum_t mapBase;

    assert(kIOMemoryTypeVirtual == type || kIOMemoryTypeVirtual64 == type || kIOMemoryTypeUIO == type);

    <span class="enscript-keyword">if</span> ((kIODirectionOutIn &amp; forDirection) == kIODirectionNone)
        forDirection = (IODirection) (forDirection | getDirection());

    upl_control_flags_t uplFlags;    <span class="enscript-comment">// This Mem Desc's default flags for upl creation
</span>    <span class="enscript-keyword">switch</span> (kIODirectionOutIn &amp; forDirection)
    {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIODirectionOut</span>:
        <span class="enscript-comment">// Pages do not need to be marked as dirty on commit
</span>        uplFlags = UPL_COPYOUT_FROM;
        <span class="enscript-keyword">break</span>;

    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIODirectionIn</span>:
    <span class="enscript-reference">default</span>:
        uplFlags = 0;	<span class="enscript-comment">// i.e. ~UPL_COPYOUT_FROM
</span>        <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (_wireCount)
    {
        <span class="enscript-keyword">if</span> ((kIOMemoryPreparedReadOnly &amp; _flags) &amp;&amp; !(UPL_COPYOUT_FROM &amp; uplFlags))
        {
	    OSReportWithBacktrace(<span class="enscript-string">&quot;IOMemoryDescriptor 0x%lx prepared read only&quot;</span>, VM_KERNEL_ADDRPERM(<span class="enscript-keyword">this</span>));
	    error = kIOReturnNotWritable;
        }
        <span class="enscript-keyword">else</span> error = kIOReturnSuccess;
	<span class="enscript-keyword">return</span> (error);
    }

    dataP = getDataP(_memoryEntries);
    IOMapper *mapper;
    mapper = dataP-&gt;fMapper;
    dataP-&gt;fMappedBase = 0;

    uplFlags |= UPL_SET_IO_WIRE | UPL_SET_LITE;
    uplFlags |= UPL_MEMORY_TAG_MAKE(IOMemoryTag(kernel_map));

    <span class="enscript-keyword">if</span> (kIODirectionPrepareToPhys32 &amp; forDirection) 
    {
	<span class="enscript-keyword">if</span> (!mapper) uplFlags |= UPL_NEED_32BIT_ADDR;
	<span class="enscript-keyword">if</span> (dataP-&gt;fDMAMapNumAddressBits &gt; 32) dataP-&gt;fDMAMapNumAddressBits = 32;
    }
    <span class="enscript-keyword">if</span> (kIODirectionPrepareNoFault    &amp; forDirection) uplFlags |= UPL_REQUEST_NO_FAULT;
    <span class="enscript-keyword">if</span> (kIODirectionPrepareNoZeroFill &amp; forDirection) uplFlags |= UPL_NOZEROFILLIO;
    <span class="enscript-keyword">if</span> (kIODirectionPrepareNonCoherent &amp; forDirection) uplFlags |= UPL_REQUEST_FORCE_COHERENCY;

    mapBase = 0;

    <span class="enscript-comment">// Note that appendBytes(NULL) zeros the data up to the desired length
</span>    <span class="enscript-comment">//           and the length parameter is an unsigned int
</span>    size_t uplPageSize = dataP-&gt;fPageCnt * <span class="enscript-keyword">sizeof</span>(upl_page_info_t);
    <span class="enscript-keyword">if</span> (uplPageSize &gt; ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)uplPageSize))    <span class="enscript-keyword">return</span> (kIOReturnNoMemory);
    <span class="enscript-keyword">if</span> (!_memoryEntries-&gt;appendBytes(0, uplPageSize)) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);
    dataP = 0;

    <span class="enscript-comment">// Find the appropriate vm_map for the given task
</span>    vm_map_t curMap;
    <span class="enscript-keyword">if</span> (_task == kernel_task &amp;&amp; (kIOMemoryBufferPageable &amp; _flags))            curMap = 0;
    <span class="enscript-keyword">else</span>                                                     curMap = get_task_map(_task);

    <span class="enscript-comment">// Iterate over the vector of virtual ranges
</span>    Ranges vec = _ranges;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pageIndex  = 0;
    IOByteCount mdOffset    = 0;
    ppnum_t highestPage     = 0;

    IOMemoryEntry * memRefEntry = 0;
    <span class="enscript-keyword">if</span> (_memRef) memRefEntry = &amp;_memRef-&gt;entries[0];

    <span class="enscript-keyword">for</span> (UInt range = 0; range &lt; _rangesCount; range++) {
        ioPLBlock iopl;
	mach_vm_address_t startPage;
        mach_vm_size_t    numBytes;
	ppnum_t highPage = 0;

	<span class="enscript-comment">// Get the startPage address and length of vec[range]
</span>	getAddrLenForInd(startPage, numBytes, type, vec, range);
	iopl.fPageOffset = startPage &amp; PAGE_MASK;
	numBytes += iopl.fPageOffset;
	startPage = trunc_page_64(startPage);

	<span class="enscript-keyword">if</span> (mapper)
	    iopl.fMappedPage = mapBase + pageIndex;
	<span class="enscript-keyword">else</span>
	    iopl.fMappedPage = 0;

	<span class="enscript-comment">// Iterate over the current range, creating UPLs
</span>        <span class="enscript-keyword">while</span> (numBytes) {
	    vm_address_t kernelStart = (vm_address_t) startPage;
            vm_map_t theMap;
	    <span class="enscript-keyword">if</span> (curMap) theMap = curMap;
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_memRef)
	    {
	        theMap = NULL;
	    }
	    <span class="enscript-keyword">else</span>
	    {
		assert(_task == kernel_task);
		theMap = IOPageableMapForAddress(kernelStart);
	    }

	    <span class="enscript-comment">// ioplFlags is an in/out parameter
</span>            upl_control_flags_t ioplFlags = uplFlags;
	    dataP = getDataP(_memoryEntries);
	    pageInfo = getPageList(dataP);
            upl_page_list_ptr_t baseInfo = &amp;pageInfo[pageIndex];

            upl_size_t ioplSize = round_page(numBytes);
            <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numPageInfo = atop_32(ioplSize);

	    <span class="enscript-keyword">if</span> ((theMap == kernel_map) 
	     &amp;&amp; (kernelStart &gt;= io_kernel_static_start) 
	     &amp;&amp; (kernelStart &lt;  io_kernel_static_end)) {
		error = io_get_kernel_static_upl(theMap, 
						kernelStart,
						&amp;ioplSize,
						&amp;iopl.fIOPL,
						baseInfo,
						&amp;numPageInfo,
						&amp;highPage);
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_memRef) {
		memory_object_offset_t entryOffset;

                entryOffset = mdOffset;
                entryOffset = (entryOffset - iopl.fPageOffset - memRefEntry-&gt;offset);
		<span class="enscript-keyword">if</span> (entryOffset &gt;= memRefEntry-&gt;size) {
		    memRefEntry++;
		    <span class="enscript-keyword">if</span> (memRefEntry &gt;= &amp;_memRef-&gt;entries[_memRef-&gt;count]) panic(<span class="enscript-string">&quot;memRefEntry&quot;</span>);
		    entryOffset = 0;
		}
		<span class="enscript-keyword">if</span> (ioplSize &gt; (memRefEntry-&gt;size - entryOffset)) ioplSize = (memRefEntry-&gt;size - entryOffset);
		error = memory_object_iopl_request(memRefEntry-&gt;entry, 
						   entryOffset,
						   &amp;ioplSize,
						   &amp;iopl.fIOPL,
						   baseInfo,
						   &amp;numPageInfo,
						   &amp;ioplFlags);
	    }
	    <span class="enscript-keyword">else</span> {
		assert(theMap);
		error = vm_map_create_upl(theMap,
						startPage,
						(upl_size_t*)&amp;ioplSize,
						&amp;iopl.fIOPL,
						baseInfo,
						&amp;numPageInfo,
						&amp;ioplFlags);
	    }

            assert(ioplSize);
            <span class="enscript-keyword">if</span> (error != KERN_SUCCESS)
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">abortExit</span>;

	    <span class="enscript-keyword">if</span> (iopl.fIOPL)
		highPage = upl_get_highest_page(iopl.fIOPL);
	    <span class="enscript-keyword">if</span> (highPage &gt; highestPage)
		highestPage = highPage;

            error = kIOReturnCannotWire;

            <span class="enscript-keyword">if</span> (baseInfo-&gt;device) {
                numPageInfo = 1;
                iopl.fFlags = kIOPLOnDevice;
            }
            <span class="enscript-keyword">else</span> {
                iopl.fFlags = 0;
            }

            iopl.fIOMDOffset = mdOffset;
            iopl.fPageInfo = pageIndex;
            <span class="enscript-keyword">if</span> (mapper &amp;&amp; pageIndex &amp;&amp; (page_mask &amp; (mdOffset + iopl.fPageOffset))) dataP-&gt;fDiscontig = true;

#<span class="enscript-reference">if</span> 0
	    <span class="enscript-comment">// used to remove the upl for auto prepares here, for some errant code
</span>	    <span class="enscript-comment">// that freed memory before the descriptor pointing at it
</span>	    <span class="enscript-keyword">if</span> ((_flags &amp; kIOMemoryAutoPrepare) &amp;&amp; iopl.fIOPL)
	    {
		upl_commit(iopl.fIOPL, 0, 0);
		upl_deallocate(iopl.fIOPL);
		iopl.fIOPL = 0;
	    }
#<span class="enscript-reference">endif</span>

            <span class="enscript-keyword">if</span> (!_memoryEntries-&gt;appendBytes(&amp;iopl, <span class="enscript-keyword">sizeof</span>(iopl))) {
                <span class="enscript-comment">// Clean up partial created and unsaved iopl
</span>                <span class="enscript-keyword">if</span> (iopl.fIOPL) {
                    upl_abort(iopl.fIOPL, 0);
                    upl_deallocate(iopl.fIOPL);
                }
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">abortExit</span>;
            }
	    dataP = 0;

            <span class="enscript-comment">// Check for a multiple iopl's in one virtual range
</span>            pageIndex += numPageInfo;
            mdOffset -= iopl.fPageOffset;
            <span class="enscript-keyword">if</span> (ioplSize &lt; numBytes) {
                numBytes -= ioplSize;
                startPage += ioplSize;
                mdOffset += ioplSize;
                iopl.fPageOffset = 0;
		<span class="enscript-keyword">if</span> (mapper) iopl.fMappedPage = mapBase + pageIndex;
            }
            <span class="enscript-keyword">else</span> {
                mdOffset += numBytes;
                <span class="enscript-keyword">break</span>;
            }
        }
    }

    _highestPage = highestPage;

    <span class="enscript-keyword">if</span> (UPL_COPYOUT_FROM &amp; uplFlags) _flags |= kIOMemoryPreparedReadOnly;

    <span class="enscript-keyword">if</span> ((kIOTracking &amp; gIOKitDebug) 
     <span class="enscript-comment">//&amp;&amp; !(_flags &amp; kIOMemoryAutoPrepare)
</span>     )
    {
        dataP = getDataP(_memoryEntries);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
        IOTrackingAdd(gIOWireTracking, &amp;dataP-&gt;fWireTracking, ptoa(_pages), false);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-keyword">return</span> kIOReturnSuccess;

<span class="enscript-reference">abortExit</span>:
    {
        dataP = getDataP(_memoryEntries);
        UInt done = getNumIOPL(_memoryEntries, dataP);
        ioPLBlock *ioplList = getIOPLList(dataP);
    
        <span class="enscript-keyword">for</span> (UInt range = 0; range &lt; done; range++)
	{
	    <span class="enscript-keyword">if</span> (ioplList[range].fIOPL) {
             upl_abort(ioplList[range].fIOPL, 0);
             upl_deallocate(ioplList[range].fIOPL);
	    }
	}
	(<span class="enscript-type">void</span>) _memoryEntries-&gt;initWithBytes(dataP, computeDataSize(0, 0)); <span class="enscript-comment">// == setLength()
</span>    }

    <span class="enscript-keyword">if</span> (error == KERN_FAILURE)
        error = kIOReturnCannotWire;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == KERN_MEMORY_ERROR)
        error = kIOReturnNoResources;

    <span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::initMemoryEntries</span>(size_t size, IOMapper * mapper)
{
    ioGMDData * dataP;
    <span class="enscript-type">unsigned</span>    dataSize = size;

    <span class="enscript-keyword">if</span> (!_memoryEntries) {
	_memoryEntries = OSData::withCapacity(dataSize);
	<span class="enscript-keyword">if</span> (!_memoryEntries)
	    <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!_memoryEntries-&gt;initWithCapacity(dataSize))
	<span class="enscript-keyword">return</span> false;

    _memoryEntries-&gt;appendBytes(0, computeDataSize(0, 0));
    dataP = getDataP(_memoryEntries);

    <span class="enscript-keyword">if</span> (mapper == kIOMapperWaitSystem) {
        <span class="enscript-reference">IOMapper</span>::checkForSystemMapper();
        mapper = IOMapper::gSystem;
    }
    dataP-&gt;fMapper               = mapper;
    dataP-&gt;fPageCnt              = 0;
    dataP-&gt;fMappedBase           = 0;
    dataP-&gt;fDMAMapNumAddressBits = 64;
    dataP-&gt;fDMAMapAlignment      = 0;
    dataP-&gt;fPreparationID        = kIOPreparationIDUnprepared;
    dataP-&gt;fDiscontig            = false;
    dataP-&gt;fCompletionError      = false;

    <span class="enscript-keyword">return</span> (true);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::dmaMap</span>(
    IOMapper                    * mapper,
    IODMACommand                * command,
    <span class="enscript-type">const</span> IODMAMapSpecification * mapSpec,
    uint64_t                      offset,
    uint64_t                      length,
    uint64_t                    * mapAddress,
    uint64_t                    * mapLength)
{
    IOReturn ret;
    uint32_t mapOptions;

    mapOptions = 0;
    mapOptions |= kIODMAMapReadAccess;
    <span class="enscript-keyword">if</span> (!(kIOMemoryPreparedReadOnly &amp; _flags)) mapOptions |= kIODMAMapWriteAccess;

    ret = mapper-&gt;iovmMapMemory(<span class="enscript-keyword">this</span>, offset, length, mapOptions, 
				mapSpec, command, NULL, mapAddress, mapLength);

    <span class="enscript-keyword">return</span> (ret);
}

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::dmaMap</span>(
    IOMapper                    * mapper,
    IODMACommand                * command,
    <span class="enscript-type">const</span> IODMAMapSpecification * mapSpec,
    uint64_t                      offset,
    uint64_t                      length,
    uint64_t                    * mapAddress,
    uint64_t                    * mapLength)
{
    IOReturn          err = kIOReturnSuccess;
    ioGMDData *       dataP;
    IOOptionBits      type = _flags &amp; kIOMemoryTypeMask;

    *mapAddress = 0;
    <span class="enscript-keyword">if</span> (kIOMemoryHostOnly &amp; _flags) <span class="enscript-keyword">return</span> (kIOReturnSuccess);

    <span class="enscript-keyword">if</span> ((type == kIOMemoryTypePhysical) || (type == kIOMemoryTypePhysical64)
     || offset || (length != _length))
    {
	err = super::dmaMap(mapper, command, mapSpec, offset, length, mapAddress, mapLength);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_memoryEntries &amp;&amp; _pages &amp;&amp; (dataP = getDataP(_memoryEntries)))
    {
	<span class="enscript-type">const</span> ioPLBlock * ioplList = getIOPLList(dataP);
	upl_page_info_t * pageList;
	uint32_t          mapOptions = 0;

	IODMAMapSpecification mapSpec;
	bzero(&amp;mapSpec, <span class="enscript-keyword">sizeof</span>(mapSpec));
	mapSpec.numAddressBits = dataP-&gt;fDMAMapNumAddressBits;
	mapSpec.alignment = dataP-&gt;fDMAMapAlignment;

	<span class="enscript-comment">// For external UPLs the fPageInfo field points directly to
</span>	<span class="enscript-comment">// the upl's upl_page_info_t array.
</span>	<span class="enscript-keyword">if</span> (ioplList-&gt;fFlags &amp; kIOPLExternUPL)
	{
	    pageList = (upl_page_info_t *) ioplList-&gt;fPageInfo;
	    mapOptions |= kIODMAMapPagingPath;
	}
	<span class="enscript-keyword">else</span> pageList = getPageList(dataP);

	<span class="enscript-keyword">if</span> ((_length == ptoa_64(_pages)) &amp;&amp; !(page_mask &amp; ioplList-&gt;fPageOffset))
	{
	    mapOptions |= kIODMAMapPageListFullyOccupied;
	}

	mapOptions |= kIODMAMapReadAccess;
	<span class="enscript-keyword">if</span> (!(kIOMemoryPreparedReadOnly &amp; _flags)) mapOptions |= kIODMAMapWriteAccess;

	<span class="enscript-comment">// Check for direct device non-paged memory
</span>	<span class="enscript-keyword">if</span> (ioplList-&gt;fFlags &amp; kIOPLOnDevice) mapOptions |= kIODMAMapPhysicallyContiguous;

	IODMAMapPageList dmaPageList =
	{
		.pageOffset    = ioplList-&gt;fPageOffset &amp; page_mask,
		.pageListCount = _pages,
		.pageList      = &amp;pageList[0]
	};
	err = mapper-&gt;iovmMapMemory(<span class="enscript-keyword">this</span>, offset, length, mapOptions, &amp;mapSpec, 
				    command, &amp;dmaPageList, mapAddress, mapLength);
    }

    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * prepare
 *
 * Prepare the memory for an I/O transfer.  This involves paging in
 * the memory, if necessary, and wiring it down for the duration of
 * the transfer.  The complete() method completes the processing of
 * the memory after the I/O transfer finishes.  This method needn't
 * called for non-pageable memory.
 */</span>

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::prepare</span>(IODirection forDirection)
{
    IOReturn error    = kIOReturnSuccess;
    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;

    <span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type))
	<span class="enscript-keyword">return</span> kIOReturnSuccess;

    <span class="enscript-keyword">if</span> (_prepareLock)
	IOLockLock(_prepareLock);

    <span class="enscript-keyword">if</span> (kIOMemoryTypeVirtual == type || kIOMemoryTypeVirtual64 == type || kIOMemoryTypeUIO == type)
    {
	error = wireVirtual(forDirection);
    }

    <span class="enscript-keyword">if</span> (kIOReturnSuccess == error)
    {
	<span class="enscript-keyword">if</span> (1 == ++_wireCount)
	{
	    <span class="enscript-keyword">if</span> (kIOMemoryClearEncrypt &amp; _flags)
	    {
		performOperation(kIOMemoryClearEncrypted, 0, _length);
	    }
	}
    }

    <span class="enscript-keyword">if</span> (_prepareLock)
	IOLockUnlock(_prepareLock);

    <span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * complete
 *
 * Complete processing of the memory after an I/O transfer finishes.
 * This method should not be called unless a prepare was previously
 * issued; the prepare() and complete() must occur in pairs, before
 * before and after an I/O transfer involving pageable memory.
 */</span>

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::complete</span>(IODirection forDirection)
{
    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
    ioGMDData * dataP;

    <span class="enscript-keyword">if</span> ((kIOMemoryTypePhysical == type) || (kIOMemoryTypePhysical64 == type))
	<span class="enscript-keyword">return</span> kIOReturnSuccess;

    <span class="enscript-keyword">if</span> (_prepareLock)
	IOLockLock(_prepareLock);

    assert(_wireCount);

    <span class="enscript-keyword">if</span> ((kIODirectionCompleteWithError &amp; forDirection) 
     &amp;&amp; (dataP = getDataP(_memoryEntries)))
        dataP-&gt;fCompletionError = true;

    <span class="enscript-keyword">if</span> (_wireCount)
    {
        <span class="enscript-keyword">if</span> ((kIOMemoryClearEncrypt &amp; _flags) &amp;&amp; (1 == _wireCount))
        {
            performOperation(kIOMemorySetEncrypted, 0, _length);
        }

	_wireCount--;
	<span class="enscript-keyword">if</span> (!_wireCount || (kIODirectionCompleteWithDataValid &amp; forDirection))
	{
	    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
	    dataP = getDataP(_memoryEntries);
	    ioPLBlock *ioplList = getIOPLList(dataP);
	    UInt ind, count = getNumIOPL(_memoryEntries, dataP);

	    <span class="enscript-keyword">if</span> (_wireCount)
	    {
		<span class="enscript-comment">// kIODirectionCompleteWithDataValid &amp; forDirection
</span>		<span class="enscript-keyword">if</span> (kIOMemoryTypeVirtual == type || kIOMemoryTypeVirtual64 == type || kIOMemoryTypeUIO == type)
		{
		    <span class="enscript-keyword">for</span> (ind = 0; ind &lt; count; ind++)
		    {
			<span class="enscript-keyword">if</span> (ioplList[ind].fIOPL) iopl_valid_data(ioplList[ind].fIOPL);
		    }
		}
	    }
	    <span class="enscript-keyword">else</span>
	    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOMD_DEBUG_DMAACTIVE</span>
		<span class="enscript-keyword">if</span> (__iomd_reservedA) panic(<span class="enscript-string">&quot;complete() while dma active&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOMD_DEBUG_DMAACTIVE */</span>

		<span class="enscript-keyword">if</span> (dataP-&gt;fMappedBase) {
		    dataP-&gt;fMapper-&gt;iovmUnmapMemory(<span class="enscript-keyword">this</span>, NULL, dataP-&gt;fMappedBase, dataP-&gt;fMappedLength);
		    dataP-&gt;fMappedBase = 0;
		}
		<span class="enscript-comment">// Only complete iopls that we created which are for TypeVirtual
</span>		<span class="enscript-keyword">if</span> (kIOMemoryTypeVirtual == type || kIOMemoryTypeVirtual64 == type || kIOMemoryTypeUIO == type) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
		    <span class="enscript-keyword">if</span> ((kIOTracking &amp; gIOKitDebug) 
		     <span class="enscript-comment">//&amp;&amp; !(_flags &amp; kIOMemoryAutoPrepare)
</span>		     )
		    {
			IOTrackingRemove(gIOWireTracking, &amp;dataP-&gt;fWireTracking, ptoa(_pages));
		    }
#<span class="enscript-reference">endif</span>
		    <span class="enscript-keyword">for</span> (ind = 0; ind &lt; count; ind++)
			<span class="enscript-keyword">if</span> (ioplList[ind].fIOPL) {
			    <span class="enscript-keyword">if</span> (dataP-&gt;fCompletionError) 
				upl_abort(ioplList[ind].fIOPL, 0 <span class="enscript-comment">/*!UPL_ABORT_DUMP_PAGES*/</span>);
			    <span class="enscript-keyword">else</span>
				upl_commit(ioplList[ind].fIOPL, 0, 0);
			    upl_deallocate(ioplList[ind].fIOPL);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMemoryTypeUPL == type) {
		    upl_set_referenced(ioplList[0].fIOPL, false);
		}

		(<span class="enscript-type">void</span>) _memoryEntries-&gt;initWithBytes(dataP, computeDataSize(0, 0)); <span class="enscript-comment">// == setLength()
</span>
		dataP-&gt;fPreparationID = kIOPreparationIDUnprepared;
	    }
	}
    }

    <span class="enscript-keyword">if</span> (_prepareLock)
	IOLockUnlock(_prepareLock);

    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::doMap</span>(
	vm_map_t		__addressMap,
	IOVirtualAddress *	__address,
	IOOptionBits		options,
	IOByteCount		__offset,
	IOByteCount		__length )
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (!(kIOMap64Bit &amp; options)) panic(<span class="enscript-string">&quot;IOGeneralMemoryDescriptor::doMap !64bit&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    kern_return_t  err;

    IOMemoryMap *  mapping = (IOMemoryMap *) *__address;
    mach_vm_size_t offset  = mapping-&gt;fOffset + __offset;
    mach_vm_size_t length  = mapping-&gt;fLength;

    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;
    Ranges vec = _ranges;

    mach_vm_address_t range0Addr = 0;
    mach_vm_size_t    range0Len = 0;

    <span class="enscript-keyword">if</span> ((offset &gt;= _length) || ((offset + length) &gt; _length))
	<span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    <span class="enscript-keyword">if</span> (vec.v)
	getAddrLenForInd(range0Addr, range0Len, type, vec, 0);

    <span class="enscript-comment">// mapping source == dest? (could be much better)
</span>    <span class="enscript-keyword">if</span> (_task
     &amp;&amp; (mapping-&gt;fAddressTask == _task)
     &amp;&amp; (mapping-&gt;fAddressMap == get_task_map(_task)) 
     &amp;&amp; (options &amp; kIOMapAnywhere)
     &amp;&amp; (1 == _rangesCount) 
     &amp;&amp; (0 == offset)
     &amp;&amp; range0Addr 
     &amp;&amp; (length &lt;= range0Len))
    {
	mapping-&gt;fAddress = range0Addr;
	mapping-&gt;fOptions |= kIOMapStatic;

	<span class="enscript-keyword">return</span>( kIOReturnSuccess );
    }

    <span class="enscript-keyword">if</span> (!_memRef)
    {
        IOOptionBits createOptions = 0;
	<span class="enscript-keyword">if</span> (!(kIOMapReadOnly &amp; options)) 
	{
	    createOptions |= kIOMemoryReferenceWrite;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
            <span class="enscript-keyword">if</span> (kIODirectionOut == (kIODirectionOutIn &amp; _flags))
            {
                OSReportWithBacktrace(<span class="enscript-string">&quot;warning: creating writable mapping from IOMemoryDescriptor(kIODirectionOut) - use kIOMapReadOnly or change direction&quot;</span>);
	    }
#<span class="enscript-reference">endif</span>
	}
	err = memoryReferenceCreate(createOptions, &amp;_memRef);
	<span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">return</span> (err);
    }

    memory_object_t pager;
    pager = (memory_object_t) (reserved ? reserved-&gt;dp.devicePager : 0);

    <span class="enscript-comment">// &lt;upl_transpose //
</span>    <span class="enscript-keyword">if</span> ((kIOMapReference|kIOMapUnique) == ((kIOMapReference|kIOMapUnique) &amp; options))
    {
        <span class="enscript-keyword">do</span>
	{
	    upl_t	        redirUPL2;
	    upl_size_t          size;
	    upl_control_flags_t flags;
	    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>        lock_count;

	    <span class="enscript-keyword">if</span> (!_memRef || (1 != _memRef-&gt;count))
	    {
		err = kIOReturnNotReadable;
		<span class="enscript-keyword">break</span>;
	    }

	    size = round_page(mapping-&gt;fLength);
	    flags = UPL_COPYOUT_FROM | UPL_SET_INTERNAL 
			| UPL_SET_LITE | UPL_SET_IO_WIRE | UPL_BLOCK_ACCESS
			| UPL_MEMORY_TAG_MAKE(IOMemoryTag(kernel_map));

	    <span class="enscript-keyword">if</span> (KERN_SUCCESS != memory_object_iopl_request(_memRef-&gt;entries[0].entry, 0, &amp;size, &amp;redirUPL2,
					    NULL, NULL,
					    &amp;flags))
		redirUPL2 = NULL;

	    <span class="enscript-keyword">for</span> (lock_count = 0;
		 IORecursiveLockHaveLock(gIOMemoryLock);
		 lock_count++) {
	      UNLOCK;
	    }
	    err = upl_transpose(redirUPL2, mapping-&gt;fRedirUPL);
	    <span class="enscript-keyword">for</span> (;
		 lock_count;
		 lock_count--) {
	      LOCK;
	    }

	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != err)
	    {
		IOLog(<span class="enscript-string">&quot;upl_transpose(%x)\n&quot;</span>, err);
		err = kIOReturnSuccess;
	    }

	    <span class="enscript-keyword">if</span> (redirUPL2)
	    {
		upl_commit(redirUPL2, NULL, 0);
		upl_deallocate(redirUPL2);
		redirUPL2 = 0;
	    }
	    {
		<span class="enscript-comment">// swap the memEntries since they now refer to different vm_objects
</span>		IOMemoryReference * me = _memRef;
		_memRef = mapping-&gt;fMemory-&gt;_memRef;
		mapping-&gt;fMemory-&gt;_memRef = me;
	    }
	    <span class="enscript-keyword">if</span> (pager)
		err = populateDevicePager( pager, mapping-&gt;fAddressMap, mapping-&gt;fAddress, offset, length, options );
	}
	<span class="enscript-keyword">while</span> (false);
    }
    <span class="enscript-comment">// upl_transpose&gt; //
</span>    <span class="enscript-keyword">else</span>
    {
	err = memoryReferenceMap(_memRef, mapping-&gt;fAddressMap, offset, length, options, &amp;mapping-&gt;fAddress);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
        <span class="enscript-keyword">if</span> (err == KERN_SUCCESS) IOTrackingAdd(gIOMapTracking, &amp;mapping-&gt;fTracking, length, false);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((err == KERN_SUCCESS) &amp;&amp; pager)
	{
	    err = populateDevicePager(pager, mapping-&gt;fAddressMap, mapping-&gt;fAddress, offset, length, options);

	    <span class="enscript-keyword">if</span> (err != KERN_SUCCESS) doUnmap(mapping-&gt;fAddressMap, (IOVirtualAddress) mapping, 0);
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMapDefaultCache == (options &amp; kIOMapCacheMask))
	    {
		mapping-&gt;fOptions |= ((_flags &amp; kIOMemoryBufferCacheMask) &gt;&gt; kIOMemoryBufferCacheShift);
	    }
	}
    }

    <span class="enscript-keyword">return</span> (err);
}

IOReturn <span class="enscript-function-name">IOGeneralMemoryDescriptor::doUnmap</span>(
	vm_map_t		addressMap,
	IOVirtualAddress	__address,
	IOByteCount		__length )
{
    <span class="enscript-keyword">return</span> (super::doUnmap(addressMap, __address, __length));
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IOMemoryMap, OSObject )

<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryMap, 7);

<span class="enscript-comment">/* ex-inline function implementation */</span>
IOPhysicalAddress <span class="enscript-function-name">IOMemoryMap::getPhysicalAddress</span>()
    { <span class="enscript-keyword">return</span>( getPhysicalSegment( 0, 0 )); }

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOMemoryMap::init</span>(
        task_t			intoTask,
        mach_vm_address_t	toAddress,
        IOOptionBits		_options,
        mach_vm_size_t		_offset,
        mach_vm_size_t		_length )
{
    <span class="enscript-keyword">if</span> (!intoTask)
	<span class="enscript-keyword">return</span>( false);

    <span class="enscript-keyword">if</span> (!super::init())
	<span class="enscript-keyword">return</span>(false);

    fAddressMap  = get_task_map(intoTask);
    <span class="enscript-keyword">if</span> (!fAddressMap)
	<span class="enscript-keyword">return</span>(false);
    vm_map_reference(fAddressMap);

    fAddressTask = intoTask;
    fOptions     = _options;
    fLength      = _length;
    fOffset	 = _offset;
    fAddress     = toAddress;

    <span class="enscript-keyword">return</span> (true);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOMemoryMap::setMemoryDescriptor</span>(IOMemoryDescriptor * _memory, mach_vm_size_t _offset)
{
    <span class="enscript-keyword">if</span> (!_memory)
	<span class="enscript-keyword">return</span>(false);

    <span class="enscript-keyword">if</span> (!fSuperMap)
    {
	<span class="enscript-keyword">if</span>( (_offset + fLength) &gt; _memory-&gt;getLength())
	    <span class="enscript-keyword">return</span>( false);
	fOffset = _offset;
    }

    _memory-&gt;retain();
    <span class="enscript-keyword">if</span> (fMemory)
    {
	<span class="enscript-keyword">if</span> (fMemory != _memory)
	    fMemory-&gt;removeMapping(<span class="enscript-keyword">this</span>);
	fMemory-&gt;release();
    }
    fMemory = _memory;

    <span class="enscript-keyword">return</span>( true );
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::doMap</span>(
	vm_map_t		__addressMap,
	IOVirtualAddress *	__address,
	IOOptionBits		options,
	IOByteCount		__offset,
	IOByteCount		__length )
{
    <span class="enscript-keyword">return</span> (kIOReturnUnsupported);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::handleFault</span>(
        <span class="enscript-type">void</span> *			_pager,
	mach_vm_size_t		sourceOffset,
	mach_vm_size_t		length)
{
    <span class="enscript-keyword">if</span>( kIOMemoryRedirected &amp; _flags)
    {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	IOLog(<span class="enscript-string">&quot;sleep mem redirect %p, %qx\n&quot;</span>, <span class="enscript-keyword">this</span>, sourceOffset);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">do</span> {
	    SLEEP;
	} <span class="enscript-keyword">while</span>( kIOMemoryRedirected &amp; _flags );
    }
    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::populateDevicePager</span>(
        <span class="enscript-type">void</span> *			_pager,
	vm_map_t		addressMap,
	mach_vm_address_t	address,
	mach_vm_size_t		sourceOffset,
	mach_vm_size_t		length,
        IOOptionBits		options )
{
    IOReturn		err = kIOReturnSuccess;
    memory_object_t	pager = (memory_object_t) _pager;
    mach_vm_size_t	size;
    mach_vm_size_t	bytes;
    mach_vm_size_t	page;
    mach_vm_size_t	pageOffset;
    mach_vm_size_t	pagerOffset;
    IOPhysicalLength	segLen, chunk;
    addr64_t		physAddr;
    IOOptionBits        type;

    type = _flags &amp; kIOMemoryTypeMask;

    <span class="enscript-keyword">if</span> (reserved-&gt;dp.pagerContig)
    {
        sourceOffset = 0;
        pagerOffset  = 0;
    }

    physAddr = getPhysicalSegment( sourceOffset, &amp;segLen, kIOMemoryMapperNone );
    assert( physAddr );
    pageOffset = physAddr - trunc_page_64( physAddr );
    pagerOffset = sourceOffset;

    size = length + pageOffset;
    physAddr -= pageOffset;

    segLen += pageOffset;
    bytes = size;
    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-comment">// in the middle of the loop only map whole pages
</span>	<span class="enscript-keyword">if</span>( segLen &gt;= bytes) segLen = bytes;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (segLen != trunc_page(segLen))    err = kIOReturnVMError;
        <span class="enscript-keyword">if</span> (physAddr != trunc_page_64(physAddr))  err = kIOReturnBadArgument;

	<span class="enscript-keyword">if</span> (kIOReturnSuccess != err) <span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
        <span class="enscript-keyword">if</span> ((kIOMemoryTypeUPL != type) 
            &amp;&amp; pmap_has_managed_page(atop_64(physAddr), atop_64(physAddr + segLen - 1))) 
	{
            OSReportWithBacktrace(<span class="enscript-string">&quot;IOMemoryDescriptor physical with managed page 0x%qx:0x%qx&quot;</span>, physAddr, segLen);
        }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG || DEVELOPMENT */</span>

        chunk = (reserved-&gt;dp.pagerContig ? round_page(segLen) : page_size);
        <span class="enscript-keyword">for</span> (page = 0;
    	     (page &lt; segLen) &amp;&amp; (KERN_SUCCESS == err);
            page += chunk)
        {
            err = device_pager_populate_object(pager, pagerOffset,
                (ppnum_t)(atop_64(physAddr + page)), chunk);
            pagerOffset += chunk;
        }

	assert (KERN_SUCCESS == err);
	<span class="enscript-keyword">if</span> (err) <span class="enscript-keyword">break</span>;

	<span class="enscript-comment">// This call to vm_fault causes an early pmap level resolution
</span>	<span class="enscript-comment">// of the mappings created above for kernel mappings, since
</span>	<span class="enscript-comment">// faulting in later can't take place from interrupt level.
</span>	<span class="enscript-keyword">if</span> ((addressMap == kernel_map) &amp;&amp; !(kIOMemoryRedirected &amp; _flags))
	{
	    vm_fault(addressMap, 
		     (vm_map_offset_t)trunc_page_64(address),
		     VM_PROT_READ|VM_PROT_WRITE, 
		     FALSE, THREAD_UNINT, NULL, 
		     (vm_map_offset_t)0);
	}

	sourceOffset += segLen - pageOffset;
	address += segLen;
	bytes -= segLen;
	pageOffset = 0;
    } 
    <span class="enscript-keyword">while</span> (bytes &amp;&amp; (physAddr = getPhysicalSegment( sourceOffset, &amp;segLen, kIOMemoryMapperNone )));

    <span class="enscript-keyword">if</span> (bytes)
        err = kIOReturnBadArgument;

    <span class="enscript-keyword">return</span> (err);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::doUnmap</span>(
	vm_map_t		addressMap,
	IOVirtualAddress	__address,
	IOByteCount		__length )
{
    IOReturn	      err;
    IOMemoryMap *     mapping;
    mach_vm_address_t address;
    mach_vm_size_t    length;

    <span class="enscript-keyword">if</span> (__length) panic(<span class="enscript-string">&quot;doUnmap&quot;</span>);

    mapping = (IOMemoryMap *) __address;
    addressMap = mapping-&gt;fAddressMap;
    address    = mapping-&gt;fAddress;
    length     = mapping-&gt;fLength;

    <span class="enscript-keyword">if</span> (kIOMapOverwrite &amp; mapping-&gt;fOptions) err = KERN_SUCCESS;
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span> ((addressMap == kernel_map) &amp;&amp; (kIOMemoryBufferPageable &amp; _flags))
            addressMap = IOPageableMapForAddress( address );
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
        <span class="enscript-keyword">if</span>( kIOLogMapping &amp; gIOKitDebug) IOLog(<span class="enscript-string">&quot;IOMemoryDescriptor::doUnmap map %p, 0x%qx:0x%qx\n&quot;</span>,
        	                                addressMap, address, length );
#<span class="enscript-reference">endif</span>
        err = mach_vm_deallocate( addressMap, address, length );
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    IOTrackingRemove(gIOMapTracking, &amp;mapping-&gt;fTracking, length);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> (err);
}

IOReturn <span class="enscript-function-name">IOMemoryDescriptor::redirect</span>( task_t safeTask, <span class="enscript-type">bool</span> doRedirect )
{
    IOReturn		err = kIOReturnSuccess;
    IOMemoryMap *	mapping = 0;
    OSIterator *	iter;

    LOCK;

    <span class="enscript-keyword">if</span>( doRedirect)
        _flags |= kIOMemoryRedirected;
    <span class="enscript-keyword">else</span>
        _flags &amp;= ~kIOMemoryRedirected;

    <span class="enscript-keyword">do</span> {
	<span class="enscript-keyword">if</span>( (iter = OSCollectionIterator::withCollection( _mappings))) {

	    memory_object_t   pager;

	    <span class="enscript-keyword">if</span>( reserved)
		pager = (memory_object_t) reserved-&gt;dp.devicePager;
	    <span class="enscript-keyword">else</span>
		pager = MACH_PORT_NULL;

	    <span class="enscript-keyword">while</span>( (mapping = (IOMemoryMap *) iter-&gt;getNextObject()))
	    {
		mapping-&gt;redirect( safeTask, doRedirect );
		<span class="enscript-keyword">if</span> (!doRedirect &amp;&amp; !safeTask &amp;&amp; pager &amp;&amp; (kernel_map == mapping-&gt;fAddressMap))
		{
		    err = populateDevicePager(pager, mapping-&gt;fAddressMap, mapping-&gt;fAddress, mapping-&gt;fOffset, mapping-&gt;fLength, kIOMapDefaultCache );
		}
	    }

	    iter-&gt;release();
	}
    } <span class="enscript-keyword">while</span>( false );

    <span class="enscript-keyword">if</span> (!doRedirect)
    {
        WAKEUP;
    }

    UNLOCK;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-comment">// temporary binary compatibility
</span>    IOSubMemoryDescriptor * subMem;
    <span class="enscript-keyword">if</span>( (subMem = OSDynamicCast( IOSubMemoryDescriptor, <span class="enscript-keyword">this</span>)))
	err = subMem-&gt;redirect( safeTask, doRedirect );
    <span class="enscript-keyword">else</span>
	err = kIOReturnSuccess;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-keyword">return</span>( err );
}

IOReturn <span class="enscript-function-name">IOMemoryMap::redirect</span>( task_t safeTask, <span class="enscript-type">bool</span> doRedirect )
{
    IOReturn err = kIOReturnSuccess;

    <span class="enscript-keyword">if</span>( fSuperMap) {
<span class="enscript-comment">//        err = ((IOMemoryMap *)superMap)-&gt;redirect( safeTask, doRedirect );
</span>    } <span class="enscript-keyword">else</span> {

        LOCK;

	<span class="enscript-keyword">do</span>
	{
	    <span class="enscript-keyword">if</span> (!fAddress)
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">if</span> (!fAddressMap)
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">if</span> ((!safeTask || (get_task_map(safeTask) != fAddressMap))
	      &amp;&amp; (0 == (fOptions &amp; kIOMapStatic)))
	    {
		IOUnmapPages( fAddressMap, fAddress, fLength );
		err = kIOReturnSuccess;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		IOLog(<span class="enscript-string">&quot;IOMemoryMap::redirect(%d, %p) 0x%qx:0x%qx from %p\n&quot;</span>, doRedirect, <span class="enscript-keyword">this</span>, fAddress, fLength, fAddressMap);
#<span class="enscript-reference">endif</span>
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kIOMapWriteCombineCache == (fOptions &amp; kIOMapCacheMask))
	    {
		IOOptionBits newMode;
		newMode = (fOptions &amp; ~kIOMapCacheMask) | (doRedirect ? kIOMapInhibitCache : kIOMapWriteCombineCache);
		IOProtectCacheMode(fAddressMap, fAddress, fLength, newMode);
	    }
	}
	<span class="enscript-keyword">while</span> (false);
	UNLOCK;
    }

    <span class="enscript-keyword">if</span> ((((fMemory-&gt;_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical)
	 || ((fMemory-&gt;_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical64))
     &amp;&amp; safeTask
     &amp;&amp; (doRedirect != (0 != (fMemory-&gt;_flags &amp; kIOMemoryRedirected))))
	fMemory-&gt;redirect(safeTask, doRedirect);

    <span class="enscript-keyword">return</span>( err );
}

IOReturn <span class="enscript-function-name">IOMemoryMap::unmap</span>( <span class="enscript-type">void</span> )
{
    IOReturn	err;

    LOCK;

    <span class="enscript-keyword">if</span>( fAddress &amp;&amp; fAddressMap &amp;&amp; (0 == fSuperMap) &amp;&amp; fMemory
        &amp;&amp; (0 == (kIOMapStatic &amp; fOptions))) {

        err = fMemory-&gt;doUnmap(fAddressMap, (IOVirtualAddress) <span class="enscript-keyword">this</span>, 0);

    } <span class="enscript-keyword">else</span>
	err = kIOReturnSuccess;

    <span class="enscript-keyword">if</span> (fAddressMap)
    {
        vm_map_deallocate(fAddressMap);
        fAddressMap = 0;
    }

    fAddress = 0;

    UNLOCK;

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryMap::taskDied</span>( <span class="enscript-type">void</span> )
{
    LOCK;
    <span class="enscript-keyword">if</span> (fUserClientUnmap) unmap();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>
    <span class="enscript-keyword">else</span>                  IOTrackingRemove(gIOMapTracking, &amp;fTracking, fLength);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span>( fAddressMap) {
        vm_map_deallocate(fAddressMap);
        fAddressMap = 0;
    }
    fAddressTask = 0;
    fAddress	 = 0;
    UNLOCK;
}

IOReturn <span class="enscript-function-name">IOMemoryMap::userClientUnmap</span>( <span class="enscript-type">void</span> )
{
    fUserClientUnmap = true;
    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

<span class="enscript-comment">// Overload the release mechanism.  All mappings must be a member
</span><span class="enscript-comment">// of a memory descriptors _mappings set.  This means that we
</span><span class="enscript-comment">// always have 2 references on a mapping.  When either of these mappings
</span><span class="enscript-comment">// are released we need to free ourselves.
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryMap::taggedRelease</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *tag) <span class="enscript-type">const</span>
{
    LOCK;
    <span class="enscript-reference">super</span>::taggedRelease(tag, 2);
    UNLOCK;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryMap::free</span>()
{
    unmap();

    <span class="enscript-keyword">if</span> (fMemory)
    {
        LOCK;
	fMemory-&gt;removeMapping(<span class="enscript-keyword">this</span>);
	UNLOCK;
	fMemory-&gt;release();
    }

    <span class="enscript-keyword">if</span> (fOwner &amp;&amp; (fOwner != fMemory))
    {
        LOCK;
	fOwner-&gt;removeMapping(<span class="enscript-keyword">this</span>);
	UNLOCK;
    }

    <span class="enscript-keyword">if</span> (fSuperMap)
	fSuperMap-&gt;release();

    <span class="enscript-keyword">if</span> (fRedirUPL) {
	upl_commit(fRedirUPL, NULL, 0);
	upl_deallocate(fRedirUPL);
    }

    <span class="enscript-reference">super</span>::free();
}

IOByteCount <span class="enscript-function-name">IOMemoryMap::getLength</span>()
{
    <span class="enscript-keyword">return</span>( fLength );
}

IOVirtualAddress <span class="enscript-function-name">IOMemoryMap::getVirtualAddress</span>()
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (fSuperMap)
	fSuperMap-&gt;getVirtualAddress();
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fAddressMap 
		&amp;&amp; vm_map_is_64bit(fAddressMap)
		&amp;&amp; (<span class="enscript-keyword">sizeof</span>(IOVirtualAddress) &lt; 8))
    {
	OSReportWithBacktrace(<span class="enscript-string">&quot;IOMemoryMap::getVirtualAddress(0x%qx) called on 64b map; use ::getAddress()&quot;</span>, fAddress);
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    <span class="enscript-keyword">return</span> (fAddress);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
mach_vm_address_t 	IOMemoryMap::getAddress()
{
    <span class="enscript-keyword">return</span>( fAddress);
}

mach_vm_size_t 	IOMemoryMap::getSize()
{
    <span class="enscript-keyword">return</span>( fLength );
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>


task_t <span class="enscript-function-name">IOMemoryMap::getAddressTask</span>()
{
    <span class="enscript-keyword">if</span>( fSuperMap)
	<span class="enscript-keyword">return</span>( fSuperMap-&gt;getAddressTask());
    <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( fAddressTask);
}

IOOptionBits <span class="enscript-function-name">IOMemoryMap::getMapOptions</span>()
{
    <span class="enscript-keyword">return</span>( fOptions);
}

IOMemoryDescriptor * <span class="enscript-function-name">IOMemoryMap::getMemoryDescriptor</span>()
{
    <span class="enscript-keyword">return</span>( fMemory );
}

IOMemoryMap * <span class="enscript-function-name">IOMemoryMap::copyCompatible</span>(
		IOMemoryMap * newMapping )
{
    task_t		task      = newMapping-&gt;getAddressTask();
    mach_vm_address_t	toAddress = newMapping-&gt;fAddress;
    IOOptionBits	_options  = newMapping-&gt;fOptions;
    mach_vm_size_t	_offset   = newMapping-&gt;fOffset;
    mach_vm_size_t	_length   = newMapping-&gt;fLength;

    <span class="enscript-keyword">if</span>( (!task) || (!fAddressMap) || (fAddressMap != get_task_map(task)))
	<span class="enscript-keyword">return</span>( 0 );
    <span class="enscript-keyword">if</span>( (fOptions ^ _options) &amp; kIOMapReadOnly)
	<span class="enscript-keyword">return</span>( 0 );
    <span class="enscript-keyword">if</span>( (kIOMapDefaultCache != (_options &amp; kIOMapCacheMask)) 
     &amp;&amp; ((fOptions ^ _options) &amp; kIOMapCacheMask))
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( (0 == (_options &amp; kIOMapAnywhere)) &amp;&amp; (fAddress != toAddress))
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( _offset &lt; fOffset)
	<span class="enscript-keyword">return</span>( 0 );

    _offset -= fOffset;

    <span class="enscript-keyword">if</span>( (_offset + _length) &gt; fLength)
	<span class="enscript-keyword">return</span>( 0 );

    retain();
    <span class="enscript-keyword">if</span>( (fLength == _length) &amp;&amp; (!_offset))
    {
	newMapping = <span class="enscript-keyword">this</span>;
    }
    <span class="enscript-keyword">else</span>
    {
	newMapping-&gt;fSuperMap = <span class="enscript-keyword">this</span>;
	newMapping-&gt;fOffset   = fOffset + _offset;
	newMapping-&gt;fAddress  = fAddress + _offset;
    }

    <span class="enscript-keyword">return</span>( newMapping );
}

IOReturn <span class="enscript-function-name">IOMemoryMap::wireRange</span>(
    	uint32_t		options,
        mach_vm_size_t		offset,
        mach_vm_size_t		length)
{
    IOReturn kr;
    mach_vm_address_t start = trunc_page_64(fAddress + offset);
    mach_vm_address_t end   = round_page_64(fAddress + offset + length);
    vm_prot_t prot;

    prot = (kIODirectionOutIn &amp; options);
    <span class="enscript-keyword">if</span> (prot)
    {
	prot |= VM_PROT_MEMORY_TAG_MAKE(IOMemoryTag(kernel_map));
	kr = vm_map_wire(fAddressMap, start, end, prot, FALSE);
    }
    <span class="enscript-keyword">else</span>
    {
	kr = vm_map_unwire(fAddressMap, start, end, FALSE);
    }

    <span class="enscript-keyword">return</span> (kr);
}


IOPhysicalAddress 
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-function-name">IOMemoryMap::getPhysicalSegment</span>( IOByteCount _offset, IOPhysicalLength * _length, IOOptionBits _options)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
<span class="enscript-function-name">IOMemoryMap::getPhysicalSegment</span>( IOByteCount _offset, IOPhysicalLength * _length)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
{
    IOPhysicalAddress	address;

    LOCK;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
    address = fMemory-&gt;getPhysicalSegment( fOffset + _offset, _length, _options );
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
    address = fMemory-&gt;getPhysicalSegment( fOffset + _offset, _length );
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
    UNLOCK;

    <span class="enscript-keyword">return</span>( address );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::initialize</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>( 0 == gIOMemoryLock)
	gIOMemoryLock = IORecursiveLockAlloc();

    gIOLastPage = IOGetLastPageNumber();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>( _mappings) _mappings-&gt;release();

    <span class="enscript-keyword">if</span> (reserved)
    {
	IODelete(reserved, IOMemoryDescriptorReserved, 1);
	reserved = NULL;
    }
    <span class="enscript-reference">super</span>::free();
}

IOMemoryMap * <span class="enscript-function-name">IOMemoryDescriptor::setMapping</span>(
	task_t			intoTask,
	IOVirtualAddress	mapAddress,
	IOOptionBits		options )
{
    <span class="enscript-keyword">return</span> (createMappingInTask( intoTask, mapAddress,
				    options | kIOMapStatic,
				    0, getLength() ));
}

IOMemoryMap * <span class="enscript-function-name">IOMemoryDescriptor::map</span>( 
	IOOptionBits		options )
{
    <span class="enscript-keyword">return</span> (createMappingInTask( kernel_task, 0,
				options | kIOMapAnywhere,
				0, getLength() ));
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
IOMemoryMap * <span class="enscript-function-name">IOMemoryDescriptor::map</span>( 
	task_t		        intoTask,
	IOVirtualAddress	atAddress,
	IOOptionBits		options,
	IOByteCount		offset,
	IOByteCount		length )
{
    <span class="enscript-keyword">if</span> ((!(kIOMapAnywhere &amp; options)) &amp;&amp; vm_map_is_64bit(get_task_map(intoTask)))
    {
	OSReportWithBacktrace(<span class="enscript-string">&quot;IOMemoryDescriptor::map() in 64b task, use ::createMappingInTask()&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
    }

    <span class="enscript-keyword">return</span> (createMappingInTask(intoTask, atAddress,
				options, offset, length));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

IOMemoryMap * <span class="enscript-function-name">IOMemoryDescriptor::createMappingInTask</span>(
	task_t			intoTask,
	mach_vm_address_t	atAddress,
	IOOptionBits		options,
	mach_vm_size_t		offset,
	mach_vm_size_t		length)
{
    IOMemoryMap * result;
    IOMemoryMap * mapping;

    <span class="enscript-keyword">if</span> (0 == length)
	length = getLength();

    mapping = <span class="enscript-keyword">new</span> IOMemoryMap;

    <span class="enscript-keyword">if</span>( mapping
     &amp;&amp; !mapping-&gt;init( intoTask, atAddress,
			options, offset, length )) {
	mapping-&gt;release();
	mapping = 0;
    }

    <span class="enscript-keyword">if</span> (mapping)
	result = makeMapping(<span class="enscript-keyword">this</span>, intoTask, (IOVirtualAddress) mapping, options | kIOMap64Bit, 0, 0);
    <span class="enscript-keyword">else</span>
	result = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
    <span class="enscript-keyword">if</span> (!result)
	IOLog(<span class="enscript-string">&quot;createMappingInTask failed desc %p, addr %qx, options %x, offset %qx, length %llx\n&quot;</span>,
		<span class="enscript-keyword">this</span>, atAddress, (uint32_t) options, offset, length);
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> (result);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span> // <span class="enscript-variable-name">there</span> <span class="enscript-variable-name">is</span> <span class="enscript-variable-name">only</span> <span class="enscript-variable-name">a</span> 64 <span class="enscript-variable-name">bit</span> <span class="enscript-variable-name">version</span> <span class="enscript-variable-name">for</span> <span class="enscript-variable-name">LP64</span>
IOReturn <span class="enscript-function-name">IOMemoryMap::redirect</span>(IOMemoryDescriptor * newBackingMemory,
			        IOOptionBits         options,
			        IOByteCount          offset)
{
    <span class="enscript-keyword">return</span> (redirect(newBackingMemory, options, (mach_vm_size_t)offset));
}
#<span class="enscript-reference">endif</span>

IOReturn <span class="enscript-function-name">IOMemoryMap::redirect</span>(IOMemoryDescriptor * newBackingMemory,
			        IOOptionBits         options,
			        mach_vm_size_t       offset)
{
    IOReturn err = kIOReturnSuccess;
    IOMemoryDescriptor * physMem = 0;

    LOCK;

    <span class="enscript-keyword">if</span> (fAddress &amp;&amp; fAddressMap) <span class="enscript-keyword">do</span> 
    {
	<span class="enscript-keyword">if</span> (((fMemory-&gt;_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical)
	    || ((fMemory-&gt;_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical64))
	{
	    physMem = fMemory;
	    physMem-&gt;retain();
	}

	<span class="enscript-keyword">if</span> (!fRedirUPL &amp;&amp; fMemory-&gt;_memRef &amp;&amp; (1 == fMemory-&gt;_memRef-&gt;count))
	{
	    upl_size_t          size = round_page(fLength);
	    upl_control_flags_t flags = UPL_COPYOUT_FROM | UPL_SET_INTERNAL 
					| UPL_SET_LITE | UPL_SET_IO_WIRE | UPL_BLOCK_ACCESS
					| UPL_MEMORY_TAG_MAKE(IOMemoryTag(kernel_map));
	    <span class="enscript-keyword">if</span> (KERN_SUCCESS != memory_object_iopl_request(fMemory-&gt;_memRef-&gt;entries[0].entry, 0, &amp;size, &amp;fRedirUPL,
					    NULL, NULL,
					    &amp;flags))
		fRedirUPL = 0;

	    <span class="enscript-keyword">if</span> (physMem)
	    {
		IOUnmapPages( fAddressMap, fAddress, fLength );
		<span class="enscript-keyword">if</span> ((false))
		    physMem-&gt;redirect(0, true);
	    }
	}

	<span class="enscript-keyword">if</span> (newBackingMemory)
	{
	    <span class="enscript-keyword">if</span> (newBackingMemory != fMemory)
	    {
		fOffset = 0;
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">this</span> != newBackingMemory-&gt;makeMapping(newBackingMemory, fAddressTask, (IOVirtualAddress) <span class="enscript-keyword">this</span>, 
							    options | kIOMapUnique | kIOMapReference | kIOMap64Bit,
							    offset, fLength))
		    err = kIOReturnError;
	    }
	    <span class="enscript-keyword">if</span> (fRedirUPL)
	    {
		upl_commit(fRedirUPL, NULL, 0);
		upl_deallocate(fRedirUPL);
		fRedirUPL = 0;
	    }
	    <span class="enscript-keyword">if</span> ((false) &amp;&amp; physMem)
		physMem-&gt;redirect(0, false);
	}
    }
    <span class="enscript-keyword">while</span> (false);

    UNLOCK;

    <span class="enscript-keyword">if</span> (physMem)
	physMem-&gt;release();

    <span class="enscript-keyword">return</span> (err);
}

IOMemoryMap * <span class="enscript-function-name">IOMemoryDescriptor::makeMapping</span>(
	IOMemoryDescriptor *	owner,
	task_t			__intoTask,
	IOVirtualAddress	__address,
	IOOptionBits		options,
	IOByteCount		__offset,
	IOByteCount		__length )
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
    <span class="enscript-keyword">if</span> (!(kIOMap64Bit &amp; options)) panic(<span class="enscript-string">&quot;IOMemoryDescriptor::makeMapping !64bit&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

    IOMemoryDescriptor * mapDesc = 0;
    IOMemoryMap *	 result = 0;
    OSIterator *	 iter;

    IOMemoryMap *  mapping = (IOMemoryMap *) __address;
    mach_vm_size_t offset  = mapping-&gt;fOffset + __offset;
    mach_vm_size_t length  = mapping-&gt;fLength;

    mapping-&gt;fOffset = offset;

    LOCK;

    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-keyword">if</span> (kIOMapStatic &amp; options)
	{
	    result = mapping;
	    addMapping(mapping);
	    mapping-&gt;setMemoryDescriptor(<span class="enscript-keyword">this</span>, 0);
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-keyword">if</span> (kIOMapUnique &amp; options)
	{
	    addr64_t phys;
	    IOByteCount       physLen;

<span class="enscript-comment">//	    if (owner != this)		continue;
</span>
	    <span class="enscript-keyword">if</span> (((_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical)
		|| ((_flags &amp; kIOMemoryTypeMask) == kIOMemoryTypePhysical64))
	    {
		phys = getPhysicalSegment(offset, &amp;physLen, kIOMemoryMapperNone);
		<span class="enscript-keyword">if</span> (!phys || (physLen &lt; length))
		    <span class="enscript-keyword">continue</span>;
    
		mapDesc = IOMemoryDescriptor::withAddressRange(
				phys, length, getDirection() | kIOMemoryMapperNone, NULL);
		<span class="enscript-keyword">if</span> (!mapDesc)
		    <span class="enscript-keyword">continue</span>;
		offset = 0;
		mapping-&gt;fOffset = offset;
	    }
	}
	<span class="enscript-keyword">else</span>
	{
	    <span class="enscript-comment">// look for a compatible existing mapping
</span>	    <span class="enscript-keyword">if</span>( (iter = OSCollectionIterator::withCollection(_mappings)))
	    {
		IOMemoryMap * lookMapping;
		<span class="enscript-keyword">while</span> ((lookMapping = (IOMemoryMap *) iter-&gt;getNextObject()))
		{
		    <span class="enscript-keyword">if</span> ((result = lookMapping-&gt;copyCompatible(mapping)))
		    {
			addMapping(result);
			result-&gt;setMemoryDescriptor(<span class="enscript-keyword">this</span>, offset);
			<span class="enscript-keyword">break</span>;
		    }
		}
		iter-&gt;release();
	    }
	    <span class="enscript-keyword">if</span> (result || (options &amp; kIOMapReference))
	    {
	        <span class="enscript-keyword">if</span> (result != mapping)
	        {
                    mapping-&gt;release();
                    mapping = NULL;
                }
		<span class="enscript-keyword">continue</span>;
	    }
	}

	<span class="enscript-keyword">if</span> (!mapDesc)
	{
	    mapDesc = <span class="enscript-keyword">this</span>;
	    mapDesc-&gt;retain();
	}
	IOReturn
	kr = mapDesc-&gt;doMap( 0, (IOVirtualAddress *) &amp;mapping, options, 0, 0 );
	<span class="enscript-keyword">if</span> (kIOReturnSuccess == kr)
	{
	    result = mapping;
	    mapDesc-&gt;addMapping(result);
	    result-&gt;setMemoryDescriptor(mapDesc, offset);
	}
	<span class="enscript-keyword">else</span>
	{
	    mapping-&gt;release();
	    mapping = NULL;
	}
    }
    <span class="enscript-keyword">while</span>( false );

    UNLOCK;

    <span class="enscript-keyword">if</span> (mapDesc)
	mapDesc-&gt;release();

    <span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::addMapping</span>(
	IOMemoryMap * mapping )
{
    <span class="enscript-keyword">if</span>( mapping)
    {
        <span class="enscript-keyword">if</span>( 0 == _mappings)
            _mappings = OSSet::withCapacity(1);
	<span class="enscript-keyword">if</span>( _mappings )
	    _mappings-&gt;setObject( mapping );
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMemoryDescriptor::removeMapping</span>(
	IOMemoryMap * mapping )
{
    <span class="enscript-keyword">if</span>( _mappings)
        _mappings-&gt;removeObject( mapping);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">// obsolete initializers
</span><span class="enscript-comment">// - initWithOptions is the designated initializer 
</span><span class="enscript-type">bool</span>
<span class="enscript-function-name">IOMemoryDescriptor::initWithAddress</span>(<span class="enscript-type">void</span> *      address,
                                    IOByteCount   length,
                                    IODirection direction)
{
    <span class="enscript-keyword">return</span>( false );
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOMemoryDescriptor::initWithAddress</span>(IOVirtualAddress address,
                                    IOByteCount    length,
                                    IODirection  direction,
                                    task_t       task)
{
    <span class="enscript-keyword">return</span>( false );
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOMemoryDescriptor::initWithPhysicalAddress</span>(
				 IOPhysicalAddress	address,
				 IOByteCount		length,
				 IODirection      	direction )
{
    <span class="enscript-keyword">return</span>( false );
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOMemoryDescriptor::initWithRanges</span>(
                                   	IOVirtualRange * ranges,
                                   	UInt32           withCount,
                                   	IODirection      direction,
                                   	task_t           task,
                                  	<span class="enscript-type">bool</span>             asReference)
{
    <span class="enscript-keyword">return</span>( false );
}

<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOMemoryDescriptor::initWithPhysicalRanges</span>(	IOPhysicalRange * ranges,
                                        	UInt32           withCount,
                                        	IODirection      direction,
                                        	<span class="enscript-type">bool</span>             asReference)
{
    <span class="enscript-keyword">return</span>( false );
}

<span class="enscript-type">void</span> * <span class="enscript-function-name">IOMemoryDescriptor::getVirtualSegment</span>(IOByteCount offset,
					IOByteCount * lengthOfSegment)
{
    <span class="enscript-keyword">return</span>( 0 );
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOGeneralMemoryDescriptor::serialize</span>(OSSerialize * s) <span class="enscript-type">const</span>
{
    OSSymbol <span class="enscript-type">const</span> *keys[2];
    OSObject *values[2];
    OSArray * array;

    <span class="enscript-type">struct</span> SerData {
	user_addr_t address;
	user_size_t length;
    } *vcopy;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> index, nRanges;
    <span class="enscript-type">bool</span> result;

    IOOptionBits type = _flags &amp; kIOMemoryTypeMask;

    <span class="enscript-keyword">if</span> (s == NULL) <span class="enscript-keyword">return</span> false;

    array = OSArray::withCapacity(4);
    <span class="enscript-keyword">if</span> (!array)  <span class="enscript-keyword">return</span> (false);

    nRanges = _rangesCount;
    vcopy = (SerData *) IOMalloc(<span class="enscript-keyword">sizeof</span>(SerData) * nRanges);
    <span class="enscript-keyword">if</span> (vcopy == 0) <span class="enscript-keyword">return</span> false;

    keys[0] = OSSymbol::withCString(<span class="enscript-string">&quot;address&quot;</span>);
    keys[1] = OSSymbol::withCString(<span class="enscript-string">&quot;length&quot;</span>);

    result = false;
    values[0] = values[1] = 0;

    <span class="enscript-comment">// From this point on we can go to bail.
</span>
    <span class="enscript-comment">// Copy the volatile data so we don't have to allocate memory
</span>    <span class="enscript-comment">// while the lock is held.
</span>    LOCK;
    <span class="enscript-keyword">if</span> (nRanges == _rangesCount) {
	Ranges vec = _ranges;
        <span class="enscript-keyword">for</span> (index = 0; index &lt; nRanges; index++) {
	    mach_vm_address_t addr; mach_vm_size_t len;
	    getAddrLenForInd(addr, len, type, vec, index);
            vcopy[index].address = addr;
            vcopy[index].length  = len;
        }
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// The descriptor changed out from under us.  Give up.
</span>        UNLOCK;
	result = false;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
    }
    UNLOCK;

    <span class="enscript-keyword">for</span> (index = 0; index &lt; nRanges; index++)
    {
	user_addr_t addr = vcopy[index].address;
	IOByteCount len = (IOByteCount) vcopy[index].length;
	values[0] = OSNumber::withNumber(addr, <span class="enscript-keyword">sizeof</span>(addr) * 8);
	<span class="enscript-keyword">if</span> (values[0] == 0) {
	  result = false;
	  <span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
	values[1] = OSNumber::withNumber(len, <span class="enscript-keyword">sizeof</span>(len) * 8);
	<span class="enscript-keyword">if</span> (values[1] == 0) {
	  result = false;
	  <span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
        OSDictionary *dict = OSDictionary::withObjects((<span class="enscript-type">const</span> OSObject **)values, (<span class="enscript-type">const</span> OSSymbol **)keys, 2);
	<span class="enscript-keyword">if</span> (dict == 0) {
	  result = false;
	  <span class="enscript-keyword">goto</span> <span class="enscript-reference">bail</span>;
	}
	array-&gt;setObject(dict);
	dict-&gt;release();
	values[0]-&gt;release();
	values[1]-&gt;release();
	values[0] = values[1] = 0;
    }

    result = array-&gt;serialize(s);

 <span class="enscript-reference">bail</span>:
    <span class="enscript-keyword">if</span> (array)
      array-&gt;release();
    <span class="enscript-keyword">if</span> (values[0])
      values[0]-&gt;release();
    <span class="enscript-keyword">if</span> (values[1])
      values[1]-&gt;release();
    <span class="enscript-keyword">if</span> (keys[0])
      keys[0]-&gt;release();
    <span class="enscript-keyword">if</span> (keys[1])
      keys[1]-&gt;release();
    <span class="enscript-keyword">if</span> (vcopy)
        IOFree(vcopy, <span class="enscript-keyword">sizeof</span>(SerData) * nRanges);

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 7);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__LP64__ */</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 1);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOMemoryDescriptor, 7);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 8);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 9);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 10);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 11);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 12);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 13);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 14);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOMemoryDescriptor, 15);

<span class="enscript-comment">/* ex-inline function implementation */</span>
IOPhysicalAddress 
<span class="enscript-function-name">IOMemoryDescriptor::getPhysicalAddress</span>()
        { <span class="enscript-keyword">return</span>( getPhysicalSegment( 0, 0 )); }
</pre>
<hr />
</body></html>