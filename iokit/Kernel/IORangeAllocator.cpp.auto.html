<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IORangeAllocator.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IORangeAllocator.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1999 Apple Computer, Inc.
 *
 *
 * HISTORY
 *
 * sdouglas 05 Nov 99 - created.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSArray.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSNumber.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IORangeAllocator.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLocks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>( IORangeAllocator, OSObject )

<span class="enscript-type">struct</span> IORangeAllocatorElement {
    <span class="enscript-comment">// closed range
</span>    IORangeScalar	start;
    IORangeScalar	end;
};

IOLock *	gIORangeAllocatorLock;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCK</span>()		\
	<span class="enscript-keyword">if</span>( options &amp; kLocking)	IOTakeLock( gIORangeAllocatorLock )
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNLOCK</span>()	\
	<span class="enscript-keyword">if</span>( options &amp; kLocking)	IOUnlock( gIORangeAllocatorLock )

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IORangeAllocator::init</span>( IORangeScalar endOfRange,
				IORangeScalar _defaultAlignment,
				UInt32 _capacity,
				IOOptionBits _options )
{
    <span class="enscript-keyword">if</span>( !super::init())
	<span class="enscript-keyword">return</span>( false );

    <span class="enscript-keyword">if</span>( !_capacity)
	_capacity = 1;
    <span class="enscript-keyword">if</span>( !_defaultAlignment)
	_defaultAlignment = 1;
    capacity		= 0;
    capacityIncrement	= _capacity;
    numElements 	= 0;
    elements 		= 0;
    defaultAlignmentMask = _defaultAlignment - 1;
    options		= _options;

    <span class="enscript-keyword">if</span>( (!gIORangeAllocatorLock) &amp;&amp; (options &amp; kLocking))
	gIORangeAllocatorLock = IOLockAlloc();

    <span class="enscript-keyword">if</span>( endOfRange)
	deallocate( 0, endOfRange + 1 );

    <span class="enscript-keyword">return</span>( true );
}

IORangeAllocator * <span class="enscript-function-name">IORangeAllocator::withRange</span>(
					IORangeScalar endOfRange,
				        IORangeScalar defaultAlignment,
				        UInt32 capacity,
					IOOptionBits options )
{
    IORangeAllocator * thingy;

    thingy = <span class="enscript-keyword">new</span> IORangeAllocator;
    <span class="enscript-keyword">if</span>( thingy &amp;&amp; ! thingy-&gt;init( endOfRange, defaultAlignment,
				capacity, options )) {
	thingy-&gt;release();
	thingy = 0;
    }

    <span class="enscript-keyword">return</span>( thingy );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORangeAllocator::free</span>()
{
    <span class="enscript-keyword">if</span>( elements)
	IODelete( elements, IORangeAllocatorElement, capacity );

    <span class="enscript-reference">super</span>::free();
}

UInt32 <span class="enscript-function-name">IORangeAllocator::getFragmentCount</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( numElements );
}

UInt32 <span class="enscript-function-name">IORangeAllocator::getFragmentCapacity</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( capacity );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORangeAllocator::setFragmentCapacityIncrement</span>( UInt32 count )
{
    capacityIncrement = count;
}


<span class="enscript-comment">// allocate element at index
</span><span class="enscript-type">bool</span> <span class="enscript-function-name">IORangeAllocator::allocElement</span>( UInt32 index )
{
    UInt32			newCapacity;
    IORangeAllocatorElement *	newElements;

    <span class="enscript-keyword">if</span>( ((numElements == capacity) &amp;&amp; capacityIncrement)
     || (!elements)) {

	newCapacity = capacity + capacityIncrement;
	newElements = IONew( IORangeAllocatorElement, newCapacity );
	<span class="enscript-keyword">if</span>( !newElements)
	    <span class="enscript-keyword">return</span>( false );

	<span class="enscript-keyword">if</span>( elements) {
	    bcopy( elements,
		   newElements,
		   index * <span class="enscript-keyword">sizeof</span>( IORangeAllocatorElement));
	    bcopy( elements + index,
		   newElements + index + 1,
		   (numElements - index) * <span class="enscript-keyword">sizeof</span>( IORangeAllocatorElement));

	    IODelete( elements, IORangeAllocatorElement, capacity );
	}

	elements = newElements;
	capacity = newCapacity;

    } <span class="enscript-keyword">else</span> {

	bcopy( elements + index,
	       elements + index + 1,
	       (numElements - index) * <span class="enscript-keyword">sizeof</span>( IORangeAllocatorElement));
    }
    numElements++;

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-comment">// destroy element at index
</span><span class="enscript-type">void</span> <span class="enscript-function-name">IORangeAllocator::deallocElement</span>( UInt32 index )
{
    numElements--;
    bcopy( elements + index + 1,
	   elements + index,
	   (numElements - index) * <span class="enscript-keyword">sizeof</span>( IORangeAllocatorElement));
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IORangeAllocator::allocate</span>( IORangeScalar size,
				 IORangeScalar * result,
				 IORangeScalar alignment )
{
    IORangeScalar	data, dataEnd;
    IORangeScalar	thisStart, thisEnd;
    UInt32		index;
    <span class="enscript-type">bool</span>		ok = false;

    <span class="enscript-keyword">if</span>( !size || !result)
	<span class="enscript-keyword">return</span>( false );

    <span class="enscript-keyword">if</span>( 0 == alignment)
	alignment = defaultAlignmentMask;
    <span class="enscript-keyword">else</span>
        alignment--;

    size = (size + defaultAlignmentMask) &amp; ~defaultAlignmentMask;

    LOCK();

    <span class="enscript-keyword">for</span>( index = 0; index &lt; numElements; index++ ) {

	thisStart = elements[index].start;
	thisEnd = elements[index].end;
        data = (thisStart + alignment) &amp; ~alignment;
	dataEnd = (data + size - 1);

	ok = (dataEnd &lt;= thisEnd);
	<span class="enscript-keyword">if</span>( ok) {
	    <span class="enscript-keyword">if</span>( data != thisStart) {
		<span class="enscript-keyword">if</span>( dataEnd != thisEnd) {
		    <span class="enscript-keyword">if</span>( allocElement( index + 1 )) {
			elements[index++].end = data - 1;
			elements[index].start = dataEnd + 1;
			elements[index].end = thisEnd;
		    } <span class="enscript-keyword">else</span>
			ok = false;
		} <span class="enscript-keyword">else</span>
		    elements[index].end = data - 1;
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span>( dataEnd != thisEnd)
		    elements[index].start = dataEnd + 1;
		<span class="enscript-keyword">else</span>
		    deallocElement( index );
	    }
	    <span class="enscript-keyword">if</span>( ok)
		*result = data;
      	    <span class="enscript-keyword">break</span>;
	} 
    }

    UNLOCK();

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IORangeAllocator::allocateRange</span>( IORangeScalar data,
					 IORangeScalar size )
{
    IORangeScalar	thisStart, thisEnd;
    IORangeScalar	dataEnd;
    UInt32		index;
    <span class="enscript-type">bool</span>		found = false;

    <span class="enscript-keyword">if</span>( !size)
	<span class="enscript-keyword">return</span>( 0 );

    size = (size + defaultAlignmentMask) &amp; ~defaultAlignmentMask;
    dataEnd = data + size - 1;

    LOCK();

    <span class="enscript-keyword">for</span>( index = 0;
	 (!found) &amp;&amp; (index &lt; numElements);
	 index++ ) {

	thisStart = elements[index].start;
	thisEnd = elements[index].end;

	<span class="enscript-keyword">if</span>( thisStart &gt; data)
	    <span class="enscript-keyword">break</span>;
	found = (dataEnd &lt;= thisEnd);

        <span class="enscript-keyword">if</span>( found) {
	    <span class="enscript-keyword">if</span>( data != thisStart) {
	        <span class="enscript-keyword">if</span>( dataEnd != thisEnd) {
		    found = allocElement( index + 1 );
		    <span class="enscript-keyword">if</span>( found) {
		        elements[index++].end = data - 1;
		        elements[index].start = dataEnd + 1;
		        elements[index].end = thisEnd;
		    }
	        } <span class="enscript-keyword">else</span>
	       	    elements[index].end = data - 1;
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( dataEnd != thisEnd)
      	        elements[index].start = dataEnd + 1;
	    <span class="enscript-keyword">else</span>
	        deallocElement( index );
        }
    }

    UNLOCK();

    <span class="enscript-keyword">return</span>( found );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IORangeAllocator::deallocate</span>( IORangeScalar data,
				   IORangeScalar size )
{
    IORangeScalar	dataEnd;
    UInt32		index;
    <span class="enscript-type">bool</span>		headContig = false;
    <span class="enscript-type">bool</span>		tailContig = false;

    size = (size + defaultAlignmentMask) &amp; ~defaultAlignmentMask;
    dataEnd = data + size - 1;

    LOCK();

    <span class="enscript-keyword">for</span>( index = 0; index &lt; numElements; index++ ) {
	<span class="enscript-keyword">if</span>( elements[index].start &lt; data) {
	    headContig = (data &lt;= (elements[index].end + 1));
	    <span class="enscript-keyword">continue</span>;
	}
	tailContig = ((data + size) &gt;= elements[index].start);
	<span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span>( headContig) {
        <span class="enscript-keyword">if</span>( tailContig) {
            elements[index-1].end = elements[index].end;
	    deallocElement( index );
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/*safe*/</span> <span class="enscript-keyword">if</span>( dataEnd &gt; elements[index-1].end)
	    elements[index-1].end = dataEnd;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( tailContig) {
	<span class="enscript-keyword">if</span>( data &lt; elements[index].start) <span class="enscript-comment">/*safe*/</span>
	    elements[index].start = data;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( allocElement( index)) {
	elements[index].start = data;
	elements[index].end = dataEnd;
    }

    UNLOCK();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IORangeAllocator::serialize</span>(OSSerialize *s) <span class="enscript-type">const</span>
{
    OSArray *	array = OSArray::withCapacity( numElements * 2 );
    OSNumber *	num;
    UInt32	index;
    <span class="enscript-type">bool</span>	ret;

    <span class="enscript-keyword">if</span>( !array)
	<span class="enscript-keyword">return</span>( false );

    LOCK();

    <span class="enscript-keyword">for</span>( index = 0; index &lt; numElements; index++) {
	<span class="enscript-keyword">if</span>( (num = OSNumber::withNumber( elements[index].start,
					8 * <span class="enscript-keyword">sizeof</span>(IORangeScalar) ))) {
	    array-&gt;setObject(num);
	    num-&gt;release();
	}
	<span class="enscript-keyword">if</span>( (num = OSNumber::withNumber( elements[index].end,
					8 * <span class="enscript-keyword">sizeof</span>(IORangeScalar) ))) {
	    array-&gt;setObject(num);
	    num-&gt;release();
	}
    }

    UNLOCK();

    ret = array-&gt;serialize(s);
    array-&gt;release();

    <span class="enscript-keyword">return</span>( ret );
}

IORangeScalar <span class="enscript-function-name">IORangeAllocator::getFreeCount</span>( <span class="enscript-type">void</span> )
{
    UInt32		index;
    IORangeScalar	sum = 0;

    <span class="enscript-keyword">for</span>( index = 0; index &lt; numElements; index++)
	sum += elements[index].end - elements[index].start + 1;

    <span class="enscript-keyword">return</span>( sum );
}

</pre>
<hr />
</body></html>