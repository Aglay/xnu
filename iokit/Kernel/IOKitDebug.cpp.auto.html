<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOKitDebug.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOKitDebug.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2010 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSCPPDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IOKITDEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_INIT_VALUE</span> IOKITDEBUG
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_INIT_VALUE</span> 0
#<span class="enscript-reference">endif</span>

SInt64          gIOKitDebug = DEBUG_INIT_VALUE;
SInt64          gIOKitTrace = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IODEBUG_CTLFLAGS</span>        CTLFLAG_RW
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IODEBUG_CTLFLAGS</span>        CTLFLAG_RD
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_QUAD</span>(_debug, OID_AUTO, iokit, IODEBUG_CTLFLAGS | CTLFLAG_LOCKED, &amp;gIOKitDebug, <span class="enscript-string">&quot;boot_arg io&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_debug, OID_AUTO, iotrace, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;gIOKitTrace, <span class="enscript-string">&quot;trace io&quot;</span>);


<span class="enscript-type">int</span>             debug_malloc_size;
<span class="enscript-type">int</span>             debug_iomalloc_size;

vm_size_t       debug_iomallocpageable_size;
<span class="enscript-type">int</span>             debug_container_malloc_size;
<span class="enscript-comment">// int          debug_ivars_size; // in OSObject.cpp
</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEBG</span>(fmt, args...)   { kprintf(fmt, ## args); }
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEBG</span>(fmt, args...)   { IOLog(fmt, ## args); }
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPrintPlane</span>( <span class="enscript-type">const</span> IORegistryPlane * plane )
{
    IORegistryEntry *           next;
    IORegistryIterator *        iter;
    OSOrderedSet *              all;
    <span class="enscript-type">char</span>                        format[] = <span class="enscript-string">&quot;%xxxs&quot;</span>;
    IOService *                 service;

    iter = IORegistryIterator::iterateOver( plane );
    assert( iter );
    all = iter-&gt;iterateAll();
    <span class="enscript-keyword">if</span>( all) {
        DEBG(<span class="enscript-string">&quot;Count %d\n&quot;</span>, all-&gt;getCount() );
        all-&gt;release();
    } <span class="enscript-keyword">else</span>
        DEBG(<span class="enscript-string">&quot;Empty\n&quot;</span>);

    iter-&gt;reset();
    <span class="enscript-keyword">while</span>( (next = iter-&gt;getNextObjectRecursive())) {
        snprintf(format + 1, <span class="enscript-keyword">sizeof</span>(format) - 1, <span class="enscript-string">&quot;%ds&quot;</span>, 2 * next-&gt;getDepth( plane ));
        DEBG( format, <span class="enscript-string">&quot;&quot;</span>);
        DEBG( <span class="enscript-string">&quot;\033[33m%s&quot;</span>, next-&gt;getName( plane ));
        <span class="enscript-keyword">if</span>( (next-&gt;getLocation( plane )))
            DEBG(<span class="enscript-string">&quot;@%s&quot;</span>, next-&gt;getLocation( plane ));
        DEBG(<span class="enscript-string">&quot;\033[0m &lt;class %s&quot;</span>, next-&gt;getMetaClass()-&gt;getClassName());
        <span class="enscript-keyword">if</span>( (service = OSDynamicCast(IOService, next)))
            DEBG(<span class="enscript-string">&quot;, busy %ld&quot;</span>, (<span class="enscript-type">long</span>) service-&gt;getBusyState());
        DEBG( <span class="enscript-string">&quot;&gt;\n&quot;</span>);
<span class="enscript-comment">//      IOSleep(250);
</span>    }
    iter-&gt;release();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">db_piokjunk</span>(<span class="enscript-type">void</span>)
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">db_dumpiojunk</span>( <span class="enscript-type">const</span> IORegistryPlane * plane __unused )
{
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOPrintMemory</span>( <span class="enscript-type">void</span> )
{

<span class="enscript-comment">//    OSMetaClass::printInstanceCounts();
</span>
    IOLog(<span class="enscript-string">&quot;\n&quot;</span>
            <span class="enscript-string">&quot;ivar kalloc()       0x%08x\n&quot;</span>
            <span class="enscript-string">&quot;malloc()            0x%08x\n&quot;</span>
            <span class="enscript-string">&quot;containers kalloc() 0x%08x\n&quot;</span>
            <span class="enscript-string">&quot;IOMalloc()          0x%08x\n&quot;</span>
            <span class="enscript-string">&quot;----------------------------------------\n&quot;</span>,
            debug_ivars_size,
            debug_malloc_size,
            debug_container_malloc_size,
            debug_iomalloc_size
            );
}

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOKitDiagnostics, OSObject)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

OSObject * <span class="enscript-function-name">IOKitDiagnostics::diagnostics</span>( <span class="enscript-type">void</span> )
{
    IOKitDiagnostics * diags;

    diags = <span class="enscript-keyword">new</span> IOKitDiagnostics;
    <span class="enscript-keyword">if</span>( diags &amp;&amp; !diags-&gt;init()) {
        diags-&gt;release();
        diags = 0;
    }

    <span class="enscript-keyword">return</span>( diags );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOKitDiagnostics::updateOffset</span>( OSDictionary * dict,
                        UInt64 value, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name )
{
    OSNumber * off;

    off = OSNumber::withNumber( value, 64 );
    <span class="enscript-keyword">if</span>( !off)
        <span class="enscript-keyword">return</span>;

    dict-&gt;setObject( name, off );
    off-&gt;release();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOKitDiagnostics::serialize</span>(OSSerialize *s) <span class="enscript-type">const</span>
{
    OSDictionary *      dict;
    <span class="enscript-type">bool</span>                ok;

    dict = OSDictionary::withCapacity( 5 );
    <span class="enscript-keyword">if</span>( !dict)
        <span class="enscript-keyword">return</span>( false );

    updateOffset( dict, debug_ivars_size, <span class="enscript-string">&quot;Instance allocation&quot;</span> );
    updateOffset( dict, debug_container_malloc_size, <span class="enscript-string">&quot;Container allocation&quot;</span> );
    updateOffset( dict, debug_iomalloc_size, <span class="enscript-string">&quot;IOMalloc allocation&quot;</span> );
    updateOffset( dict, debug_iomallocpageable_size, <span class="enscript-string">&quot;Pageable allocation&quot;</span> );

    <span class="enscript-reference">OSMetaClass</span>::serializeClassDictionary(dict);

    ok = dict-&gt;serialize( s );

    dict-&gt;release();

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSCPPDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

__private_extern__ <span class="enscript-string">&quot;C&quot;</span> <span class="enscript-type">void</span> qsort(
    <span class="enscript-type">void</span> * array,
    size_t nmembers,
    size_t member_size,
    <span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *));

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> ppnum_t pmap_find_phys(pmap_t pmap, addr64_t va);
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> ppnum_t pmap_valid_page(ppnum_t pn);

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">struct</span> IOTRecursiveLock
{
    lck_mtx_t * mutex;
    thread_t    thread;
    UInt32      count;
};

<span class="enscript-type">struct</span> IOTrackingQueue
{
    queue_chain_t     link;
    IOTRecursiveLock  lock;
    queue_head_t      sites;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *      name;
    size_t            allocSize;
    size_t            minCaptureSize;
    uint32_t          siteCount;
    uint8_t           captureOn;
    uint8_t           isAlloc;
};

<span class="enscript-type">struct</span> IOTrackingCallSite
{
    queue_chain_t          link;
    IOTrackingQueue *      queue;
    uint32_t               crc;
    IOTrackingCallSiteInfo info; 
    queue_chain_t          instances;
    IOTracking *           addresses;
};

<span class="enscript-type">struct</span> IOTrackingLeaksRef
{
    uintptr_t * instances;
    uint32_t    count;
    uint32_t    found;
    size_t      bytes;
};

<span class="enscript-type">enum</span>
{
    kInstanceFlagAddress    = 0x01UL,
    kInstanceFlagReferenced = 0x02UL,
    kInstanceFlags          = 0x03UL
};

lck_mtx_t *  gIOTrackingLock;
queue_head_t gIOTrackingQ;

<span class="enscript-type">enum</span>
{
    kTrackingAddressFlagAllocated    = 0x00000001
};

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOTrackingAddressFlags</span>(ptr)	(ptr-&gt;flags)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOTrackingAddressFlags</span>(ptr)	(ptr-&gt;tracking.flags)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">IOTRecursiveLockLock</span>(IOTRecursiveLock * lock)
{
    <span class="enscript-keyword">if</span> (lock-&gt;thread == current_thread()) lock-&gt;count++;
    <span class="enscript-keyword">else</span>
    {
        lck_mtx_lock(lock-&gt;mutex);
        assert(lock-&gt;thread == 0);
        assert(lock-&gt;count == 0);
        lock-&gt;thread = current_thread();
        lock-&gt;count = 1;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">IOTRecursiveLockUnlock</span>(IOTRecursiveLock * lock)
{
    assert(lock-&gt;thread == current_thread());
    <span class="enscript-keyword">if</span> (0 == (--lock-&gt;count))
    {
        lock-&gt;thread = 0;
        lck_mtx_unlock(lock-&gt;mutex);
    }
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingInit</span>(<span class="enscript-type">void</span>)
{
    queue_init(&amp;gIOTrackingQ);
    gIOTrackingLock = lck_mtx_alloc_init(IOLockGroup, LCK_ATTR_NULL);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOTrackingQueue *
<span class="enscript-function-name">IOTrackingQueueAlloc</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, size_t allocSize, size_t minCaptureSize, <span class="enscript-type">bool</span> isAlloc)
{
    IOTrackingQueue * queue;
    queue = (typeof(queue)) kalloc(<span class="enscript-keyword">sizeof</span>(IOTrackingQueue));
    bzero(queue, <span class="enscript-keyword">sizeof</span>(IOTrackingQueue));

    queue-&gt;name           = name;
    queue-&gt;allocSize      = allocSize;
    queue-&gt;minCaptureSize = minCaptureSize;
    queue-&gt;lock.mutex     = lck_mtx_alloc_init(IOLockGroup, LCK_ATTR_NULL);
    queue_init(&amp;queue-&gt;sites);

    queue-&gt;captureOn = (0 != (kIOTrackingBoot &amp; gIOKitDebug));
    queue-&gt;isAlloc   = isAlloc;

    lck_mtx_lock(gIOTrackingLock);
    queue_enter(&amp;gIOTrackingQ, queue, IOTrackingQueue *, link);
    lck_mtx_unlock(gIOTrackingLock);

    <span class="enscript-keyword">return</span> (queue);
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingQueueFree</span>(IOTrackingQueue * queue)
{
    lck_mtx_lock(gIOTrackingLock);
    IOTrackingReset(queue);
    remque(&amp;queue-&gt;link);
    lck_mtx_unlock(gIOTrackingLock);

    lck_mtx_free(queue-&gt;lock.mutex, IOLockGroup);

    kfree(queue, <span class="enscript-keyword">sizeof</span>(IOTrackingQueue));
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/* fasthash
   The MIT License

   Copyright (C) 2012 Zilong Tan (<a href="mailto:eric.zltan@gmail.com">eric.zltan@gmail.com</a>)

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the &quot;Software&quot;), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/</span>


<span class="enscript-comment">// Compression function for Merkle-Damgard construction.
</span><span class="enscript-comment">// This function is generated using the framework provided.
</span>#<span class="enscript-reference">define</span> <span class="enscript-function-name">mix</span>(h) ({                               \
                  (h) ^= (h) &gt;&gt; 23;             \
                  (h) *= 0x2127599bf4325c37ULL; \
                  (h) ^= (h) &gt;&gt; 47; })

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">fasthash64</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *buf, size_t len, uint64_t seed)
{
    <span class="enscript-type">const</span> uint64_t    m = 0x880355f21e6d1965ULL;
    <span class="enscript-type">const</span> uint64_t *pos = (<span class="enscript-type">const</span> uint64_t *)buf;
    <span class="enscript-type">const</span> uint64_t *end = pos + (len / 8);
    <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *pos2;
    uint64_t h = seed ^ (len * m);
    uint64_t v;

    <span class="enscript-keyword">while</span> (pos != end) {
        v  = *pos++;
        h ^= mix(v);
        h *= m;
    }

    pos2 = (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)pos;
    v = 0;

    <span class="enscript-keyword">switch</span> (len &amp; 7) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>: v ^= (uint64_t)pos2[6] &lt;&lt; 48;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>: v ^= (uint64_t)pos2[5] &lt;&lt; 40;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>: v ^= (uint64_t)pos2[4] &lt;&lt; 32;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>: v ^= (uint64_t)pos2[3] &lt;&lt; 24;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>: v ^= (uint64_t)pos2[2] &lt;&lt; 16;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>: v ^= (uint64_t)pos2[1] &lt;&lt; 8;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>: v ^= (uint64_t)pos2[0];
            h ^= mix(v);
            h *= m;
    }

    <span class="enscript-keyword">return</span> mix(h);
} 

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">fasthash32</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *buf, size_t len, uint32_t seed)
{
    <span class="enscript-comment">// the following trick converts the 64-bit hashcode to Fermat
</span>    <span class="enscript-comment">// residue, which shall retain information from both the higher
</span>    <span class="enscript-comment">// and lower parts of hashcode.
</span>    uint64_t h = fasthash64(buf, len, seed);
    <span class="enscript-keyword">return</span> h - (h &gt;&gt; 32);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingAdd</span>(IOTrackingQueue * queue, IOTracking * mem, size_t size, <span class="enscript-type">bool</span> address)
{
    IOTrackingCallSite * site;
    uint32_t             crc, num;
    uintptr_t            bt[kIOTrackingCallSiteBTs + 1];

    <span class="enscript-keyword">if</span> (mem-&gt;site)                    <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (!queue-&gt;captureOn)            <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (size &lt; queue-&gt;minCaptureSize) <span class="enscript-keyword">return</span>;

    assert(!mem-&gt;link.next);

    num  = fastbacktrace(&amp;bt[0], kIOTrackingCallSiteBTs + 1);
    num--;
    crc = fasthash32(&amp;bt[1], num * <span class="enscript-keyword">sizeof</span>(bt[0]), 0x04C11DB7);

    IOTRecursiveLockLock(&amp;queue-&gt;lock);
    queue_iterate(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link)
    {
        <span class="enscript-keyword">if</span> (crc == site-&gt;crc) <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (queue_end(&amp;queue-&gt;sites, (queue_entry_t) site))
    {
        site = (typeof(site)) kalloc(<span class="enscript-keyword">sizeof</span>(IOTrackingCallSite));

        queue_init(&amp;site-&gt;instances);
        site-&gt;addresses  = (IOTracking *) &amp;site-&gt;instances;
        site-&gt;queue      = queue;
        site-&gt;crc        = crc;
        site-&gt;info.count = 0;
        memset(&amp;site-&gt;info.size[0], 0, <span class="enscript-keyword">sizeof</span>(site-&gt;info.size));
        bcopy(&amp;bt[1], &amp;site-&gt;info.bt[0], num * <span class="enscript-keyword">sizeof</span>(site-&gt;info.bt[0]));
        assert(num &lt;= kIOTrackingCallSiteBTs);
        bzero(&amp;site-&gt;info.bt[num], (kIOTrackingCallSiteBTs - num) * <span class="enscript-keyword">sizeof</span>(site-&gt;info.bt[0]));

        queue_enter_first(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link);
        queue-&gt;siteCount++;
    }

    <span class="enscript-keyword">if</span> (address)
    {
        queue_enter<span class="enscript-comment">/*last*/</span>(&amp;site-&gt;instances, mem, IOTrackingCallSite *, link);
        <span class="enscript-keyword">if</span> (queue_end(&amp;site-&gt;instances, (queue_entry_t)site-&gt;addresses)) site-&gt;addresses = mem;
    }
    <span class="enscript-keyword">else</span> queue_enter_first(&amp;site-&gt;instances, mem, IOTrackingCallSite *, link);

    mem-&gt;site = site;
    site-&gt;info.size[0] += size;
    site-&gt;info.count++;

    IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingRemove</span>(IOTrackingQueue * queue, IOTracking * mem, size_t size)
{
    <span class="enscript-keyword">if</span> (!mem-&gt;link.next) <span class="enscript-keyword">return</span>;

    IOTRecursiveLockLock(&amp;queue-&gt;lock);

    assert(mem-&gt;site);

    <span class="enscript-keyword">if</span> (mem == mem-&gt;site-&gt;addresses) mem-&gt;site-&gt;addresses = (IOTracking *) queue_next(&amp;mem-&gt;link);
    remque(&amp;mem-&gt;link);

    assert(mem-&gt;site-&gt;info.count);
    mem-&gt;site-&gt;info.count--;
    assert(mem-&gt;site-&gt;info.size[0] &gt;= size);
    mem-&gt;site-&gt;info.size[0] -= size;
    <span class="enscript-keyword">if</span> (!mem-&gt;site-&gt;info.count)
    {
        assert(queue_empty(&amp;mem-&gt;site-&gt;instances));
        assert(!mem-&gt;site-&gt;info.size[0]);
        assert(!mem-&gt;site-&gt;info.size[1]);

        remque(&amp;mem-&gt;site-&gt;link);
        assert(queue-&gt;siteCount);
        queue-&gt;siteCount--;
        kfree(mem-&gt;site, <span class="enscript-keyword">sizeof</span>(IOTrackingCallSite));
    }
    IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingAlloc</span>(IOTrackingQueue * queue, uintptr_t address, size_t size)
{
    IOTrackingAddress * tracking;
    
    <span class="enscript-keyword">if</span> (!queue-&gt;captureOn)            <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (size &lt; queue-&gt;minCaptureSize) <span class="enscript-keyword">return</span>;

    address = ~address;
    tracking = (typeof(tracking)) kalloc(<span class="enscript-keyword">sizeof</span>(IOTrackingAddress));
    bzero(tracking, <span class="enscript-keyword">sizeof</span>(IOTrackingAddress));
    IOTrackingAddressFlags(tracking) |= kTrackingAddressFlagAllocated;
    tracking-&gt;address = address;
    tracking-&gt;size    = size;

    IOTrackingAdd(queue, &amp;tracking-&gt;tracking, size, true);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingFree</span>(IOTrackingQueue * queue, uintptr_t address, size_t size)
{
    IOTrackingCallSite * site;
    IOTrackingAddress  * tracking;
    <span class="enscript-type">bool</span>                 done;

    address = ~address;
    IOTRecursiveLockLock(&amp;queue-&gt;lock);
    done = false;
    queue_iterate(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link)
    {
        <span class="enscript-keyword">for</span> (tracking = (IOTrackingAddress *) site-&gt;addresses; 
                !done &amp;&amp; !queue_end(&amp;site-&gt;instances, (queue_entry_t) tracking);
                tracking = (IOTrackingAddress *) queue_next(&amp;tracking-&gt;tracking.link))
        {
            <span class="enscript-keyword">if</span> ((done = (address == tracking-&gt;address)))
            {
                IOTrackingRemove(queue, &amp;tracking-&gt;tracking, size);
                kfree(tracking, <span class="enscript-keyword">sizeof</span>(IOTrackingAddress));
            }
        }
        <span class="enscript-keyword">if</span> (done) <span class="enscript-keyword">break</span>;
    }

    IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingAccumSize</span>(IOTrackingQueue * queue, IOTracking * mem, size_t size)
{
    IOTRecursiveLockLock(&amp;queue-&gt;lock);
    <span class="enscript-keyword">if</span> (mem-&gt;link.next)
    {
        assert(mem-&gt;site);
        assert((size &gt; 0) || (mem-&gt;site-&gt;info.size[1] &gt;= -size));
        mem-&gt;site-&gt;info.size[1] += size;    
    };
    IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingReset</span>(IOTrackingQueue * queue)
{
    IOTrackingCallSite * site;
    IOTracking         * tracking;
    IOTrackingAddress  * trackingAddress;
    <span class="enscript-type">bool</span>                 addresses;

    IOTRecursiveLockLock(&amp;queue-&gt;lock);
    <span class="enscript-keyword">while</span> (!queue_empty(&amp;queue-&gt;sites))
    {
        queue_remove_first(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link);
        addresses = false;
        <span class="enscript-keyword">while</span> (!queue_empty(&amp;site-&gt;instances))
        {
            queue_remove_first(&amp;site-&gt;instances, tracking, IOTracking *, link);
            tracking-&gt;link.next = 0;
            <span class="enscript-keyword">if</span> (tracking == site-&gt;addresses) addresses = true;
            <span class="enscript-keyword">if</span> (addresses)
            {
                trackingAddress = (typeof(trackingAddress)) tracking;
                <span class="enscript-keyword">if</span> (kTrackingAddressFlagAllocated &amp; IOTrackingAddressFlags(trackingAddress))
                {
		    kfree(tracking, <span class="enscript-keyword">sizeof</span>(IOTrackingAddress));
		}
	    }
        }
        kfree(site, <span class="enscript-keyword">sizeof</span>(IOTrackingCallSite));
    }
    queue-&gt;siteCount = 0;
    IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">IOTrackingCallSiteInfoCompare</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * left, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * right)
{
    IOTrackingCallSiteInfo * l = (typeof(l)) left;
    IOTrackingCallSiteInfo * r = (typeof(r)) right;
    size_t                   lsize, rsize;

    rsize = r-&gt;size[0] + r-&gt;size[1];
    lsize = l-&gt;size[0] + l-&gt;size[1];

    <span class="enscript-keyword">return</span> ((rsize &gt; lsize) ? 1 : ((rsize == lsize) ? 0 : -1));
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">IOTrackingAddressCompare</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> * left, <span class="enscript-type">const</span> <span class="enscript-type">void</span> * right)
{
    IOTracking * instance;
    uintptr_t    inst, laddr, raddr;

    inst = ((typeof(inst) *) left)[0];
    instance = (typeof(instance)) (inst &amp; ~kInstanceFlags);
    <span class="enscript-keyword">if</span> (kInstanceFlagAddress &amp; inst) laddr = ~((IOTrackingAddress *)instance)-&gt;address;
    <span class="enscript-keyword">else</span>                             laddr = (uintptr_t) (instance + 1);

    inst = ((typeof(inst) *) right)[0];
    instance = (typeof(instance)) (inst &amp; ~kInstanceFlags);
    <span class="enscript-keyword">if</span> (kInstanceFlagAddress &amp; inst) raddr = ~((IOTrackingAddress *)instance)-&gt;address;
    <span class="enscript-keyword">else</span>                             raddr = (uintptr_t) (instance + 1);

    <span class="enscript-keyword">return</span> ((laddr &gt; raddr) ? 1 : ((laddr == raddr) ? 0 : -1));
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">IOTrackingLeakScan</span>(<span class="enscript-type">void</span> * refcon)
{
    IOTrackingLeaksRef * ref = (typeof(ref)) refcon;
    uintptr_t          * instances;
    IOTracking         * instance;
    uint64_t             vaddr, vincr;
    ppnum_t              ppn;
    uintptr_t            ptr, addr, inst;
    size_t               size;
    uint32_t             baseIdx, lim, ptrIdx, count;
    boolean_t            is;

<span class="enscript-comment">//    if (cpu_number()) return;
</span>
    instances = ref-&gt;instances;
    count     = ref-&gt;count;

    <span class="enscript-keyword">for</span> (vaddr = VM_MIN_KERNEL_AND_KEXT_ADDRESS;
         vaddr &lt; VM_MAX_KERNEL_ADDRESS;
         ml_set_interrupts_enabled(is), vaddr += vincr)
    {
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
        thread_block(NULL);
#<span class="enscript-reference">endif</span>
        is = ml_set_interrupts_enabled(false);

        ppn = kernel_pmap_present_mapping(vaddr, &amp;vincr);
        <span class="enscript-comment">// check noencrypt to avoid VM structs (map entries) with pointers
</span>        <span class="enscript-keyword">if</span> (ppn &amp;&amp; (!pmap_valid_page(ppn) || pmap_is_noencrypt(ppn))) ppn = 0;
        <span class="enscript-keyword">if</span> (!ppn) <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">for</span> (ptrIdx = 0; ptrIdx &lt; (page_size / <span class="enscript-keyword">sizeof</span>(uintptr_t)); ptrIdx++)
        {
            ptr = ((uintptr_t *)vaddr)[ptrIdx];

            <span class="enscript-keyword">for</span> (lim = count, baseIdx = 0; lim; lim &gt;&gt;= 1)
            {
                inst = instances[baseIdx + (lim &gt;&gt; 1)];
                instance = (typeof(instance)) (inst &amp; ~kInstanceFlags);
                <span class="enscript-keyword">if</span> (kInstanceFlagAddress &amp; inst)
                {
                    addr = ~((IOTrackingAddress *)instance)-&gt;address;
                    size = ((IOTrackingAddress *)instance)-&gt;size;
                }
                <span class="enscript-keyword">else</span>
                {
                    addr = (uintptr_t) (instance + 1);
                    size = instance-&gt;site-&gt;queue-&gt;allocSize;
                }
                <span class="enscript-keyword">if</span> ((ptr &gt;= addr) &amp;&amp; (ptr &lt; (addr + size)))
                {
                    <span class="enscript-keyword">if</span> (!(kInstanceFlagReferenced &amp; inst))
                    {
                        inst |= kInstanceFlagReferenced;
                        instances[baseIdx + (lim &gt;&gt; 1)] = inst;
                        ref-&gt;found++;
                    }
                    <span class="enscript-keyword">break</span>;
                }
                <span class="enscript-keyword">if</span> (ptr &gt; addr) 
                {       
                    <span class="enscript-comment">// move right
</span>                    baseIdx += (lim &gt;&gt; 1) + 1;
                    lim--;
                }
                <span class="enscript-comment">// else move left
</span>            }
        }
        ref-&gt;bytes += page_size;    
    }
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> OSData *
<span class="enscript-function-name">IOTrackingLeaks</span>(OSData * data)
{
    IOTrackingLeaksRef       ref;
    IOTrackingCallSiteInfo   unslideInfo;
    IOTrackingCallSite     * site;
    OSData                 * leakData;
    uintptr_t              * instances;
    IOTracking             * instance;
    uintptr_t                inst;
    uint32_t                 count, idx, numSites, dups, siteCount;

    instances = (typeof(instances)) data-&gt;getBytesNoCopy();
    count = (data-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(*instances));
    qsort(instances, count, <span class="enscript-keyword">sizeof</span>(*instances), &amp;IOTrackingAddressCompare);
    
    bzero(&amp;ref, <span class="enscript-keyword">sizeof</span>(ref));
    ref.instances = instances;
    ref.count = count;

    IOTrackingLeakScan(&amp;ref);
    
    IOLog(<span class="enscript-string">&quot;leaks scanned %ld MB, instance count %d, found %d\n&quot;</span>, ref.bytes / 1024 / 1024, count, ref.found);

    leakData = OSData::withCapacity(128 * <span class="enscript-keyword">sizeof</span>(IOTrackingCallSiteInfo));

    <span class="enscript-keyword">for</span> (numSites = 0, idx = 0; idx &lt; count; idx++)
    {
        inst = instances[idx];
        <span class="enscript-keyword">if</span> (kInstanceFlagReferenced &amp; inst) <span class="enscript-keyword">continue</span>;
        instance = (typeof(instance)) (inst &amp; ~kInstanceFlags);
        site = instance-&gt;site;
	instances[numSites] = (uintptr_t) site;
	numSites++;
    }

    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; numSites; idx++)
    {
        inst = instances[idx];
        <span class="enscript-keyword">if</span> (!inst) <span class="enscript-keyword">continue</span>;
        site = (typeof(site)) inst;
	<span class="enscript-keyword">for</span> (siteCount = 1, dups = (idx + 1); dups &lt; numSites; dups++)
	{
	    <span class="enscript-keyword">if</span> (instances[dups] == (uintptr_t) site)
	    {
		siteCount++;
		instances[dups] = 0;
	    }
	}
        unslideInfo.count   = siteCount;
        unslideInfo.size[0] = (site-&gt;info.size[0] * site-&gt;info.count) / siteCount;
        unslideInfo.size[1] = (site-&gt;info.size[1] * site-&gt;info.count) / siteCount;;
        <span class="enscript-keyword">for</span> (uint32_t j = 0; j &lt; kIOTrackingCallSiteBTs; j++)
        {
            unslideInfo.bt[j] = VM_KERNEL_UNSLIDE(site-&gt;info.bt[j]);
        }
        leakData-&gt;appendBytes(&amp;unslideInfo, <span class="enscript-keyword">sizeof</span>(unslideInfo));
    }
    data-&gt;release();

    <span class="enscript-keyword">return</span> (leakData);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> <span class="enscript-type">bool</span>
<span class="enscript-function-name">SkipName</span>(uint32_t options, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, size_t namesLen, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * names)
{
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * scan;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * next;
    <span class="enscript-type">bool</span>         exclude, found;
    size_t       qLen, sLen;

    <span class="enscript-keyword">if</span> (!namesLen || !names) <span class="enscript-keyword">return</span> (false);
    <span class="enscript-comment">// &lt;len&gt;&lt;name&gt;...&lt;len&gt;&lt;name&gt;&lt;0&gt;
</span>    exclude = (0 != (kIOTrackingExcludeNames &amp; options));
    qLen    = strlen(name);
    scan    = names;
    found   = false;
    <span class="enscript-keyword">do</span>
    {
        sLen = scan[0];
        scan++;
        next = scan + sLen;
        <span class="enscript-keyword">if</span> (next &gt;= (names + namesLen)) <span class="enscript-keyword">break</span>;
        found = ((sLen == qLen) &amp;&amp; !strncmp(scan, name, sLen));
        scan = next;
    }
    <span class="enscript-keyword">while</span> (!found &amp;&amp; (scan &lt; (names + namesLen)));

    <span class="enscript-keyword">return</span> (!(exclude ^ found));
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOTRACKING */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

kern_return_t
<span class="enscript-function-name">IOTrackingDebug</span>(uint32_t selector, uint32_t options,
                <span class="enscript-type">const</span> <span class="enscript-type">char</span> * names, size_t namesLen, 
                size_t size, OSObject ** result)
{
    kern_return_t            ret;
    OSData                 * data;

    <span class="enscript-keyword">if</span> (result) *result = 0;
    data = 0;
    ret = kIOReturnNotReady;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOTRACKING</span>

    IOTrackingQueue        * queue;
    IOTracking             * instance;
    IOTrackingCallSite     * site;
    IOTrackingCallSiteInfo * siteInfos;
    IOTrackingCallSiteInfo * siteInfo;
    <span class="enscript-type">bool</span>                     addresses;
    uint32_t                 num, idx;
    uintptr_t                instFlags;

    <span class="enscript-keyword">if</span> (!(kIOTracking &amp; gIOKitDebug)) <span class="enscript-keyword">return</span> (kIOReturnNotReady);
    ret = kIOReturnNotFound;

    lck_mtx_lock(gIOTrackingLock);
    queue_iterate(&amp;gIOTrackingQ, queue, IOTrackingQueue *, link)
    {
        <span class="enscript-keyword">if</span> (SkipName(options, queue-&gt;name, namesLen, names)) <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">switch</span> (selector)
        {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingResetTracking</span>:
            {
                IOTrackingReset(queue);
                ret = kIOReturnSuccess;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingStartCapture</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingStopCapture</span>:
            {
                queue-&gt;captureOn = (kIOTrackingStartCapture == selector);
                ret = kIOReturnSuccess;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingSetMinCaptureSize</span>:
            {
                queue-&gt;minCaptureSize = size;
                ret = kIOReturnSuccess;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingLeaks</span>:
            {
                <span class="enscript-keyword">if</span> (!queue-&gt;isAlloc) <span class="enscript-keyword">break</span>;

                <span class="enscript-keyword">if</span> (!data) data = OSData::withCapacity(1024 * <span class="enscript-keyword">sizeof</span>(uintptr_t));

                IOTRecursiveLockLock(&amp;queue-&gt;lock);
                queue_iterate(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link)
                {
                    addresses = false;
                    queue_iterate(&amp;site-&gt;instances, instance, IOTracking *, link)
                    {
                        <span class="enscript-keyword">if</span> (instance == site-&gt;addresses) addresses = true;
                        instFlags = (typeof(instFlags)) instance; 
                        <span class="enscript-keyword">if</span> (addresses) instFlags |= kInstanceFlagAddress;
                        data-&gt;appendBytes(&amp;instFlags, <span class="enscript-keyword">sizeof</span>(instFlags));
                    }
                }
                <span class="enscript-comment">// queue is locked
</span>                ret = kIOReturnSuccess;
                <span class="enscript-keyword">break</span>;
            }

            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingGetTracking</span>:
            <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOTrackingPrintTracking</span>:
            {
                <span class="enscript-keyword">if</span> (!data) data = OSData::withCapacity(128 * <span class="enscript-keyword">sizeof</span>(IOTrackingCallSiteInfo));

                IOTRecursiveLockLock(&amp;queue-&gt;lock);
                num = queue-&gt;siteCount;
                idx = 0;
                queue_iterate(&amp;queue-&gt;sites, site, IOTrackingCallSite *, link)
                {
                    assert(idx &lt; num);
                    idx++;

                    <span class="enscript-keyword">if</span> (size &amp;&amp; ((site-&gt;info.size[0] + site-&gt;info.size[1]) &lt; size)) <span class="enscript-keyword">continue</span>;

                    IOTrackingCallSiteInfo unslideInfo;
                    unslideInfo.count = site-&gt;info.count;
                    memcpy(&amp;unslideInfo.size[0], &amp;site-&gt;info.size[0], <span class="enscript-keyword">sizeof</span>(unslideInfo.size));

                    <span class="enscript-keyword">for</span> (uint32_t j = 0; j &lt; kIOTrackingCallSiteBTs; j++)
                    {
                        unslideInfo.bt[j] = VM_KERNEL_UNSLIDE(site-&gt;info.bt[j]);
                    }
                    data-&gt;appendBytes(&amp;unslideInfo, <span class="enscript-keyword">sizeof</span>(unslideInfo));
                }
                assert(idx == num);
                IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
                ret = kIOReturnSuccess;
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-reference">default</span>:
                ret = kIOReturnUnsupported;
                <span class="enscript-keyword">break</span>;
        }
    }

    <span class="enscript-keyword">if</span> ((kIOTrackingLeaks == selector) &amp;&amp; data)
    {
        data = IOTrackingLeaks(data);
        queue_iterate(&amp;gIOTrackingQ, queue, IOTrackingQueue *, link)
        {
            <span class="enscript-keyword">if</span> (SkipName(options, queue-&gt;name, namesLen, names)) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (!queue-&gt;isAlloc)                                 <span class="enscript-keyword">continue</span>;
            IOTRecursiveLockUnlock(&amp;queue-&gt;lock);
        }
    }

    lck_mtx_unlock(gIOTrackingLock);

    <span class="enscript-keyword">if</span> (data)
    {
        siteInfos = (typeof(siteInfos)) data-&gt;getBytesNoCopy();
        num = (data-&gt;getLength() / <span class="enscript-keyword">sizeof</span>(IOTrackingCallSiteInfo));
        qsort(siteInfos, num, <span class="enscript-keyword">sizeof</span>(*siteInfos), &amp;IOTrackingCallSiteInfoCompare);

        <span class="enscript-keyword">if</span> (kIOTrackingPrintTracking == selector)
        {
            <span class="enscript-keyword">for</span> (idx = 0; idx &lt; num; idx++)
            {
                siteInfo = &amp;siteInfos[idx];
                printf(<span class="enscript-string">&quot;\n0x%lx bytes (0x%lx + 0x%lx), %d call%s, [%d]\n&quot;</span>,
                    siteInfo-&gt;size[0] + siteInfo-&gt;size[1], 
                    siteInfo-&gt;size[0], siteInfo-&gt;size[1], 
                    siteInfo-&gt;count, (siteInfo-&gt;count != 1) ? <span class="enscript-string">&quot;s&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, idx);
                uintptr_t * bt = &amp;siteInfo-&gt;bt[0];
                printf(<span class="enscript-string">&quot;      Backtrace 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\n&quot;</span>, 
                        bt[0], bt[1], bt[2], bt[3], bt[4], bt[5], bt[6], bt[7], 
                        bt[8], bt[9], bt[10], bt[11], bt[12], bt[13], bt[14], bt[15]);
                kmod_dump_log((vm_offset_t *) &amp;bt[0], kIOTrackingCallSiteBTs, FALSE);
            }
            data-&gt;release();
            data = 0;
        }
    }

    *result = data;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOTRACKING */</span>

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDiagnosticsUserClient.h&gt;</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOUserClient

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOKitDiagnosticsClient, IOUserClient)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

IOUserClient * <span class="enscript-function-name">IOKitDiagnosticsClient::withTask</span>(task_t owningTask)
{
    IOKitDiagnosticsClient * inst;

    inst = <span class="enscript-keyword">new</span> IOKitDiagnosticsClient;
    <span class="enscript-keyword">if</span> (inst &amp;&amp; !inst-&gt;init())
    {
        inst-&gt;release();
        inst = 0;
    }

    <span class="enscript-keyword">return</span> (inst);
}

IOReturn <span class="enscript-function-name">IOKitDiagnosticsClient::clientClose</span>(<span class="enscript-type">void</span>)
{
    terminate();
    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

IOReturn <span class="enscript-function-name">IOKitDiagnosticsClient::setProperties</span>(OSObject * properties)
{
    IOReturn kr = kIOReturnUnsupported;
    <span class="enscript-keyword">return</span> (kr);
}

IOReturn <span class="enscript-function-name">IOKitDiagnosticsClient::externalMethod</span>(uint32_t selector, IOExternalMethodArguments * args,
                                                IOExternalMethodDispatch * dispatch, OSObject * target, <span class="enscript-type">void</span> * reference)
{
    IOReturn                           ret = kIOReturnBadArgument;
    <span class="enscript-type">const</span> IOKitDiagnosticsParameters * params;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * names;
    size_t       namesLen;
    OSObject   * result;

    <span class="enscript-keyword">if</span> (args-&gt;structureInputSize &lt; <span class="enscript-keyword">sizeof</span>(IOKitDiagnosticsParameters)) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);
    params = (typeof(params)) args-&gt;structureInput;
    <span class="enscript-keyword">if</span> (!params) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    names = 0;
    namesLen = args-&gt;structureInputSize - <span class="enscript-keyword">sizeof</span>(IOKitDiagnosticsParameters);
    <span class="enscript-keyword">if</span> (namesLen) names = (typeof(names))(params + 1);

    ret = IOTrackingDebug(selector, params-&gt;options, names, namesLen, params-&gt;size, &amp;result);

    <span class="enscript-keyword">if</span> ((kIOReturnSuccess == ret) &amp;&amp; args-&gt;structureVariableOutputData) *args-&gt;structureVariableOutputData = result;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result) result-&gt;release();

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
</pre>
<hr />
</body></html>