<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOCatalogue.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOCatalogue.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1998 Apple Inc.  All rights reserved. 
 *
 * HISTORY
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_data.h&gt;</span>
};

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSContainers.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSUnserialize.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSKextLibPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODeviceTreeSupport.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Internal</span> <span class="enscript-variable-name">Declarations</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>

IOCatalogue    * gIOCatalogue;
<span class="enscript-type">const</span> OSSymbol * gIOClassKey;
<span class="enscript-type">const</span> OSSymbol * gIOProbeScoreKey;
<span class="enscript-type">const</span> OSSymbol * gIOModuleIdentifierKey;
IORWLock         * gIOCatalogLock;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Utility</span> <span class="enscript-variable-name">functions</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">IOCatalogue</span> <span class="enscript-variable-name">class</span> <span class="enscript-variable-name">implementation</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOCatalogue, OSObject)

<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">isModuleLoadedNoOSKextLock</span>(OSDictionary *theKexts,
                                       OSDictionary *theModuleDict);


<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::initialize</span>(<span class="enscript-type">void</span>)
{
    OSArray              * array;
    OSString             * errorString;
    <span class="enscript-type">bool</span>		   rc;

    <span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * gIOKernelConfigTables;

    array = OSDynamicCast(OSArray, OSUnserialize(gIOKernelConfigTables, &amp;errorString));
    <span class="enscript-keyword">if</span> (!array &amp;&amp; errorString) {
        IOLog(<span class="enscript-string">&quot;KernelConfigTables syntax error: %s\n&quot;</span>,
            errorString-&gt;getCStringNoCopy());
        errorString-&gt;release();
    }

    gIOClassKey              = OSSymbol::withCStringNoCopy( kIOClassKey );
    gIOProbeScoreKey 	     = OSSymbol::withCStringNoCopy( kIOProbeScoreKey );
    gIOModuleIdentifierKey   = OSSymbol::withCStringNoCopy( kCFBundleIdentifierKey );

    assert( array &amp;&amp; gIOClassKey &amp;&amp; gIOProbeScoreKey 
	    &amp;&amp; gIOModuleIdentifierKey);

    gIOCatalogue = <span class="enscript-keyword">new</span> IOCatalogue;
    assert(gIOCatalogue);
    rc = gIOCatalogue-&gt;init(array);
    assert(rc);
    array-&gt;release();
}

<span class="enscript-comment">/*********************************************************************
* Initialize the IOCatalog object.
*********************************************************************/</span>
OSArray * <span class="enscript-function-name">IOCatalogue::arrayForPersonality</span>(OSDictionary * dict)
{
    <span class="enscript-type">const</span> OSSymbol * sym;

    sym = OSDynamicCast(OSSymbol, dict-&gt;getObject(gIOProviderClassKey));
    <span class="enscript-keyword">if</span> (!sym) 	<span class="enscript-keyword">return</span> (0);

    <span class="enscript-keyword">return</span> ((OSArray *) personalities-&gt;getObject(sym));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::addPersonality</span>(OSDictionary * dict)
{
    <span class="enscript-type">const</span> OSSymbol * sym;
    OSArray * arr;

    sym = OSDynamicCast(OSSymbol, dict-&gt;getObject(gIOProviderClassKey));
    <span class="enscript-keyword">if</span> (!sym) <span class="enscript-keyword">return</span>;
    arr = (OSArray *) personalities-&gt;getObject(sym);
    <span class="enscript-keyword">if</span> (arr) arr-&gt;setObject(dict);
    <span class="enscript-keyword">else</span>
    {
        arr = OSArray::withObjects((<span class="enscript-type">const</span> OSObject **)&amp;dict, 1, 2);
        personalities-&gt;setObject(sym, arr);
        arr-&gt;release();
    }
}

<span class="enscript-comment">/*********************************************************************
* Initialize the IOCatalog object.
*********************************************************************/</span>
<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::init</span>(OSArray * initArray)
{
    OSDictionary         * dict;
    OSObject * obj;

    <span class="enscript-keyword">if</span> ( !super::init() )
        <span class="enscript-keyword">return</span> false;

    generation = 1;
    
    personalities = OSDictionary::withCapacity(32);
    personalities-&gt;setOptions(OSCollection::kSort, OSCollection::kSort);
    <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx = 0; (obj = initArray-&gt;getObject(idx)); idx++)
    {
	dict = OSDynamicCast(OSDictionary, obj);
	<span class="enscript-keyword">if</span> (!dict) <span class="enscript-keyword">continue</span>;
	<span class="enscript-reference">OSKext</span>::uniquePersonalityProperties(dict);
        <span class="enscript-keyword">if</span>( 0 == dict-&gt;getObject( gIOClassKey ))
        {
            IOLog(<span class="enscript-string">&quot;Missing or bad \&quot;%s\&quot; key\n&quot;</span>,
                    gIOClassKey-&gt;getCStringNoCopy());
	    <span class="enscript-keyword">continue</span>;
	}
	dict-&gt;setObject(<span class="enscript-string">&quot;KernelConfigTable&quot;</span>, kOSBooleanTrue);
        addPersonality(dict);
    }

    gIOCatalogLock = IORWLockAlloc();
    lock = gIOCatalogLock;

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">/*********************************************************************
* Release all resources used by IOCatalogue and deallocate.
* This will probably never be called.
*********************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::free</span>( <span class="enscript-type">void</span> )
{
    panic(<span class="enscript-string">&quot;&quot;</span>);
}

<span class="enscript-comment">/*********************************************************************
*********************************************************************/</span>
OSOrderedSet *
<span class="enscript-function-name">IOCatalogue::findDrivers</span>(
    IOService * service,
    SInt32 * generationCount)
{
    OSDictionary         * nextTable;
    OSOrderedSet         * set;
    OSArray              * array;
    <span class="enscript-type">const</span> OSMetaClass    * meta;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           idx;

    set = OSOrderedSet::withCapacity( 1, IOServiceOrdering,
                                      (<span class="enscript-type">void</span> *)gIOProbeScoreKey );
    <span class="enscript-keyword">if</span>( !set )
	<span class="enscript-keyword">return</span>( 0 );

    IORWLockRead(lock);

    meta = service-&gt;getMetaClass();
    <span class="enscript-keyword">while</span> (meta)
    {
    	array = (OSArray *) personalities-&gt;getObject(meta-&gt;getClassNameSymbol());
	<span class="enscript-keyword">if</span> (array) <span class="enscript-keyword">for</span> (idx = 0; (nextTable = (OSDictionary *) array-&gt;getObject(idx)); idx++)
	{
            set-&gt;setObject(nextTable);
	}
	<span class="enscript-keyword">if</span> (meta == &amp;IOService::gMetaClass) <span class="enscript-keyword">break</span>;
	meta = meta-&gt;getSuperClass();
    }

    *generationCount = getGenerationCount();

    IORWLockUnlock(lock);

    <span class="enscript-keyword">return</span>( set );
}

<span class="enscript-comment">/*********************************************************************
* Is personality already in the catalog?
*********************************************************************/</span>
OSOrderedSet *
<span class="enscript-function-name">IOCatalogue::findDrivers</span>(
    OSDictionary * matching,
    SInt32 * generationCount)
{
    OSCollectionIterator * iter;
    OSDictionary         * dict;
    OSOrderedSet         * set;
    OSArray              * array;
    <span class="enscript-type">const</span> OSSymbol       * key;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           idx;

    <span class="enscript-reference">OSKext</span>::uniquePersonalityProperties(matching);

    set = OSOrderedSet::withCapacity( 1, IOServiceOrdering,
                                      (<span class="enscript-type">void</span> *)gIOProbeScoreKey );
    <span class="enscript-keyword">if</span> (!set) <span class="enscript-keyword">return</span> (0);
    iter = OSCollectionIterator::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!iter) 
    {
    	set-&gt;release();
    	<span class="enscript-keyword">return</span> (0);
    }

    IORWLockRead(lock);
    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
    {
        array = (OSArray *) personalities-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (array) <span class="enscript-keyword">for</span> (idx = 0; (dict = (OSDictionary *) array-&gt;getObject(idx)); idx++)
        {
	   <span class="enscript-comment">/* This comparison must be done with only the keys in the
	    * &quot;matching&quot; dict to enable general searches.
	    */</span>
	    <span class="enscript-keyword">if</span> ( dict-&gt;isEqualTo(matching, matching) )
		set-&gt;setObject(dict);
	}
    }
    *generationCount = getGenerationCount();
    IORWLockUnlock(lock);

    iter-&gt;release();
    <span class="enscript-keyword">return</span> set;
}

<span class="enscript-comment">/*********************************************************************
* Add driver config tables to catalog and start matching process.
*
* Important that existing personalities are kept (not replaced)
* if duplicates found. Personalities can come from OSKext objects
* or from userland kext library. We want to minimize distinct
* copies between OSKext &amp; IOCatalogue.
*
* xxx - userlib used to refuse to send personalities with IOKitDebug
* xxx - during safe boot. That would be better implemented here.
*********************************************************************/</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::addDrivers</span>(
    OSArray * drivers,
    <span class="enscript-type">bool</span> doNubMatching)
{
    <span class="enscript-type">bool</span>                   result = false;
    OSCollectionIterator * iter = NULL;       <span class="enscript-comment">// must release
</span>    OSOrderedSet         * set = NULL;        <span class="enscript-comment">// must release
</span>    OSObject             * object = NULL;       <span class="enscript-comment">// do not release
</span>    OSArray              * persons = NULL;    <span class="enscript-comment">// do not release
</span>    
    persons = OSDynamicCast(OSArray, drivers);
    <span class="enscript-keyword">if</span> (!persons) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    set = OSOrderedSet::withCapacity( 10, IOServiceOrdering,
        (<span class="enscript-type">void</span> *)gIOProbeScoreKey );
    <span class="enscript-keyword">if</span> (!set) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    iter = OSCollectionIterator::withCollection(persons);
    <span class="enscript-keyword">if</span> (!iter) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

   <span class="enscript-comment">/* Start with success; clear it on an error.
    */</span>
    result = true;

    IORWLockWrite(lock);
    <span class="enscript-keyword">while</span> ( (object = iter-&gt;getNextObject()) ) {
    
        <span class="enscript-comment">// xxx Deleted OSBundleModuleDemand check; will handle in other ways for SL
</span>
        OSDictionary * personality = OSDynamicCast(OSDictionary, object);

        SInt count;

        <span class="enscript-keyword">if</span> (!personality) {
            IOLog(<span class="enscript-string">&quot;IOCatalogue::addDrivers() encountered non-dictionary; bailing.\n&quot;</span>);
            result = false;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-reference">OSKext</span>::uniquePersonalityProperties(personality);

        <span class="enscript-comment">// Add driver personality to catalogue.
</span>
	OSArray * array = arrayForPersonality(personality);
	<span class="enscript-keyword">if</span> (!array) addPersonality(personality);
	<span class="enscript-keyword">else</span>
	{       
	    count = array-&gt;getCount();
	    <span class="enscript-keyword">while</span> (count--) {
		OSDictionary * driver;
		
		<span class="enscript-comment">// Be sure not to double up on personalities.
</span>		driver = (OSDictionary *)array-&gt;getObject(count);
		
	       <span class="enscript-comment">/* Unlike in other functions, this comparison must be exact!
		* The catalogue must be able to contain personalities that
		* are proper supersets of others.
		* Do not compare just the properties present in one driver
		* personality or the other.
		*/</span>
		<span class="enscript-keyword">if</span> (personality-&gt;isEqualTo(driver)) {
		    <span class="enscript-keyword">break</span>;
		}
	    }
	    <span class="enscript-keyword">if</span> (count &gt;= 0) {
		<span class="enscript-comment">// its a dup
</span>		<span class="enscript-keyword">continue</span>;
	    }
	    result = array-&gt;setObject(personality);
	    <span class="enscript-keyword">if</span> (!result) {
		<span class="enscript-keyword">break</span>;
	    }
        }

	set-&gt;setObject(personality);        
    }
    <span class="enscript-comment">// Start device matching.
</span>    <span class="enscript-keyword">if</span> (result &amp;&amp; doNubMatching &amp;&amp; (set-&gt;getCount() &gt; 0)) {
        <span class="enscript-reference">IOService</span>::catalogNewDrivers(set);
        generation++;
    }
    IORWLockUnlock(lock);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (set)  set-&gt;release();
    <span class="enscript-keyword">if</span> (iter) iter-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*********************************************************************
* Remove drivers from the catalog which match the
* properties in the matching dictionary.
*********************************************************************/</span>
<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOCatalogue::removeDrivers</span>(
    OSDictionary * matching,
    <span class="enscript-type">bool</span> doNubMatching)
{
    OSOrderedSet         * set;
    OSCollectionIterator * iter;
    OSDictionary         * dict;
    OSArray              * array;
    <span class="enscript-type">const</span> OSSymbol       * key;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           idx;

    <span class="enscript-keyword">if</span> ( !matching )
        <span class="enscript-keyword">return</span> false;
    
    set = OSOrderedSet::withCapacity(10,
                                     IOServiceOrdering,
                                     (<span class="enscript-type">void</span> *)gIOProbeScoreKey);
    <span class="enscript-keyword">if</span> ( !set )
        <span class="enscript-keyword">return</span> false;
    iter = OSCollectionIterator::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!iter) 
    {
    	set-&gt;release();
    	<span class="enscript-keyword">return</span> (false);
    }

    IORWLockWrite(lock);
    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
    {
        array = (OSArray *) personalities-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (array) <span class="enscript-keyword">for</span> (idx = 0; (dict = (OSDictionary *) array-&gt;getObject(idx)); idx++)
        {
           <span class="enscript-comment">/* This comparison must be done with only the keys in the
            * &quot;matching&quot; dict to enable general searches.
            */</span>
            <span class="enscript-keyword">if</span> ( dict-&gt;isEqualTo(matching, matching) ) {
                set-&gt;setObject(dict);        
                array-&gt;removeObject(idx);
                idx--;
            }
        }
        <span class="enscript-comment">// Start device matching.
</span>        <span class="enscript-keyword">if</span> ( doNubMatching &amp;&amp; (set-&gt;getCount() &gt; 0) ) {
            <span class="enscript-reference">IOService</span>::catalogNewDrivers(set);
            generation++;
        }
    }
    IORWLockUnlock(lock);
   
    set-&gt;release();
    iter-&gt;release();
    
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">// Return the generation count.
</span>SInt32 <span class="enscript-function-name">IOCatalogue::getGenerationCount</span>(<span class="enscript-type">void</span>) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span>( generation );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::isModuleLoaded</span>(OSString * moduleName) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span> isModuleLoaded(moduleName-&gt;getCStringNoCopy());
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::isModuleLoaded</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * moduleName) <span class="enscript-type">const</span>
{
    OSReturn ret;
    ret = OSKext::loadKextWithIdentifier(moduleName);
    <span class="enscript-keyword">if</span> (kOSKextReturnDeferred == ret) {
        <span class="enscript-comment">// a request has been queued but the module isn't necessarily 
</span>        <span class="enscript-comment">// loaded yet, so stall.
</span>        <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-comment">// module is present or never will be 
</span>    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">// Check to see if module has been loaded already.
</span><span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::isModuleLoaded</span>(OSDictionary * driver) <span class="enscript-type">const</span>
{
    OSString             * moduleName = NULL;
    OSString             * publisherName = NULL;

    <span class="enscript-keyword">if</span> ( !driver )
        <span class="enscript-keyword">return</span> false;

    <span class="enscript-comment">/* The personalities of codeless kexts often contain the bundle ID of the
     * kext they reference, and not the bundle ID of the codeless kext itself.
     * The prelinked kernel needs to know the bundle ID of the codeless kext
     * so it can include these personalities, so OSKext stores that bundle ID
     * in the IOPersonalityPublisher key, and we record it as requested here.
     */</span>
    publisherName = OSDynamicCast(OSString, 
        driver-&gt;getObject(kIOPersonalityPublisherKey));
    <span class="enscript-reference">OSKext</span>::recordIdentifierRequest(publisherName);

    moduleName = OSDynamicCast(OSString, driver-&gt;getObject(gIOModuleIdentifierKey));
    <span class="enscript-keyword">if</span> ( moduleName )
        <span class="enscript-keyword">return</span> isModuleLoaded(moduleName);

   <span class="enscript-comment">/* If a personality doesn't hold the &quot;CFBundleIdentifier&quot; key
    * it is assumed to be an &quot;in-kernel&quot; driver.
    */</span>
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-comment">/* This function is called after a module has been loaded.
 * Is invoked from user client call, ultimately from IOKitLib's
 * IOCatalogueModuleLoaded(). Sent from kextd.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::moduleHasLoaded</span>(OSString * moduleName)
{
    OSDictionary * dict;

    dict = OSDictionary::withCapacity(2);
    dict-&gt;setObject(gIOModuleIdentifierKey, moduleName);
    startMatching(dict);
    dict-&gt;release();

    (<span class="enscript-type">void</span>) OSKext::setDeferredLoadSucceeded();
    (<span class="enscript-type">void</span>) OSKext::considerRebuildOfPrelinkedKernel();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::moduleHasLoaded</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * moduleName)
{
    OSString * name;

    name = OSString::withCString(moduleName);
    moduleHasLoaded(name);
    name-&gt;release();
}

<span class="enscript-comment">// xxx - return is really OSReturn/kern_return_t
</span>IOReturn <span class="enscript-function-name">IOCatalogue::unloadModule</span>(OSString * moduleName) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">return</span> OSKext::removeKextWithIdentifier(moduleName-&gt;getCStringNoCopy());
}

IOReturn <span class="enscript-function-name">IOCatalogue::_terminateDrivers</span>(OSDictionary * matching)
{
    OSDictionary         * dict;
    OSIterator           * iter;
    IOService            * service;
    IOReturn               ret;

    <span class="enscript-keyword">if</span> ( !matching )
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    ret = kIOReturnSuccess;
    dict = 0;
    iter = IORegistryIterator::iterateOver(gIOServicePlane,
                                kIORegistryIterateRecursively);
    <span class="enscript-keyword">if</span> ( !iter )
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    <span class="enscript-reference">OSKext</span>::uniquePersonalityProperties( matching );

    <span class="enscript-comment">// terminate instances.
</span>    <span class="enscript-keyword">do</span> {
        iter-&gt;reset();
        <span class="enscript-keyword">while</span>( (service = (IOService *)iter-&gt;getNextObject()) ) {
            dict = service-&gt;getPropertyTable();
            <span class="enscript-keyword">if</span> ( !dict )
                <span class="enscript-keyword">continue</span>;

           <span class="enscript-comment">/* Terminate only for personalities that match the matching dictionary.
            * This comparison must be done with only the keys in the
            * &quot;matching&quot; dict to enable general matching.
            */</span>
            <span class="enscript-keyword">if</span> ( !dict-&gt;isEqualTo(matching, matching) )
                 <span class="enscript-keyword">continue</span>;

            <span class="enscript-keyword">if</span> ( !service-&gt;terminate(kIOServiceRequired|kIOServiceSynchronous) ) {
                ret = kIOReturnUnsupported;
                <span class="enscript-keyword">break</span>;
            }
        }
    } <span class="enscript-keyword">while</span>( !service &amp;&amp; !iter-&gt;isValid());
    iter-&gt;release();

    <span class="enscript-keyword">return</span> ret;
}

IOReturn <span class="enscript-function-name">IOCatalogue::_removeDrivers</span>(OSDictionary * matching)
{
    IOReturn               ret = kIOReturnSuccess;
    OSCollectionIterator * iter;
    OSDictionary         * dict;
    OSArray              * array;
    <span class="enscript-type">const</span> OSSymbol       * key;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           idx;

    <span class="enscript-comment">// remove configs from catalog.
</span>
    iter = OSCollectionIterator::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!iter) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
    {
        array = (OSArray *) personalities-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (array) <span class="enscript-keyword">for</span> (idx = 0; (dict = (OSDictionary *) array-&gt;getObject(idx)); idx++)
        {

	    <span class="enscript-comment">/* Remove from the catalogue's array any personalities
	     * that match the matching dictionary.
	     * This comparison must be done with only the keys in the
	     * &quot;matching&quot; dict to enable general matching.
	     */</span>
            <span class="enscript-keyword">if</span> (dict-&gt;isEqualTo(matching, matching))
            {
                array-&gt;removeObject(idx);
                idx--;
            }
        }
    }
    iter-&gt;release();

    <span class="enscript-keyword">return</span> ret;
}

IOReturn <span class="enscript-function-name">IOCatalogue::terminateDrivers</span>(OSDictionary * matching)
{
    IOReturn ret;

    ret = _terminateDrivers(matching);
    IORWLockWrite(lock);
    <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
	ret = _removeDrivers(matching);
    IORWLockUnlock(lock);

    <span class="enscript-keyword">return</span> ret;
}

IOReturn <span class="enscript-function-name">IOCatalogue::terminateDriversForModule</span>(
    OSString * moduleName,
    <span class="enscript-type">bool</span> unload)
{
    IOReturn ret;
    OSDictionary * dict;
    <span class="enscript-type">bool</span> isLoaded = false;

   <span class="enscript-comment">/* Check first if the kext currently has any linkage dependents;
    * in such a case the unload would fail so let's not terminate any
    * IOServices (since doing so typically results in a panic when there
    * are loaded dependencies). Note that we aren't locking the kext here
    * so it might lose or gain dependents by the time we call unloadModule();
    * I think that's ok, our unload can fail if a kext comes in on top of
    * this one even after we've torn down IOService objects. Conversely,
    * if we fail the unload here and then lose a library, the autounload
    * thread will get us in short order.
    */</span>
    <span class="enscript-keyword">if</span> (OSKext::isKextWithIdentifierLoaded(moduleName-&gt;getCStringNoCopy())) {
    
        isLoaded = true;

        <span class="enscript-keyword">if</span> (!OSKext::canUnloadKextWithIdentifier(moduleName,
            <span class="enscript-comment">/* checkClasses */</span> false)) {
            ret = kOSKextReturnInUse;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    dict = OSDictionary::withCapacity(1);
    <span class="enscript-keyword">if</span> (!dict) {
        ret = kIOReturnNoMemory;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    dict-&gt;setObject(gIOModuleIdentifierKey, moduleName);

    ret = _terminateDrivers(dict);
    
   <span class="enscript-comment">/* No goto between IOLock calls!
    */</span>
    IORWLockWrite(lock);
    <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret) {
        ret = _removeDrivers(dict);
    }

    <span class="enscript-comment">// Unload the module itself.
</span>    <span class="enscript-keyword">if</span> (unload &amp;&amp; isLoaded &amp;&amp; ret == kIOReturnSuccess) {
        ret = unloadModule(moduleName);
    }

    IORWLockUnlock(lock);

    dict-&gt;release();

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> ret;
}

IOReturn <span class="enscript-function-name">IOCatalogue::terminateDriversForModule</span>(
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * moduleName,
    <span class="enscript-type">bool</span> unload)
{
    OSString * name;
    IOReturn ret;

    name = OSString::withCString(moduleName);
    <span class="enscript-keyword">if</span> ( !name )
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    ret = terminateDriversForModule(name, unload);
    name-&gt;release();

    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::startMatching</span>( OSDictionary * matching )
{
    OSCollectionIterator * iter;
    OSDictionary         * dict;
    OSOrderedSet         * set;
    OSArray              * array;
    <span class="enscript-type">const</span> OSSymbol *       key;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>           idx;
    
    <span class="enscript-keyword">if</span> ( !matching )
        <span class="enscript-keyword">return</span> false;

    set = OSOrderedSet::withCapacity(10, IOServiceOrdering,
                                     (<span class="enscript-type">void</span> *)gIOProbeScoreKey);
    <span class="enscript-keyword">if</span> ( !set )
        <span class="enscript-keyword">return</span> false;

    iter = OSCollectionIterator::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!iter) 
    {
    	set-&gt;release();
        <span class="enscript-keyword">return</span> false;
    }

    IORWLockRead(lock);

    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
    {
        array = (OSArray *) personalities-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (array) <span class="enscript-keyword">for</span> (idx = 0; (dict = (OSDictionary *) array-&gt;getObject(idx)); idx++)
        {
	   <span class="enscript-comment">/* This comparison must be done with only the keys in the
	    * &quot;matching&quot; dict to enable general matching.
	    */</span>
            <span class="enscript-keyword">if</span> (dict-&gt;isEqualTo(matching, matching)) {
                set-&gt;setObject(dict);
            }        
        }
    }

    <span class="enscript-comment">// Start device matching.
</span>    <span class="enscript-keyword">if</span> ( set-&gt;getCount() &gt; 0 ) {
        <span class="enscript-reference">IOService</span>::catalogNewDrivers(set);
        generation++;
    }

    IORWLockUnlock(lock);

    set-&gt;release();
    iter-&gt;release();

    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOCatalogue::reset</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-reference">IOCatalogue</span>::resetAndAddDrivers(<span class="enscript-comment">/* no drivers; true reset */</span> NULL,
        <span class="enscript-comment">/* doMatching */</span> false);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::resetAndAddDrivers</span>(OSArray * drivers, <span class="enscript-type">bool</span> doNubMatching)
{
    <span class="enscript-type">bool</span>                   result              = false;
    OSArray              * newPersonalities    = NULL;  <span class="enscript-comment">// do not release
</span>    OSCollectionIterator * iter                = NULL;  <span class="enscript-comment">// must release
</span>    OSOrderedSet         * matchSet            = NULL;  <span class="enscript-comment">// must release
</span>    <span class="enscript-type">const</span> OSSymbol       * key;
    OSArray              * array;
    OSDictionary         * thisNewPersonality   = NULL; <span class="enscript-comment">// do not release
</span>    OSDictionary         * thisOldPersonality   = NULL; <span class="enscript-comment">// do not release
</span>    OSDictionary         * myKexts              = NULL; <span class="enscript-comment">// must release
</span>    <span class="enscript-type">signed</span> <span class="enscript-type">int</span>             idx, newIdx;

    <span class="enscript-keyword">if</span> (drivers) {
        newPersonalities = OSDynamicCast(OSArray, drivers);
        <span class="enscript-keyword">if</span> (!newPersonalities) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
    }
    matchSet = OSOrderedSet::withCapacity(10, IOServiceOrdering,
        (<span class="enscript-type">void</span> *)gIOProbeScoreKey);
    <span class="enscript-keyword">if</span> (!matchSet) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    iter = OSCollectionIterator::withCollection(personalities);
    <span class="enscript-keyword">if</span> (!iter) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">/* need copy of loaded kexts so we can check if for loaded modules without
     * taking the OSKext lock.  There is a potential of deadlocking if we get
     * an OSKext via the normal path.  See 14672140.
     */</span>
    myKexts = OSKext::copyKexts();
    
    result = true;

    IOLog(<span class="enscript-string">&quot;Resetting IOCatalogue.\n&quot;</span>);

   <span class="enscript-comment">/* No goto finish from here to unlock.
    */</span>
    IORWLockWrite(lock);
    
    <span class="enscript-keyword">while</span> ((key = (<span class="enscript-type">const</span> OSSymbol *) iter-&gt;getNextObject()))
    {
        array = (OSArray *) personalities-&gt;getObject(key);
        <span class="enscript-keyword">if</span> (!array) <span class="enscript-keyword">continue</span>;
        
        <span class="enscript-keyword">for</span> (idx = 0;
             (thisOldPersonality = (OSDictionary *) array-&gt;getObject(idx));
             idx++)
        {
            <span class="enscript-keyword">if</span> (thisOldPersonality-&gt;getObject(<span class="enscript-string">&quot;KernelConfigTable&quot;</span>)) <span class="enscript-keyword">continue</span>;
            thisNewPersonality = NULL;

            <span class="enscript-keyword">if</span> (newPersonalities) {
                <span class="enscript-keyword">for</span>  (newIdx = 0;
                      (thisNewPersonality = (OSDictionary *) newPersonalities-&gt;getObject(newIdx));
                      newIdx++)
                {
                    <span class="enscript-comment">/* Unlike in other functions, this comparison must be exact!
                     * The catalogue must be able to contain personalities that
                     * are proper supersets of others.
                     * Do not compare just the properties present in one driver
                     * personality or the other.
                     */</span>
                    <span class="enscript-keyword">if</span> (OSDynamicCast(OSDictionary, thisNewPersonality) == NULL) {
                        <span class="enscript-comment">/* skip thisNewPersonality if it is not an OSDictionary */</span>
                        <span class="enscript-keyword">continue</span>;
                    }
                    <span class="enscript-keyword">if</span> (thisNewPersonality-&gt;isEqualTo(thisOldPersonality))
                        <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">if</span> (thisNewPersonality) {
                <span class="enscript-comment">// dup, ignore
</span>               newPersonalities-&gt;removeObject(newIdx);
            }
            <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// not in new set - remove
</span>                <span class="enscript-comment">// only remove dictionary if this module in not loaded - 9953845
</span>                <span class="enscript-keyword">if</span> ( isModuleLoadedNoOSKextLock(myKexts, thisOldPersonality) == false ) {
                    <span class="enscript-keyword">if</span> (matchSet) {
                        matchSet-&gt;setObject(thisOldPersonality);
                    }
                    array-&gt;removeObject(idx);
                    idx--;
                }
            }
        } <span class="enscript-comment">// for...
</span>    } <span class="enscript-comment">// while...
</span>
    <span class="enscript-comment">// add new
</span>    <span class="enscript-keyword">if</span> (newPersonalities) {
        <span class="enscript-keyword">for</span> (newIdx = 0;
             (thisNewPersonality = (OSDictionary *) newPersonalities-&gt;getObject(newIdx));
             newIdx++)
        {
            <span class="enscript-keyword">if</span> (OSDynamicCast(OSDictionary, thisNewPersonality) == NULL) {
                <span class="enscript-comment">/* skip thisNewPersonality if it is not an OSDictionary */</span>
                <span class="enscript-keyword">continue</span>;
            }
            
            <span class="enscript-reference">OSKext</span>::uniquePersonalityProperties(thisNewPersonality);
            addPersonality(thisNewPersonality);
            matchSet-&gt;setObject(thisNewPersonality);
        }
    }

   <span class="enscript-comment">/* Finally, start device matching on all new &amp; removed personalities.
    */</span>
    <span class="enscript-keyword">if</span> (result &amp;&amp; doNubMatching &amp;&amp; (matchSet-&gt;getCount() &gt; 0)) {
        <span class="enscript-reference">IOService</span>::catalogNewDrivers(matchSet);
        generation++;
    }

    IORWLockUnlock(lock);

<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (matchSet)   matchSet-&gt;release();
    <span class="enscript-keyword">if</span> (iter)       iter-&gt;release();
    <span class="enscript-keyword">if</span> (myKexts)    myKexts-&gt;release();

    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::serialize</span>(OSSerialize * s) <span class="enscript-type">const</span>
{
    <span class="enscript-keyword">if</span> ( !s )
        <span class="enscript-keyword">return</span> false;

    <span class="enscript-keyword">return</span> super::serialize(s);
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOCatalogue::serializeData</span>(IOOptionBits kind, OSSerialize * s) <span class="enscript-type">const</span>
{
    kern_return_t kr = kIOReturnSuccess;

    <span class="enscript-keyword">switch</span> ( kind )
    {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogGetContents</span>:
            kr = KERN_NOT_SUPPORTED;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogGetModuleDemandList</span>:
            kr = KERN_NOT_SUPPORTED;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogGetCacheMissList</span>:
            kr = KERN_NOT_SUPPORTED;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogGetROMMkextList</span>:
            kr = KERN_NOT_SUPPORTED;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            kr = kIOReturnBadArgument;
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/* isModuleLoadedNoOSKextLock - used to check to see if a kext is loaded 
 * without taking the OSKext lock.  We use this to avoid the problem
 * where taking the IOCatalog lock then the OSKext lock will dealock when
 * a kext load or unload is happening at the same time as IOCatalog changing.
 *
 * theKexts - is a dictionary of current kexts (from OSKext::copyKexts) with
 *      key set to the kext bundle ID and value set to an OSKext object
 * theModuleDict - is an IOKit personality dictionary for a given module (kext)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">bool</span> <span class="enscript-function-name">isModuleLoadedNoOSKextLock</span>(OSDictionary *theKexts,
                                       OSDictionary *theModuleDict)
{
    <span class="enscript-type">bool</span>                    myResult = false;
    <span class="enscript-type">const</span> OSString *        myBundleID = NULL;  <span class="enscript-comment">// do not release
</span>    OSKext *                myKext = NULL;      <span class="enscript-comment">// do not release
</span>
    <span class="enscript-keyword">if</span> (theKexts == NULL || theModuleDict == NULL) {
        <span class="enscript-keyword">return</span>( myResult );
    }
    
    <span class="enscript-comment">// gIOModuleIdentifierKey is &quot;CFBundleIdentifier&quot;
</span>    myBundleID = OSDynamicCast(OSString,
                               theModuleDict-&gt;getObject(gIOModuleIdentifierKey));
    <span class="enscript-keyword">if</span> (myBundleID == NULL) {
        <span class="enscript-keyword">return</span>( myResult );
    }

    myKext = OSDynamicCast(OSKext, theKexts-&gt;getObject(myBundleID-&gt;getCStringNoCopy()));
    <span class="enscript-keyword">if</span> (myKext) {
        myResult = myKext-&gt;isLoaded();
    }
    
    <span class="enscript-keyword">return</span>( myResult );
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PRAGMA_MARK</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> <span class="enscript-variable-name">Obsolete</span> <span class="enscript-variable-name">Kext</span> <span class="enscript-variable-name">Loading</span> <span class="enscript-variable-name">Stuff</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*********************************************************************
**********************************************************************
***                  BINARY COMPATIBILITY SECTION                  ***
**********************************************************************
**********************************************************************
* These functions are no longer used are necessary for C++ binary
* compatibility on i386.
**********************************************************************/</span>
</pre>
<hr />
</body></html>