<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOHistogramReporter.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOHistogramReporter.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2013 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__STDC_LIMIT_MACROS</span>     // what are the C++ equivalents?
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKernelReportStructs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKernelReporters.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOReporterDefs.h&quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOReporter
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOHistogramReporter, IOReporter);

<span class="enscript-comment">/* static */</span>
IOHistogramReporter*
<span class="enscript-function-name">IOHistogramReporter::with</span>(IOService *reportingService,
                          IOReportCategories categories,
                          uint64_t channelID,
                          <span class="enscript-type">const</span> <span class="enscript-type">char</span> *channelName,
                          IOReportUnits unit,
                          <span class="enscript-type">int</span> nSegments,
                          IOHistogramSegmentConfig *config)
{
    IOHistogramReporter *reporter = <span class="enscript-keyword">new</span> IOHistogramReporter;
    
    <span class="enscript-type">const</span> OSSymbol *tmpChannelName = NULL;
    
    <span class="enscript-keyword">if</span> (reporter) {
        
        <span class="enscript-keyword">if</span> (channelName)
            tmpChannelName = OSSymbol::withCString(channelName);
                
        <span class="enscript-keyword">if</span>(reporter-&gt;initWith(reportingService, categories,
                              channelID, tmpChannelName,
                              unit, nSegments, config)) {
            <span class="enscript-keyword">return</span> reporter;
        }
    }
    
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">bool</span>
<span class="enscript-function-name">IOHistogramReporter::initWith</span>(IOService *reportingService,
                              IOReportCategories categories,
                              uint64_t channelID,
                              <span class="enscript-type">const</span> OSSymbol *channelName,
                              IOReportUnits unit,
                              <span class="enscript-type">int</span> nSegments,
                              IOHistogramSegmentConfig *config)
{
    <span class="enscript-type">bool</span>            result = false;
    IOReturn        res;        <span class="enscript-comment">// for PREFL_MEMOP
</span>    size_t          configSize, elementsSize, eCountsSize, boundsSize;
    <span class="enscript-type">int</span>             cnt, cnt2, cnt3 = 0;
    int64_t        bucketBound = 0, previousBucketBound = 0;
    
    <span class="enscript-comment">// analyzer appeasement
</span>    configSize = elementsSize = eCountsSize = boundsSize = 0;
    
    IORLOG(<span class="enscript-string">&quot;IOHistogramReporter::initWith&quot;</span>);

    <span class="enscript-comment">// For now, this reporter is currently limited to a single channel
</span>    _nChannels = 1;

    IOReportChannelType channelType = {
        .categories = categories,
        .report_format = kIOReportFormatHistogram,
        .nelements = 0,  <span class="enscript-comment">// Initialized when Config is unpacked
</span>        .element_idx = 0
    };
    
    <span class="enscript-keyword">if</span> (super::init(reportingService, channelType, unit) != true) {
        IORLOG(<span class="enscript-string">&quot;%s - ERROR: super::init failed&quot;</span>, __func__);
        result = false;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">// Make sure to call this after the commit init phase
</span>    <span class="enscript-keyword">if</span> (channelName) _channelNames-&gt;setObject(channelName);
    
    _segmentCount = nSegments;
    <span class="enscript-keyword">if</span> (_segmentCount == 0) {
        IORLOG(<span class="enscript-string">&quot;IOReportHistogram init ERROR. No configuration provided!&quot;</span>);
        result = false;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    IORLOG(<span class="enscript-string">&quot;%s - %u segment(s)&quot;</span>, __func__, _segmentCount);
    
    PREFL_MEMOP_FAIL(_segmentCount, IOHistogramSegmentConfig);
    configSize = (size_t)_segmentCount * <span class="enscript-keyword">sizeof</span>(IOHistogramSegmentConfig);
    _histogramSegmentsConfig = (IOHistogramSegmentConfig*)IOMalloc(configSize);
    <span class="enscript-keyword">if</span> (!_histogramSegmentsConfig)      <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    memcpy(_histogramSegmentsConfig, config, configSize);
    
    <span class="enscript-comment">// Find out how many elements are need to store the histogram
</span>    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; _segmentCount; cnt++) {
        
        _nElements += _histogramSegmentsConfig[cnt].segment_bucket_count;
        _channelDimension += _histogramSegmentsConfig[cnt].segment_bucket_count;
        
        IORLOG(<span class="enscript-string">&quot;\t\t bucket_base_width: %u | log_scale: %u | buckets: %u&quot;</span>,
                _histogramSegmentsConfig[cnt].base_bucket_width,
                _histogramSegmentsConfig[cnt].scale_flag,
                _histogramSegmentsConfig[cnt].segment_bucket_count);
        
        <span class="enscript-keyword">if</span> (_histogramSegmentsConfig[cnt].scale_flag &gt; 1
            || _histogramSegmentsConfig[cnt].base_bucket_width == 0) {
            result = false;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

    }
    
    <span class="enscript-comment">// Update the channel type with discovered dimension
</span>    _channelType.nelements = _channelDimension;

    IORLOG(<span class="enscript-string">&quot;%s - %u channel(s) of dimension %u&quot;</span>,
           __func__, _nChannels, _channelDimension);

    IORLOG(<span class="enscript-string">&quot;%s %d segments for a total dimension of %d elements&quot;</span>,
           __func__, _nChannels, _nElements);
    
    <span class="enscript-comment">// Allocate memory for the array of report elements
</span>    PREFL_MEMOP_FAIL(_nElements, IOReportElement);
    elementsSize = (size_t)_nElements * <span class="enscript-keyword">sizeof</span>(IOReportElement);
    _elements = (IOReportElement *)IOMalloc(elementsSize);
    <span class="enscript-keyword">if</span> (!_elements)             <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    memset(_elements, 0, elementsSize);
    
    <span class="enscript-comment">// Allocate memory for the array of element watch count
</span>    PREFL_MEMOP_FAIL(_nElements, <span class="enscript-type">int</span>);
    eCountsSize = (size_t)_nChannels * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
    _enableCounts = (<span class="enscript-type">int</span> *)IOMalloc(eCountsSize);
    <span class="enscript-keyword">if</span> (!_enableCounts)         <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    memset(_enableCounts, 0, eCountsSize);
    
    lockReporter();
    <span class="enscript-keyword">for</span> (cnt2 = 0; cnt2 &lt; _channelDimension; cnt2++) {
        IOHistogramReportValues hist_values;
        <span class="enscript-keyword">if</span> (copyElementValues(cnt2, (IOReportElementValues*)&amp;hist_values)){
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        hist_values.bucket_min = kIOReportInvalidIntValue;
        hist_values.bucket_max = kIOReportInvalidIntValue;
        hist_values.bucket_sum = kIOReportInvalidIntValue;
        <span class="enscript-keyword">if</span> (setElementValues(cnt2, (IOReportElementValues*)&amp;hist_values)){
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }

        <span class="enscript-comment">// Setup IOReporter's channel IDs
</span>        _elements[cnt2].channel_id = channelID;
        
        <span class="enscript-comment">// Setup IOReporter's reporting provider service
</span>        _elements[cnt2].provider_id = _driver_id;
        
        <span class="enscript-comment">// Setup IOReporter's channel type
</span>        _elements[cnt2].channel_type = _channelType;
        _elements[cnt2].channel_type.element_idx = cnt2;
        
        <span class="enscript-comment">//IOREPORTER_DEBUG_ELEMENT(cnt2);
</span>    }
    unlockReporter();
    
    <span class="enscript-comment">// Allocate memory for the bucket upper bounds
</span>    PREFL_MEMOP_FAIL(_nElements, uint64_t);
    boundsSize = (size_t)_nElements * <span class="enscript-keyword">sizeof</span>(uint64_t);
    _bucketBounds = (int64_t*)IOMalloc(boundsSize);
    <span class="enscript-keyword">if</span> (!_bucketBounds)         <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    memset(_bucketBounds, 0, boundsSize);
    _bucketCount = _nElements;

    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; _segmentCount; cnt++) {
        
        <span class="enscript-keyword">if</span> (_histogramSegmentsConfig[cnt].segment_bucket_count &gt; INT_MAX
            || _histogramSegmentsConfig[cnt].base_bucket_width &gt; INT_MAX) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        <span class="enscript-keyword">for</span> (cnt2 = 0; cnt2 &lt; (<span class="enscript-type">int</span>)_histogramSegmentsConfig[cnt].segment_bucket_count; cnt2++) {
            
            <span class="enscript-keyword">if</span> (cnt3 &gt;= _nElements) {
                IORLOG(<span class="enscript-string">&quot;ERROR: _bucketBounds init&quot;</span>);
                <span class="enscript-keyword">return</span> false;
            }
            
            <span class="enscript-keyword">if</span> (_histogramSegmentsConfig[cnt].scale_flag) {
                <span class="enscript-comment">// FIXME: Could use pow() but not sure how to include math.h
</span>                int64_t power = 1;
                <span class="enscript-type">int</span> exponent = cnt2 + 1;
                <span class="enscript-keyword">while</span> (exponent) {
                    power *= _histogramSegmentsConfig[cnt].base_bucket_width;
                    exponent--;
                }
                bucketBound = power;
            }
            
            <span class="enscript-keyword">else</span> {
                bucketBound = _histogramSegmentsConfig[cnt].base_bucket_width *
                                                    ((<span class="enscript-type">unsigned</span>)cnt2 + 1);
            }
            
            <span class="enscript-keyword">if</span> (previousBucketBound &gt;= bucketBound) {
                IORLOG(<span class="enscript-string">&quot;Histogram ERROR: bucket bound does not increase linearly (segment %u / bucket # %u)&quot;</span>,
                       cnt, cnt2);
                result = false;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
            }
            
            _bucketBounds[cnt3] = bucketBound;
            <span class="enscript-comment">// IORLOG(&quot;_bucketBounds[%u] = %llu&quot;, cnt3, bucketBound);
</span>            previousBucketBound = _bucketBounds[cnt3];
            cnt3++;
        }
    }
    
    <span class="enscript-comment">// success
</span>    result = true;
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">if</span> (result != true) {
        
        <span class="enscript-keyword">if</span> (_histogramSegmentsConfig)
            IOFree(_histogramSegmentsConfig, configSize);
        
        <span class="enscript-keyword">if</span> (_elements)
            IOFree(_elements, elementsSize);
        
        <span class="enscript-keyword">if</span> (_enableCounts)
            IOFree(_enableCounts, eCountsSize);
        
        <span class="enscript-keyword">if</span> (_bucketBounds)
            IOFree(_bucketBounds, boundsSize);
    }
    
    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">IOHistogramReporter::free</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (_bucketBounds) {
        PREFL_MEMOP_PANIC(_nElements, int64_t);
        IOFree(_bucketBounds, (size_t)_nElements * <span class="enscript-keyword">sizeof</span>(int64_t));
    }
    <span class="enscript-keyword">if</span> (_histogramSegmentsConfig) {
        PREFL_MEMOP_PANIC(_segmentCount, IOHistogramSegmentConfig);
        IOFree(_histogramSegmentsConfig,
               (size_t)_segmentCount * <span class="enscript-keyword">sizeof</span>(IOHistogramSegmentConfig));
    }
    
    <span class="enscript-reference">super</span>::free();
}


IOReportLegendEntry*
<span class="enscript-function-name">IOHistogramReporter::handleCreateLegend</span>(<span class="enscript-type">void</span>)
{
    OSData                  *tmpConfigData;
    OSDictionary            *tmpDict;
    IOReportLegendEntry     *legendEntry = NULL;
        
    legendEntry = super::handleCreateLegend();
    
    <span class="enscript-keyword">if</span> (legendEntry) {
        
        PREFL_MEMOP_PANIC(_segmentCount, IOHistogramSegmentConfig);
        tmpConfigData = OSData::withBytes(_histogramSegmentsConfig,
                                          (<span class="enscript-type">unsigned</span>)_segmentCount *
                                            (<span class="enscript-type">unsigned</span>)<span class="enscript-keyword">sizeof</span>(IOHistogramSegmentConfig));
        <span class="enscript-keyword">if</span> (!tmpConfigData) {
            legendEntry-&gt;release();
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        tmpDict = OSDynamicCast(OSDictionary, legendEntry-&gt;getObject(kIOReportLegendInfoKey));
        <span class="enscript-keyword">if</span> (!tmpDict) {
            legendEntry-&gt;release();
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
        }
        
        tmpDict-&gt;setObject(kIOReportLegendConfigKey, tmpConfigData);
    }
    
<span class="enscript-reference">finish</span>:
    <span class="enscript-keyword">return</span> legendEntry;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">IOHistogramReporter::tallyValue</span>(int64_t value)
{
    <span class="enscript-type">int</span> result = -1;
    <span class="enscript-type">int</span> cnt = 0, element_index = 0;
    IOHistogramReportValues hist_values;
    
    lockReporter();
    
    <span class="enscript-comment">// Iterate over _bucketCount minus one to make last bucket of infinite width
</span>    <span class="enscript-keyword">for</span> (cnt = 0; cnt &lt; _bucketCount - 1; cnt++) {
        <span class="enscript-keyword">if</span> (value &lt;= _bucketBounds[cnt]) <span class="enscript-keyword">break</span>;
    }
    
    element_index = cnt;
    
    <span class="enscript-keyword">if</span> (copyElementValues(element_index, (IOReportElementValues *)&amp;hist_values) != kIOReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }
    
    <span class="enscript-comment">// init stats on first hit
</span>    <span class="enscript-keyword">if</span> (hist_values.bucket_hits == 0) {
        hist_values.bucket_min = hist_values.bucket_max = value;
        hist_values.bucket_sum = 0;     <span class="enscript-comment">// += is below
</span>    }

    <span class="enscript-comment">// update all values
</span>    <span class="enscript-keyword">if</span> (value &lt; hist_values.bucket_min) {
        hist_values.bucket_min = value;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (value &gt; hist_values.bucket_max) {
        hist_values.bucket_max = value;
    }
    hist_values.bucket_sum += value;
    hist_values.bucket_hits++;
    
    <span class="enscript-keyword">if</span> (setElementValues(element_index, (IOReportElementValues *)&amp;hist_values)
                != kIOReturnSuccess) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
    }

    <span class="enscript-comment">// success!
</span>    result = element_index;
    
<span class="enscript-reference">finish</span>:
    unlockReporter();
    <span class="enscript-keyword">return</span> result;
}
</pre>
<hr />
</body></html>