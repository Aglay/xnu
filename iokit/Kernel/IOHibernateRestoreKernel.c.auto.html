<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOHibernateRestoreKernel.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOHibernateRestoreKernel.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOHibernatePrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/boot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/WKdm_new.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOHibernateInternal.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_hibernate.h&gt;</span>

<span class="enscript-comment">/*
This code is linked into the kernel but part of the &quot;__HIB&quot; section, which means
its used by code running in the special context of restoring the kernel text and data
from the hibernation image read by the booter. hibernate_kernel_entrypoint() and everything
it calls or references needs to be careful to only touch memory also in the &quot;__HIB&quot; section.
*/</span>

uint32_t gIOHibernateState;

uint32_t gIOHibernateDebugFlags;

<span class="enscript-type">static</span> IOHibernateImageHeader _hibernateHeader;
IOHibernateImageHeader * gIOHibernateCurrentHeader = &amp;_hibernateHeader;

ppnum_t gIOHibernateHandoffPages[64];
uint32_t gIOHibernateHandoffPageCount = <span class="enscript-keyword">sizeof</span>(gIOHibernateHandoffPages) 
					/ <span class="enscript-keyword">sizeof</span>(gIOHibernateHandoffPages[0]);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEBUG</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hibprintf</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">hibprintf</span>(x...)
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">acpi_wake_prot_entry</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">rdtsc</span>(lo,hi) \
    __asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;lfence; rdtsc; lfence&quot;</span> : <span class="enscript-string">&quot;=a&quot;</span> (lo), <span class="enscript-string">&quot;=d&quot;</span> (hi))

<span class="enscript-type">static</span> inline uint64_t <span class="enscript-function-name">rdtsc64</span>(<span class="enscript-type">void</span>)
{
    uint64_t lo, hi;
    rdtsc(lo, hi);
    <span class="enscript-keyword">return</span> ((hi) &lt;&lt; 32) | (lo);
}

#<span class="enscript-reference">else</span>

<span class="enscript-type">static</span> inline uint64_t <span class="enscript-function-name">rdtsc64</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBGLOG</span>	1

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;architecture/i386/pio.h&gt;</span>

<span class="enscript-comment">/* standard port addresses */</span>
<span class="enscript-type">enum</span> {
    COM1_PORT_ADDR = 0x3f8,
    COM2_PORT_ADDR = 0x2f8
};

<span class="enscript-comment">/* UART register offsets */</span>
<span class="enscript-type">enum</span> {
    UART_RBR = 0,  <span class="enscript-comment">/* receive buffer Register   (R) */</span>
    UART_THR = 0,  <span class="enscript-comment">/* transmit holding register (W) */</span>
    UART_DLL = 0,  <span class="enscript-comment">/* DLAB = 1, divisor latch (LSB) */</span>
    UART_IER = 1,  <span class="enscript-comment">/* interrupt enable register     */</span>
    UART_DLM = 1,  <span class="enscript-comment">/* DLAB = 1, divisor latch (MSB) */</span>
    UART_IIR = 2,  <span class="enscript-comment">/* interrupt ident register (R)  */</span>
    UART_FCR = 2,  <span class="enscript-comment">/* fifo control register (W)     */</span>
    UART_LCR = 3,  <span class="enscript-comment">/* line control register         */</span>
    UART_MCR = 4,  <span class="enscript-comment">/* modem control register        */</span>
    UART_LSR = 5,  <span class="enscript-comment">/* line status register          */</span>
    UART_MSR = 6,  <span class="enscript-comment">/* modem status register         */</span>
    UART_SCR = 7   <span class="enscript-comment">/* scratch register              */</span>
};

<span class="enscript-type">enum</span> {
    UART_LCR_8BITS = 0x03,
    UART_LCR_DLAB  = 0x80
};

<span class="enscript-type">enum</span> {
    UART_MCR_DTR   = 0x01,
    UART_MCR_RTS   = 0x02,
    UART_MCR_OUT1  = 0x04,
    UART_MCR_OUT2  = 0x08,
    UART_MCR_LOOP  = 0x10
};

<span class="enscript-type">enum</span> {
    UART_LSR_DR    = 0x01,
    UART_LSR_OE    = 0x02,
    UART_LSR_PE    = 0x04,
    UART_LSR_FE    = 0x08,
    UART_LSR_THRE  = 0x20
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">uart_putc</span>(<span class="enscript-type">char</span> c)
{
    <span class="enscript-keyword">while</span> (!(inb(COM1_PORT_ADDR + UART_LSR) &amp; UART_LSR_THRE))
	{}
    outb(COM1_PORT_ADDR + UART_THR, c);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">debug_probe</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-comment">/* Verify that the Scratch Register is accessible */</span>
    outb(COM1_PORT_ADDR + UART_SCR, 0x5a);
    <span class="enscript-keyword">if</span> (inb(COM1_PORT_ADDR + UART_SCR) != 0x5a) <span class="enscript-keyword">return</span> false;
    outb(COM1_PORT_ADDR + UART_SCR, 0xa5);
    <span class="enscript-keyword">if</span> (inb(COM1_PORT_ADDR + UART_SCR) != 0xa5) <span class="enscript-keyword">return</span> false;
    uart_putc(<span class="enscript-string">'\n'</span>);
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">uart_puthex</span>(uint64_t num)
{
    <span class="enscript-type">int</span> bit;
    <span class="enscript-type">char</span> c;
    bool leading = true;

    <span class="enscript-keyword">for</span> (bit = 60; bit &gt;= 0; bit -= 4)
    {
	c = 0xf &amp; (num &gt;&gt; bit);
	<span class="enscript-keyword">if</span> (c)
	    leading = false;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (leading &amp;&amp; bit)
	    <span class="enscript-keyword">continue</span>;
	<span class="enscript-keyword">if</span> (c &lt;= 9)
	    c += <span class="enscript-string">'0'</span>;
	<span class="enscript-keyword">else</span>
	    c+= <span class="enscript-string">'a'</span> - 10;
	uart_putc(c);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">debug_code</span>(uint32_t code, uint64_t value)
{
    <span class="enscript-type">int</span> bit;
    <span class="enscript-type">char</span> c;

    <span class="enscript-keyword">if</span> (!(kIOHibernateDebugRestoreLogs &amp; gIOHibernateDebugFlags))
	<span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">for</span> (bit = 24; bit &gt;= 0; bit -= 8)
    {
	c = 0xFF &amp; (code &gt;&gt; bit);
	<span class="enscript-keyword">if</span> (c)
	    uart_putc(c);
    }
    uart_putc(<span class="enscript-string">'='</span>);
    uart_puthex(value);
    uart_putc(<span class="enscript-string">'\n'</span>);
    uart_putc(<span class="enscript-string">'\r'</span>);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(__i386__) || defined(__x86_64__) */</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DBGLOG</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">debug_probe</span>()	    (false)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">debug_code</span>(c, v)    {}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">enum</span>
{
    kIOHibernateRestoreCodeImageStart	    = 'imgS',
    kIOHibernateRestoreCodeImageEnd	    = 'imgE',
    kIOHibernateRestoreCodePageIndexStart   = 'pgiS',
    kIOHibernateRestoreCodePageIndexEnd	    = 'pgiE',
    kIOHibernateRestoreCodeMapStart	    = 'mapS',
    kIOHibernateRestoreCodeMapEnd	    = 'mapE',
    kIOHibernateRestoreCodeWakeMapSize	    = 'wkms',
    kIOHibernateRestoreCodeConflictPage	    = 'cfpg',
    kIOHibernateRestoreCodeConflictSource   = 'cfsr',
    kIOHibernateRestoreCodeNoMemory         = 'nomm',
    kIOHibernateRestoreCodeTag              = 'tag ',
    kIOHibernateRestoreCodeSignature        = 'sign',
    kIOHibernateRestoreCodeMapVirt          = 'mapV',
    kIOHibernateRestoreCodeHandoffPages     = 'hand',
    kIOHibernateRestoreCodeHandoffCount     = 'hndc',
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fatal</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    outb(0xcf9, 6);
#<span class="enscript-reference">else</span>
    <span class="enscript-keyword">while</span> (true) {}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

uint32_t
<span class="enscript-function-name">hibernate_sum_page</span>(uint8_t *buf, uint32_t ppnum)
{
    <span class="enscript-keyword">return</span> (((uint32_t *)buf)[((PAGE_SIZE &gt;&gt; 2) - 1) &amp; ppnum]);
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">static</span> hibernate_bitmap_t *
<span class="enscript-function-name">hibernate_page_bitmap</span>(hibernate_page_list_t * list, uint32_t page)
{
    uint32_t             bank;
    hibernate_bitmap_t * bitmap = &amp;list-&gt;bank_bitmap[0];

    <span class="enscript-keyword">for</span> (bank = 0; bank &lt; list-&gt;bank_count; bank++)
    {
	<span class="enscript-keyword">if</span> ((page &gt;= bitmap-&gt;first_page) &amp;&amp; (page &lt;= bitmap-&gt;last_page))
	    <span class="enscript-keyword">break</span>;
	bitmap = (hibernate_bitmap_t *) &amp;bitmap-&gt;bitmap[bitmap-&gt;bitmapwords];
    }
    <span class="enscript-keyword">if</span> (bank == list-&gt;bank_count)
	bitmap = NULL;
	
    <span class="enscript-keyword">return</span> (bitmap);
}

hibernate_bitmap_t *
<span class="enscript-function-name">hibernate_page_bitmap_pin</span>(hibernate_page_list_t * list, uint32_t * pPage)
{
    uint32_t             bank, page = *pPage;
    hibernate_bitmap_t * bitmap = &amp;list-&gt;bank_bitmap[0];

    <span class="enscript-keyword">for</span> (bank = 0; bank &lt; list-&gt;bank_count; bank++)
    {
	<span class="enscript-keyword">if</span> (page &lt;= bitmap-&gt;first_page)
	{
	    *pPage = bitmap-&gt;first_page;
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (page &lt;= bitmap-&gt;last_page)
	    <span class="enscript-keyword">break</span>;
	bitmap = (hibernate_bitmap_t *) &amp;bitmap-&gt;bitmap[bitmap-&gt;bitmapwords];
    }
    <span class="enscript-keyword">if</span> (bank == list-&gt;bank_count)
	bitmap = NULL;
	
    <span class="enscript-keyword">return</span> (bitmap);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">hibernate_page_bitset</span>(hibernate_page_list_t * list, boolean_t set, uint32_t page)
{
    hibernate_bitmap_t * bitmap;

    bitmap = hibernate_page_bitmap(list, page);
    <span class="enscript-keyword">if</span> (bitmap)
    {
	page -= bitmap-&gt;first_page;
	<span class="enscript-keyword">if</span> (set)
	    bitmap-&gt;bitmap[page &gt;&gt; 5] |= (0x80000000 &gt;&gt; (page &amp; 31));
	    <span class="enscript-comment">//setbit(page - bitmap-&gt;first_page, (int *) &amp;bitmap-&gt;bitmap[0]);
</span>	<span class="enscript-keyword">else</span>
	    bitmap-&gt;bitmap[page &gt;&gt; 5] &amp;= ~(0x80000000 &gt;&gt; (page &amp; 31));
	    <span class="enscript-comment">//clrbit(page - bitmap-&gt;first_page, (int *) &amp;bitmap-&gt;bitmap[0]);
</span>    }
}

boolean_t 
<span class="enscript-function-name">hibernate_page_bittst</span>(hibernate_page_list_t * list, uint32_t page)
{
    boolean_t		 result = TRUE;
    hibernate_bitmap_t * bitmap;

    bitmap = hibernate_page_bitmap(list, page);
    <span class="enscript-keyword">if</span> (bitmap)
    {
	page -= bitmap-&gt;first_page;
	result = (0 != (bitmap-&gt;bitmap[page &gt;&gt; 5] &amp; (0x80000000 &gt;&gt; (page &amp; 31))));
    }
    <span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">// count bits clear or set (set == TRUE) starting at page.
</span>uint32_t
<span class="enscript-function-name">hibernate_page_bitmap_count</span>(hibernate_bitmap_t * bitmap, uint32_t set, uint32_t page)
{
    uint32_t index, bit, bits;
    uint32_t count;

    count = 0;

    index = (page - bitmap-&gt;first_page) &gt;&gt; 5;
    bit = (page - bitmap-&gt;first_page) &amp; 31;

    bits = bitmap-&gt;bitmap[index];
    <span class="enscript-keyword">if</span> (set)
	bits = ~bits;
    bits = (bits &lt;&lt; bit);
    <span class="enscript-keyword">if</span> (bits)
	count += __builtin_clz(bits);
    <span class="enscript-keyword">else</span>
    {
	count += 32 - bit;
	<span class="enscript-keyword">while</span> (++index &lt; bitmap-&gt;bitmapwords)
	{
	    bits = bitmap-&gt;bitmap[index];
	    <span class="enscript-keyword">if</span> (set)
		bits = ~bits;
	    <span class="enscript-keyword">if</span> (bits)
	    {
		count += __builtin_clz(bits);
		<span class="enscript-keyword">break</span>;
	    }
	    count += 32;
	}
    }

    <span class="enscript-keyword">if</span> ((page + count) &gt; (bitmap-&gt;last_page + 1)) count = (bitmap-&gt;last_page + 1) - page;

    <span class="enscript-keyword">return</span> (count);
}

<span class="enscript-type">static</span> ppnum_t
<span class="enscript-function-name">hibernate_page_list_grab</span>(hibernate_page_list_t * list, uint32_t * pNextFree)
{
    uint32_t		 nextFree = *pNextFree;
    uint32_t		 nextFreeInBank;
    hibernate_bitmap_t * bitmap;

    nextFreeInBank = nextFree + 1;
    <span class="enscript-keyword">while</span> ((bitmap = hibernate_page_bitmap_pin(list, &amp;nextFreeInBank)))
    {
	nextFreeInBank += hibernate_page_bitmap_count(bitmap, FALSE, nextFreeInBank);
	<span class="enscript-keyword">if</span> (nextFreeInBank &lt;= bitmap-&gt;last_page)
	{
	    *pNextFree = nextFreeInBank;
	    <span class="enscript-keyword">break</span>;
	}
    }

    <span class="enscript-keyword">if</span> (!bitmap) 
    {
	debug_code(kIOHibernateRestoreCodeNoMemory, nextFree);
	fatal();
	nextFree = 0;
    }

    <span class="enscript-keyword">return</span> (nextFree);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">store_one_page</span>(uint32_t procFlags, uint32_t * src, uint32_t compressedSize, 
		uint32_t * buffer, uint32_t ppnum)
{
	uint64_t dst = ptoa_64(ppnum);
	uint8_t scratch[WKdm_SCRATCH_BUF_SIZE] __attribute__ ((aligned (16)));

	<span class="enscript-keyword">if</span> (compressedSize != PAGE_SIZE)
	{
		dst = pal_hib_map(DEST_COPY_AREA, dst);
		<span class="enscript-keyword">if</span> (compressedSize != 4) WKdm_decompress_new((WK_word*) src, (WK_word*)(uintptr_t)dst, (WK_word*) &amp;scratch[0], compressedSize);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> i;
			uint32_t *s, *d;
			
			s = src;
			d = (uint32_t *)(uintptr_t)dst;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(int32_t)); i++)
				*d++ = *s;
		}
	}
	<span class="enscript-keyword">else</span>
	{
		dst = hibernate_restore_phys_page((uint64_t) (uintptr_t) src, dst, PAGE_SIZE, procFlags);
	}

	<span class="enscript-keyword">return</span> hibernate_sum_page((uint8_t *)(uintptr_t)dst, ppnum);
}

<span class="enscript-type">long</span> 
<span class="enscript-function-name">hibernate_kernel_entrypoint</span>(uint32_t p1, 
                            uint32_t p2, uint32_t p3, uint32_t p4)
{
    uint64_t headerPhys;
    uint64_t mapPhys;
    uint64_t srcPhys;
    uint64_t imageReadPhys;
    uint64_t pageIndexPhys;
    uint32_t * pageIndexSource;
    hibernate_page_list_t * map;
    uint32_t stage;
    uint32_t count;
    uint32_t ppnum;
    uint32_t page;
    uint32_t conflictCount;
    uint32_t compressedSize;
    uint32_t uncompressedPages;
    uint32_t copyPageListHeadPage;
    uint32_t pageListPage;
    uint32_t * copyPageList;
    uint32_t * src;
    uint32_t copyPageIndex;
    uint32_t sum;
    uint32_t pageSum;
    uint32_t nextFree;
    uint32_t lastImagePage;
    uint32_t lastMapPage;
    uint32_t lastPageIndexPage;
    uint32_t handoffPages;
    uint32_t handoffPageCount;

    uint64_t timeStart;
    timeStart = rdtsc64();

    assert_static(<span class="enscript-keyword">sizeof</span>(IOHibernateImageHeader) == 512);

    headerPhys = ptoa_64(p1);

    <span class="enscript-keyword">if</span> ((kIOHibernateDebugRestoreLogs &amp; gIOHibernateDebugFlags) &amp;&amp; !debug_probe())
	gIOHibernateDebugFlags &amp;= ~kIOHibernateDebugRestoreLogs;

    debug_code(kIOHibernateRestoreCodeImageStart, headerPhys);

    memcpy(gIOHibernateCurrentHeader,
	   (<span class="enscript-type">void</span> *) pal_hib_map(IMAGE_AREA, headerPhys), 
	   <span class="enscript-keyword">sizeof</span>(IOHibernateImageHeader));

    debug_code(kIOHibernateRestoreCodeSignature, gIOHibernateCurrentHeader-&gt;signature);

    mapPhys = headerPhys
             + (offsetof(IOHibernateImageHeader, fileExtentMap)
	     + gIOHibernateCurrentHeader-&gt;fileExtentMapSize 
	     + ptoa_32(gIOHibernateCurrentHeader-&gt;restore1PageCount)
	     + gIOHibernateCurrentHeader-&gt;previewSize);

    map = (hibernate_page_list_t *) pal_hib_map(BITMAP_AREA, mapPhys);

    lastImagePage = atop_64(headerPhys + gIOHibernateCurrentHeader-&gt;image1Size);
    lastMapPage = atop_64(mapPhys + gIOHibernateCurrentHeader-&gt;bitmapSize);

    handoffPages     = gIOHibernateCurrentHeader-&gt;handoffPages;
    handoffPageCount = gIOHibernateCurrentHeader-&gt;handoffPageCount;

    debug_code(kIOHibernateRestoreCodeImageEnd,       ptoa_64(lastImagePage));
    debug_code(kIOHibernateRestoreCodeMapStart,       mapPhys);
    debug_code(kIOHibernateRestoreCodeMapEnd,         ptoa_64(lastMapPage));

    debug_code(kIOHibernateRestoreCodeMapVirt, (uintptr_t) map);
    debug_code(kIOHibernateRestoreCodeHandoffPages, ptoa_64(handoffPages));
    debug_code(kIOHibernateRestoreCodeHandoffCount, handoffPageCount);

    <span class="enscript-comment">// knock all the image pages to be used out of free map
</span>    <span class="enscript-keyword">for</span> (ppnum = atop_64(headerPhys); ppnum &lt;= lastImagePage; ppnum++)
    {
	hibernate_page_bitset(map, FALSE, ppnum);
    }
    <span class="enscript-comment">// knock all the handoff pages to be used out of free map
</span>    <span class="enscript-keyword">for</span> (ppnum = handoffPages; ppnum &lt; (handoffPages + handoffPageCount); ppnum++)
    {
	hibernate_page_bitset(map, FALSE, ppnum);
    }

    nextFree = 0;
    hibernate_page_list_grab(map, &amp;nextFree);

    sum = gIOHibernateCurrentHeader-&gt;actualRestore1Sum;
    gIOHibernateCurrentHeader-&gt;diag[0] = atop_64(headerPhys);
    gIOHibernateCurrentHeader-&gt;diag[1] = sum;
    gIOHibernateCurrentHeader-&gt;trampolineTime = 0;

    uncompressedPages    = 0;
    conflictCount        = 0;
    copyPageListHeadPage = 0;
    copyPageList         = 0;
    copyPageIndex        = PAGE_SIZE &gt;&gt; 2;

    compressedSize       = PAGE_SIZE;
    stage                = 2;
    count                = 0;
    srcPhys              = 0;

    <span class="enscript-keyword">if</span> (gIOHibernateCurrentHeader-&gt;previewSize)
    {
	pageIndexPhys     = headerPhys
	                   + (offsetof(IOHibernateImageHeader, fileExtentMap)
			   + gIOHibernateCurrentHeader-&gt;fileExtentMapSize 
			   + ptoa_32(gIOHibernateCurrentHeader-&gt;restore1PageCount));
	imageReadPhys     = (pageIndexPhys + gIOHibernateCurrentHeader-&gt;previewPageListSize);
	lastPageIndexPage = atop_64(imageReadPhys);
	pageIndexSource   = (uint32_t *) pal_hib_map(IMAGE2_AREA, pageIndexPhys);
    }
    <span class="enscript-keyword">else</span>
    {
	pageIndexPhys     = 0;
	lastPageIndexPage = 0;
	imageReadPhys     = (mapPhys + gIOHibernateCurrentHeader-&gt;bitmapSize);
    }

    debug_code(kIOHibernateRestoreCodePageIndexStart, pageIndexPhys);
    debug_code(kIOHibernateRestoreCodePageIndexEnd,   ptoa_64(lastPageIndexPage));

    <span class="enscript-keyword">while</span> (1)
    {
	<span class="enscript-keyword">switch</span> (stage)
	{
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		<span class="enscript-comment">// copy handoff data
</span>		count = srcPhys ? 0 : handoffPageCount;
		<span class="enscript-keyword">if</span> (!count)
		    <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (count &gt; gIOHibernateHandoffPageCount) count = gIOHibernateHandoffPageCount;
		srcPhys = ptoa_64(handoffPages);
		<span class="enscript-keyword">break</span>;
	
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		<span class="enscript-comment">// copy pageIndexSource pages == preview image data
</span>		<span class="enscript-keyword">if</span> (!srcPhys)
		{
		    <span class="enscript-keyword">if</span> (!pageIndexPhys) <span class="enscript-keyword">break</span>;
		    srcPhys = imageReadPhys;
		}
		ppnum = pageIndexSource[0];
		count = pageIndexSource[1];
		pageIndexSource += 2;
		pageIndexPhys   += 2 * <span class="enscript-keyword">sizeof</span>(pageIndexSource[0]);
		imageReadPhys = srcPhys;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">// copy pages
</span>		<span class="enscript-keyword">if</span> (!srcPhys) srcPhys = (mapPhys + gIOHibernateCurrentHeader-&gt;bitmapSize);
		src = (uint32_t *) pal_hib_map(IMAGE_AREA, srcPhys);
		ppnum = src[0];
		count = src[1];
		srcPhys += 2 * <span class="enscript-keyword">sizeof</span>(*src);
		imageReadPhys = srcPhys;
		<span class="enscript-keyword">break</span>;
	}


	<span class="enscript-keyword">if</span> (!count)
	{
	    <span class="enscript-keyword">if</span> (!stage)
	        <span class="enscript-keyword">break</span>;
	    stage--;
	    srcPhys = 0;
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-keyword">for</span> (page = 0; page &lt; count; page++, ppnum++)
	{
	    uint32_t tag;
	    <span class="enscript-type">int</span> conflicts;

	    src = (uint32_t *) pal_hib_map(IMAGE_AREA, srcPhys);

	    <span class="enscript-keyword">if</span> (2 == stage) ppnum = gIOHibernateHandoffPages[page];
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!stage)
	    {
		tag = *src++;
<span class="enscript-comment">//		debug_code(kIOHibernateRestoreCodeTag, (uintptr_t) tag);
</span>		srcPhys += <span class="enscript-keyword">sizeof</span>(*src);
		compressedSize = kIOHibernateTagLength &amp; tag;
	    }

	    conflicts = (ppnum &gt;= atop_64(mapPhys)) &amp;&amp; (ppnum &lt;= lastMapPage);

	    conflicts |= ((ppnum &gt;= atop_64(imageReadPhys)) &amp;&amp; (ppnum &lt;= lastImagePage));

	    <span class="enscript-keyword">if</span> (stage &gt;= 2)
 		conflicts |= ((ppnum &gt;= atop_64(srcPhys)) &amp;&amp; (ppnum &lt;= (handoffPages + handoffPageCount - 1)));

	    <span class="enscript-keyword">if</span> (stage &gt;= 1)
 		conflicts |= ((ppnum &gt;= atop_64(pageIndexPhys)) &amp;&amp; (ppnum &lt;= lastPageIndexPage));

	    <span class="enscript-keyword">if</span> (!conflicts)
	    {
		pageSum = store_one_page(gIOHibernateCurrentHeader-&gt;processorFlags,
					 src, compressedSize, 0, ppnum);
		<span class="enscript-keyword">if</span> (stage != 2)
		    sum += pageSum;
		uncompressedPages++;
	    }
	    <span class="enscript-keyword">else</span>
	    {
		uint32_t   bufferPage = 0;
		uint32_t * dst;

<span class="enscript-comment">//		debug_code(kIOHibernateRestoreCodeConflictPage,   ppnum);
</span><span class="enscript-comment">//		debug_code(kIOHibernateRestoreCodeConflictSource, (uintptr_t) src);
</span>		conflictCount++;
		<span class="enscript-keyword">if</span> (compressedSize)
		{
		    <span class="enscript-comment">// alloc new buffer page
</span>		    bufferPage = hibernate_page_list_grab(map, &amp;nextFree);
		    dst = (uint32_t *)pal_hib_map(DEST_COPY_AREA, ptoa_64(bufferPage));
		    memcpy(dst, src, compressedSize);
		}
		<span class="enscript-keyword">if</span> (copyPageIndex &gt; ((PAGE_SIZE &gt;&gt; 2) - 3))
		{
		    <span class="enscript-comment">// alloc new copy list page
</span>		    pageListPage = hibernate_page_list_grab(map, &amp;nextFree);
		    <span class="enscript-comment">// link to current
</span>		    <span class="enscript-keyword">if</span> (copyPageList) {
			    copyPageList[1] = pageListPage;
		    } <span class="enscript-keyword">else</span> {
			    copyPageListHeadPage = pageListPage;
		    }
		    copyPageList = (uint32_t *)pal_hib_map(SRC_COPY_AREA, 
				    ptoa_64(pageListPage));
		    copyPageList[1] = 0;
		    copyPageIndex = 2;
		}
		copyPageList[copyPageIndex++] = ppnum;
		copyPageList[copyPageIndex++] = bufferPage;
		copyPageList[copyPageIndex++] = (compressedSize | (stage &lt;&lt; 24));
		copyPageList[0] = copyPageIndex;
	    }
	    srcPhys += ((compressedSize + 3) &amp; ~3);
	    src     += ((compressedSize + 3) &gt;&gt; 2);
	}
    }

    <span class="enscript-comment">/* src points to the last page restored, so we need to skip over that */</span>
    hibernateRestorePALState(src);

    <span class="enscript-comment">// -- copy back conflicts
</span>
    pageListPage = copyPageListHeadPage;
    <span class="enscript-keyword">while</span> (pageListPage)
    {
	copyPageList = (uint32_t *)pal_hib_map(COPY_PAGE_AREA, ptoa_64(pageListPage));
	<span class="enscript-keyword">for</span> (copyPageIndex = 2; copyPageIndex &lt; copyPageList[0]; copyPageIndex += 3)
	{
	    ppnum          = copyPageList[copyPageIndex + 0];
	    srcPhys        = ptoa_64(copyPageList[copyPageIndex + 1]);
	    src            = (uint32_t *) pal_hib_map(SRC_COPY_AREA, srcPhys);
	    compressedSize = copyPageList[copyPageIndex + 2];
	    stage 	   = compressedSize &gt;&gt; 24;
	    compressedSize &amp;= 0x1FFF;
	    pageSum        = store_one_page(gIOHibernateCurrentHeader-&gt;processorFlags,
			    			src, compressedSize, 0, ppnum);
	    <span class="enscript-keyword">if</span> (stage != 2)
	    	sum += pageSum;
	    uncompressedPages++;
	}
	pageListPage = copyPageList[1];
    }

    pal_hib_patchup();

    <span class="enscript-comment">// -- image has been destroyed...
</span>
    gIOHibernateCurrentHeader-&gt;actualImage1Sum         = sum;
    gIOHibernateCurrentHeader-&gt;actualUncompressedPages = uncompressedPages;
    gIOHibernateCurrentHeader-&gt;conflictCount           = conflictCount;
    gIOHibernateCurrentHeader-&gt;nextFree                = nextFree;

    gIOHibernateState = kIOHibernateStateWakingFromHibernate;

    gIOHibernateCurrentHeader-&gt;trampolineTime = (((rdtsc64() - timeStart)) &gt;&gt; 8);

<span class="enscript-comment">//  debug_code('done', 0);
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SLEEP</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
    <span class="enscript-type">typedef</span> <span class="enscript-type">void</span> (*ResetProc)(<span class="enscript-type">void</span>);
    ResetProc proc;
    proc = HIB_ENTRYPOINT;
    <span class="enscript-comment">// flush caches
</span>    __asm__(<span class="enscript-string">&quot;wbinvd&quot;</span>);
    proc();
#<span class="enscript-reference">else</span>
<span class="enscript-comment">// implement me
</span>#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">return</span> -1;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEBUG</span>
<span class="enscript-comment">/* standalone printf implementation */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1986, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">long</span> ptrdiff_t;
<span class="enscript-type">char</span> <span class="enscript-type">const</span> hibhex2ascii_data[] = <span class="enscript-string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span>;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">hibhex2ascii</span>(hex)  (hibhex2ascii_data[hex])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">toupper</span>(c)      ((c) - 0x20 * (((c) &gt;= <span class="enscript-string">'a'</span>) &amp;&amp; ((c) &lt;= <span class="enscript-string">'z'</span>)))
<span class="enscript-type">static</span> size_t
<span class="enscript-function-name">hibstrlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s)
{
	size_t l = 0;
	<span class="enscript-keyword">while</span> (*s++)
		l++;
	<span class="enscript-keyword">return</span> l;
}

<span class="enscript-comment">/* Max number conversion buffer length: a u_quad_t in base 2, plus NUL byte. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXNBUF</span>	(sizeof(intmax_t) * NBBY + 1)

<span class="enscript-comment">/*
 * Put a NUL-terminated ASCII number (base &lt;= 36) in a buffer in reverse
 * order; return an optional length and a pointer to the last character
 * written in the buffer (i.e., the first character of the string).
 * The buffer pointed to by `nbuf' must have length &gt;= MAXNBUF.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ksprintn</span>(<span class="enscript-type">char</span> *nbuf, uintmax_t num, <span class="enscript-type">int</span> base, <span class="enscript-type">int</span> *lenp, <span class="enscript-type">int</span> upper)
{
	<span class="enscript-type">char</span> *p, c;

	<span class="enscript-comment">/* Truncate so we don't call umoddi3, which isn't in __HIB */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	uint32_t num2 = (uint32_t) num;
#<span class="enscript-reference">else</span>
	uintmax_t num2 = num;
#<span class="enscript-reference">endif</span>

	p = nbuf;
	*p = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">do</span> {
		c = hibhex2ascii(num2 % base);
		*++p = upper ? toupper(c) : c;
	} <span class="enscript-keyword">while</span> (num2 /= base);
	<span class="enscript-keyword">if</span> (lenp)
		*lenp = (<span class="enscript-type">int</span>)(p - nbuf);
	<span class="enscript-keyword">return</span> (p);
}

<span class="enscript-comment">/*
 * Scaled down version of printf(3).
 *
 * Two additional formats:
 *
 * The format %b is supported to decode error registers.
 * Its usage is:
 *
 *	printf(&quot;reg=%b\n&quot;, regval, &quot;*&quot;);
 *
 * where  is the output base expressed as a control character, e.g.
 * \10 gives octal; \20 gives hex.  Each arg is a sequence of characters,
 * the first of which gives the bit number to be inspected (origin 1), and
 * the next characters (up to a control character, i.e. a character &lt;= 32),
 * give the name of the register.  Thus:
 *
 *	kvprintf(&quot;reg=%b\n&quot;, 3, &quot;\10\2BITTWO\1BITONE\n&quot;);
 *
 * would produce output:
 *
 *	reg=3
 *
 * XXX:  %D  -- Hexdump, takes pointer and separator string:
 *		(&quot;%6D&quot;, ptr, &quot;:&quot;)   -&gt; XX:XX:XX:XX:XX:XX
 *		(&quot;%*D&quot;, len, ptr, &quot; &quot; -&gt; XX XX XX XX ...
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hibkvprintf</span>(<span class="enscript-type">char</span> <span class="enscript-type">const</span> *fmt, <span class="enscript-type">void</span> (*func)(<span class="enscript-type">int</span>, <span class="enscript-type">void</span>*), <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> radix, va_list ap)
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PCHAR</span>(c) {int cc=(c); if (func) (*func)(cc,arg); else *d++ = cc; retval++; }
	<span class="enscript-type">char</span> nbuf[MAXNBUF];
	<span class="enscript-type">char</span> *d;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, *percent, *q;
	u_char *up;
	<span class="enscript-type">int</span> ch, n;
	uintmax_t num;
	<span class="enscript-type">int</span> base, lflag, qflag, tmp, width, ladjust, sharpflag, neg, sign, dot;
	<span class="enscript-type">int</span> cflag, hflag, jflag, tflag, zflag;
	<span class="enscript-type">int</span> dwidth, upper;
	<span class="enscript-type">char</span> padc;
	<span class="enscript-type">int</span> stop = 0, retval = 0;

	num = 0;
	<span class="enscript-keyword">if</span> (!func)
		d = (<span class="enscript-type">char</span> *) arg;
	<span class="enscript-keyword">else</span>
		d = NULL;

	<span class="enscript-keyword">if</span> (fmt == NULL)
		fmt = <span class="enscript-string">&quot;(fmt null)\n&quot;</span>;

	<span class="enscript-keyword">if</span> (radix &lt; 2 || radix &gt; 36)
		radix = 10;

	<span class="enscript-keyword">for</span> (;;) {
		padc = <span class="enscript-string">' '</span>;
		width = 0;
		<span class="enscript-keyword">while</span> ((ch = (u_char)*fmt++) != <span class="enscript-string">'%'</span> || stop) {
			<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">return</span> (retval);
			PCHAR(ch);
		}
		percent = fmt - 1;
		qflag = 0; lflag = 0; ladjust = 0; sharpflag = 0; neg = 0;
		sign = 0; dot = 0; dwidth = 0; upper = 0;
		cflag = 0; hflag = 0; jflag = 0; tflag = 0; zflag = 0;
<span class="enscript-reference">reswitch</span>:	<span class="enscript-keyword">switch</span> (ch = (u_char)*fmt++) {
		<span class="enscript-keyword">case</span> <span class="enscript-string">'.'</span>:
			dot = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'#'</span>:
			sharpflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'+'</span>:
			sign = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'-'</span>:
			ladjust = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'%'</span>:
			PCHAR(ch);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'*'</span>:
			<span class="enscript-keyword">if</span> (!dot) {
				width = va_arg(ap, <span class="enscript-type">int</span>);
				<span class="enscript-keyword">if</span> (width &lt; 0) {
					ladjust = !ladjust;
					width = -width;
				}
			} <span class="enscript-keyword">else</span> {
				dwidth = va_arg(ap, <span class="enscript-type">int</span>);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'0'</span>:
			<span class="enscript-keyword">if</span> (!dot) {
				padc = <span class="enscript-string">'0'</span>;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
			}
		<span class="enscript-keyword">case</span> <span class="enscript-string">'1'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'2'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'3'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'4'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'5'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'6'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'7'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'8'</span>: <span class="enscript-keyword">case</span> <span class="enscript-string">'9'</span>:
				<span class="enscript-keyword">for</span> (n = 0;; ++fmt) {
					n = n * 10 + ch - <span class="enscript-string">'0'</span>;
					ch = *fmt;
					<span class="enscript-keyword">if</span> (ch &lt; <span class="enscript-string">'0'</span> || ch &gt; <span class="enscript-string">'9'</span>)
						<span class="enscript-keyword">break</span>;
				}
			<span class="enscript-keyword">if</span> (dot)
				dwidth = n;
			<span class="enscript-keyword">else</span>
				width = n;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'b'</span>:
			num = (u_int)va_arg(ap, <span class="enscript-type">int</span>);
			p = va_arg(ap, <span class="enscript-type">char</span> *);
			<span class="enscript-keyword">for</span> (q = ksprintn(nbuf, num, *p++, NULL, 0); *q;)
				PCHAR(*q--);

			<span class="enscript-keyword">if</span> (num == 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">for</span> (tmp = 0; *p;) {
				n = *p++;
				<span class="enscript-keyword">if</span> (num &amp; (1 &lt;&lt; (n - 1))) {
					PCHAR(tmp ? <span class="enscript-string">','</span> : <span class="enscript-string">'&lt;'</span>);
					<span class="enscript-keyword">for</span> (; (n = *p) &gt; <span class="enscript-string">' '</span>; ++p)
						PCHAR(n);
					tmp = 1;
				} <span class="enscript-keyword">else</span>
					<span class="enscript-keyword">for</span> (; *p &gt; <span class="enscript-string">' '</span>; ++p)
						<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (tmp)
				PCHAR(<span class="enscript-string">'&gt;'</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:
			PCHAR(va_arg(ap, <span class="enscript-type">int</span>));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'D'</span>:
			up = va_arg(ap, u_char *);
			p = va_arg(ap, <span class="enscript-type">char</span> *);
			<span class="enscript-keyword">if</span> (!width)
				width = 16;
			<span class="enscript-keyword">while</span>(width--) {
				PCHAR(hibhex2ascii(*up &gt;&gt; 4));
				PCHAR(hibhex2ascii(*up &amp; 0x0f));
				up++;
				<span class="enscript-keyword">if</span> (width)
					<span class="enscript-keyword">for</span> (q=p;*q;q++)
						PCHAR(*q);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'d'</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-string">'i'</span>:
			base = 10;
			sign = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_sign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'h'</span>:
			<span class="enscript-keyword">if</span> (hflag) {
				hflag = 0;
				cflag = 1;
			} <span class="enscript-keyword">else</span>
				hflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'j'</span>:
			jflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'l'</span>:
			<span class="enscript-keyword">if</span> (lflag) {
				lflag = 0;
				qflag = 1;
			} <span class="enscript-keyword">else</span>
				lflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'n'</span>:
			<span class="enscript-keyword">if</span> (jflag)
				*(va_arg(ap, intmax_t *)) = retval;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qflag)
				*(va_arg(ap, quad_t *)) = retval;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lflag)
				*(va_arg(ap, <span class="enscript-type">long</span> *)) = retval;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zflag)
				*(va_arg(ap, size_t *)) = retval;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hflag)
				*(va_arg(ap, <span class="enscript-type">short</span> *)) = retval;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cflag)
				*(va_arg(ap, <span class="enscript-type">char</span> *)) = retval;
			<span class="enscript-keyword">else</span>
				*(va_arg(ap, <span class="enscript-type">int</span> *)) = retval;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'o'</span>:
			base = 8;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_nosign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'p'</span>:
			base = 16;
			sharpflag = (width == 0);
			sign = 0;
			num = (uintptr_t)va_arg(ap, <span class="enscript-type">void</span> *);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">number</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'q'</span>:
			qflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'r'</span>:
			base = radix;
			<span class="enscript-keyword">if</span> (sign)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_sign</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_nosign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'s'</span>:
			p = va_arg(ap, <span class="enscript-type">char</span> *);
			<span class="enscript-keyword">if</span> (p == NULL)
				p = <span class="enscript-string">&quot;(null)&quot;</span>;
			<span class="enscript-keyword">if</span> (!dot)
				n = (typeof(n))hibstrlen (p);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">for</span> (n = 0; n &lt; dwidth &amp;&amp; p[n]; n++)
					<span class="enscript-keyword">continue</span>;

			width -= n;

			<span class="enscript-keyword">if</span> (!ladjust &amp;&amp; width &gt; 0)
				<span class="enscript-keyword">while</span> (width--)
					PCHAR(padc);
			<span class="enscript-keyword">while</span> (n--)
				PCHAR(*p++);
			<span class="enscript-keyword">if</span> (ladjust &amp;&amp; width &gt; 0)
				<span class="enscript-keyword">while</span> (width--)
					PCHAR(padc);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'t'</span>:
			tflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'u'</span>:
			base = 10;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_nosign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'X'</span>:
			upper = 1;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'x'</span>:
			base = 16;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_nosign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'y'</span>:
			base = 16;
			sign = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_sign</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-string">'z'</span>:
			zflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reswitch</span>;
<span class="enscript-reference">handle_nosign</span>:
			sign = 0;
			<span class="enscript-keyword">if</span> (jflag)
				num = va_arg(ap, uintmax_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qflag)
				num = va_arg(ap, u_quad_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tflag)
				num = va_arg(ap, ptrdiff_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lflag)
				num = va_arg(ap, u_long);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zflag)
				num = va_arg(ap, size_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hflag)
				num = (u_short)va_arg(ap, <span class="enscript-type">int</span>);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cflag)
				num = (u_char)va_arg(ap, <span class="enscript-type">int</span>);
			<span class="enscript-keyword">else</span>
				num = va_arg(ap, u_int);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">number</span>;
<span class="enscript-reference">handle_sign</span>:
			<span class="enscript-keyword">if</span> (jflag)
				num = va_arg(ap, intmax_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (qflag)
				num = va_arg(ap, quad_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tflag)
				num = va_arg(ap, ptrdiff_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lflag)
				num = va_arg(ap, <span class="enscript-type">long</span>);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zflag)
				num = va_arg(ap, ssize_t);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hflag)
				num = (<span class="enscript-type">short</span>)va_arg(ap, <span class="enscript-type">int</span>);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cflag)
				num = (<span class="enscript-type">char</span>)va_arg(ap, <span class="enscript-type">int</span>);
			<span class="enscript-keyword">else</span>
				num = va_arg(ap, <span class="enscript-type">int</span>);
<span class="enscript-reference">number</span>:
			<span class="enscript-keyword">if</span> (sign &amp;&amp; (intmax_t)num &lt; 0) {
				neg = 1;
				num = -(intmax_t)num;
			}
			p = ksprintn(nbuf, num, base, &amp;tmp, upper);
			<span class="enscript-keyword">if</span> (sharpflag &amp;&amp; num != 0) {
				<span class="enscript-keyword">if</span> (base == 8)
					tmp++;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (base == 16)
					tmp += 2;
			}
			<span class="enscript-keyword">if</span> (neg)
				tmp++;

			<span class="enscript-keyword">if</span> (!ladjust &amp;&amp; padc != <span class="enscript-string">'0'</span> &amp;&amp; width
			    &amp;&amp; (width -= tmp) &gt; 0)
				<span class="enscript-keyword">while</span> (width--)
					PCHAR(padc);
			<span class="enscript-keyword">if</span> (neg)
				PCHAR(<span class="enscript-string">'-'</span>);
			<span class="enscript-keyword">if</span> (sharpflag &amp;&amp; num != 0) {
				<span class="enscript-keyword">if</span> (base == 8) {
					PCHAR(<span class="enscript-string">'0'</span>);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (base == 16) {
					PCHAR(<span class="enscript-string">'0'</span>);
					PCHAR(<span class="enscript-string">'x'</span>);
				}
			}
			<span class="enscript-keyword">if</span> (!ladjust &amp;&amp; width &amp;&amp; (width -= tmp) &gt; 0)
				<span class="enscript-keyword">while</span> (width--)
					PCHAR(padc);

			<span class="enscript-keyword">while</span> (*p)
				PCHAR(*p--);

			<span class="enscript-keyword">if</span> (ladjust &amp;&amp; width &amp;&amp; (width -= tmp) &gt; 0)
				<span class="enscript-keyword">while</span> (width--)
					PCHAR(padc);

			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">while</span> (percent &lt; fmt)
				PCHAR(*percent++);
			<span class="enscript-comment">/*
			 * Since we ignore an formatting argument it is no
			 * longer safe to obey the remaining formatting
			 * arguments as the arguments will no longer match
			 * the format specs.
			 */</span>
			stop = 1;
			<span class="enscript-keyword">break</span>;
		}
	}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">PCHAR</span>
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">putchar</span>(<span class="enscript-type">int</span> c, <span class="enscript-type">void</span> *arg)
{
	(<span class="enscript-type">void</span>)arg;
	uart_putc(c);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hibprintf</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	<span class="enscript-comment">/* <a href="http://www.pagetable.com/?p=298">http://www.pagetable.com/?p=298</a> */</span>
	va_list ap;

	va_start(ap, fmt);
	hibkvprintf(fmt, putchar, NULL, 10, ap);
	va_end(ap);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DEBUG */</span>

</pre>
<hr />
</body></html>