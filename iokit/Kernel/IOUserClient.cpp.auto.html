<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>IOUserClient.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">IOUserClient.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/c++/OSKext.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitServer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitKeysPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOUserClient.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOService.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IORegistryEntry.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOCatalogue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBufferMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOStatisticsPrivate.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOTimeStamp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
};
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IOMACF_LOG</span> 0

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOServicePrivate.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;IOKitKernelInternal.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SCALAR64</span>(x) ((io_user_scalar_t)((unsigned int)x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SCALAR32</span>(x) ((uint32_t )x)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ARG32</span>(x)    ((void *)(uintptr_t)SCALAR32(x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">REF64</span>(x)    ((io_user_reference_t)((UInt64)(x)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">REF32</span>(x)    ((int)(x))

<span class="enscript-type">enum</span>
{
    kIOUCAsync0Flags = 3ULL,
    kIOUCAsync64Flag = 1ULL
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IOKITSTATS</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsRegisterCounter</span>() \
<span class="enscript-keyword">do</span> { \
	reserved-&gt;counter = IOStatistics::registerUserClient(<span class="enscript-keyword">this</span>); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsUnregisterCounter</span>() \
<span class="enscript-keyword">do</span> { \
	<span class="enscript-keyword">if</span> (reserved) \
		<span class="enscript-reference">IOStatistics</span>::unregisterUserClient(reserved-&gt;counter); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsClientCall</span>() \
<span class="enscript-keyword">do</span> { \
	<span class="enscript-reference">IOStatistics</span>::countUserClientCall(client); \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsRegisterCounter</span>()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsUnregisterCounter</span>()
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IOStatisticsClientCall</span>()

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IOKITSTATS */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// definitions we should get from osfmk
</span>
<span class="enscript-comment">//typedef struct ipc_port * ipc_port_t;
</span><span class="enscript-type">typedef</span> natural_t ipc_kobject_type_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IKOT_IOKIT_SPARE</span>	27
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IKOT_IOKIT_CONNECT</span>	29
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IKOT_IOKIT_OBJECT</span>	30

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

<span class="enscript-type">extern</span> ipc_port_t <span class="enscript-function-name">iokit_alloc_object_port</span>( io_object_t obj,
			ipc_kobject_type_t type );

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">iokit_destroy_object_port</span>( ipc_port_t port );

<span class="enscript-type">extern</span> mach_port_name_t <span class="enscript-function-name">iokit_make_send_right</span>( task_t task,
				io_object_t obj, ipc_kobject_type_t type );

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">iokit_mod_send_right</span>( task_t task, mach_port_name_t name, mach_port_delta_t delta );

<span class="enscript-type">extern</span> io_object_t <span class="enscript-function-name">iokit_lookup_connect_ref</span>(io_object_t clientRef, ipc_space_t task);

<span class="enscript-type">extern</span> io_object_t <span class="enscript-function-name">iokit_lookup_connect_ref_current_task</span>(io_object_t clientRef);

<span class="enscript-type">extern</span> ipc_port_t master_device_port;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">iokit_retain_port</span>( ipc_port_t port );
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">iokit_release_port</span>( ipc_port_t port );
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">iokit_release_port_send</span>( ipc_port_t port );

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">iokit_switch_object_port</span>( ipc_port_t port, io_object_t obj, ipc_kobject_type_t type );

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_traps.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// IOMachPort maps OSObjects to ports, avoiding adding an ivar to OSObject.
</span>
<span class="enscript-type">class</span> IOMachPort : <span class="enscript-type">public</span> OSObject
{
    OSDeclareDefaultStructors(IOMachPort)
<span class="enscript-type">public</span>:
    OSObject *	object;
    ipc_port_t	port;
    UInt32      mscount;
    UInt8	holdDestroy;

    <span class="enscript-type">static</span> IOMachPort * portForObject( OSObject * obj,
				ipc_kobject_type_t type );
    <span class="enscript-type">static</span> <span class="enscript-type">bool</span> noMoreSendersForObject( OSObject * obj,
				ipc_kobject_type_t type, mach_port_mscount_t * mscount );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> releasePortForObject( OSObject * obj,
				ipc_kobject_type_t type );
    <span class="enscript-type">static</span> <span class="enscript-type">void</span> setHoldDestroy( OSObject * obj, ipc_kobject_type_t type );

    <span class="enscript-type">static</span> OSDictionary * dictForType( ipc_kobject_type_t type );

    <span class="enscript-type">static</span> mach_port_name_t makeSendRightForTask( task_t task,
				io_object_t obj, ipc_kobject_type_t type );

    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSObject
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOMachPort, OSObject)

<span class="enscript-type">static</span> IOLock *		gIOObjectPortLock;

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// not in dictForType() for debugging ease
</span><span class="enscript-type">static</span> OSDictionary *	gIOObjectPorts;
<span class="enscript-type">static</span> OSDictionary *	gIOConnectPorts;

OSDictionary * <span class="enscript-function-name">IOMachPort::dictForType</span>( ipc_kobject_type_t type )
{
    OSDictionary **	 	dict;

    <span class="enscript-keyword">if</span>( IKOT_IOKIT_OBJECT == type )
	dict = &amp;gIOObjectPorts;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( IKOT_IOKIT_CONNECT == type )
	dict = &amp;gIOConnectPorts;
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span>( 0 );

    <span class="enscript-keyword">if</span>( 0 == *dict)
        *dict = OSDictionary::withCapacity( 1 );

    <span class="enscript-keyword">return</span>( *dict );
}

IOMachPort * <span class="enscript-function-name">IOMachPort::portForObject</span> ( OSObject * obj,
				ipc_kobject_type_t type )
{
    IOMachPort * 	inst = 0;
    OSDictionary *	dict;

    IOTakeLock( gIOObjectPortLock);

    <span class="enscript-keyword">do</span> {

	dict = dictForType( type );
	<span class="enscript-keyword">if</span>( !dict)
	    <span class="enscript-keyword">continue</span>;

        <span class="enscript-keyword">if</span>( (inst = (IOMachPort *)
                dict-&gt;getObject( (<span class="enscript-type">const</span> OSSymbol *) obj ))) {
	    inst-&gt;mscount++;
	    inst-&gt;retain();
            <span class="enscript-keyword">continue</span>;
	}

        inst = <span class="enscript-keyword">new</span> IOMachPort;
        <span class="enscript-keyword">if</span>( inst &amp;&amp; !inst-&gt;init()) {
            inst = 0;
            <span class="enscript-keyword">continue</span>;
	}

        inst-&gt;port = iokit_alloc_object_port( obj, type );
        <span class="enscript-keyword">if</span>( inst-&gt;port) {
	    <span class="enscript-comment">// retains obj
</span>            dict-&gt;setObject( (<span class="enscript-type">const</span> OSSymbol *) obj, inst );
	    inst-&gt;mscount++;

        } <span class="enscript-keyword">else</span> {
            inst-&gt;release();
            inst = 0;
        }

    } <span class="enscript-keyword">while</span>( false );

    IOUnlock( gIOObjectPortLock);

    <span class="enscript-keyword">return</span>( inst );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOMachPort::noMoreSendersForObject</span>( OSObject * obj,
				ipc_kobject_type_t type, mach_port_mscount_t * mscount )
{
    OSDictionary *	dict;
    IOMachPort *	machPort;
    <span class="enscript-type">bool</span>		destroyed = true;

    IOTakeLock( gIOObjectPortLock);

    <span class="enscript-keyword">if</span>( (dict = dictForType( type ))) {
        obj-&gt;retain();

	machPort = (IOMachPort *) dict-&gt;getObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
	<span class="enscript-keyword">if</span>( machPort) {
	    destroyed = (machPort-&gt;mscount &lt;= *mscount);
	    <span class="enscript-keyword">if</span>( destroyed)
		dict-&gt;removeObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
	    <span class="enscript-keyword">else</span>
		*mscount = machPort-&gt;mscount;
	} 
	obj-&gt;release();
    }

    IOUnlock( gIOObjectPortLock);

    <span class="enscript-keyword">return</span>( destroyed );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMachPort::releasePortForObject</span>( OSObject * obj,
				ipc_kobject_type_t type )
{
    OSDictionary *	dict;
    IOMachPort *	machPort;

    IOTakeLock( gIOObjectPortLock);

    <span class="enscript-keyword">if</span>( (dict = dictForType( type ))) {
        obj-&gt;retain();
	machPort = (IOMachPort *) dict-&gt;getObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
	<span class="enscript-keyword">if</span>( machPort &amp;&amp; !machPort-&gt;holdDestroy)
            dict-&gt;removeObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
        obj-&gt;release();
    }

    IOUnlock( gIOObjectPortLock);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMachPort::setHoldDestroy</span>( OSObject * obj, ipc_kobject_type_t type )
{
    OSDictionary *	dict;
    IOMachPort * 	machPort;

    IOLockLock( gIOObjectPortLock );

    <span class="enscript-keyword">if</span>( (dict = dictForType( type ))) {
        machPort = (IOMachPort *) dict-&gt;getObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
        <span class="enscript-keyword">if</span>( machPort)
            machPort-&gt;holdDestroy = true;
    }

    IOLockUnlock( gIOObjectPortLock );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::destroyUserReferences</span>( OSObject * obj )
{
    <span class="enscript-reference">IOMachPort</span>::releasePortForObject( obj, IKOT_IOKIT_OBJECT );

    <span class="enscript-comment">// panther, 3160200
</span>    <span class="enscript-comment">// IOMachPort::releasePortForObject( obj, IKOT_IOKIT_CONNECT );
</span>
    OSDictionary * dict;

    IOTakeLock( gIOObjectPortLock);
    obj-&gt;retain();

    <span class="enscript-keyword">if</span>( (dict = IOMachPort::dictForType( IKOT_IOKIT_CONNECT )))
    {
	IOMachPort * port;
	port = (IOMachPort *) dict-&gt;getObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
	<span class="enscript-keyword">if</span> (port)
	{
	    IOUserClient * uc;
	    <span class="enscript-keyword">if</span> ((uc = OSDynamicCast(IOUserClient, obj)) &amp;&amp; uc-&gt;mappings)
	    {
		dict-&gt;setObject((<span class="enscript-type">const</span> OSSymbol *) uc-&gt;mappings, port);
		iokit_switch_object_port(port-&gt;port, uc-&gt;mappings, IKOT_IOKIT_CONNECT);

		uc-&gt;mappings-&gt;release();
		uc-&gt;mappings = 0;
	    }
	    dict-&gt;removeObject( (<span class="enscript-type">const</span> OSSymbol *) obj );
	}
    }
    obj-&gt;release();
    IOUnlock( gIOObjectPortLock);
}

mach_port_name_t <span class="enscript-function-name">IOMachPort::makeSendRightForTask</span>( task_t task,
				io_object_t obj, ipc_kobject_type_t type )
{
    <span class="enscript-keyword">return</span>( iokit_make_send_right( task, obj, type ));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOMachPort::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>( port)
	iokit_destroy_object_port( port );
    <span class="enscript-reference">super</span>::free();
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">class</span> IOUserNotification : <span class="enscript-type">public</span> OSIterator
{
    OSDeclareDefaultStructors(IOUserNotification)

    IONotifier 	* 	holdNotify;
    IOLock 	*	lock;

<span class="enscript-type">public</span>:

    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span> init( <span class="enscript-type">void</span> ) APPLE_KEXT_OVERRIDE;
    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> setNotification( IONotifier * obj );

    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> reset() APPLE_KEXT_OVERRIDE;
    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span> isValid() APPLE_KEXT_OVERRIDE;
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>
<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

<span class="enscript-comment">// functions called from osfmk/device/iokit_rpc.c
</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">iokit_add_reference</span>( io_object_t obj )
{
    <span class="enscript-keyword">if</span>( obj)
	obj-&gt;retain();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">iokit_remove_reference</span>( io_object_t obj )
{
    <span class="enscript-keyword">if</span>( obj)
	obj-&gt;release();
}

ipc_port_t
<span class="enscript-function-name">iokit_port_for_object</span>( io_object_t obj, ipc_kobject_type_t type )
{
    IOMachPort * machPort;
    ipc_port_t	 port;

    <span class="enscript-keyword">if</span>( (machPort = IOMachPort::portForObject( obj, type ))) {

	port = machPort-&gt;port;
	<span class="enscript-keyword">if</span>( port)
	    iokit_retain_port( port );

	machPort-&gt;release();

    } <span class="enscript-keyword">else</span>
	port = NULL;

    <span class="enscript-keyword">return</span>( port );
}

kern_return_t
<span class="enscript-function-name">iokit_client_died</span>( io_object_t obj, ipc_port_t <span class="enscript-comment">/* port */</span>,
			ipc_kobject_type_t type, mach_port_mscount_t * mscount )
{
    IOUserClient *	client;
    IOMemoryMap *	map;
    IOUserNotification * notify;

    <span class="enscript-keyword">if</span>( !IOMachPort::noMoreSendersForObject( obj, type, mscount ))
	<span class="enscript-keyword">return</span>( kIOReturnNotReady );

    <span class="enscript-keyword">if</span>( IKOT_IOKIT_CONNECT == type)
    {
	<span class="enscript-keyword">if</span>( (client = OSDynamicCast( IOUserClient, obj ))) {
		IOStatisticsClientCall();
	    client-&gt;clientDied();
    }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( IKOT_IOKIT_OBJECT == type)
    {
	<span class="enscript-keyword">if</span>( (map = OSDynamicCast( IOMemoryMap, obj )))
	    map-&gt;taskDied();
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (notify = OSDynamicCast( IOUserNotification, obj )))
	    notify-&gt;setNotification( 0 );
    }

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

};	<span class="enscript-comment">/* extern &quot;C&quot; */</span>

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">class</span> IOServiceUserNotification : <span class="enscript-type">public</span> IOUserNotification
{
    OSDeclareDefaultStructors(IOServiceUserNotification)

    <span class="enscript-type">struct</span> PingMsg {
        mach_msg_header_t		msgHdr;
        OSNotificationHeader64		notifyHeader;
    };

    <span class="enscript-type">enum</span> { kMaxOutstanding = 1024 };

    PingMsg	*	pingMsg;
    vm_size_t		msgSize;
    OSArray 	*	newSet;
    OSObject	*	lastEntry;
    <span class="enscript-type">bool</span>		armed;

<span class="enscript-type">public</span>:

    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span> init( mach_port_t port, natural_t type,
                       <span class="enscript-type">void</span> * reference, vm_size_t referenceSize,
		       <span class="enscript-type">bool</span> clientIs64 );
    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;

    <span class="enscript-type">static</span> <span class="enscript-type">bool</span> _handler( <span class="enscript-type">void</span> * target,
                          <span class="enscript-type">void</span> * ref, IOService * newService, IONotifier * notifier );
    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span> handler( <span class="enscript-type">void</span> * ref, IOService * newService );

    <span class="enscript-type">virtual</span> OSObject * getNextObject() APPLE_KEXT_OVERRIDE;
};

<span class="enscript-type">class</span> IOServiceMessageUserNotification : <span class="enscript-type">public</span> IOUserNotification
{
    OSDeclareDefaultStructors(IOServiceMessageUserNotification)

    <span class="enscript-type">struct</span> PingMsg {
        mach_msg_header_t		msgHdr;
	mach_msg_body_t			msgBody;
	mach_msg_port_descriptor_t	ports[1];
        OSNotificationHeader64		notifyHeader __attribute__ ((packed));
    };

    PingMsg *		pingMsg;
    vm_size_t		msgSize;
    uint8_t		clientIs64;
    <span class="enscript-type">int</span>			owningPID;

<span class="enscript-type">public</span>:

    <span class="enscript-type">virtual</span> <span class="enscript-type">bool</span> init( mach_port_t port, natural_t type,
		       <span class="enscript-type">void</span> * reference, vm_size_t referenceSize,
		       vm_size_t extraSize,
		       <span class="enscript-type">bool</span> clientIs64 );

    <span class="enscript-type">virtual</span> <span class="enscript-type">void</span> free() APPLE_KEXT_OVERRIDE;
    
    <span class="enscript-type">static</span> IOReturn _handler( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                              UInt32 messageType, IOService * provider,
                              <span class="enscript-type">void</span> * messageArgument, vm_size_t argSize );
    <span class="enscript-type">virtual</span> IOReturn handler( <span class="enscript-type">void</span> * ref,
                              UInt32 messageType, IOService * provider,
                              <span class="enscript-type">void</span> * messageArgument, vm_size_t argSize );

    <span class="enscript-type">virtual</span> OSObject * getNextObject() APPLE_KEXT_OVERRIDE;
};

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> OSIterator
<span class="enscript-function-name">OSDefineMetaClass</span>( IOUserNotification, OSIterator )
<span class="enscript-function-name">OSDefineAbstractStructors</span>( IOUserNotification, OSIterator )

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserNotification::init</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>( !super::init())
	<span class="enscript-keyword">return</span>( false );

    lock = IOLockAlloc();
    <span class="enscript-keyword">if</span>( !lock)
        <span class="enscript-keyword">return</span>( false );

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserNotification::free</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">if</span>( holdNotify)
	holdNotify-&gt;remove();
    <span class="enscript-comment">// can't be in handler now
</span>
    <span class="enscript-keyword">if</span>( lock)
	IOLockFree( lock );

    <span class="enscript-reference">super</span>::free();
}


<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserNotification::setNotification</span>( IONotifier * notify )
{
    IONotifier * previousNotify;

    IOLockLock( gIOObjectPortLock);

    previousNotify = holdNotify;
    holdNotify = notify;

    IOLockUnlock( gIOObjectPortLock);

    <span class="enscript-keyword">if</span>( previousNotify)
	previousNotify-&gt;remove();
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserNotification::reset</span>()
{
    <span class="enscript-comment">// ?
</span>}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserNotification::isValid</span>()
{
    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOUserNotification
<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOServiceUserNotification, IOUserNotification)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOServiceUserNotification::init</span>( mach_port_t port, natural_t type,
				       <span class="enscript-type">void</span> * reference, vm_size_t referenceSize,
				       <span class="enscript-type">bool</span> clientIs64 )
{
    <span class="enscript-keyword">if</span>( !super::init())
        <span class="enscript-keyword">return</span>( false );

    newSet = OSArray::withCapacity( 1 );
    <span class="enscript-keyword">if</span>( !newSet)
        <span class="enscript-keyword">return</span>( false );

    <span class="enscript-keyword">if</span> (referenceSize &gt; <span class="enscript-keyword">sizeof</span>(OSAsyncReference64))
        <span class="enscript-keyword">return</span>( false );

    msgSize = <span class="enscript-keyword">sizeof</span>(PingMsg) - <span class="enscript-keyword">sizeof</span>(OSAsyncReference64) + referenceSize;
    pingMsg = (PingMsg *) IOMalloc( msgSize);
    <span class="enscript-keyword">if</span>( !pingMsg)
        <span class="enscript-keyword">return</span>( false );

    bzero( pingMsg, msgSize);

    pingMsg-&gt;msgHdr.msgh_remote_port	= port;
    pingMsg-&gt;msgHdr.msgh_bits 		= MACH_MSGH_BITS(
                                            MACH_MSG_TYPE_COPY_SEND <span class="enscript-comment">/*remote*/</span>,
                                            MACH_MSG_TYPE_MAKE_SEND <span class="enscript-comment">/*local*/</span>);
    pingMsg-&gt;msgHdr.msgh_size 		= msgSize;
    pingMsg-&gt;msgHdr.msgh_id		= kOSNotificationMessageID;

    pingMsg-&gt;notifyHeader.size = 0;
    pingMsg-&gt;notifyHeader.type = type;
    bcopy( reference, pingMsg-&gt;notifyHeader.reference, referenceSize );

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOServiceUserNotification::free</span>( <span class="enscript-type">void</span> )
{
    PingMsg   *	_pingMsg;
    vm_size_t	_msgSize;
    OSArray   *	_newSet;
    OSObject  *	_lastEntry;

    _pingMsg   = pingMsg;
    _msgSize   = msgSize;
    _lastEntry = lastEntry;
    _newSet    = newSet;

    <span class="enscript-reference">super</span>::free();

    <span class="enscript-keyword">if</span>( _pingMsg &amp;&amp; _msgSize) {
		<span class="enscript-keyword">if</span> (_pingMsg-&gt;msgHdr.msgh_remote_port) {
			iokit_release_port_send(_pingMsg-&gt;msgHdr.msgh_remote_port);
		}
        IOFree(_pingMsg, _msgSize);
	}

    <span class="enscript-keyword">if</span>( _lastEntry)
        _lastEntry-&gt;release();

    <span class="enscript-keyword">if</span>( _newSet)
        _newSet-&gt;release();
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOServiceUserNotification::_handler</span>( <span class="enscript-type">void</span> * target,
                                    <span class="enscript-type">void</span> * ref, IOService * newService, IONotifier * notifier )
{
    <span class="enscript-keyword">return</span>( ((IOServiceUserNotification *) target)-&gt;handler( ref, newService ));
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOServiceUserNotification::handler</span>( <span class="enscript-type">void</span> * ref,
                                IOService * newService )
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	count;
    kern_return_t	kr;
    ipc_port_t		port = NULL;
    <span class="enscript-type">bool</span>		sendPing = false;

    IOTakeLock( lock );

    count = newSet-&gt;getCount();
    <span class="enscript-keyword">if</span>( count &lt; kMaxOutstanding) {

        newSet-&gt;setObject( newService );
        <span class="enscript-keyword">if</span>( (sendPing = (armed &amp;&amp; (0 == count))))
            armed = false;
    }

    IOUnlock( lock );

    <span class="enscript-keyword">if</span>( kIOServiceTerminatedNotificationType == pingMsg-&gt;notifyHeader.type)
        <span class="enscript-reference">IOMachPort</span>::setHoldDestroy( newService, IKOT_IOKIT_OBJECT );

    <span class="enscript-keyword">if</span>( sendPing) {
	<span class="enscript-keyword">if</span>( (port = iokit_port_for_object( <span class="enscript-keyword">this</span>, IKOT_IOKIT_OBJECT ) ))
            pingMsg-&gt;msgHdr.msgh_local_port = port;
	<span class="enscript-keyword">else</span>
            pingMsg-&gt;msgHdr.msgh_local_port = NULL;

        kr = mach_msg_send_from_kernel_with_options( &amp;pingMsg-&gt;msgHdr,
						     pingMsg-&gt;msgHdr.msgh_size,
						     (MACH_SEND_MSG | MACH_SEND_ALWAYS | MACH_SEND_IMPORTANCE),
						     0);
	<span class="enscript-keyword">if</span>( port)
	    iokit_release_port( port );

        <span class="enscript-keyword">if</span>( KERN_SUCCESS != kr)
            IOLog(<span class="enscript-string">&quot;%s: mach_msg_send_from_kernel_proper {%x}\n&quot;</span>, __FILE__, kr );
    }

    <span class="enscript-keyword">return</span>( true );
}

OSObject * <span class="enscript-function-name">IOServiceUserNotification::getNextObject</span>()
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	count;
    OSObject *		result;

    IOTakeLock( lock );

    <span class="enscript-keyword">if</span>( lastEntry)
        lastEntry-&gt;release();

    count = newSet-&gt;getCount();
    <span class="enscript-keyword">if</span>( count ) {
        result = newSet-&gt;getObject( count - 1 );
        result-&gt;retain();
        newSet-&gt;removeObject( count - 1);
    } <span class="enscript-keyword">else</span> {
        result = 0;
        armed = true;
    }
    lastEntry = result;

    IOUnlock( lock );

    <span class="enscript-keyword">return</span>( result );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-function-name">OSDefineMetaClassAndStructors</span>(IOServiceMessageUserNotification, IOUserNotification)

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOServiceMessageUserNotification::init</span>( mach_port_t port, natural_t type,
				<span class="enscript-type">void</span> * reference, vm_size_t referenceSize, vm_size_t extraSize,
				<span class="enscript-type">bool</span> client64 )
{
    <span class="enscript-keyword">if</span>( !super::init())
        <span class="enscript-keyword">return</span>( false );

    <span class="enscript-keyword">if</span> (referenceSize &gt; <span class="enscript-keyword">sizeof</span>(OSAsyncReference64))
        <span class="enscript-keyword">return</span>( false );

    clientIs64 = client64;

    owningPID = proc_selfpid();

    extraSize += <span class="enscript-keyword">sizeof</span>(IOServiceInterestContent64);
    msgSize = <span class="enscript-keyword">sizeof</span>(PingMsg) - <span class="enscript-keyword">sizeof</span>(OSAsyncReference64) + referenceSize + extraSize;
    pingMsg = (PingMsg *) IOMalloc( msgSize);
    <span class="enscript-keyword">if</span>( !pingMsg)
        <span class="enscript-keyword">return</span>( false );

    bzero( pingMsg, msgSize);

    pingMsg-&gt;msgHdr.msgh_remote_port	= port;
    pingMsg-&gt;msgHdr.msgh_bits 		= MACH_MSGH_BITS_COMPLEX
					|  MACH_MSGH_BITS(
                                            MACH_MSG_TYPE_COPY_SEND <span class="enscript-comment">/*remote*/</span>,
                                            MACH_MSG_TYPE_MAKE_SEND <span class="enscript-comment">/*local*/</span>);
    pingMsg-&gt;msgHdr.msgh_size 		= msgSize;
    pingMsg-&gt;msgHdr.msgh_id		= kOSNotificationMessageID;

    pingMsg-&gt;msgBody.msgh_descriptor_count = 1;

    pingMsg-&gt;ports[0].name 		= 0;
    pingMsg-&gt;ports[0].disposition 	= MACH_MSG_TYPE_MAKE_SEND;
    pingMsg-&gt;ports[0].type 		= MACH_MSG_PORT_DESCRIPTOR;

    pingMsg-&gt;notifyHeader.size 		= extraSize;
    pingMsg-&gt;notifyHeader.type 		= type;
    bcopy( reference, pingMsg-&gt;notifyHeader.reference, referenceSize );

    <span class="enscript-keyword">return</span>( true );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOServiceMessageUserNotification::free</span>( <span class="enscript-type">void</span> )
{
    PingMsg *	_pingMsg;
    vm_size_t	_msgSize;

    _pingMsg   = pingMsg;
    _msgSize   = msgSize;

    <span class="enscript-reference">super</span>::free();

    <span class="enscript-keyword">if</span>( _pingMsg &amp;&amp; _msgSize) {
		<span class="enscript-keyword">if</span> (_pingMsg-&gt;msgHdr.msgh_remote_port) {
			iokit_release_port_send(_pingMsg-&gt;msgHdr.msgh_remote_port);
		}
        IOFree( _pingMsg, _msgSize);
	}
}

IOReturn <span class="enscript-function-name">IOServiceMessageUserNotification::_handler</span>( <span class="enscript-type">void</span> * target, <span class="enscript-type">void</span> * ref,
                                            UInt32 messageType, IOService * provider,
                                            <span class="enscript-type">void</span> * argument, vm_size_t argSize )
{
    <span class="enscript-keyword">return</span>( ((IOServiceMessageUserNotification *) target)-&gt;handler(
                                ref, messageType, provider, argument, argSize));
}

IOReturn <span class="enscript-function-name">IOServiceMessageUserNotification::handler</span>( <span class="enscript-type">void</span> * ref,
                                    UInt32 messageType, IOService * provider,
                                    <span class="enscript-type">void</span> * messageArgument, vm_size_t argSize )
{
    kern_return_t		 kr;
    ipc_port_t 			 thisPort, providerPort;
    IOServiceInterestContent64 * data = (IOServiceInterestContent64 *)
					((((uint8_t *) pingMsg) + msgSize) - pingMsg-&gt;notifyHeader.size);
                                        <span class="enscript-comment">// == pingMsg-&gt;notifyHeader.content;
</span>
    <span class="enscript-keyword">if</span> (kIOMessageCopyClientID == messageType)
    {
        *((<span class="enscript-type">void</span> **) messageArgument) = OSNumber::withNumber(owningPID, 32);
        <span class="enscript-keyword">return</span> (kIOReturnSuccess);
    }

    data-&gt;messageType = messageType;

    <span class="enscript-keyword">if</span>( argSize == 0)
    {
	data-&gt;messageArgument[0] = (io_user_reference_t) messageArgument;
	<span class="enscript-keyword">if</span> (clientIs64)
	    argSize = <span class="enscript-keyword">sizeof</span>(data-&gt;messageArgument[0]);
	<span class="enscript-keyword">else</span>
	{
	    data-&gt;messageArgument[0] |= (data-&gt;messageArgument[0] &lt;&lt; 32);
	    argSize = <span class="enscript-keyword">sizeof</span>(uint32_t);
	}
    }
    <span class="enscript-keyword">else</span>
    {
        <span class="enscript-keyword">if</span>( argSize &gt; kIOUserNotifyMaxMessageSize)
            argSize = kIOUserNotifyMaxMessageSize;
        bcopy( messageArgument, data-&gt;messageArgument, argSize );
    }

    <span class="enscript-comment">// adjust message size for ipc restrictions
</span>    natural_t type;
    type = pingMsg-&gt;notifyHeader.type;
    type &amp;= ~(kIOKitNoticationMsgSizeMask &lt;&lt; kIOKitNoticationTypeSizeAdjShift);
    type |= ((argSize &amp; kIOKitNoticationMsgSizeMask) &lt;&lt; kIOKitNoticationTypeSizeAdjShift);
    pingMsg-&gt;notifyHeader.type = type;
    argSize = (argSize + kIOKitNoticationMsgSizeMask) &amp; ~kIOKitNoticationMsgSizeMask;

    pingMsg-&gt;msgHdr.msgh_size = msgSize - pingMsg-&gt;notifyHeader.size
        + <span class="enscript-keyword">sizeof</span>( IOServiceInterestContent64 )
        - <span class="enscript-keyword">sizeof</span>( data-&gt;messageArgument)
        + argSize;

    providerPort = iokit_port_for_object( provider, IKOT_IOKIT_OBJECT );
    pingMsg-&gt;ports[0].name = providerPort;
    thisPort = iokit_port_for_object( <span class="enscript-keyword">this</span>, IKOT_IOKIT_OBJECT );
    pingMsg-&gt;msgHdr.msgh_local_port = thisPort;
    kr = mach_msg_send_from_kernel_with_options( &amp;pingMsg-&gt;msgHdr,
						 pingMsg-&gt;msgHdr.msgh_size,
						 (MACH_SEND_MSG | MACH_SEND_ALWAYS | MACH_SEND_IMPORTANCE),
						 0);
    <span class="enscript-keyword">if</span>( thisPort)
	iokit_release_port( thisPort );
    <span class="enscript-keyword">if</span>( providerPort)
	iokit_release_port( providerPort );

    <span class="enscript-keyword">if</span>( KERN_SUCCESS != kr)
        IOLog(<span class="enscript-string">&quot;%s: mach_msg_send_from_kernel_proper {%x}\n&quot;</span>, __FILE__, kr );

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

OSObject * <span class="enscript-function-name">IOServiceMessageUserNotification::getNextObject</span>()
{
    <span class="enscript-keyword">return</span>( 0 );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">super</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">super</span> IOService
<span class="enscript-function-name">OSDefineMetaClassAndAbstractStructors</span>( IOUserClient, IOService )

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::initialize</span>( <span class="enscript-type">void</span> )
{
    gIOObjectPortLock = IOLockAlloc();

    assert( gIOObjectPortLock );
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::setAsyncReference</span>(OSAsyncReference asyncRef,
                                     mach_port_t wakePort,
                                     <span class="enscript-type">void</span> *callback, <span class="enscript-type">void</span> *refcon)
{
    asyncRef[kIOAsyncReservedIndex]      = ((uintptr_t) wakePort) 
					 | (kIOUCAsync0Flags &amp; asyncRef[kIOAsyncReservedIndex]);
    asyncRef[kIOAsyncCalloutFuncIndex]   = (uintptr_t) callback;
    asyncRef[kIOAsyncCalloutRefconIndex] = (uintptr_t) refcon;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::setAsyncReference64</span>(OSAsyncReference64 asyncRef,
					mach_port_t wakePort,
					mach_vm_address_t callback, io_user_reference_t refcon)
{
    asyncRef[kIOAsyncReservedIndex]      = ((io_user_reference_t) wakePort)
					 | (kIOUCAsync0Flags &amp; asyncRef[kIOAsyncReservedIndex]);
    asyncRef[kIOAsyncCalloutFuncIndex]   = (io_user_reference_t) callback;
    asyncRef[kIOAsyncCalloutRefconIndex] = refcon;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::setAsyncReference64</span>(OSAsyncReference64 asyncRef,
					mach_port_t wakePort,
					mach_vm_address_t callback, io_user_reference_t refcon, task_t task)
{
    setAsyncReference64(asyncRef, wakePort, callback, refcon);
    <span class="enscript-keyword">if</span> (vm_map_is_64bit(get_task_map(task))) {
            asyncRef[kIOAsyncReservedIndex] |= kIOUCAsync64Flag;
    }
}

<span class="enscript-type">static</span> OSDictionary * <span class="enscript-function-name">CopyConsoleUser</span>(UInt32 uid)
{
	OSArray * array;
	OSDictionary * user = 0; 

	<span class="enscript-keyword">if</span> ((array = OSDynamicCast(OSArray,
	    <span class="enscript-reference">IORegistryEntry</span>::getRegistryRoot()-&gt;copyProperty(gIOConsoleUsersKey))))
	{
	    <span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx = 0;
		    (user = OSDynamicCast(OSDictionary, array-&gt;getObject(idx)));
		    idx++) {
            OSNumber * num;
            
            <span class="enscript-keyword">if</span> ((num = OSDynamicCast(OSNumber, user-&gt;getObject(gIOConsoleSessionUIDKey)))
              &amp;&amp; (uid == num-&gt;unsigned32BitValue())) {
                user-&gt;retain();
                <span class="enscript-keyword">break</span>;
            }
	    }
	    array-&gt;release();
	}
    <span class="enscript-keyword">return</span> user;
}

<span class="enscript-type">static</span> OSDictionary * <span class="enscript-function-name">CopyUserOnConsole</span>(<span class="enscript-type">void</span>)
{
    OSArray * array;
    OSDictionary * user = 0; 
    
    <span class="enscript-keyword">if</span> ((array = OSDynamicCast(OSArray,
	<span class="enscript-reference">IORegistryEntry</span>::getRegistryRoot()-&gt;copyProperty(gIOConsoleUsersKey))))
    {
	<span class="enscript-keyword">for</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx = 0;
		(user = OSDynamicCast(OSDictionary, array-&gt;getObject(idx)));
		idx++)
	{
	    <span class="enscript-keyword">if</span> (kOSBooleanTrue == user-&gt;getObject(gIOConsoleSessionOnConsoleKey))
	    {
		user-&gt;retain();
		<span class="enscript-keyword">break</span>;
	    }
	}
	array-&gt;release();
    }
    <span class="enscript-keyword">return</span> (user);
}

IOReturn <span class="enscript-function-name">IOUserClient::clientHasAuthorization</span>( task_t task,
                                               IOService * service )
{
    proc_t p;
    
    p = (proc_t) get_bsdtask_info(task);
    <span class="enscript-keyword">if</span> (p)
    {
        uint64_t authorizationID;

        authorizationID = proc_uniqueid(p);
        <span class="enscript-keyword">if</span> (authorizationID)
        {
            <span class="enscript-keyword">if</span> (service-&gt;getAuthorizationID() == authorizationID)
            {
                <span class="enscript-keyword">return</span> (kIOReturnSuccess);
            }
        }
    }

    <span class="enscript-keyword">return</span> (kIOReturnNotPermitted);
}

IOReturn <span class="enscript-function-name">IOUserClient::clientHasPrivilege</span>( <span class="enscript-type">void</span> * securityToken,
                                            <span class="enscript-type">const</span> <span class="enscript-type">char</span> * privilegeName )
{
    kern_return_t           kr;
    security_token_t        token;
    mach_msg_type_number_t  count;
    task_t                  task;
    OSDictionary *          user;
    <span class="enscript-type">bool</span>                    secureConsole;


    <span class="enscript-keyword">if</span> (!strncmp(privilegeName, kIOClientPrivilegeForeground, 
                <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeForeground)))
    {
	<span class="enscript-keyword">if</span> (task_is_gpu_denied(current_task()))
		<span class="enscript-keyword">return</span> (kIOReturnNotPrivileged);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (kIOReturnSuccess);
    }

    <span class="enscript-keyword">if</span> (!strncmp(privilegeName, kIOClientPrivilegeConsoleSession,
                                <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeConsoleSession)))
    {
	kauth_cred_t cred;
	proc_t       p;

        task = (task_t) securityToken;
	<span class="enscript-keyword">if</span> (!task)
	    task = current_task();
	p = (proc_t) get_bsdtask_info(task);
	kr = kIOReturnNotPrivileged;

	<span class="enscript-keyword">if</span> (p &amp;&amp; (cred = kauth_cred_proc_ref(p)))
	{
	    user = CopyUserOnConsole();
	    <span class="enscript-keyword">if</span> (user)
	    {
		OSNumber * num;
		<span class="enscript-keyword">if</span> ((num = OSDynamicCast(OSNumber, user-&gt;getObject(gIOConsoleSessionAuditIDKey)))
		  &amp;&amp; (cred-&gt;cr_audit.as_aia_p-&gt;ai_asid == (au_asid_t) num-&gt;unsigned32BitValue()))
		{
		    kr = kIOReturnSuccess;
		}
		user-&gt;release();
	    }
	    kauth_cred_unref(&amp;cred);
	}
	<span class="enscript-keyword">return</span> (kr);
    }

    <span class="enscript-keyword">if</span> ((secureConsole = !strncmp(privilegeName, kIOClientPrivilegeSecureConsoleProcess,
            <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeSecureConsoleProcess))))
        task = (task_t)((IOUCProcessToken *)securityToken)-&gt;token;
    <span class="enscript-keyword">else</span>
        task = (task_t)securityToken;

    count = TASK_SECURITY_TOKEN_COUNT;
    kr = task_info( task, TASK_SECURITY_TOKEN, (task_info_t) &amp;token, &amp;count );

    <span class="enscript-keyword">if</span> (KERN_SUCCESS != kr)
    {}
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncmp(privilegeName, kIOClientPrivilegeAdministrator, 
                <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeAdministrator))) {
        <span class="enscript-keyword">if</span> (0 != token.val[0])
            kr = kIOReturnNotPrivileged;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncmp(privilegeName, kIOClientPrivilegeLocalUser,
                <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeLocalUser))) {
        user = CopyConsoleUser(token.val[0]);
        <span class="enscript-keyword">if</span> ( user )
            user-&gt;release();
        <span class="enscript-keyword">else</span>
            kr = kIOReturnNotPrivileged;            
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (secureConsole || !strncmp(privilegeName, kIOClientPrivilegeConsoleUser,
                                    <span class="enscript-keyword">sizeof</span>(kIOClientPrivilegeConsoleUser))) {
        user = CopyConsoleUser(token.val[0]);
        <span class="enscript-keyword">if</span> ( user ) {
            <span class="enscript-keyword">if</span> (user-&gt;getObject(gIOConsoleSessionOnConsoleKey) != kOSBooleanTrue)
                kr = kIOReturnNotPrivileged;
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( secureConsole ) {
                OSNumber * pid = OSDynamicCast(OSNumber, user-&gt;getObject(gIOConsoleSessionSecureInputPIDKey));
                <span class="enscript-keyword">if</span> ( pid &amp;&amp; pid-&gt;unsigned32BitValue() != ((IOUCProcessToken *)securityToken)-&gt;pid)
                    kr = kIOReturnNotPrivileged;
            }
            user-&gt;release();
        }
        <span class="enscript-keyword">else</span> 
            kr = kIOReturnNotPrivileged;
    } <span class="enscript-keyword">else</span>
        kr = kIOReturnUnsupported;

    <span class="enscript-keyword">return</span> (kr);
}

OSObject * <span class="enscript-function-name">IOUserClient::copyClientEntitlement</span>( task_t task,
                                                <span class="enscript-type">const</span> <span class="enscript-type">char</span> * entitlement )
{
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_ENTITLEMENTS_LEN</span>	(128 * 1024)

	proc_t p = NULL;
	pid_t pid = 0;
	<span class="enscript-type">char</span> procname[MAXCOMLEN + 1] = <span class="enscript-string">&quot;&quot;</span>;
	size_t len = 0;
	<span class="enscript-type">void</span> *entitlements_blob = NULL;
	<span class="enscript-type">char</span> *entitlements_data = NULL;
	OSObject *entitlements_obj = NULL;
	OSDictionary *entitlements = NULL;
	OSString *errorString = NULL;
	OSObject *value = NULL;

	p = (proc_t)get_bsdtask_info(task);
	<span class="enscript-keyword">if</span> (p == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	pid = proc_pid(p);
	proc_name(pid, procname, (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(procname));

	<span class="enscript-keyword">if</span> (cs_entitlements_blob_get(p, &amp;entitlements_blob, &amp;len) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-keyword">if</span> (len &lt;= offsetof(CS_GenericBlob, data))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/*
	 * Per &lt;rdar://problem/11593877&gt;, enforce a limit on the amount of XML
	 * we'll try to parse in the kernel.
	 */</span>
	len -= offsetof(CS_GenericBlob, data);
	<span class="enscript-keyword">if</span> (len &gt; MAX_ENTITLEMENTS_LEN) {
		IOLog(<span class="enscript-string">&quot;failed to parse entitlements for %s[%u]: %lu bytes of entitlements exceeds maximum of %u\n&quot;</span>, procname, pid, len, MAX_ENTITLEMENTS_LEN);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/*
	 * OSUnserializeXML() expects a nul-terminated string, but that isn't
	 * what is stored in the entitlements blob.  Copy the string and
	 * terminate it.
	 */</span>
	entitlements_data = (<span class="enscript-type">char</span> *)IOMalloc(len + 1);
	<span class="enscript-keyword">if</span> (entitlements_data == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	memcpy(entitlements_data, ((CS_GenericBlob *)entitlements_blob)-&gt;data, len);
	entitlements_data[len] = <span class="enscript-string">'\0'</span>;

	entitlements_obj = OSUnserializeXML(entitlements_data, len + 1, &amp;errorString);
	<span class="enscript-keyword">if</span> (errorString != NULL) {
		IOLog(<span class="enscript-string">&quot;failed to parse entitlements for %s[%u]: %s\n&quot;</span>, procname, pid, errorString-&gt;getCStringNoCopy());
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	<span class="enscript-keyword">if</span> (entitlements_obj == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	entitlements = OSDynamicCast(OSDictionary, entitlements_obj);
	<span class="enscript-keyword">if</span> (entitlements == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/* Fetch the entitlement value from the dictionary. */</span>
	value = entitlements-&gt;getObject(entitlement);
	<span class="enscript-keyword">if</span> (value != NULL)
		value-&gt;retain();

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (entitlements_data != NULL)
		IOFree(entitlements_data, len + 1);
	<span class="enscript-keyword">if</span> (entitlements_obj != NULL)
		entitlements_obj-&gt;release();
	<span class="enscript-keyword">if</span> (errorString != NULL)
		errorString-&gt;release();
	<span class="enscript-keyword">return</span> value;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserClient::init</span>()
{
	<span class="enscript-keyword">if</span> (getPropertyTable() || super::init())
		<span class="enscript-keyword">return</span> reserve();
	
	<span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserClient::init</span>(OSDictionary * dictionary)
{
	<span class="enscript-keyword">if</span> (getPropertyTable() || super::init(dictionary))
		<span class="enscript-keyword">return</span> reserve();
	
	<span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserClient::initWithTask</span>(task_t owningTask,
                                <span class="enscript-type">void</span> * securityID,
                                UInt32 type )
{	
	<span class="enscript-keyword">if</span> (getPropertyTable() || super::init())
		<span class="enscript-keyword">return</span> reserve();
	
	<span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserClient::initWithTask</span>(task_t owningTask,
                                <span class="enscript-type">void</span> * securityID,
                                UInt32 type,
                                OSDictionary * properties )
{
    <span class="enscript-type">bool</span> ok;

    ok = super::init( properties );
    ok &amp;= initWithTask( owningTask, securityID, type );

    <span class="enscript-keyword">return</span>( ok );
}

<span class="enscript-type">bool</span> <span class="enscript-function-name">IOUserClient::reserve</span>()
{		
    <span class="enscript-keyword">if</span>(!reserved) {
	reserved = IONew(ExpansionData, 1);
	<span class="enscript-keyword">if</span> (!reserved) {
	    <span class="enscript-keyword">return</span> false;
	}
    }
    setTerminateDefer(NULL, true);
    IOStatisticsRegisterCounter();
    
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">IOUserClient::free</span>()
{
    <span class="enscript-keyword">if</span>( mappings)
        mappings-&gt;release();
		
    IOStatisticsUnregisterCounter();

    <span class="enscript-keyword">if</span> (reserved)
        IODelete(reserved, ExpansionData, 1);
		
    <span class="enscript-reference">super</span>::free();
}

IOReturn <span class="enscript-function-name">IOUserClient::clientDied</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( clientClose());
}

IOReturn <span class="enscript-function-name">IOUserClient::clientClose</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported );
}

IOService * <span class="enscript-function-name">IOUserClient::getService</span>( <span class="enscript-type">void</span> )
{
    <span class="enscript-keyword">return</span>( 0 );
}

IOReturn <span class="enscript-function-name">IOUserClient::registerNotificationPort</span>(
		mach_port_t 	<span class="enscript-comment">/* port */</span>,
		UInt32		<span class="enscript-comment">/* type */</span>,
                UInt32		<span class="enscript-comment">/* refCon */</span>)
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported);
}

IOReturn <span class="enscript-function-name">IOUserClient::registerNotificationPort</span>(
		mach_port_t port,
		UInt32		type,
		io_user_reference_t refCon)
{
    <span class="enscript-keyword">return</span> (registerNotificationPort(port, type, (UInt32) refCon));
}

IOReturn <span class="enscript-function-name">IOUserClient::getNotificationSemaphore</span>( UInt32 notification_type,
                                    semaphore_t * semaphore )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported);
}

IOReturn <span class="enscript-function-name">IOUserClient::connectClient</span>( IOUserClient * <span class="enscript-comment">/* client */</span> )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported);
}

IOReturn <span class="enscript-function-name">IOUserClient::clientMemoryForType</span>( UInt32 type,
			        IOOptionBits * options,
				IOMemoryDescriptor ** memory )
{
    <span class="enscript-keyword">return</span>( kIOReturnUnsupported);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">__LP64__</span>
IOMemoryMap * <span class="enscript-function-name">IOUserClient::mapClientMemory</span>( 
	IOOptionBits		type,
	task_t			task,
	IOOptionBits		mapFlags,
	IOVirtualAddress	atAddress )
{
    <span class="enscript-keyword">return</span> (NULL);
}
#<span class="enscript-reference">endif</span>

IOMemoryMap * <span class="enscript-function-name">IOUserClient::mapClientMemory64</span>( 
	IOOptionBits		type,
	task_t			task,
	IOOptionBits		mapFlags,
	mach_vm_address_t	atAddress )
{
    IOReturn		err;
    IOOptionBits	options = 0;
    IOMemoryDescriptor * memory;
    IOMemoryMap *	map = 0;

    err = clientMemoryForType( (UInt32) type, &amp;options, &amp;memory );

    <span class="enscript-keyword">if</span>( memory &amp;&amp; (kIOReturnSuccess == err)) {

        options = (options &amp; ~kIOMapUserOptionsMask)
		| (mapFlags &amp; kIOMapUserOptionsMask);
	map = memory-&gt;createMappingInTask( task, atAddress, options );
	memory-&gt;release();
    }

    <span class="enscript-keyword">return</span>( map );
}

IOReturn <span class="enscript-function-name">IOUserClient::exportObjectToClient</span>(task_t task,
			OSObject *obj, io_object_t *clientObj)
{
    mach_port_name_t	name;

    name = IOMachPort::makeSendRightForTask( task, obj, IKOT_IOKIT_OBJECT );

    *(mach_port_name_t *)clientObj = name;
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

IOExternalMethod * <span class="enscript-function-name">IOUserClient::getExternalMethodForIndex</span>( UInt32 <span class="enscript-comment">/* index */</span>)
{
    <span class="enscript-keyword">return</span>( 0 );
}

IOExternalAsyncMethod * <span class="enscript-function-name">IOUserClient::getExternalAsyncMethodForIndex</span>( UInt32 <span class="enscript-comment">/* index */</span>)
{
    <span class="enscript-keyword">return</span>( 0 );
}

IOExternalMethod * IOUserClient::
<span class="enscript-function-name">getTargetAndMethodForIndex</span>(IOService **targetP, UInt32 index)
{
    IOExternalMethod *method = getExternalMethodForIndex(index);

    <span class="enscript-keyword">if</span> (method)
        *targetP = (IOService *) method-&gt;object;

    <span class="enscript-keyword">return</span> method;
}

IOExternalAsyncMethod * IOUserClient::
<span class="enscript-function-name">getAsyncTargetAndMethodForIndex</span>(IOService ** targetP, UInt32 index)
{
    IOExternalAsyncMethod *method = getExternalAsyncMethodForIndex(index);

    <span class="enscript-keyword">if</span> (method)
        *targetP = (IOService *) method-&gt;object;

    <span class="enscript-keyword">return</span> method;
}

IOExternalTrap * IOUserClient::
<span class="enscript-function-name">getExternalTrapForIndex</span>(UInt32 index)
{
	<span class="enscript-keyword">return</span> NULL;
}

IOExternalTrap * IOUserClient::
<span class="enscript-function-name">getTargetAndTrapForIndex</span>(IOService ** targetP, UInt32 index)
{
      IOExternalTrap *trap = getExternalTrapForIndex(index);

      <span class="enscript-keyword">if</span> (trap) {
              *targetP = trap-&gt;object;
      }

      <span class="enscript-keyword">return</span> trap;
}

IOReturn <span class="enscript-function-name">IOUserClient::releaseAsyncReference64</span>(OSAsyncReference64 reference)
{
    mach_port_t port;
    port = (mach_port_t) (reference[0] &amp; ~kIOUCAsync0Flags);

    <span class="enscript-keyword">if</span> (MACH_PORT_NULL != port)
	iokit_release_port_send(port);

    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

IOReturn <span class="enscript-function-name">IOUserClient::releaseNotificationPort</span>(mach_port_t port)
{
    <span class="enscript-keyword">if</span> (MACH_PORT_NULL != port)
	iokit_release_port_send(port);

    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

IOReturn <span class="enscript-function-name">IOUserClient::sendAsyncResult</span>(OSAsyncReference reference,
                                       IOReturn result, <span class="enscript-type">void</span> *args[], UInt32 numArgs)
{
    OSAsyncReference64  reference64;
    io_user_reference_t args64[kMaxAsyncArgs];
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>        idx;

    <span class="enscript-keyword">if</span> (numArgs &gt; kMaxAsyncArgs)
        <span class="enscript-keyword">return</span> kIOReturnMessageTooLarge;

    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; kOSAsyncRef64Count; idx++)
	reference64[idx] = REF64(reference[idx]);

    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; numArgs; idx++)
	args64[idx] = REF64(args[idx]);

    <span class="enscript-keyword">return</span> (sendAsyncResult64(reference64, result, args64, numArgs));
}

IOReturn <span class="enscript-function-name">IOUserClient::sendAsyncResult64WithOptions</span>(OSAsyncReference64 reference,
                                        IOReturn result, io_user_reference_t args[], UInt32 numArgs, IOOptionBits options)
{
	<span class="enscript-keyword">return</span> _sendAsyncResult64(reference, result, args, numArgs, options);
}

IOReturn <span class="enscript-function-name">IOUserClient::sendAsyncResult64</span>(OSAsyncReference64 reference,
                                        IOReturn result, io_user_reference_t args[], UInt32 numArgs)
{
        <span class="enscript-keyword">return</span> _sendAsyncResult64(reference, result, args, numArgs, 0);
}

IOReturn <span class="enscript-function-name">IOUserClient::_sendAsyncResult64</span>(OSAsyncReference64 reference,
                                        IOReturn result, io_user_reference_t args[], UInt32 numArgs, IOOptionBits options)
{
    <span class="enscript-type">struct</span> ReplyMsg
    {
	mach_msg_header_t msgHdr;
	<span class="enscript-type">union</span>
	{
	    <span class="enscript-type">struct</span>
	    {
		OSNotificationHeader	 notifyHdr;
		IOAsyncCompletionContent asyncContent;
		uint32_t		 args[kMaxAsyncArgs];
	    } msg32;
	    <span class="enscript-type">struct</span>
	    {
		OSNotificationHeader64	 notifyHdr;
		IOAsyncCompletionContent asyncContent;
		io_user_reference_t	 args[kMaxAsyncArgs] __attribute__ ((packed));
	    } msg64;
	} m;
    };
    ReplyMsg      replyMsg;
    mach_port_t	  replyPort;
    kern_return_t kr;

    <span class="enscript-comment">// If no reply port, do nothing.
</span>    replyPort = (mach_port_t) (reference[0] &amp; ~kIOUCAsync0Flags);
    <span class="enscript-keyword">if</span> (replyPort == MACH_PORT_NULL)
        <span class="enscript-keyword">return</span> kIOReturnSuccess;
    
    <span class="enscript-keyword">if</span> (numArgs &gt; kMaxAsyncArgs)
        <span class="enscript-keyword">return</span> kIOReturnMessageTooLarge;

    replyMsg.msgHdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND <span class="enscript-comment">/*remote*/</span>,
						0 <span class="enscript-comment">/*local*/</span>);
    replyMsg.msgHdr.msgh_remote_port = replyPort;
    replyMsg.msgHdr.msgh_local_port  = 0;
    replyMsg.msgHdr.msgh_id          = kOSNotificationMessageID;
    <span class="enscript-keyword">if</span> (kIOUCAsync64Flag &amp; reference[0])
    {
	replyMsg.msgHdr.msgh_size =
	    <span class="enscript-keyword">sizeof</span>(replyMsg.msgHdr) + <span class="enscript-keyword">sizeof</span>(replyMsg.m.msg64) 
	    - (kMaxAsyncArgs - numArgs) * <span class="enscript-keyword">sizeof</span>(io_user_reference_t);
	replyMsg.m.msg64.notifyHdr.size = <span class="enscript-keyword">sizeof</span>(IOAsyncCompletionContent)
					+ numArgs * <span class="enscript-keyword">sizeof</span>(io_user_reference_t);
	replyMsg.m.msg64.notifyHdr.type = kIOAsyncCompletionNotificationType;
	bcopy(reference, replyMsg.m.msg64.notifyHdr.reference, <span class="enscript-keyword">sizeof</span>(OSAsyncReference64));

	replyMsg.m.msg64.asyncContent.result = result;
	<span class="enscript-keyword">if</span> (numArgs)
	    bcopy(args, replyMsg.m.msg64.args, numArgs * <span class="enscript-keyword">sizeof</span>(io_user_reference_t));
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> idx;

	replyMsg.msgHdr.msgh_size =
	    <span class="enscript-keyword">sizeof</span>(replyMsg.msgHdr) + <span class="enscript-keyword">sizeof</span>(replyMsg.m.msg32)
	    - (kMaxAsyncArgs - numArgs) * <span class="enscript-keyword">sizeof</span>(uint32_t);

	replyMsg.m.msg32.notifyHdr.size = <span class="enscript-keyword">sizeof</span>(IOAsyncCompletionContent)
					+ numArgs * <span class="enscript-keyword">sizeof</span>(uint32_t);
	replyMsg.m.msg32.notifyHdr.type = kIOAsyncCompletionNotificationType;

	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; kOSAsyncRefCount; idx++)
	    replyMsg.m.msg32.notifyHdr.reference[idx] = REF32(reference[idx]);

	replyMsg.m.msg32.asyncContent.result = result;

	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; numArgs; idx++)
	    replyMsg.m.msg32.args[idx] = REF32(args[idx]);
    }

	<span class="enscript-keyword">if</span> ((options &amp; kIOUserNotifyOptionCanDrop) != 0) { 
		kr = mach_msg_send_from_kernel_with_options( &amp;replyMsg.msgHdr,
										 replyMsg.msgHdr.msgh_size, MACH_SEND_TIMEOUT, MACH_MSG_TIMEOUT_NONE);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Fail on full queue. */</span>
		kr = mach_msg_send_from_kernel_proper( &amp;replyMsg.msgHdr,
										 replyMsg.msgHdr.msgh_size);
	}
    <span class="enscript-keyword">if</span> ((KERN_SUCCESS != kr) &amp;&amp; (MACH_SEND_TIMED_OUT != kr))
        IOLog(<span class="enscript-string">&quot;%s: mach_msg_send_from_kernel_proper {%x}\n&quot;</span>, __FILE__, kr );
    <span class="enscript-keyword">return</span> kr;
}


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK</span>(cls,obj,out)			\
	cls * out;				\
	<span class="enscript-keyword">if</span>( !(out = OSDynamicCast( cls, obj)))	\
	    <span class="enscript-keyword">return</span>( kIOReturnBadArgument )

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">// Create a vm_map_copy_t or kalloc'ed data for memory
</span><span class="enscript-comment">// to be copied out. ipc will free after the copyout.
</span>
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">copyoutkdata</span>( <span class="enscript-type">const</span> <span class="enscript-type">void</span> * data, vm_size_t len,
                                    io_buf_ptr_t * buf )
{
    kern_return_t	err;
    vm_map_copy_t	copy;

    err = vm_map_copyin( kernel_map, CAST_USER_ADDR_T(data), len,
                    false <span class="enscript-comment">/* src_destroy */</span>, &amp;copy);

    assert( err == KERN_SUCCESS );
    <span class="enscript-keyword">if</span>( err == KERN_SUCCESS )
        *buf = (<span class="enscript-type">char</span> *) copy;

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

<span class="enscript-comment">/* Routine io_server_version */</span>
kern_return_t <span class="enscript-function-name">is_io_server_version</span>(
	mach_port_t master_port,
	uint64_t *version)
{
    *version = IOKIT_SERVER_VERSION;
    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

<span class="enscript-comment">/* Routine io_object_get_class */</span>
kern_return_t <span class="enscript-function-name">is_io_object_get_class</span>(
    io_object_t object,
    io_name_t className )
{
    <span class="enscript-type">const</span> OSMetaClass* my_obj = NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * my_class_name = NULL;
	
    <span class="enscript-keyword">if</span>( !object)
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );
		
    <span class="enscript-keyword">if</span> ( !my_class_name ) {
        my_obj = object-&gt;getMetaClass();
        <span class="enscript-keyword">if</span> (!my_obj) {
            <span class="enscript-keyword">return</span> (kIOReturnNotFound);
        }

        my_class_name = my_obj-&gt;getClassName();
    }
	
    strlcpy( className, my_class_name, <span class="enscript-keyword">sizeof</span>(io_name_t));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_object_get_superclass */</span>
kern_return_t <span class="enscript-function-name">is_io_object_get_superclass</span>(
	mach_port_t master_port,
	io_name_t obj_name, 
	io_name_t class_name)
{
	<span class="enscript-type">const</span> OSMetaClass* my_obj = NULL;
	<span class="enscript-type">const</span> OSMetaClass* superclass = NULL;
	<span class="enscript-type">const</span> OSSymbol *my_name = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *my_cstr = NULL;

	<span class="enscript-keyword">if</span> (!obj_name || !class_name) 
		<span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

	my_name = OSSymbol::withCString(obj_name);
	
	<span class="enscript-keyword">if</span> (my_name) {
		my_obj = OSMetaClass::getMetaClassWithName(my_name);
		my_name-&gt;release();
	}
	<span class="enscript-keyword">if</span> (my_obj) {
		superclass = my_obj-&gt;getSuperClass();
	}
	
	<span class="enscript-keyword">if</span> (!superclass)  {
		<span class="enscript-keyword">return</span>( kIOReturnNotFound );
	}

	my_cstr = superclass-&gt;getClassName();
		
	<span class="enscript-keyword">if</span> (my_cstr) {
		strlcpy(class_name, my_cstr, <span class="enscript-keyword">sizeof</span>(io_name_t));
		<span class="enscript-keyword">return</span>( kIOReturnSuccess );
	}
	<span class="enscript-keyword">return</span> (kIOReturnNotFound);
}

<span class="enscript-comment">/* Routine io_object_get_bundle_identifier */</span>
kern_return_t <span class="enscript-function-name">is_io_object_get_bundle_identifier</span>(
	mach_port_t master_port,
	io_name_t obj_name, 
	io_name_t bundle_name)
{
	<span class="enscript-type">const</span> OSMetaClass* my_obj = NULL;
	<span class="enscript-type">const</span> OSSymbol *my_name = NULL;
	<span class="enscript-type">const</span> OSSymbol *identifier = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *my_cstr = NULL;

	<span class="enscript-keyword">if</span> (!obj_name || !bundle_name) 
		<span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);
	
	my_name = OSSymbol::withCString(obj_name);	
	
	<span class="enscript-keyword">if</span> (my_name) {
		my_obj = OSMetaClass::getMetaClassWithName(my_name);
		my_name-&gt;release();
	}

	<span class="enscript-keyword">if</span> (my_obj) {
		identifier = my_obj-&gt;getKmodName();
	}
	<span class="enscript-keyword">if</span> (!identifier) {
		<span class="enscript-keyword">return</span>( kIOReturnNotFound );
	}
	
	my_cstr = identifier-&gt;getCStringNoCopy();
	<span class="enscript-keyword">if</span> (my_cstr) {
		strlcpy(bundle_name, identifier-&gt;getCStringNoCopy(), <span class="enscript-keyword">sizeof</span>(io_name_t));
		<span class="enscript-keyword">return</span>( kIOReturnSuccess );
	}

	<span class="enscript-keyword">return</span> (kIOReturnBadArgument);
}

<span class="enscript-comment">/* Routine io_object_conforms_to */</span>
kern_return_t <span class="enscript-function-name">is_io_object_conforms_to</span>(
	io_object_t object,
	io_name_t className,
	boolean_t *conforms )
{
    <span class="enscript-keyword">if</span>( !object)
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    *conforms = (0 != object-&gt;metaCast( className ));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_object_get_retain_count */</span>
kern_return_t <span class="enscript-function-name">is_io_object_get_retain_count</span>(
	io_object_t object,
	uint32_t *retainCount )
{
    <span class="enscript-keyword">if</span>( !object)
        <span class="enscript-keyword">return</span>( kIOReturnBadArgument );

    *retainCount = object-&gt;getRetainCount();
    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_iterator_next */</span>
kern_return_t <span class="enscript-function-name">is_io_iterator_next</span>(
	io_object_t iterator,
	io_object_t *object )
{
    OSObject *	obj;

    CHECK( OSIterator, iterator, iter );

    obj = iter-&gt;getNextObject();
    <span class="enscript-keyword">if</span>( obj) {
	obj-&gt;retain();
	*object = obj;
        <span class="enscript-keyword">return</span>( kIOReturnSuccess );
    } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( kIOReturnNoDevice );
}

<span class="enscript-comment">/* Routine io_iterator_reset */</span>
kern_return_t <span class="enscript-function-name">is_io_iterator_reset</span>(
	io_object_t iterator )
{
    CHECK( OSIterator, iterator, iter );

    iter-&gt;reset();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_iterator_is_valid */</span>
kern_return_t <span class="enscript-function-name">is_io_iterator_is_valid</span>(
	io_object_t iterator,
	boolean_t *is_valid )
{
    CHECK( OSIterator, iterator, iter );

    *is_valid = iter-&gt;isValid();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}


<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_match_property_table</span>(
	io_service_t _service,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * matching,
	mach_msg_type_number_t matching_size,
	boolean_t *matches)
{
    CHECK( IOService, _service, service );

    kern_return_t	kr;
    OSObject *		obj;
    OSDictionary *	dict;

    obj = matching_size ? OSUnserializeXML(matching, matching_size)
			: OSUnserializeXML(matching);
    <span class="enscript-keyword">if</span>( (dict = OSDynamicCast( OSDictionary, obj))) {
        *matches = service-&gt;passiveMatch( dict );
	kr = kIOReturnSuccess;
    } <span class="enscript-keyword">else</span>
	kr = kIOReturnBadArgument;

    <span class="enscript-keyword">if</span>( obj)
        obj-&gt;release();

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_match_property_table */</span>
kern_return_t <span class="enscript-function-name">is_io_service_match_property_table</span>(
	io_service_t service,
	io_string_t matching,
	boolean_t *matches )
{
    <span class="enscript-keyword">return</span> (internal_io_service_match_property_table(service, matching, 0, matches));
}


<span class="enscript-comment">/* Routine io_service_match_property_table_ool */</span>
kern_return_t <span class="enscript-function-name">is_io_service_match_property_table_ool</span>(
	io_object_t service,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	boolean_t *matches )
{
    kern_return_t	  kr;
    vm_offset_t 	  data;
    vm_map_offset_t	  map_data;

    kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) matching );
    data = CAST_DOWN(vm_offset_t, map_data);

    <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr) {
        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>	*result = internal_io_service_match_property_table(service,
		(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)data, matchingCnt, matches );
	vm_deallocate( kernel_map, data, matchingCnt );
    }

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_match_property_table_bin */</span>
kern_return_t <span class="enscript-function-name">is_io_service_match_property_table_bin</span>(
	io_object_t service,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	boolean_t *matches)
{
    <span class="enscript-keyword">return</span> (internal_io_service_match_property_table(service, matching, matchingCnt, matches));
}

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_get_matching_services</span>(
	mach_port_t master_port,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * matching,
	mach_msg_type_number_t matching_size,
	io_iterator_t *existing )
{
    kern_return_t	kr;
    OSObject *		obj;
    OSDictionary *	dict;

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    obj = matching_size ? OSUnserializeXML(matching, matching_size)
			: OSUnserializeXML(matching);
    <span class="enscript-keyword">if</span>( (dict = OSDynamicCast( OSDictionary, obj))) {
        *existing = IOService::getMatchingServices( dict );
	kr = kIOReturnSuccess;
    } <span class="enscript-keyword">else</span>
	kr = kIOReturnBadArgument;

    <span class="enscript-keyword">if</span>( obj)
        obj-&gt;release();

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_get_matching_services */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_services</span>(
	mach_port_t master_port,
	io_string_t matching,
	io_iterator_t *existing )
{
    <span class="enscript-keyword">return</span> (internal_io_service_get_matching_services(master_port, matching, 0, existing));
}

<span class="enscript-comment">/* Routine io_service_get_matching_services_ool */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_services_ool</span>(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	io_object_t *existing )
{
    kern_return_t	kr;
    vm_offset_t 	data;
    vm_map_offset_t	map_data;

    kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) matching );
    data = CAST_DOWN(vm_offset_t, map_data);

    <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr) {
        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>	*result = internal_io_service_get_matching_services(master_port,
			(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) data, matchingCnt, existing);
	vm_deallocate( kernel_map, data, matchingCnt );
    }

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_get_matching_services_bin */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_services_bin</span>(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	io_object_t *existing)
{
    <span class="enscript-keyword">return</span> (internal_io_service_get_matching_services(master_port, matching, matchingCnt, existing));
}


<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_get_matching_service</span>(
	mach_port_t master_port,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * matching,
	mach_msg_type_number_t matching_size,
	io_service_t *service )
{
    kern_return_t	kr;
    OSObject *		obj;
    OSDictionary *	dict;

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    obj = matching_size ? OSUnserializeXML(matching, matching_size)
			: OSUnserializeXML(matching);
    <span class="enscript-keyword">if</span>( (dict = OSDynamicCast( OSDictionary, obj))) {
        *service = IOService::copyMatchingService( dict );
	kr = *service ? kIOReturnSuccess : kIOReturnNotFound;
    } <span class="enscript-keyword">else</span>
	kr = kIOReturnBadArgument;

    <span class="enscript-keyword">if</span>( obj)
        obj-&gt;release();

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_get_matching_service */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_service</span>(
	mach_port_t master_port,
	io_string_t matching,
	io_service_t *service )
{
    <span class="enscript-keyword">return</span> (internal_io_service_get_matching_service(master_port, matching, 0, service));
}

<span class="enscript-comment">/* Routine io_service_get_matching_services_ool */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_service_ool</span>(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	io_object_t *service )
{
    kern_return_t	kr;
    vm_offset_t 	data;
    vm_map_offset_t	map_data;

    kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) matching );
    data = CAST_DOWN(vm_offset_t, map_data);

    <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr) {
        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>	*result = internal_io_service_get_matching_service(master_port,
			(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) data, matchingCnt, service );
	vm_deallocate( kernel_map, data, matchingCnt );
    }

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_get_matching_service_bin */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_matching_service_bin</span>(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	io_object_t *service)
{
    <span class="enscript-keyword">return</span> (internal_io_service_get_matching_service(master_port, matching, matchingCnt, service));
}

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_add_notification</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * matching,
	size_t matching_size,
	mach_port_t port,
	<span class="enscript-type">void</span> * reference,
	vm_size_t referenceSize,
	<span class="enscript-type">bool</span> client64,
	io_object_t * notification )
{
    IOServiceUserNotification *	userNotify = 0;
    IONotifier *		notify = 0;
    <span class="enscript-type">const</span> OSSymbol *		sym;
    OSDictionary *		dict;
    IOReturn			err;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> <span class="enscript-type">int</span>		userMsgType;

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    <span class="enscript-keyword">do</span> {
        err = kIOReturnNoResources;

        <span class="enscript-keyword">if</span>( !(sym = OSSymbol::withCString( notification_type )))
	    err = kIOReturnNoResources;

	<span class="enscript-keyword">if</span> (matching_size)
	{
            dict = OSDynamicCast(OSDictionary, OSUnserializeXML(matching, matching_size));
	}
	<span class="enscript-keyword">else</span>
	{
	    dict = OSDynamicCast(OSDictionary, OSUnserializeXML(matching));
	}

        <span class="enscript-keyword">if</span> (!dict) {
            err = kIOReturnBadArgument;
	    <span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-keyword">if</span>( (sym == gIOPublishNotification)
	 || (sym == gIOFirstPublishNotification))
	    userMsgType = kIOServicePublishNotificationType;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (sym == gIOMatchedNotification)
	      || (sym == gIOFirstMatchNotification))
	    userMsgType = kIOServiceMatchedNotificationType;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( sym == gIOTerminatedNotification)
	    userMsgType = kIOServiceTerminatedNotificationType;
	<span class="enscript-keyword">else</span>
	    userMsgType = kLastIOKitNotificationType;

        userNotify = <span class="enscript-keyword">new</span> IOServiceUserNotification;

        <span class="enscript-keyword">if</span>( userNotify &amp;&amp; !userNotify-&gt;init( port, userMsgType,
                                             reference, referenceSize, client64)) {
			iokit_release_port_send(port);
            userNotify-&gt;release();
            userNotify = 0;
        }
        <span class="enscript-keyword">if</span>( !userNotify)
	    <span class="enscript-keyword">continue</span>;

        notify = IOService::addMatchingNotification( sym, dict,
                                             &amp;userNotify-&gt;_handler, userNotify );
	<span class="enscript-keyword">if</span>( notify) {
            *notification = userNotify;
	    userNotify-&gt;setNotification( notify );
	    err = kIOReturnSuccess;
	} <span class="enscript-keyword">else</span>
	    err = kIOReturnUnsupported;

    } <span class="enscript-keyword">while</span>( false );

    <span class="enscript-keyword">if</span>( sym)
	sym-&gt;release();
    <span class="enscript-keyword">if</span>( dict)
	dict-&gt;release();

    <span class="enscript-keyword">return</span>( err );
}


<span class="enscript-comment">/* Routine io_service_add_notification */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_notification</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	io_object_t * notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification(master_port, notification_type, 
		matching, 0, port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref_t),
		false, notification));
}

<span class="enscript-comment">/* Routine io_service_add_notification_64 */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_notification_64</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	io_object_t *notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification(master_port, notification_type, 
		matching, 0, wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref64_t),
		true, notification));
}

<span class="enscript-comment">/* Routine io_service_add_notification_bin */</span>
kern_return_t is_io_service_add_notification_bin
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	io_object_t *notification)
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification(master_port, notification_type, 
		matching, matchingCnt, wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref_t),
		false, notification));
}

<span class="enscript-comment">/* Routine io_service_add_notification_bin_64 */</span>
kern_return_t is_io_service_add_notification_bin_64
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	io_object_t *notification)
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification(master_port, notification_type, 
		matching, matchingCnt, wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref64_t),
		true, notification));
}

<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_add_notification_ool</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	<span class="enscript-type">void</span> * reference,
	vm_size_t referenceSize,
	<span class="enscript-type">bool</span> client64,
	kern_return_t *result,
	io_object_t *notification )
{
    kern_return_t	kr;
    vm_offset_t 	data;
    vm_map_offset_t	map_data;

    kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) matching );
    data = CAST_DOWN(vm_offset_t, map_data);

    <span class="enscript-keyword">if</span>( KERN_SUCCESS == kr) {
        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>	*result = internal_io_service_add_notification( master_port, notification_type,
			(<span class="enscript-type">char</span> *) data, matchingCnt, wake_port, reference, referenceSize, client64, notification );
	vm_deallocate( kernel_map, data, matchingCnt );
    }

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_add_notification_ool */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_notification_ool</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	kern_return_t *result,
	io_object_t *notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification_ool(master_port, notification_type, 
		matching, matchingCnt, wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref_t),
		false, result, notification));
}

<span class="enscript-comment">/* Routine io_service_add_notification_ool_64 */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_notification_ool_64</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	kern_return_t *result,
	io_object_t *notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_notification_ool(master_port, notification_type, 
		matching, matchingCnt, wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref64_t),
		true, result, notification));
}

<span class="enscript-comment">/* Routine io_service_add_notification_old */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_notification_old</span>(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t port,
	<span class="enscript-comment">// for binary compatibility reasons, this must be natural_t for ILP32
</span>	natural_t ref,
	io_object_t * notification )
{
    <span class="enscript-keyword">return</span>( is_io_service_add_notification( master_port, notification_type,
            matching, port, &amp;ref, 1, notification ));
}


<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">internal_io_service_add_interest_notification</span>(
        io_object_t _service,
        io_name_t type_of_interest,
        mach_port_t port,
	<span class="enscript-type">void</span> * reference,
	vm_size_t referenceSize,
	<span class="enscript-type">bool</span> client64,
        io_object_t * notification )
{

    IOServiceMessageUserNotification *	userNotify = 0;
    IONotifier *			notify = 0;
    <span class="enscript-type">const</span> OSSymbol *			sym;
    IOReturn				err;

    CHECK( IOService, _service, service );

    err = kIOReturnNoResources;
    <span class="enscript-keyword">if</span>( (sym = OSSymbol::withCString( type_of_interest ))) <span class="enscript-keyword">do</span> {

        userNotify = <span class="enscript-keyword">new</span> IOServiceMessageUserNotification;

        <span class="enscript-keyword">if</span>( userNotify &amp;&amp; !userNotify-&gt;init( port, kIOServiceMessageNotificationType,
                                             reference, referenceSize,
					     kIOUserNotifyMaxMessageSize,
					     client64 )) {
			iokit_release_port_send(port);
            userNotify-&gt;release();
            userNotify = 0;
        }
        <span class="enscript-keyword">if</span>( !userNotify)
            <span class="enscript-keyword">continue</span>;

        notify = service-&gt;registerInterest( sym,
                                    &amp;userNotify-&gt;_handler, userNotify );
        <span class="enscript-keyword">if</span>( notify) {
            *notification = userNotify;
            userNotify-&gt;setNotification( notify );
            err = kIOReturnSuccess;
        } <span class="enscript-keyword">else</span>
            err = kIOReturnUnsupported;

	sym-&gt;release();

    } <span class="enscript-keyword">while</span>( false );

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/* Routine io_service_add_message_notification */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_interest_notification</span>(
        io_object_t service,
        io_name_t type_of_interest,
        mach_port_t port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
        io_object_t * notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_interest_notification(service, type_of_interest,
		    port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref_t), false, notification));
}

<span class="enscript-comment">/* Routine io_service_add_interest_notification_64 */</span>
kern_return_t <span class="enscript-function-name">is_io_service_add_interest_notification_64</span>(
	io_object_t service,
	io_name_t type_of_interest,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	io_object_t *notification )
{
    <span class="enscript-keyword">return</span> (internal_io_service_add_interest_notification(service, type_of_interest,
		    wake_port, &amp;reference[0], <span class="enscript-keyword">sizeof</span>(io_async_ref64_t), true, notification));
}


<span class="enscript-comment">/* Routine io_service_acknowledge_notification */</span>
kern_return_t <span class="enscript-function-name">is_io_service_acknowledge_notification</span>(
	io_object_t _service,
	natural_t notify_ref,
	natural_t response )
{
    CHECK( IOService, _service, service );

    <span class="enscript-keyword">return</span>( service-&gt;acknowledgeNotification( (IONotificationRef)(uintptr_t) notify_ref,
                                              (IOOptionBits) response ));
    
}

<span class="enscript-comment">/* Routine io_connect_get_semaphore */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_get_notification_semaphore</span>(
	io_connect_t connection,
	natural_t notification_type,
	semaphore_t *semaphore )
{
    CHECK( IOUserClient, connection, client );

    IOStatisticsClientCall();
    <span class="enscript-keyword">return</span>( client-&gt;getNotificationSemaphore( (UInt32) notification_type,
                                              semaphore ));
}

<span class="enscript-comment">/* Routine io_registry_get_root_entry */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_get_root_entry</span>(
	mach_port_t master_port,
	io_object_t *root )
{
    IORegistryEntry *	entry;

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    entry = IORegistryEntry::getRegistryRoot();
    <span class="enscript-keyword">if</span>( entry)
	entry-&gt;retain();
    *root = entry;

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_registry_create_iterator */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_create_iterator</span>(
	mach_port_t master_port,
	io_name_t plane,
	uint32_t options,
	io_object_t *iterator )
{
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    *iterator = IORegistryIterator::iterateOver(
	<span class="enscript-reference">IORegistryEntry</span>::getPlane( plane ), options );

    <span class="enscript-keyword">return</span>( *iterator ? kIOReturnSuccess : kIOReturnBadArgument );
}

<span class="enscript-comment">/* Routine io_registry_entry_create_iterator */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_create_iterator</span>(
	io_object_t registry_entry,
	io_name_t plane,
	uint32_t options,
	io_object_t *iterator )
{
    CHECK( IORegistryEntry, registry_entry, entry );

    *iterator = IORegistryIterator::iterateOver( entry,
	<span class="enscript-reference">IORegistryEntry</span>::getPlane( plane ), options );

    <span class="enscript-keyword">return</span>( *iterator ? kIOReturnSuccess : kIOReturnBadArgument );
}

<span class="enscript-comment">/* Routine io_registry_iterator_enter */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_iterator_enter_entry</span>(
	io_object_t iterator )
{
    CHECK( IORegistryIterator, iterator, iter );

    iter-&gt;enterEntry();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_registry_iterator_exit */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_iterator_exit_entry</span>(
	io_object_t iterator )
{
    <span class="enscript-type">bool</span>	didIt;

    CHECK( IORegistryIterator, iterator, iter );

    didIt = iter-&gt;exitEntry();

    <span class="enscript-keyword">return</span>( didIt ? kIOReturnSuccess : kIOReturnNoDevice );
}

<span class="enscript-comment">/* Routine io_registry_entry_from_path */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_from_path</span>(
	mach_port_t master_port,
	io_string_t path,
	io_object_t *registry_entry )
{
    IORegistryEntry *	entry;

    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span>( kIOReturnNotPrivileged);

    entry = IORegistryEntry::fromPath( path );

    *registry_entry = entry;

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}


<span class="enscript-comment">/* Routine io_registry_entry_from_path */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_from_path_ool</span>(
	mach_port_t master_port,
	io_string_inband_t path,
	io_buf_ptr_t path_ool,
	mach_msg_type_number_t path_oolCnt,
	kern_return_t *result,
	io_object_t *registry_entry)
{
    IORegistryEntry *	entry;
    vm_map_offset_t	map_data;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * 	cpath;
    IOReturn            res;
    kern_return_t       err;

    <span class="enscript-keyword">if</span> (master_port != master_device_port) <span class="enscript-keyword">return</span>(kIOReturnNotPrivileged);

    map_data = 0;
    entry    = 0;
    res = err = KERN_SUCCESS;
    <span class="enscript-keyword">if</span> (path[0]) cpath = path;
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-keyword">if</span> (!path_oolCnt)                                      <span class="enscript-keyword">return</span>(kIOReturnBadArgument);
	<span class="enscript-keyword">if</span> (path_oolCnt &gt; (<span class="enscript-keyword">sizeof</span>(io_struct_inband_t) * 1024)) <span class="enscript-keyword">return</span>(kIOReturnMessageTooLarge);

	err = vm_map_copyout(kernel_map, &amp;map_data, (vm_map_copy_t) path_ool);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS == err)
	{
	    <span class="enscript-comment">// must return success to mig after vm_map_copyout() succeeds, so result is actual
</span>	    cpath = CAST_DOWN(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, map_data);
	    <span class="enscript-keyword">if</span> (cpath[path_oolCnt - 1]) res = kIOReturnBadArgument;
	}
    }

    <span class="enscript-keyword">if</span> ((KERN_SUCCESS == err) &amp;&amp; (KERN_SUCCESS == res))
    {
	entry = IORegistryEntry::fromPath(cpath);
	res = entry ? kIOReturnSuccess : kIOReturnNotFound;
    }

    <span class="enscript-keyword">if</span> (map_data) vm_deallocate(kernel_map, map_data, path_oolCnt);

    <span class="enscript-keyword">if</span> (KERN_SUCCESS != err) res = err;
    *registry_entry = entry;
    *result = res;

    <span class="enscript-keyword">return</span> (err);
}


<span class="enscript-comment">/* Routine io_registry_entry_in_plane */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_in_plane</span>(
	io_object_t registry_entry,
	io_name_t plane,
	boolean_t *inPlane )
{
    CHECK( IORegistryEntry, registry_entry, entry );

    *inPlane = entry-&gt;inPlane( IORegistryEntry::getPlane( plane ));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}


<span class="enscript-comment">/* Routine io_registry_entry_get_path */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_path</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_string_t path )
{
    <span class="enscript-type">int</span>		length;
    CHECK( IORegistryEntry, registry_entry, entry );

    length = <span class="enscript-keyword">sizeof</span>( io_string_t);
    <span class="enscript-keyword">if</span>( entry-&gt;getPath( path, &amp;length, IORegistryEntry::getPlane( plane )))
	<span class="enscript-keyword">return</span>( kIOReturnSuccess );
    <span class="enscript-keyword">else</span>
	<span class="enscript-keyword">return</span>( kIOReturnBadArgument );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_path */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_path_ool</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_string_inband_t path,
	io_buf_ptr_t *path_ool,
	mach_msg_type_number_t *path_oolCnt)
{
    <span class="enscript-type">enum</span>   { kMaxPath = 16384 };
    IOReturn err;
    <span class="enscript-type">int</span>      length;
    <span class="enscript-type">char</span>   * buf;

    CHECK( IORegistryEntry, registry_entry, entry );

    *path_ool    = NULL;
    *path_oolCnt = 0;
    length = <span class="enscript-keyword">sizeof</span>(io_string_inband_t);
    <span class="enscript-keyword">if</span> (entry-&gt;getPath(path, &amp;length, IORegistryEntry::getPlane(plane))) err = kIOReturnSuccess;
    <span class="enscript-keyword">else</span>
    {
	length = kMaxPath;
	buf = IONew(<span class="enscript-type">char</span>, length);
	<span class="enscript-keyword">if</span> (!buf) err = kIOReturnNoMemory;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!entry-&gt;getPath(buf, &amp;length, IORegistryEntry::getPlane(plane))) err = kIOReturnError;
	<span class="enscript-keyword">else</span>
	{
	    *path_oolCnt = length;
	    err = copyoutkdata(buf, length, path_ool);
	}
	<span class="enscript-keyword">if</span> (buf) IODelete(buf, <span class="enscript-type">char</span>, kMaxPath);
    }

    <span class="enscript-keyword">return</span> (err);
}


<span class="enscript-comment">/* Routine io_registry_entry_get_name */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_name</span>(
	io_object_t registry_entry,
	io_name_t name )
{
    CHECK( IORegistryEntry, registry_entry, entry );

    strncpy( name, entry-&gt;getName(), <span class="enscript-keyword">sizeof</span>( io_name_t));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_name_in_plane */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_name_in_plane</span>(
	io_object_t registry_entry,
	io_name_t planeName,
	io_name_t name )
{
    <span class="enscript-type">const</span> IORegistryPlane * plane;
    CHECK( IORegistryEntry, registry_entry, entry );

    <span class="enscript-keyword">if</span>( planeName[0])
        plane = IORegistryEntry::getPlane( planeName );
    <span class="enscript-keyword">else</span>
        plane = 0;

    strncpy( name, entry-&gt;getName( plane), <span class="enscript-keyword">sizeof</span>( io_name_t));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_location_in_plane */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_location_in_plane</span>(
	io_object_t registry_entry,
	io_name_t planeName,
	io_name_t location )
{
    <span class="enscript-type">const</span> IORegistryPlane * plane;
    CHECK( IORegistryEntry, registry_entry, entry );

    <span class="enscript-keyword">if</span>( planeName[0])
        plane = IORegistryEntry::getPlane( planeName );
    <span class="enscript-keyword">else</span>
        plane = 0;

    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * cstr = entry-&gt;getLocation( plane );

    <span class="enscript-keyword">if</span>( cstr) {
        strncpy( location, cstr, <span class="enscript-keyword">sizeof</span>( io_name_t));
        <span class="enscript-keyword">return</span>( kIOReturnSuccess );
    } <span class="enscript-keyword">else</span>
        <span class="enscript-keyword">return</span>( kIOReturnNotFound );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_registry_entry_id */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_registry_entry_id</span>(
	io_object_t registry_entry,
	uint64_t *entry_id )
{
    CHECK( IORegistryEntry, registry_entry, entry );

    *entry_id = entry-&gt;getRegistryEntryID();

    <span class="enscript-keyword">return</span> (kIOReturnSuccess);
}

<span class="enscript-comment">/* Routine io_registry_entry_get_property */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_property_bytes</span>(
	io_object_t registry_entry,
	io_name_t property_name,
	io_struct_inband_t buf,
	mach_msg_type_number_t *dataCnt )
{
    OSObject	*	obj;
    OSData 	*	data;
    OSString 	*	str;
    OSBoolean	*	boo;
    OSNumber 	*	off;
    UInt64		offsetBytes;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	len = 0;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *	bytes = 0;
    IOReturn		ret = kIOReturnSuccess;

    CHECK( IORegistryEntry, registry_entry, entry );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))
        <span class="enscript-keyword">return</span> kIOReturnNotPermitted;
#<span class="enscript-reference">endif</span>

    obj = entry-&gt;copyProperty(property_name);
    <span class="enscript-keyword">if</span>( !obj)
        <span class="enscript-keyword">return</span>( kIOReturnNoResources );

    <span class="enscript-comment">// One day OSData will be a common container base class
</span>    <span class="enscript-comment">// until then...
</span>    <span class="enscript-keyword">if</span>( (data = OSDynamicCast( OSData, obj ))) {
	len = data-&gt;getLength();
	bytes = data-&gt;getBytesNoCopy();

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (str = OSDynamicCast( OSString, obj ))) {
	len = str-&gt;getLength() + 1;
	bytes = str-&gt;getCStringNoCopy();

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (boo = OSDynamicCast( OSBoolean, obj ))) {
	len = boo-&gt;isTrue() ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;Yes&quot;</span>) : <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;No&quot;</span>);
	bytes = boo-&gt;isTrue() ? <span class="enscript-string">&quot;Yes&quot;</span> : <span class="enscript-string">&quot;No&quot;</span>;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (off = OSDynamicCast( OSNumber, obj ))) {
	offsetBytes = off-&gt;unsigned64BitValue();
	len = off-&gt;numberOfBytes();
	bytes = &amp;offsetBytes;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__BIG_ENDIAN__</span>
	bytes = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)
		(((UInt32) bytes) + (<span class="enscript-keyword">sizeof</span>( UInt64) - len));
#<span class="enscript-reference">endif</span>

    } <span class="enscript-keyword">else</span>
	ret = kIOReturnBadArgument;

    <span class="enscript-keyword">if</span>( bytes) {
	<span class="enscript-keyword">if</span>( *dataCnt &lt; len)
	    ret = kIOReturnIPCError;
	<span class="enscript-keyword">else</span> {
            *dataCnt = len;
            bcopy( bytes, buf, len );
	}
    }
    obj-&gt;release();

    <span class="enscript-keyword">return</span>( ret );
}


<span class="enscript-comment">/* Routine io_registry_entry_get_property */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_property</span>(
	io_object_t registry_entry,
	io_name_t property_name,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt )
{
    kern_return_t	err;
    vm_size_t 		len;
    OSObject *		obj;

    CHECK( IORegistryEntry, registry_entry, entry );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))
        <span class="enscript-keyword">return</span> kIOReturnNotPermitted;
#<span class="enscript-reference">endif</span>

    obj = entry-&gt;copyProperty(property_name);
    <span class="enscript-keyword">if</span>( !obj)
        <span class="enscript-keyword">return</span>( kIOReturnNotFound );

    OSSerialize * s = OSSerialize::withCapacity(4096);
    <span class="enscript-keyword">if</span>( !s) {
        obj-&gt;release();
	<span class="enscript-keyword">return</span>( kIOReturnNoMemory );
    }

    <span class="enscript-keyword">if</span>( obj-&gt;serialize( s )) {
        len = s-&gt;getLength();
        *propertiesCnt = len;
        err = copyoutkdata( s-&gt;text(), len, properties );

    } <span class="enscript-keyword">else</span>
        err = kIOReturnUnsupported;

    s-&gt;release();
    obj-&gt;release();

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_property_recursively */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_property_recursively</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
        uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt )
{
    kern_return_t	err;
    vm_size_t 		len;
    OSObject *		obj;

    CHECK( IORegistryEntry, registry_entry, entry );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))
        <span class="enscript-keyword">return</span> kIOReturnNotPermitted;
#<span class="enscript-reference">endif</span>

    obj = entry-&gt;copyProperty( property_name,
                               <span class="enscript-reference">IORegistryEntry</span>::getPlane( plane ), options);
    <span class="enscript-keyword">if</span>( !obj)
        <span class="enscript-keyword">return</span>( kIOReturnNotFound );

    OSSerialize * s = OSSerialize::withCapacity(4096);
    <span class="enscript-keyword">if</span>( !s) {
        obj-&gt;release();
	<span class="enscript-keyword">return</span>( kIOReturnNoMemory );
    }

    <span class="enscript-keyword">if</span>( obj-&gt;serialize( s )) {
        len = s-&gt;getLength();
        *propertiesCnt = len;
        err = copyoutkdata( s-&gt;text(), len, properties );

    } <span class="enscript-keyword">else</span>
        err = kIOReturnUnsupported;

    s-&gt;release();
    obj-&gt;release();

    <span class="enscript-keyword">return</span>( err );
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">filteredProperties</span>(IORegistryEntry *entry, OSDictionary *properties, OSDictionary **filteredp)
{
    kern_return_t	err = 0;
    OSDictionary	*filtered = NULL;
    OSCollectionIterator *iter = NULL;
    OSSymbol		*key;
    OSObject		*p;
    kauth_cred_t	cred = kauth_cred_get();

    <span class="enscript-keyword">if</span> (properties == NULL)
	<span class="enscript-keyword">return</span> kIOReturnUnsupported;

    <span class="enscript-keyword">if</span> ((iter = OSCollectionIterator::withCollection(properties)) == NULL ||
        (filtered = OSDictionary::withCapacity(properties-&gt;getCapacity())) == NULL) {
	err = kIOReturnNoMemory;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-keyword">while</span> ((p = iter-&gt;getNextObject()) != NULL) {
	<span class="enscript-keyword">if</span> ((key = OSDynamicCast(OSSymbol, p)) == NULL ||
	    mac_iokit_check_get_property(cred, entry, key-&gt;getCStringNoCopy()) != 0)
	    <span class="enscript-keyword">continue</span>;
	filtered-&gt;setObject(key, properties-&gt;getObject(key));
    }

<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (iter != NULL)
	iter-&gt;release();
    *filteredp = filtered;
    <span class="enscript-keyword">return</span> err;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Routine io_registry_entry_get_properties */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_properties</span>(
	io_object_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt )
{
    kern_return_t	err = 0;
    vm_size_t 		len;

    CHECK( IORegistryEntry, registry_entry, entry );

    OSSerialize * s = OSSerialize::withCapacity(4096);
    <span class="enscript-keyword">if</span>( !s)
	<span class="enscript-keyword">return</span>( kIOReturnNoMemory );

    <span class="enscript-keyword">if</span> (!entry-&gt;serializeProperties(s))
	err = kIOReturnUnsupported;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (!err &amp;&amp; mac_iokit_check_filter_properties(kauth_cred_get(), entry)) {
	OSObject *propobj = OSUnserializeXML(s-&gt;text(), s-&gt;getLength());
	OSDictionary *filteredprops = NULL;
	err = filteredProperties(entry, OSDynamicCast(OSDictionary, propobj), &amp;filteredprops);
	<span class="enscript-keyword">if</span> (propobj) propobj-&gt;release();

	<span class="enscript-keyword">if</span> (!err) {
	    s-&gt;clearText();
	    <span class="enscript-keyword">if</span> (!filteredprops-&gt;serialize(s))
		err = kIOReturnUnsupported;
	}
	<span class="enscript-keyword">if</span> (filteredprops != NULL)
	    filteredprops-&gt;release();
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

    <span class="enscript-keyword">if</span> (!err) {
	len = s-&gt;getLength();
	*propertiesCnt = len;
	err = copyoutkdata( s-&gt;text(), len, properties );
    }

    s-&gt;release();
    <span class="enscript-keyword">return</span>( err );
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>

<span class="enscript-type">struct</span> GetPropertiesEditorRef
{
    kauth_cred_t      cred;
    IORegistryEntry * entry;
    OSCollection    * root;
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> OSMetaClassBase *
<span class="enscript-function-name">GetPropertiesEditor</span>(<span class="enscript-type">void</span>                  * reference,
					OSSerialize           * s, 
					OSCollection          * container, 
					<span class="enscript-type">const</span> OSSymbol        * name,
					<span class="enscript-type">const</span> OSMetaClassBase * value)
{
    GetPropertiesEditorRef * ref = (typeof(ref)) reference;

    <span class="enscript-keyword">if</span> (!ref-&gt;root) ref-&gt;root = container;
    <span class="enscript-keyword">if</span> (ref-&gt;root == container)
	{
		<span class="enscript-keyword">if</span> (0 != mac_iokit_check_get_property(ref-&gt;cred, ref-&gt;entry, name-&gt;getCStringNoCopy())) 
		{
			value = 0;
		}
	}
	<span class="enscript-keyword">if</span> (value) value-&gt;retain();
    <span class="enscript-keyword">return</span> (value);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

<span class="enscript-comment">/* Routine io_registry_entry_get_properties */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_properties_bin</span>(
	io_object_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt)
{
    kern_return_t	       err = kIOReturnSuccess;
    vm_size_t 		       len;
    OSSerialize          * s;
    <span class="enscript-reference">OSSerialize</span>::Editor    editor = 0;
    <span class="enscript-type">void</span>                 * editRef = 0;

    CHECK(IORegistryEntry, registry_entry, entry);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    GetPropertiesEditorRef ref;
    <span class="enscript-keyword">if</span> (mac_iokit_check_filter_properties(kauth_cred_get(), entry))
    {
    	editor    = &amp;GetPropertiesEditor;
    	editRef   = &amp;ref;
    	ref.cred  = kauth_cred_get();
    	ref.entry = entry;
    	ref.root  = 0;
    }
#<span class="enscript-reference">endif</span>

    s = OSSerialize::binaryWithCapacity(4096, editor, editRef);
    <span class="enscript-keyword">if</span> (!s) <span class="enscript-keyword">return</span> (kIOReturnNoMemory);

    <span class="enscript-keyword">if</span> (!entry-&gt;serializeProperties(s)) err = kIOReturnUnsupported;

    <span class="enscript-keyword">if</span> (kIOReturnSuccess == err)
    {
		len = s-&gt;getLength();
		*propertiesCnt = len;
		err = copyoutkdata(s-&gt;text(), len, properties);
    }
    s-&gt;release();

    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/* Routine io_registry_entry_get_property_bin */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_property_bin</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt )
{
    kern_return_t	err;
    vm_size_t 		len;
    OSObject *		obj;
    <span class="enscript-type">const</span> OSSymbol *    sym;

    CHECK( IORegistryEntry, registry_entry, entry );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
    <span class="enscript-keyword">if</span> (0 != mac_iokit_check_get_property(kauth_cred_get(), entry, property_name))
        <span class="enscript-keyword">return</span> kIOReturnNotPermitted;
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> ((kIORegistryIterateRecursively &amp; options) &amp;&amp; plane[0])
    {
	obj = entry-&gt;copyProperty(property_name,
				  <span class="enscript-reference">IORegistryEntry</span>::getPlane(plane), options);
    }
    <span class="enscript-keyword">else</span>
    {
	obj = entry-&gt;copyProperty(property_name);
    }

    <span class="enscript-keyword">if</span>( !obj)
        <span class="enscript-keyword">return</span>( kIOReturnNotFound );

    sym = OSSymbol::withCString(property_name);
    <span class="enscript-keyword">if</span> (sym)
    {
        <span class="enscript-keyword">if</span> (gIORemoveOnReadProperties-&gt;containsObject(sym)) entry-&gt;removeProperty(sym);
        sym-&gt;release();
    }

    OSSerialize * s = OSSerialize::binaryWithCapacity(4096);
    <span class="enscript-keyword">if</span>( !s) {
        obj-&gt;release();
	<span class="enscript-keyword">return</span>( kIOReturnNoMemory );
    }

    <span class="enscript-keyword">if</span>( obj-&gt;serialize( s )) {
        len = s-&gt;getLength();
        *propertiesCnt = len;
        err = copyoutkdata( s-&gt;text(), len, properties );

    } <span class="enscript-keyword">else</span> err = kIOReturnUnsupported; 

    s-&gt;release();
    obj-&gt;release();

    <span class="enscript-keyword">return</span>( err );
}


<span class="enscript-comment">/* Routine io_registry_entry_set_properties */</span>
kern_return_t is_io_registry_entry_set_properties
(
	io_object_t registry_entry,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
        kern_return_t * result)
{
    OSObject *		obj;
    kern_return_t	err;
    IOReturn		res;
    vm_offset_t 	data;
    vm_map_offset_t	map_data;

    CHECK( IORegistryEntry, registry_entry, entry );

    <span class="enscript-keyword">if</span>( propertiesCnt &gt; <span class="enscript-keyword">sizeof</span>(io_struct_inband_t) * 1024)
        <span class="enscript-keyword">return</span>( kIOReturnMessageTooLarge);

    err = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) properties );
    data = CAST_DOWN(vm_offset_t, map_data);

    <span class="enscript-keyword">if</span>( KERN_SUCCESS == err) {

        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>        obj = OSUnserializeXML( (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) data, propertiesCnt );
	vm_deallocate( kernel_map, data, propertiesCnt );

	<span class="enscript-keyword">if</span> (!obj)
	    res = kIOReturnBadArgument;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 != mac_iokit_check_set_properties(kauth_cred_get(),
	    registry_entry, obj))
	{
	    res = kIOReturnNotPermitted;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">else</span>
	{
	    res = entry-&gt;setProperties( obj );
	}

	<span class="enscript-keyword">if</span> (obj)
	    obj-&gt;release();
    } <span class="enscript-keyword">else</span>
        res = err;

    *result = res;
    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_child_iterator */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_child_iterator</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_object_t *iterator )
{
    CHECK( IORegistryEntry, registry_entry, entry );

    *iterator = entry-&gt;getChildIterator(
	<span class="enscript-reference">IORegistryEntry</span>::getPlane( plane ));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_registry_entry_get_parent_iterator */</span>
kern_return_t <span class="enscript-function-name">is_io_registry_entry_get_parent_iterator</span>(
	io_object_t registry_entry,
	io_name_t plane,
	io_object_t *iterator)
{
    CHECK( IORegistryEntry, registry_entry, entry );

    *iterator = entry-&gt;getParentIterator(
	<span class="enscript-reference">IORegistryEntry</span>::getPlane( plane ));

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_service_get_busy_state */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_busy_state</span>(
	io_object_t _service,
	uint32_t *busyState )
{
    CHECK( IOService, _service, service );

    *busyState = service-&gt;getBusyState();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_service_get_state */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_state</span>(
	io_object_t _service,
	uint64_t *state,
	uint32_t *busy_state,
	uint64_t *accumulated_busy_time )
{
    CHECK( IOService, _service, service );

    *state                 = service-&gt;getState();
    *busy_state            = service-&gt;getBusyState();
    *accumulated_busy_time = service-&gt;getAccumulatedBusyTime();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_service_wait_quiet */</span>
kern_return_t <span class="enscript-function-name">is_io_service_wait_quiet</span>(
	io_object_t _service,
	mach_timespec_t wait_time )
{
    uint64_t    timeoutNS;
    
    CHECK( IOService, _service, service );

    timeoutNS = wait_time.tv_sec;
    timeoutNS *= kSecondScale;
    timeoutNS += wait_time.tv_nsec;
    
    <span class="enscript-keyword">return</span>( service-&gt;waitQuiet(timeoutNS) );
}

<span class="enscript-comment">/* Routine io_service_request_probe */</span>
kern_return_t <span class="enscript-function-name">is_io_service_request_probe</span>(
	io_object_t _service,
	uint32_t options )
{
    CHECK( IOService, _service, service );

    <span class="enscript-keyword">return</span>( service-&gt;requestProbe( options ));
}

<span class="enscript-comment">/* Routine io_service_get_authorization_id */</span>
kern_return_t <span class="enscript-function-name">is_io_service_get_authorization_id</span>(
	io_object_t _service,
	uint64_t *authorization_id )
{
    kern_return_t	   kr;

    CHECK( IOService, _service, service );

    kr = IOUserClient::clientHasPrivilege( (<span class="enscript-type">void</span> *) current_task(),
                                            kIOClientPrivilegeAdministrator );
    <span class="enscript-keyword">if</span>( kIOReturnSuccess != kr)
        <span class="enscript-keyword">return</span>( kr );

    *authorization_id = service-&gt;getAuthorizationID();

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_service_set_authorization_id */</span>
kern_return_t <span class="enscript-function-name">is_io_service_set_authorization_id</span>(
	io_object_t _service,
	uint64_t authorization_id )
{
    CHECK( IOService, _service, service );

    <span class="enscript-keyword">return</span>( service-&gt;setAuthorizationID( authorization_id ) );
}

<span class="enscript-comment">/* Routine io_service_open_ndr */</span>
kern_return_t <span class="enscript-function-name">is_io_service_open_extended</span>(
	io_object_t _service,
	task_t owningTask,
	uint32_t connect_type,
	NDR_record_t ndr,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
        kern_return_t * result,
	io_object_t *connection )
{
    IOUserClient * client = 0;
    kern_return_t  err = KERN_SUCCESS;
    IOReturn	   res = kIOReturnSuccess;
    OSDictionary * propertiesDict = 0;
    <span class="enscript-type">bool</span>	   crossEndian;
    <span class="enscript-type">bool</span>	   disallowAccess;

    CHECK( IOService, _service, service );

    <span class="enscript-keyword">if</span> (!owningTask) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-keyword">if</span> (properties)
	{
	    OSObject *	    obj;
	    vm_offset_t     data;
	    vm_map_offset_t map_data;

	    <span class="enscript-keyword">if</span>( propertiesCnt &gt; <span class="enscript-keyword">sizeof</span>(io_struct_inband_t))
		<span class="enscript-keyword">return</span>( kIOReturnMessageTooLarge);

	    err = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t) properties );
	    res = err;
	    data = CAST_DOWN(vm_offset_t, map_data);
	    <span class="enscript-keyword">if</span> (KERN_SUCCESS == err)
	    {
		<span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>		obj = OSUnserializeXML( (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) data, propertiesCnt );
		vm_deallocate( kernel_map, data, propertiesCnt );
		propertiesDict = OSDynamicCast(OSDictionary, obj);
		<span class="enscript-keyword">if</span> (!propertiesDict)
		{
		    res = kIOReturnBadArgument;
		    <span class="enscript-keyword">if</span> (obj)
			obj-&gt;release();
		}
	    }
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != res)
		<span class="enscript-keyword">break</span>;
	}

	crossEndian = (ndr.int_rep != NDR_record.int_rep);
	<span class="enscript-keyword">if</span> (crossEndian)
	{
	    <span class="enscript-keyword">if</span> (!propertiesDict)
		propertiesDict = OSDictionary::withCapacity(4);
	    OSData * data = OSData::withBytes(&amp;ndr, <span class="enscript-keyword">sizeof</span>(ndr));
	    <span class="enscript-keyword">if</span> (data)
	    {
		<span class="enscript-keyword">if</span> (propertiesDict)
		    propertiesDict-&gt;setObject(kIOUserClientCrossEndianKey, data);
		data-&gt;release();
	    }
	}

	res = service-&gt;newUserClient( owningTask, (<span class="enscript-type">void</span> *) owningTask,
		    connect_type, propertiesDict, &amp;client );

	<span class="enscript-keyword">if</span> (propertiesDict)
	    propertiesDict-&gt;release();

	<span class="enscript-keyword">if</span> (res == kIOReturnSuccess)
	{
	    assert( OSDynamicCast(IOUserClient, client) );

	    disallowAccess = (crossEndian
		&amp;&amp; (kOSBooleanTrue != service-&gt;getProperty(kIOUserClientCrossEndianCompatibleKey))
		&amp;&amp; (kOSBooleanTrue != client-&gt;getProperty(kIOUserClientCrossEndianCompatibleKey)));
            <span class="enscript-keyword">if</span> (disallowAccess) res = kIOReturnUnsupported;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 != mac_iokit_check_open(kauth_cred_get(), client, connect_type))
		res = kIOReturnNotPermitted;
#<span class="enscript-reference">endif</span>
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess != res)
	    {
		IOStatisticsClientCall();
		client-&gt;clientClose();
		client-&gt;release();
		client = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    client-&gt;sharedInstance = (0 != client-&gt;getProperty(kIOUserClientSharedInstanceKey));
	    OSString * creatorName = IOCopyLogNameForPID(proc_selfpid());
	    <span class="enscript-keyword">if</span> (creatorName)
	    {
		client-&gt;setProperty(kIOUserClientCreatorKey, creatorName);
		creatorName-&gt;release();
	    }
	    client-&gt;setTerminateDefer(service, false);
	}
    }
    <span class="enscript-keyword">while</span> (false);

    *connection = client;
    *result = res;

    <span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/* Routine io_service_close */</span>
kern_return_t <span class="enscript-function-name">is_io_service_close</span>(
	io_object_t connection )
{
    OSSet * mappings;
    <span class="enscript-keyword">if</span> ((mappings = OSDynamicCast(OSSet, connection)))
	<span class="enscript-keyword">return</span>( kIOReturnSuccess );

    CHECK( IOUserClient, connection, client );

    IOStatisticsClientCall();
    client-&gt;clientClose();

    <span class="enscript-keyword">return</span>( kIOReturnSuccess );
}

<span class="enscript-comment">/* Routine io_connect_get_service */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_get_service</span>(
	io_object_t connection,
	io_object_t *service )
{
    IOService * theService;

    CHECK( IOUserClient, connection, client );

    theService = client-&gt;getService();
    <span class="enscript-keyword">if</span>( theService)
	theService-&gt;retain();

    *service = theService;

    <span class="enscript-keyword">return</span>( theService ? kIOReturnSuccess : kIOReturnUnsupported );
}

<span class="enscript-comment">/* Routine io_connect_set_notification_port */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_set_notification_port</span>(
	io_object_t connection,
	uint32_t notification_type,
	mach_port_t port,
	uint32_t reference)
{
    CHECK( IOUserClient, connection, client );

    IOStatisticsClientCall();
    <span class="enscript-keyword">return</span>( client-&gt;registerNotificationPort( port, notification_type,
						(io_user_reference_t) reference ));
}

<span class="enscript-comment">/* Routine io_connect_set_notification_port */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_set_notification_port_64</span>(
	io_object_t connection,
	uint32_t notification_type,
	mach_port_t port,
	io_user_reference_t reference)
{
    CHECK( IOUserClient, connection, client );

    IOStatisticsClientCall();
    <span class="enscript-keyword">return</span>( client-&gt;registerNotificationPort( port, notification_type,
						reference ));
}

<span class="enscript-comment">/* Routine io_connect_map_memory_into_task */</span>
kern_return_t is_io_connect_map_memory_into_task
(
	io_connect_t connection,
	uint32_t memory_type,
	task_t into_task,
	mach_vm_address_t *address,
	mach_vm_size_t *size,
	uint32_t flags
)
{
    IOReturn		err;
    IOMemoryMap *	map;

    CHECK( IOUserClient, connection, client );

    <span class="enscript-keyword">if</span> (!into_task) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    IOStatisticsClientCall();
    map = client-&gt;mapClientMemory64( memory_type, into_task, flags, *address );

    <span class="enscript-keyword">if</span>( map) {
        *address = map-&gt;getAddress();
        <span class="enscript-keyword">if</span>( size)
            *size = map-&gt;getSize();

        <span class="enscript-keyword">if</span>( client-&gt;sharedInstance
	    || (into_task != current_task())) {
            <span class="enscript-comment">// push a name out to the task owning the map,
</span>            <span class="enscript-comment">// so we can clean up maps
</span>	    mach_port_name_t name __unused =
		<span class="enscript-reference">IOMachPort</span>::makeSendRightForTask(
                                    into_task, map, IKOT_IOKIT_OBJECT );

        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// keep it with the user client
</span>            IOLockLock( gIOObjectPortLock);
            <span class="enscript-keyword">if</span>( 0 == client-&gt;mappings)
                client-&gt;mappings = OSSet::withCapacity(2);
            <span class="enscript-keyword">if</span>( client-&gt;mappings)
                client-&gt;mappings-&gt;setObject( map);
            IOLockUnlock( gIOObjectPortLock);
            map-&gt;release();
        }
        err = kIOReturnSuccess;

    } <span class="enscript-keyword">else</span>
	err = kIOReturnBadArgument;

    <span class="enscript-keyword">return</span>( err );
}

<span class="enscript-comment">/* Routine is_io_connect_map_memory */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_map_memory</span>(
	io_object_t     connect,
	uint32_t	type,
	task_t		task,
	uint32_t  *	mapAddr,
	uint32_t  *	mapSize,
	uint32_t	flags )
{
    IOReturn	      err;
    mach_vm_address_t address;
    mach_vm_size_t    size;

    address = SCALAR64(*mapAddr);
    size    = SCALAR64(*mapSize);

    err = is_io_connect_map_memory_into_task(connect, type, task, &amp;address, &amp;size, flags);

    *mapAddr = SCALAR32(address);
    *mapSize = SCALAR32(size);

    <span class="enscript-keyword">return</span> (err);
}

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>

IOMemoryMap * <span class="enscript-function-name">IOUserClient::removeMappingForDescriptor</span>(IOMemoryDescriptor * mem)
{
    OSIterator *  iter;
    IOMemoryMap * map = 0;

    IOLockLock(gIOObjectPortLock);

    iter = OSCollectionIterator::withCollection(mappings);
    <span class="enscript-keyword">if</span>(iter)
    {
        <span class="enscript-keyword">while</span> ((map = OSDynamicCast(IOMemoryMap, iter-&gt;getNextObject())))
        {
            <span class="enscript-keyword">if</span>(mem == map-&gt;getMemoryDescriptor())
            {
                map-&gt;retain();
                mappings-&gt;removeObject(map);
                <span class="enscript-keyword">break</span>;
            }
        }
        iter-&gt;release();
    }

    IOLockUnlock(gIOObjectPortLock);

    <span class="enscript-keyword">return</span> (map);
}

<span class="enscript-type">extern</span> <span class="enscript-string">&quot;C&quot;</span> {

<span class="enscript-comment">/* Routine io_connect_unmap_memory_from_task */</span>
kern_return_t is_io_connect_unmap_memory_from_task
(
	io_connect_t connection,
	uint32_t memory_type,
	task_t from_task,
	mach_vm_address_t address)
{
    IOReturn		err;
    IOOptionBits	options = 0;
    IOMemoryDescriptor * memory;
    IOMemoryMap *	map;

    CHECK( IOUserClient, connection, client );

    <span class="enscript-keyword">if</span> (!from_task) <span class="enscript-keyword">return</span> (kIOReturnBadArgument);

    IOStatisticsClientCall();
    err = client-&gt;clientMemoryForType( (UInt32) memory_type, &amp;options, &amp;memory );

    <span class="enscript-keyword">if</span>( memory &amp;&amp; (kIOReturnSuccess == err)) {

        options = (options &amp; ~kIOMapUserOptionsMask)
		| kIOMapAnywhere | kIOMapReference;

	map = memory-&gt;createMappingInTask( from_task, address, options );
	memory-&gt;release();
        <span class="enscript-keyword">if</span>( map)
	{
            IOLockLock( gIOObjectPortLock);
            <span class="enscript-keyword">if</span>( client-&gt;mappings)
                client-&gt;mappings-&gt;removeObject( map);
            IOLockUnlock( gIOObjectPortLock);

	    mach_port_name_t name = 0;
	    <span class="enscript-keyword">if</span> (from_task != current_task())
		name = IOMachPort::makeSendRightForTask( from_task, map, IKOT_IOKIT_OBJECT );
	    <span class="enscript-keyword">if</span> (name)
	    {
		map-&gt;userClientUnmap();
		err = iokit_mod_send_right( from_task, name, -2 );
		err = kIOReturnSuccess;
	    }
	    <span class="enscript-keyword">else</span>
		<span class="enscript-reference">IOMachPort</span>::releasePortForObject( map, IKOT_IOKIT_OBJECT );
	    <span class="enscript-keyword">if</span> (from_task == current_task())
		map-&gt;release();
        }
	<span class="enscript-keyword">else</span>
            err = kIOReturnBadArgument;
    }

    <span class="enscript-keyword">return</span>( err );
}

kern_return_t <span class="enscript-function-name">is_io_connect_unmap_memory</span>(
	io_object_t     connect,
	uint32_t	type,
	task_t		task,
	uint32_t 	mapAddr )
{
    IOReturn		err;
    mach_vm_address_t   address;
    
    address = SCALAR64(mapAddr);
    
    err = is_io_connect_unmap_memory_from_task(connect, type, task, mapAddr);

    <span class="enscript-keyword">return</span> (err);
}


<span class="enscript-comment">/* Routine io_connect_add_client */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_add_client</span>(
	io_object_t connection,
	io_object_t connect_to)
{
    CHECK( IOUserClient, connection, client );
    CHECK( IOUserClient, connect_to, to );

    IOStatisticsClientCall();
    <span class="enscript-keyword">return</span>( client-&gt;connectClient( to ) );
}


<span class="enscript-comment">/* Routine io_connect_set_properties */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_set_properties</span>(
	io_object_t connection,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
        kern_return_t * result)
{
    <span class="enscript-keyword">return</span>( is_io_registry_entry_set_properties( connection, properties, propertiesCnt, result ));
}

<span class="enscript-comment">/* Routine io_user_client_method */</span>
kern_return_t is_io_connect_method_var_output
(
	io_connect_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	io_buf_ptr_t *var_output,
	mach_msg_type_number_t *var_outputCnt
)
{
    CHECK( IOUserClient, connection, client );

    IOExternalMethodArguments args;
    IOReturn ret;
    IOMemoryDescriptor * inputMD  = 0;
    OSObject *           structureVariableOutputData = 0;

    bzero(&amp;args.__reserved[0], <span class="enscript-keyword">sizeof</span>(args.__reserved));
    args.version = kIOExternalMethodArgumentsCurrentVersion;

    args.selector = selector;

    args.asyncWakePort               = MACH_PORT_NULL;
    args.asyncReference              = 0;
    args.asyncReferenceCount         = 0;
    args.structureVariableOutputData = &amp;structureVariableOutputData;

    args.scalarInput = scalar_input;
    args.scalarInputCount = scalar_inputCnt;
    args.structureInput = inband_input;
    args.structureInputSize = inband_inputCnt;

    <span class="enscript-keyword">if</span> (ool_input)
	inputMD = IOMemoryDescriptor::withAddressRange(ool_input, ool_input_size, 
						    kIODirectionOut, current_task());

    args.structureInputDescriptor = inputMD;

    args.scalarOutput = scalar_output;
    args.scalarOutputCount = *scalar_outputCnt;
    bzero(&amp;scalar_output[0], *scalar_outputCnt * <span class="enscript-keyword">sizeof</span>(scalar_output[0]));
    args.structureOutput = inband_output;
    args.structureOutputSize = *inband_outputCnt;
    args.structureOutputDescriptor = NULL;
    args.structureOutputDescriptorSize = 0;

    IOStatisticsClientCall();
    ret = client-&gt;externalMethod( selector, &amp;args );

    *scalar_outputCnt = args.scalarOutputCount;
    *inband_outputCnt = args.structureOutputSize;

    <span class="enscript-keyword">if</span> (var_outputCnt &amp;&amp; var_output &amp;&amp; (kIOReturnSuccess == ret))
    {
    	OSSerialize * serialize;
    	OSData      * data;
	vm_size_t     len;

	<span class="enscript-keyword">if</span> ((serialize = OSDynamicCast(OSSerialize, structureVariableOutputData)))
	{
	    len = serialize-&gt;getLength();
	    *var_outputCnt = len;
	    ret = copyoutkdata(serialize-&gt;text(), len, var_output);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((data = OSDynamicCast(OSData, structureVariableOutputData)))
	{
	    len = data-&gt;getLength();
	    *var_outputCnt = len;
	    ret = copyoutkdata(data-&gt;getBytesNoCopy(), len, var_output);
	}
	<span class="enscript-keyword">else</span>
	{
	    ret = kIOReturnUnderrun;
	}
    }

    <span class="enscript-keyword">if</span> (inputMD)
	inputMD-&gt;release();
    <span class="enscript-keyword">if</span> (structureVariableOutputData)
    	structureVariableOutputData-&gt;release();

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* Routine io_user_client_method */</span>
kern_return_t is_io_connect_method
(
	io_connect_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
)
{
    CHECK( IOUserClient, connection, client );

    IOExternalMethodArguments args;
    IOReturn ret;
    IOMemoryDescriptor * inputMD  = 0;
    IOMemoryDescriptor * outputMD = 0;

    bzero(&amp;args.__reserved[0], <span class="enscript-keyword">sizeof</span>(args.__reserved));
    args.version = kIOExternalMethodArgumentsCurrentVersion;

    args.selector = selector;

    args.asyncWakePort               = MACH_PORT_NULL;
    args.asyncReference              = 0;
    args.asyncReferenceCount         = 0;
    args.structureVariableOutputData = 0;

    args.scalarInput = scalar_input;
    args.scalarInputCount = scalar_inputCnt;
    args.structureInput = inband_input;
    args.structureInputSize = inband_inputCnt;

    <span class="enscript-keyword">if</span> (ool_input)
	inputMD = IOMemoryDescriptor::withAddressRange(ool_input, ool_input_size, 
						    kIODirectionOut, current_task());

    args.structureInputDescriptor = inputMD;

    args.scalarOutput = scalar_output;
    args.scalarOutputCount = *scalar_outputCnt;
    bzero(&amp;scalar_output[0], *scalar_outputCnt * <span class="enscript-keyword">sizeof</span>(scalar_output[0]));
    args.structureOutput = inband_output;
    args.structureOutputSize = *inband_outputCnt;

    <span class="enscript-keyword">if</span> (ool_output &amp;&amp; ool_output_size)
    {
	outputMD = IOMemoryDescriptor::withAddressRange(ool_output, *ool_output_size, 
						    kIODirectionIn, current_task());
    }

    args.structureOutputDescriptor = outputMD;
    args.structureOutputDescriptorSize = ool_output_size ? *ool_output_size : 0;

    IOStatisticsClientCall();
    ret = client-&gt;externalMethod( selector, &amp;args );

    *scalar_outputCnt = args.scalarOutputCount;
    *inband_outputCnt = args.structureOutputSize;
    *ool_output_size  = args.structureOutputDescriptorSize;

    <span class="enscript-keyword">if</span> (inputMD)
	inputMD-&gt;release();
    <span class="enscript-keyword">if</span> (outputMD)
	outputMD-&gt;release();

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* Routine io_async_user_client_method */</span>
kern_return_t is_io_connect_async_method
(
	io_connect_t connection,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t * ool_output_size
)
{
    CHECK( IOUserClient, connection, client );

    IOExternalMethodArguments args;
    IOReturn ret;
    IOMemoryDescriptor * inputMD  = 0;
    IOMemoryDescriptor * outputMD = 0;

    bzero(&amp;args.__reserved[0], <span class="enscript-keyword">sizeof</span>(args.__reserved));
    args.version = kIOExternalMethodArgumentsCurrentVersion;

    reference[0]	     = (io_user_reference_t) wake_port;
    <span class="enscript-keyword">if</span> (vm_map_is_64bit(get_task_map(current_task()))) 
	reference[0]	     |= kIOUCAsync64Flag;

    args.selector = selector;

    args.asyncWakePort       = wake_port;
    args.asyncReference      = reference;
    args.asyncReferenceCount = referenceCnt;

    args.scalarInput = scalar_input;
    args.scalarInputCount = scalar_inputCnt;
    args.structureInput = inband_input;
    args.structureInputSize = inband_inputCnt;

    <span class="enscript-keyword">if</span> (ool_input)
	inputMD = IOMemoryDescriptor::withAddressRange(ool_input, ool_input_size,
						    kIODirectionOut, current_task());

    args.structureInputDescriptor = inputMD;

    args.scalarOutput = scalar_output;
    args.scalarOutputCount = *scalar_outputCnt;
    bzero(&amp;scalar_output[0], *scalar_outputCnt * <span class="enscript-keyword">sizeof</span>(scalar_output[0]));
    args.structureOutput = inband_output;
    args.structureOutputSize = *inband_outputCnt;

    <span class="enscript-keyword">if</span> (ool_output)
    {
	outputMD = IOMemoryDescriptor::withAddressRange(ool_output, *ool_output_size,
						    kIODirectionIn, current_task());
    }

    args.structureOutputDescriptor = outputMD;
    args.structureOutputDescriptorSize = *ool_output_size;

    IOStatisticsClientCall();
    ret = client-&gt;externalMethod( selector, &amp;args );

    *inband_outputCnt = args.structureOutputSize;
    *ool_output_size  = args.structureOutputDescriptorSize;

    <span class="enscript-keyword">if</span> (inputMD)
	inputMD-&gt;release();
    <span class="enscript-keyword">if</span> (outputMD)
	outputMD-&gt;release();

    <span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* Routine io_connect_method_scalarI_scalarO */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_method_scalarI_scalarO</span>(
	io_object_t	   connect,
	uint32_t	   index,
        io_scalar_inband_t       input,
        mach_msg_type_number_t	 inputCount,
        io_scalar_inband_t       output,
        mach_msg_type_number_t * outputCount )
{
    IOReturn err;
    uint32_t i;
    io_scalar_inband64_t _input;
    io_scalar_inband64_t _output;

    mach_msg_type_number_t struct_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    bzero(&amp;_output[0], <span class="enscript-keyword">sizeof</span>(_output));
    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);
	
    err = is_io_connect_method(connect, index, 
		    _input, inputCount, 
		    NULL, 0,
		    0, 0,
		    NULL, &amp;struct_outputCnt,
		    _output, outputCount,
		    0, &amp;ool_output_size);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; *outputCount; i++)
	output[i] = SCALAR32(_output[i]);

    <span class="enscript-keyword">return</span> (err);
}

kern_return_t <span class="enscript-function-name">shim_io_connect_method_scalarI_scalarO</span>(
	IOExternalMethod *	method,
	IOService *		object,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	 inputCount,
        io_user_scalar_t * output,
        mach_msg_type_number_t * outputCount )
{
    IOMethod		func;
    io_scalar_inband_t  _output;
    IOReturn 		err;
    err = kIOReturnBadArgument;

    bzero(&amp;_output[0], <span class="enscript-keyword">sizeof</span>(_output));
    <span class="enscript-keyword">do</span> {

	<span class="enscript-keyword">if</span>( inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( *outputCount != method-&gt;count1)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

	<span class="enscript-keyword">switch</span>( inputCount) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					ARG32(input[3]), ARG32(input[4]), ARG32(input[5]) );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					ARG32(input[3]), ARG32(input[4]), 
					&amp;_output[0] );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					ARG32(input[3]),
					&amp;_output[0], &amp;_output[1] );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					&amp;_output[0], &amp;_output[1], &amp;_output[2] );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]),
					&amp;_output[0], &amp;_output[1], &amp;_output[2],
					&amp;_output[3] );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		err = (object-&gt;*func)(  ARG32(input[0]),
					&amp;_output[0], &amp;_output[1], &amp;_output[2],
					&amp;_output[3], &amp;_output[4] );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		err = (object-&gt;*func)(  &amp;_output[0], &amp;_output[1], &amp;_output[2],
					&amp;_output[3], &amp;_output[4], &amp;_output[5] );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
	}
    }
    <span class="enscript-keyword">while</span>( false);

    uint32_t i;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; *outputCount; i++)
	output[i] = SCALAR32(_output[i]);

    <span class="enscript-keyword">return</span>( err);
}

<span class="enscript-comment">/* Routine io_async_method_scalarI_scalarO */</span>
kern_return_t <span class="enscript-function-name">is_io_async_method_scalarI_scalarO</span>(
	io_object_t	   connect,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t	   index,
        io_scalar_inband_t       input,
        mach_msg_type_number_t	 inputCount,
        io_scalar_inband_t       output,
        mach_msg_type_number_t * outputCount )
{
    IOReturn err;
    uint32_t i;
    io_scalar_inband64_t _input;
    io_scalar_inband64_t _output;
    io_async_ref64_t _reference;

    bzero(&amp;_output[0], <span class="enscript-keyword">sizeof</span>(_output));
    <span class="enscript-keyword">for</span> (i = 0; i &lt; referenceCnt; i++)
	_reference[i] = REF64(reference[i]);

    mach_msg_type_number_t struct_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);

    err = is_io_connect_async_method(connect, 
		    wake_port, _reference, referenceCnt,
		    index, 
		    _input, inputCount, 
		    NULL, 0,
		    0, 0,
		    NULL, &amp;struct_outputCnt,
		    _output, outputCount,
		    0, &amp;ool_output_size);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; *outputCount; i++)
	output[i] = SCALAR32(_output[i]);

    <span class="enscript-keyword">return</span> (err);
}
<span class="enscript-comment">/* Routine io_async_method_scalarI_structureO */</span>
kern_return_t <span class="enscript-function-name">is_io_async_method_scalarI_structureO</span>(
	io_object_t	connect,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t	index,
        io_scalar_inband_t input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    uint32_t i;
    io_scalar_inband64_t _input;
    io_async_ref64_t _reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; referenceCnt; i++)
	_reference[i] = REF64(reference[i]);

    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);
	
    <span class="enscript-keyword">return</span> (is_io_connect_async_method(connect, 
		    wake_port, _reference, referenceCnt,
		    index,
		    _input, inputCount, 
		    NULL, 0,
		    0, 0,
		    output, outputCount,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}

<span class="enscript-comment">/* Routine io_async_method_scalarI_structureI */</span>
kern_return_t <span class="enscript-function-name">is_io_async_method_scalarI_structureI</span>(
	io_connect_t		connect,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t		index,
        io_scalar_inband_t	input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t	inputStruct,
        mach_msg_type_number_t	inputStructCount )
{
    uint32_t i;
    io_scalar_inband64_t _input;
    io_async_ref64_t _reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; referenceCnt; i++)
	_reference[i] = REF64(reference[i]);

    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_msg_type_number_t inband_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);
	
    <span class="enscript-keyword">return</span> (is_io_connect_async_method(connect, 
		    wake_port, _reference, referenceCnt,
		    index,
		    _input, inputCount, 
		    inputStruct, inputStructCount,
		    0, 0,
		    NULL, &amp;inband_outputCnt,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}

<span class="enscript-comment">/* Routine io_async_method_structureI_structureO */</span>
kern_return_t <span class="enscript-function-name">is_io_async_method_structureI_structureO</span>(
	io_object_t	connect,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t	index,
        io_struct_inband_t		input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    uint32_t i;
    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;
    io_async_ref64_t _reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; referenceCnt; i++)
	_reference[i] = REF64(reference[i]);

    <span class="enscript-keyword">return</span> (is_io_connect_async_method(connect,
		    wake_port, _reference, referenceCnt,
		    index,
		    NULL, 0, 
		    input, inputCount,
		    0, 0,
		    output, outputCount,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}


kern_return_t <span class="enscript-function-name">shim_io_async_method_scalarI_scalarO</span>(
	IOExternalAsyncMethod *	method,
	IOService *		object,
	mach_port_t             asyncWakePort,
	io_user_reference_t *   asyncReference,
	uint32_t                asyncReferenceCount,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	 inputCount,
        io_user_scalar_t * output,
        mach_msg_type_number_t * outputCount )
{
    IOAsyncMethod	func;
    uint32_t		i;
    io_scalar_inband_t  _output;
    IOReturn 		err;
    io_async_ref_t	reference;

    bzero(&amp;_output[0], <span class="enscript-keyword">sizeof</span>(_output));
    <span class="enscript-keyword">for</span> (i = 0; i &lt; asyncReferenceCount; i++)
	reference[i] = REF32(asyncReference[i]);

    err = kIOReturnBadArgument;

    <span class="enscript-keyword">do</span> {

	<span class="enscript-keyword">if</span>( inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( *outputCount != method-&gt;count1)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

        <span class="enscript-keyword">switch</span>( inputCount) {

            <span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]), ARG32(input[4]), ARG32(input[5]) );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
                err = (object-&gt;*func)(  reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]), ARG32(input[4]),
                                        &amp;_output[0] );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
                err = (object-&gt;*func)(  reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]),
                                        &amp;_output[0], &amp;_output[1] );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
                err = (object-&gt;*func)(  reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        &amp;_output[0], &amp;_output[1], &amp;_output[2] );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
                err = (object-&gt;*func)(  reference,
                                        ARG32(input[0]), ARG32(input[1]),
                                        &amp;_output[0], &amp;_output[1], &amp;_output[2],
                                        &amp;_output[3] );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
                err = (object-&gt;*func)(  reference,
                                        ARG32(input[0]), 
					&amp;_output[0], &amp;_output[1], &amp;_output[2],
                                        &amp;_output[3], &amp;_output[4] );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
                err = (object-&gt;*func)(  reference,
                                        &amp;_output[0], &amp;_output[1], &amp;_output[2],
                                        &amp;_output[3], &amp;_output[4], &amp;_output[5] );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
        }
    }
    <span class="enscript-keyword">while</span>( false);

    <span class="enscript-keyword">for</span> (i = 0; i &lt; *outputCount; i++)
	output[i] = SCALAR32(_output[i]);

    <span class="enscript-keyword">return</span>( err);
}


<span class="enscript-comment">/* Routine io_connect_method_scalarI_structureO */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_method_scalarI_structureO</span>(
	io_object_t	connect,
	uint32_t	index,
        io_scalar_inband_t input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    uint32_t i;
    io_scalar_inband64_t _input;

    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);
	
    <span class="enscript-keyword">return</span> (is_io_connect_method(connect, index, 
		    _input, inputCount, 
		    NULL, 0,
		    0, 0,
		    output, outputCount,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}

kern_return_t <span class="enscript-function-name">shim_io_connect_method_scalarI_structureO</span>(

	IOExternalMethod *	method,
	IOService *		object,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        IOByteCount *	outputCount )
{
    IOMethod		func;
    IOReturn 		err;

    err = kIOReturnBadArgument;

    <span class="enscript-keyword">do</span> {
	<span class="enscript-keyword">if</span>( inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (*outputCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

	<span class="enscript-keyword">switch</span>( inputCount) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]), ARG32(input[4]),
                                        output );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					ARG32(input[3]),
					output, (<span class="enscript-type">void</span> *)outputCount );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					output, (<span class="enscript-type">void</span> *)outputCount, 0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		err = (object-&gt;*func)(  ARG32(input[0]), ARG32(input[1]),
					output, (<span class="enscript-type">void</span> *)outputCount, 0, 0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		err = (object-&gt;*func)(  ARG32(input[0]),
					output, (<span class="enscript-type">void</span> *)outputCount, 0, 0, 0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		err = (object-&gt;*func)(  output, (<span class="enscript-type">void</span> *)outputCount, 0, 0, 0, 0 );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
	}
    }
    <span class="enscript-keyword">while</span>( false);

    <span class="enscript-keyword">return</span>( err);
}


kern_return_t <span class="enscript-function-name">shim_io_async_method_scalarI_structureO</span>(
	IOExternalAsyncMethod *	method,
	IOService *		object,
	mach_port_t             asyncWakePort,
	io_user_reference_t *   asyncReference,
	uint32_t                asyncReferenceCount,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    IOAsyncMethod	func;
    uint32_t		i;
    IOReturn 		err;
    io_async_ref_t	reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; asyncReferenceCount; i++)
	reference[i] = REF32(asyncReference[i]);

    err = kIOReturnBadArgument;
    <span class="enscript-keyword">do</span> {
	<span class="enscript-keyword">if</span>( inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (*outputCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

        <span class="enscript-keyword">switch</span>( inputCount) {

            <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]), ARG32(input[4]),
                                        output );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]),
                                        output, (<span class="enscript-type">void</span> *)outputCount );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        output, (<span class="enscript-type">void</span> *)outputCount, 0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]),
                                        output, (<span class="enscript-type">void</span> *)outputCount, 0, 0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]),
                                        output, (<span class="enscript-type">void</span> *)outputCount, 0, 0, 0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
                err = (object-&gt;*func)(	reference,
                                        output, (<span class="enscript-type">void</span> *)outputCount, 0, 0, 0, 0 );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
        }
    }
    <span class="enscript-keyword">while</span>( false);

    <span class="enscript-keyword">return</span>( err);
}

<span class="enscript-comment">/* Routine io_connect_method_scalarI_structureI */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_method_scalarI_structureI</span>(
	io_connect_t		connect,
	uint32_t		index,
        io_scalar_inband_t	input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t	inputStruct,
        mach_msg_type_number_t	inputStructCount )
{
    uint32_t i;
    io_scalar_inband64_t _input;

    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_msg_type_number_t inband_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; inputCount; i++)
	_input[i] = SCALAR64(input[i]);
	
    <span class="enscript-keyword">return</span> (is_io_connect_method(connect, index, 
		    _input, inputCount, 
		    inputStruct, inputStructCount,
		    0, 0,
		    NULL, &amp;inband_outputCnt,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}

kern_return_t <span class="enscript-function-name">shim_io_connect_method_scalarI_structureI</span>(
    IOExternalMethod *	method,
    IOService *		object,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		inputStruct,
        mach_msg_type_number_t	inputStructCount )
{
    IOMethod		func;
    IOReturn		err = kIOReturnBadArgument;

    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-keyword">if</span> (inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (inputStructCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

	<span class="enscript-keyword">switch</span>( inputCount) {

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		err = (object-&gt;*func)( ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					ARG32(input[3]), ARG32(input[4]), 
					inputStruct );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		err = (object-&gt;*func)( ARG32(input[0]), ARG32(input[1]), (<span class="enscript-type">void</span> *)  input[2],
					ARG32(input[3]),
					inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		err = (object-&gt;*func)( ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
					inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
					0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		err = (object-&gt;*func)( ARG32(input[0]), ARG32(input[1]),
					inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
					0, 0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
		err = (object-&gt;*func)( ARG32(input[0]),
					inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
					0, 0, 0 );
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		err = (object-&gt;*func)( inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
					0, 0, 0, 0 );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
	}
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">return</span>( err);
}

kern_return_t <span class="enscript-function-name">shim_io_async_method_scalarI_structureI</span>(
	IOExternalAsyncMethod *	method,
	IOService *		object,
	mach_port_t             asyncWakePort,
	io_user_reference_t *   asyncReference,
	uint32_t                asyncReferenceCount,
        <span class="enscript-type">const</span> io_user_scalar_t * input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		inputStruct,
        mach_msg_type_number_t	inputStructCount )
{
    IOAsyncMethod	func;
    uint32_t		i;
    IOReturn		err = kIOReturnBadArgument;
    io_async_ref_t	reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; asyncReferenceCount; i++)
	reference[i] = REF32(asyncReference[i]);

    <span class="enscript-keyword">do</span>
    {
	<span class="enscript-keyword">if</span> (inputCount != method-&gt;count0)
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (inputStructCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

        func = method-&gt;func;

        <span class="enscript-keyword">switch</span>( inputCount) {

            <span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]), ARG32(input[4]),
                                        inputStruct );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        ARG32(input[3]),
                                        inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]), ARG32(input[2]),
                                        inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
                                        0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]), ARG32(input[1]),
                                        inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
                                        0, 0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
                err = (object-&gt;*func)(	reference,
                                        ARG32(input[0]),
                                        inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
                                        0, 0, 0 );
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
                err = (object-&gt;*func)(	reference,
                                        inputStruct, (<span class="enscript-type">void</span> *)(uintptr_t)inputStructCount,
                                        0, 0, 0, 0 );
                <span class="enscript-keyword">break</span>;

            <span class="enscript-reference">default</span>:
                IOLog(<span class="enscript-string">&quot;%s: Bad method table\n&quot;</span>, object-&gt;getName());
        }
    }
    <span class="enscript-keyword">while</span> (false);

    <span class="enscript-keyword">return</span>( err);
}

<span class="enscript-comment">/* Routine io_connect_method_structureI_structureO */</span>
kern_return_t <span class="enscript-function-name">is_io_connect_method_structureI_structureO</span>(
	io_object_t	connect,
	uint32_t	index,
        io_struct_inband_t		input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    mach_msg_type_number_t scalar_outputCnt = 0;
    mach_vm_size_t ool_output_size = 0;

    <span class="enscript-keyword">return</span> (is_io_connect_method(connect, index, 
		    NULL, 0, 
		    input, inputCount,
		    0, 0,
		    output, outputCount,
		    NULL, &amp;scalar_outputCnt,
		    0, &amp;ool_output_size));
}

kern_return_t <span class="enscript-function-name">shim_io_connect_method_structureI_structureO</span>(
    IOExternalMethod *	method,
    IOService *		object,
        io_struct_inband_t		input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        IOByteCount *	outputCount )
{
    IOMethod		func;
    IOReturn 		err = kIOReturnBadArgument;

    <span class="enscript-keyword">do</span> 
    {
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count0)
		&amp;&amp; (inputCount != method-&gt;count0))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (*outputCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

	func = method-&gt;func;

	<span class="enscript-keyword">if</span>( method-&gt;count1) {
	    <span class="enscript-keyword">if</span>( method-&gt;count0) {
		err = (object-&gt;*func)( input, output,
					(<span class="enscript-type">void</span> *)(uintptr_t)inputCount, outputCount, 0, 0 );
	    } <span class="enscript-keyword">else</span> {
		err = (object-&gt;*func)( output, outputCount, 0, 0, 0, 0 );
	    }
	} <span class="enscript-keyword">else</span> {
		err = (object-&gt;*func)( input, (<span class="enscript-type">void</span> *)(uintptr_t)inputCount, 0, 0, 0, 0 );
	}
    }
    <span class="enscript-keyword">while</span>( false);


    <span class="enscript-keyword">return</span>( err);
}

kern_return_t <span class="enscript-function-name">shim_io_async_method_structureI_structureO</span>(
	IOExternalAsyncMethod *	method,
	IOService *		object,
	mach_port_t           asyncWakePort,
	io_user_reference_t * asyncReference,
	uint32_t              asyncReferenceCount,
        io_struct_inband_t		input,
        mach_msg_type_number_t	inputCount,
        io_struct_inband_t		output,
        mach_msg_type_number_t *	outputCount )
{
    IOAsyncMethod	func;
    uint32_t            i;
    IOReturn 		err;
    io_async_ref_t	reference;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; asyncReferenceCount; i++)
	reference[i] = REF32(asyncReference[i]);

    err = kIOReturnBadArgument;
    <span class="enscript-keyword">do</span> 
    {
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count0)
		&amp;&amp; (inputCount != method-&gt;count0))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient inputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}
	<span class="enscript-keyword">if</span>( (kIOUCVariableStructureSize != method-&gt;count1)
		&amp;&amp; (*outputCount != method-&gt;count1))
	{
	    IOLog(<span class="enscript-string">&quot;%s: IOUserClient outputCount count mismatch\n&quot;</span>, object-&gt;getName());
	    <span class="enscript-keyword">continue</span>;
	}

        func = method-&gt;func;

        <span class="enscript-keyword">if</span>( method-&gt;count1) {
            <span class="enscript-keyword">if</span>( method-&gt;count0) {
                err = (object-&gt;*func)( reference,
                                       input, output,
                                        (<span class="enscript-type">void</span> *)(uintptr_t)inputCount, outputCount, 0, 0 );
            } <span class="enscript-keyword">else</span> {
                err = (object-&gt;*func)( reference,
                                       output, outputCount, 0, 0, 0, 0 );
            }
        } <span class="enscript-keyword">else</span> {
                err = (object-&gt;*func)( reference,
                                       input, (<span class="enscript-type">void</span> *)(uintptr_t)inputCount, 0, 0, 0, 0 );
        }
    }
    <span class="enscript-keyword">while</span>( false);

    <span class="enscript-keyword">return</span>( err);
}

<span class="enscript-comment">/* Routine io_catalog_send_data */</span>
kern_return_t <span class="enscript-function-name">is_io_catalog_send_data</span>(
        mach_port_t		master_port,
        uint32_t                flag,
        io_buf_ptr_t 		inData,
        mach_msg_type_number_t 	inDataCount,
        kern_return_t *		result)
{
    OSObject * obj = 0;
    vm_offset_t data;
    kern_return_t kr = kIOReturnError;

    <span class="enscript-comment">//printf(&quot;io_catalog_send_data called. flag: %d\n&quot;, flag);
</span>    
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    <span class="enscript-keyword">if</span>( (flag != kIOCatalogRemoveKernelLinker &amp;&amp; 
            flag != kIOCatalogKextdActive &amp;&amp;
            flag != kIOCatalogKextdFinishedLaunching) &amp;&amp; 
        ( !inData || !inDataCount) ) 
    {
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }

    <span class="enscript-keyword">if</span> (inData) {
        vm_map_offset_t map_data;

        <span class="enscript-keyword">if</span>( inDataCount &gt; <span class="enscript-keyword">sizeof</span>(io_struct_inband_t) * 1024)
            <span class="enscript-keyword">return</span>( kIOReturnMessageTooLarge);

        kr = vm_map_copyout( kernel_map, &amp;map_data, (vm_map_copy_t)inData);
		data = CAST_DOWN(vm_offset_t, map_data);

        <span class="enscript-keyword">if</span>( kr != KERN_SUCCESS)
            <span class="enscript-keyword">return</span> kr;

        <span class="enscript-comment">// must return success after vm_map_copyout() succeeds
</span>
        <span class="enscript-keyword">if</span>( inDataCount ) {
            obj = (OSObject *)OSUnserializeXML((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)data, inDataCount);
            vm_deallocate( kernel_map, data, inDataCount );
            <span class="enscript-keyword">if</span>( !obj) {
                *result = kIOReturnNoMemory;
                <span class="enscript-keyword">return</span>( KERN_SUCCESS);
            }
        }
    }

    <span class="enscript-keyword">switch</span> ( flag ) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogResetDrivers</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogResetDriversNoMatch</span>: {
                OSArray * array;

                array = OSDynamicCast(OSArray, obj);
                <span class="enscript-keyword">if</span> (array) {
                   <span class="enscript-keyword">if</span> ( !gIOCatalogue-&gt;resetAndAddDrivers(array,
                        flag == kIOCatalogResetDrivers) ) {

                        kr = kIOReturnError;
                    }
                } <span class="enscript-keyword">else</span> {
                    kr = kIOReturnBadArgument;
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogAddDrivers</span>: 
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogAddDriversNoMatch</span>: {
                OSArray * array;

                array = OSDynamicCast(OSArray, obj);
                <span class="enscript-keyword">if</span> ( array ) {
                    <span class="enscript-keyword">if</span> ( !gIOCatalogue-&gt;addDrivers( array , 
                                          flag == kIOCatalogAddDrivers) ) {
                        kr = kIOReturnError;
                    }
                }
                <span class="enscript-keyword">else</span> {
                    kr = kIOReturnBadArgument;
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogRemoveDrivers</span>: 
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogRemoveDriversNoMatch</span>: {
                OSDictionary * dict;

                dict = OSDynamicCast(OSDictionary, obj);
                <span class="enscript-keyword">if</span> ( dict ) {
                    <span class="enscript-keyword">if</span> ( !gIOCatalogue-&gt;removeDrivers( dict, 
                                          flag == kIOCatalogRemoveDrivers ) ) {
                        kr = kIOReturnError;
                    }
                }
                <span class="enscript-keyword">else</span> {
                    kr = kIOReturnBadArgument;
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogStartMatching</span>: {
                OSDictionary * dict;

                dict = OSDynamicCast(OSDictionary, obj);
                <span class="enscript-keyword">if</span> ( dict ) {
                    <span class="enscript-keyword">if</span> ( !gIOCatalogue-&gt;startMatching( dict ) ) {
                        kr = kIOReturnError;
                    }
                }
                <span class="enscript-keyword">else</span> {
                    kr = kIOReturnBadArgument;
                }
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogRemoveKernelLinker</span>:
            kr = KERN_NOT_SUPPORTED;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogKextdActive</span>:
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
            IOServiceTrace(IOSERVICE_KEXTD_ALIVE, 0, 0, 0, 0);
            <span class="enscript-reference">OSKext</span>::setKextdActive();

           <span class="enscript-comment">/* Dump all nonloaded startup extensions; kextd will now send them
            * down on request.
            */</span>
            <span class="enscript-reference">OSKext</span>::flushNonloadedKexts( <span class="enscript-comment">/* flushPrelinkedKexts */</span> false);
#<span class="enscript-reference">endif</span>
            kr = kIOReturnSuccess;
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogKextdFinishedLaunching</span>: {
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NO_KEXTD</span>
                <span class="enscript-type">static</span> <span class="enscript-type">bool</span> clearedBusy = false;

                <span class="enscript-keyword">if</span> (!clearedBusy) {
                    IOService * serviceRoot = IOService::getServiceRoot();
                    <span class="enscript-keyword">if</span> (serviceRoot) {
                        IOServiceTrace(IOSERVICE_KEXTD_READY, 0, 0, 0, 0);
                        serviceRoot-&gt;adjustBusy(-1);
                        clearedBusy = true;
                    }
                }
#<span class="enscript-reference">endif</span>
                kr = kIOReturnSuccess;
            }
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            kr = kIOReturnBadArgument;
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (obj) obj-&gt;release();
    
    *result = kr;
    <span class="enscript-keyword">return</span>( KERN_SUCCESS);
}

<span class="enscript-comment">/* Routine io_catalog_terminate */</span>
kern_return_t <span class="enscript-function-name">is_io_catalog_terminate</span>(
	mach_port_t master_port,
	uint32_t flag,
	io_name_t name )
{
    kern_return_t	   kr;

    <span class="enscript-keyword">if</span>( master_port != master_device_port )
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    kr = IOUserClient::clientHasPrivilege( (<span class="enscript-type">void</span> *) current_task(),
                                            kIOClientPrivilegeAdministrator );
    <span class="enscript-keyword">if</span>( kIOReturnSuccess != kr)
        <span class="enscript-keyword">return</span>( kr );

    <span class="enscript-keyword">switch</span> ( flag ) {
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">SECURE_KERNEL</span>)
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogServiceTerminate</span>:
            OSIterator *	iter;
            IOService *		service;

            iter = IORegistryIterator::iterateOver(gIOServicePlane,
                                        kIORegistryIterateRecursively);
            <span class="enscript-keyword">if</span> ( !iter )
                <span class="enscript-keyword">return</span> kIOReturnNoMemory;

            <span class="enscript-keyword">do</span> {
                iter-&gt;reset();
                <span class="enscript-keyword">while</span>( (service = (IOService *)iter-&gt;getNextObject()) ) {
                    <span class="enscript-keyword">if</span>( service-&gt;metaCast(name)) {
                        <span class="enscript-keyword">if</span> ( !service-&gt;terminate( kIOServiceRequired
                                                | kIOServiceSynchronous) ) {
                            kr = kIOReturnUnsupported;
                            <span class="enscript-keyword">break</span>;
                        }
                    }
                }
            } <span class="enscript-keyword">while</span>( !service &amp;&amp; !iter-&gt;isValid());
            iter-&gt;release();
            <span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogModuleUnload</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogModuleTerminate</span>:
            kr = gIOCatalogue-&gt;terminateDriversForModule(name,
                                        flag == kIOCatalogModuleUnload);
            <span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

        <span class="enscript-reference">default</span>:
            kr = kIOReturnBadArgument;
            <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">return</span>( kr );
}

<span class="enscript-comment">/* Routine io_catalog_get_data */</span>
kern_return_t <span class="enscript-function-name">is_io_catalog_get_data</span>(
        mach_port_t		master_port,
        uint32_t                flag,
        io_buf_ptr_t 		*outData,
        mach_msg_type_number_t 	*outDataCount)
{
    kern_return_t kr = kIOReturnSuccess;
    OSSerialize * s;
    
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    <span class="enscript-comment">//printf(&quot;io_catalog_get_data called. flag: %d\n&quot;, flag);
</span>    
    s = OSSerialize::withCapacity(4096);
    <span class="enscript-keyword">if</span> ( !s )
        <span class="enscript-keyword">return</span> kIOReturnNoMemory;

    kr = gIOCatalogue-&gt;serializeData(flag, s);

    <span class="enscript-keyword">if</span> ( kr == kIOReturnSuccess ) {
        vm_offset_t data;
        vm_map_copy_t copy;
        vm_size_t size;

        size = s-&gt;getLength();
        kr = vm_allocate(kernel_map, &amp;data, size, VM_FLAGS_ANYWHERE);
        <span class="enscript-keyword">if</span> ( kr == kIOReturnSuccess ) {
            bcopy(s-&gt;text(), (<span class="enscript-type">void</span> *)data, size);
            kr = vm_map_copyin(kernel_map, (vm_map_address_t)data,
			       (vm_map_size_t)size, true, &amp;copy);
            *outData = (<span class="enscript-type">char</span> *)copy;
            *outDataCount = size;
        }
    }

    s-&gt;release();

    <span class="enscript-keyword">return</span> kr;
}

<span class="enscript-comment">/* Routine io_catalog_get_gen_count */</span>
kern_return_t <span class="enscript-function-name">is_io_catalog_get_gen_count</span>(
        mach_port_t		master_port,
        uint32_t                *genCount)
{
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    <span class="enscript-comment">//printf(&quot;io_catalog_get_gen_count called.\n&quot;);
</span>
    <span class="enscript-keyword">if</span> ( !genCount )
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;

    *genCount = gIOCatalogue-&gt;getGenerationCount();
    
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

<span class="enscript-comment">/* Routine io_catalog_module_loaded.
 * Is invoked from IOKitLib's IOCatalogueModuleLoaded(). Doesn't seem to be used.
 */</span>
kern_return_t <span class="enscript-function-name">is_io_catalog_module_loaded</span>(
        mach_port_t		master_port,
        io_name_t               name)
{
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    <span class="enscript-comment">//printf(&quot;io_catalog_module_loaded called. name %s\n&quot;, name);
</span>    
    <span class="enscript-keyword">if</span> ( !name )
        <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    
    gIOCatalogue-&gt;moduleHasLoaded(name);
    
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

kern_return_t <span class="enscript-function-name">is_io_catalog_reset</span>(
	mach_port_t		master_port,
	uint32_t		flag)
{
    <span class="enscript-keyword">if</span>( master_port != master_device_port)
        <span class="enscript-keyword">return</span> kIOReturnNotPrivileged;

    <span class="enscript-keyword">switch</span> ( flag ) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOCatalogResetDefault</span>:
            gIOCatalogue-&gt;reset();
            <span class="enscript-keyword">break</span>;

        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span> kIOReturnBadArgument;
    }
    
    <span class="enscript-keyword">return</span> kIOReturnSuccess;
}

kern_return_t <span class="enscript-function-name">iokit_user_client_trap</span>(<span class="enscript-type">struct</span> iokit_user_client_trap_args *args)
{
    kern_return_t result = kIOReturnBadArgument;
    IOUserClient *userClient;

    <span class="enscript-keyword">if</span> ((userClient = OSDynamicCast(IOUserClient,
            iokit_lookup_connect_ref_current_task((OSObject *)(args-&gt;userClientRef))))) {
        IOExternalTrap *trap;
        IOService *target = NULL;

        trap = userClient-&gt;getTargetAndTrapForIndex(&amp;target, args-&gt;index);

        <span class="enscript-keyword">if</span> (trap &amp;&amp; target) {
            IOTrap func;

            func = trap-&gt;func;

            <span class="enscript-keyword">if</span> (func) {
                result = (target-&gt;*func)(args-&gt;p1, args-&gt;p2, args-&gt;p3, args-&gt;p4, args-&gt;p5, args-&gt;p6);
            }
        }

        userClient-&gt;release();
    }

    <span class="enscript-keyword">return</span> result;
}

} <span class="enscript-comment">/* extern &quot;C&quot; */</span>

IOReturn <span class="enscript-function-name">IOUserClient::externalMethod</span>( uint32_t selector, IOExternalMethodArguments * args,
					IOExternalMethodDispatch * dispatch, OSObject * target, <span class="enscript-type">void</span> * reference )
{
    IOReturn    err;
    IOService * object;
    IOByteCount structureOutputSize;

    <span class="enscript-keyword">if</span> (dispatch)
    {
	uint32_t count;
	count = dispatch-&gt;checkScalarInputCount;
	<span class="enscript-keyword">if</span> ((kIOUCVariableStructureSize != count) &amp;&amp; (count != args-&gt;scalarInputCount))
	{
	    <span class="enscript-keyword">return</span> (kIOReturnBadArgument);
	}

	count = dispatch-&gt;checkStructureInputSize;
	<span class="enscript-keyword">if</span> ((kIOUCVariableStructureSize != count) 
	    &amp;&amp; (count != ((args-&gt;structureInputDescriptor) 
			    ? args-&gt;structureInputDescriptor-&gt;getLength() : args-&gt;structureInputSize)))
	{
	    <span class="enscript-keyword">return</span> (kIOReturnBadArgument);
	}

	count = dispatch-&gt;checkScalarOutputCount;
	<span class="enscript-keyword">if</span> ((kIOUCVariableStructureSize != count) &amp;&amp; (count != args-&gt;scalarOutputCount))
	{
	    <span class="enscript-keyword">return</span> (kIOReturnBadArgument);
	}

	count = dispatch-&gt;checkStructureOutputSize;
	<span class="enscript-keyword">if</span> ((kIOUCVariableStructureSize != count) 
	    &amp;&amp; (count != ((args-&gt;structureOutputDescriptor) 
			    ? args-&gt;structureOutputDescriptor-&gt;getLength() : args-&gt;structureOutputSize)))
	{
	    <span class="enscript-keyword">return</span> (kIOReturnBadArgument);
	}

	<span class="enscript-keyword">if</span> (dispatch-&gt;function)
	    err = (*dispatch-&gt;function)(target, reference, args);
	<span class="enscript-keyword">else</span>
	    err = kIOReturnNoCompletion;	    <span class="enscript-comment">/* implementator can dispatch */</span>

	<span class="enscript-keyword">return</span> (err);
    }


    <span class="enscript-comment">// pre-Leopard API's don't do ool structs
</span>    <span class="enscript-keyword">if</span> (args-&gt;structureInputDescriptor || args-&gt;structureOutputDescriptor)
    {
       err = kIOReturnIPCError;
       <span class="enscript-keyword">return</span> (err);
    }

    structureOutputSize = args-&gt;structureOutputSize;

    <span class="enscript-keyword">if</span> (args-&gt;asyncWakePort)
    {
	IOExternalAsyncMethod *	method;
	object = 0;
	<span class="enscript-keyword">if</span>( !(method = getAsyncTargetAndMethodForIndex(&amp;object, selector)) || !object )
	    <span class="enscript-keyword">return</span> (kIOReturnUnsupported);

    <span class="enscript-keyword">if</span> (kIOUCForegroundOnly &amp; method-&gt;flags)
    {
	<span class="enscript-keyword">if</span> (task_is_gpu_denied(current_task()))
            <span class="enscript-keyword">return</span> (kIOReturnNotPermitted);
    }

	<span class="enscript-keyword">switch</span> (method-&gt;flags &amp; kIOUCTypeMask)
	{
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIStructI</span>:
		err = shim_io_async_method_scalarI_structureI( method, object,
					args-&gt;asyncWakePort, args-&gt;asyncReference, args-&gt;asyncReferenceCount,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					(<span class="enscript-type">char</span> *)args-&gt;structureInput, args-&gt;structureInputSize );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIScalarO</span>:
		err = shim_io_async_method_scalarI_scalarO( method, object,
					args-&gt;asyncWakePort, args-&gt;asyncReference, args-&gt;asyncReferenceCount,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					args-&gt;scalarOutput, &amp;args-&gt;scalarOutputCount );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIStructO</span>:
		err = shim_io_async_method_scalarI_structureO( method, object,
					args-&gt;asyncWakePort, args-&gt;asyncReference, args-&gt;asyncReferenceCount,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					(<span class="enscript-type">char</span> *) args-&gt;structureOutput, &amp;args-&gt;structureOutputSize );
		<span class="enscript-keyword">break</span>;


	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCStructIStructO</span>:
		err = shim_io_async_method_structureI_structureO( method, object,
					args-&gt;asyncWakePort, args-&gt;asyncReference, args-&gt;asyncReferenceCount,
					(<span class="enscript-type">char</span> *)args-&gt;structureInput, args-&gt;structureInputSize,
					(<span class="enscript-type">char</span> *) args-&gt;structureOutput, &amp;args-&gt;structureOutputSize );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		err = kIOReturnBadArgument;
		<span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">else</span>
    {
	IOExternalMethod *	method;
	object = 0;
	<span class="enscript-keyword">if</span>( !(method = getTargetAndMethodForIndex(&amp;object, selector)) || !object )
	    <span class="enscript-keyword">return</span> (kIOReturnUnsupported);

    <span class="enscript-keyword">if</span> (kIOUCForegroundOnly &amp; method-&gt;flags)
    {
	<span class="enscript-keyword">if</span> (task_is_gpu_denied(current_task()))
            <span class="enscript-keyword">return</span> (kIOReturnNotPermitted);
    }

	<span class="enscript-keyword">switch</span> (method-&gt;flags &amp; kIOUCTypeMask)
	{
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIStructI</span>:
		err = shim_io_connect_method_scalarI_structureI( method, object,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					(<span class="enscript-type">char</span> *) args-&gt;structureInput, args-&gt;structureInputSize );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIScalarO</span>:
		err = shim_io_connect_method_scalarI_scalarO( method, object,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					args-&gt;scalarOutput, &amp;args-&gt;scalarOutputCount );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCScalarIStructO</span>:
		err = shim_io_connect_method_scalarI_structureO( method, object,
					args-&gt;scalarInput, args-&gt;scalarInputCount,
					(<span class="enscript-type">char</span> *) args-&gt;structureOutput, &amp;structureOutputSize );
		<span class="enscript-keyword">break</span>;


	    <span class="enscript-keyword">case</span> <span class="enscript-reference">kIOUCStructIStructO</span>:
		err = shim_io_connect_method_structureI_structureO( method, object,
					(<span class="enscript-type">char</span> *) args-&gt;structureInput, args-&gt;structureInputSize,
					(<span class="enscript-type">char</span> *) args-&gt;structureOutput, &amp;structureOutputSize );
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-reference">default</span>:
		err = kIOReturnBadArgument;
		<span class="enscript-keyword">break</span>;
	}
    }

    args-&gt;structureOutputSize = structureOutputSize;

    <span class="enscript-keyword">return</span> (err);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 1);
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOUserClient, 0);
<span class="enscript-function-name">OSMetaClassDefineReservedUsed</span>(IOUserClient, 1);
#<span class="enscript-reference">endif</span>
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 2);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 3);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 4);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 5);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 6);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 7);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 8);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 9);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 10);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 11);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 12);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 13);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 14);
<span class="enscript-function-name">OSMetaClassDefineReservedUnused</span>(IOUserClient, 15);

</pre>
<hr />
</body></html>