<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>TestIOMemoryDescriptor.cpp</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">TestIOMemoryDescriptor.cpp&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/system.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOLib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMapper.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IODMACommand.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitKeysPrivate.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOSubMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOSubMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMultiMemoryDescriptor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBufferMemoryDescriptor.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOKitDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>

__BEGIN_DECLS
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;device/device_port.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
__END_DECLS


<span class="enscript-comment">/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">IOMultMemoryDescriptorTest</span>(<span class="enscript-type">int</span> newValue)
{
    IOMemoryDescriptor * mds[3];
    IOMultiMemoryDescriptor * mmd;
    IOMemoryMap * map;
    <span class="enscript-type">void</span> * addr;
    uint8_t * data;
    uint32_t i;
    IOAddressRange ranges[2];

    data = (typeof(data)) IOMallocAligned(ptoa(8), page_size);
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ptoa(8); i++) data[i] = atop(i) | 0xD0;
   
    ranges[0].address = (IOVirtualAddress)(data + ptoa(4));
    ranges[0].length  = ptoa(4);
    ranges[1].address = (IOVirtualAddress)(data + ptoa(0));
    ranges[1].length  = ptoa(4);

    mds[0] = IOMemoryDescriptor::withAddressRanges(&amp;ranges[0], 2, kIODirectionOutIn, kernel_task);

    mds[1] = IOSubMemoryDescriptor::withSubRange(mds[0], ptoa(3), ptoa(2), kIODirectionOutIn);
    mds[2] = IOSubMemoryDescriptor::withSubRange(mds[0], ptoa(7), ptoa(1), kIODirectionOutIn);

    mmd = IOMultiMemoryDescriptor::withDescriptors(&amp;mds[0], <span class="enscript-keyword">sizeof</span>(mds)/<span class="enscript-keyword">sizeof</span>(mds[0]), kIODirectionOutIn, false);
    mds[2]-&gt;release();
    mds[1]-&gt;release();
    mds[0]-&gt;release();
    map = mmd-&gt;createMappingInTask(kernel_task, 0, kIOMapAnywhere, ptoa(7), mmd-&gt;getLength() - ptoa(7));
    mmd-&gt;release();
    assert(map);

    addr = (<span class="enscript-type">void</span> *) map-&gt;getVirtualAddress();
    assert(ptoa(4) == map-&gt;getLength());
    assert(0xd3d3d3d3 == ((uint32_t *)addr)[ptoa(0) / <span class="enscript-keyword">sizeof</span>(uint32_t)]);
    assert(0xd7d7d7d7 == ((uint32_t *)addr)[ptoa(1) / <span class="enscript-keyword">sizeof</span>(uint32_t)]);
    assert(0xd0d0d0d0 == ((uint32_t *)addr)[ptoa(2) / <span class="enscript-keyword">sizeof</span>(uint32_t)]);
    assert(0xd3d3d3d3 == ((uint32_t *)addr)[ptoa(3) / <span class="enscript-keyword">sizeof</span>(uint32_t)]);
    map-&gt;release();
    IOFreeAligned(data, ptoa(8));

    <span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">int</span> <span class="enscript-function-name">IOMemoryDescriptorTest</span>(<span class="enscript-type">int</span> newValue)
{
    <span class="enscript-type">int</span> result;

#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">if</span> (5 == newValue)
    {
	IOReturn             ret;
	IOMemoryDescriptor * md;
	IODMACommand       * dma;
	<span class="enscript-reference">IODMACommand</span>::SegmentOptions segOptions =
	{
	    .fStructSize      = <span class="enscript-keyword">sizeof</span>(segOptions),
	    .fNumAddressBits  = 64,
	    .fMaxSegmentSize  = 4096,
	    .fMaxTransferSize = 128*1024,
	    .fAlignment       = 4,
	    .fAlignmentLength = 4,
	    .fAlignmentInternalSegments = 0x1000
	};

	IOAddressRange ranges[3][2] =
	{
	    {
		{ (uintptr_t) &amp;IOMemoryDescriptorTest, 0x2ffc },
		{ 0, 0 },
	    },
	    {
		{ ranges[0][0].address, 0x10 },
		{ 0x3000 + ranges[0][0].address, 0xff0 },
	    },
	    {
		{ ranges[0][0].address, 0x2ffc },
		{ trunc_page(ranges[0][0].address), 0x800 },
	    },
	};
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t rangesCount[3] = { 1, 2, 2 };
	uint32_t test;

	<span class="enscript-keyword">for</span> (test = 0; test &lt; 3; test++)
	{
	    kprintf(<span class="enscript-string">&quot;---[%d] address 0x%qx-0x%qx, 0x%qx-0x%qx\n&quot;</span>, test, 
	    			ranges[test][0].address, ranges[test][0].length,
	    			ranges[test][1].address, ranges[test][1].length);

	    md = IOMemoryDescriptor::withAddressRanges((IOAddressRange*)&amp;ranges[test][0], rangesCount[test], kIODirectionOut, kernel_task);
	    assert(md);
	    ret = md-&gt;prepare();
	    assert(kIOReturnSuccess == ret);
	    dma = IODMACommand::withSpecification(kIODMACommandOutputHost64, &amp;segOptions,
						  <span class="enscript-reference">IODMACommand</span>::kMapped, NULL, NULL);
	    assert(dma);
	    ret = dma-&gt;setMemoryDescriptor(md, true);
	    <span class="enscript-keyword">if</span> (kIOReturnSuccess == ret)
	    {
		<span class="enscript-reference">IODMACommand</span>::Segment64 segments[1];
		UInt32                  numSegments;
		UInt64                  offset;

		offset = 0;
		<span class="enscript-keyword">do</span>
		{
		    numSegments = 1;
		    ret = dma-&gt;gen64IOVMSegments(&amp;offset, &amp;segments[0], &amp;numSegments);
		    assert(kIOReturnSuccess == ret);
		    assert(1 == numSegments);
		    kprintf(<span class="enscript-string">&quot;seg 0x%qx, 0x%qx\n&quot;</span>, segments[0].fIOVMAddr, segments[0].fLength);
		}
		<span class="enscript-keyword">while</span> (offset &lt; md-&gt;getLength());

		ret = dma-&gt;clearMemoryDescriptor(true);
		assert(kIOReturnSuccess == ret);
		dma-&gt;release();
	    }
	    md-&gt;release();
        }

	<span class="enscript-keyword">return</span> (kIOReturnSuccess);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (4 == newValue)
    {
	IOService * isp;
	IOMapper *  mapper;
	IOBufferMemoryDescriptor * md1;
	IODMACommand * dma;
	IOReturn       ret;
	size_t         bufSize = 8192 * 8192 * <span class="enscript-keyword">sizeof</span>(uint32_t);
	uint64_t start, time, nano;

	isp = IOService::copyMatchingService(IOService::nameMatching(<span class="enscript-string">&quot;isp&quot;</span>));
	assert(isp);
        mapper = IOMapper::copyMapperForDeviceWithIndex(isp, 0);
	assert(mapper);

	md1 = IOBufferMemoryDescriptor::inTaskWithOptions(TASK_NULL, 
		kIODirectionOutIn | kIOMemoryPersistent | kIOMemoryPageable,
		bufSize, page_size);

	ret = md1-&gt;prepare();
	assert(kIOReturnSuccess == ret);

	IODMAMapSpecification mapSpec;
	bzero(&amp;mapSpec, <span class="enscript-keyword">sizeof</span>(mapSpec));
	uint64_t mapped;
	uint64_t mappedLength;

	start = mach_absolute_time();

	ret =  md1-&gt;dmaMap(mapper, NULL, &amp;mapSpec, 0, bufSize, &amp;mapped, &amp;mappedLength);
	assert(kIOReturnSuccess == ret);

	time = mach_absolute_time() - start;

	absolutetime_to_nanoseconds(time, &amp;nano);
	kprintf(<span class="enscript-string">&quot;time %lld us\n&quot;</span>, nano / 1000ULL);
	kprintf(<span class="enscript-string">&quot;seg0 0x%qx, 0x%qx\n&quot;</span>, mapped, mappedLength);

	assert(md1);

	dma = IODMACommand::withSpecification(kIODMACommandOutputHost32, 
				32, 0, IODMACommand::kMapped, 0, 1, mapper, NULL);

	assert(dma);

	start = mach_absolute_time();
	ret = dma-&gt;setMemoryDescriptor(md1, true);
	assert(kIOReturnSuccess == ret);
	time = mach_absolute_time() - start;

	absolutetime_to_nanoseconds(time, &amp;nano);
	kprintf(<span class="enscript-string">&quot;time %lld us\n&quot;</span>, nano / 1000ULL);

	
	<span class="enscript-reference">IODMACommand</span>::Segment32 segments[1];
	UInt32                  numSegments = 1;
	UInt64                  offset;

	offset = 0;
	ret = dma-&gt;gen32IOVMSegments(&amp;offset, &amp;segments[0], &amp;numSegments);
	assert(kIOReturnSuccess == ret);
	assert(1 == numSegments);
	kprintf(<span class="enscript-string">&quot;seg0 0x%x, 0x%x\n&quot;</span>, (<span class="enscript-type">int</span>)segments[0].fIOVMAddr, (<span class="enscript-type">int</span>)segments[0].fLength);

	ret = dma-&gt;clearMemoryDescriptor(true);
	assert(kIOReturnSuccess == ret);

	md1-&gt;release();

	<span class="enscript-keyword">return</span> (kIOReturnSuccess);
    }

    <span class="enscript-keyword">if</span> (3 == newValue)
    {
	IOBufferMemoryDescriptor * md1;
	IOBufferMemoryDescriptor * md2;
	IOMemoryMap * map1;
	IOMemoryMap * map2;
	uint32_t * buf1;
	uint32_t * buf2;
	IOReturn err;

	md1 = IOBufferMemoryDescriptor::inTaskWithOptions(TASK_NULL, 
		kIODirectionOutIn | kIOMemoryPersistent | kIOMemoryPageable,
		64*1024, page_size);
	assert(md1);
	map1 = md1-&gt;createMappingInTask(kernel_task, 0, kIOMapAnywhere | kIOMapUnique);
	assert(map1);
	buf1 = (uint32_t *) map1-&gt;getVirtualAddress();

	md2 = IOBufferMemoryDescriptor::inTaskWithOptions(TASK_NULL, 
		kIODirectionOutIn | kIOMemoryPersistent | kIOMemoryPageable,
		64*1024, page_size);
	assert(md2);
	map2 = md2-&gt;createMappingInTask(kernel_task, 0, kIOMapAnywhere | kIOMapUnique);
	assert(map2);
	buf2 = (uint32_t *) map2-&gt;getVirtualAddress();

	memset(buf1, 0x11, 64*1024L);
	memset(buf2, 0x22, 64*1024L);

	kprintf(<span class="enscript-string">&quot;md1 %p, map1 %p, buf2 %p; md2 %p, map2 %p, buf2 %p\n&quot;</span>, md1, map1, buf1, md2, map2, buf2);

	kprintf(<span class="enscript-string">&quot;no redir 0x%08x, 0x%08x\n&quot;</span>, buf1[0], buf2[0]);
	assert(0x11111111 == buf1[0]);
	assert(0x22222222 == buf2[0]);
	err = map1-&gt;redirect(md2, 0, 0ULL);
	kprintf(<span class="enscript-string">&quot;redir md2(0x%x) 0x%08x, 0x%08x\n&quot;</span>, err, buf1[0], buf2[0]);
	assert(0x11111111 == buf2[0]);
	assert(0x22222222 == buf1[0]);
	err = map1-&gt;redirect(md1, 0, 0ULL);
	kprintf(<span class="enscript-string">&quot;redir md1(0x%x) 0x%08x, 0x%08x\n&quot;</span>, err, buf1[0], buf2[0]);
	assert(0x11111111 == buf1[0]);
	assert(0x22222222 == buf2[0]);
	map1-&gt;release();
	map2-&gt;release();
	md1-&gt;release();
	md2-&gt;release();
    }
#<span class="enscript-reference">endif</span>

    result = IOMultMemoryDescriptorTest(newValue);
    <span class="enscript-keyword">if</span> (result) <span class="enscript-keyword">return</span> (result);

    IOGeneralMemoryDescriptor * md;
    vm_offset_t data[2];
    vm_size_t  bsize = 16*1024*1024;
    vm_size_t  srcsize, srcoffset, mapoffset, size;
    kern_return_t kr;

    kr = vm_allocate(kernel_map, &amp;data[0], bsize, VM_FLAGS_ANYWHERE);
    vm_inherit(kernel_map, data[0] + ptoa(1), ptoa(1), VM_INHERIT_NONE);
    vm_inherit(kernel_map, data[0] + ptoa(16), ptoa(4), VM_INHERIT_NONE);

    IOLog(<span class="enscript-string">&quot;data 0x%lx, 0x%lx\n&quot;</span>, (<span class="enscript-type">long</span>)data[0], (<span class="enscript-type">long</span>)data[1]);

    uint32_t idx, offidx;
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; (bsize / <span class="enscript-keyword">sizeof</span>(uint32_t)); idx++)
    {
	((uint32_t*)data[0])[idx] = idx;    
    }

    <span class="enscript-keyword">for</span> (srcoffset = 0; srcoffset &lt; bsize; srcoffset = ((srcoffset &lt;&lt; 2) + 0x40c))
    {
	<span class="enscript-keyword">for</span> (srcsize = 4; srcsize &lt; (bsize - srcoffset - 1); srcsize = ((srcsize &lt;&lt; 2) + 0x3fc))
	{
	    IOAddressRange ranges[3];
	    uint32_t rangeCount = 1;

	    bzero(&amp;ranges[0], <span class="enscript-keyword">sizeof</span>(ranges));
	    ranges[0].address = data[0] + srcoffset;
	    ranges[0].length  = srcsize;

	    <span class="enscript-keyword">if</span> (srcsize &gt; ptoa(5))
	    {
		ranges[0].length  = 7634;
		ranges[1].length  = 9870;
		ranges[2].length  = srcsize - ranges[0].length - ranges[1].length;
		ranges[1].address = ranges[0].address + ranges[0].length;
		ranges[2].address = ranges[1].address + ranges[1].length;
		rangeCount = 3;	    
	    }
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((srcsize &gt; ptoa(2)) &amp;&amp; !(page_mask &amp; srcoffset))
	    {
		ranges[0].length  = ptoa(1);
		ranges[1].length  = ptoa(1);
		ranges[2].length  = srcsize - ranges[0].length - ranges[1].length;
		ranges[0].address = data[0] + srcoffset + ptoa(1);
		ranges[1].address = data[0] + srcoffset;
		ranges[2].address = ranges[0].address + ranges[0].length;
		rangeCount = 3;	    
	    }

	    md = OSDynamicCast(IOGeneralMemoryDescriptor, 
	    	<span class="enscript-reference">IOMemoryDescriptor</span>::withAddressRanges(&amp;ranges[0], rangeCount, kIODirectionInOut, kernel_task));
	    assert(md);

	    IOLog(<span class="enscript-string">&quot;IOMemoryDescriptor::withAddressRanges [0x%lx @ 0x%lx]\n[0x%llx, 0x%llx],\n[0x%llx, 0x%llx],\n[0x%llx, 0x%llx]\n&quot;</span>, 
	    	    (<span class="enscript-type">long</span>) srcsize, (<span class="enscript-type">long</span>) srcoffset,
		    (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[0].address - data[0], (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[0].length,
		    (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[1].address - data[0], (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[1].length,
		    (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[2].address - data[0], (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) ranges[2].length);

	    <span class="enscript-keyword">if</span> (kIOReturnSuccess == kr)
	    {
		<span class="enscript-keyword">for</span> (mapoffset = 0; mapoffset &lt; srcsize; mapoffset = ((mapoffset &lt;&lt; 1) + 0xf00))
		{
		    <span class="enscript-keyword">for</span> (size = 4; size &lt; (srcsize - mapoffset - 1); size = ((size &lt;&lt; 2) + 0x200))
		    {
		    	IOMemoryMap     * map;
			mach_vm_address_t addr = 0;
			uint32_t          data;

<span class="enscript-comment">//			IOLog(&quot;&lt;mapRef [0x%lx @ 0x%lx]\n&quot;, (long) size, (long) mapoffset);
</span>
			map = md-&gt;createMappingInTask(kernel_task, 0, kIOMapAnywhere, mapoffset, size);
			<span class="enscript-keyword">if</span> (map) addr = map-&gt;getAddress();
			<span class="enscript-keyword">else</span> kr = kIOReturnError;

<span class="enscript-comment">//			IOLog(&quot;&gt;mapRef 0x%x %llx\n&quot;, kr, addr);
</span>
			<span class="enscript-keyword">if</span> (kIOReturnSuccess != kr) <span class="enscript-keyword">break</span>;
			kr = md-&gt;prepare();
			<span class="enscript-keyword">if</span> (kIOReturnSuccess != kr)
			{
			    panic(<span class="enscript-string">&quot;prepare() fail 0x%x\n&quot;</span>, kr);
			    <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">for</span> (idx = 0; idx &lt; size; idx += <span class="enscript-keyword">sizeof</span>(uint32_t))
			{
			    offidx = (idx + mapoffset + srcoffset);
			    <span class="enscript-keyword">if</span> ((srcsize &lt;= ptoa(5)) &amp;&amp; (srcsize &gt; ptoa(2)) &amp;&amp; !(page_mask &amp; srcoffset))
			    {
			    	<span class="enscript-keyword">if</span> (offidx &lt; ptoa(2)) offidx ^= ptoa(1);
			    }
			    offidx /= <span class="enscript-keyword">sizeof</span>(uint32_t);

			    <span class="enscript-keyword">if</span> (offidx != ((uint32_t*)addr)[idx/<span class="enscript-keyword">sizeof</span>(uint32_t)]) 
			    {
				panic(<span class="enscript-string">&quot;vm mismatch md %p map %p, @ 0x%x, 0x%lx, 0x%lx, \n&quot;</span>, md, map, idx, (<span class="enscript-type">long</span>) srcoffset, (<span class="enscript-type">long</span>) mapoffset);
				kr = kIOReturnBadMedia;
			    }
			    <span class="enscript-keyword">else</span>
			    {
			        <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(data) != md-&gt;readBytes(mapoffset + idx, &amp;data, <span class="enscript-keyword">sizeof</span>(data))) data = 0;
				<span class="enscript-keyword">if</span> (offidx != data) 
				{
				    panic(<span class="enscript-string">&quot;phys mismatch md %p map %p, @ 0x%x, 0x%lx, 0x%lx, \n&quot;</span>, md, map, idx, (<span class="enscript-type">long</span>) srcoffset, (<span class="enscript-type">long</span>) mapoffset);
				    kr = kIOReturnBadMedia;
				}
			    }
			}
			md-&gt;complete();
			map-&gt;release();
<span class="enscript-comment">//			IOLog(&quot;unmapRef %llx\n&quot;, addr);
</span>		    }
		    <span class="enscript-keyword">if</span> (kIOReturnSuccess != kr) <span class="enscript-keyword">break</span>;
		}
	    }
            md-&gt;release();
            <span class="enscript-keyword">if</span> (kIOReturnSuccess != kr) <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (kIOReturnSuccess != kr) <span class="enscript-keyword">break</span>;
    }

    <span class="enscript-keyword">if</span> (kIOReturnSuccess != kr) IOLog(<span class="enscript-string">&quot;FAIL: src 0x%lx @ 0x%lx, map 0x%lx @ 0x%lx\n&quot;</span>, 
    					(<span class="enscript-type">long</span>) srcsize, (<span class="enscript-type">long</span>) srcoffset, (<span class="enscript-type">long</span>) size, (<span class="enscript-type">long</span>) mapoffset);

    assert(kr == kIOReturnSuccess);

    vm_deallocate(kernel_map, data[0], bsize);
<span class="enscript-comment">//    vm_deallocate(kernel_map, data[1], size);
</span>
    <span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
</pre>
<hr />
</body></html>