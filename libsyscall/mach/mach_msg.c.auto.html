<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mach_msg.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mach_msg.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1991,1990,1989 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS &quot;AS IS&quot;
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  <a href="mailto:Software.Distribution@CS.CMU.EDU">Software.Distribution@CS.CMU.EDU</a>
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mig_errors.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_statistics.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;TargetConditionals.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_importance_assertion_begin_with_msg</span>(mach_msg_header_t * msg, mach_msg_trailer_t * trailer, uint64_t * assertion_handlep);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_importance_assertion_complete</span>(uint64_t assertion_handle);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MACH_MSG_TRAP</span>(msg, opt, ssize, rsize, rname, to, not) \
	 mach_msg_trap((msg), (opt), (ssize), (rsize), (rname), (to), (not))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LIBMACH_OPTIONS</span>	(MACH_SEND_INTERRUPT|MACH_RCV_INTERRUPT)

<span class="enscript-comment">/*
 *	Routine:	mach_msg
 *	Purpose:
 *		Send and/or receive a message.  If the message operation
 *		is interrupted, and the user did not request an indication
 *		of that fact, then restart the appropriate parts of the
 * 		operation.
 */</span>
mach_msg_return_t
<span class="enscript-function-name">mach_msg</span>(msg, option, send_size, rcv_size, rcv_name, timeout, notify)
	mach_msg_header_t *msg;
	mach_msg_option_t option;
	mach_msg_size_t send_size;
	mach_msg_size_t rcv_size;
	mach_port_t rcv_name;
	mach_msg_timeout_t timeout;
	mach_port_t notify;
{
	mach_msg_return_t mr;

	<span class="enscript-comment">/*
	 * Consider the following cases:
	 *	1) Errors in pseudo-receive (eg, MACH_SEND_INTERRUPTED
	 *	plus special bits).
	 *	2) Use of MACH_SEND_INTERRUPT/MACH_RCV_INTERRUPT options.
	 *	3) RPC calls with interruptions in one/both halves.
	 *
	 * We refrain from passing the option bits that we implement
	 * to the kernel.  This prevents their presence from inhibiting
	 * the kernel's fast paths (when it checks the option value).
	 */</span>

	mr = MACH_MSG_TRAP(msg, option &amp;~ LIBMACH_OPTIONS,
			   send_size, rcv_size, rcv_name,
			   timeout, notify);
	<span class="enscript-keyword">if</span> (mr == MACH_MSG_SUCCESS)
		<span class="enscript-keyword">return</span> MACH_MSG_SUCCESS;

	<span class="enscript-keyword">if</span> ((option &amp; MACH_SEND_INTERRUPT) == 0)
		<span class="enscript-keyword">while</span> (mr == MACH_SEND_INTERRUPTED)
			mr = MACH_MSG_TRAP(msg,
				option &amp;~ LIBMACH_OPTIONS,
				send_size, rcv_size, rcv_name,
				timeout, notify);

	<span class="enscript-keyword">if</span> ((option &amp; MACH_RCV_INTERRUPT) == 0)
		<span class="enscript-keyword">while</span> (mr == MACH_RCV_INTERRUPTED)
			mr = MACH_MSG_TRAP(msg,
				option &amp;~ (LIBMACH_OPTIONS|MACH_SEND_MSG),
				0, rcv_size, rcv_name,
				timeout, notify);

	<span class="enscript-keyword">return</span> mr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_msg_overwrite
 *	Purpose:
 *		Send and/or receive a message.  If the message operation
 *		is interrupted, and the user did not request an indication
 *		of that fact, then restart the appropriate parts of the
 * 		operation.
 *
 *		Distinct send and receive buffers may be specified.  If
 *		no separate receive buffer is specified, the msg parameter
 *		will be used for both send and receive operations.
 *
 *		In addition to a distinct receive buffer, that buffer may
 *		already contain scatter control information to direct the
 *		receiving of the message.
 */</span>
mach_msg_return_t
<span class="enscript-function-name">mach_msg_overwrite</span>(msg, option, send_size, rcv_limit, rcv_name, timeout, 
		   notify, rcv_msg, rcv_scatter_size)
	mach_msg_header_t *msg;
	mach_msg_option_t option;
	mach_msg_size_t send_size;
	mach_msg_size_t rcv_limit;
	mach_port_t rcv_name;
	mach_msg_timeout_t timeout;
	mach_port_t notify;
	mach_msg_header_t *rcv_msg;
	mach_msg_size_t rcv_scatter_size;
{
	mach_msg_return_t mr;

	<span class="enscript-comment">/*
	 * Consider the following cases:
	 *	1) Errors in pseudo-receive (eg, MACH_SEND_INTERRUPTED
	 *	plus special bits).
	 *	2) Use of MACH_SEND_INTERRUPT/MACH_RCV_INTERRUPT options.
	 *	3) RPC calls with interruptions in one/both halves.
	 *
	 * We refrain from passing the option bits that we implement
	 * to the kernel.  This prevents their presence from inhibiting
	 * the kernel's fast paths (when it checks the option value).
	 */</span>

	mr = mach_msg_overwrite_trap(msg, option &amp;~ LIBMACH_OPTIONS,
			   send_size, rcv_limit, rcv_name,
			   timeout, notify, rcv_msg, rcv_scatter_size);
	<span class="enscript-keyword">if</span> (mr == MACH_MSG_SUCCESS)
		<span class="enscript-keyword">return</span> MACH_MSG_SUCCESS;

	<span class="enscript-keyword">if</span> ((option &amp; MACH_SEND_INTERRUPT) == 0)
		<span class="enscript-keyword">while</span> (mr == MACH_SEND_INTERRUPTED)
			mr = mach_msg_overwrite_trap(msg,
				option &amp;~ LIBMACH_OPTIONS,
				send_size, rcv_limit, rcv_name,
				timeout, notify, rcv_msg, rcv_scatter_size);

	<span class="enscript-keyword">if</span> ((option &amp; MACH_RCV_INTERRUPT) == 0)
		<span class="enscript-keyword">while</span> (mr == MACH_RCV_INTERRUPTED)
			mr = mach_msg_overwrite_trap(msg,
				option &amp;~ (LIBMACH_OPTIONS|MACH_SEND_MSG),
				0, rcv_limit, rcv_name,
				timeout, notify, rcv_msg, rcv_scatter_size);

	<span class="enscript-keyword">return</span> mr;
}


mach_msg_return_t
<span class="enscript-function-name">mach_msg_send</span>(mach_msg_header_t *msg)
{
	<span class="enscript-keyword">return</span> mach_msg(msg, MACH_SEND_MSG,
			msg-&gt;msgh_size, 0, MACH_PORT_NULL,
			MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
}

mach_msg_return_t
<span class="enscript-function-name">mach_msg_receive</span>(mach_msg_header_t *msg)
{
	<span class="enscript-keyword">return</span> mach_msg(msg, MACH_RCV_MSG,
			0, msg-&gt;msgh_size, msg-&gt;msgh_local_port,
			MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mach_msg_destroy_port</span>(mach_port_t port, mach_msg_type_name_t type)
{
    <span class="enscript-keyword">if</span> (MACH_PORT_VALID(port)) <span class="enscript-keyword">switch</span> (type) {
      <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND</span>:
      <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_SEND_ONCE</span>:
	<span class="enscript-comment">/* destroy the send/send-once right */</span>
	(<span class="enscript-type">void</span>) mach_port_deallocate(mach_task_self_, port);
	<span class="enscript-keyword">break</span>;

      <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MOVE_RECEIVE</span>:
	<span class="enscript-comment">/* destroy the receive right */</span>
	(<span class="enscript-type">void</span>) mach_port_mod_refs(mach_task_self_, port,
				  MACH_PORT_RIGHT_RECEIVE, -1);
	<span class="enscript-keyword">break</span>;

      <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND</span>:
	<span class="enscript-comment">/* create a send right and then destroy it */</span>
	(<span class="enscript-type">void</span>) mach_port_insert_right(mach_task_self_, port,
				      port, MACH_MSG_TYPE_MAKE_SEND);
	(<span class="enscript-type">void</span>) mach_port_deallocate(mach_task_self_, port);
	<span class="enscript-keyword">break</span>;

      <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_TYPE_MAKE_SEND_ONCE</span>:
	<span class="enscript-comment">/* create a send-once right and then destroy it */</span>
	(<span class="enscript-type">void</span>) mach_port_extract_right(mach_task_self_, port,
				       MACH_MSG_TYPE_MAKE_SEND_ONCE,
				       &amp;port, &amp;type);
	(<span class="enscript-type">void</span>) mach_port_deallocate(mach_task_self_, port);
	<span class="enscript-keyword">break</span>;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mach_msg_destroy_memory</span>(vm_offset_t addr, vm_size_t size)
{
    <span class="enscript-keyword">if</span> (size != 0)
	(<span class="enscript-type">void</span>) vm_deallocate(mach_task_self_, addr, size);
}


<span class="enscript-comment">/*
 *	Routine:	mach_msg_destroy
 *	Purpose:
 *		mach_msg_destroy is useful in two contexts.
 *
 *		First, it can deallocate all port rights and
 *		out-of-line memory in a received message.
 *		When a server receives a request it doesn't want,
 *		it needs this functionality.
 *
 *		Second, it can mimic the side-effects of a msg-send
 *		operation.  The effect is as if the message were sent
 *		and then destroyed inside the kernel.  When a server
 *		can't send a reply (because the client died),
 *		it needs this functionality.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_msg_destroy</span>(mach_msg_header_t *msg)
{
    mach_msg_bits_t mbits = msg-&gt;msgh_bits;

    <span class="enscript-comment">/*
     *	The msgh_local_port field doesn't hold a port right.
     *	The receive operation consumes the destination port right.
     */</span>

    mach_msg_destroy_port(msg-&gt;msgh_remote_port, MACH_MSGH_BITS_REMOTE(mbits));
    mach_msg_destroy_port(msg-&gt;msgh_voucher_port, MACH_MSGH_BITS_VOUCHER(mbits));

    <span class="enscript-keyword">if</span> (mbits &amp; MACH_MSGH_BITS_COMPLEX) {
	mach_msg_base_t		*base;
	mach_msg_type_number_t	count, i;
	mach_msg_descriptor_t	*daddr;
	
    	base = (mach_msg_base_t *) msg;
	count = base-&gt;body.msgh_descriptor_count;

    	daddr = (mach_msg_descriptor_t *) (base + 1);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {

	    <span class="enscript-keyword">switch</span> (daddr-&gt;type.type) {
	    
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_PORT_DESCRIPTOR</span>: {
		    mach_msg_port_descriptor_t *dsc;

		    <span class="enscript-comment">/* 
		     * Destroy port rights carried in the message 
		     */</span>
		    dsc = &amp;daddr-&gt;port;
		    mach_msg_destroy_port(dsc-&gt;name, dsc-&gt;disposition);
		    daddr = (mach_msg_descriptor_t *)(dsc + 1);
		    <span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_OOL_DESCRIPTOR</span>: {
		    mach_msg_ool_descriptor_t *dsc;

		    <span class="enscript-comment">/* 
		     * Destroy memory carried in the message 
		     */</span>
		    dsc = &amp;daddr-&gt;out_of_line;
		    <span class="enscript-keyword">if</span> (dsc-&gt;deallocate) {
		        mach_msg_destroy_memory((vm_offset_t)dsc-&gt;address,
						dsc-&gt;size);
		    }
		    daddr = (mach_msg_descriptor_t *)(dsc + 1);
		    <span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_OOL_VOLATILE_DESCRIPTOR</span>: {
		    mach_msg_ool_descriptor_t *dsc;

		    <span class="enscript-comment">/*
		     * Just skip it.
		     */</span>
		    dsc = &amp;daddr-&gt;out_of_line;
		    daddr = (mach_msg_descriptor_t *)(dsc + 1);
		    <span class="enscript-keyword">break</span>;
	    }

	    <span class="enscript-keyword">case</span> <span class="enscript-reference">MACH_MSG_OOL_PORTS_DESCRIPTOR</span>: {
		    mach_port_t             		*ports;
		    mach_msg_ool_ports_descriptor_t	*dsc;
		    mach_msg_type_number_t   		j;

		    <span class="enscript-comment">/*
		     * Destroy port rights carried in the message 
		     */</span>
		    dsc = &amp;daddr-&gt;ool_ports;
		    ports = (mach_port_t *) dsc-&gt;address;
		    <span class="enscript-keyword">for</span> (j = 0; j &lt; dsc-&gt;count; j++, ports++)  {
		        mach_msg_destroy_port(*ports, dsc-&gt;disposition);
		    }

		    <span class="enscript-comment">/* 
		     * Destroy memory carried in the message 
		     */</span>
		    <span class="enscript-keyword">if</span> (dsc-&gt;deallocate) {
		        mach_msg_destroy_memory((vm_offset_t)dsc-&gt;address, 
					dsc-&gt;count * <span class="enscript-keyword">sizeof</span>(mach_port_t));
		    }
		    daddr = (mach_msg_descriptor_t *)(dsc + 1);
		    <span class="enscript-keyword">break</span>;
	    }
	    }
	}
    }
}

<span class="enscript-comment">/*
 *	Routine:	mach_msg_server_once
 *	Purpose:
 *		A simple generic server function.  It allows more flexibility
 *		than mach_msg_server by processing only one message request
 *		and then returning to the user.  Note that more in the way
 * 		of error codes are returned to the user; specifically, any
 * 		failing error from mach_msg calls will be returned
 *		(though errors from the demux routine or the routine it
 *		calls will not be).
 */</span>
mach_msg_return_t
<span class="enscript-function-name">mach_msg_server_once</span>(
	boolean_t (*demux)(mach_msg_header_t *, mach_msg_header_t *),
	mach_msg_size_t max_size,
	mach_port_t rcv_name,
	mach_msg_options_t options)
{
	mig_reply_error_t *bufRequest, *bufReply;
	mach_msg_size_t request_size;
	mach_msg_size_t request_alloc;
	mach_msg_size_t trailer_alloc;
	mach_msg_size_t reply_alloc;
	mach_msg_return_t mr;
	kern_return_t kr;
	mach_port_t self = mach_task_self_;
	voucher_mach_msg_state_t old_state = VOUCHER_MACH_MSG_STATE_UNCHANGED;

	options &amp;= ~(MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_VOUCHER);

	trailer_alloc = REQUESTED_TRAILER_SIZE(options);
	request_alloc = (mach_msg_size_t)round_page(max_size + trailer_alloc);

	request_size = (options &amp; MACH_RCV_LARGE) ?
    		   request_alloc : max_size + trailer_alloc;

	reply_alloc = (mach_msg_size_t)round_page((options &amp; MACH_SEND_TRAILER) ? 
			     (max_size + MAX_TRAILER_SIZE) :
			     max_size);

	kr = vm_allocate(self,
		     (vm_address_t *)&amp;bufReply,
		     reply_alloc,
		     VM_MAKE_TAG(VM_MEMORY_MACH_MSG)|TRUE);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;    

	<span class="enscript-keyword">for</span> (;;) {
		mach_msg_size_t new_request_alloc;

		kr = vm_allocate(self,
			 (vm_address_t *)&amp;bufRequest,
			 request_alloc,
			 VM_MAKE_TAG(VM_MEMORY_MACH_MSG)|TRUE);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			vm_deallocate(self,
					(vm_address_t)bufReply,
			  		reply_alloc);
			<span class="enscript-keyword">return</span> kr;
		}    
	
		mr = mach_msg(&amp;bufRequest-&gt;Head, MACH_RCV_MSG|MACH_RCV_VOUCHER|options,
					  0, request_size, rcv_name,
					  MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
	
		<span class="enscript-keyword">if</span> (!((mr == MACH_RCV_TOO_LARGE) &amp;&amp; (options &amp; MACH_RCV_LARGE)))
			<span class="enscript-keyword">break</span>;

		new_request_alloc = (mach_msg_size_t)round_page(bufRequest-&gt;Head.msgh_size +
									   trailer_alloc);
		vm_deallocate(self,
				(vm_address_t) bufRequest,
				request_alloc);
		request_size = request_alloc = new_request_alloc;
	}

	<span class="enscript-keyword">if</span> (mr == MACH_MSG_SUCCESS) {
	<span class="enscript-comment">/* we have a request message */</span>

		old_state = voucher_mach_msg_adopt(&amp;bufRequest-&gt;Head);

		(<span class="enscript-type">void</span>) (*demux)(&amp;bufRequest-&gt;Head, &amp;bufReply-&gt;Head);

		<span class="enscript-keyword">if</span> (!(bufReply-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)) {
			<span class="enscript-keyword">if</span> (bufReply-&gt;RetCode == MIG_NO_REPLY)
				bufReply-&gt;Head.msgh_remote_port = MACH_PORT_NULL;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bufReply-&gt;RetCode != KERN_SUCCESS) &amp;&amp;
					 (bufRequest-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)) {
				<span class="enscript-comment">/* destroy the request - but not the reply port */</span>
				bufRequest-&gt;Head.msgh_remote_port = MACH_PORT_NULL;
				mach_msg_destroy(&amp;bufRequest-&gt;Head);
			}
		}

		<span class="enscript-comment">/*
		 *	We don't want to block indefinitely because the client
		 *	isn't receiving messages from the reply port.
		 *	If we have a send-once right for the reply port, then
		 *	this isn't a concern because the send won't block.
		 *	If we have a send right, we need to use MACH_SEND_TIMEOUT.
		 *	To avoid falling off the kernel's fast RPC path unnecessarily,
		 *	we only supply MACH_SEND_TIMEOUT when absolutely necessary.
		 */</span>
		<span class="enscript-keyword">if</span> (bufReply-&gt;Head.msgh_remote_port != MACH_PORT_NULL) {

			mr = mach_msg(&amp;bufReply-&gt;Head,
				(MACH_MSGH_BITS_REMOTE(bufReply-&gt;Head.msgh_bits) ==
				 MACH_MSG_TYPE_MOVE_SEND_ONCE) ?
				MACH_SEND_MSG|options :
				MACH_SEND_MSG|MACH_SEND_TIMEOUT|options,
				bufReply-&gt;Head.msgh_size, 0, MACH_PORT_NULL,
				MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
		
			<span class="enscript-keyword">if</span> ((mr != MACH_SEND_INVALID_DEST) &amp;&amp;
				(mr != MACH_SEND_TIMED_OUT))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done_once</span>;
			mr = MACH_MSG_SUCCESS;
		}
		<span class="enscript-keyword">if</span> (bufReply-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)
			mach_msg_destroy(&amp;bufReply-&gt;Head);
	}

 <span class="enscript-reference">done_once</span>:
	voucher_mach_msg_revert(old_state);

	(<span class="enscript-type">void</span>)vm_deallocate(self,
			(vm_address_t) bufRequest,
			request_alloc);
	(<span class="enscript-type">void</span>)vm_deallocate(self,
			(vm_address_t) bufReply,
			reply_alloc);
	<span class="enscript-keyword">return</span> mr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_msg_server
 *	Purpose:
 *		A simple generic server function.  Note that changes here
 * 		should be considered for duplication above.
 */</span>
mach_msg_return_t
<span class="enscript-function-name">mach_msg_server</span>(
	boolean_t (*demux)(mach_msg_header_t *, mach_msg_header_t *),
	mach_msg_size_t max_size,
	mach_port_t rcv_name,
	mach_msg_options_t options)
{
	mig_reply_error_t *bufRequest, *bufReply;
	mach_msg_size_t request_size;
	mach_msg_size_t new_request_alloc;
	mach_msg_size_t request_alloc;
	mach_msg_size_t trailer_alloc;
	mach_msg_size_t reply_alloc;
	mach_msg_return_t mr;
	kern_return_t kr;
	mach_port_t self = mach_task_self_;
	voucher_mach_msg_state_t old_state = VOUCHER_MACH_MSG_STATE_UNCHANGED;
	boolean_t buffers_swapped = FALSE;

	options &amp;= ~(MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_VOUCHER|MACH_RCV_OVERWRITE);

	reply_alloc = (mach_msg_size_t)round_page((options &amp; MACH_SEND_TRAILER) ?
						  (max_size + MAX_TRAILER_SIZE) : max_size);

	kr = vm_allocate(self,
			 (vm_address_t *)&amp;bufReply,
			 reply_alloc,
			 VM_MAKE_TAG(VM_MEMORY_MACH_MSG)|TRUE);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		<span class="enscript-keyword">return</span> kr;

	request_alloc = 0;
	trailer_alloc = REQUESTED_TRAILER_SIZE(options);
	new_request_alloc = (mach_msg_size_t)round_page(max_size + trailer_alloc);

	request_size = (options &amp; MACH_RCV_LARGE) ?
	new_request_alloc : max_size + trailer_alloc;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (request_alloc &lt; new_request_alloc) {
			request_alloc = new_request_alloc;
			kr = vm_allocate(self,
					 (vm_address_t *)&amp;bufRequest,
					 request_alloc,
					 VM_MAKE_TAG(VM_MEMORY_MACH_MSG)|TRUE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				vm_deallocate(self,
					      (vm_address_t)bufReply,
					      reply_alloc);
				<span class="enscript-keyword">return</span> kr;
			}
		}

		mr = mach_msg(&amp;bufRequest-&gt;Head, MACH_RCV_MSG|MACH_RCV_VOUCHER|options,
			      0, request_size, rcv_name,
			      MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

		<span class="enscript-keyword">while</span> (mr == MACH_MSG_SUCCESS) {
			<span class="enscript-comment">/* we have another request message */</span>

			buffers_swapped = FALSE;
			old_state = voucher_mach_msg_adopt(&amp;bufRequest-&gt;Head);

			(<span class="enscript-type">void</span>) (*demux)(&amp;bufRequest-&gt;Head, &amp;bufReply-&gt;Head);

			<span class="enscript-keyword">if</span> (!(bufReply-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)) {
				<span class="enscript-keyword">if</span> (bufReply-&gt;RetCode == MIG_NO_REPLY)
					bufReply-&gt;Head.msgh_remote_port = MACH_PORT_NULL;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bufReply-&gt;RetCode != KERN_SUCCESS) &amp;&amp;
					 (bufRequest-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)) {
					<span class="enscript-comment">/* destroy the request - but not the reply port */</span>
					bufRequest-&gt;Head.msgh_remote_port = MACH_PORT_NULL;
					mach_msg_destroy(&amp;bufRequest-&gt;Head);
				}
			}

			<span class="enscript-comment">/*
			 * We don't want to block indefinitely because the client
			 * isn't receiving messages from the reply port.
			 * If we have a send-once right for the reply port, then
			 * this isn't a concern because the send won't block.
			 * If we have a send right, we need to use MACH_SEND_TIMEOUT.
			 * To avoid falling off the kernel's fast RPC path,
			 * we only supply MACH_SEND_TIMEOUT when absolutely necessary.
			 */</span>
			<span class="enscript-keyword">if</span> (bufReply-&gt;Head.msgh_remote_port != MACH_PORT_NULL) {
				<span class="enscript-keyword">if</span> (request_alloc == reply_alloc) {
					mig_reply_error_t *bufTemp;

					mr = mach_msg(
					      &amp;bufReply-&gt;Head,
					      (MACH_MSGH_BITS_REMOTE(bufReply-&gt;Head.msgh_bits) ==
					       MACH_MSG_TYPE_MOVE_SEND_ONCE) ?
					      MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TIMEOUT|MACH_RCV_VOUCHER|options :
					      MACH_SEND_MSG|MACH_RCV_MSG|MACH_SEND_TIMEOUT|MACH_RCV_TIMEOUT|MACH_RCV_VOUCHER|options,
					      bufReply-&gt;Head.msgh_size, request_size, rcv_name,
					      MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

					<span class="enscript-comment">/* swap request and reply */</span>
					bufTemp = bufRequest;
					bufRequest = bufReply;
					bufReply = bufTemp;
					buffers_swapped = TRUE;
				} <span class="enscript-keyword">else</span> {
					mr = mach_msg_overwrite(
						&amp;bufReply-&gt;Head,
						(MACH_MSGH_BITS_REMOTE(bufReply-&gt;Head.msgh_bits) ==
						 MACH_MSG_TYPE_MOVE_SEND_ONCE) ?
						 MACH_SEND_MSG|MACH_RCV_MSG|MACH_RCV_TIMEOUT|MACH_RCV_VOUCHER|options :
						 MACH_SEND_MSG|MACH_RCV_MSG|MACH_SEND_TIMEOUT|MACH_RCV_TIMEOUT|MACH_RCV_VOUCHER|options,
						bufReply-&gt;Head.msgh_size, request_size, rcv_name,
						MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL,
						&amp;bufRequest-&gt;Head, 0);
				}

				<span class="enscript-keyword">if</span> ((mr != MACH_SEND_INVALID_DEST) &amp;&amp;
				    (mr != MACH_SEND_TIMED_OUT) &amp;&amp;
				    (mr != MACH_RCV_TIMED_OUT)) {

					voucher_mach_msg_revert(old_state);
					old_state = VOUCHER_MACH_MSG_STATE_UNCHANGED;

					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-comment">/* 
			 * Need to destroy the reply msg in case if there was a send timeout or
			 * invalid destination. The reply msg would be swapped with request msg
			 * if buffers_swapped is true, thus destroy request msg instead of
			 * reply msg in such cases.
			 */</span>
			<span class="enscript-keyword">if</span> (mr != MACH_RCV_TIMED_OUT) {
				<span class="enscript-keyword">if</span> (buffers_swapped) {
					<span class="enscript-keyword">if</span> (bufRequest-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)
						mach_msg_destroy(&amp;bufRequest-&gt;Head);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (bufReply-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX)
						mach_msg_destroy(&amp;bufReply-&gt;Head);
				}
			}
			voucher_mach_msg_revert(old_state);
			old_state = VOUCHER_MACH_MSG_STATE_UNCHANGED;

			mr = mach_msg(&amp;bufRequest-&gt;Head, MACH_RCV_MSG|MACH_RCV_VOUCHER|options,
					0, request_size, rcv_name,
					MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);

		} <span class="enscript-comment">/* while (mr == MACH_MSG_SUCCESS) */</span>

		<span class="enscript-keyword">if</span> ((mr == MACH_RCV_TOO_LARGE) &amp;&amp; (options &amp; MACH_RCV_LARGE)) {
			new_request_alloc = (mach_msg_size_t)round_page(bufRequest-&gt;Head.msgh_size +
									trailer_alloc);
			request_size = new_request_alloc;
			vm_deallocate(self,
				      (vm_address_t) bufRequest,
				      request_alloc);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">break</span>;

	} <span class="enscript-comment">/* for(;;) */</span>

	(<span class="enscript-type">void</span>)vm_deallocate(self,
			    (vm_address_t) bufRequest,
			    request_alloc);
	(<span class="enscript-type">void</span>)vm_deallocate(self,
			    (vm_address_t) bufReply,
			    reply_alloc);
	<span class="enscript-keyword">return</span> mr;
}

<span class="enscript-comment">/*
 *	Routine:	mach_msg_server_importance
 *	Purpose:
 *		A simple generic server function which handles importance
 * 		promotion assertions for adaptive daemons.
 */</span>
mach_msg_return_t
<span class="enscript-function-name">mach_msg_server_importance</span>(
	boolean_t (*demux)(mach_msg_header_t *, mach_msg_header_t *),
	mach_msg_size_t max_size,
	mach_port_t rcv_name,
	mach_msg_options_t options)
{
	<span class="enscript-keyword">return</span> mach_msg_server(demux, max_size, rcv_name, options);
}

kern_return_t
<span class="enscript-function-name">mach_voucher_deallocate</span>(
	mach_voucher_t	voucher)
{
	<span class="enscript-keyword">return</span> mach_port_deallocate(mach_task_self(), voucher);
}
</pre>
<hr />
</body></html>