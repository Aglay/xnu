<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mptcp_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mptcp_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/sha1.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

<span class="enscript-comment">/*
 * Notes on MPTCP implementation.
 *
 * MPTCP is implemented as &lt;SOCK_STREAM,IPPROTO_TCP&gt; protocol in PF_MULTIPATH
 * communication domain.  The structure mtcbinfo describes the MPTCP instance
 * of a Multipath protocol in that domain.  It is used to keep track of all
 * MPTCP PCB instances in the system, and is protected by the global lock
 * mppi_lock.
 *
 * An MPTCP socket is opened by calling socket(PF_MULTIPATH, SOCK_STREAM,
 * IPPROTO_TCP).  Upon success, a Multipath PCB gets allocated and along with
 * it comes an MPTCP Session and an MPTCP PCB.  All three structures are
 * allocated from the same memory block, and each structure has a pointer
 * to the adjacent ones.  The layout is defined by the mpp_mtp structure.
 * The socket lock (mpp_lock) is used to protect accesses to the Multipath
 * PCB (mppcb) as well as the MPTCP Session (mptses).
 *
 * The MPTCP Session is an MPTCP-specific extension to the Multipath PCB;
 * in particular, the list of subflows as well as the MPTCP thread.
 *
 * A functioning MPTCP Session consists of one or more subflow sockets.  Each
 * subflow socket is essentially a regular PF_INET/PF_INET6 TCP socket, and is
 * represented by the mptsub structure.  Because each subflow requires access
 * to the MPTCP Session, the MPTCP socket's so_usecount is bumped up for each
 * subflow.  This gets decremented prior to the subflow's destruction.  The
 * subflow lock (mpts_lock) is used to protect accesses to the subflow.
 *
 * To handle events (read, write, control) from the subflows, an MPTCP thread
 * is created; currently, there is one thread per MPTCP Session.  In order to
 * prevent the MPTCP socket from being destroyed while being accessed by the
 * MPTCP thread, we bump up the MPTCP socket's so_usecount for the thread,
 * which will be decremented prior to the thread's termination.  The thread
 * lock (mpte_thread_lock) is used to synchronize its signalling.
 *
 * Lock ordering is defined as follows:
 *
 *	mtcbinfo (mppi_lock)
 *		mp_so (mpp_lock)
 *			mpts (mpts_lock)
 *				so (inpcb_mtx)
 *					mptcb (mpt_lock)
 *
 * It is not a requirement that all of the above locks need to be acquired
 * in succession, but the correct lock ordering must be followed when there
 * are more than one locks that need to be held.  The MPTCP thread lock is
 * is not constrained by this arrangement, because none of the other locks
 * is ever acquired while holding mpte_thread_lock; therefore it may be called
 * at any moment to signal the thread.
 *
 * An MPTCP socket will be destroyed when its so_usecount drops to zero; this
 * work is done by the MPTCP garbage collector which is invoked on demand by
 * the PF_MULTIPATH garbage collector.  This process will take place once all
 * of the subflows have been destroyed, and the MPTCP thread be instructed to
 * self-terminate.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_sesdestroy</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_thread_signal_locked</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_thread_terminate_signal</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_thread_dowork</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_thread_func</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_thread_destroy</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_key_pool_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_attach_to_subf</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mptcb *, uint8_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_detach_mptcb_from_subf</span>(<span class="enscript-type">struct</span> mptcb *, <span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_conn_properties</span>(<span class="enscript-type">struct</span> mptcb *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_init_statevars</span>(<span class="enscript-type">struct</span> mptcb *);

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">mptcp_gc</span>(<span class="enscript-type">struct</span> mppcbinfo *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_subflow_socreate</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *,
    <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *, <span class="enscript-type">struct</span> socket **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_subflow_soclose</span>(<span class="enscript-type">struct</span> mptsub *, <span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_subflow_soconnectx</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_subflow_soreceive</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr **,
    <span class="enscript-type">struct</span> uio *, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_subflow_rupcall</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_subflow_input</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_subflow_wupcall</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_subflow_eupcall</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">void</span> *, uint32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_update_last_owner</span>(<span class="enscript-type">struct</span> mptsub *, <span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_output_needed</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *to_mpts);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_get_rtt_measurement</span>(<span class="enscript-type">struct</span> mptsub *, <span class="enscript-type">struct</span> mptses *);

<span class="enscript-comment">/*
 * Possible return values for subflow event handlers.  Note that success
 * values must be greater or equal than MPTS_EVRET_OK.  Values less than that
 * indicate errors or actions which require immediate attention; they will
 * prevent the rest of the handlers from processing their respective events
 * until the next round of events processing.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	MPTS_EVRET_DELETE		= 1,	<span class="enscript-comment">/* delete this subflow */</span>
	MPTS_EVRET_OK			= 2,	<span class="enscript-comment">/* OK */</span>
	MPTS_EVRET_CONNECT_PENDING	= 3,	<span class="enscript-comment">/* resume pended connects */</span>
	MPTS_EVRET_DISCONNECT_FALLBACK	= 4,	<span class="enscript-comment">/* abort all but preferred */</span>
} ev_ret_t;

<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_events</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_connreset_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_cantrcvmore_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_cantsendmore_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_timeout_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_nosrcaddr_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_failover_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_ifdenied_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_suspend_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_resume_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_connected_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_disconnected_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_mpstatus_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_mustrst_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_fastjoin_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_deleteok_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);
<span class="enscript-type">static</span> ev_ret_t <span class="enscript-function-name">mptcp_subflow_mpcantrcvmore_ev</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptsub *, uint64_t *);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">mptcp_evret2str</span>(ev_ret_t);

<span class="enscript-type">static</span> mptcp_key_t *<span class="enscript-function-name">mptcp_reserve_key</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_do_sha1</span>(mptcp_key_t *, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_init_authparms</span>(<span class="enscript-type">struct</span> mptcb *);

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mptsub_zone_size;		<span class="enscript-comment">/* size of mptsub */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *mptsub_zone;		<span class="enscript-comment">/* zone for mptsub */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mptopt_zone_size;		<span class="enscript-comment">/* size of mptopt */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *mptopt_zone;		<span class="enscript-comment">/* zone for mptopt */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mpt_subauth_entry_size;	<span class="enscript-comment">/* size of subf auth entry */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *mpt_subauth_zone;		<span class="enscript-comment">/* zone of subf auth entry */</span>

<span class="enscript-type">struct</span> mppcbinfo mtcbinfo;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mptcp_keys_pool_head mptcp_keys_pool;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MPTCP_SUBFLOW_WRITELEN</span>	(8 * 1024)	<span class="enscript-comment">/* bytes to write each time */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MPTCP_SUBFLOW_READLEN</span>	(8 * 1024)	<span class="enscript-comment">/* bytes to read each time */</span>

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet);

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet, OID_AUTO, mptcp, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;MPTCP&quot;</span>);

uint32_t mptcp_dbg_area = 0;		<span class="enscript-comment">/* more noise if greater than 1 */</span>
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_mptcp, OID_AUTO, dbg_area, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;mptcp_dbg_area, 0, <span class="enscript-string">&quot;MPTCP debug area&quot;</span>);

uint32_t mptcp_dbg_level = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_mptcp, OID_AUTO, dbg_level, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;mptcp_dbg_level, 0, <span class="enscript-string">&quot;MPTCP debug level&quot;</span>);


<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_mptcp, OID_AUTO, pcbcount, CTLFLAG_RD|CTLFLAG_LOCKED,
	&amp;mtcbinfo.mppi_count, 0, <span class="enscript-string">&quot;Number of active PCBs&quot;</span>);

<span class="enscript-comment">/*
 * Since there is one kernel thread per mptcp socket, imposing an artificial
 * limit on number of allowed mptcp sockets.
 */</span>
uint32_t mptcp_socket_limit = MPPCB_LIMIT;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_mptcp, OID_AUTO, sk_lim, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;mptcp_socket_limit, 0, <span class="enscript-string">&quot;MPTCP socket limit&quot;</span>);

<span class="enscript-comment">/*
 * SYSCTL to turn on delayed cellular subflow start.
 */</span>
uint32_t mptcp_delayed_subf_start = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_mptcp, OID_AUTO, delayed, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;mptcp_delayed_subf_start, 0, <span class="enscript-string">&quot;MPTCP Delayed Subflow start&quot;</span>);

<span class="enscript-comment">/*
 * sysctl to use network status hints from symptomsd
 */</span>
uint32_t mptcp_use_symptomsd = 1;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_mptcp, OID_AUTO, usesymptoms, CTLFLAG_RW|CTLFLAG_LOCKED,
	&amp;mptcp_use_symptomsd, 0, <span class="enscript-string">&quot;MPTCP Use SymptomsD&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw mptcp_subflow_protosw;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs mptcp_subflow_usrreqs;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6protosw mptcp_subflow_protosw6;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs mptcp_subflow_usrreqs6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mptcp_subflow_event_entry {
	uint64_t        sofilt_hint_mask;
	ev_ret_t        (*sofilt_hint_ev_hdlr)(
			    <span class="enscript-type">struct</span> mptses *mpte,
			    <span class="enscript-type">struct</span> mptsub *mpts,
			    uint64_t *p_mpsofilt_hint);
} mptsub_ev_entry_t;

<span class="enscript-type">static</span> mptsub_ev_entry_t mpsub_ev_entry_tbl [] = {
	{
		.sofilt_hint_mask = SO_FILT_HINT_MPCANTRCVMORE,
		.sofilt_hint_ev_hdlr =	mptcp_subflow_mpcantrcvmore_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_MPFAILOVER,
		.sofilt_hint_ev_hdlr = mptcp_subflow_failover_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_CONNRESET,
		.sofilt_hint_ev_hdlr = mptcp_subflow_connreset_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_MUSTRST,
		.sofilt_hint_ev_hdlr = mptcp_subflow_mustrst_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_CANTRCVMORE,
		.sofilt_hint_ev_hdlr = mptcp_subflow_cantrcvmore_ev,
	},
	{	.sofilt_hint_mask = SO_FILT_HINT_CANTSENDMORE,
		.sofilt_hint_ev_hdlr = mptcp_subflow_cantsendmore_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_TIMEOUT,
		.sofilt_hint_ev_hdlr = mptcp_subflow_timeout_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_NOSRCADDR,
		.sofilt_hint_ev_hdlr = mptcp_subflow_nosrcaddr_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_IFDENIED,
		.sofilt_hint_ev_hdlr = mptcp_subflow_ifdenied_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_SUSPEND,
		.sofilt_hint_ev_hdlr = mptcp_subflow_suspend_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_RESUME,
		.sofilt_hint_ev_hdlr = mptcp_subflow_resume_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_CONNECTED,
		.sofilt_hint_ev_hdlr = mptcp_subflow_connected_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_MPSTATUS,
		.sofilt_hint_ev_hdlr = mptcp_subflow_mpstatus_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_DELETEOK,
		.sofilt_hint_ev_hdlr = mptcp_deleteok_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_DISCONNECTED,
		.sofilt_hint_ev_hdlr = mptcp_subflow_disconnected_ev,
	},
	{
		.sofilt_hint_mask = SO_FILT_HINT_MPFASTJ,
		.sofilt_hint_ev_hdlr = mptcp_fastjoin_ev,
	}
};

<span class="enscript-comment">/*
 * Protocol pr_init callback.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> mptcp_initialized = 0;
	<span class="enscript-type">struct</span> protosw *prp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6protosw *prp6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-comment">/* do this only once */</span>
	<span class="enscript-keyword">if</span> (mptcp_initialized)
		<span class="enscript-keyword">return</span>;
	mptcp_initialized = 1;

	<span class="enscript-comment">/*
	 * Since PF_MULTIPATH gets initialized after PF_INET/INET6,
	 * we must be able to find IPPROTO_TCP entries for both.
	 */</span>
	prp = pffindproto_locked(PF_INET, IPPROTO_TCP, SOCK_STREAM);
	VERIFY(prp != NULL);
	bcopy(prp, &amp;mptcp_subflow_protosw, <span class="enscript-keyword">sizeof</span> (*prp));
	bcopy(prp-&gt;pr_usrreqs, &amp;mptcp_subflow_usrreqs,
	    <span class="enscript-keyword">sizeof</span> (mptcp_subflow_usrreqs));
	mptcp_subflow_protosw.pr_entry.tqe_next = NULL;
	mptcp_subflow_protosw.pr_entry.tqe_prev = NULL;
	mptcp_subflow_protosw.pr_usrreqs = &amp;mptcp_subflow_usrreqs;
	mptcp_subflow_usrreqs.pru_soreceive = mptcp_subflow_soreceive;
	mptcp_subflow_usrreqs.pru_rcvoob = pru_rcvoob_notsupp;
	<span class="enscript-comment">/*
	 * Socket filters shouldn't attach/detach to/from this protosw
	 * since pr_protosw is to be used instead, which points to the
	 * real protocol; if they do, it is a bug and we should panic.
	 */</span>
	mptcp_subflow_protosw.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	mptcp_subflow_protosw.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	prp6 = (<span class="enscript-type">struct</span> ip6protosw *)pffindproto_locked(PF_INET6,
	    IPPROTO_TCP, SOCK_STREAM);
	VERIFY(prp6 != NULL);
	bcopy(prp6, &amp;mptcp_subflow_protosw6, <span class="enscript-keyword">sizeof</span> (*prp6));
	bcopy(prp6-&gt;pr_usrreqs, &amp;mptcp_subflow_usrreqs6,
	    <span class="enscript-keyword">sizeof</span> (mptcp_subflow_usrreqs6));
	mptcp_subflow_protosw6.pr_entry.tqe_next = NULL;
	mptcp_subflow_protosw6.pr_entry.tqe_prev = NULL;
	mptcp_subflow_protosw6.pr_usrreqs = &amp;mptcp_subflow_usrreqs6;
	mptcp_subflow_usrreqs6.pru_soreceive = mptcp_subflow_soreceive;
	mptcp_subflow_usrreqs6.pru_rcvoob = pru_rcvoob_notsupp;
	<span class="enscript-comment">/*
	 * Socket filters shouldn't attach/detach to/from this protosw
	 * since pr_protosw is to be used instead, which points to the
	 * real protocol; if they do, it is a bug and we should panic.
	 */</span>
	mptcp_subflow_protosw6.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	mptcp_subflow_protosw6.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	bzero(&amp;mtcbinfo, <span class="enscript-keyword">sizeof</span> (mtcbinfo));
	TAILQ_INIT(&amp;mtcbinfo.mppi_pcbs);
	mtcbinfo.mppi_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mpp_mtp);
	<span class="enscript-keyword">if</span> ((mtcbinfo.mppi_zone = zinit(mtcbinfo.mppi_size,
	    1024 * mtcbinfo.mppi_size, 8192, <span class="enscript-string">&quot;mptcb&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate MPTCP PCB zone\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(mtcbinfo.mppi_zone, Z_CALLERACCT, FALSE);
	zone_change(mtcbinfo.mppi_zone, Z_EXPAND, TRUE);

	mtcbinfo.mppi_lock_grp_attr = lck_grp_attr_alloc_init();
	mtcbinfo.mppi_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mppcb&quot;</span>,
	    mtcbinfo.mppi_lock_grp_attr);
	mtcbinfo.mppi_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;mtcbinfo.mppi_lock, mtcbinfo.mppi_lock_grp,
	    mtcbinfo.mppi_lock_attr);

	mtcbinfo.mppi_gc = mptcp_gc;
	mtcbinfo.mppi_timer = mptcp_timer;
	mtcbinfo.mppi_pcbe_create = mptcp_sescreate;

	<span class="enscript-comment">/* attach to MP domain for garbage collection to take place */</span>
	mp_pcbinfo_attach(&amp;mtcbinfo);

	mptsub_zone_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptsub);
	<span class="enscript-keyword">if</span> ((mptsub_zone = zinit(mptsub_zone_size, 1024 * mptsub_zone_size,
	    8192, <span class="enscript-string">&quot;mptsub&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate MPTCP subflow zone\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(mptsub_zone, Z_CALLERACCT, FALSE);
	zone_change(mptsub_zone, Z_EXPAND, TRUE);

	mptopt_zone_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptopt);
	<span class="enscript-keyword">if</span> ((mptopt_zone = zinit(mptopt_zone_size, 128 * mptopt_zone_size,
	    1024, <span class="enscript-string">&quot;mptopt&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate MPTCP option zone\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(mptopt_zone, Z_CALLERACCT, FALSE);
	zone_change(mptopt_zone, Z_EXPAND, TRUE);

	mpt_subauth_entry_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_subf_auth_entry);
	<span class="enscript-keyword">if</span> ((mpt_subauth_zone = zinit(mpt_subauth_entry_size,
	    1024 * mpt_subauth_entry_size, 8192, <span class="enscript-string">&quot;mptauth&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate MPTCP address auth zone \n&quot;</span>,
		    __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(mpt_subauth_zone, Z_CALLERACCT, FALSE);
	zone_change(mpt_subauth_zone, Z_EXPAND, TRUE);

	<span class="enscript-comment">/* Set up a list of unique keys */</span>
	mptcp_key_pool_init();
}

<span class="enscript-comment">/*
 * Create an MPTCP session, called as a result of opening a MPTCP socket.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">mptcp_sescreate</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> mppcb *mpp)
{
	<span class="enscript-type">struct</span> mppcbinfo *mppi;
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(mpp != NULL);
	mppi = mpp-&gt;mpp_pcbinfo;
	VERIFY(mppi != NULL);

	__IGNORE_WCASTALIGN(mpte = &amp;((<span class="enscript-type">struct</span> mpp_mtp *)mpp)-&gt;mpp_ses);
	__IGNORE_WCASTALIGN(mp_tp = &amp;((<span class="enscript-type">struct</span> mpp_mtp *)mpp)-&gt;mtcb);

	<span class="enscript-comment">/* MPTCP Multipath PCB Extension */</span>
	bzero(mpte, <span class="enscript-keyword">sizeof</span> (*mpte));
	VERIFY(mpp-&gt;mpp_pcbe == NULL);
	mpp-&gt;mpp_pcbe = mpte;
	mpte-&gt;mpte_mppcb = mpp;
	mpte-&gt;mpte_mptcb = mp_tp;

	TAILQ_INIT(&amp;mpte-&gt;mpte_sopts);
	TAILQ_INIT(&amp;mpte-&gt;mpte_subflows);
	mpte-&gt;mpte_associd = SAE_ASSOCID_ANY;
	mpte-&gt;mpte_connid_last = SAE_CONNID_ANY;

	lck_mtx_init(&amp;mpte-&gt;mpte_thread_lock, mppi-&gt;mppi_lock_grp,
	    mppi-&gt;mppi_lock_attr);

	<span class="enscript-comment">/*
	 * XXX: <a href="mailto:adi@apple.com">adi@apple.com</a>
	 *
	 * This can be rather expensive if we have lots of MPTCP sockets,
	 * but we need a kernel thread for this model to work.  Perhaps we
	 * could amortize the costs by having one worker thread per a group
	 * of MPTCP sockets.
	 */</span>
	<span class="enscript-keyword">if</span> (kernel_thread_start(mptcp_thread_func, mpte,
	    &amp;mpte-&gt;mpte_thread) != KERN_SUCCESS) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mp_so-&gt;so_usecount++;		<span class="enscript-comment">/* for thread */</span>

	<span class="enscript-comment">/* MPTCP Protocol Control Block */</span>
	bzero(mp_tp, <span class="enscript-keyword">sizeof</span> (*mp_tp));
	lck_mtx_init(&amp;mp_tp-&gt;mpt_lock, mppi-&gt;mppi_lock_grp,
	    mppi-&gt;mppi_lock_attr);
	mp_tp-&gt;mpt_mpte = mpte;
	mp_tp-&gt;mpt_state = MPTCPS_CLOSED;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error != 0)
		lck_mtx_destroy(&amp;mpte-&gt;mpte_thread_lock, mppi-&gt;mppi_lock_grp);
	DTRACE_MPTCP5(session__create, <span class="enscript-type">struct</span> socket *, mp_so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;mp_so-&gt;so_rcv,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;mp_so-&gt;so_snd,
	    <span class="enscript-type">struct</span> mppcb *, mpp, <span class="enscript-type">int</span>, error);

	<span class="enscript-keyword">return</span> ((error != 0) ? NULL : mpte);
}

<span class="enscript-comment">/*
 * Destroy an MPTCP session.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_sesdestroy</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	mp_tp = mpte-&gt;mpte_mptcb;
	VERIFY(mp_tp != NULL);

	<span class="enscript-comment">/*
	 * MPTCP Multipath PCB Extension section
	 */</span>
	mptcp_flush_sopts(mpte);
	VERIFY(TAILQ_EMPTY(&amp;mpte-&gt;mpte_subflows) &amp;&amp; mpte-&gt;mpte_numflows == 0);

	lck_mtx_destroy(&amp;mpte-&gt;mpte_thread_lock,
	    mpte-&gt;mpte_mppcb-&gt;mpp_pcbinfo-&gt;mppi_lock_grp);

	<span class="enscript-comment">/*
	 * MPTCP Protocol Control Block section
	 */</span>
	lck_mtx_destroy(&amp;mp_tp-&gt;mpt_lock,
	    mpte-&gt;mpte_mppcb-&gt;mpp_pcbinfo-&gt;mppi_lock_grp);

	DTRACE_MPTCP2(session__destroy, <span class="enscript-type">struct</span> mptses *, mpte,
	    <span class="enscript-type">struct</span> mptcb *, mp_tp);
}

<span class="enscript-comment">/*
 * Allocate an MPTCP socket option structure.
 */</span>
<span class="enscript-type">struct</span> mptopt *
<span class="enscript-function-name">mptcp_sopt_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mptopt *mpo;

	mpo = (how == M_WAITOK) ? zalloc(mptopt_zone) :
	    zalloc_noblock(mptopt_zone);
	<span class="enscript-keyword">if</span> (mpo != NULL) {
		bzero(mpo, mptopt_zone_size);
	}

	<span class="enscript-keyword">return</span> (mpo);
}

<span class="enscript-comment">/*
 * Free an MPTCP socket option structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_sopt_free</span>(<span class="enscript-type">struct</span> mptopt *mpo)
{
	VERIFY(!(mpo-&gt;mpo_flags &amp; MPOF_ATTACHED));

	zfree(mptopt_zone, mpo);
}

<span class="enscript-comment">/*
 * Add a socket option to the MPTCP socket option list.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_sopt_insert</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptopt *mpo)
{
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(!(mpo-&gt;mpo_flags &amp; MPOF_ATTACHED));
	mpo-&gt;mpo_flags |= MPOF_ATTACHED;
	TAILQ_INSERT_TAIL(&amp;mpte-&gt;mpte_sopts, mpo, mpo_entry);
}

<span class="enscript-comment">/*
 * Remove a socket option from the MPTCP socket option list.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_sopt_remove</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptopt *mpo)
{
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(mpo-&gt;mpo_flags &amp; MPOF_ATTACHED);
	mpo-&gt;mpo_flags &amp;= ~MPOF_ATTACHED;
	TAILQ_REMOVE(&amp;mpte-&gt;mpte_sopts, mpo, mpo_entry);
}

<span class="enscript-comment">/*
 * Search for an existing &lt;sopt_level,sopt_name&gt; socket option.
 */</span>
<span class="enscript-type">struct</span> mptopt *
<span class="enscript-function-name">mptcp_sopt_find</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">struct</span> mptopt *mpo;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	TAILQ_FOREACH(mpo, &amp;mpte-&gt;mpte_sopts, mpo_entry) {
		<span class="enscript-keyword">if</span> (mpo-&gt;mpo_level == sopt-&gt;sopt_level &amp;&amp;
		    mpo-&gt;mpo_name == sopt-&gt;sopt_name)
			<span class="enscript-keyword">break</span>;
	}
	VERIFY(mpo == NULL || sopt-&gt;sopt_valsize == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>));

	<span class="enscript-keyword">return</span> (mpo);
}

<span class="enscript-comment">/*
 * Flushes all recorded socket options from an MP socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_flush_sopts</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> mptopt *mpo, *tmpo;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	TAILQ_FOREACH_SAFE(mpo, &amp;mpte-&gt;mpte_sopts, mpo_entry, tmpo) {
		mptcp_sopt_remove(mpte, mpo);
		mptcp_sopt_free(mpo);
	}
	VERIFY(TAILQ_EMPTY(&amp;mpte-&gt;mpte_sopts));
}

<span class="enscript-comment">/*
 * Allocate a MPTCP subflow structure.
 */</span>
<span class="enscript-type">struct</span> mptsub *
<span class="enscript-function-name">mptcp_subflow_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mptsub *mpts;

	mpts = (how == M_WAITOK) ? zalloc(mptsub_zone) :
	    zalloc_noblock(mptsub_zone);
	<span class="enscript-keyword">if</span> (mpts != NULL) {
		bzero(mpts, mptsub_zone_size);
		lck_mtx_init(&amp;mpts-&gt;mpts_lock, mtcbinfo.mppi_lock_grp,
		    mtcbinfo.mppi_lock_attr);
	}

	<span class="enscript-keyword">return</span> (mpts);
}

<span class="enscript-comment">/*
 * Deallocate a subflow structure, called when all of the references held
 * on it have been released.  This implies that the subflow has been deleted.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_free</span>(<span class="enscript-type">struct</span> mptsub *mpts)
{
	MPTS_LOCK_ASSERT_HELD(mpts);

	VERIFY(mpts-&gt;mpts_refcnt == 0);
	VERIFY(!(mpts-&gt;mpts_flags &amp; MPTSF_ATTACHED));
	VERIFY(mpts-&gt;mpts_mpte == NULL);
	VERIFY(mpts-&gt;mpts_socket == NULL);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_src_sl != NULL) {
		sockaddrlist_free(mpts-&gt;mpts_src_sl);
		mpts-&gt;mpts_src_sl = NULL;
	}
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_dst_sl != NULL) {
		sockaddrlist_free(mpts-&gt;mpts_dst_sl);
		mpts-&gt;mpts_dst_sl = NULL;
	}
	MPTS_UNLOCK(mpts);
	lck_mtx_destroy(&amp;mpts-&gt;mpts_lock, mtcbinfo.mppi_lock_grp);

	zfree(mptsub_zone, mpts);
}

<span class="enscript-comment">/*
 * Create an MPTCP subflow socket.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_socreate</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts, <span class="enscript-type">int</span> dom,
    <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> socket **so)
{
	<span class="enscript-type">struct</span> mptopt smpo, *mpo, *tmpo;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">int</span> error;

	*so = NULL;
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	<span class="enscript-comment">/*
	 * Create the subflow socket (multipath subflow, non-blocking.)
	 *
	 * This will cause SOF_MP_SUBFLOW socket flag to be set on the subflow
	 * socket; it will be cleared when the socket is peeled off or closed.
	 * It also indicates to the underlying TCP to handle MPTCP options.
	 * A multipath subflow socket implies SS_NOFDREF state.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = socreate_internal(dom, so, SOCK_STREAM,
	    IPPROTO_TCP, p, SOCF_ASYNC | SOCF_MP_SUBFLOW, PROC_NULL)) != 0) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: subflow socreate mp_so 0x%llx&quot;</span>
		    <span class="enscript-string">&quot; unable to create subflow socket error %d\n&quot;</span>,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), error),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		<span class="enscript-keyword">return</span> (error);
	}

	socket_lock(*so, 0);
	VERIFY((*so)-&gt;so_flags &amp; SOF_MP_SUBFLOW);
	VERIFY(((*so)-&gt;so_state &amp; (SS_NBIO|SS_NOFDREF)) ==
	    (SS_NBIO|SS_NOFDREF));

	<span class="enscript-comment">/* prevent the socket buffers from being compressed */</span>
	(*so)-&gt;so_rcv.sb_flags |= SB_NOCOMPRESS;
	(*so)-&gt;so_snd.sb_flags |= SB_NOCOMPRESS;

	bzero(&amp;smpo, <span class="enscript-keyword">sizeof</span> (smpo));
	smpo.mpo_flags |= MPOF_SUBFLOW_OK;
	smpo.mpo_level = SOL_SOCKET;
	smpo.mpo_intval = 1;

	<span class="enscript-comment">/* disable SIGPIPE */</span>
	smpo.mpo_name = SO_NOSIGPIPE;
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_sosetopt(mpte, *so, &amp;smpo)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* find out if the subflow's source address goes away */</span>
	smpo.mpo_name = SO_NOADDRERR;
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_sosetopt(mpte, *so, &amp;smpo)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* enable keepalive */</span>
	smpo.mpo_name = SO_KEEPALIVE;
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_sosetopt(mpte, *so, &amp;smpo)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Limit the receive socket buffer size to 64k.
	 *
	 * We need to take into consideration the window scale option
	 * which could be negotiated in one subflow but disabled in
	 * another subflow.
	 * XXX This can be improved in the future.
	 */</span>
	smpo.mpo_name = SO_RCVBUF;
	smpo.mpo_intval = MPTCP_RWIN_MAX;
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_sosetopt(mpte, *so, &amp;smpo)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* N.B.: set by sosetopt */</span>
	VERIFY(!((*so)-&gt;so_rcv.sb_flags &amp; SB_AUTOSIZE));
	<span class="enscript-comment">/* Prevent automatic socket buffer sizing. */</span>
	(*so)-&gt;so_snd.sb_flags &amp;= ~SB_AUTOSIZE;

	smpo.mpo_level = IPPROTO_TCP;
	smpo.mpo_intval = mptcp_subflow_keeptime;
	smpo.mpo_name = TCP_KEEPALIVE;
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_sosetopt(mpte, *so, &amp;smpo)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* replay setsockopt(2) on the subflow sockets for eligible options */</span>
	TAILQ_FOREACH_SAFE(mpo, &amp;mpte-&gt;mpte_sopts, mpo_entry, tmpo) {
		<span class="enscript-type">int</span> interim;

		<span class="enscript-keyword">if</span> (!(mpo-&gt;mpo_flags &amp; MPOF_SUBFLOW_OK))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Skip those that are handled internally; these options
		 * should not have been recorded and marked with the
		 * MPOF_SUBFLOW_OK by mptcp_setopt(), but just in case.
		 */</span>
		<span class="enscript-keyword">if</span> (mpo-&gt;mpo_level == SOL_SOCKET &amp;&amp;
		    (mpo-&gt;mpo_name == SO_NOSIGPIPE ||
		    mpo-&gt;mpo_name == SO_NOADDRERR ||
		    mpo-&gt;mpo_name == SO_KEEPALIVE))
			<span class="enscript-keyword">continue</span>;

		interim = (mpo-&gt;mpo_flags &amp; MPOF_INTERIM);
		<span class="enscript-keyword">if</span> (mptcp_subflow_sosetopt(mpte, *so, mpo) != 0 &amp;&amp; interim) {
			<span class="enscript-type">char</span> buf[32];
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: subflow socreate&quot;</span>
			    <span class="enscript-string">&quot; mp_so 0x%llx&quot;</span>
			    <span class="enscript-string">&quot; sopt %s val %d interim record removed\n&quot;</span>,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mptcp_sopt2str(mpo-&gt;mpo_level, mpo-&gt;mpo_name,
			    buf, <span class="enscript-keyword">sizeof</span> (buf)), mpo-&gt;mpo_intval),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			mptcp_sopt_remove(mpte, mpo);
			mptcp_sopt_free(mpo);
			<span class="enscript-keyword">continue</span>;
		}
	}

	<span class="enscript-comment">/*
	 * We need to receive everything that the subflow socket has,
	 * so use a customized socket receive function.  We will undo
	 * this when the socket is peeled off or closed.
	 */</span>
	mpts-&gt;mpts_oprotosw = (*so)-&gt;so_proto;
	<span class="enscript-keyword">switch</span> (dom) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
		(*so)-&gt;so_proto = &amp;mptcp_subflow_protosw;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
		(*so)-&gt;so_proto = (<span class="enscript-type">struct</span> protosw *)&amp;mptcp_subflow_protosw6;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

<span class="enscript-reference">out</span>:
	socket_unlock(*so, 0);

	DTRACE_MPTCP4(subflow__create, <span class="enscript-type">struct</span> mptses *, mpte,
	    <span class="enscript-type">struct</span> mptsub *, mpts, <span class="enscript-type">int</span>, dom, <span class="enscript-type">int</span>, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Close an MPTCP subflow socket.
 *
 * Note that this may be called on an embryonic subflow, and the only
 * thing that is guaranteed valid is the protocol-user request.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_soclose</span>(<span class="enscript-type">struct</span> mptsub *mpts, <span class="enscript-type">struct</span> socket *so)
{
	MPTS_LOCK_ASSERT_HELD(mpts);

	socket_lock(so, 0);
	VERIFY(so-&gt;so_flags &amp; SOF_MP_SUBFLOW);
	VERIFY((so-&gt;so_state &amp; (SS_NBIO|SS_NOFDREF)) == (SS_NBIO|SS_NOFDREF));

	<span class="enscript-comment">/* restore protocol-user requests */</span>
	VERIFY(mpts-&gt;mpts_oprotosw != NULL);
	so-&gt;so_proto = mpts-&gt;mpts_oprotosw;
	socket_unlock(so, 0);

	mpts-&gt;mpts_socket = NULL;	<span class="enscript-comment">/* may already be NULL */</span>

	DTRACE_MPTCP5(subflow__close, <span class="enscript-type">struct</span> mptsub *, mpts,
	    <span class="enscript-type">struct</span> socket *, so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd,
	    <span class="enscript-type">struct</span> mptses *, mpts-&gt;mpts_mpte);

	<span class="enscript-keyword">return</span> (soclose(so));
}

<span class="enscript-comment">/*
 * Connect an MPTCP subflow socket.
 *
 * This may be called inline as part of adding a subflow, or asynchronously
 * by the thread (upon progressing to MPTCPF_JOIN_READY).  Note that in the
 * pending connect case, the subflow socket may have been bound to an interface
 * and/or a source IP address which may no longer be around by the time this
 * routine is called; in that case the connect attempt will most likely fail.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_soconnectx</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts)
{
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">int</span> af, error;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	VERIFY((mpts-&gt;mpts_flags &amp; (MPTSF_CONNECTING|MPTSF_CONNECTED)) ==
	    MPTSF_CONNECTING);
	VERIFY(mpts-&gt;mpts_socket != NULL);
	so = mpts-&gt;mpts_socket;
	af = mpts-&gt;mpts_family;

	<span class="enscript-keyword">if</span> (af == AF_INET || af == AF_INET6) {
		<span class="enscript-type">struct</span> sockaddr_entry *dst_se;
		<span class="enscript-type">char</span> dbuf[MAX_IPv6_STR_LEN];

		dst_se = TAILQ_FIRST(&amp;mpts-&gt;mpts_dst_sl-&gt;sl_head);
		VERIFY(dst_se != NULL);

		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: connectx mp_so 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;dst %s[%d] cid %d [pended %s]\n&quot;</span>,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mpte-&gt;mpte_mppcb-&gt;mpp_socket),
		    inet_ntop(af, ((af == AF_INET) ?
		    (<span class="enscript-type">void</span> *)&amp;SIN(dst_se-&gt;se_addr)-&gt;sin_addr.s_addr :
		    (<span class="enscript-type">void</span> *)&amp;SIN6(dst_se-&gt;se_addr)-&gt;sin6_addr),
		    dbuf, <span class="enscript-keyword">sizeof</span> (dbuf)), ((af == AF_INET) ?
		    ntohs(SIN(dst_se-&gt;se_addr)-&gt;sin_port) :
		    ntohs(SIN6(dst_se-&gt;se_addr)-&gt;sin6_port)),
		    mpts-&gt;mpts_connid,
		    ((mpts-&gt;mpts_flags &amp; MPTSF_CONNECT_PENDING) ?
		    <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
	}

	mpts-&gt;mpts_flags &amp;= ~MPTSF_CONNECT_PENDING;

	socket_lock(so, 0);
	mptcp_attach_to_subf(so, mpte-&gt;mpte_mptcb, mpte-&gt;mpte_addrid_last);
	
	<span class="enscript-comment">/* connect the subflow socket */</span>
	error = soconnectxlocked(so, &amp;mpts-&gt;mpts_src_sl, &amp;mpts-&gt;mpts_dst_sl,
	    mpts-&gt;mpts_mpcr.mpcr_proc, mpts-&gt;mpts_mpcr.mpcr_ifscope,
	    mpte-&gt;mpte_associd, NULL, CONNREQF_MPTCP,
	    &amp;mpts-&gt;mpts_mpcr, <span class="enscript-keyword">sizeof</span> (mpts-&gt;mpts_mpcr), NULL, NULL);
	socket_unlock(so, 0);

	<span class="enscript-comment">/* Allocate a unique address id per subflow */</span>
	mpte-&gt;mpte_addrid_last++;
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_addrid_last == 0)
		mpte-&gt;mpte_addrid_last++;

	DTRACE_MPTCP3(subflow__connect, <span class="enscript-type">struct</span> mptses *, mpte,
	    <span class="enscript-type">struct</span> mptsub *, mpts, <span class="enscript-type">int</span>, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * MPTCP subflow socket receive routine, derived from soreceive().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_soreceive</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **psa,
    <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">struct</span> mbuf **mp0, <span class="enscript-type">struct</span> mbuf **controlp, <span class="enscript-type">int</span> *flagsp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">uio</span>)
	<span class="enscript-type">int</span> flags, error = 0;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">struct</span> mbuf *m, **mp = mp0;
	<span class="enscript-type">struct</span> mbuf *nextrecord;

	socket_lock(so, 1);
	VERIFY(so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 1) {
		panic(<span class="enscript-string">&quot;%s: so=%x no other reference on socket\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * We return all that is there in the subflow's socket receive buffer
	 * to the MPTCP layer, so we require that the caller passes in the
	 * expected parameters.
	 */</span>
	<span class="enscript-keyword">if</span> (mp == NULL || controlp != NULL) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	*mp = NULL;
	<span class="enscript-keyword">if</span> (psa != NULL)
		*psa = NULL;
	<span class="enscript-keyword">if</span> (flagsp != NULL)
		flags = *flagsp &amp;~ MSG_EOR;
	<span class="enscript-keyword">else</span>
		flags = 0;

	<span class="enscript-keyword">if</span> (flags &amp; (MSG_PEEK|MSG_OOB|MSG_NEEDSA|MSG_WAITALL|MSG_WAITSTREAM)) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);
	}
	flags |= (MSG_DONTWAIT|MSG_NBIO);

	<span class="enscript-comment">/*
	 * If a recv attempt is made on a previously-accepted socket
	 * that has been marked as inactive (disconnected), reject
	 * the request.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
		<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;

		error = ENOTCONN;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] (%d)\n&quot;</span>,
		    __func__, proc_pid(p), (uint64_t)VM_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), error));
		<span class="enscript-comment">/*
		 * This socket should have been disconnected and flushed
		 * prior to being returned from sodefunct(); there should
		 * be no data on its receive list, so panic otherwise.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_DEFUNCT)
			sb_empty_assert(sb, __func__);
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * See if the socket has been closed (SS_NOFDREF|SS_CANTRCVMORE)
	 * and if so just return to the caller.  This could happen when
	 * soreceive() is called by a socket upcall function during the
	 * time the socket is freed.  The socket buffer would have been
	 * locked across the upcall, therefore we cannot put this thread
	 * to sleep (else we will deadlock) or return EWOULDBLOCK (else
	 * we may livelock), because the lock on the socket buffer will
	 * only be released when the upcall routine returns to its caller.
	 * Because the socket has been officially closed, there can be
	 * no further read on it.
	 *
	 * A multipath subflow socket would have its SS_NOFDREF set by
	 * default, so check for SOF_MP_SUBFLOW socket flag; when the
	 * socket is closed for real, SOF_MP_SUBFLOW would be cleared.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_NOFDREF | SS_CANTRCVMORE)) ==
	    (SS_NOFDREF | SS_CANTRCVMORE) &amp;&amp; !(so-&gt;so_flags &amp; SOF_MP_SUBFLOW)) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * For consistency with soreceive() semantics, we need to obey
	 * SB_LOCK in case some other code path has locked the buffer.
	 */</span>
	error = sblock(&amp;so-&gt;so_rcv, 0);
	<span class="enscript-keyword">if</span> (error != 0) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (error);
	}

	m = so-&gt;so_rcv.sb_mb;
	<span class="enscript-keyword">if</span> (m == NULL) {
		<span class="enscript-comment">/*
		 * Panic if we notice inconsistencies in the socket's
		 * receive list; both sb_mb and sb_cc should correctly
		 * reflect the contents of the list, otherwise we may
		 * end up with false positives during select() or poll()
		 * which could put the application in a bad state.
		 */</span>
		SB_MB_CHECK(&amp;so-&gt;so_rcv);

		<span class="enscript-keyword">if</span> (so-&gt;so_error != 0) {
			error = so-&gt;so_error;
			so-&gt;so_error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}

		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}

		<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING))) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}

		<span class="enscript-comment">/*
		 * MSG_DONTWAIT is implicitly defined and this routine will
		 * never block, so return EWOULDBLOCK when there is nothing.
		 */</span>
		error = EWOULDBLOCK;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgrcv);
	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;mptcp_subflow_soreceive 1&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;mptcp_subflow_soreceive 1&quot;</span>);

	<span class="enscript-keyword">while</span> (m != NULL) {
		nextrecord = m-&gt;m_nextpkt;
		sbfree(&amp;so-&gt;so_rcv, m);

		<span class="enscript-keyword">if</span> (mp != NULL) {
			*mp = m;
			mp = &amp;m-&gt;m_next;
			so-&gt;so_rcv.sb_mb = m = m-&gt;m_next;
			*mp = NULL;
		}

		<span class="enscript-keyword">if</span> (m != NULL) {
			m-&gt;m_nextpkt = nextrecord;
			<span class="enscript-keyword">if</span> (nextrecord == NULL)
				so-&gt;so_rcv.sb_lastrecord = m;
		} <span class="enscript-keyword">else</span> {
			m = so-&gt;so_rcv.sb_mb = nextrecord;
			SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
		}
		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;mptcp_subflow_soreceive 2&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;mptcp_subflow_soreceive 2&quot;</span>);
	}

	DTRACE_MPTCP3(subflow__receive, <span class="enscript-type">struct</span> socket *, so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv, <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd);
	<span class="enscript-comment">/* notify protocol that we drained all the data */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_proto-&gt;pr_flags &amp; PR_WANTRCVD) &amp;&amp; so-&gt;so_pcb != NULL)
		(*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_rcvd)(so, flags);

	<span class="enscript-keyword">if</span> (flagsp != NULL)
		*flagsp |= flags;

<span class="enscript-reference">release</span>:
	sbunlock(&amp;so-&gt;so_rcv, FALSE);	<span class="enscript-comment">/* will unlock socket */</span>
	<span class="enscript-keyword">return</span> (error);

}


<span class="enscript-comment">/*
 * Prepare an MPTCP subflow socket for peeloff(2); basically undo
 * the work done earlier when the subflow socket was created.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_sopeeloff</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
    <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> mptopt smpo;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">int</span> p, c;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	MPTS_LOCK_ASSERT_HELD(mpts);

	socket_lock(so, 0);
	VERIFY(so-&gt;so_flags &amp; SOF_MP_SUBFLOW);
	VERIFY((so-&gt;so_state &amp; (SS_NBIO|SS_NOFDREF)) == (SS_NBIO|SS_NOFDREF));

	<span class="enscript-comment">/* inherit MPTCP socket states */</span>
	<span class="enscript-keyword">if</span> (!(mp_so-&gt;so_state &amp; SS_NBIO))
		so-&gt;so_state &amp;= ~SS_NBIO;

	<span class="enscript-comment">/*
	 * At this point, the socket is not yet closed, as there is at least
	 * one outstanding usecount previously held by mpts_socket from
	 * socreate().  Atomically clear SOF_MP_SUBFLOW and SS_NOFDREF here.
	 */</span>
	so-&gt;so_flags &amp;= ~SOF_MP_SUBFLOW;
	so-&gt;so_state &amp;= ~SS_NOFDREF;
	so-&gt;so_flags &amp;= ~SOF_MPTCP_TRUE;

	<span class="enscript-comment">/* allow socket buffers to be compressed */</span>
	so-&gt;so_rcv.sb_flags &amp;= ~SB_NOCOMPRESS;
	so-&gt;so_snd.sb_flags &amp;= ~SB_NOCOMPRESS;

	<span class="enscript-comment">/*
	 * Allow socket buffer auto sizing.
	 *
	 * This will increase the current 64k buffer size to whatever is best.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_rcv.sb_flags &amp; SB_USRSIZE))	 
		so-&gt;so_rcv.sb_flags |= SB_AUTOSIZE;
	<span class="enscript-keyword">if</span> (!(so-&gt;so_snd.sb_flags &amp; SB_USRSIZE))
		so-&gt;so_snd.sb_flags |= SB_AUTOSIZE;

	<span class="enscript-comment">/* restore protocol-user requests */</span>
	VERIFY(mpts-&gt;mpts_oprotosw != NULL);
	so-&gt;so_proto = mpts-&gt;mpts_oprotosw;

	bzero(&amp;smpo, <span class="enscript-keyword">sizeof</span> (smpo));
	smpo.mpo_flags |= MPOF_SUBFLOW_OK;
	smpo.mpo_level = SOL_SOCKET;

	<span class="enscript-comment">/* inherit SOF_NOSIGPIPE from parent MP socket */</span>
	p = (mp_so-&gt;so_flags &amp; SOF_NOSIGPIPE);
	c = (so-&gt;so_flags &amp; SOF_NOSIGPIPE);
	smpo.mpo_intval = ((p - c) &gt; 0) ? 1 : 0;
	smpo.mpo_name = SO_NOSIGPIPE;
	<span class="enscript-keyword">if</span> ((p - c) != 0)
		(<span class="enscript-type">void</span>) mptcp_subflow_sosetopt(mpte, so, &amp;smpo);

	<span class="enscript-comment">/* inherit SOF_NOADDRAVAIL from parent MP socket */</span>
	p = (mp_so-&gt;so_flags &amp; SOF_NOADDRAVAIL);
	c = (so-&gt;so_flags &amp; SOF_NOADDRAVAIL);
	smpo.mpo_intval = ((p - c) &gt; 0) ? 1 : 0;
	smpo.mpo_name = SO_NOADDRERR;
	<span class="enscript-keyword">if</span> ((p - c) != 0)
		(<span class="enscript-type">void</span>) mptcp_subflow_sosetopt(mpte, so, &amp;smpo);

	<span class="enscript-comment">/* inherit SO_KEEPALIVE from parent MP socket */</span>
	p = (mp_so-&gt;so_options &amp; SO_KEEPALIVE);
	c = (so-&gt;so_options &amp; SO_KEEPALIVE);
	smpo.mpo_intval = ((p - c) &gt; 0) ? 1 : 0;
	smpo.mpo_name = SO_KEEPALIVE;
	<span class="enscript-keyword">if</span> ((p - c) != 0)
		(<span class="enscript-type">void</span>) mptcp_subflow_sosetopt(mpte, so, &amp;smpo);

	<span class="enscript-comment">/* unset TCP level default keepalive option */</span>
	p = (intotcpcb(sotoinpcb(mp_so)))-&gt;t_keepidle;
	c = (intotcpcb(sotoinpcb(so)))-&gt;t_keepidle;
	smpo.mpo_level = IPPROTO_TCP;
	smpo.mpo_intval = 0;
	smpo.mpo_name = TCP_KEEPALIVE;
	<span class="enscript-keyword">if</span> ((p - c) != 0)
		(<span class="enscript-type">void</span>) mptcp_subflow_sosetopt(mpte, so, &amp;smpo);
	socket_unlock(so, 0);

	DTRACE_MPTCP5(subflow__peeloff, <span class="enscript-type">struct</span> mptses *, mpte,
	    <span class="enscript-type">struct</span> mptsub *, mpts, <span class="enscript-type">struct</span> socket *, so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv, <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd);
}

<span class="enscript-comment">/*
 * Establish an initial MPTCP connection (if first subflow and not yet
 * connected), or add a subflow to an existing MPTCP connection.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_add</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
    <span class="enscript-type">struct</span> proc *p, uint32_t ifscope)
{
	<span class="enscript-type">struct</span> sockaddr_entry *se, *src_se = NULL, *dst_se = NULL;
	<span class="enscript-type">struct</span> socket *mp_so, *so = NULL;
	<span class="enscript-type">struct</span> mptsub_connreq mpcr;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">int</span> af, error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt;= MPTCPS_CLOSE_WAIT) {
		<span class="enscript-comment">/* If the remote end sends Data FIN, refuse subflow adds */</span>
		error = ENOTCONN;
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">return</span> (error);
	}
	MPT_UNLOCK(mp_tp);

	MPTS_LOCK(mpts);
	VERIFY(!(mpts-&gt;mpts_flags &amp; (MPTSF_CONNECTING|MPTSF_CONNECTED)));
	VERIFY(mpts-&gt;mpts_mpte == NULL);
	VERIFY(mpts-&gt;mpts_socket == NULL);
	VERIFY(mpts-&gt;mpts_dst_sl != NULL);
	VERIFY(mpts-&gt;mpts_connid == SAE_CONNID_ANY);

	<span class="enscript-comment">/* select source (if specified) and destination addresses */</span>
	<span class="enscript-keyword">if</span> ((error = in_selectaddrs(AF_UNSPEC, &amp;mpts-&gt;mpts_src_sl, &amp;src_se,
	    &amp;mpts-&gt;mpts_dst_sl, &amp;dst_se)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	VERIFY(mpts-&gt;mpts_dst_sl != NULL &amp;&amp; dst_se != NULL);
	VERIFY(src_se == NULL || mpts-&gt;mpts_src_sl != NULL);
	af = mpts-&gt;mpts_family = dst_se-&gt;se_addr-&gt;sa_family;
	VERIFY(src_se == NULL || src_se-&gt;se_addr-&gt;sa_family == af);
	VERIFY(af == AF_INET || af == AF_INET6);

	<span class="enscript-comment">/*
	 * If the source address is not specified, allocate a storage for
	 * it, so that later on we can fill it in with the actual source
	 * IP address chosen by the underlying layer for the subflow after
	 * it is connected.
	 */</span>
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_src_sl == NULL) {
		mpts-&gt;mpts_src_sl =
		    sockaddrlist_dup(mpts-&gt;mpts_dst_sl, M_WAITOK);
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_src_sl == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		se = TAILQ_FIRST(&amp;mpts-&gt;mpts_src_sl-&gt;sl_head);
		VERIFY(se != NULL &amp;&amp; se-&gt;se_addr != NULL &amp;&amp;
		    se-&gt;se_addr-&gt;sa_len == dst_se-&gt;se_addr-&gt;sa_len);
		bzero(se-&gt;se_addr, se-&gt;se_addr-&gt;sa_len);
		se-&gt;se_addr-&gt;sa_len = dst_se-&gt;se_addr-&gt;sa_len;
		se-&gt;se_addr-&gt;sa_family = dst_se-&gt;se_addr-&gt;sa_family;
	}

	<span class="enscript-comment">/* create the subflow socket */</span>
	<span class="enscript-keyword">if</span> ((error = mptcp_subflow_socreate(mpte, mpts, af, p, &amp;so)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* If fastjoin is requested, set state in mpts */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MPTCP_FASTJOIN) &amp;&amp;
	    (mp_tp-&gt;mpt_state == MPTCPS_ESTABLISHED) &amp;&amp;
	    (mpte-&gt;mpte_nummpcapflows == 0)) {
		mpts-&gt;mpts_flags |= MPTSF_FASTJ_REQD;
		mpts-&gt;mpts_rel_seq = 1;
		MPT_LOCK(mp_tp);
		mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
		MPT_UNLOCK(mp_tp);
	}

	<span class="enscript-comment">/*
	 * Increment the counter, while avoiding 0 (SAE_CONNID_ANY) and
	 * -1 (SAE_CONNID_ALL).
	 */</span>
	mpte-&gt;mpte_connid_last++;
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_connid_last == SAE_CONNID_ALL ||
	    mpte-&gt;mpte_connid_last == SAE_CONNID_ANY)
		mpte-&gt;mpte_connid_last++;

	mpts-&gt;mpts_connid = mpte-&gt;mpte_connid_last;
	VERIFY(mpts-&gt;mpts_connid != SAE_CONNID_ANY &amp;&amp;
	    mpts-&gt;mpts_connid != SAE_CONNID_ALL);
	
	<span class="enscript-comment">/* Allocate a unique address id per subflow */</span>
	mpte-&gt;mpte_addrid_last++;
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_addrid_last == 0)
		mpte-&gt;mpte_addrid_last++;

	<span class="enscript-comment">/* bind subflow socket to the specified interface */</span>
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE) {
		socket_lock(so, 0);
		error = inp_bindif(sotoinpcb(so), ifscope, &amp;mpts-&gt;mpts_outif);
		<span class="enscript-keyword">if</span> (error != 0) {
			socket_unlock(so, 0);
			(<span class="enscript-type">void</span>) mptcp_subflow_soclose(mpts, so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		VERIFY(mpts-&gt;mpts_outif != NULL);
		mpts-&gt;mpts_flags |= MPTSF_BOUND_IF;

		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: subflow_add mp_so 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;bindif %s[%d] cid d\n&quot;</span>,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mpts-&gt;mpts_outif-&gt;if_xname,
		    ifscope, mpts-&gt;mpts_connid),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
		socket_unlock(so, 0);
	}

	<span class="enscript-comment">/* if source address and/or port is specified, bind to it */</span>
	<span class="enscript-keyword">if</span> (src_se != NULL) {
		<span class="enscript-type">struct</span> sockaddr *sa = src_se-&gt;se_addr;
		uint32_t mpts_flags = 0;
		in_port_t lport;

		<span class="enscript-keyword">switch</span> (af) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (SIN(sa)-&gt;sin_addr.s_addr != INADDR_ANY)
				mpts_flags |= MPTSF_BOUND_IP;
			<span class="enscript-keyword">if</span> ((lport = SIN(sa)-&gt;sin_port) != 0)
				mpts_flags |= MPTSF_BOUND_PORT;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			VERIFY(af == AF_INET6);
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;SIN6(sa)-&gt;sin6_addr))
				mpts_flags |= MPTSF_BOUND_IP;
			<span class="enscript-keyword">if</span> ((lport = SIN6(sa)-&gt;sin6_port) != 0)
				mpts_flags |= MPTSF_BOUND_PORT;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		}

		error = sobindlock(so, sa, 1);	<span class="enscript-comment">/* will lock/unlock socket */</span>
		<span class="enscript-keyword">if</span> (error != 0) {
			(<span class="enscript-type">void</span>) mptcp_subflow_soclose(mpts, so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		mpts-&gt;mpts_flags |= mpts_flags;

		<span class="enscript-keyword">if</span> (af == AF_INET || af == AF_INET6) {
			<span class="enscript-type">char</span> sbuf[MAX_IPv6_STR_LEN];

			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: subflow_add &quot;</span>
			    <span class="enscript-string">&quot;mp_so 0x%llx bindip %s[%d] cid %d\n&quot;</span>,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    inet_ntop(af, ((af == AF_INET) ?
			    (<span class="enscript-type">void</span> *)&amp;SIN(sa)-&gt;sin_addr.s_addr :
			    (<span class="enscript-type">void</span> *)&amp;SIN6(sa)-&gt;sin6_addr), sbuf, <span class="enscript-keyword">sizeof</span> (sbuf)),
			    ntohs(lport), mpts-&gt;mpts_connid),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
		}
	}

	<span class="enscript-comment">/*
	 * Insert the subflow into the list, and associate the MPTCP PCB
	 * as well as the the subflow socket.  From this point on, removing
	 * the subflow needs to be done via mptcp_subflow_del().
	 */</span>
	TAILQ_INSERT_TAIL(&amp;mpte-&gt;mpte_subflows, mpts, mpts_entry);
	mpte-&gt;mpte_numflows++;

	atomic_bitset_32(&amp;mpts-&gt;mpts_flags, MPTSF_ATTACHED);
	mpts-&gt;mpts_mpte = mpte;
	mpts-&gt;mpts_socket = so;
	MPTS_ADDREF_LOCKED(mpts);	<span class="enscript-comment">/* for being in MPTCP subflow list */</span>
	MPTS_ADDREF_LOCKED(mpts);	<span class="enscript-comment">/* for subflow socket */</span>
	mp_so-&gt;so_usecount++;		<span class="enscript-comment">/* for subflow socket */</span>

	<span class="enscript-comment">/* register for subflow socket read/write events */</span>
	(<span class="enscript-type">void</span>) sock_setupcalls(so, mptcp_subflow_rupcall, mpts,
	    mptcp_subflow_wupcall, mpts);

	<span class="enscript-comment">/*
	 * Register for subflow socket control events; ignore
	 * SO_FILT_HINT_CONNINFO_UPDATED from below since we
	 * will generate it here.
	 */</span>
	(<span class="enscript-type">void</span>) sock_catchevents(so, mptcp_subflow_eupcall, mpts,
	    SO_FILT_HINT_CONNRESET | SO_FILT_HINT_CANTRCVMORE |
	    SO_FILT_HINT_CANTSENDMORE | SO_FILT_HINT_TIMEOUT |
	    SO_FILT_HINT_NOSRCADDR | SO_FILT_HINT_IFDENIED |
	    SO_FILT_HINT_SUSPEND | SO_FILT_HINT_RESUME |
	    SO_FILT_HINT_CONNECTED | SO_FILT_HINT_DISCONNECTED |
	    SO_FILT_HINT_MPFAILOVER | SO_FILT_HINT_MPSTATUS |
	    SO_FILT_HINT_MUSTRST | SO_FILT_HINT_MPFASTJ |
	    SO_FILT_HINT_DELETEOK | SO_FILT_HINT_MPCANTRCVMORE);

	<span class="enscript-comment">/* sanity check */</span>
	VERIFY(!(mpts-&gt;mpts_flags &amp;
	    (MPTSF_CONNECTING|MPTSF_CONNECTED|MPTSF_CONNECT_PENDING)));

	bzero(&amp;mpcr, <span class="enscript-keyword">sizeof</span> (mpcr));
	mpcr.mpcr_proc = p;
	mpcr.mpcr_ifscope = ifscope;
	<span class="enscript-comment">/*
	 * Indicate to the TCP subflow whether or not it should establish
	 * the initial MPTCP connection, or join an existing one.  Fill
	 * in the connection request structure with additional info needed
	 * by the underlying TCP (to be used in the TCP options, etc.)
	 */</span>
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED &amp;&amp; mpte-&gt;mpte_numflows == 1) {
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state == MPTCPS_CLOSED) {
			mp_tp-&gt;mpt_localkey = mptcp_reserve_key();
			mptcp_conn_properties(mp_tp);
		}
		MPT_UNLOCK(mp_tp);
		soisconnecting(mp_so);
		mpcr.mpcr_type = MPTSUB_CONNREQ_MP_ENABLE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!(mp_tp-&gt;mpt_flags &amp; MPTCPF_JOIN_READY))
			mpts-&gt;mpts_flags |= MPTSF_CONNECT_PENDING;

		<span class="enscript-comment">/* avoid starting up cellular subflow unless required */</span>
		<span class="enscript-keyword">if</span> ((mptcp_delayed_subf_start) &amp;&amp;
		    (IFNET_IS_CELLULAR(mpts-&gt;mpts_outif))) {
		    	mpts-&gt;mpts_flags |= MPTSF_CONNECT_PENDING;
		}
		MPT_UNLOCK(mp_tp);
		mpcr.mpcr_type = MPTSUB_CONNREQ_MP_ADD;
	}

	mpts-&gt;mpts_mpcr = mpcr;
	mpts-&gt;mpts_flags |= MPTSF_CONNECTING;

	<span class="enscript-keyword">if</span> (af == AF_INET || af == AF_INET6) {
		<span class="enscript-type">char</span> dbuf[MAX_IPv6_STR_LEN];

		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s &quot;</span>
		    <span class="enscript-string">&quot;mp_so 0x%llx dst %s[%d] cid %d &quot;</span>
		    <span class="enscript-string">&quot;[pending %s]\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    inet_ntop(af, ((af == AF_INET) ?
		    (<span class="enscript-type">void</span> *)&amp;SIN(dst_se-&gt;se_addr)-&gt;sin_addr.s_addr :
		    (<span class="enscript-type">void</span> *)&amp;SIN6(dst_se-&gt;se_addr)-&gt;sin6_addr),
		    dbuf, <span class="enscript-keyword">sizeof</span> (dbuf)), ((af == AF_INET) ?
		    ntohs(SIN(dst_se-&gt;se_addr)-&gt;sin_port) :
		    ntohs(SIN6(dst_se-&gt;se_addr)-&gt;sin6_port)),
		    mpts-&gt;mpts_connid,
		    ((mpts-&gt;mpts_flags &amp; MPTSF_CONNECT_PENDING) ?
		    <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
	}

	<span class="enscript-comment">/* connect right away if first attempt, or if join can be done now */</span>
	<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_CONNECT_PENDING))
		error = mptcp_subflow_soconnectx(mpte, mpts);

<span class="enscript-reference">out</span>:
	MPTS_UNLOCK(mpts);
	<span class="enscript-keyword">if</span> (error == 0) {
		soevent(mp_so, SO_FILT_HINT_LOCKED |
		    SO_FILT_HINT_CONNINFO_UPDATED);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Delete/remove a subflow from an MPTCP.  The underlying subflow socket
 * will no longer be accessible after a subflow is deleted, thus this
 * should occur only after the subflow socket has been disconnected.
 * If peeloff(2) is called, leave the socket open.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_del</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts, boolean_t close)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	MPTS_LOCK(mpts);
	so = mpts-&gt;mpts_socket;
	VERIFY(so != NULL);
	
	<span class="enscript-keyword">if</span> (close &amp;&amp; !((mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    (mpts-&gt;mpts_flags &amp; MPTSF_USER_DISCONNECT))) {
		MPTS_UNLOCK(mpts);
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: subflow_del returning&quot;</span>
		    <span class="enscript-string">&quot; mp_so 0x%llx flags %x\n&quot;</span>,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), mpts-&gt;mpts_flags),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
		<span class="enscript-keyword">return</span>;
	}

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: subflow_del mp_so 0x%llx &quot;</span>
	    <span class="enscript-string">&quot;[u=%d,r=%d] cid %d [close %s] %d %x error %d\n&quot;</span>,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
	    mp_so-&gt;so_usecount,
	    mp_so-&gt;so_retaincnt, mpts-&gt;mpts_connid,
	    (close ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>), mpts-&gt;mpts_soerror,
	    mpts-&gt;mpts_flags,
	    mp_so-&gt;so_error),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

	VERIFY(mpts-&gt;mpts_mpte == mpte);
	VERIFY(mpts-&gt;mpts_connid != SAE_CONNID_ANY &amp;&amp;
	    mpts-&gt;mpts_connid != SAE_CONNID_ALL);

	VERIFY(mpts-&gt;mpts_flags &amp; MPTSF_ATTACHED);
	atomic_bitclear_32(&amp;mpts-&gt;mpts_flags, MPTSF_ATTACHED);
	TAILQ_REMOVE(&amp;mpte-&gt;mpte_subflows, mpts, mpts_entry);
	VERIFY(mpte-&gt;mpte_numflows != 0);
	mpte-&gt;mpte_numflows--;
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_active_sub == mpts)
		mpte-&gt;mpte_active_sub = NULL;

	<span class="enscript-comment">/*
	 * Drop references held by this subflow socket; there
	 * will be no further upcalls made from this point.
	 */</span>
	(<span class="enscript-type">void</span>) sock_setupcalls(so, NULL, NULL, NULL, NULL);
	(<span class="enscript-type">void</span>) sock_catchevents(so, NULL, NULL, 0);

	mptcp_detach_mptcb_from_subf(mpte-&gt;mpte_mptcb, so);
	
	<span class="enscript-keyword">if</span> (close)
		(<span class="enscript-type">void</span>) mptcp_subflow_soclose(mpts, so);

	VERIFY(mp_so-&gt;so_usecount != 0);
	mp_so-&gt;so_usecount--;		<span class="enscript-comment">/* for subflow socket */</span>
	mpts-&gt;mpts_mpte = NULL;
	mpts-&gt;mpts_socket = NULL;
	MPTS_UNLOCK(mpts);

	MPTS_REMREF(mpts);		<span class="enscript-comment">/* for MPTCP subflow list */</span>
	MPTS_REMREF(mpts);		<span class="enscript-comment">/* for subflow socket */</span>

	soevent(mp_so, SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNINFO_UPDATED);
}

<span class="enscript-comment">/*
 * Disconnect a subflow socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_disconnect</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
    boolean_t deleteok)
{
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">int</span> send_dfin = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	VERIFY(mpts-&gt;mpts_mpte == mpte);
	VERIFY(mpts-&gt;mpts_socket != NULL);
	VERIFY(mpts-&gt;mpts_connid != SAE_CONNID_ANY &amp;&amp;
	    mpts-&gt;mpts_connid != SAE_CONNID_ALL);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; (MPTSF_DISCONNECTING|MPTSF_DISCONNECTED))
		<span class="enscript-keyword">return</span>;

	mpts-&gt;mpts_flags |= MPTSF_DISCONNECTING;

	<span class="enscript-comment">/*
	 * If this is coming from disconnectx(2) or issued as part of
	 * closing the MPTCP socket, the subflow shouldn't stick around.
	 * Otherwise let it linger around in case the upper layers need
	 * to retrieve its conninfo.
	 */</span>
	<span class="enscript-keyword">if</span> (deleteok)
		mpts-&gt;mpts_flags |= MPTSF_DELETEOK;

	so = mpts-&gt;mpts_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt; MPTCPS_ESTABLISHED)
		send_dfin = 1;
	MPT_UNLOCK(mp_tp);

	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; (SS_ISDISCONNECTING | SS_ISDISCONNECTED)) &amp;&amp;
	    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket %s: cid %d fin %d &quot;</span>
		    <span class="enscript-string">&quot;[linger %s]\n&quot;</span>, __func__, mpts-&gt;mpts_connid, send_dfin,
		    (deleteok ? <span class="enscript-string">&quot;NO&quot;</span> : <span class="enscript-string">&quot;YES&quot;</span>)),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

		<span class="enscript-keyword">if</span> (send_dfin)
			mptcp_send_dfin(so);
		(<span class="enscript-type">void</span>) soshutdownlock(so, SHUT_RD);
		(<span class="enscript-type">void</span>) soshutdownlock(so, SHUT_WR);
		(<span class="enscript-type">void</span>) sodisconnectlocked(so);
	}
	socket_unlock(so, 0);
	<span class="enscript-comment">/*
	 * Generate a disconnect event for this subflow socket, in case
	 * the lower layer doesn't do it; this is needed because the
	 * subflow socket deletion relies on it.  This will also end up
	 * generating SO_FILT_HINT_CONNINFO_UPDATED on the MPTCP socket;
	 * we cannot do that here because subflow lock is currently held.
	 */</span>
	mptcp_subflow_eupcall(so, mpts, SO_FILT_HINT_DISCONNECTED);
}

<span class="enscript-comment">/*
 * Subflow socket read upcall.
 *
 * Called when the associated subflow socket posted a read event.  The subflow
 * socket lock has been released prior to invoking the callback.  Note that the
 * upcall may occur synchronously as a result of MPTCP performing an action on
 * it, or asynchronously as a result of an event happening at the subflow layer.
 * Therefore, to maintain lock ordering, the only lock that can be acquired
 * here is the thread lock, for signalling purposes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_rupcall</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> waitf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>, <span class="enscript-variable-name">waitf</span>)
	<span class="enscript-type">struct</span> mptsub *mpts = arg;
	<span class="enscript-type">struct</span> mptses *mpte = mpts-&gt;mpts_mpte;

	<span class="enscript-comment">/* 
	 * mpte should never be NULL, except in a race with 
	 * mptcp_subflow_del 
	 */</span>
	<span class="enscript-keyword">if</span> (mpte == NULL)
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(&amp;mpte-&gt;mpte_thread_lock);
	mptcp_thread_signal_locked(mpte);
	lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
}

<span class="enscript-comment">/*
 * Subflow socket input.
 *
 * Called in the context of the MPTCP thread, for reading data from the
 * underlying subflow socket and delivering it to MPTCP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_input</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts)
{
	<span class="enscript-type">struct</span> mbuf *m = NULL;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> mptsub *mpts_alt = NULL;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	DTRACE_MPTCP2(subflow__input, <span class="enscript-type">struct</span> mptses *, mpte, 
	    <span class="enscript-type">struct</span> mptsub *, mpts);

	<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_CONNECTED))
		<span class="enscript-keyword">return</span>;

	so = mpts-&gt;mpts_socket;

	error = sock_receive_internal(so, NULL, &amp;m, 0, NULL);
	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EWOULDBLOCK) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Receiver: %s cid %d error %d\n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid, error),
		    MPTCP_RECEIVER_DBG, MPTCP_LOGLVL_ERR);
		MPTS_UNLOCK(mpts);
		mpts_alt = mptcp_get_subflow(mpte, mpts, NULL);
		<span class="enscript-keyword">if</span> (mpts_alt == NULL) {
			<span class="enscript-keyword">if</span> (mptcp_delayed_subf_start) {
				mpts_alt = mptcp_get_pending_subflow(mpte,
				    mpts);
				<span class="enscript-keyword">if</span> (mpts_alt) {
					mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Receiver:&quot;</span>
					<span class="enscript-string">&quot; %s: pending %d\n&quot;</span>,
					__func__, mpts_alt-&gt;mpts_connid),
					MPTCP_RECEIVER_DBG, MPTCP_LOGLVL_ERR);
				} <span class="enscript-keyword">else</span> {
					mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Receiver:&quot;</span>
					    <span class="enscript-string">&quot; %s: no pending flow for cid %d&quot;</span>,
					    __func__, mpts-&gt;mpts_connid),
					    MPTCP_RECEIVER_DBG, MPTCP_LOGLVL_ERR);
				}
			} <span class="enscript-keyword">else</span> {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Receiver: %s: no alt&quot;</span>
				    <span class="enscript-string">&quot; path for cid %d\n&quot;</span>, __func__, 
				    mpts-&gt;mpts_connid),
				    MPTCP_RECEIVER_DBG, MPTCP_LOGLVL_ERR);
			}
		}
		MPTS_LOCK(mpts);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Receiver: %s: cid %d \n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid),
		    MPTCP_RECEIVER_DBG, MPTCP_LOGLVL_VERBOSE);
	}

	<span class="enscript-comment">/* In fallback, make sure to accept data on all but one subflow */</span>
	<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) &amp;&amp;
	    (!(mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE))) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (m != NULL) {

		<span class="enscript-comment">/* Did we receive data on the backup subflow? */</span>
		<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE))
			mpts-&gt;mpts_peerswitch++;
		<span class="enscript-keyword">else</span>
			mpts-&gt;mpts_peerswitch = 0;

		<span class="enscript-comment">/*
		 * Release subflow lock since this may trigger MPTCP to send,
		 * possibly on a different subflow.  An extra reference has
		 * been held on the subflow by the MPTCP thread before coming
		 * here, so we can be sure that it won't go away, in the event
		 * the MP socket lock gets released.
		 */</span>
		MPTS_UNLOCK(mpts);
		mptcp_input(mpte, m);
		MPTS_LOCK(mpts);
	}
}

<span class="enscript-comment">/*
 * Subflow socket write upcall.
 *
 * Called when the associated subflow socket posted a read event.  The subflow
 * socket lock has been released prior to invoking the callback.  Note that the
 * upcall may occur synchronously as a result of MPTCP performing an action on
 * it, or asynchronously as a result of an event happening at the subflow layer.
 * Therefore, to maintain lock ordering, the only lock that can be acquired
 * here is the thread lock, for signalling purposes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_wupcall</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> waitf)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>, <span class="enscript-variable-name">waitf</span>)
	<span class="enscript-type">struct</span> mptsub *mpts = arg;
	<span class="enscript-type">struct</span> mptses *mpte = mpts-&gt;mpts_mpte;

	<span class="enscript-comment">/*
	 * mpte should never be NULL except in a race with 
	 * mptcp_subflow_del which doesn't hold socket lock across critical
	 * section. This upcall is made after releasing the socket lock.
	 * Interleaving of socket operations becomes possible therefore.
	 */</span>
	<span class="enscript-keyword">if</span> (mpte == NULL)
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(&amp;mpte-&gt;mpte_thread_lock);
	mptcp_thread_signal_locked(mpte);
	lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
}

<span class="enscript-comment">/*
 * Subflow socket output.
 *
 * Called for sending data from MPTCP to the underlying subflow socket.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_output</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	size_t sb_cc = 0, tot_sent = 0;
	<span class="enscript-type">struct</span> mbuf *sb_mb;
	<span class="enscript-type">int</span> error = 0;
	u_int64_t mpt_dsn = 0;
	<span class="enscript-type">struct</span> mptcb *mp_tp = mpte-&gt;mpte_mptcb;
	<span class="enscript-type">struct</span> mbuf *mpt_mbuf = NULL;
	u_int64_t off = 0;
	<span class="enscript-type">struct</span> mbuf *head, *tail;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	so = mpts-&gt;mpts_socket;

	DTRACE_MPTCP2(subflow__output, <span class="enscript-type">struct</span> mptses *, mpte, 
	    <span class="enscript-type">struct</span> mptsub *, mpts);

	<span class="enscript-comment">/* subflow socket is suspended? */</span>
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_SUSPENDED) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Sender: %s mp_so 0x%llx cid %d is &quot;</span>
		    <span class="enscript-string">&quot;flow controlled\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), mpts-&gt;mpts_connid),
		    MPTCP_SENDER_DBG, MPTCP_LOGLVL_ERR);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* subflow socket is not MPTCP capable? */</span>
	<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE) &amp;&amp;
	    !(mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) &amp;&amp;
	    !(mpts-&gt;mpts_flags &amp; MPTSF_FASTJ_SEND)) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Sender: %s mp_so 0x%llx cid %d not &quot;</span>
		    <span class="enscript-string">&quot;MPTCP capable\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), mpts-&gt;mpts_connid),
		    MPTCP_SENDER_DBG, MPTCP_LOGLVL_ERR);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Remove Addr Option is not sent reliably as per I-D */</span>
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_flags &amp; MPTE_SND_REM_ADDR) {
		<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(sotoinpcb(so));
		tp-&gt;t_rem_aid = mpte-&gt;mpte_lost_aid;
		<span class="enscript-keyword">if</span> (mptcp_remaddr_enable)
			tp-&gt;t_mpflags |= TMPF_SND_REM_ADDR;
		mpte-&gt;mpte_flags &amp;= ~MPTE_SND_REM_ADDR;
	}

	<span class="enscript-comment">/*
	 * The mbuf chains containing the metadata (as well as pointing to
	 * the user data sitting at the MPTCP output queue) would then be
	 * sent down to the subflow socket.
	 *
	 * Some notes on data sequencing:
	 *
	 *   a. Each mbuf must be a M_PKTHDR.
	 *   b. MPTCP metadata is stored in the mptcp_pktinfo structure
	 *	in the mbuf pkthdr structure.
	 *   c. Each mbuf containing the MPTCP metadata must have its
	 *	pkt_flags marked with the PKTF_MPTCP flag.
	 */</span>

	<span class="enscript-comment">/* First, drop acknowledged data */</span>
	sb_mb = mp_so-&gt;so_snd.sb_mb;
	<span class="enscript-keyword">if</span> (sb_mb == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VERIFY(sb_mb-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP);

	mpt_mbuf = sb_mb;
	<span class="enscript-keyword">while</span> (mpt_mbuf &amp;&amp; mpt_mbuf-&gt;m_pkthdr.mp_rlen == 0) {
		mpt_mbuf = mpt_mbuf-&gt;m_next;
	}
	<span class="enscript-keyword">if</span> (mpt_mbuf &amp;&amp; (mpt_mbuf-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP)) {
		mpt_dsn = mpt_mbuf-&gt;m_pkthdr.mp_dsn;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (MPTCP_SEQ_LT(mpt_dsn, mp_tp-&gt;mpt_snduna)) {
		u_int64_t len = 0;
		len = mp_tp-&gt;mpt_snduna - mpt_dsn;
		MPT_UNLOCK(mp_tp);
		sbdrop(&amp;mp_so-&gt;so_snd, (<span class="enscript-type">int</span>)len);
		MPT_LOCK(mp_tp);
	}

	<span class="enscript-comment">/*
	 * In degraded mode, we don't receive data acks, so force free
	 * mbufs less than snd_nxt
	 */</span>
	<span class="enscript-keyword">if</span> (mp_so-&gt;so_snd.sb_mb == NULL) {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	mpt_dsn = mp_so-&gt;so_snd.sb_mb-&gt;m_pkthdr.mp_dsn;
	<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) &amp;&amp;
	    (mp_tp-&gt;mpt_flags &amp; MPTCPF_POST_FALLBACK_SYNC) &amp;&amp;
	    MPTCP_SEQ_LT(mpt_dsn, mp_tp-&gt;mpt_sndnxt)) {
		u_int64_t len = 0;
		len = mp_tp-&gt;mpt_sndnxt - mpt_dsn;
		sbdrop(&amp;mp_so-&gt;so_snd, (<span class="enscript-type">int</span>)len);
		mp_tp-&gt;mpt_snduna = mp_tp-&gt;mpt_sndnxt;
	}

	<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) &amp;&amp;
	    !(mp_tp-&gt;mpt_flags &amp; MPTCPF_POST_FALLBACK_SYNC)) {
		mp_tp-&gt;mpt_flags |= MPTCPF_POST_FALLBACK_SYNC;
		so-&gt;so_flags1 |= SOF1_POST_FALLBACK_SYNC;
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_RECVD_MPFAIL)
			mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_dsn_at_csum_fail;
	}

	<span class="enscript-comment">/*
	 * Adjust the subflow's notion of next byte to send based on
	 * the last unacknowledged byte
	 */</span>
	<span class="enscript-keyword">if</span> (MPTCP_SEQ_LT(mpts-&gt;mpts_sndnxt, mp_tp-&gt;mpt_snduna)) {
		mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
		<span class="enscript-comment">/*
		 * With FastJoin, a write before the fastjoin event will use
		 * an uninitialized relative sequence number.
		 */</span>
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_rel_seq == 0)
			mpts-&gt;mpts_rel_seq = 1;
	}

	<span class="enscript-comment">/*
	 * Adjust the top level notion of next byte used for retransmissions
	 * and sending FINs.
	 */</span>
	<span class="enscript-keyword">if</span> (MPTCP_SEQ_LT(mp_tp-&gt;mpt_sndnxt, mp_tp-&gt;mpt_snduna)) {
		mp_tp-&gt;mpt_sndnxt = mp_tp-&gt;mpt_snduna;
	}


	<span class="enscript-comment">/* Now determine the offset from which to start transmitting data */</span>
	sb_mb = mp_so-&gt;so_snd.sb_mb;
	sb_cc = mp_so-&gt;so_snd.sb_cc;
	<span class="enscript-keyword">if</span> (sb_mb == NULL) {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (MPTCP_SEQ_LT(mpts-&gt;mpts_sndnxt, mp_tp-&gt;mpt_sndmax)) {
		off = mpts-&gt;mpts_sndnxt - mp_tp-&gt;mpt_snduna;
		sb_cc -= (size_t)off;
	} <span class="enscript-keyword">else</span> {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	MPT_UNLOCK(mp_tp);

	mpt_mbuf = sb_mb;
	mpt_dsn = mpt_mbuf-&gt;m_pkthdr.mp_dsn;

	<span class="enscript-keyword">while</span> (mpt_mbuf &amp;&amp; ((mpt_mbuf-&gt;m_pkthdr.mp_rlen == 0) ||
	    (mpt_mbuf-&gt;m_pkthdr.mp_rlen &lt;= (u_int32_t)off))) {
		off -= mpt_mbuf-&gt;m_pkthdr.mp_rlen;
		mpt_mbuf = mpt_mbuf-&gt;m_next;
		mpt_dsn = mpt_mbuf-&gt;m_pkthdr.mp_dsn;
	}
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED)
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s cid = %d &quot;</span>
		    <span class="enscript-string">&quot;snduna = %llu sndnxt = %llu probe %d\n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid,
		    mp_tp-&gt;mpt_snduna, mpts-&gt;mpts_sndnxt,
		    mpts-&gt;mpts_probecnt),
		    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);

	VERIFY(mpt_mbuf &amp;&amp; (mpt_mbuf-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP));

	head = tail = NULL;

	<span class="enscript-keyword">while</span> (tot_sent &lt; sb_cc) {
		<span class="enscript-type">struct</span> mbuf *m;
		size_t mlen;

		mlen = mpt_mbuf-&gt;m_pkthdr.mp_rlen;
		mlen -= off;
		<span class="enscript-keyword">if</span> (mlen == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> (mlen &gt; sb_cc) {
			panic(<span class="enscript-string">&quot;%s: unexpected %lu %lu \n&quot;</span>, __func__,
			    mlen, sb_cc);
		}

		m = m_copym_mode(mpt_mbuf, (<span class="enscript-type">int</span>)off, mlen, M_DONTWAIT,
		    M_COPYM_MUST_COPY_HDR);
		<span class="enscript-keyword">if</span> (m == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Create a DSN mapping for the data (m_copym does it) */</span>
		mpt_dsn = mpt_mbuf-&gt;m_pkthdr.mp_dsn;
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		m-&gt;m_pkthdr.pkt_flags |= PKTF_MPTCP;
		m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_MPSO;
		m-&gt;m_pkthdr.mp_dsn = mpt_dsn + off;
		m-&gt;m_pkthdr.mp_rseq = mpts-&gt;mpts_rel_seq;
		m-&gt;m_pkthdr.mp_rlen = mlen;
		mpts-&gt;mpts_rel_seq += mlen;
		m-&gt;m_pkthdr.len = mlen;

		<span class="enscript-keyword">if</span> (head == NULL) {
			 head = tail = m;
		} <span class="enscript-keyword">else</span> {
			tail-&gt;m_next = m;
			tail = m;
		}

		tot_sent += mlen;
		off = 0;
		mpt_mbuf = mpt_mbuf-&gt;m_next;
	}

	<span class="enscript-keyword">if</span> (head != NULL) {

		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_FASTJ_SEND) {
			<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(sotoinpcb(so));
			tp-&gt;t_mpflags |= TMPF_FASTJOIN_SEND;
		}

		error = sock_sendmbuf(so, NULL, head, 0, NULL);

		DTRACE_MPTCP7(send, <span class="enscript-type">struct</span> mbuf *, head, <span class="enscript-type">struct</span> socket *, so, 
		    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv,
		    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd,
		    <span class="enscript-type">struct</span> mptses *, mpte, <span class="enscript-type">struct</span> mptsub *, mpts,
		    size_t, tot_sent);
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		mpts-&gt;mpts_sndnxt += tot_sent;

		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_probesoon &amp;&amp; mpts-&gt;mpts_maxseg &amp;&amp; tot_sent) {
			tcpstat.tcps_mp_num_probes++;
			<span class="enscript-keyword">if</span> (tot_sent &lt; mpts-&gt;mpts_maxseg)
				mpts-&gt;mpts_probecnt += 1;
			<span class="enscript-keyword">else</span>
				mpts-&gt;mpts_probecnt +=
				    tot_sent/mpts-&gt;mpts_maxseg;
		}

		MPT_LOCK(mp_tp);

		<span class="enscript-keyword">if</span> (MPTCP_SEQ_LT(mp_tp-&gt;mpt_sndnxt, mpts-&gt;mpts_sndnxt)) {
			<span class="enscript-keyword">if</span> (MPTCP_DATASEQ_HIGH32(mpts-&gt;mpts_sndnxt) &gt;
			    MPTCP_DATASEQ_HIGH32(mp_tp-&gt;mpt_sndnxt))
				mp_tp-&gt;mpt_flags |= MPTCPF_SND_64BITDSN;
			mp_tp-&gt;mpt_sndnxt = mpts-&gt;mpts_sndnxt;
		}
		mptcp_cancel_timer(mp_tp, MPTT_REXMT);
		MPT_UNLOCK(mp_tp);

		<span class="enscript-comment">/* Send once in SYN_SENT state to avoid sending SYN spam */</span>
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_FASTJ_SEND) {
			so-&gt;so_flags &amp;= ~SOF_MPTCP_FASTJOIN;		    
			mpts-&gt;mpts_flags &amp;= ~MPTSF_FASTJ_SEND;
		}

		<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) ||
		    (mpts-&gt;mpts_probesoon != 0))
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s cid %d &quot;</span>
			    <span class="enscript-string">&quot;wrote %d %d probe %d probedelta %d\n&quot;</span>,
			    __func__, mpts-&gt;mpts_connid, (<span class="enscript-type">int</span>)tot_sent,
			    (<span class="enscript-type">int</span>) sb_cc, mpts-&gt;mpts_probecnt,
			    (tcp_now - mpts-&gt;mpts_probesoon)),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
	} <span class="enscript-keyword">else</span> {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Sender: %s cid %d error %d len %zd\n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid, error, tot_sent),
		    MPTCP_SENDER_DBG, MPTCP_LOGLVL_ERR);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Subflow socket control event upcall.
 *
 * Called when the associated subflow socket posted one or more control events.
 * The subflow socket lock has been released prior to invoking the callback.
 * Note that the upcall may occur synchronously as a result of MPTCP performing
 * an action on it, or asynchronously as a result of an event happening at the
 * subflow layer.  Therefore, to maintain lock ordering, the only lock that can
 * be acquired here is the thread lock, for signalling purposes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_eupcall</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">void</span> *arg, uint32_t events)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>)
	<span class="enscript-type">struct</span> mptsub *mpts = arg;
	<span class="enscript-type">struct</span> mptses *mpte = mpts-&gt;mpts_mpte;

	VERIFY(mpte != NULL);

	lck_mtx_lock(&amp;mpte-&gt;mpte_thread_lock);
	atomic_bitset_32(&amp;mpts-&gt;mpts_evctl, events);
	mptcp_thread_signal_locked(mpte);
	lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
}

<span class="enscript-comment">/*
 * Subflow socket control events.
 *
 * Called for handling events related to the underlying subflow socket.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_events</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	uint32_t events, save_events;
	ev_ret_t ret = MPTS_EVRET_OK;
	<span class="enscript-type">int</span> i = 0;
	<span class="enscript-type">int</span> mpsub_ev_entry_count = <span class="enscript-keyword">sizeof</span>(mpsub_ev_entry_tbl)/
		<span class="enscript-keyword">sizeof</span>(mpsub_ev_entry_tbl[0]);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	<span class="enscript-comment">/* bail if there's nothing to process */</span>
	<span class="enscript-keyword">if</span> ((events = mpts-&gt;mpts_evctl) == 0)
		<span class="enscript-keyword">return</span> (ret);

	<span class="enscript-keyword">if</span> (events &amp; (SO_FILT_HINT_CONNRESET|SO_FILT_HINT_MUSTRST|
	    SO_FILT_HINT_CANTRCVMORE|SO_FILT_HINT_CANTSENDMORE|
	    SO_FILT_HINT_TIMEOUT|SO_FILT_HINT_NOSRCADDR|
	    SO_FILT_HINT_IFDENIED|SO_FILT_HINT_SUSPEND|
	    SO_FILT_HINT_DISCONNECTED)) {
		events |= SO_FILT_HINT_MPFAILOVER;
	}

	save_events = events;

	DTRACE_MPTCP3(subflow__events, <span class="enscript-type">struct</span> mptses *, mpte,
	    <span class="enscript-type">struct</span> mptsub *, mpts, uint32_t, events);

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: %s cid %d events=%b\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, events, SO_FILT_HINT_BITS),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_VERBOSE);

	<span class="enscript-comment">/*
	 * Process all the socket filter hints and reset the hint
	 * once it is handled
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; (i &lt; mpsub_ev_entry_count) &amp;&amp; events; i++) {
		<span class="enscript-keyword">if</span> ((events &amp; mpsub_ev_entry_tbl[i].sofilt_hint_mask) &amp;&amp;
		    (ret &gt;= MPTS_EVRET_OK)) {
			ev_ret_t error =
				mpsub_ev_entry_tbl[i].sofilt_hint_ev_hdlr(mpte, mpts, p_mpsofilt_hint);
			events &amp;= ~mpsub_ev_entry_tbl[i].sofilt_hint_mask;
			ret = ((error &gt;= MPTS_EVRET_OK) ? MAX(error, ret) : error);
		}
	}

	<span class="enscript-comment">/*
	 * We should be getting only events specified via sock_catchevents(),
	 * so loudly complain if we have any unprocessed one(s).
	 */</span>
	<span class="enscript-keyword">if</span> (events != 0 || ret &lt; MPTS_EVRET_OK) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Events %s%s: cid %d evret %s (%d)&quot;</span>
		    <span class="enscript-string">&quot; unhandled events=%b\n&quot;</span>,
		    (events != 0) &amp;&amp; (ret == MPTS_EVRET_OK) ? <span class="enscript-string">&quot;MPTCP_ERROR &quot;</span> : <span class="enscript-string">&quot;&quot;</span>, 
		    __func__, mpts-&gt;mpts_connid,
		    mptcp_evret2str(ret), ret, events, SO_FILT_HINT_BITS),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);
	}

	<span class="enscript-comment">/* clear the ones we've processed */</span>
	atomic_bitclear_32(&amp;mpts-&gt;mpts_evctl, save_events);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_CONNRESET subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_connreset_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d [linger %s]\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (linger ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-comment">/*
	 * We got a TCP RST for this subflow connection.
	 *
	 * Right now, we simply propagate ECONNREFUSED to the MPTCP socket
	 * client if the MPTCP connection has not been established or
	 * if the connection has only one subflow and is a connection being
	 * resumed. Otherwise we close the socket.
	 */</span>
	mptcp_subflow_disconnect(mpte, mpts, !linger);

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		mpts-&gt;mpts_soerror = mp_so-&gt;so_error = ECONNREFUSED;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mpte-&gt;mpte_nummpcapflows &lt; 1) {
		mpts-&gt;mpts_soerror = mp_so-&gt;so_error = ECONNRESET;
		*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNRESET;
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/*
	 * Keep the subflow socket around, unless the MPTCP socket has
	 * been detached or the subflow has been disconnected explicitly,
	 * in which case it should be deleted right away.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_CANTRCVMORE subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_cantrcvmore_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	so = mpts-&gt;mpts_socket;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d\n&quot;</span>, __func__, mpts-&gt;mpts_connid),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-comment">/*
	 * We got a FIN for this subflow connection.  This subflow socket
	 * is no longer available for receiving data;
	 * The FIN may arrive with data. The data is handed up to the
	 * mptcp socket and the subflow is disconnected.
	 */</span>

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);	<span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_CANTSENDMORE subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_cantsendmore_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	so = mpts-&gt;mpts_socket;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d\n&quot;</span>, __func__, mpts-&gt;mpts_connid),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);	<span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_TIMEOUT subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_timeout_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	mptcplog((LOG_NOTICE, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d [linger %s]\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (linger ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_soerror == 0)
		mpts-&gt;mpts_soerror = ETIMEDOUT;

	<span class="enscript-comment">/*
	 * The subflow connection has timed out.
	 *
	 * Right now, we simply propagate ETIMEDOUT to the MPTCP socket
	 * client if the MPTCP connection has not been established. Otherwise
	 * drop it.
	 */</span>
	mptcp_subflow_disconnect(mpte, mpts, !linger);

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		mp_so-&gt;so_error = ETIMEDOUT;
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/*
	 * Keep the subflow socket around, unless the MPTCP socket has
	 * been detached or the subflow has been disconnected explicitly,
	 * in which case it should be deleted right away.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_NOSRCADDR subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_nosrcaddr_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	<span class="enscript-comment">/* Not grabbing socket lock as t_local_aid is write once only */</span>
	tp = intotcpcb(sotoinpcb(so));
	<span class="enscript-comment">/*
	 * This overwrites any previous mpte_lost_aid to avoid storing
	 * too much state when the typical case has only two subflows.
	 */</span>
	mpte-&gt;mpte_flags |= MPTE_SND_REM_ADDR;
	mpte-&gt;mpte_lost_aid = tp-&gt;t_local_aid;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s cid %d [linger %s]\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (linger ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_soerror == 0)
		mpts-&gt;mpts_soerror = EADDRNOTAVAIL;

	<span class="enscript-comment">/*
	 * The subflow connection has lost its source address.
	 *
	 * Right now, we simply propagate EADDRNOTAVAIL to the MPTCP socket
	 * client if the MPTCP connection has not been established.  If it
	 * has been established with one subflow , we keep the MPTCP
	 * connection valid without any subflows till closed by application.
	 * This lets tcp connection manager decide whether to close this or
	 * not as it reacts to reachability changes too.
	 */</span>
	mptcp_subflow_disconnect(mpte, mpts, !linger);

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> ((mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) &amp;&amp;
	    (mp_so-&gt;so_flags &amp; SOF_NOADDRAVAIL)) {
		mp_so-&gt;so_error = EADDRNOTAVAIL;
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/*
	 * Keep the subflow socket around, unless the MPTCP socket has
	 * been detached or the subflow has been disconnected explicitly,
	 * in which case it should be deleted right away.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_MPCANTRCVMORE subflow socket event that
 * indicates that the remote side sent a Data FIN
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_mpcantrcvmore_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *so, *mp_so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;

	MPTE_LOCK_ASSERT_HELD(mpte);    <span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	so = mpts-&gt;mpts_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d\n&quot;</span>, __func__, mpts-&gt;mpts_connid),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
	
	<span class="enscript-comment">/*
	* We got a Data FIN for the MPTCP connection.  
	* The FIN may arrive with data. The data is handed up to the
	* mptcp socket and the user is notified so that it may close
	* the socket if needed.
	*/</span>
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state == MPTCPS_CLOSE_WAIT) {
		*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_CANTRCVMORE;
	}
	MPT_UNLOCK(mp_tp);
	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK); <span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_MPFAILOVER subflow socket event
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_failover_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> mptsub *mpts_alt = NULL;
	<span class="enscript-type">struct</span> socket *so = NULL;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">int</span> altpath_exists = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);    <span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mptcplog((LOG_NOTICE, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: mp_so 0x%llx\n&quot;</span>, __func__,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	MPTS_UNLOCK(mpts);
	mpts_alt = mptcp_get_subflow(mpte, mpts, NULL);

	<span class="enscript-comment">/*
	 * If there is no alternate eligible subflow, ignore the
	 * failover hint.
	 */</span>
	<span class="enscript-keyword">if</span> (mpts_alt == NULL) {
		mptcplog((LOG_WARNING, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
		    <span class="enscript-string">&quot;%s: no alternate path\n&quot;</span>, __func__),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);

		<span class="enscript-keyword">if</span> (mptcp_delayed_subf_start) {
			mpts_alt = mptcp_get_pending_subflow(mpte, mpts);
			<span class="enscript-keyword">if</span> (mpts_alt != NULL) {
				MPTS_LOCK(mpts_alt);
				(<span class="enscript-type">void</span>) mptcp_subflow_soconnectx(mpte,
				    mpts_alt);
				MPTS_UNLOCK(mpts_alt);	
			}
		}
		MPTS_LOCK(mpts);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	MPTS_LOCK(mpts_alt);
	altpath_exists = 1;
	so = mpts_alt-&gt;mpts_socket;
	<span class="enscript-keyword">if</span> (mpts_alt-&gt;mpts_flags &amp; MPTSF_FAILINGOVER) {
		socket_lock(so, 1);
		<span class="enscript-comment">/* All data acknowledged and no RTT spike */</span>
		<span class="enscript-keyword">if</span> ((so-&gt;so_snd.sb_cc == 0) &amp;&amp;
		    (mptcp_no_rto_spike(so))) {
			so-&gt;so_flags &amp;= ~SOF_MP_TRYFAILOVER;
			mpts_alt-&gt;mpts_flags &amp;= ~MPTSF_FAILINGOVER;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* no alternate path available */</span>
			altpath_exists = 0;
		}
		socket_unlock(so, 1);
	}
	<span class="enscript-keyword">if</span> (altpath_exists) {
		mptcplog((LOG_INFO, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
		    <span class="enscript-string">&quot;%s: cid = %d\n&quot;</span>,
		    __func__, mpts_alt-&gt;mpts_connid),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
		mpts_alt-&gt;mpts_flags |= MPTSF_ACTIVE;
		mpts_alt-&gt;mpts_peerswitch = 0;
		<span class="enscript-type">struct</span> mptcb *mp_tp = mpte-&gt;mpte_mptcb;
		<span class="enscript-comment">/* Bring the subflow's notion of snd_nxt into the send window */</span>
		MPT_LOCK(mp_tp);
		mpts_alt-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
		MPT_UNLOCK(mp_tp);
		mpte-&gt;mpte_active_sub = mpts_alt;
		socket_lock(so, 1);
		sowwakeup(so);
		socket_unlock(so, 1);
	}
	MPTS_UNLOCK(mpts_alt);

	<span class="enscript-keyword">if</span> (altpath_exists) {
		*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNINFO_UPDATED;
		mptcplog((LOG_NOTICE, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx switched from &quot;</span>
		    <span class="enscript-string">&quot;%d to %d\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mpts-&gt;mpts_connid, mpts_alt-&gt;mpts_connid),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
		tcpstat.tcps_mp_switches++;
	}

	MPTS_LOCK(mpts);
	<span class="enscript-keyword">if</span> (altpath_exists) {
		mpts-&gt;mpts_flags |= MPTSF_FAILINGOVER;
		mpts-&gt;mpts_flags &amp;= ~MPTSF_ACTIVE;
	} <span class="enscript-keyword">else</span> {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events %s: no alt cid = %d\n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
<span class="enscript-reference">done</span>:
		so = mpts-&gt;mpts_socket;
		socket_lock(so, 1);
		so-&gt;so_flags &amp;= ~SOF_MP_TRYFAILOVER;
		socket_unlock(so, 1);
	}
	MPTS_LOCK_ASSERT_HELD(mpts);
	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_IFDENIED subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_ifdenied_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d [linger %s]\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (linger ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_soerror == 0)
		mpts-&gt;mpts_soerror = EHOSTUNREACH;

	<span class="enscript-comment">/*
	 * The subflow connection cannot use the outgoing interface.
	 *
	 * Right now, we simply propagate EHOSTUNREACH to the MPTCP socket
	 * client if the MPTCP connection has not been established.  If it
	 * has been established, let the upper layer call disconnectx.
	 */</span>
	mptcp_subflow_disconnect(mpte, mpts, !linger);
	*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_IFDENIED;

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		mp_so-&gt;so_error = EHOSTUNREACH;
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/*
	 * Keep the subflow socket around, unless the MPTCP socket has
	 * been detached or the subflow has been disconnected explicitly,
	 * in which case it should be deleted right away.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_SUSPEND subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_suspend_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	so = mpts-&gt;mpts_socket;

	<span class="enscript-comment">/* the subflow connection is being flow controlled */</span>
	mpts-&gt;mpts_flags |= MPTSF_SUSPENDED;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid), MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);	<span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_RESUME subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_resume_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	<span class="enscript-type">struct</span> socket *so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);

	so = mpts-&gt;mpts_socket;

	<span class="enscript-comment">/* the subflow connection is no longer flow controlled */</span>
	mpts-&gt;mpts_flags &amp;= ~MPTSF_SUSPENDED;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d\n&quot;</span>, __func__, mpts-&gt;mpts_connid),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);	<span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_CONNECTED subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_connected_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">char</span> buf0[MAX_IPv6_STR_LEN], buf1[MAX_IPv6_STR_LEN];
	<span class="enscript-type">struct</span> sockaddr_entry *src_se, *dst_se;
	<span class="enscript-type">struct</span> sockaddr_storage src;
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">struct</span> ifnet *outifp;
	<span class="enscript-type">int</span> af, error = 0;
	boolean_t mpok = FALSE;
	boolean_t cell = FALSE;
	boolean_t wifi = FALSE;
	boolean_t wired = FALSE;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	MPTS_LOCK_ASSERT_HELD(mpts);
	so = mpts-&gt;mpts_socket;
	af = mpts-&gt;mpts_family;

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_CONNECTED)
		<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);

	<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTED) ||
	    (mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTING)) {
        	socket_lock(so, 0);
		<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; (SS_ISDISCONNECTING | SS_ISDISCONNECTED)) &amp;&amp;
		    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
		    mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
		        <span class="enscript-string">&quot;%s: cid %d disconnect before tcp connect\n&quot;</span>,
		        __func__, mpts-&gt;mpts_connid),
			MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
			(<span class="enscript-type">void</span>) soshutdownlock(so, SHUT_RD);
			(<span class="enscript-type">void</span>) soshutdownlock(so, SHUT_WR);
			(<span class="enscript-type">void</span>) sodisconnectlocked(so);
		}
		socket_unlock(so, 0);
		<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);
	}

	<span class="enscript-comment">/*
	 * The subflow connection has been connected.  Find out whether it
	 * is connected as a regular TCP or as a MPTCP subflow.  The idea is:
	 *
	 *   a. If MPTCP connection is not yet established, then this must be
	 *	the first subflow connection.  If MPTCP failed to negotiate,
	 *	indicate to the MPTCP socket client via EPROTO, that the
	 *	underlying TCP connection may be peeled off via peeloff(2).
	 *	Otherwise, mark the MPTCP socket as connected.
	 *
	 *   b. If MPTCP connection has been established, then this must be
	 *	one of the subsequent subflow connections. If MPTCP failed
	 *	to negotiate, disconnect the connection since peeloff(2)
	 *	is no longer possible.
	 *
	 * Right now, we simply unblock any waiters at the MPTCP socket layer
	 * if the MPTCP connection has not been established.
	 */</span>
	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISDISCONNECTED) {
		<span class="enscript-comment">/*
		 * With MPTCP joins, a connection is connected at the subflow
		 * level, but the 4th ACK from the server elevates the MPTCP
		 * subflow to connected state. So there is a small window 
		 * where the subflow could get disconnected before the 
		 * connected event is processed.
		 */</span>
		socket_unlock(so, 0);
		<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);
	}

	mpts-&gt;mpts_soerror = 0;
	mpts-&gt;mpts_flags &amp;= ~MPTSF_CONNECTING;
	mpts-&gt;mpts_flags |= MPTSF_CONNECTED;
	<span class="enscript-keyword">if</span> (sototcpcb(so)-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)
		mpts-&gt;mpts_flags |= MPTSF_MP_CAPABLE;

	VERIFY(mpts-&gt;mpts_dst_sl != NULL);
	dst_se = TAILQ_FIRST(&amp;mpts-&gt;mpts_dst_sl-&gt;sl_head);
	VERIFY(dst_se != NULL &amp;&amp; dst_se-&gt;se_addr != NULL &amp;&amp;
	    dst_se-&gt;se_addr-&gt;sa_family == af);

	VERIFY(mpts-&gt;mpts_src_sl != NULL);
	src_se = TAILQ_FIRST(&amp;mpts-&gt;mpts_src_sl-&gt;sl_head);
	VERIFY(src_se != NULL &amp;&amp; src_se-&gt;se_addr != NULL &amp;&amp;
	    src_se-&gt;se_addr-&gt;sa_family == af);

	<span class="enscript-comment">/* get/check source IP address */</span>
	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		error = in_getsockaddr_s(so, &amp;src);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-type">struct</span> sockaddr_in *ms = SIN(src_se-&gt;se_addr);
			<span class="enscript-type">struct</span> sockaddr_in *s = SIN(&amp;src);

			VERIFY(s-&gt;sin_len == ms-&gt;sin_len);
			VERIFY(ms-&gt;sin_family == AF_INET);

			<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_BOUND_IP) &amp;&amp;
			    bcmp(&amp;ms-&gt;sin_addr, &amp;s-&gt;sin_addr,
			    <span class="enscript-keyword">sizeof</span> (ms-&gt;sin_addr)) != 0) {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
				    <span class="enscript-string">&quot;%s: cid %d local &quot;</span>
				    <span class="enscript-string">&quot;address %s (expected %s)\n&quot;</span>, __func__,
				    mpts-&gt;mpts_connid, inet_ntop(AF_INET,
				    (<span class="enscript-type">void</span> *)&amp;s-&gt;sin_addr.s_addr, buf0,
				    <span class="enscript-keyword">sizeof</span> (buf0)), inet_ntop(AF_INET,
				    (<span class="enscript-type">void</span> *)&amp;ms-&gt;sin_addr.s_addr, buf1,
				    <span class="enscript-keyword">sizeof</span> (buf1))),
				    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);
			}
			bcopy(s, ms, <span class="enscript-keyword">sizeof</span> (*s));
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		error = in6_getsockaddr_s(so, &amp;src);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-type">struct</span> sockaddr_in6 *ms = SIN6(src_se-&gt;se_addr);
			<span class="enscript-type">struct</span> sockaddr_in6 *s = SIN6(&amp;src);

			VERIFY(s-&gt;sin6_len == ms-&gt;sin6_len);
			VERIFY(ms-&gt;sin6_family == AF_INET6);

			<span class="enscript-keyword">if</span> ((mpts-&gt;mpts_flags &amp; MPTSF_BOUND_IP) &amp;&amp;
			    bcmp(&amp;ms-&gt;sin6_addr, &amp;s-&gt;sin6_addr,
			    <span class="enscript-keyword">sizeof</span> (ms-&gt;sin6_addr)) != 0) {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
				    <span class="enscript-string">&quot;%s: cid %d local &quot;</span>
				    <span class="enscript-string">&quot;address %s (expected %s)\n&quot;</span>, __func__,
				    mpts-&gt;mpts_connid, inet_ntop(AF_INET6,
				    (<span class="enscript-type">void</span> *)&amp;s-&gt;sin6_addr, buf0,
				    <span class="enscript-keyword">sizeof</span> (buf0)), inet_ntop(AF_INET6,
				    (<span class="enscript-type">void</span> *)&amp;ms-&gt;sin6_addr, buf1,
				    <span class="enscript-keyword">sizeof</span> (buf1))),
				    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);
			}
			bcopy(s, ms, <span class="enscript-keyword">sizeof</span> (*s));
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (error != 0) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Events &quot;</span>
		    <span class="enscript-string">&quot;%s: cid %d getsockaddr failed (%d)\n&quot;</span>,
		    __func__, mpts-&gt;mpts_connid, error),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);
	}

	<span class="enscript-comment">/* get/verify the outbound interface */</span>
	outifp = sotoinpcb(so)-&gt;inp_last_outifp;	<span class="enscript-comment">/* could be NULL */</span>
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_BOUND_IF) {
		VERIFY(mpts-&gt;mpts_outif != NULL);
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_outif != outifp) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Events: %s: cid %d outif %s &quot;</span>
			    <span class="enscript-string">&quot;(expected %s)\n&quot;</span>, __func__, mpts-&gt;mpts_connid,
			    ((outifp != NULL) ? outifp-&gt;if_xname : <span class="enscript-string">&quot;NULL&quot;</span>),
			    mpts-&gt;mpts_outif-&gt;if_xname),
			    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_ERR);

			<span class="enscript-keyword">if</span> (outifp == NULL)
				outifp = mpts-&gt;mpts_outif;
		}
	} <span class="enscript-keyword">else</span> {
		mpts-&gt;mpts_outif = outifp;
	}

	mpts-&gt;mpts_srtt = (intotcpcb(sotoinpcb(so)))-&gt;t_srtt;
	mpts-&gt;mpts_rxtcur = (intotcpcb(sotoinpcb(so)))-&gt;t_rxtcur;
	mpts-&gt;mpts_maxseg = (intotcpcb(sotoinpcb(so)))-&gt;t_maxseg;

	cell = IFNET_IS_CELLULAR(mpts-&gt;mpts_outif);
	wifi = (!cell &amp;&amp; IFNET_IS_WIFI(mpts-&gt;mpts_outif));
	wired = (!wifi &amp;&amp; IFNET_IS_WIRED(mpts-&gt;mpts_outif));

	<span class="enscript-keyword">if</span> (cell)
		mpts-&gt;mpts_linktype |= MPTSL_CELL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wifi)
		mpts-&gt;mpts_linktype |= MPTSL_WIFI;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wired)
		mpts-&gt;mpts_linktype |= MPTSL_WIRED;

	socket_unlock(so, 0);

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s: cid %d &quot;</span>
	    <span class="enscript-string">&quot;establishment srtt %d \n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (mpts-&gt;mpts_srtt &gt;&gt; 5)),
	    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);


	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d outif %s %s[%d] -&gt; %s[%d] &quot;</span>
	    <span class="enscript-string">&quot;is %s\n&quot;</span>, __func__, mpts-&gt;mpts_connid, ((outifp != NULL) ?
	    outifp-&gt;if_xname : <span class="enscript-string">&quot;NULL&quot;</span>), inet_ntop(af, (af == AF_INET) ?
	    (<span class="enscript-type">void</span> *)&amp;SIN(src_se-&gt;se_addr)-&gt;sin_addr.s_addr :
	    (<span class="enscript-type">void</span> *)&amp;SIN6(src_se-&gt;se_addr)-&gt;sin6_addr, buf0, <span class="enscript-keyword">sizeof</span> (buf0)),
	    ((af == AF_INET) ? ntohs(SIN(src_se-&gt;se_addr)-&gt;sin_port) :
	    ntohs(SIN6(src_se-&gt;se_addr)-&gt;sin6_port)),
	    inet_ntop(af, ((af == AF_INET) ?
	    (<span class="enscript-type">void</span> *)&amp;SIN(dst_se-&gt;se_addr)-&gt;sin_addr.s_addr :
	    (<span class="enscript-type">void</span> *)&amp;SIN6(dst_se-&gt;se_addr)-&gt;sin6_addr), buf1, <span class="enscript-keyword">sizeof</span> (buf1)),
	    ((af == AF_INET) ? ntohs(SIN(dst_se-&gt;se_addr)-&gt;sin_port) :
	    ntohs(SIN6(dst_se-&gt;se_addr)-&gt;sin6_port)),
	    ((mpts-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE) ?
	    <span class="enscript-string">&quot;MPTCP capable&quot;</span> : <span class="enscript-string">&quot;a regular TCP&quot;</span>)),
	    (MPTCP_SOCKET_DBG | MPTCP_EVENTS_DBG), MPTCP_LOGLVL_LOG);

	mpok = (mpts-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE);
	MPTS_UNLOCK(mpts);

	*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNINFO_UPDATED;

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		<span class="enscript-comment">/* case (a) above */</span>
		<span class="enscript-keyword">if</span> (!mpok) {
			mp_tp-&gt;mpt_flags |= MPTCPF_PEEL_OFF;
			(<span class="enscript-type">void</span>) mptcp_drop(mpte, mp_tp, EPROTO);
			MPT_UNLOCK(mp_tp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (mptcp_init_authparms(mp_tp) != 0) {
				mp_tp-&gt;mpt_flags |= MPTCPF_PEEL_OFF;
				(<span class="enscript-type">void</span>) mptcp_drop(mpte, mp_tp, EPROTO);
				MPT_UNLOCK(mp_tp);
				mpok = FALSE;
			} <span class="enscript-keyword">else</span> {
				mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP State: &quot;</span>
				    <span class="enscript-string">&quot;MPTCPS_ESTABLISHED for mp_so 0x%llx \n&quot;</span>,
				    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so)),
				    MPTCP_STATE_DBG, MPTCP_LOGLVL_LOG);
				mp_tp-&gt;mpt_state = MPTCPS_ESTABLISHED;
				mpte-&gt;mpte_associd = mpts-&gt;mpts_connid;
				DTRACE_MPTCP2(state__change, 
				    <span class="enscript-type">struct</span> mptcb *, mp_tp, 
				    uint32_t, 0 <span class="enscript-comment">/* event */</span>);
				mptcp_init_statevars(mp_tp);
				MPT_UNLOCK(mp_tp);

				(<span class="enscript-type">void</span>) mptcp_setconnorder(mpte,
				    mpts-&gt;mpts_connid, 1);
				soisconnected(mp_so);
			}
		}
		MPTS_LOCK(mpts);
		<span class="enscript-keyword">if</span> (mpok) {
			<span class="enscript-comment">/* Initialize the relative sequence number */</span>
			mpts-&gt;mpts_rel_seq = 1;
			mpts-&gt;mpts_flags |= MPTSF_MPCAP_CTRSET;
			mpte-&gt;mpte_nummpcapflows++;
			MPT_LOCK_SPIN(mp_tp);
			mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
			MPT_UNLOCK(mp_tp);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mpok) {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">if</span> (mptcp_rwnotify &amp;&amp; (mpte-&gt;mpte_nummpcapflows == 0)) {
			<span class="enscript-comment">/* Experimental code, disabled by default. */</span>
			sorwakeup(mp_so);
			sowwakeup(mp_so);
		}
		<span class="enscript-comment">/*
		 * case (b) above
		 * In case of additional flows, the MPTCP socket is not
		 * MPTSF_MP_CAPABLE until an ACK is received from server
		 * for 3-way handshake.  TCP would have guaranteed that this
		 * is an MPTCP subflow.
		 */</span>
		MPTS_LOCK(mpts);
		mpts-&gt;mpts_flags |= MPTSF_MPCAP_CTRSET;
		mpts-&gt;mpts_flags &amp;= ~MPTSF_FASTJ_REQD;
		mpte-&gt;mpte_nummpcapflows++;
		<span class="enscript-comment">/* With Fastjoin, rel sequence will be nonzero */</span>
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_rel_seq == 0)
			mpts-&gt;mpts_rel_seq = 1;
		MPT_LOCK_SPIN(mp_tp);
		<span class="enscript-comment">/* With Fastjoin, sndnxt is updated before connected_ev */</span>
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_sndnxt == 0) {
			mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
		} 
		MPT_UNLOCK(mp_tp);
		mptcp_output_needed(mpte, mpts);
	} <span class="enscript-keyword">else</span> {
		MPT_UNLOCK(mp_tp);
		MPTS_LOCK(mpts);
	}

	MPTS_LOCK_ASSERT_HELD(mpts);

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);	<span class="enscript-comment">/* keep the subflow socket around */</span>
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_DISCONNECTED subflow socket event.
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_disconnected_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d [linger %s]\n&quot;</span>, __func__,
	    mpts-&gt;mpts_connid, (linger ? <span class="enscript-string">&quot;YES&quot;</span> : <span class="enscript-string">&quot;NO&quot;</span>)),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTED)
		<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);

	<span class="enscript-comment">/*
	 * Clear flags that are used by getconninfo to return state.
	 * Retain like MPTSF_DELETEOK for internal purposes.
	 */</span>
	mpts-&gt;mpts_flags &amp;= ~(MPTSF_CONNECTING|MPTSF_CONNECT_PENDING|
	    MPTSF_CONNECTED|MPTSF_DISCONNECTING|MPTSF_PREFERRED|
	    MPTSF_MP_CAPABLE|MPTSF_MP_READY|MPTSF_MP_DEGRADED|
	    MPTSF_SUSPENDED|MPTSF_ACTIVE);
	mpts-&gt;mpts_flags |= MPTSF_DISCONNECTED;

	<span class="enscript-comment">/*
	 * The subflow connection has been disconnected.
	 *
	 * Right now, we simply unblock any waiters at the MPTCP socket layer
	 * if the MPTCP connection has not been established.
	 */</span>
	*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNINFO_UPDATED;

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MPCAP_CTRSET) {
		mpte-&gt;mpte_nummpcapflows--;
		<span class="enscript-keyword">if</span> (mpte-&gt;mpte_active_sub == mpts) {
			mpte-&gt;mpte_active_sub = NULL;
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
			    <span class="enscript-string">&quot;%s: resetting active subflow \n&quot;</span>,
			    __func__), MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
		}
		mpts-&gt;mpts_flags &amp;= ~MPTSF_MPCAP_CTRSET;
	}

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		MPT_UNLOCK(mp_tp);
		MPTS_UNLOCK(mpts);
		soisdisconnected(mp_so);
		MPTS_LOCK(mpts);
	} <span class="enscript-keyword">else</span> {
		MPT_UNLOCK(mp_tp);
	}

	<span class="enscript-comment">/*
	 * The underlying subflow socket has been disconnected;
	 * it is no longer useful to us.  Keep the subflow socket
	 * around, unless the MPTCP socket has been detached or
	 * the subflow has been disconnected explicitly, in which
	 * case it should be deleted right away.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_MPSTATUS subflow socket event
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_mpstatus_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
		uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	ev_ret_t ret = MPTS_EVRET_OK;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	MPTS_LOCK_ASSERT_HELD(mpts);
	so = mpts-&gt;mpts_socket;

	socket_lock(so, 0);
	MPT_LOCK(mp_tp);

	<span class="enscript-keyword">if</span> (sototcpcb(so)-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)
		mpts-&gt;mpts_flags |= MPTSF_MP_CAPABLE;
	<span class="enscript-keyword">else</span>
		mpts-&gt;mpts_flags &amp;= ~MPTSF_MP_CAPABLE;

	<span class="enscript-keyword">if</span> (sototcpcb(so)-&gt;t_mpflags &amp; TMPF_TCP_FALLBACK) {
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		mpts-&gt;mpts_flags |= MPTSF_MP_DEGRADED;
	}
	<span class="enscript-keyword">else</span>
		mpts-&gt;mpts_flags &amp;= ~MPTSF_MP_DEGRADED;

	<span class="enscript-keyword">if</span> (sototcpcb(so)-&gt;t_mpflags &amp; TMPF_MPTCP_READY)
		mpts-&gt;mpts_flags |= MPTSF_MP_READY;
	<span class="enscript-keyword">else</span>
		mpts-&gt;mpts_flags &amp;= ~MPTSF_MP_READY;

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) {
		mp_tp-&gt;mpt_flags |= MPTCPF_FALLBACK_TO_TCP;
		mp_tp-&gt;mpt_flags &amp;= ~MPTCPF_JOIN_READY;
	}

	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_FALLBACK_TO_TCP) {
		VERIFY(!(mp_tp-&gt;mpt_flags &amp; MPTCPF_JOIN_READY));
		ret = MPTS_EVRET_DISCONNECT_FALLBACK;
		*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED |
			SO_FILT_HINT_CONNINFO_UPDATED;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_READY) {
		mp_tp-&gt;mpt_flags |= MPTCPF_JOIN_READY;
		ret = MPTS_EVRET_CONNECT_PENDING;
	} <span class="enscript-keyword">else</span> {
		*p_mpsofilt_hint |= SO_FILT_HINT_LOCKED |
			SO_FILT_HINT_CONNINFO_UPDATED;
	}

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s: mp_so 0x%llx mpt_flags=%b cid %d &quot;</span>
	    <span class="enscript-string">&quot;mptsf=%b\n&quot;</span>, __func__,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mpte-&gt;mpte_mppcb-&gt;mpp_socket),
	    mp_tp-&gt;mpt_flags, MPTCPF_BITS, mpts-&gt;mpts_connid,
	    mpts-&gt;mpts_flags, MPTSF_BITS),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

<span class="enscript-reference">done</span>:
	MPT_UNLOCK(mp_tp);
	socket_unlock(so, 0);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * Handle SO_FILT_HINT_MUSTRST subflow socket event
 */</span>
<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_subflow_mustrst_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
	<span class="enscript-type">struct</span> socket *mp_so, *so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	boolean_t linger;


	MPTE_LOCK_ASSERT_HELD(mpte);    <span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;
	so = mpts-&gt;mpts_socket;

	linger = (!(mpts-&gt;mpts_flags &amp; MPTSF_DELETEOK) &amp;&amp;
	    !(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING));

	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_soerror == 0)
		mpts-&gt;mpts_soerror = ECONNABORTED;

	<span class="enscript-comment">/* We got an invalid option or a fast close */</span>
	socket_lock(so, 0);
	<span class="enscript-type">struct</span> tcptemp *t_template;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	tp = intotcpcb(inp);
	so-&gt;so_error = ECONNABORTED;

	t_template = tcp_maketemplate(tp);
	<span class="enscript-keyword">if</span> (t_template) {
		<span class="enscript-type">struct</span> tcp_respond_args tra;

		bzero(&amp;tra, <span class="enscript-keyword">sizeof</span>(tra));
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_BOUND_IF)
			tra.ifscope = inp-&gt;inp_boundifp-&gt;if_index;
		<span class="enscript-keyword">else</span>
			tra.ifscope = IFSCOPE_NONE;
		tra.awdl_unrestricted = 1;

		tcp_respond(tp, t_template-&gt;tt_ipgen,
		    &amp;t_template-&gt;tt_t, (<span class="enscript-type">struct</span> mbuf *)NULL,
		    tp-&gt;rcv_nxt, tp-&gt;snd_una, TH_RST, &amp;tra);
		(<span class="enscript-type">void</span>) m_free(dtom(t_template));
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx cid %d \n&quot;</span>,
		    __func__, (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    so, mpts-&gt;mpts_connid),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
	}
	socket_unlock(so, 0);
	mptcp_subflow_disconnect(mpte, mpts, !linger);

	*p_mpsofilt_hint |=  (SO_FILT_HINT_LOCKED | SO_FILT_HINT_CONNINFO_UPDATED);

	<span class="enscript-keyword">if</span> (!(mp_tp-&gt;mpt_flags &amp; MPTCPF_FALLBACK_TO_TCP))
		*p_mpsofilt_hint |= SO_FILT_HINT_CONNRESET;

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> ((mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) ||
	    (mp_tp-&gt;mpt_state == MPTCPS_FASTCLOSE_WAIT)) {
		mp_so-&gt;so_error = ECONNABORTED;
	}
	<span class="enscript-comment">/*
	 * Ideally there should be a state transition for when a FASTCLOSE
	 * is received. Right now we keep the connection in MPTCPS_ESTABLISHED
	 * state and only go to terminal state when the user level code calls
	 * close after processing the SO_FILT_HINT_CONNRESET event.
	 */</span>
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_gc_ticks == MPT_GC_TICKS)
		mp_tp-&gt;mpt_gc_ticks = MPT_GC_TICKS_FAST;
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/*
	 * Keep the subflow socket around unless the subflow has been
	 * disconnected explicitly.
	 */</span>
	<span class="enscript-keyword">return</span> (linger ? MPTS_EVRET_OK : MPTS_EVRET_DELETE);
}

<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_fastjoin_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	MPTE_LOCK_ASSERT_HELD(mpte);    <span class="enscript-comment">/* same as MP socket lock */</span>
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_nummpcapflows == 0) {
		<span class="enscript-type">struct</span> mptcb *mp_tp = mpte-&gt;mpte_mptcb;
		mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Events: %s: %llx %llx \n&quot;</span>,
		    __func__, mp_tp-&gt;mpt_snduna, mpts-&gt;mpts_sndnxt),
		    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

		mpte-&gt;mpte_active_sub = mpts;
		mpts-&gt;mpts_flags |= (MPTSF_FASTJ_SEND | MPTSF_ACTIVE);
		MPT_LOCK(mp_tp);
		<span class="enscript-comment">/*
		 * If mptcp_subflow_output is called before fastjoin_ev
		 * then mpts-&gt;mpts_sndnxt is initialized to mp_tp-&gt;mpt_snduna
		 * and further mpts-&gt;mpts_sndnxt is incremented by len copied.
		 */</span>
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_sndnxt == 0) {
			mpts-&gt;mpts_sndnxt = mp_tp-&gt;mpt_snduna;
			mpts-&gt;mpts_rel_seq = 1;
		}
		MPT_UNLOCK(mp_tp);
	}

	<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);
}

<span class="enscript-type">static</span> ev_ret_t
<span class="enscript-function-name">mptcp_deleteok_ev</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *mpts,
	uint64_t *p_mpsofilt_hint)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p_mpsofilt_hint</span>)
	MPTE_LOCK_ASSERT_HELD(mpte);
	MPTS_LOCK_ASSERT_HELD(mpts);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: &quot;</span>
	    <span class="enscript-string">&quot;%s cid %d\n&quot;</span>, __func__, mpts-&gt;mpts_connid),
	    MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);

	mpts-&gt;mpts_flags |= MPTSF_DELETEOK;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTED)
		<span class="enscript-keyword">return</span> (MPTS_EVRET_DELETE);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (MPTS_EVRET_OK);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">mptcp_evret2str</span>(ev_ret_t ret)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *c = <span class="enscript-string">&quot;UNKNOWN&quot;</span>;

	<span class="enscript-keyword">switch</span> (ret) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_DELETE</span>:
		c = <span class="enscript-string">&quot;MPTS_EVRET_DELETE&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_CONNECT_PENDING</span>:
		c = <span class="enscript-string">&quot;MPTS_EVRET_CONNECT_PENDING&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_DISCONNECT_FALLBACK</span>:
		c = <span class="enscript-string">&quot;MPTS_EVRET_DISCONNECT_FALLBACK&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_OK</span>:
		c = <span class="enscript-string">&quot;MPTS_EVRET_OK&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (c);
}

<span class="enscript-comment">/*
 * Add a reference to a subflow structure; used by MPTS_ADDREF().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_addref</span>(<span class="enscript-type">struct</span> mptsub *mpts, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		MPTS_LOCK(mpts);
	<span class="enscript-keyword">else</span>
		MPTS_LOCK_ASSERT_HELD(mpts);

	<span class="enscript-keyword">if</span> (++mpts-&gt;mpts_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: mpts %p wraparound refcnt\n&quot;</span>, __func__, mpts);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (!locked)
		MPTS_UNLOCK(mpts);
}

<span class="enscript-comment">/*
 * Remove a reference held on a subflow structure; used by MPTS_REMREF();
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_subflow_remref</span>(<span class="enscript-type">struct</span> mptsub *mpts)
{
	MPTS_LOCK(mpts);
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: mpts %p negative refcnt\n&quot;</span>, __func__, mpts);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (--mpts-&gt;mpts_refcnt &gt; 0) {
		MPTS_UNLOCK(mpts);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* callee will unlock and destroy lock */</span>
	mptcp_subflow_free(mpts);
}

<span class="enscript-comment">/*
 * Issues SOPT_SET on an MPTCP subflow socket; socket must already be locked,
 * caller must ensure that the option can be issued on subflow sockets, via
 * MPOF_SUBFLOW_OK flag.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_sosetopt</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> socket *so,
    <span class="enscript-type">struct</span> mptopt *mpo)
{
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> sockopt sopt;
	<span class="enscript-type">char</span> buf[32];
	<span class="enscript-type">int</span> error;

	VERIFY(mpo-&gt;mpo_flags &amp; MPOF_SUBFLOW_OK);
	mpo-&gt;mpo_flags &amp;= ~MPOF_INTERIM;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	bzero(&amp;sopt, <span class="enscript-keyword">sizeof</span> (sopt));
	sopt.sopt_dir = SOPT_SET;
	sopt.sopt_level = mpo-&gt;mpo_level;
	sopt.sopt_name = mpo-&gt;mpo_name;
	sopt.sopt_val = CAST_USER_ADDR_T(&amp;mpo-&gt;mpo_intval);
	sopt.sopt_valsize = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
	sopt.sopt_p = kernproc;

	error = sosetoptlock(so, &amp;sopt, 0);	<span class="enscript-comment">/* already locked */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s &quot;</span>
		    <span class="enscript-string">&quot;val %d set successful\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(mpo-&gt;mpo_level, mpo-&gt;mpo_name,
		    buf, <span class="enscript-keyword">sizeof</span> (buf)), mpo-&gt;mpo_intval),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
	} <span class="enscript-keyword">else</span> {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s &quot;</span>
		    <span class="enscript-string">&quot;val %d set error %d\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(mpo-&gt;mpo_level, mpo-&gt;mpo_name,
		    buf, <span class="enscript-keyword">sizeof</span> (buf)), mpo-&gt;mpo_intval, error),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Issues SOPT_GET on an MPTCP subflow socket; socket must already be locked,
 * caller must ensure that the option can be issued on subflow sockets, via
 * MPOF_SUBFLOW_OK flag.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_subflow_sogetopt</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> socket *so,
    <span class="enscript-type">struct</span> mptopt *mpo)
{
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> sockopt sopt;
	<span class="enscript-type">char</span> buf[32];
	<span class="enscript-type">int</span> error;

	VERIFY(mpo-&gt;mpo_flags &amp; MPOF_SUBFLOW_OK);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	bzero(&amp;sopt, <span class="enscript-keyword">sizeof</span> (sopt));
	sopt.sopt_dir = SOPT_GET;
	sopt.sopt_level = mpo-&gt;mpo_level;
	sopt.sopt_name = mpo-&gt;mpo_name;
	sopt.sopt_val = CAST_USER_ADDR_T(&amp;mpo-&gt;mpo_intval);
	sopt.sopt_valsize = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
	sopt.sopt_p = kernproc;

	error = sogetoptlock(so, &amp;sopt, 0);	<span class="enscript-comment">/* already locked */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s &quot;</span>
		    <span class="enscript-string">&quot;val %d get successful\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(mpo-&gt;mpo_level, mpo-&gt;mpo_name,
		    buf, <span class="enscript-keyword">sizeof</span> (buf)), mpo-&gt;mpo_intval),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
	} <span class="enscript-keyword">else</span> {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s get error %d\n&quot;</span>,
		    __func__, (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(mpo-&gt;mpo_level,
		    mpo-&gt;mpo_name, buf, <span class="enscript-keyword">sizeof</span> (buf)), error),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * MPTCP garbage collector.
 *
 * This routine is called by the MP domain on-demand, periodic callout,
 * which is triggered when a MPTCP socket is closed.  The callout will
 * repeat as long as this routine returns a non-zero value.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">mptcp_gc</span>(<span class="enscript-type">struct</span> mppcbinfo *mppi)
{
	<span class="enscript-type">struct</span> mppcb *mpp, *tmpp;
	uint32_t active = 0;

	lck_mtx_assert(&amp;mppi-&gt;mppi_lock, LCK_MTX_ASSERT_OWNED);

	TAILQ_FOREACH_SAFE(mpp, &amp;mppi-&gt;mppi_pcbs, mpp_entry, tmpp) {
		<span class="enscript-type">struct</span> socket *mp_so;
		<span class="enscript-type">struct</span> mptses *mpte;
		<span class="enscript-type">struct</span> mptcb *mp_tp;

		VERIFY(mpp-&gt;mpp_flags &amp; MPP_ATTACHED);
		mp_so = mpp-&gt;mpp_socket;
		VERIFY(mp_so != NULL);
		mpte = mptompte(mpp);
		VERIFY(mpte != NULL);
		mp_tp = mpte-&gt;mpte_mptcb;
		VERIFY(mp_tp != NULL);

		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx found &quot;</span>
		    <span class="enscript-string">&quot;(u=%d,r=%d,s=%d)\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), mp_so-&gt;so_usecount,
		    mp_so-&gt;so_retaincnt, mpp-&gt;mpp_state),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

		<span class="enscript-keyword">if</span> (!lck_mtx_try_lock(&amp;mpp-&gt;mpp_lock)) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: mp_so 0x%llx skipped &quot;</span>
			    <span class="enscript-string">&quot;(u=%d,r=%d)\n&quot;</span>, __func__,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mp_so-&gt;so_usecount, mp_so-&gt;so_retaincnt),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
			active++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* check again under the lock */</span>
		<span class="enscript-keyword">if</span> (mp_so-&gt;so_usecount &gt; 1) {
			boolean_t wakeup = FALSE;
			<span class="enscript-type">struct</span> mptsub *mpts, *tmpts;

			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: mp_so 0x%llx skipped &quot;</span>
			    <span class="enscript-string">&quot;[u=%d,r=%d] %d %d\n&quot;</span>, __func__,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mp_so-&gt;so_usecount, mp_so-&gt;so_retaincnt,
			    mp_tp-&gt;mpt_gc_ticks,
			    mp_tp-&gt;mpt_state),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

			MPT_LOCK(mp_tp);
			<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt;= MPTCPS_FIN_WAIT_1) {
				<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_gc_ticks &gt; 0)
					mp_tp-&gt;mpt_gc_ticks--;
				<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_gc_ticks == 0) {
					wakeup = TRUE;
					<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_localkey != NULL) {
						mptcp_free_key(
						    mp_tp-&gt;mpt_localkey);
						mp_tp-&gt;mpt_localkey = NULL;
					}
				}
			}
			MPT_UNLOCK(mp_tp);
			<span class="enscript-keyword">if</span> (wakeup) {
				TAILQ_FOREACH_SAFE(mpts,
				    &amp;mpte-&gt;mpte_subflows, mpts_entry, tmpts) {
					MPTS_LOCK(mpts);
					mpts-&gt;mpts_flags |= MPTSF_DELETEOK;
					<span class="enscript-keyword">if</span> (mpts-&gt;mpts_soerror == 0)
						mpts-&gt;mpts_soerror = ETIMEDOUT;
					mptcp_subflow_eupcall(mpts-&gt;mpts_socket,
					    mpts, SO_FILT_HINT_DISCONNECTED);
					MPTS_UNLOCK(mpts);
				}
			}
			lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
			active++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (mpp-&gt;mpp_state != MPPCB_STATE_DEAD) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: mp_so 0x%llx skipped &quot;</span>
			    <span class="enscript-string">&quot;[u=%d,r=%d,s=%d]\n&quot;</span>, __func__,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mp_so-&gt;so_usecount, mp_so-&gt;so_retaincnt,
			    mpp-&gt;mpp_state),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
			lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
			active++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * The PCB has been detached, and there is exactly 1 refnct
		 * held by the MPTCP thread.  Signal that thread to terminate,
		 * after which the last refcnt will be released.  That will
		 * allow it to be destroyed below during the next round.
		 */</span>
		<span class="enscript-keyword">if</span> (mp_so-&gt;so_usecount == 1) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: mp_so 0x%llx scheduled for &quot;</span>
			    <span class="enscript-string">&quot;termination [u=%d,r=%d]\n&quot;</span>, __func__,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mp_so-&gt;so_usecount, mp_so-&gt;so_retaincnt),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

			<span class="enscript-comment">/* signal MPTCP thread to terminate */</span>
			mptcp_thread_terminate_signal(mpte);
			lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
			active++;
			<span class="enscript-keyword">continue</span>;
		}

		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx destroyed [u=%d,r=%d]\n&quot;</span>,
		    __func__, (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mp_so-&gt;so_usecount, mp_so-&gt;so_retaincnt),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

		DTRACE_MPTCP4(dispose, <span class="enscript-type">struct</span> socket *, mp_so, 
		    <span class="enscript-type">struct</span> sockbuf *, &amp;mp_so-&gt;so_rcv,
		    <span class="enscript-type">struct</span> sockbuf *, &amp;mp_so-&gt;so_snd,
		    <span class="enscript-type">struct</span> mppcb *, mpp);

		mp_pcbdispose(mpp);
	}

	<span class="enscript-keyword">return</span> (active);
}

<span class="enscript-comment">/*
 * Drop a MPTCP connection, reporting the specified error.
 */</span>
<span class="enscript-type">struct</span> mptses *
<span class="enscript-function-name">mptcp_drop</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptcb *mp_tp, <span class="enscript-type">int</span> errno)
{
	<span class="enscript-type">struct</span> socket *mp_so;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPT_LOCK_ASSERT_HELD(mp_tp);
	VERIFY(mpte-&gt;mpte_mptcb == mp_tp);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	mp_tp-&gt;mpt_state = MPTCPS_TERMINATE;
	DTRACE_MPTCP2(state__change, <span class="enscript-type">struct</span> mptcb *, mp_tp, 
	    uint32_t, 0 <span class="enscript-comment">/* event */</span>);

	<span class="enscript-keyword">if</span> (errno == ETIMEDOUT &amp;&amp; mp_tp-&gt;mpt_softerror != 0)
		errno = mp_tp-&gt;mpt_softerror;
	mp_so-&gt;so_error = errno;

	<span class="enscript-keyword">return</span> (mptcp_close(mpte, mp_tp));
}

<span class="enscript-comment">/*
 * Close a MPTCP control block.
 */</span>
<span class="enscript-type">struct</span> mptses *
<span class="enscript-function-name">mptcp_close</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptcb *mp_tp)
{
	<span class="enscript-type">struct</span> socket *mp_so = NULL;
	<span class="enscript-type">struct</span> mptsub *mpts = NULL, *tmpts = NULL;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	MPT_LOCK_ASSERT_HELD(mp_tp);
	VERIFY(mpte-&gt;mpte_mptcb == mp_tp);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_localkey != NULL) {
		mptcp_free_key(mp_tp-&gt;mpt_localkey);
		mp_tp-&gt;mpt_localkey = NULL;
	}

	MPT_UNLOCK(mp_tp);
	soisdisconnected(mp_so);

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_PEEL_OFF) {
		<span class="enscript-keyword">return</span> (NULL);
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/* Clean up all subflows */</span>
	TAILQ_FOREACH_SAFE(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry, tmpts) {
		MPTS_LOCK(mpts);
		mpts-&gt;mpts_flags |= MPTSF_USER_DISCONNECT;
		mptcp_subflow_disconnect(mpte, mpts, TRUE);
		MPTS_UNLOCK(mpts);
		mptcp_subflow_del(mpte, mpts, TRUE);
	}
	MPT_LOCK(mp_tp);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_notify_close</span>(<span class="enscript-type">struct</span> socket *so)
{
	soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_DISCONNECTED));
}

<span class="enscript-comment">/*
 * Signal MPTCP thread to wake up.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_signal</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	lck_mtx_lock(&amp;mpte-&gt;mpte_thread_lock);
	mptcp_thread_signal_locked(mpte);
	lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
}

<span class="enscript-comment">/*
 * Signal MPTCP thread to wake up (locked version)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_signal_locked</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	lck_mtx_assert(&amp;mpte-&gt;mpte_thread_lock, LCK_MTX_ASSERT_OWNED);

	mpte-&gt;mpte_thread_reqs++;
	<span class="enscript-keyword">if</span> (!mpte-&gt;mpte_thread_active &amp;&amp; mpte-&gt;mpte_thread != THREAD_NULL)
		wakeup_one((caddr_t)&amp;mpte-&gt;mpte_thread);
}

<span class="enscript-comment">/*
 * Signal MPTCP thread to terminate.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_terminate_signal</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	lck_mtx_lock(&amp;mpte-&gt;mpte_thread_lock);
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_thread != THREAD_NULL) {
		mpte-&gt;mpte_thread = THREAD_NULL;
		mpte-&gt;mpte_thread_reqs++;
		<span class="enscript-keyword">if</span> (!mpte-&gt;mpte_thread_active)
			wakeup_one((caddr_t)&amp;mpte-&gt;mpte_thread);
	}
	lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
}

<span class="enscript-comment">/*
 * MPTCP thread workloop.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_dowork</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> mptsub *mpts, *tmpts;
	boolean_t connect_pending = FALSE, disconnect_fallback = FALSE;
	uint64_t mpsofilt_hint_mask = 0;

	MPTE_LOCK(mpte);		<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(mpte-&gt;mpte_mppcb != NULL);
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	VERIFY(mp_so != NULL);

	TAILQ_FOREACH_SAFE(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry, tmpts) {
		ev_ret_t ret;

		MPTS_LOCK(mpts);
		MPTS_ADDREF_LOCKED(mpts);	<span class="enscript-comment">/* for us */</span>
		
		<span class="enscript-comment">/* Update process ownership based on parent mptcp socket */</span>
		mptcp_update_last_owner(mpts, mp_so);
		
		mptcp_subflow_input(mpte, mpts);

		mptcp_get_rtt_measurement(mpts, mpte);

		ret = mptcp_subflow_events(mpte, mpts, &amp;mpsofilt_hint_mask);

		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: cid %d \n&quot;</span>, __func__,
			    mpts-&gt;mpts_connid),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
			(<span class="enscript-type">void</span>) mptcp_subflow_output(mpte, mpts);
		}

		<span class="enscript-comment">/*
		 * If MPTCP socket is closed, disconnect all subflows.
		 * This will generate a disconnect event which will
		 * be handled during the next iteration, causing a
		 * non-zero error to be returned above.
		 */</span>
		<span class="enscript-keyword">if</span> (mp_so-&gt;so_flags &amp; SOF_PCBCLEARING)
			mptcp_subflow_disconnect(mpte, mpts, FALSE);
		MPTS_UNLOCK(mpts);

		<span class="enscript-keyword">switch</span> (ret) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_OK</span>:
			<span class="enscript-comment">/* nothing to do */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_DELETE</span>:
			mptcp_subflow_del(mpte, mpts, TRUE);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_CONNECT_PENDING</span>:
			connect_pending = TRUE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTS_EVRET_DISCONNECT_FALLBACK</span>:
			disconnect_fallback = TRUE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			mptcplog((LOG_DEBUG,
			    <span class="enscript-string">&quot;MPTCP Socket: %s: mptcp_subflow_events &quot;</span>
			    <span class="enscript-string">&quot;returned invalid value: %d\n&quot;</span>,  __func__,
			    ret),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);
			<span class="enscript-keyword">break</span>;
		}
		MPTS_REMREF(mpts);		<span class="enscript-comment">/* ours */</span>
	}

	<span class="enscript-keyword">if</span> (mpsofilt_hint_mask) {
		soevent(mp_so, mpsofilt_hint_mask);
	}

	<span class="enscript-keyword">if</span> (!connect_pending &amp;&amp; !disconnect_fallback) {
		MPTE_UNLOCK(mpte);
		<span class="enscript-keyword">return</span>;
	}

	TAILQ_FOREACH_SAFE(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry, tmpts) {
		MPTS_LOCK(mpts);
		<span class="enscript-keyword">if</span> (disconnect_fallback) {
			<span class="enscript-type">struct</span> socket *so = NULL;
			<span class="enscript-type">struct</span> inpcb *inp = NULL;
			<span class="enscript-type">struct</span> tcpcb *tp = NULL;

			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED) {
				MPTS_UNLOCK(mpts);
				<span class="enscript-keyword">continue</span>;
			}

			mpts-&gt;mpts_flags |= MPTSF_MP_DEGRADED;

			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; (MPTSF_DISCONNECTING|
			    MPTSF_DISCONNECTED|MPTSF_CONNECT_PENDING)) {
				MPTS_UNLOCK(mpts);
				<span class="enscript-keyword">continue</span>;
			}
			so = mpts-&gt;mpts_socket;

			<span class="enscript-comment">/*
			 * The MPTCP connection has degraded to a fallback
			 * mode, so there is no point in keeping this subflow
			 * regardless of its MPTCP-readiness state, unless it
			 * is the primary one which we use for fallback.  This
			 * assumes that the subflow used for fallback is the
			 * ACTIVE one.
			 */</span>

			socket_lock(so, 1);
			inp = sotoinpcb(so);
			tp = intotcpcb(inp);
			tp-&gt;t_mpflags &amp;=
			    ~(TMPF_MPTCP_READY|TMPF_MPTCP_TRUE);
			tp-&gt;t_mpflags |= TMPF_TCP_FALLBACK;
			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE) {
				socket_unlock(so, 1);
				MPTS_UNLOCK(mpts);
				<span class="enscript-keyword">continue</span>;
			}
			tp-&gt;t_mpflags |= TMPF_RESET;
			soevent(so, SO_FILT_HINT_LOCKED | SO_FILT_HINT_MUSTRST);
			socket_unlock(so, 1);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (connect_pending) {
			<span class="enscript-comment">/*
			 * If delayed subflow start is set and cellular,
			 * delay the connect till a retransmission timeout
			 */</span>

			<span class="enscript-keyword">if</span> ((mptcp_delayed_subf_start) &amp;&amp;
			    (IFNET_IS_CELLULAR(mpts-&gt;mpts_outif))) {
				MPTS_UNLOCK(mpts);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * The MPTCP connection has progressed to a state
			 * where it supports full multipath semantics; allow
			 * additional joins to be attempted for all subflows
			 * that are in the PENDING state.
			 */</span>
			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_CONNECT_PENDING) {
				(<span class="enscript-type">void</span>) mptcp_subflow_soconnectx(mpte, mpts);
			}
		}
		MPTS_UNLOCK(mpts);
	}

	MPTE_UNLOCK(mpte);
}

<span class="enscript-comment">/*
 * MPTCP thread.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_func</span>(<span class="enscript-type">void</span> *v, wait_result_t w)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">w</span>)
	<span class="enscript-type">struct</span> mptses *mpte = v;
	<span class="enscript-type">struct</span> timespec *ts = NULL;

	VERIFY(mpte != NULL);

	lck_mtx_lock_spin(&amp;mpte-&gt;mpte_thread_lock);

	<span class="enscript-keyword">for</span> (;;) {
		lck_mtx_assert(&amp;mpte-&gt;mpte_thread_lock, LCK_MTX_ASSERT_OWNED);

		<span class="enscript-keyword">if</span> (mpte-&gt;mpte_thread != THREAD_NULL) {
			(<span class="enscript-type">void</span>) msleep(&amp;mpte-&gt;mpte_thread,
			    &amp;mpte-&gt;mpte_thread_lock, (PZERO - 1) | PSPIN,
			    __func__, ts);
		}

		<span class="enscript-comment">/* MPTCP socket is closed? */</span>
		<span class="enscript-keyword">if</span> (mpte-&gt;mpte_thread == THREAD_NULL) {
			lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
			<span class="enscript-comment">/* callee will destroy thread lock */</span>
			mptcp_thread_destroy(mpte);
			<span class="enscript-comment">/* NOTREACHED */</span>
			<span class="enscript-keyword">return</span>;
		}

		mpte-&gt;mpte_thread_active = 1;
		<span class="enscript-keyword">for</span> (;;) {
			uint32_t reqs = mpte-&gt;mpte_thread_reqs;

			lck_mtx_unlock(&amp;mpte-&gt;mpte_thread_lock);
			mptcp_thread_dowork(mpte);
			lck_mtx_lock_spin(&amp;mpte-&gt;mpte_thread_lock);

			<span class="enscript-comment">/* if there's no pending request, we're done */</span>
			<span class="enscript-keyword">if</span> (reqs == mpte-&gt;mpte_thread_reqs ||
			    mpte-&gt;mpte_thread == THREAD_NULL)
				<span class="enscript-keyword">break</span>;
		}
		mpte-&gt;mpte_thread_reqs = 0;
		mpte-&gt;mpte_thread_active = 0;
	}
}

<span class="enscript-comment">/*
 * Destroy a MTCP thread, to be called in the MPTCP thread context
 * upon receiving an indication to self-terminate.  This routine
 * will not return, as the current thread is terminated at the end.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_thread_destroy</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> socket *mp_so;

	MPTE_LOCK(mpte);		<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(mpte-&gt;mpte_thread == THREAD_NULL);
	VERIFY(mpte-&gt;mpte_mppcb != NULL);

	mptcp_sesdestroy(mpte);

	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	VERIFY(mp_so != NULL);
	VERIFY(mp_so-&gt;so_usecount != 0);
	mp_so-&gt;so_usecount--;		<span class="enscript-comment">/* for thread */</span>
	mpte-&gt;mpte_mppcb-&gt;mpp_flags |= MPP_DEFUNCT;
	MPTE_UNLOCK(mpte);

	<span class="enscript-comment">/* for the extra refcnt from kernel_thread_start() */</span>
	thread_deallocate(current_thread());
	<span class="enscript-comment">/* this is the end */</span>
	thread_terminate(current_thread());
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * Protocol pr_lock callback.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_lock</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (mpp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>, __func__,
		    mp_so, lr_saved, solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	lck_mtx_lock(&amp;mpp-&gt;mpp_lock);

	<span class="enscript-keyword">if</span> (mp_so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: so=%p so_pcb=%p lr=%p ref=%x lrh= %s\n&quot;</span>, __func__,
		    mp_so, mp_so-&gt;so_pcb, lr_saved, mp_so-&gt;so_usecount,
		    solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refcount != 0)
		mp_so-&gt;so_usecount++;
	mp_so-&gt;lock_lr[mp_so-&gt;next_lock_lr] = lr_saved;
	mp_so-&gt;next_lock_lr = (mp_so-&gt;next_lock_lr + 1) % SO_LCKDBG_MAX;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Protocol pr_unlock callback.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_unlock</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (mpp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB usecount=%x lr=%p lrh= %s\n&quot;</span>, __func__,
		    mp_so, mp_so-&gt;so_usecount, lr_saved,
		    solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	lck_mtx_assert(&amp;mpp-&gt;mpp_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (refcount != 0)
		mp_so-&gt;so_usecount--;

	<span class="enscript-keyword">if</span> (mp_so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: so=%p usecount=%x lrh= %s\n&quot;</span>, __func__,
		    mp_so, mp_so-&gt;so_usecount, solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	mp_so-&gt;unlock_lr[mp_so-&gt;next_unlock_lr] = lr_saved;
	mp_so-&gt;next_unlock_lr = (mp_so-&gt;next_unlock_lr + 1) % SO_LCKDBG_MAX;
	lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Protocol pr_getlock callback.
 */</span>
lck_mtx_t *
<span class="enscript-function-name">mptcp_getlock</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> locktype)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">locktype</span>)
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);

	<span class="enscript-keyword">if</span> (mpp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NULL so_pcb %s\n&quot;</span>, __func__, mp_so,
		    solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (mp_so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: so=%p usecount=%x lrh= %s\n&quot;</span>, __func__,
		    mp_so, mp_so-&gt;so_usecount, solockhistory_nr(mp_so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">return</span> (&amp;mpp-&gt;mpp_lock);
}

<span class="enscript-comment">/*
 * Key generation functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_generate_unique_key</span>(<span class="enscript-type">struct</span> mptcp_key_entry *key_entry)
{
	<span class="enscript-type">struct</span> mptcp_key_entry *key_elm;
<span class="enscript-reference">try_again</span>:
	read_random(&amp;key_entry-&gt;mkey_value, <span class="enscript-keyword">sizeof</span> (key_entry-&gt;mkey_value));
	<span class="enscript-keyword">if</span> (key_entry-&gt;mkey_value == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	mptcp_do_sha1(&amp;key_entry-&gt;mkey_value, key_entry-&gt;mkey_digest,
	    <span class="enscript-keyword">sizeof</span> (key_entry-&gt;mkey_digest));

	LIST_FOREACH(key_elm, &amp;mptcp_keys_pool, mkey_next) {
		<span class="enscript-keyword">if</span> (key_elm-&gt;mkey_value == key_entry-&gt;mkey_value) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
		}
		<span class="enscript-keyword">if</span> (bcmp(key_elm-&gt;mkey_digest, key_entry-&gt;mkey_digest, 4) ==
		    0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
		}
	}
}

<span class="enscript-type">static</span> mptcp_key_t *
<span class="enscript-function-name">mptcp_reserve_key</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> mptcp_key_entry *key_elm;
	<span class="enscript-type">struct</span> mptcp_key_entry *found_elm = NULL;

	lck_mtx_lock(&amp;mptcp_keys_pool.mkph_lock);
	LIST_FOREACH(key_elm, &amp;mptcp_keys_pool, mkey_next) {
		<span class="enscript-keyword">if</span> (key_elm-&gt;mkey_flags == MKEYF_FREE) {
			key_elm-&gt;mkey_flags = MKEYF_INUSE;
			found_elm = key_elm;
			<span class="enscript-keyword">break</span>;
		}
	}
	lck_mtx_unlock(&amp;mptcp_keys_pool.mkph_lock);

	<span class="enscript-keyword">if</span> (found_elm) {
		<span class="enscript-keyword">return</span> (&amp;found_elm-&gt;mkey_value);
	}

	key_elm = (<span class="enscript-type">struct</span> mptcp_key_entry *)
	    zalloc(mptcp_keys_pool.mkph_key_entry_zone);
	key_elm-&gt;mkey_flags = MKEYF_INUSE;

	lck_mtx_lock(&amp;mptcp_keys_pool.mkph_lock);
	mptcp_generate_unique_key(key_elm);
	LIST_INSERT_HEAD(&amp;mptcp_keys_pool, key_elm, mkey_next);
	mptcp_keys_pool.mkph_count += 1;
	lck_mtx_unlock(&amp;mptcp_keys_pool.mkph_lock);
	<span class="enscript-keyword">return</span> (&amp;key_elm-&gt;mkey_value);
}

<span class="enscript-type">static</span> caddr_t
<span class="enscript-function-name">mptcp_get_stored_digest</span>(mptcp_key_t *key)
{
	<span class="enscript-type">struct</span> mptcp_key_entry *key_holder;
	caddr_t digest = NULL;

	lck_mtx_lock(&amp;mptcp_keys_pool.mkph_lock);
	key_holder = (<span class="enscript-type">struct</span> mptcp_key_entry *)(<span class="enscript-type">void</span> *)((caddr_t)key -
	    offsetof(<span class="enscript-type">struct</span> mptcp_key_entry, mkey_value));
	<span class="enscript-keyword">if</span> (key_holder-&gt;mkey_flags != MKEYF_INUSE)
		panic_plain(<span class="enscript-string">&quot;%s&quot;</span>, __func__);
	digest = &amp;key_holder-&gt;mkey_digest[0];
	lck_mtx_unlock(&amp;mptcp_keys_pool.mkph_lock);
	<span class="enscript-keyword">return</span> (digest);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_free_key</span>(mptcp_key_t *key)
{
	<span class="enscript-type">struct</span> mptcp_key_entry *key_holder;
	<span class="enscript-type">struct</span> mptcp_key_entry *key_elm;
	<span class="enscript-type">int</span> pt = RandomULong();

	lck_mtx_lock(&amp;mptcp_keys_pool.mkph_lock);
	key_holder = (<span class="enscript-type">struct</span> mptcp_key_entry *)(<span class="enscript-type">void</span>*)((caddr_t)key -
	    offsetof(<span class="enscript-type">struct</span> mptcp_key_entry, mkey_value));
	key_holder-&gt;mkey_flags = MKEYF_FREE;

	LIST_REMOVE(key_holder, mkey_next);
	mptcp_keys_pool.mkph_count -= 1;

	<span class="enscript-comment">/* Free half the time */</span>
	<span class="enscript-keyword">if</span> (pt &amp; 0x01) {
		zfree(mptcp_keys_pool.mkph_key_entry_zone, key_holder);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Insert it at random point to avoid early reuse */</span>
		<span class="enscript-type">int</span> i = 0;
		<span class="enscript-keyword">if</span> (mptcp_keys_pool.mkph_count &gt; 1) {
			pt = pt % (mptcp_keys_pool.mkph_count - 1);
			LIST_FOREACH(key_elm, &amp;mptcp_keys_pool, mkey_next) {
				<span class="enscript-keyword">if</span> (++i &gt;= pt) {
					LIST_INSERT_AFTER(key_elm, key_holder,
					    mkey_next);
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> (i &lt; pt)
				panic(<span class="enscript-string">&quot;missed insertion&quot;</span>);
		} <span class="enscript-keyword">else</span> {
			LIST_INSERT_HEAD(&amp;mptcp_keys_pool, key_holder,
			    mkey_next);
		}
		mptcp_keys_pool.mkph_count += 1;
	}
	lck_mtx_unlock(&amp;mptcp_keys_pool.mkph_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_key_pool_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> mptcp_key_entry *key_entry;

	LIST_INIT(&amp;mptcp_keys_pool);
	mptcp_keys_pool.mkph_count = 0;

	mptcp_keys_pool.mkph_key_elm_sz = (vm_size_t)
	    (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_key_entry));
	mptcp_keys_pool.mkph_key_entry_zone = zinit(
	    mptcp_keys_pool.mkph_key_elm_sz,
	    MPTCP_MX_KEY_ALLOCS * mptcp_keys_pool.mkph_key_elm_sz,
	    MPTCP_MX_PREALLOC_ZONE_SZ, <span class="enscript-string">&quot;mptkeys&quot;</span>);
	<span class="enscript-keyword">if</span> (mptcp_keys_pool.mkph_key_entry_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate MPTCP keys zone \n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(mptcp_keys_pool.mkph_key_entry_zone, Z_CALLERACCT, FALSE);
	zone_change(mptcp_keys_pool.mkph_key_entry_zone, Z_EXPAND, TRUE);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MPTCP_KEY_PREALLOCS_MX; i++) {
		key_entry = (<span class="enscript-type">struct</span> mptcp_key_entry *)
		    zalloc(mptcp_keys_pool.mkph_key_entry_zone);
		key_entry-&gt;mkey_flags = MKEYF_FREE;
		mptcp_generate_unique_key(key_entry);
		LIST_INSERT_HEAD(&amp;mptcp_keys_pool, key_entry, mkey_next);
		mptcp_keys_pool.mkph_count += 1;
	}
	lck_mtx_init(&amp;mptcp_keys_pool.mkph_lock, mtcbinfo.mppi_lock_grp,
	    mtcbinfo.mppi_lock_attr);
}

<span class="enscript-comment">/*
 * MPTCP Join support
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_attach_to_subf</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> mptcb *mp_tp,
    uint8_t addr_id)
{
	<span class="enscript-type">struct</span> tcpcb *tp = sototcpcb(so);
	<span class="enscript-type">struct</span> mptcp_subf_auth_entry *sauth_entry;
	MPT_LOCK_ASSERT_NOTHELD(mp_tp);

	MPT_LOCK_SPIN(mp_tp);
	tp-&gt;t_mptcb = mp_tp;
	<span class="enscript-comment">/*
	 * The address ID of the first flow is implicitly 0.
	 */</span>
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state == MPTCPS_CLOSED) {
		tp-&gt;t_local_aid = 0;
	} <span class="enscript-keyword">else</span> {
		tp-&gt;t_local_aid = addr_id;
		tp-&gt;t_mpflags |= (TMPF_PREESTABLISHED | TMPF_JOINED_FLOW);
		so-&gt;so_flags |= SOF_MP_SEC_SUBFLOW;
	}
	MPT_UNLOCK(mp_tp);
	sauth_entry = zalloc(mpt_subauth_zone);
	sauth_entry-&gt;msae_laddr_id = tp-&gt;t_local_aid;
	sauth_entry-&gt;msae_raddr_id = 0;
	sauth_entry-&gt;msae_raddr_rand = 0;
<span class="enscript-reference">try_again</span>:
	sauth_entry-&gt;msae_laddr_rand = RandomULong();
	<span class="enscript-keyword">if</span> (sauth_entry-&gt;msae_laddr_rand == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	MPT_LOCK_SPIN(mp_tp);
	LIST_INSERT_HEAD(&amp;mp_tp-&gt;mpt_subauth_list, sauth_entry, msae_next);
	MPT_UNLOCK(mp_tp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_detach_mptcb_from_subf</span>(<span class="enscript-type">struct</span> mptcb *mp_tp, <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> mptcp_subf_auth_entry *sauth_entry;
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	<span class="enscript-type">int</span> found = 0;

	socket_lock(so, 0);
	tp = sototcpcb(so);
	<span class="enscript-keyword">if</span> (tp == NULL) {
		socket_unlock(so, 0);
		<span class="enscript-keyword">return</span>;
	}

	MPT_LOCK(mp_tp);
	LIST_FOREACH(sauth_entry, &amp;mp_tp-&gt;mpt_subauth_list, msae_next) {
		<span class="enscript-keyword">if</span> (sauth_entry-&gt;msae_laddr_id == tp-&gt;t_local_aid) {
			found = 1;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (found) {
		LIST_REMOVE(sauth_entry, msae_next);
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-keyword">if</span> (found)
		zfree(mpt_subauth_zone, sauth_entry);

	tp-&gt;t_mptcb = NULL;
	socket_unlock(so, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_get_rands</span>(mptcp_addr_id addr_id, <span class="enscript-type">struct</span> mptcb *mp_tp, u_int32_t *lrand,
    u_int32_t *rrand)
{
	<span class="enscript-type">struct</span> mptcp_subf_auth_entry *sauth_entry;
	MPT_LOCK_ASSERT_NOTHELD(mp_tp);

	MPT_LOCK(mp_tp);
	LIST_FOREACH(sauth_entry, &amp;mp_tp-&gt;mpt_subauth_list, msae_next) {
		<span class="enscript-keyword">if</span> (sauth_entry-&gt;msae_laddr_id == addr_id) {
			<span class="enscript-keyword">if</span> (lrand)
				*lrand = sauth_entry-&gt;msae_laddr_rand;
			<span class="enscript-keyword">if</span> (rrand)
				*rrand = sauth_entry-&gt;msae_raddr_rand;
			<span class="enscript-keyword">break</span>;
		}
	}
	MPT_UNLOCK(mp_tp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_set_raddr_rand</span>(mptcp_addr_id laddr_id, <span class="enscript-type">struct</span> mptcb *mp_tp,
    mptcp_addr_id raddr_id, u_int32_t raddr_rand)
{
	<span class="enscript-type">struct</span> mptcp_subf_auth_entry *sauth_entry;
	MPT_LOCK_ASSERT_NOTHELD(mp_tp);

	MPT_LOCK(mp_tp);
	LIST_FOREACH(sauth_entry, &amp;mp_tp-&gt;mpt_subauth_list, msae_next) {
		<span class="enscript-keyword">if</span> (sauth_entry-&gt;msae_laddr_id == laddr_id) {
			<span class="enscript-keyword">if</span> ((sauth_entry-&gt;msae_raddr_id != 0) &amp;&amp;
			    (sauth_entry-&gt;msae_raddr_id != raddr_id)) {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: %s mismatched&quot;</span>
				    <span class="enscript-string">&quot; address ids %d %d \n&quot;</span>, __func__, raddr_id,
				    sauth_entry-&gt;msae_raddr_id),
				    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
				MPT_UNLOCK(mp_tp);
				<span class="enscript-keyword">return</span>;
			}
			sauth_entry-&gt;msae_raddr_id = raddr_id;
			<span class="enscript-keyword">if</span> ((sauth_entry-&gt;msae_raddr_rand != 0) &amp;&amp;
			    (sauth_entry-&gt;msae_raddr_rand != raddr_rand)) {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
				    <span class="enscript-string">&quot;%s: dup SYN_ACK %d %d \n&quot;</span>,
				    __func__, raddr_rand,
				    sauth_entry-&gt;msae_raddr_rand),
				    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
				MPT_UNLOCK(mp_tp);
				<span class="enscript-keyword">return</span>;
			}
			sauth_entry-&gt;msae_raddr_rand = raddr_rand;
			MPT_UNLOCK(mp_tp);
			<span class="enscript-keyword">return</span>;
		}
	}
	MPT_UNLOCK(mp_tp);
}

<span class="enscript-comment">/*
 * SHA1 support for MPTCP
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_do_sha1</span>(mptcp_key_t *key, <span class="enscript-type">char</span> *sha_digest, <span class="enscript-type">int</span> digest_len)
{
	SHA1_CTX sha1ctxt;
	<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *sha1_base;
	<span class="enscript-type">int</span> sha1_size;

	<span class="enscript-keyword">if</span> (digest_len != SHA1_RESULTLEN) {
		<span class="enscript-keyword">return</span> (FALSE);
	}

	sha1_base = (<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) key;
	sha1_size = <span class="enscript-keyword">sizeof</span> (mptcp_key_t);
	SHA1Init(&amp;sha1ctxt);
	SHA1Update(&amp;sha1ctxt, sha1_base, sha1_size);
	SHA1Final(sha_digest, &amp;sha1ctxt);
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_hmac_sha1</span>(mptcp_key_t key1, mptcp_key_t key2,
	u_int32_t rand1, u_int32_t rand2, u_char *digest, <span class="enscript-type">int</span> digest_len)
{
	SHA1_CTX  sha1ctxt;
	mptcp_key_t key_ipad[8] = {0}; <span class="enscript-comment">/* key XOR'd with inner pad */</span>
	mptcp_key_t key_opad[8] = {0}; <span class="enscript-comment">/* key XOR'd with outer pad */</span>
	u_int32_t data[2];
	<span class="enscript-type">int</span> i;

	bzero(digest, digest_len);

	<span class="enscript-comment">/* Set up the Key for HMAC */</span>
	key_ipad[0] = key1;
	key_ipad[1] = key2;

	key_opad[0] = key1;
	key_opad[1] = key2;

	<span class="enscript-comment">/* Set up the message for HMAC */</span>
	data[0] = rand1;
	data[1] = rand2;

	<span class="enscript-comment">/* Key is 512 block length, so no need to compute hash */</span>

	<span class="enscript-comment">/* Compute SHA1(Key XOR opad, SHA1(Key XOR ipad, data)) */</span>

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i++) {
		key_ipad[i] ^= 0x3636363636363636;
		key_opad[i] ^= 0x5c5c5c5c5c5c5c5c;
	}

	<span class="enscript-comment">/* Perform inner SHA1 */</span>
	SHA1Init(&amp;sha1ctxt);
	SHA1Update(&amp;sha1ctxt, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)key_ipad, <span class="enscript-keyword">sizeof</span> (key_ipad));
	SHA1Update(&amp;sha1ctxt, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)data, <span class="enscript-keyword">sizeof</span> (data));
	SHA1Final(digest, &amp;sha1ctxt);

	<span class="enscript-comment">/* Perform outer SHA1 */</span>
	SHA1Init(&amp;sha1ctxt);
	SHA1Update(&amp;sha1ctxt, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)key_opad, <span class="enscript-keyword">sizeof</span> (key_opad));
	SHA1Update(&amp;sha1ctxt, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)digest, SHA1_RESULTLEN);
	SHA1Final(digest, &amp;sha1ctxt);
}

<span class="enscript-comment">/*
 * corresponds to MAC-B = MAC (Key=(Key-B+Key-A), Msg=(R-B+R-A))
 * corresponds to MAC-A = MAC (Key=(Key-A+Key-B), Msg=(R-A+R-B))
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_get_hmac</span>(mptcp_addr_id aid, <span class="enscript-type">struct</span> mptcb *mp_tp, u_char *digest,
    <span class="enscript-type">int</span> digest_len)
{
	uint32_t lrand, rrand;
	mptcp_key_t localkey, remotekey;
	MPT_LOCK_ASSERT_NOTHELD(mp_tp);

	<span class="enscript-keyword">if</span> (digest_len != SHA1_RESULTLEN)
		<span class="enscript-keyword">return</span>;

	lrand = rrand = 0;
	mptcp_get_rands(aid, mp_tp, &amp;lrand, &amp;rrand);
	MPT_LOCK_SPIN(mp_tp);
	localkey = *mp_tp-&gt;mpt_localkey;
	remotekey = mp_tp-&gt;mpt_remotekey;
	MPT_UNLOCK(mp_tp);
	mptcp_hmac_sha1(localkey, remotekey, lrand, rrand, digest,
	    digest_len);
}

u_int64_t
<span class="enscript-function-name">mptcp_get_trunced_hmac</span>(mptcp_addr_id aid, <span class="enscript-type">struct</span> mptcb *mp_tp)
{
	u_char digest[SHA1_RESULTLEN];
	u_int64_t trunced_digest;

	mptcp_get_hmac(aid, mp_tp, &amp;digest[0], <span class="enscript-keyword">sizeof</span> (digest));
	bcopy(digest, &amp;trunced_digest, 8);
	<span class="enscript-keyword">return</span> (trunced_digest);
}

<span class="enscript-comment">/*
 * Authentication data generation
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_generate_token</span>(<span class="enscript-type">char</span> *sha_digest, <span class="enscript-type">int</span> sha_digest_len, caddr_t token,
    <span class="enscript-type">int</span> token_len)
{
	VERIFY(token_len == <span class="enscript-keyword">sizeof</span> (u_int32_t));
	VERIFY(sha_digest_len == SHA1_RESULTLEN);

	<span class="enscript-comment">/* Most significant 32 bits of the SHA1 hash */</span>
	bcopy(sha_digest, token, <span class="enscript-keyword">sizeof</span> (u_int32_t));
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_generate_idsn</span>(<span class="enscript-type">char</span> *sha_digest, <span class="enscript-type">int</span> sha_digest_len, caddr_t idsn,
    <span class="enscript-type">int</span> idsn_len)
{
	VERIFY(idsn_len == <span class="enscript-keyword">sizeof</span> (u_int64_t));
	VERIFY(sha_digest_len == SHA1_RESULTLEN);

	<span class="enscript-comment">/*
	 * Least significant 64 bits of the SHA1 hash
	 */</span>

	idsn[7] = sha_digest[12];
	idsn[6] = sha_digest[13];
	idsn[5] = sha_digest[14];
	idsn[4] = sha_digest[15];
	idsn[3] = sha_digest[16];
	idsn[2] = sha_digest[17];
	idsn[1] = sha_digest[18];
	idsn[0] = sha_digest[19];
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_init_authparms</span>(<span class="enscript-type">struct</span> mptcb *mp_tp)
{
	caddr_t local_digest = NULL;
	<span class="enscript-type">char</span> remote_digest[MPTCP_SHA1_RESULTLEN];
	MPT_LOCK_ASSERT_HELD(mp_tp);

	<span class="enscript-comment">/* Only Version 0 is supported for auth purposes */</span>
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_version != MPTCP_STD_VERSION_0)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/* Setup local and remote tokens and Initial DSNs */</span>
	local_digest = mptcp_get_stored_digest(mp_tp-&gt;mpt_localkey);
	mptcp_generate_token(local_digest, SHA1_RESULTLEN,
	    (caddr_t)&amp;mp_tp-&gt;mpt_localtoken, <span class="enscript-keyword">sizeof</span> (mp_tp-&gt;mpt_localtoken));
	mptcp_generate_idsn(local_digest, SHA1_RESULTLEN,
	    (caddr_t)&amp;mp_tp-&gt;mpt_local_idsn, <span class="enscript-keyword">sizeof</span> (u_int64_t));

	<span class="enscript-keyword">if</span> (!mptcp_do_sha1(&amp;mp_tp-&gt;mpt_remotekey, remote_digest,
	    SHA1_RESULTLEN)) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: %s: unexpected failure&quot;</span>,
		    __func__), MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
		<span class="enscript-keyword">return</span> (-1);
	}
	mptcp_generate_token(remote_digest, SHA1_RESULTLEN,
	    (caddr_t)&amp;mp_tp-&gt;mpt_remotetoken, <span class="enscript-keyword">sizeof</span> (mp_tp-&gt;mpt_localtoken));
	mptcp_generate_idsn(remote_digest, SHA1_RESULTLEN,
	    (caddr_t)&amp;mp_tp-&gt;mpt_remote_idsn, <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_init_statevars</span>(<span class="enscript-type">struct</span> mptcb *mp_tp)
{
	MPT_LOCK_ASSERT_HELD(mp_tp);

	<span class="enscript-comment">/* The subflow SYN is also first MPTCP byte */</span>
	mp_tp-&gt;mpt_snduna = mp_tp-&gt;mpt_sndmax = mp_tp-&gt;mpt_local_idsn + 1;
	mp_tp-&gt;mpt_sndnxt = mp_tp-&gt;mpt_snduna;

	mp_tp-&gt;mpt_rcvatmark = mp_tp-&gt;mpt_rcvnxt = mp_tp-&gt;mpt_remote_idsn + 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_conn_properties</span>(<span class="enscript-type">struct</span> mptcb *mp_tp)
{
	<span class="enscript-comment">/* There is only Version 0 at this time */</span>
	mp_tp-&gt;mpt_version = MPTCP_STD_VERSION_0;

	<span class="enscript-comment">/* Set DSS checksum flag */</span>
	<span class="enscript-keyword">if</span> (mptcp_dss_csum)
		mp_tp-&gt;mpt_flags |= MPTCPF_CHECKSUM;

	<span class="enscript-comment">/* Set up receive window */</span>
	mp_tp-&gt;mpt_rcvwnd = mptcp_sbspace(mp_tp);

	<span class="enscript-comment">/* Set up gc ticks */</span>
	mp_tp-&gt;mpt_gc_ticks = MPT_GC_TICKS;
}

<span class="enscript-comment">/*
 * Helper Functions
 */</span>
mptcp_token_t
<span class="enscript-function-name">mptcp_get_localtoken</span>(<span class="enscript-type">void</span>* mptcb_arg)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)mptcb_arg;
	<span class="enscript-keyword">return</span> (mp_tp-&gt;mpt_localtoken);
}

mptcp_token_t
<span class="enscript-function-name">mptcp_get_remotetoken</span>(<span class="enscript-type">void</span>* mptcb_arg)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)mptcb_arg;
	<span class="enscript-keyword">return</span> (mp_tp-&gt;mpt_remotetoken);
}

u_int64_t
<span class="enscript-function-name">mptcp_get_localkey</span>(<span class="enscript-type">void</span>* mptcb_arg)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)mptcb_arg;
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_localkey != NULL)
		<span class="enscript-keyword">return</span> (*mp_tp-&gt;mpt_localkey);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}

u_int64_t
<span class="enscript-function-name">mptcp_get_remotekey</span>(<span class="enscript-type">void</span>* mptcb_arg)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)mptcb_arg;
	<span class="enscript-keyword">return</span> (mp_tp-&gt;mpt_remotekey);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_send_dfin</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = NULL;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (!inp)
		<span class="enscript-keyword">return</span>;

	tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (!tp)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_RESET))
		tp-&gt;t_mpflags |= TMPF_SEND_DFIN;
}

<span class="enscript-comment">/*
 * Data Sequence Mapping routines
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_insert_dsn</span>(<span class="enscript-type">struct</span> mppcb *mpp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp;

	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	__IGNORE_WCASTALIGN(mp_tp = &amp;((<span class="enscript-type">struct</span> mpp_mtp *)mpp)-&gt;mtcb);
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
		MPT_UNLOCK(mp_tp);
		panic(<span class="enscript-string">&quot;%s: data write before establishment.&quot;</span>,
		    __func__);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">while</span> (m) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		m-&gt;m_pkthdr.pkt_flags |= (PKTF_MPTCP | PKTF_MPSO);
		m-&gt;m_pkthdr.mp_dsn = mp_tp-&gt;mpt_sndmax;
		m-&gt;m_pkthdr.mp_rlen = m_pktlen(m);
		mp_tp-&gt;mpt_sndmax += m_pktlen(m);
		m = m-&gt;m_next;
	}
	MPT_UNLOCK(mp_tp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_preproc_sbdrop</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len)
{
	u_int32_t sub_len = 0;

	<span class="enscript-keyword">while</span> (m) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP) {
			sub_len = m-&gt;m_pkthdr.mp_rlen;

			<span class="enscript-keyword">if</span> (sub_len &lt; len) {
				m-&gt;m_pkthdr.mp_dsn += sub_len;
				<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPSO)) {
					m-&gt;m_pkthdr.mp_rseq += sub_len;
				}
				m-&gt;m_pkthdr.mp_rlen = 0;
				len -= sub_len;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* sub_len &gt;= len */</span>
				m-&gt;m_pkthdr.mp_dsn += len;
				<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPSO)) {
					m-&gt;m_pkthdr.mp_rseq += len;
				}
				mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: &quot;</span>
				    <span class="enscript-string">&quot;%s: dsn 0x%llu ssn %u len %d %d\n&quot;</span>,
				    __func__,
				    m-&gt;m_pkthdr.mp_dsn, m-&gt;m_pkthdr.mp_rseq,
				    m-&gt;m_pkthdr.mp_rlen, len),
				    MPTCP_SENDER_DBG, MPTCP_LOGLVL_VERBOSE);
				m-&gt;m_pkthdr.mp_rlen -= len;
				<span class="enscript-keyword">return</span>;
			}
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;%s: MPTCP tag not set&quot;</span>, __func__);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		m = m-&gt;m_next;
	}
}

<span class="enscript-comment">/* Obtain the DSN mapping stored in the mbuf */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_output_getm_dsnmap32</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> off, uint32_t datalen,
    u_int32_t *dsn, u_int32_t *relseq, u_int16_t *data_len, u_int64_t *dsn64p)
{
	u_int64_t dsn64;

	mptcp_output_getm_dsnmap64(so, off, datalen, &amp;dsn64, relseq, data_len);
	*dsn = (u_int32_t)MPTCP_DATASEQ_LOW32(dsn64);
	*dsn64p = dsn64;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_output_getm_dsnmap64</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> off, uint32_t datalen,
    u_int64_t *dsn, u_int32_t *relseq, u_int16_t *data_len)
{
	<span class="enscript-type">struct</span> mbuf *m = so-&gt;so_snd.sb_mb;
	<span class="enscript-type">struct</span> mbuf *mnext = NULL;
	uint32_t runlen = 0;
	u_int64_t dsn64;
	uint32_t contig_len = 0;

	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (off &lt; 0)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/*
	 * In the subflow socket, the DSN sequencing can be discontiguous,
	 * but the subflow sequence mapping is contiguous. Use the subflow
	 * sequence property to find the right mbuf and corresponding dsn
	 * mapping.
	 */</span>

	<span class="enscript-keyword">while</span> (m) {
		VERIFY(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP);
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)off &gt;= m-&gt;m_pkthdr.mp_rlen) {
			off -= m-&gt;m_pkthdr.mp_rlen;
			m = m-&gt;m_next;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (m == NULL) {
		panic(<span class="enscript-string">&quot;%s: bad offset&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	dsn64 = m-&gt;m_pkthdr.mp_dsn + off;
	*dsn = dsn64;
	*relseq = m-&gt;m_pkthdr.mp_rseq + off;

	<span class="enscript-comment">/*
	 * Now find the last contiguous byte and its length from
	 * start.
	 */</span>
	runlen = m-&gt;m_pkthdr.mp_rlen - off;
	contig_len = runlen;

	<span class="enscript-comment">/* If datalen does not span multiple mbufs, return */</span>
	<span class="enscript-keyword">if</span> (datalen &lt;= runlen) {
		*data_len = min(datalen, UINT16_MAX);
		<span class="enscript-keyword">return</span>;
	}

	mnext = m-&gt;m_next;
	<span class="enscript-keyword">while</span> (datalen &gt; runlen) {
		<span class="enscript-keyword">if</span> (mnext == NULL) {
			panic(<span class="enscript-string">&quot;%s: bad datalen = %d, %d %d&quot;</span>, __func__, datalen,
			    runlen, off);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		VERIFY(mnext-&gt;m_flags &amp; M_PKTHDR);
		VERIFY(mnext-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP);

		<span class="enscript-comment">/*
		 * case A. contiguous DSN stream
		 * case B. discontiguous DSN stream
		 */</span>
		<span class="enscript-keyword">if</span> (mnext-&gt;m_pkthdr.mp_dsn == (dsn64 + runlen)) {
			<span class="enscript-comment">/* case A */</span>
			runlen += mnext-&gt;m_pkthdr.mp_rlen;
			contig_len += mnext-&gt;m_pkthdr.mp_rlen;
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s: contig \n&quot;</span>,
			    __func__), MPTCP_SENDER_DBG, MPTCP_LOGLVL_VERBOSE);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* case B */</span>
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: &quot;</span>
			    <span class="enscript-string">&quot;%s: discontig datalen %d contig_len %d cc %d \n&quot;</span>,
			    __func__, datalen, contig_len, so-&gt;so_snd.sb_cc),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_VERBOSE);
			<span class="enscript-keyword">break</span>;
		}
		mnext = mnext-&gt;m_next;
	}
	datalen = min(datalen, UINT16_MAX);
	*data_len = min(datalen, contig_len);
	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: &quot;</span>
	    <span class="enscript-string">&quot;%s: %llu %u %d %d \n&quot;</span>, __func__,
	    *dsn, *relseq, *data_len, off),
	    MPTCP_SENDER_DBG, MPTCP_LOGLVL_VERBOSE);
}

<span class="enscript-comment">/*
 * MPTCP's notion of the next insequence Data Sequence number is adjusted
 * here. It must be called from mptcp_adj_rmap() which is called only after
 * reassembly of out of order data. The rcvnxt variable must
 * be updated only when atleast some insequence new data is received.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_adj_rcvnxt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);

	<span class="enscript-keyword">if</span> (mp_tp == NULL)
		<span class="enscript-keyword">return</span>;
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> ((MPTCP_SEQ_GEQ(mp_tp-&gt;mpt_rcvnxt, m-&gt;m_pkthdr.mp_dsn)) &amp;&amp;
	    (MPTCP_SEQ_LEQ(mp_tp-&gt;mpt_rcvnxt, (m-&gt;m_pkthdr.mp_dsn +
	    m-&gt;m_pkthdr.mp_rlen)))) {
		mp_tp-&gt;mpt_rcvnxt = m-&gt;m_pkthdr.mp_dsn + m-&gt;m_pkthdr.mp_rlen;
	}
	MPT_UNLOCK(mp_tp);
}

<span class="enscript-comment">/*
 * Note that this is called only from tcp_input() via mptcp_input_preproc()
 * tcp_input() may trim data after the dsn mapping is inserted into the mbuf.
 * When it trims data tcp_input calls m_adj() which does not remove the
 * m_pkthdr even if the m_len becomes 0 as a result of trimming the mbuf.
 * The dsn map insertion cannot be delayed after trim, because data can be in
 * the reassembly queue for a while and the DSN option info in tp will be
 * overwritten for every new packet received.
 * The dsn map will be adjusted just prior to appending to subflow sockbuf
 * with mptcp_adj_rmap()
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_insert_rmap</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mbuf *m)
{
	VERIFY(!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP));

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_EMBED_DSN) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		m-&gt;m_pkthdr.mp_dsn = tp-&gt;t_rcv_map.mpt_dsn;
		m-&gt;m_pkthdr.mp_rseq = tp-&gt;t_rcv_map.mpt_sseq;
		m-&gt;m_pkthdr.mp_rlen = tp-&gt;t_rcv_map.mpt_len;
		m-&gt;m_pkthdr.pkt_flags |= PKTF_MPTCP;
		tp-&gt;t_mpflags &amp;= ~TMPF_EMBED_DSN;
		tp-&gt;t_mpflags |= TMPF_MPTCP_ACKNOW;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_adj_rmap</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> mbuf *m)
{
	u_int64_t dsn;
	u_int32_t sseq, datalen;
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(sotoinpcb(so));
	u_int32_t old_rcvnxt = 0;

	<span class="enscript-keyword">if</span> (m_pktlen(m) == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

		dsn = m-&gt;m_pkthdr.mp_dsn;
		sseq = m-&gt;m_pkthdr.mp_rseq + tp-&gt;irs;
		datalen = m-&gt;m_pkthdr.mp_rlen;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* data arrived without an DSS option mapping */</span>

		<span class="enscript-comment">/* initial subflow can fallback right after SYN handshake */</span>
		mptcp_notify_mpfail(so);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* In the common case, data is in window and in sequence */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len == (<span class="enscript-type">int</span>)datalen) {
		mptcp_adj_rcvnxt(tp, m);
		<span class="enscript-keyword">return</span> 0;
	}

	old_rcvnxt = tp-&gt;rcv_nxt - m-&gt;m_pkthdr.len;
	<span class="enscript-keyword">if</span> (SEQ_GT(old_rcvnxt, sseq)) {
		<span class="enscript-comment">/* data trimmed from the left */</span>
		<span class="enscript-type">int</span> off = old_rcvnxt - sseq;
		m-&gt;m_pkthdr.mp_dsn += off;
		m-&gt;m_pkthdr.mp_rseq += off;
		m-&gt;m_pkthdr.mp_rlen = m-&gt;m_pkthdr.len;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old_rcvnxt == sseq) {
		<span class="enscript-comment">/*
		 * data was trimmed from the right
		 */</span>
		m-&gt;m_pkthdr.mp_rlen = m-&gt;m_pkthdr.len;
	} <span class="enscript-keyword">else</span> {
		mptcp_notify_mpfail(so);
		<span class="enscript-keyword">return</span> (-1);
	}
	mptcp_adj_rcvnxt(tp, m);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Following routines help with failure detection and failover of data
 * transfer from one subflow to another.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_act_on_txfail</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span>;

	tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_TRYFAILOVER) {
		<span class="enscript-keyword">return</span>;
	}

	so-&gt;so_flags |= SOF_MP_TRYFAILOVER;
	soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_MPFAILOVER));
}

<span class="enscript-comment">/*
 * Support for MP_FAIL option
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_get_map_for_dsn</span>(<span class="enscript-type">struct</span> socket *so, u_int64_t dsn_fail, u_int32_t *tcp_seq)
{
	<span class="enscript-type">struct</span> mbuf *m = so-&gt;so_snd.sb_mb;
	u_int64_t dsn;
	<span class="enscript-type">int</span> off = 0;
	u_int32_t datalen;

	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">while</span> (m != NULL) {
		VERIFY(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_MPTCP);
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		dsn = m-&gt;m_pkthdr.mp_dsn;
		datalen = m-&gt;m_pkthdr.mp_rlen;
		<span class="enscript-keyword">if</span> (MPTCP_SEQ_LEQ(dsn, dsn_fail) &amp;&amp;
		    (MPTCP_SEQ_GEQ(dsn + datalen, dsn_fail))) {
			off = dsn_fail - dsn;
			*tcp_seq = m-&gt;m_pkthdr.mp_rseq + off;
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s: %llu %llu \n&quot;</span>,
			    __func__, dsn, dsn_fail),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">return</span> (0);
		}

		m = m-&gt;m_next;
	}

	<span class="enscript-comment">/*
	 * If there was no mbuf data and a fallback to TCP occurred, there's
	 * not much else to do.
	 */</span>

	mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Sender: &quot;</span>
	    <span class="enscript-string">&quot;%s: %llu not found \n&quot;</span>, __func__, dsn_fail),
	    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * Support for sending contiguous MPTCP bytes in subflow
 * Also for preventing sending data with ACK in 3-way handshake
 */</span>
int32_t
<span class="enscript-function-name">mptcp_adj_sendlen</span>(<span class="enscript-type">struct</span> socket *so, int32_t off, int32_t len)
{
	u_int64_t	mdss_dsn = 0;
	u_int32_t	mdss_subflow_seq = 0;
	u_int16_t	mdss_data_len = 0;

	<span class="enscript-keyword">if</span> (len == 0)
		<span class="enscript-keyword">return</span> (len);

	mptcp_output_getm_dsnmap64(so, off, (u_int32_t)len,
	    &amp;mdss_dsn, &amp;mdss_subflow_seq, &amp;mdss_data_len);

	<span class="enscript-comment">/* 
	 * Special case handling for Fast Join. We want to send data right
	 * after ACK of the 3-way handshake, but not piggyback the data
	 * with the 3rd ACK of the 3WHS. TMPF_FASTJOINBY2_SEND and
	 * mdss_data_len control this.
	 */</span>
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	tp = intotcpcb(sotoinpcb(so)); 
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW) &amp;&amp;
            (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_RECVD_JOIN)) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_FASTJOINBY2_SEND))) {
	    mdss_data_len = 0;
	    tp-&gt;t_mpflags |= TMPF_FASTJOINBY2_SEND;
	}    
	<span class="enscript-keyword">return</span> (mdss_data_len);
}

int32_t
<span class="enscript-function-name">mptcp_sbspace</span>(<span class="enscript-type">struct</span> mptcb *mpt)
{
	<span class="enscript-type">struct</span> sockbuf *sb;
	uint32_t rcvbuf;
	int32_t space;

	MPT_LOCK_ASSERT_HELD(mpt);
	MPTE_LOCK_ASSERT_HELD(mpt-&gt;mpt_mpte);

	sb = &amp;mpt-&gt;mpt_mpte-&gt;mpte_mppcb-&gt;mpp_socket-&gt;so_rcv;
	rcvbuf = sb-&gt;sb_hiwat;
	space = ((int32_t)imin((rcvbuf - sb-&gt;sb_cc),
	    (sb-&gt;sb_mbmax - sb-&gt;sb_mbcnt)));
	<span class="enscript-keyword">if</span> (space &lt; 0)
		space = 0;
	<span class="enscript-comment">/* XXX check if it's too small? */</span>

	<span class="enscript-keyword">return</span> (space);
}

<span class="enscript-comment">/*
 * Support Fallback to Regular TCP
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_notify_mpready</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	<span class="enscript-keyword">if</span> (so == NULL)
		<span class="enscript-keyword">return</span>;

	tp = intotcpcb(sotoinpcb(so));

	<span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">return</span>;

	DTRACE_MPTCP4(multipath__ready, <span class="enscript-type">struct</span> socket *, so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv, <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd,
	    <span class="enscript-type">struct</span> tcpcb *, tp);

	<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_MPTCP_READY)
		<span class="enscript-keyword">return</span>;

	tp-&gt;t_mpflags &amp;= ~TMPF_TCP_FALLBACK;
	tp-&gt;t_mpflags |= TMPF_MPTCP_READY;

	soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_MPSTATUS));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_notify_mpfail</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	<span class="enscript-keyword">if</span> (so == NULL)
		<span class="enscript-keyword">return</span>;

	tp = intotcpcb(sotoinpcb(so));

	<span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">return</span>;

	DTRACE_MPTCP4(multipath__failed, <span class="enscript-type">struct</span> socket *, so,
	    <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_rcv, <span class="enscript-type">struct</span> sockbuf *, &amp;so-&gt;so_snd,
	    <span class="enscript-type">struct</span> tcpcb *, tp);

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_TCP_FALLBACK)
		<span class="enscript-keyword">return</span>;

	tp-&gt;t_mpflags &amp;= ~(TMPF_MPTCP_READY|TMPF_MPTCP_TRUE);
	tp-&gt;t_mpflags |= TMPF_TCP_FALLBACK;

	soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_MPSTATUS));
}

<span class="enscript-comment">/*
 * Keepalive helper function
 */</span>
boolean_t
<span class="enscript-function-name">mptcp_ok_to_keepalive</span>(<span class="enscript-type">struct</span> mptcb *mp_tp)
{
	boolean_t ret = 1;
	VERIFY(mp_tp != NULL);
	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt;= MPTCPS_CLOSE_WAIT) {
		ret = 0;
	}
	MPT_UNLOCK(mp_tp);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * MPTCP t_maxseg adjustment function
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_adj_mss</span>(<span class="enscript-type">struct</span> tcpcb *tp, boolean_t mtudisc)
{
	<span class="enscript-type">int</span> mss_lower = 0;
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MPTCP_COMPUTE_LEN</span> {				\
	mss_lower = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss_ack_opt);	\
	MPT_LOCK(mp_tp);				\
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)		\
		mss_lower += 2;				\
	<span class="enscript-keyword">else</span>						\
		<span class="enscript-comment">/* adjust to 32-bit boundary + EOL */</span>	\
		mss_lower += 2;				\
	MPT_UNLOCK(mp_tp);				\
}
	<span class="enscript-keyword">if</span> (mp_tp == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * For the first subflow and subsequent subflows, adjust mss for
	 * most common MPTCP option size, for case where tcp_mss is called
	 * during option processing and MTU discovery.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW))) {
		MPTCP_COMPUTE_LEN;
	}

	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN)) {
		MPTCP_COMPUTE_LEN;
	}

	<span class="enscript-keyword">if</span> ((mtudisc) &amp;&amp; (tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)) {
		MPTCP_COMPUTE_LEN;
	}

	<span class="enscript-keyword">return</span> (mss_lower);
}

<span class="enscript-comment">/*
 * Update the pid, upid, uuid of the subflow so, based on parent so
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_update_last_owner</span>(<span class="enscript-type">struct</span> mptsub *mpts, <span class="enscript-type">struct</span> socket *parent_mpso)
{
	<span class="enscript-type">struct</span> socket *subflow_so = mpts-&gt;mpts_socket;
	
	MPTS_LOCK_ASSERT_HELD(mpts);

	socket_lock(subflow_so, 0);
	<span class="enscript-keyword">if</span> ((subflow_so-&gt;last_pid != parent_mpso-&gt;last_pid) ||
		(subflow_so-&gt;last_upid != parent_mpso-&gt;last_upid)) {
		subflow_so-&gt;last_upid = parent_mpso-&gt;last_upid;
		subflow_so-&gt;last_pid = parent_mpso-&gt;last_pid;
		uuid_copy(subflow_so-&gt;last_uuid, parent_mpso-&gt;last_uuid);
	}
	so_update_policy(subflow_so);
	socket_unlock(subflow_so, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_mptcp_subflow</span>(<span class="enscript-type">struct</span> socket *so, mptcp_flow_t *flow, <span class="enscript-type">struct</span> mptsub *mpts)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	tcp_getconninfo(so, &amp;flow-&gt;flow_ci);
	inp = sotoinpcb(so);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0) {
		flow-&gt;flow_src.ss_family = AF_INET6;
		flow-&gt;flow_dst.ss_family = AF_INET6;
		flow-&gt;flow_src.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		flow-&gt;flow_dst.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		SIN6(&amp;flow-&gt;flow_src)-&gt;sin6_port = inp-&gt;in6p_lport;
		SIN6(&amp;flow-&gt;flow_dst)-&gt;sin6_port = inp-&gt;in6p_fport;
		SIN6(&amp;flow-&gt;flow_src)-&gt;sin6_addr = inp-&gt;in6p_laddr;
		SIN6(&amp;flow-&gt;flow_dst)-&gt;sin6_addr = inp-&gt;in6p_faddr;
	} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV4) != 0) {
		flow-&gt;flow_src.ss_family = AF_INET;
		flow-&gt;flow_dst.ss_family = AF_INET;
		flow-&gt;flow_src.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		flow-&gt;flow_dst.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		SIN(&amp;flow-&gt;flow_src)-&gt;sin_port = inp-&gt;inp_lport;
		SIN(&amp;flow-&gt;flow_dst)-&gt;sin_port = inp-&gt;inp_fport;
		SIN(&amp;flow-&gt;flow_src)-&gt;sin_addr = inp-&gt;inp_laddr;
		SIN(&amp;flow-&gt;flow_dst)-&gt;sin_addr = inp-&gt;inp_faddr;
	}
	flow-&gt;flow_len = <span class="enscript-keyword">sizeof</span>(*flow);
	flow-&gt;flow_tcpci_offset = offsetof(mptcp_flow_t, flow_ci);
	flow-&gt;flow_flags = mpts-&gt;mpts_flags;
	flow-&gt;flow_cid = mpts-&gt;mpts_connid;
	flow-&gt;flow_sndnxt = mpts-&gt;mpts_sndnxt;
	flow-&gt;flow_relseq = mpts-&gt;mpts_rel_seq;
	flow-&gt;flow_soerror = mpts-&gt;mpts_soerror;
	flow-&gt;flow_probecnt = mpts-&gt;mpts_probecnt;
	flow-&gt;flow_peerswitch = mpts-&gt;mpts_peerswitch;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
mptcp_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0, f;
	size_t n, len;
	<span class="enscript-type">struct</span> mppcb *mpp;
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">struct</span> socket *so;
	conninfo_mptcp_t mptcpci;
	mptcp_flow_t *flows = NULL;

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	lck_mtx_lock(&amp;mtcbinfo.mppi_lock);
	n = mtcbinfo.mppi_count;
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		lck_mtx_unlock(&amp;mtcbinfo.mppi_lock);
		req-&gt;oldidx = (n + n/8) * <span class="enscript-keyword">sizeof</span>(conninfo_mptcp_t) + 
		    4 * (n + n/8)  * <span class="enscript-keyword">sizeof</span>(mptcp_flow_t);
		<span class="enscript-keyword">return</span> (0);
	}
	TAILQ_FOREACH(mpp, &amp;mtcbinfo.mppi_pcbs, mpp_entry) {
		flows = NULL;
		lck_mtx_lock(&amp;mpp-&gt;mpp_lock);
		VERIFY(mpp-&gt;mpp_flags &amp; MPP_ATTACHED);
		<span class="enscript-keyword">if</span> (mpp-&gt;mpp_flags &amp; MPP_DEFUNCT) {
			lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
			<span class="enscript-keyword">continue</span>;
		}
		mpte = mptompte(mpp);
		VERIFY(mpte != NULL);
		mp_tp = mpte-&gt;mpte_mptcb;
		VERIFY(mp_tp != NULL);

		bzero(&amp;mptcpci, <span class="enscript-keyword">sizeof</span>(mptcpci));
		MPT_LOCK(mp_tp);
		mptcpci.mptcpci_state = mp_tp-&gt;mpt_state;
		mptcpci.mptcpci_flags = mp_tp-&gt;mpt_flags;
		mptcpci.mptcpci_ltoken = mp_tp-&gt;mpt_localtoken;
		mptcpci.mptcpci_rtoken = mp_tp-&gt;mpt_remotetoken;
		mptcpci.mptcpci_notsent_lowat = mp_tp-&gt;mpt_notsent_lowat;
		mptcpci.mptcpci_snduna = mp_tp-&gt;mpt_snduna;
		mptcpci.mptcpci_sndnxt = mp_tp-&gt;mpt_sndnxt;
		mptcpci.mptcpci_sndmax = mp_tp-&gt;mpt_sndmax;
		mptcpci.mptcpci_lidsn = mp_tp-&gt;mpt_local_idsn;
		mptcpci.mptcpci_sndwnd = mp_tp-&gt;mpt_sndwnd;
		mptcpci.mptcpci_rcvnxt = mp_tp-&gt;mpt_rcvnxt;
		mptcpci.mptcpci_rcvatmark = mp_tp-&gt;mpt_rcvatmark;
		mptcpci.mptcpci_ridsn = mp_tp-&gt;mpt_remote_idsn;
		mptcpci.mptcpci_rcvwnd = mp_tp-&gt;mpt_rcvwnd;
		MPT_UNLOCK(mp_tp);

		mptcpci.mptcpci_nflows = mpte-&gt;mpte_numflows;
		mptcpci.mptcpci_mpte_flags = mpte-&gt;mpte_flags;
		mptcpci.mptcpci_mpte_addrid = mpte-&gt;mpte_addrid_last;
		mptcpci.mptcpci_flow_offset =
		    offsetof(conninfo_mptcp_t, mptcpci_flows);

		len = <span class="enscript-keyword">sizeof</span>(*flows) * mpte-&gt;mpte_numflows;
		<span class="enscript-keyword">if</span> (mpte-&gt;mpte_numflows != 0) {
			flows = _MALLOC(len, M_TEMP, M_WAITOK | M_ZERO);
			<span class="enscript-keyword">if</span> (flows == NULL) {
				lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
				<span class="enscript-keyword">break</span>;
			}
			mptcpci.mptcpci_len = <span class="enscript-keyword">sizeof</span>(mptcpci) +
			    <span class="enscript-keyword">sizeof</span>(*flows) * (mptcpci.mptcpci_nflows - 1);
			error = SYSCTL_OUT(req, &amp;mptcpci,
			    <span class="enscript-keyword">sizeof</span>(mptcpci) - <span class="enscript-keyword">sizeof</span>(mptcp_flow_t));
		} <span class="enscript-keyword">else</span> {
			mptcpci.mptcpci_len = <span class="enscript-keyword">sizeof</span>(mptcpci);
			error = SYSCTL_OUT(req, &amp;mptcpci, <span class="enscript-keyword">sizeof</span>(mptcpci));
		}   
		<span class="enscript-keyword">if</span> (error) {
			lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
			FREE(flows, M_TEMP);
			<span class="enscript-keyword">break</span>;
		}
		f = 0;
		TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			MPTS_LOCK(mpts);
			so = mpts-&gt;mpts_socket;
			socket_lock(so, 0);
			fill_mptcp_subflow(so, &amp;flows[f], mpts);
			socket_unlock(so, 0);
			MPTS_UNLOCK(mpts);
			f++;
		}
		lck_mtx_unlock(&amp;mpp-&gt;mpp_lock);
		<span class="enscript-keyword">if</span> (flows) {
			error = SYSCTL_OUT(req, flows, len);
			FREE(flows, M_TEMP);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	}
	lck_mtx_unlock(&amp;mtcbinfo.mppi_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_mptcp, OID_AUTO, pcblist, CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, mptcp_pcblist, <span class="enscript-string">&quot;S,conninfo_mptcp_t&quot;</span>, 
    <span class="enscript-string">&quot;List of active MPTCP connections&quot;</span>);

<span class="enscript-comment">/*
 * Check the health of the other subflows and do an mptcp_output if
 * there is no other active or functional subflow at the time of
 * call of this function.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_output_needed</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptsub *to_mpts)
{
	<span class="enscript-type">struct</span> mptsub *from_mpts = NULL;

	MPTE_LOCK_ASSERT_HELD(mpte);

	MPTS_UNLOCK(to_mpts);
	
	from_mpts = mpte-&gt;mpte_active_sub; 

	<span class="enscript-keyword">if</span> (from_mpts == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_needed</span>;

	MPTS_LOCK(from_mpts);

	<span class="enscript-keyword">if</span> ((from_mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTED) ||
	    (from_mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTING)) {
		MPTS_UNLOCK(from_mpts);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">output_needed</span>;
	}

	MPTS_UNLOCK(from_mpts);
	MPTS_LOCK(to_mpts);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">output_needed</span>:	
	mptcp_output(mpte);	
	MPTS_LOCK(to_mpts);
}

<span class="enscript-comment">/*
 * Set notsent lowat mark on the MPTCB
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_set_notsent_lowat</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_mppcb-&gt;mpp_flags &amp; MPP_ATTACHED)
		mp_tp = mpte-&gt;mpte_mptcb;

	<span class="enscript-keyword">if</span> (mp_tp)
		mp_tp-&gt;mpt_notsent_lowat = optval;
	<span class="enscript-keyword">else</span>
		error = EINVAL;

	<span class="enscript-keyword">return</span> error;	
}

u_int32_t
<span class="enscript-function-name">mptcp_get_notsent_lowat</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;

	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_mppcb-&gt;mpp_flags &amp; MPP_ATTACHED)
		mp_tp = mpte-&gt;mpte_mptcb;

	<span class="enscript-keyword">if</span> (mp_tp)
		<span class="enscript-keyword">return</span> mp_tp-&gt;mpt_notsent_lowat;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>                             
<span class="enscript-function-name">mptcp_notsent_lowat_check</span>(<span class="enscript-type">struct</span> socket *so) {
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">struct</span> mppcb *mpp;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">struct</span> mptsub *mpts;

	<span class="enscript-type">int</span> notsent = 0;

	mpp = sotomppcb(so);
	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		<span class="enscript-keyword">return</span> (0);
	}

	mpte = mptompte(mpp);
	mp_tp = mpte-&gt;mpte_mptcb;

	MPT_LOCK(mp_tp);
	notsent = so-&gt;so_snd.sb_cc;

	<span class="enscript-keyword">if</span> ((notsent == 0) ||
	    ((notsent - (mp_tp-&gt;mpt_sndnxt - mp_tp-&gt;mpt_snduna)) &lt;=
	    mp_tp-&gt;mpt_notsent_lowat)) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: &quot;</span>
		    <span class="enscript-string">&quot;lowat %d notsent %d actual %d \n&quot;</span>,
		    mp_tp-&gt;mpt_notsent_lowat, notsent,
		    notsent - (mp_tp-&gt;mpt_sndnxt - mp_tp-&gt;mpt_snduna)),
		    MPTCP_SENDER_DBG , MPTCP_LOGLVL_VERBOSE);
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">return</span> (1);
	}
	MPT_UNLOCK(mp_tp);

	<span class="enscript-comment">/* When Nagle's algorithm is not disabled, it is better
	 * to wakeup the client even before there is atleast one
	 * maxseg of data to write.
	 */</span>
	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-type">int</span> retval = 0;
		MPTS_LOCK(mpts);
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE) {
			<span class="enscript-type">struct</span> socket *subf_so = mpts-&gt;mpts_socket;
			socket_lock(subf_so, 0);
			<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(sotoinpcb(subf_so));
			
			notsent = so-&gt;so_snd.sb_cc -
			   (tp-&gt;snd_nxt - tp-&gt;snd_una);
			
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_NODELAY) == 0 &amp;&amp;
			    notsent &gt; 0 &amp;&amp; (notsent &lt;= (<span class="enscript-type">int</span>)tp-&gt;t_maxseg)) {
				retval = 1;
			}
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: lowat %d notsent %d&quot;</span>
			    <span class="enscript-string">&quot; nodelay false \n&quot;</span>,
			    mp_tp-&gt;mpt_notsent_lowat, notsent),
			    MPTCP_SENDER_DBG , MPTCP_LOGLVL_VERBOSE);
			socket_unlock(subf_so, 0);
			MPTS_UNLOCK(mpts);
			<span class="enscript-keyword">return</span> (retval);
		}
		MPTS_UNLOCK(mpts);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_get_rtt_measurement</span>(<span class="enscript-type">struct</span> mptsub *mpts, <span class="enscript-type">struct</span> mptses *mpte)
{
	MPTE_LOCK_ASSERT_HELD(mpte);
	MPTS_LOCK_ASSERT_HELD(mpts);

	<span class="enscript-type">struct</span> socket *subflow_so = mpts-&gt;mpts_socket;
	socket_lock(subflow_so, 0);
	mpts-&gt;mpts_srtt = (intotcpcb(sotoinpcb(subflow_so)))-&gt;t_srtt;
	mpts-&gt;mpts_rxtcur = (intotcpcb(sotoinpcb(subflow_so)))-&gt;t_rxtcur;
	socket_unlock(subflow_so, 0);
}

<span class="enscript-comment">/* Using Symptoms Advisory to detect poor WiFi or poor Cell */</span>
<span class="enscript-type">static</span> kern_ctl_ref mptcp_kern_ctrl_ref = NULL;
<span class="enscript-type">static</span> uint32_t mptcp_kern_skt_inuse = 0;
symptoms_advisory_t mptcp_advisory;

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">mptcp_symptoms_ctl_connect</span>(kern_ctl_ref kctlref, <span class="enscript-type">struct</span> sockaddr_ctl *sac,
	<span class="enscript-type">void</span> **unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">sac</span>, <span class="enscript-variable-name">unitinfo</span>)
	<span class="enscript-comment">/*
	 * We don't need to do anything here. But we can atleast ensure
	 * only one user opens the MPTCP_KERN_CTL_NAME control socket.
	 */</span>
	<span class="enscript-keyword">if</span> (OSCompareAndSwap(0, 1, &amp;mptcp_kern_skt_inuse))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (EALREADY);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">mptcp_symptoms_ctl_disconnect</span>(kern_ctl_ref kctlref, u_int32_t kcunit,
	<span class="enscript-type">void</span> *unitinfo)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">kcunit</span>, <span class="enscript-variable-name">unitinfo</span>)
	<span class="enscript-keyword">if</span> (OSCompareAndSwap(1, 0, &amp;mptcp_kern_skt_inuse)) {
		<span class="enscript-comment">/* TBD needs to be locked if the size grows more than an int */</span>
		bzero(&amp;mptcp_advisory, <span class="enscript-keyword">sizeof</span>(mptcp_advisory));
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">mptcp_symptoms_ctl_send</span>(kern_ctl_ref kctlref, u_int32_t kcunit, <span class="enscript-type">void</span> *unitinfo,
       mbuf_t m, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kctlref</span>, <span class="enscript-variable-name">kcunit</span>, <span class="enscript-variable-name">unitinfo</span>, <span class="enscript-variable-name">flags</span>)
	symptoms_advisory_t     *sa = NULL;

	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; <span class="enscript-keyword">sizeof</span>(*sa)) {
		mbuf_freem(m);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (mbuf_len(m) &gt;= <span class="enscript-keyword">sizeof</span>(*sa))
		sa = mbuf_data(m);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (mptcp_advisory.sa_nwk_status_int != sa-&gt;sa_nwk_status_int) {
		<span class="enscript-comment">/*
		 * we could use this notification to notify all mptcp pcbs
		 * of the change in network status. But its difficult to
		 * define if sending REMOVE_ADDR or MP_PRIO is appropriate
		 * given that these are only soft indicators of the network
		 * state. Leaving this as TBD for now.
		 */</span>
	}

	<span class="enscript-keyword">if</span> (sa-&gt;sa_nwk_status != SYMPTOMS_ADVISORY_NOCOMMENT) {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: %s wifi %d,%d cell %d,%d\n&quot;</span>,
		    __func__, sa-&gt;sa_wifi_status, mptcp_advisory.sa_wifi_status,
		    sa-&gt;sa_cell_status, mptcp_advisory.sa_cell_status),
		    MPTCP_SOCKET_DBG | MPTCP_EVENTS_DBG,
		    MPTCP_LOGLVL_LOG);

		<span class="enscript-keyword">if</span> ((sa-&gt;sa_wifi_status &amp;
		    (SYMPTOMS_ADVISORY_WIFI_BAD | SYMPTOMS_ADVISORY_WIFI_OK)) !=
		    (SYMPTOMS_ADVISORY_WIFI_BAD | SYMPTOMS_ADVISORY_WIFI_OK)) {
			mptcp_advisory.sa_wifi_status = sa-&gt;sa_wifi_status;
		}

		<span class="enscript-keyword">if</span> ((sa-&gt;sa_cell_status &amp;
		    (SYMPTOMS_ADVISORY_CELL_BAD | SYMPTOMS_ADVISORY_CELL_OK)) !=
		    (SYMPTOMS_ADVISORY_CELL_BAD | SYMPTOMS_ADVISORY_CELL_OK)) {
			mptcp_advisory.sa_cell_status = sa-&gt;sa_cell_status;
		}
	} <span class="enscript-keyword">else</span> {
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Events: %s NOCOMMENT &quot;</span>
		    <span class="enscript-string">&quot;wifi %d cell %d\n&quot;</span>, __func__,
		    mptcp_advisory.sa_wifi_status,
		    mptcp_advisory.sa_cell_status),
		    MPTCP_SOCKET_DBG | MPTCP_EVENTS_DBG, MPTCP_LOGLVL_LOG);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_control_register</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* Set up the advisory control socket */</span>
	<span class="enscript-type">struct</span> kern_ctl_reg mptcp_kern_ctl;

	bzero(&amp;mptcp_kern_ctl, <span class="enscript-keyword">sizeof</span>(mptcp_kern_ctl));
	strlcpy(mptcp_kern_ctl.ctl_name, MPTCP_KERN_CTL_NAME,
	    <span class="enscript-keyword">sizeof</span>(mptcp_kern_ctl.ctl_name));
	mptcp_kern_ctl.ctl_connect = mptcp_symptoms_ctl_connect;
	mptcp_kern_ctl.ctl_disconnect = mptcp_symptoms_ctl_disconnect;
	mptcp_kern_ctl.ctl_send = mptcp_symptoms_ctl_send;
	mptcp_kern_ctl.ctl_flags = CTL_FLAG_PRIVILEGED;

	(<span class="enscript-type">void</span>)ctl_register(&amp;mptcp_kern_ctl, &amp;mptcp_kern_ctrl_ref);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_is_wifi_unusable</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* a false return val indicates there is no info or wifi is ok */</span>
	<span class="enscript-keyword">return</span> (mptcp_advisory.sa_wifi_status &amp; SYMPTOMS_ADVISORY_WIFI_BAD);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_is_cell_unusable</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* a false return val indicates there is no info or cell is ok */</span>
	<span class="enscript-keyword">return</span> (mptcp_advisory.sa_cell_status &amp; SYMPTOMS_ADVISORY_CELL_BAD);
}

<span class="enscript-type">struct</span> mptsub*
<span class="enscript-function-name">mptcp_use_symptoms_hints</span>(<span class="enscript-type">struct</span> mptsub* best, <span class="enscript-type">struct</span> mptsub *second_best)
{
	<span class="enscript-type">struct</span> mptsub *cellsub = NULL;
	<span class="enscript-type">struct</span> mptsub *wifisub = NULL;
	<span class="enscript-type">struct</span> mptsub *wiredsub = NULL;

	VERIFY ((best != NULL) &amp;&amp; (second_best != NULL));

	<span class="enscript-keyword">if</span> (!mptcp_use_symptomsd)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> (!mptcp_kern_skt_inuse)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/*
	 * There could be devices with more than one wifi interface or 
	 * more than one wired or cell interfaces. 
	 * TBD: SymptomsD is unavailable on such platforms as of now.
	 * Try to prefer best when possible in general.
	 * Also, SymptomsD sends notifications about wifi only when it
	 * is primary.
	 */</span>
	<span class="enscript-keyword">if</span> (best-&gt;mpts_linktype &amp; MPTSL_WIFI)
		wifisub = best;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (best-&gt;mpts_linktype &amp; MPTSL_CELL)
		cellsub = best;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (best-&gt;mpts_linktype &amp; MPTSL_WIRED)
		wiredsub = best;

	<span class="enscript-comment">/*
	 * On platforms with wired paths, don't use hints about wifi or cell.
	 * Currently, SymptomsD is not available on platforms with wired paths.
	 */</span>
	<span class="enscript-keyword">if</span> (wiredsub)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> ((wifisub == NULL) &amp;&amp; (second_best-&gt;mpts_linktype &amp; MPTSL_WIFI))
		wifisub = second_best;

	<span class="enscript-keyword">if</span> ((cellsub == NULL) &amp;&amp; (second_best-&gt;mpts_linktype &amp; MPTSL_CELL))
		cellsub = second_best;

	<span class="enscript-keyword">if</span> ((wiredsub == NULL) &amp;&amp; (second_best-&gt;mpts_linktype &amp; MPTSL_WIRED))
		wiredsub = second_best;

	<span class="enscript-keyword">if</span> ((wifisub == best) &amp;&amp; mptcp_is_wifi_unusable()) {
		tcpstat.tcps_mp_sel_symtomsd++;
		<span class="enscript-keyword">if</span> (mptcp_is_cell_unusable()) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: SymptomsD hint&quot;</span>
			    <span class="enscript-string">&quot; suggests both Wifi and Cell are bad. Wired %s.&quot;</span>,
			    (wiredsub == NULL) ? <span class="enscript-string">&quot;none&quot;</span> : <span class="enscript-string">&quot;present&quot;</span>),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">return</span> (wiredsub);
		} <span class="enscript-keyword">else</span> {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: SymptomsD hint&quot;</span>
			    <span class="enscript-string">&quot; suggests Wifi bad, Cell good. Wired %s.&quot;</span>,
			    (wiredsub == NULL) ? <span class="enscript-string">&quot;none&quot;</span> : <span class="enscript-string">&quot;present&quot;</span>),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">return</span> ((wiredsub != NULL) ? wiredsub : cellsub);
		}
	}

	<span class="enscript-keyword">if</span> ((cellsub == best) &amp;&amp; (mptcp_is_cell_unusable())) {
		tcpstat.tcps_mp_sel_symtomsd++;
		<span class="enscript-keyword">if</span> (mptcp_is_wifi_unusable()) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: SymptomsD hint&quot;</span>
			    <span class="enscript-string">&quot; suggests both Cell and Wifi are bad. Wired %s.&quot;</span>,
			    (wiredsub == NULL) ? <span class="enscript-string">&quot;none&quot;</span> : <span class="enscript-string">&quot;present&quot;</span>),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">return</span> (wiredsub);
		} <span class="enscript-keyword">else</span> {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: SymptomsD hint&quot;</span>
			    <span class="enscript-string">&quot; suggests Cell bad, Wifi good. Wired %s.&quot;</span>,
			    (wiredsub == NULL) ? <span class="enscript-string">&quot;none&quot;</span> : <span class="enscript-string">&quot;present&quot;</span>),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">return</span> ((wiredsub != NULL) ? wiredsub : wifisub);
		}
	}

	<span class="enscript-comment">/* little is known about the state of the network or wifi is good */</span>
	<span class="enscript-keyword">return</span> (NULL); 
}
</pre>
<hr />
</body></html>