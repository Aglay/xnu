<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in_rmx.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in_rmx.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright 1994, 1995 Massachusetts Institute of Technology
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby
 * granted, provided that both the above copyright notice and this
 * permission notice appear in all copies, that both the above
 * copyright notice and this permission notice appear in all
 * supporting documentation, and that the name of M.I.T. not be used
 * in advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.  M.I.T. makes
 * no representations about the suitability of this software for any
 * purpose.  It is provided &quot;as is&quot; without express or implied
 * warranty.
 *
 * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS
 * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT
 * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */</span>

<span class="enscript-comment">/*
 * This code does two things necessary for the enhanced TCP metrics to
 * function in a useful manner:
 *  1) It marks all non-host routes as `cloning', thus ensuring that
 *     every actual reference to such a route actually gets turned
 *     into a reference to a host route to the specific destination
 *     requested.
 *  2) When such routes lose all their references, it arranges for them
 *     to be deleted in some random collection of circumstances, so that
 *     a large quantity of stale routing data is not kept in kernel memory
 *     indefinitely.  See in_rtqtimo() below for the exact mechanism.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_arp.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tvtohz</span>(<span class="enscript-type">struct</span> timeval *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> in_rtqtimo_run;		<span class="enscript-comment">/* in_rtqtimo is scheduled to run */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_rtqtimo</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_sched_rtqtimo</span>(<span class="enscript-type">struct</span> timeval *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">in_addroute</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> radix_node_head *,
    <span class="enscript-type">struct</span> radix_node *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">in_deleteroute</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *,
    <span class="enscript-type">struct</span> radix_node_head *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">in_matroute</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> radix_node_head *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">in_matroute_args</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> radix_node_head *,
    rn_matchf_t *f, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_clsroute</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">struct</span> radix_node_head *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_rtqkill</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_ifadownkill</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPRF_OURS</span>		RTF_PROTO3	<span class="enscript-comment">/* set on routes we manage */</span>

<span class="enscript-comment">/*
 * Do what we need to do when inserting a route.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">in_addroute</span>(<span class="enscript-type">void</span> *v_arg, <span class="enscript-type">void</span> *n_arg, <span class="enscript-type">struct</span> radix_node_head *head,
    <span class="enscript-type">struct</span> radix_node *treenodes)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)treenodes;
	<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)rt_key(rt);
	<span class="enscript-type">struct</span> radix_node *ret;
	<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];
	uint32_t flags = rt-&gt;rt_flags;
	boolean_t verbose = (rt_verbose &gt; 1);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (verbose)
		rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));

	<span class="enscript-comment">/*
	 * For IP, all unicast non-host routes are automatically cloning.
	 */</span>
	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(sin-&gt;sin_addr.s_addr)))
		rt-&gt;rt_flags |= RTF_MULTICAST;

	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; (RTF_HOST | RTF_CLONING | RTF_MULTICAST)))
		rt-&gt;rt_flags |= RTF_PRCLONING;

	<span class="enscript-comment">/*
	 * A little bit of help for both IP output and input:
	 *   For host routes, we make sure that RTF_BROADCAST
	 *   is set for anything that looks like a broadcast address.
	 *   This way, we can avoid an expensive call to in_broadcast()
	 *   in ip_output() most of the time (because the route passed
	 *   to ip_output() is almost always a host route).
	 *
	 *   We also do the same for local addresses, with the thought
	 *   that this might one day be used to speed up ip_input().
	 *
	 * We also mark routes to multicast addresses as such, because
	 * it's easy to do and might be useful (but this is much more
	 * dubious since it's so easy to inspect the address).  (This
	 * is done above.)
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_HOST) {
		<span class="enscript-keyword">if</span> (in_broadcast(sin-&gt;sin_addr, rt-&gt;rt_ifp)) {
			rt-&gt;rt_flags |= RTF_BROADCAST;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(rt);
			IFA_LOCK_SPIN(rt-&gt;rt_ifa);
			<span class="enscript-keyword">if</span> (satosin(rt-&gt;rt_ifa-&gt;ifa_addr)-&gt;sin_addr.s_addr ==
			    sin-&gt;sin_addr.s_addr)
				rt-&gt;rt_flags |= RTF_LOCAL;
			IFA_UNLOCK(rt-&gt;rt_ifa);
		}
	}

	<span class="enscript-keyword">if</span> (!rt-&gt;rt_rmx.rmx_mtu &amp;&amp; !(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU) &amp;&amp;
	    rt-&gt;rt_ifp)
		rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu;

	ret = rn_addroute(v_arg, n_arg, head, treenodes);
	<span class="enscript-keyword">if</span> (ret == NULL &amp;&amp; (rt-&gt;rt_flags &amp; RTF_HOST)) {
		<span class="enscript-type">struct</span> rtentry *rt2;
		<span class="enscript-comment">/*
		 * We are trying to add a host route, but can't.
		 * Find out if it is because of an
		 * ARP entry and delete it if so.
		 */</span>
		rt2 = rtalloc1_scoped_locked(rt_key(rt), 0,
		    RTF_CLONING | RTF_PRCLONING, sin_get_ifscope(rt_key(rt)));
		<span class="enscript-keyword">if</span> (rt2 != NULL) {
			<span class="enscript-type">char</span> dbufc[MAX_IPv4_STR_LEN];

			RT_LOCK(rt2);
			<span class="enscript-keyword">if</span> (verbose)
				rt_str(rt2, dbufc, <span class="enscript-keyword">sizeof</span> (dbufc), NULL, 0);

			<span class="enscript-keyword">if</span> ((rt2-&gt;rt_flags &amp; RTF_LLINFO) &amp;&amp;
			    (rt2-&gt;rt_flags &amp; RTF_HOST) &amp;&amp;
			    rt2-&gt;rt_gateway != NULL &amp;&amp;
			    rt2-&gt;rt_gateway-&gt;sa_family == AF_LINK) {
				<span class="enscript-keyword">if</span> (verbose) {
					log(LOG_DEBUG, <span class="enscript-string">&quot;%s: unable to insert &quot;</span>
					    <span class="enscript-string">&quot;route to %s;%s, flags=%b, due to &quot;</span>
					    <span class="enscript-string">&quot;existing ARP route %s-&gt;%s &quot;</span>
					    <span class="enscript-string">&quot;flags=%b, attempting to delete\n&quot;</span>,
					    __func__, dbuf,
					    (rt-&gt;rt_ifp != NULL) ?
					    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
					    rt-&gt;rt_flags, RTF_BITS, dbufc,
					    (rt2-&gt;rt_ifp != NULL) ?
					    rt2-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
					    rt2-&gt;rt_flags, RTF_BITS);
				}
				<span class="enscript-comment">/*
				 * Safe to drop rt_lock and use rt_key,
				 * rt_gateway, since holding rnh_lock here
				 * prevents another thread from calling
				 * rt_setgate() on this route.
				 */</span>
				RT_UNLOCK(rt2);
				(<span class="enscript-type">void</span>) rtrequest_locked(RTM_DELETE, rt_key(rt2),
				    rt2-&gt;rt_gateway, rt_mask(rt2),
				    rt2-&gt;rt_flags, NULL);
				ret = rn_addroute(v_arg, n_arg, head,
				    treenodes);
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(rt2);
			}
			rtfree_locked(rt2);
		}
	}

	<span class="enscript-keyword">if</span> (!verbose)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">if</span> (ret != NULL) {
		<span class="enscript-keyword">if</span> (flags != rt-&gt;rt_flags) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to %s-&gt;%s-&gt;%s inserted, &quot;</span>
			    <span class="enscript-string">&quot;oflags=%b, flags=%b\n&quot;</span>, __func__,
			    dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
			    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, flags, RTF_BITS,
			    rt-&gt;rt_flags, RTF_BITS);
		} <span class="enscript-keyword">else</span> {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to %s-&gt;%s-&gt;%s inserted, &quot;</span>
			    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, __func__, dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    rt-&gt;rt_flags, RTF_BITS);
		}
	} <span class="enscript-keyword">else</span> {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: unable to insert route to %s-&gt;%s-&gt;%s, &quot;</span>
		    <span class="enscript-string">&quot;flags=%b, already exists\n&quot;</span>, __func__, dbuf, gbuf,
		    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
		    rt-&gt;rt_flags, RTF_BITS);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">in_deleteroute</span>(<span class="enscript-type">void</span> *v_arg, <span class="enscript-type">void</span> *netmask_arg, <span class="enscript-type">struct</span> radix_node_head *head)
{
	<span class="enscript-type">struct</span> radix_node *rn;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	rn = rn_delete(v_arg, netmask_arg, head);
	<span class="enscript-keyword">if</span> (rt_verbose &gt; 1 &amp;&amp; rn != NULL) {
		<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];
		<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;

		RT_LOCK(rt);
		rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to %s-&gt;%s-&gt;%s deleted, &quot;</span>
		    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, __func__, dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
		    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, rt-&gt;rt_flags, RTF_BITS);
		RT_UNLOCK(rt);
	}
	<span class="enscript-keyword">return</span> (rn);
}

<span class="enscript-comment">/*
 * Validate (unexpire) an expiring AF_INET route.
 */</span>
<span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">in_validate</span>(<span class="enscript-type">struct</span> radix_node *rn)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;

	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/* This is first reference? */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_refcnt == 0) {
		<span class="enscript-keyword">if</span> (rt_verbose &gt; 2) {
			<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];

			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to %s-&gt;%s-&gt;%s validated, &quot;</span>
			    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, __func__, dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    rt-&gt;rt_flags, RTF_BITS);
		}

		<span class="enscript-comment">/*
		 * It's one of ours; unexpire it.  If the timer is already
		 * scheduled, let it run later as it won't re-arm itself
		 * if there's nothing to do.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTPRF_OURS) {
			rt-&gt;rt_flags &amp;= ~RTPRF_OURS;
			rt_setexpire(rt, 0);
		}
	}
	<span class="enscript-keyword">return</span> (rn);
}

<span class="enscript-comment">/*
 * Similar to in_matroute_args except without the leaf-matching parameters.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">in_matroute</span>(<span class="enscript-type">void</span> *v_arg, <span class="enscript-type">struct</span> radix_node_head *head)
{
	<span class="enscript-keyword">return</span> (in_matroute_args(v_arg, head, NULL, NULL));
}

<span class="enscript-comment">/*
 * This code is the inverse of in_clsroute: on first reference, if we
 * were managing the route, stop doing so and set the expiration timer
 * back off again.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> radix_node *
<span class="enscript-function-name">in_matroute_args</span>(<span class="enscript-type">void</span> *v_arg, <span class="enscript-type">struct</span> radix_node_head *head,
    rn_matchf_t *f, <span class="enscript-type">void</span> *w)
{
	<span class="enscript-type">struct</span> radix_node *rn = rn_match_args(v_arg, head, f, w);

	<span class="enscript-keyword">if</span> (rn != NULL) {
		RT_LOCK_SPIN((<span class="enscript-type">struct</span> rtentry *)rn);
		in_validate(rn);
		RT_UNLOCK((<span class="enscript-type">struct</span> rtentry *)rn);
	}
	<span class="enscript-keyword">return</span> (rn);
}

<span class="enscript-comment">/* one hour is ``really old'' */</span>
<span class="enscript-type">static</span> uint32_t rtq_reallyold = 60*60;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_ip, IPCTL_RTEXPIRE, rtexpire,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;rtq_reallyold, 0,
	<span class="enscript-string">&quot;Default expiration time on dynamically learned routes&quot;</span>);

<span class="enscript-comment">/* never automatically crank down to less */</span>
<span class="enscript-type">static</span> uint32_t rtq_minreallyold = 10;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_ip, IPCTL_RTMINEXPIRE, rtminexpire,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;rtq_minreallyold, 0,
	<span class="enscript-string">&quot;Minimum time to attempt to hold onto dynamically learned routes&quot;</span>);

<span class="enscript-comment">/* 128 cached routes is ``too many'' */</span>
<span class="enscript-type">static</span> uint32_t rtq_toomany = 128;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_ip, IPCTL_RTMAXCACHE, rtmaxcache,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;rtq_toomany, 0,
	<span class="enscript-string">&quot;Upper limit on dynamically learned routes&quot;</span>);

<span class="enscript-comment">/*
 * On last reference drop, mark the route as belong to us so that it can be
 * timed out.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_clsroute</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">struct</span> radix_node_head *head)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">head</span>)
	<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	boolean_t verbose = (rt_verbose &gt; 1);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP))
		<span class="enscript-keyword">return</span>;		<span class="enscript-comment">/* prophylactic measures */</span>

	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_LLINFO | RTF_HOST)) != RTF_HOST)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTPRF_OURS)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; (RTF_WASCLONED | RTF_DYNAMIC)))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (verbose)
		rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));

	<span class="enscript-comment">/*
	 * Delete the route immediately if RTF_DELCLONE is set or
	 * if route caching is disabled (rtq_reallyold set to 0).
	 * Otherwise, let it expire and be deleted by in_rtqkill().
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_DELCLONE) || rtq_reallyold == 0) {
		<span class="enscript-type">int</span> err;

		<span class="enscript-keyword">if</span> (verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: deleting route to %s-&gt;%s-&gt;%s, &quot;</span>
			    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, __func__, dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    rt-&gt;rt_flags, RTF_BITS);
		}
		<span class="enscript-comment">/*
		 * Delete the route from the radix tree but since we are
		 * called when the route's reference count is 0, don't
		 * deallocate it until we return from this routine by
		 * telling rtrequest that we're interested in it.
		 * Safe to drop rt_lock and use rt_key, rt_gateway since
		 * holding rnh_lock here prevents another thread from
		 * calling rt_setgate() on this route.
		 */</span>
		RT_UNLOCK(rt);
		err = rtrequest_locked(RTM_DELETE, rt_key(rt),
		    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, &amp;rt);
		<span class="enscript-keyword">if</span> (err == 0) {
			<span class="enscript-comment">/* Now let the caller free it */</span>
			RT_LOCK(rt);
			RT_REMREF_LOCKED(rt);
		} <span class="enscript-keyword">else</span> {
			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> (!verbose)
				rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf),
				    gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			log(LOG_ERR, <span class="enscript-string">&quot;%s: error deleting route to &quot;</span>
			    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags=%b, err=%d\n&quot;</span>, __func__,
			    dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
			    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, rt-&gt;rt_flags,
			    RTF_BITS, err);
		}
	} <span class="enscript-keyword">else</span> {
		uint64_t timenow;

		timenow = net_uptime();
		rt-&gt;rt_flags |= RTPRF_OURS;
		rt_setexpire(rt, timenow + rtq_reallyold);

		<span class="enscript-keyword">if</span> (verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to %s-&gt;%s-&gt;%s invalidated, &quot;</span>
			    <span class="enscript-string">&quot;flags=%b, expire=T+%u\n&quot;</span>, __func__, dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    rt-&gt;rt_flags, RTF_BITS, rt-&gt;rt_expire - timenow);
		}

		<span class="enscript-comment">/* We have at least one entry; arm the timer if not already */</span>
		in_sched_rtqtimo(NULL);
	}
}

<span class="enscript-type">struct</span> rtqk_arg {
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">int</span> updating;
	<span class="enscript-type">int</span> draining;
	uint32_t killed;
	uint32_t found;
	uint64_t nextstop;
};

<span class="enscript-comment">/*
 * Get rid of old routes.  When draining, this deletes everything, even when
 * the timeout is not expired yet.  When updating, this makes sure that
 * nothing has a timeout longer than the current value of rtq_reallyold.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in_rtqkill</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *rock)
{
	<span class="enscript-type">struct</span> rtqk_arg *ap = rock;
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	boolean_t verbose = (rt_verbose &gt; 1);
	uint64_t timenow;
	<span class="enscript-type">int</span> err;

	timenow = net_uptime();
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTPRF_OURS) {
		<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];

		<span class="enscript-keyword">if</span> (verbose)
			rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));

		ap-&gt;found++;
		VERIFY(rt-&gt;rt_expire == 0 || rt-&gt;rt_rmx.rmx_expire != 0);
		VERIFY(rt-&gt;rt_expire != 0 || rt-&gt;rt_rmx.rmx_expire == 0);
		<span class="enscript-keyword">if</span> (ap-&gt;draining || rt-&gt;rt_expire &lt;= timenow) {
			<span class="enscript-keyword">if</span> (rt-&gt;rt_refcnt &gt; 0) {
				panic(<span class="enscript-string">&quot;%s: route %p marked with RTPRF_OURS &quot;</span>
				    <span class="enscript-string">&quot;with non-zero refcnt (%u)&quot;</span>, __func__,
				    rt, rt-&gt;rt_refcnt);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-keyword">if</span> (verbose) {
				log(LOG_DEBUG, <span class="enscript-string">&quot;%s: deleting route to &quot;</span>
				    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags=%b, draining=%d\n&quot;</span>,
				    __func__, dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, rt-&gt;rt_flags,
				    RTF_BITS, ap-&gt;draining);
			}
			RT_ADDREF_LOCKED(rt);	<span class="enscript-comment">/* for us to free below */</span>
			<span class="enscript-comment">/*
			 * Delete this route since we're done with it;
			 * the route may be freed afterwards, so we
			 * can no longer refer to 'rt' upon returning
			 * from rtrequest().  Safe to drop rt_lock and
			 * use rt_key, rt_gateway since holding rnh_lock
			 * here prevents another thread from calling
			 * rt_setgate() on this route.
			 */</span>
			RT_UNLOCK(rt);
			err = rtrequest_locked(RTM_DELETE, rt_key(rt),
			    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
			<span class="enscript-keyword">if</span> (err != 0) {
				RT_LOCK(rt);
				<span class="enscript-keyword">if</span> (!verbose)
					rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf),
					    gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
				log(LOG_ERR, <span class="enscript-string">&quot;%s: error deleting route to &quot;</span>
				    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags=%b, err=%d\n&quot;</span>, __func__,
				    dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
				    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, rt-&gt;rt_flags,
				    RTF_BITS, err);
				RT_UNLOCK(rt);
			} <span class="enscript-keyword">else</span> {
				ap-&gt;killed++;
			}
			rtfree_locked(rt);
		} <span class="enscript-keyword">else</span> {
			uint64_t expire = (rt-&gt;rt_expire - timenow);

			<span class="enscript-keyword">if</span> (ap-&gt;updating &amp;&amp; expire &gt; rtq_reallyold) {
				rt_setexpire(rt, timenow + rtq_reallyold);
				<span class="enscript-keyword">if</span> (verbose) {
					log(LOG_DEBUG, <span class="enscript-string">&quot;%s: route to &quot;</span>
					    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags=%b, adjusted &quot;</span>
					    <span class="enscript-string">&quot;expire=T+%u (was T+%u)\n&quot;</span>,
					    __func__, dbuf, gbuf,
					    (rt-&gt;rt_ifp != NULL) ?
					    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
					    rt-&gt;rt_flags, RTF_BITS,
					    (rt-&gt;rt_expire - timenow), expire);
				}
			}
			ap-&gt;nextstop = lmin(ap-&gt;nextstop, rt-&gt;rt_expire);
			RT_UNLOCK(rt);
		}
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTQ_TIMEOUT</span>	60*10	<span class="enscript-comment">/* run no less than once every ten minutes */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> rtq_timeout = RTQ_TIMEOUT;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_rtqtimo</span>(<span class="enscript-type">void</span> *targ)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">targ</span>)
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> rtqk_arg arg;
	<span class="enscript-type">struct</span> timeval atv;
	<span class="enscript-type">static</span> uint64_t last_adjusted_timeout = 0;
	boolean_t verbose = (rt_verbose &gt; 1);
	uint64_t timenow;
	uint32_t ours;

	lck_mtx_lock(rnh_lock);
	rnh = rt_tables[AF_INET];
	VERIFY(rnh != NULL);

	<span class="enscript-comment">/* Get the timestamp after we acquire the lock for better accuracy */</span>
	timenow = net_uptime();
	<span class="enscript-keyword">if</span> (verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: initial nextstop is T+%u seconds\n&quot;</span>,
		    __func__, rtq_timeout);
	}
	bzero(&amp;arg, <span class="enscript-keyword">sizeof</span> (arg));
	arg.rnh = rnh;
	arg.nextstop = timenow + rtq_timeout;
	rnh-&gt;rnh_walktree(rnh, in_rtqkill, &amp;arg);
	<span class="enscript-keyword">if</span> (verbose) {
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: found %u, killed %u\n&quot;</span>, __func__,
		    arg.found, arg.killed);
	}
	<span class="enscript-comment">/*
	 * Attempt to be somewhat dynamic about this:
	 * If there are ``too many'' routes sitting around taking up space,
	 * then crank down the timeout, and see if we can't make some more
	 * go away.  However, we make sure that we will never adjust more
	 * than once in rtq_timeout seconds, to keep from cranking down too
	 * hard.
	 */</span>
	ours = (arg.found - arg.killed);
	<span class="enscript-keyword">if</span> (ours &gt; rtq_toomany &amp;&amp;
	    ((timenow - last_adjusted_timeout) &gt;= (uint64_t)rtq_timeout) &amp;&amp;
	    rtq_reallyold &gt; rtq_minreallyold) {
		rtq_reallyold = 2 * rtq_reallyold / 3;
		<span class="enscript-keyword">if</span> (rtq_reallyold &lt; rtq_minreallyold)
			rtq_reallyold = rtq_minreallyold;

		last_adjusted_timeout = timenow;
		<span class="enscript-keyword">if</span> (verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: adjusted rtq_reallyold to %d &quot;</span>
			    <span class="enscript-string">&quot;seconds\n&quot;</span>, __func__, rtq_reallyold);
		}
		arg.found = arg.killed = 0;
		arg.updating = 1;
		rnh-&gt;rnh_walktree(rnh, in_rtqkill, &amp;arg);
	}

	atv.tv_usec = 0;
	atv.tv_sec = arg.nextstop - timenow;
	<span class="enscript-comment">/* re-arm the timer only if there's work to do */</span>
	in_rtqtimo_run = 0;
	<span class="enscript-keyword">if</span> (ours &gt; 0)
		in_sched_rtqtimo(&amp;atv);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (verbose)
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: not rescheduling timer\n&quot;</span>, __func__);
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_sched_rtqtimo</span>(<span class="enscript-type">struct</span> timeval *atv)
{
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!in_rtqtimo_run) {
		<span class="enscript-type">struct</span> timeval tv;

		<span class="enscript-keyword">if</span> (atv == NULL) {
			tv.tv_usec = 0;
			tv.tv_sec = MAX(rtq_timeout / 10, 1);
			atv = &amp;tv;
		}
		<span class="enscript-keyword">if</span> (rt_verbose &gt; 1) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: timer scheduled in &quot;</span>
			    <span class="enscript-string">&quot;T+%llus.%lluu\n&quot;</span>, __func__,
			    (uint64_t)atv-&gt;tv_sec, (uint64_t)atv-&gt;tv_usec);
		}
		in_rtqtimo_run = 1;
		timeout(in_rtqtimo, NULL, tvtohz(atv));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_rtqdrain</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> rtqk_arg arg;

	<span class="enscript-keyword">if</span> (rt_verbose &gt; 1)
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: draining routes\n&quot;</span>, __func__);

	lck_mtx_lock(rnh_lock);
	rnh = rt_tables[AF_INET];
	VERIFY(rnh != NULL);
	bzero(&amp;arg, <span class="enscript-keyword">sizeof</span> (arg));
	arg.rnh = rnh;
	arg.draining = 1;
	rnh-&gt;rnh_walktree(rnh, in_rtqkill, &amp;arg);
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-comment">/*
 * Initialize our routing tree.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_inithead</span>(<span class="enscript-type">void</span> **head, <span class="enscript-type">int</span> off)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh;

	<span class="enscript-comment">/* If called from route_init(), make sure it is exactly once */</span>
	VERIFY(head != (<span class="enscript-type">void</span> **)&amp;rt_tables[AF_INET] || *head == NULL);

	<span class="enscript-keyword">if</span> (!rn_inithead(head, off))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * We can get here from nfs_subs.c as well, in which case this
	 * won't be for the real routing table and thus we're done;
	 * this also takes care of the case when we're called more than
	 * once from anywhere but route_init().
	 */</span>
	<span class="enscript-keyword">if</span> (head != (<span class="enscript-type">void</span> **)&amp;rt_tables[AF_INET])
		<span class="enscript-keyword">return</span> (1);	<span class="enscript-comment">/* only do this for the real routing table */</span>

	rnh = *head;
	rnh-&gt;rnh_addaddr = in_addroute;
	rnh-&gt;rnh_deladdr = in_deleteroute;
	rnh-&gt;rnh_matchaddr = in_matroute;
	rnh-&gt;rnh_matchaddr_args = in_matroute_args;
	rnh-&gt;rnh_close = in_clsroute;
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * This zaps old routes when the interface goes down or interface
 * address is deleted.  In the latter case, it deletes static routes
 * that point to this address.  If we don't do this, we may end up
 * using the old address in the future.  The ones we always want to
 * get rid of are things like ARP entries, since the user might down
 * the interface, walk over to a completely different network, and
 * plug back in.
 */</span>
<span class="enscript-type">struct</span> in_ifadown_arg {
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">int</span> del;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in_ifadownkill</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *xap)
{
	<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], gbuf[MAX_IPv4_STR_LEN];
	<span class="enscript-type">struct</span> in_ifadown_arg *ap = xap;
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	boolean_t verbose = (rt_verbose != 0);
	<span class="enscript-type">int</span> err;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifa == ap-&gt;ifa &amp;&amp;
	    (ap-&gt;del || !(rt-&gt;rt_flags &amp; RTF_STATIC))) {
		rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf), gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
		<span class="enscript-keyword">if</span> (verbose) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: deleting route to %s-&gt;%s-&gt;%s, &quot;</span>
			    <span class="enscript-string">&quot;flags=%b\n&quot;</span>, __func__, dbuf, gbuf,
			    (rt-&gt;rt_ifp != NULL) ? rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>,
			    rt-&gt;rt_flags, RTF_BITS);
		}
		RT_ADDREF_LOCKED(rt);	<span class="enscript-comment">/* for us to free below */</span>
		<span class="enscript-comment">/*
		 * We need to disable the automatic prune that happens
		 * in this case in rtrequest() because it will blow
		 * away the pointers that rn_walktree() needs in order
		 * continue our descent.  We will end up deleting all
		 * the routes that rtrequest() would have in any case,
		 * so that behavior is not needed there.  Safe to drop
		 * rt_lock and use rt_key, rt_gateway, since holding
		 * rnh_lock here prevents another thread from calling
		 * rt_setgate() on this route.
		 */</span>
		rt-&gt;rt_flags &amp;= ~(RTF_CLONING | RTF_PRCLONING);
		RT_UNLOCK(rt);
		err = rtrequest_locked(RTM_DELETE, rt_key(rt),
		    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
		<span class="enscript-keyword">if</span> (err != 0) {
			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> (!verbose)
				rt_str(rt, dbuf, <span class="enscript-keyword">sizeof</span> (dbuf),
				    gbuf, <span class="enscript-keyword">sizeof</span> (gbuf));
			log(LOG_ERR, <span class="enscript-string">&quot;%s: error deleting route to &quot;</span>
			    <span class="enscript-string">&quot;%s-&gt;%s-&gt;%s, flags=%b, err=%d\n&quot;</span>, __func__,
			    dbuf, gbuf, (rt-&gt;rt_ifp != NULL) ?
			    rt-&gt;rt_ifp-&gt;if_xname : <span class="enscript-string">&quot;&quot;</span>, rt-&gt;rt_flags,
			    RTF_BITS, err);
			RT_UNLOCK(rt);
		}
		rtfree_locked(rt);
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in_ifadown</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> delete)
{
	<span class="enscript-type">struct</span> in_ifadown_arg arg;
	<span class="enscript-type">struct</span> radix_node_head *rnh;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Holding rnh_lock here prevents the possibility of
	 * ifa from changing (e.g. in_ifinit), so it is safe
	 * to access its ifa_addr without locking.
	 */</span>
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-comment">/* trigger route cache reevaluation */</span>
	routegenid_inet_update();

	arg.rnh = rnh = rt_tables[AF_INET];
	arg.ifa = ifa;
	arg.del = delete;
	rnh-&gt;rnh_walktree(rnh, in_ifadownkill, &amp;arg);
	IFA_LOCK_SPIN(ifa);
	ifa-&gt;ifa_flags &amp;= ~IFA_ROUTE;
	IFA_UNLOCK(ifa);
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>