<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mptcp_opt.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mptcp_opt.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_opt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_seq.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/sha1.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_timer.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

<span class="enscript-comment">/*
 * SYSCTL for enforcing 64 bit dsn
 */</span>
int32_t force_64bit_dsn = 0; 
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_mptcp, OID_AUTO, force_64bit_dsn, 
    CTLFLAG_RW|CTLFLAG_LOCKED, &amp;force_64bit_dsn, 0,
    <span class="enscript-string">&quot;Force MPTCP 64bit dsn&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_validate_join_hmac</span>(<span class="enscript-type">struct</span> tcpcb *, u_char*, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_snd_mpprio</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">int</span> optlen);

<span class="enscript-comment">/*
 * MPTCP Options Output Processing
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>
<span class="enscript-function-name">mptcp_setup_first_subflow_syn_opts</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, u_char *opt,
    <span class="enscript-type">unsigned</span> optlen)
{
	<span class="enscript-type">struct</span> tcpcb *tp = sototcpcb(so);
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	mp_tp = tptomptp(tp);

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW))
		<span class="enscript-keyword">return</span> (optlen);

	<span class="enscript-comment">/*
	 * Avoid retransmitting the MP_CAPABLE option.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &gt; mptcp_mpcap_retries)
		<span class="enscript-keyword">return</span> (optlen);

	<span class="enscript-keyword">if</span> ((flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) {
		<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp mptcp_opt;
		mptcp_key_t mp_localkey = 0;

		mp_localkey = mptcp_get_localkey(mp_tp);
		<span class="enscript-keyword">if</span> (mp_localkey == 0) {
			<span class="enscript-comment">/* an embryonic connection was closed from above */</span>
			<span class="enscript-keyword">return</span> (optlen);
		}
		bzero(&amp;mptcp_opt,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp));
		mptcp_opt.mmc_common.mmco_kind = TCPOPT_MULTIPATH;
		mptcp_opt.mmc_common.mmco_len =
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp);
		mptcp_opt.mmc_common.mmco_subtype = MPO_CAPABLE;
		MPT_LOCK_SPIN(mp_tp);
		mptcp_opt.mmc_common.mmco_version = mp_tp-&gt;mpt_version;
		mptcp_opt.mmc_common.mmco_flags |= MPCAP_PROPOSAL_SBIT;
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)
			mptcp_opt.mmc_common.mmco_flags |=
			    MPCAP_CHECKSUM_CBIT;
		MPT_UNLOCK(mp_tp);
		mptcp_opt.mmc_localkey = mp_localkey;
		memcpy(opt + optlen, &amp;mptcp_opt,
		    mptcp_opt.mmc_common.mmco_len);
		optlen += mptcp_opt.mmc_common.mmco_len;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Only the SYN flag is set */</span>
		<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common mptcp_opt;
		mptcp_key_t mp_localkey = 0;
		mp_localkey = mptcp_get_localkey(mp_tp);
		so-&gt;so_flags |= SOF_MPTCP_CLIENT;
		<span class="enscript-keyword">if</span> (mp_localkey == 0) {
			<span class="enscript-comment">/* an embryonic connection was closed */</span>
			<span class="enscript-keyword">return</span> (optlen);
		}
		bzero(&amp;mptcp_opt,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common));
		mptcp_opt.mmco_kind = TCPOPT_MULTIPATH;
		mptcp_opt.mmco_len =
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common) +
		    <span class="enscript-keyword">sizeof</span> (mptcp_key_t);
		mptcp_opt.mmco_subtype = MPO_CAPABLE;
		MPT_LOCK_SPIN(mp_tp);
		mptcp_opt.mmco_version = mp_tp-&gt;mpt_version;
		mptcp_opt.mmco_flags |= MPCAP_PROPOSAL_SBIT;
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)
			mptcp_opt.mmco_flags |= MPCAP_CHECKSUM_CBIT;
		MPT_UNLOCK(mp_tp);
		(<span class="enscript-type">void</span>) memcpy(opt + optlen, &amp;mptcp_opt,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common));
		optlen += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common);
		(<span class="enscript-type">void</span>) memcpy(opt + optlen, &amp;mp_localkey,
		    <span class="enscript-keyword">sizeof</span> (mptcp_key_t));
		optlen += <span class="enscript-keyword">sizeof</span> (mptcp_key_t);
	}

	<span class="enscript-keyword">return</span> (optlen);
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>
<span class="enscript-function-name">mptcp_setup_join_subflow_syn_opts</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, u_char *opt,
    <span class="enscript-type">unsigned</span> optlen)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	<span class="enscript-keyword">if</span> (!inp)
		<span class="enscript-keyword">return</span> (optlen);

	tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (!tp)
		<span class="enscript-keyword">return</span> (optlen);

	<span class="enscript-keyword">if</span> (!tp-&gt;t_mptcb)
		<span class="enscript-keyword">return</span> (optlen);

	<span class="enscript-keyword">if</span> ((flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) {
		<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp mpjoin_rsp;
		<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);

		<span class="enscript-keyword">if</span> (mp_tp == NULL)
			<span class="enscript-keyword">return</span> (optlen);

		MPT_LOCK(mp_tp);
		<span class="enscript-keyword">if</span> (mptcp_get_localkey(mp_tp) == 0) {
			MPT_UNLOCK(mp_tp);
			<span class="enscript-keyword">return</span> (optlen);
		}
		MPT_UNLOCK(mp_tp);
		bzero(&amp;mpjoin_rsp, <span class="enscript-keyword">sizeof</span> (mpjoin_rsp));
		mpjoin_rsp.mmjo_kind = TCPOPT_MULTIPATH;
		mpjoin_rsp.mmjo_len = <span class="enscript-keyword">sizeof</span> (mpjoin_rsp);
		mpjoin_rsp.mmjo_subtype_bkp = MPO_JOIN &lt;&lt; 4;
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_BACKUP_PATH)
			mpjoin_rsp.mmjo_subtype_bkp |= MPTCP_BACKUP;
		mpjoin_rsp.mmjo_addr_id = tp-&gt;t_local_aid;
		mptcp_get_rands(tp-&gt;t_local_aid, tptomptp(tp),
		    &amp;mpjoin_rsp.mmjo_rand, NULL);
		mpjoin_rsp.mmjo_mac = mptcp_get_trunced_hmac(tp-&gt;t_local_aid,
		    mp_tp);
		memcpy(opt + optlen, &amp;mpjoin_rsp, mpjoin_rsp.mmjo_len);
		optlen += mpjoin_rsp.mmjo_len;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> mptcp_mpjoin_opt_req mpjoin_req;
		bzero(&amp;mpjoin_req, <span class="enscript-keyword">sizeof</span> (mpjoin_req));
		mpjoin_req.mmjo_kind = TCPOPT_MULTIPATH;
		mpjoin_req.mmjo_len = <span class="enscript-keyword">sizeof</span> (mpjoin_req);
		mpjoin_req.mmjo_subtype_bkp = MPO_JOIN &lt;&lt; 4;
		<span class="enscript-comment">/* A secondary subflow is started off as backup */</span>
		mpjoin_req.mmjo_subtype_bkp |= MPTCP_BACKUP;
		tp-&gt;t_mpflags |= TMPF_BACKUP_PATH;
		mpjoin_req.mmjo_addr_id = tp-&gt;t_local_aid;
		mpjoin_req.mmjo_peer_token = mptcp_get_remotetoken(tp-&gt;t_mptcb);
		<span class="enscript-keyword">if</span> (mpjoin_req.mmjo_peer_token == 0) {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s: peer token 0&quot;</span>,
				__func__),
				MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		}	
		mptcp_get_rands(tp-&gt;t_local_aid, tptomptp(tp),
		    &amp;mpjoin_req.mmjo_rand, NULL);
		memcpy(opt + optlen, &amp;mpjoin_req, mpjoin_req.mmjo_len);
		optlen += mpjoin_req.mmjo_len;
		<span class="enscript-comment">/* send an event up, if Fast Join is requested */</span>
		<span class="enscript-keyword">if</span> (mptcp_zerortt_fastjoin &amp;&amp; 
		    (so-&gt;so_flags &amp; SOF_MPTCP_FASTJOIN)) {
			soevent(so,
			    (SO_FILT_HINT_LOCKED | SO_FILT_HINT_MPFASTJ));
		}
	}
	<span class="enscript-keyword">return</span> (optlen);
}

<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">mptcp_setup_join_ack_opts</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *opt, <span class="enscript-type">unsigned</span> optlen)
{
	<span class="enscript-type">unsigned</span> new_optlen;
	<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2 join_rsp2;

	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2)) {
		printf(<span class="enscript-string">&quot;%s: no space left %d \n&quot;</span>, __func__, optlen);
		<span class="enscript-keyword">return</span> (optlen);
	}

	bzero(&amp;join_rsp2, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2));
	join_rsp2.mmjo_kind = TCPOPT_MULTIPATH;
	join_rsp2.mmjo_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2);
	join_rsp2.mmjo_subtype = MPO_JOIN;
	mptcp_get_hmac(tp-&gt;t_local_aid, tptomptp(tp),
	    (u_char*)&amp;join_rsp2.mmjo_mac,
	    <span class="enscript-keyword">sizeof</span> (join_rsp2.mmjo_mac));
	memcpy(opt + optlen, &amp;join_rsp2, join_rsp2.mmjo_len);
	new_optlen = optlen + join_rsp2.mmjo_len;
	tp-&gt;t_mpflags |= TMPF_FASTJOINBY2_SEND;
	<span class="enscript-keyword">return</span> (new_optlen);
}

<span class="enscript-type">unsigned</span>
<span class="enscript-function-name">mptcp_setup_syn_opts</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, u_char *opt, <span class="enscript-type">unsigned</span> optlen)
{
	<span class="enscript-type">unsigned</span> new_optlen;

	<span class="enscript-keyword">if</span> (mptcp_enable == 0) {
		<span class="enscript-comment">/* do nothing */</span>
		<span class="enscript-keyword">return</span> (optlen);
	}

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_MP_SEC_SUBFLOW)) {
		new_optlen = mptcp_setup_first_subflow_syn_opts(so, flags, opt,
		    optlen);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * To simulate SYN_ACK with no join opt, comment this line on
		 * OS X server side. This serves as a testing hook.
		 */</span>
		new_optlen = mptcp_setup_join_subflow_syn_opts(so, flags, opt,
		    optlen);
	}
	<span class="enscript-keyword">return</span> (new_optlen);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_send_mpfail</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *opt, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> optlen)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">tp</span>, <span class="enscript-variable-name">opt</span>, <span class="enscript-variable-name">optlen</span>)

	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	<span class="enscript-type">struct</span> mptcp_mpfail_opt fail_opt;
	uint64_t dsn;
	<span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpfail_opt);

	mp_tp = tptomptp(tp);
	<span class="enscript-keyword">if</span> (mp_tp == NULL) {
		tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPFAIL;
		<span class="enscript-keyword">return</span> (optlen);
	}

	<span class="enscript-comment">/* if option space low give up */</span>
	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpfail_opt)) {
		tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPFAIL;
		<span class="enscript-keyword">return</span> (optlen);
	}	

	MPT_LOCK(mp_tp);
	dsn = mp_tp-&gt;mpt_rcvnxt;
	MPT_UNLOCK(mp_tp);

	bzero(&amp;fail_opt, <span class="enscript-keyword">sizeof</span> (fail_opt));
	fail_opt.mfail_kind = TCPOPT_MULTIPATH;
	fail_opt.mfail_len = len;
	fail_opt.mfail_subtype = MPO_FAIL;
	fail_opt.mfail_dsn = mptcp_hton64(dsn);
	memcpy(opt + optlen, &amp;fail_opt, len);
	optlen += len;
	tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPFAIL;
	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s: %d \n&quot;</span>, __func__,
	    tp-&gt;t_local_aid), (MPTCP_SOCKET_DBG | MPTCP_SENDER_DBG), 
	    MPTCP_LOGLVL_LOG);
	<span class="enscript-keyword">return</span> (optlen);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_send_infinite_mapping</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *opt, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> optlen)
{
	<span class="enscript-type">struct</span> mptcp_dsn_opt infin_opt;
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	size_t len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dsn_opt);
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> csum_len = 0;

	<span class="enscript-keyword">if</span> (!so)
		<span class="enscript-keyword">return</span> (optlen);

	mp_tp = tptomptp(tp);
	<span class="enscript-keyword">if</span> (mp_tp == NULL)
		<span class="enscript-keyword">return</span> (optlen);

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)
		csum_len = 2;

	<span class="enscript-comment">/* try later */</span>
	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt; (len + csum_len)) {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">return</span> (optlen);
	}
	bzero(&amp;infin_opt, <span class="enscript-keyword">sizeof</span> (infin_opt));
	infin_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
	infin_opt.mdss_copt.mdss_len = len + csum_len;
	infin_opt.mdss_copt.mdss_subtype = MPO_DSS;
	infin_opt.mdss_copt.mdss_flags |= MDSS_M;
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_RECVD_MPFAIL) {
		infin_opt.mdss_dsn = (u_int32_t)
		    MPTCP_DATASEQ_LOW32(mp_tp-&gt;mpt_dsn_at_csum_fail);
		infin_opt.mdss_subflow_seqn = mp_tp-&gt;mpt_ssn_at_csum_fail;
	} <span class="enscript-keyword">else</span> {
		infin_opt.mdss_dsn = (u_int32_t)
		    MPTCP_DATASEQ_LOW32(mp_tp-&gt;mpt_snduna);
		infin_opt.mdss_subflow_seqn = tp-&gt;snd_una - tp-&gt;iss;
	}
	MPT_UNLOCK(mp_tp);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (optlen);
	<span class="enscript-keyword">if</span> ((infin_opt.mdss_dsn == 0) || (infin_opt.mdss_subflow_seqn == 0)) {
		<span class="enscript-keyword">return</span> (optlen);
	}
	infin_opt.mdss_dsn = htonl(infin_opt.mdss_dsn);
	infin_opt.mdss_subflow_seqn = htonl(infin_opt.mdss_subflow_seqn);
	infin_opt.mdss_data_len = 0;

	memcpy(opt + optlen, &amp;infin_opt, len);
	optlen += len;
	<span class="enscript-keyword">if</span> (csum_len != 0) {
		<span class="enscript-comment">/* The checksum field is set to 0 for infinite mapping */</span>
		uint16_t csum = 0;
		memcpy(opt + optlen, &amp;csum, csum_len);
		optlen += csum_len;
	}

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s: dsn = %x, seq = %x len = %x\n&quot;</span>, 
	    __func__,
	    ntohl(infin_opt.mdss_dsn),
	    ntohl(infin_opt.mdss_subflow_seqn),
	    ntohs(infin_opt.mdss_data_len)),
	    (MPTCP_SOCKET_DBG | MPTCP_SENDER_DBG),
	    MPTCP_LOGLVL_LOG);

	<span class="enscript-comment">/* so-&gt;so_flags &amp;= ~SOF_MPTCP_CLIENT; */</span>
	tp-&gt;t_mpflags |= TMPF_INFIN_SENT;
	tcpstat.tcps_estab_fallback++;
	<span class="enscript-keyword">return</span> (optlen);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_ok_to_fin</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_int64_t dsn, u_int32_t datalen)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	mp_tp = tptomptp(tp);

	MPT_LOCK(mp_tp);
	dsn = (mp_tp-&gt;mpt_sndmax &amp; MPTCP_DATASEQ_LOW32_MASK) | dsn;
	<span class="enscript-keyword">if</span> ((dsn + datalen) == mp_tp-&gt;mpt_sndmax) {
		MPT_UNLOCK(mp_tp);
		<span class="enscript-keyword">return</span> (1);
	}
	MPT_UNLOCK(mp_tp);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/* Must be called from tcp_output to fill in the fast close option */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_send_fastclose</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *opt, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> optlen,
	<span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> mptcp_fastclose_opt fastclose_opt;
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);

	<span class="enscript-comment">/* Only ACK flag should be set */</span>
	<span class="enscript-keyword">if</span> (flags != TH_ACK)
		<span class="enscript-keyword">return</span> (optlen);

	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt;
		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_fastclose_opt)) {
		<span class="enscript-keyword">return</span> (optlen);
	}

	bzero(&amp;fastclose_opt, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_fastclose_opt));
	fastclose_opt.mfast_kind = TCPOPT_MULTIPATH;
	fastclose_opt.mfast_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_fastclose_opt);
	fastclose_opt.mfast_subtype = MPO_FASTCLOSE;
	MPT_LOCK_SPIN(mp_tp);
	fastclose_opt.mfast_key =  mptcp_get_remotekey(mp_tp);
	MPT_UNLOCK(mp_tp);
	memcpy(opt + optlen, &amp;fastclose_opt, fastclose_opt.mfast_len);
	optlen += fastclose_opt.mfast_len;

	<span class="enscript-keyword">return</span> (optlen);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_setup_opts</span>(<span class="enscript-type">struct</span> tcpcb *tp, int32_t off, u_char *opt,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> optlen, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> datalen,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> **dss_lenp, u_int8_t **finp, u_int64_t *dss_valp,
    u_int32_t **sseqp, boolean_t *p_mptcp_acknow)
{
	<span class="enscript-type">struct</span> inpcb *inp = (<span class="enscript-type">struct</span> inpcb *)tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);
	boolean_t do_csum = FALSE;
	boolean_t send_64bit_dsn = FALSE;
	boolean_t send_64bit_ack = FALSE;
	u_int32_t old_mpt_flags = tp-&gt;t_mpflags &amp;
	    (TMPF_SND_MPPRIO | TMPF_SND_REM_ADDR | TMPF_SND_MPFAIL |
	    TMPF_MPCAP_RETRANSMIT);

	<span class="enscript-keyword">if</span> ((mptcp_enable == 0) ||
	    (mp_tp == NULL) ||
	    (mp_tp-&gt;mpt_flags &amp; MPTCPF_PEEL_OFF) ||
	    (tp-&gt;t_state == TCPS_CLOSED)) {
		<span class="enscript-comment">/* do nothing */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM) {
		do_csum = TRUE;
	}

	<span class="enscript-comment">/* tcp_output handles the SYN path separately */</span>
	<span class="enscript-keyword">if</span> (flags &amp; TH_SYN) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt;
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common)) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket:  &quot;</span>
		    <span class="enscript-string">&quot;%s: no space left %d flags %x &quot;</span>
		    <span class="enscript-string">&quot;tp-&gt;t_mpflags %x &quot;</span>
		    <span class="enscript-string">&quot;len %d\n&quot;</span>, __func__, optlen, flags, tp-&gt;t_mpflags,
		    datalen), MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_FASTCLOSE) {
		optlen = mptcp_send_fastclose(tp, opt, optlen, flags);
		VERIFY(datalen == 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_TCP_FALLBACK) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SND_MPFAIL)
			optlen = mptcp_send_mpfail(tp, opt, optlen);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_INFIN_SENT))
			optlen = mptcp_send_infinite_mapping(tp, opt, optlen);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SND_MPPRIO) {
		optlen = mptcp_snd_mpprio(tp, opt, optlen);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (((tp-&gt;t_mpflags &amp; TMPF_FASTJOINBY2_SEND) ||
	    (tp-&gt;t_mpflags &amp; TMPF_FASTJOIN_SEND )) &amp;&amp;
	    (datalen &gt; 0)) {
		tp-&gt;t_mpflags &amp;= ~TMPF_FASTJOINBY2_SEND;
		tp-&gt;t_mpflags &amp;= ~TMPF_FASTJOIN_SEND;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fastjoin_send</span>;
	}

	<span class="enscript-keyword">if</span> (((tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_SENT_KEYS)) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW))) ||
	    (tp-&gt;t_mpflags &amp; TMPF_MPCAP_RETRANSMIT)) {
		<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1 mptcp_opt;
		<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt;
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
		bzero(&amp;mptcp_opt, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1));
		mptcp_opt.mmc_common.mmco_kind = TCPOPT_MULTIPATH;
		mptcp_opt.mmc_common.mmco_len =
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1);
		mptcp_opt.mmc_common.mmco_subtype = MPO_CAPABLE;
		mptcp_opt.mmc_common.mmco_version = mp_tp-&gt;mpt_version;
		<span class="enscript-comment">/* HMAC-SHA1 is the proposal */</span>
		mptcp_opt.mmc_common.mmco_flags |= MPCAP_PROPOSAL_SBIT;
		MPT_LOCK(mp_tp);
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)
			mptcp_opt.mmc_common.mmco_flags |= MPCAP_CHECKSUM_CBIT;
		mptcp_opt.mmc_localkey = mptcp_get_localkey(mp_tp);
		mptcp_opt.mmc_remotekey = mptcp_get_remotekey(mp_tp);
		MPT_UNLOCK(mp_tp);
		memcpy(opt + optlen, &amp;mptcp_opt, mptcp_opt.mmc_common.mmco_len);
		optlen += mptcp_opt.mmc_common.mmco_len;
		tp-&gt;t_mpflags |= TMPF_SENT_KEYS | TMPF_MPTCP_TRUE;
		so-&gt;so_flags |= SOF_MPTCP_TRUE;
		tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
		tp-&gt;t_mpflags &amp;= ~TMPF_MPCAP_RETRANSMIT;

		<span class="enscript-keyword">if</span> (!tp-&gt;t_mpuna) {
			tp-&gt;t_mpuna = tp-&gt;snd_una;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* its a retransmission of the MP_CAPABLE ACK */</span>
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SND_REM_ADDR) {
			<span class="enscript-type">int</span> rem_opt_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_remaddr_opt);
			<span class="enscript-keyword">if</span> ((optlen + rem_opt_len) &lt;= MAX_TCPOPTLEN) {
				mptcp_send_remaddr_opt(tp,
				    (<span class="enscript-type">struct</span> mptcp_remaddr_opt *)(opt + optlen));
				optlen += rem_opt_len;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_mpflags &amp;= ~TMPF_SND_REM_ADDR;
			}
		}
	}

	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_RECVD_JOIN)) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN) &amp;&amp;
	    (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))) {
	    	MPT_LOCK(mp_tp);
	    	<span class="enscript-keyword">if</span> (mptcp_get_localkey(mp_tp) == 0) {
			MPT_UNLOCK(mp_tp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
		}
		MPT_UNLOCK(mp_tp);
		<span class="enscript-comment">/* Do the ACK part */</span>
		optlen = mptcp_setup_join_ack_opts(tp, opt, optlen);
		<span class="enscript-keyword">if</span> (!tp-&gt;t_mpuna) {
			tp-&gt;t_mpuna = tp-&gt;snd_una;
		}
		<span class="enscript-comment">/* Start a timer to retransmit the ACK */</span>
		tp-&gt;t_timer[TCPT_JACK_RXMT] =
			    OFFSET_FROM_START(tp, tcp_jack_rxmt);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
<span class="enscript-reference">fastjoin_send</span>:
	<span class="enscript-comment">/* 
	 * From here on, all options are sent only if MPTCP_TRUE 
	 * or when data is sent early on as in Fast Join
	 */</span>

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> ((mp_tp-&gt;mpt_flags &amp; MPTCPF_SND_64BITDSN) || force_64bit_dsn) {
		send_64bit_dsn = TRUE;
	}
	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_SND_64BITACK) {
		send_64bit_ack = TRUE;
	}
	MPT_UNLOCK(mp_tp);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CHECK_OPTLEN</span>	{						\
	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt; len) {				\
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket:  &quot;</span>			\
		    <span class="enscript-string">&quot;%s: len %d optlen %d \n&quot;</span>, __func__, len, optlen),	\
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);		\
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;					\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DO_FIN</span>(dsn_opt) {						\
	<span class="enscript-type">int</span> sndfin = 0;							\
	sndfin = mptcp_ok_to_fin(tp, dsn_opt.mdss_dsn, datalen);	\
	<span class="enscript-keyword">if</span> (sndfin) {							\
		dsn_opt.mdss_copt.mdss_flags |= MDSS_F;			\
		*finp = opt + optlen + offsetof(<span class="enscript-type">struct</span> mptcp_dss_copt,	\
		    mdss_flags);					\
		dsn_opt.mdss_data_len += 1;    				\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CHECK_DATALEN</span> {							\
	<span class="enscript-comment">/* MPTCP socket does not support IP options */</span>			\
	<span class="enscript-keyword">if</span> ((datalen + optlen + len) &gt; tp-&gt;t_maxopd) {			\
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket:  &quot;</span>			\
		    <span class="enscript-string">&quot;%s: nosp %d len %d opt %d %d %d\n&quot;</span>,		\
		    __func__, datalen, len, optlen,			\
		    tp-&gt;t_maxseg, tp-&gt;t_maxopd),			\
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);		\
		<span class="enscript-comment">/* remove option length from payload len */</span>		\
		datalen = tp-&gt;t_maxopd - optlen - len;			\
	}								\
}

	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    (send_64bit_dsn)) {
		<span class="enscript-comment">/*
		 * If there was the need to send 64-bit Data ACK along
		 * with 64-bit DSN, then 26 or 28 bytes would be used.
		 * With timestamps and NOOP padding that will cause
		 * overflow. Hence, in the rare event that both 64-bit
		 * DSN and 64-bit ACK have to be sent, delay the send of
		 * 64-bit ACK until our 64-bit DSN is acked with a 64-bit ack.
		 * XXX If this delay causes issue, remove the 2-byte padding.
		 */</span>
		<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt dsn_ack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (dsn_ack_opt);

		<span class="enscript-keyword">if</span> (do_csum) {
			len += 2;
		}

		CHECK_OPTLEN;

		bzero(&amp;dsn_ack_opt, <span class="enscript-keyword">sizeof</span> (dsn_ack_opt));
		dsn_ack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dsn_ack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dsn_ack_opt.mdss_copt.mdss_len = len;
		dsn_ack_opt.mdss_copt.mdss_flags |=
		    MDSS_M | MDSS_m | MDSS_A;

		CHECK_DATALEN;

		mptcp_output_getm_dsnmap64(so, off, (u_int32_t)datalen,
		    &amp;dsn_ack_opt.mdss_dsn,
		    &amp;dsn_ack_opt.mdss_subflow_seqn,
		    &amp;dsn_ack_opt.mdss_data_len);

		*dss_valp = dsn_ack_opt.mdss_dsn;

		<span class="enscript-keyword">if</span> ((dsn_ack_opt.mdss_data_len == 0) ||
		    (dsn_ack_opt.mdss_dsn == 0)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN) {
			DO_FIN(dsn_ack_opt);
		}

		MPT_LOCK(mp_tp);
		dsn_ack_opt.mdss_ack =
		    htonl(MPTCP_DATAACK_LOW32(mp_tp-&gt;mpt_rcvnxt));
		MPT_UNLOCK(mp_tp);

		dsn_ack_opt.mdss_dsn = mptcp_hton64(dsn_ack_opt.mdss_dsn);
		dsn_ack_opt.mdss_subflow_seqn = htonl(
		    dsn_ack_opt.mdss_subflow_seqn);
		dsn_ack_opt.mdss_data_len = htons(
		    dsn_ack_opt.mdss_data_len);
		*dss_lenp = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)(opt + optlen +
		    offsetof(<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt, mdss_data_len));

		memcpy(opt + optlen, &amp;dsn_ack_opt, <span class="enscript-keyword">sizeof</span> (dsn_ack_opt));

		<span class="enscript-keyword">if</span> (do_csum) {
			*sseqp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen +
			    offsetof(<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt,
			    mdss_subflow_seqn));
		}
		optlen += len;
		mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: long DSS = %llx ACK = %llx \n&quot;</span>,
		    __func__,
		    mptcp_ntoh64(dsn_ack_opt.mdss_dsn),
		    mptcp_ntoh64(dsn_ack_opt.mdss_ack)),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
		
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    (!send_64bit_dsn) &amp;&amp;
	    !(tp-&gt;t_mpflags &amp; TMPF_MPTCP_ACKNOW))  {
		<span class="enscript-type">struct</span> mptcp_dsn_opt dsn_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dsn_opt);

		<span class="enscript-keyword">if</span> (do_csum) {
			len += 2;
		}

		CHECK_OPTLEN;

		bzero(&amp;dsn_opt, <span class="enscript-keyword">sizeof</span> (dsn_opt));
		dsn_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dsn_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dsn_opt.mdss_copt.mdss_len = len;
		dsn_opt.mdss_copt.mdss_flags |= MDSS_M;

		CHECK_DATALEN;

		mptcp_output_getm_dsnmap32(so, off, (u_int32_t)datalen,
		    &amp;dsn_opt.mdss_dsn,
		    &amp;dsn_opt.mdss_subflow_seqn, &amp;dsn_opt.mdss_data_len,
		    dss_valp);

		<span class="enscript-keyword">if</span> ((dsn_opt.mdss_data_len == 0) ||
		    (dsn_opt.mdss_dsn == 0)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN) {
			DO_FIN(dsn_opt);
		}

		dsn_opt.mdss_dsn = htonl(dsn_opt.mdss_dsn);
		dsn_opt.mdss_subflow_seqn = htonl(dsn_opt.mdss_subflow_seqn);
		dsn_opt.mdss_data_len = htons(dsn_opt.mdss_data_len);
		*dss_lenp = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)(opt + optlen +
		    offsetof(<span class="enscript-type">struct</span> mptcp_dsn_opt, mdss_data_len));
		memcpy(opt + optlen, &amp;dsn_opt, <span class="enscript-keyword">sizeof</span> (dsn_opt));
		<span class="enscript-keyword">if</span> (do_csum) {
			*sseqp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen +
			    offsetof(<span class="enscript-type">struct</span> mptcp_dsn_opt, mdss_subflow_seqn));
		}
		optlen += len;
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-comment">/* 32-bit Data ACK option */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_MPTCP_ACKNOW) &amp;&amp;
	    (!send_64bit_ack) &amp;&amp;
	    !(tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    !(tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN)) {

		<span class="enscript-type">struct</span> mptcp_data_ack_opt dack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = 0;
<span class="enscript-reference">do_ack32_only</span>:
		len = <span class="enscript-keyword">sizeof</span> (dack_opt);

		CHECK_OPTLEN;

		bzero(&amp;dack_opt, len);
		dack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dack_opt.mdss_copt.mdss_len = len;
		dack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dack_opt.mdss_copt.mdss_flags |= MDSS_A;
		MPT_LOCK_SPIN(mp_tp);
		dack_opt.mdss_ack =
		    htonl(MPTCP_DATAACK_LOW32(mp_tp-&gt;mpt_rcvnxt));
		MPT_UNLOCK(mp_tp);
		memcpy(opt + optlen, &amp;dack_opt, len);
		optlen += len;
		VERIFY(optlen &lt;= MAX_TCPOPTLEN);
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-comment">/* 64-bit Data ACK option */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_MPTCP_ACKNOW) &amp;&amp;
	    (send_64bit_ack) &amp;&amp;
	    !(tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    !(tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN)) {
		<span class="enscript-type">struct</span> mptcp_data_ack64_opt dack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = 0;
<span class="enscript-reference">do_ack64_only</span>:
		len = <span class="enscript-keyword">sizeof</span> (dack_opt);

		CHECK_OPTLEN;

		bzero(&amp;dack_opt, len);
		dack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dack_opt.mdss_copt.mdss_len = len;
		dack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dack_opt.mdss_copt.mdss_flags |= (MDSS_A | MDSS_a);
		MPT_LOCK_SPIN(mp_tp);
		dack_opt.mdss_ack = mptcp_hton64(mp_tp-&gt;mpt_rcvnxt);
		<span class="enscript-comment">/*
		 * The other end should retransmit 64-bit DSN until it
		 * receives a 64-bit ACK.
		 */</span>
		mp_tp-&gt;mpt_flags &amp;= ~MPTCPF_SND_64BITACK;
		MPT_UNLOCK(mp_tp);
		memcpy(opt + optlen, &amp;dack_opt, len);
		optlen += len;
		VERIFY(optlen &lt;= MAX_TCPOPTLEN);
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-comment">/* 32-bit DSS+Data ACK option */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    (!send_64bit_dsn) &amp;&amp;
	    (!send_64bit_ack) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_MPTCP_ACKNOW)) {
		<span class="enscript-type">struct</span> mptcp_dss_ack_opt dss_ack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (dss_ack_opt);

		<span class="enscript-keyword">if</span> (do_csum)
			len += 2;

		CHECK_OPTLEN;

		bzero(&amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));
		dss_ack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dss_ack_opt.mdss_copt.mdss_len = len;
		dss_ack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dss_ack_opt.mdss_copt.mdss_flags |= MDSS_A | MDSS_M;
		MPT_LOCK_SPIN(mp_tp);
		dss_ack_opt.mdss_ack =
		    htonl(MPTCP_DATAACK_LOW32(mp_tp-&gt;mpt_rcvnxt));
		MPT_UNLOCK(mp_tp);

		CHECK_DATALEN;

		mptcp_output_getm_dsnmap32(so, off, (u_int32_t)datalen,
		    &amp;dss_ack_opt.mdss_dsn,
		    &amp;dss_ack_opt.mdss_subflow_seqn,
		    &amp;dss_ack_opt.mdss_data_len,
		    dss_valp);

		<span class="enscript-keyword">if</span> ((dss_ack_opt.mdss_data_len == 0) ||
		    (dss_ack_opt.mdss_dsn == 0)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_ack32_only</span>;
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN) {
			DO_FIN(dss_ack_opt);
		}

		dss_ack_opt.mdss_dsn = htonl(dss_ack_opt.mdss_dsn);
		dss_ack_opt.mdss_subflow_seqn =
		    htonl(dss_ack_opt.mdss_subflow_seqn);
		dss_ack_opt.mdss_data_len = htons(dss_ack_opt.mdss_data_len);
		*dss_lenp = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)(opt + optlen +
		    offsetof(<span class="enscript-type">struct</span> mptcp_dss_ack_opt, mdss_data_len));
		memcpy(opt + optlen, &amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));
		<span class="enscript-keyword">if</span> (do_csum) {
			*sseqp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen +
			    offsetof(<span class="enscript-type">struct</span> mptcp_dss_ack_opt,
			    mdss_subflow_seqn));
		}

		optlen += len;

		<span class="enscript-keyword">if</span> (optlen &gt; MAX_TCPOPTLEN)
			panic(<span class="enscript-string">&quot;optlen too large&quot;</span>);
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-comment">/* 32-bit DSS + 64-bit DACK option */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_SEND_DSN) &amp;&amp;
	    (!send_64bit_dsn) &amp;&amp;
	    (send_64bit_ack) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_MPTCP_ACKNOW)) {
		<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt dss_ack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (dss_ack_opt);

		<span class="enscript-keyword">if</span> (do_csum)
			len += 2;

		CHECK_OPTLEN;

		bzero(&amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));
		dss_ack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dss_ack_opt.mdss_copt.mdss_len = len;
		dss_ack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dss_ack_opt.mdss_copt.mdss_flags |= MDSS_M | MDSS_A | MDSS_a;
		MPT_LOCK_SPIN(mp_tp);
		dss_ack_opt.mdss_ack =
		    mptcp_hton64(mp_tp-&gt;mpt_rcvnxt);
		MPT_UNLOCK(mp_tp);

		CHECK_DATALEN;

		mptcp_output_getm_dsnmap32(so, off, (u_int32_t)datalen,
		    &amp;dss_ack_opt.mdss_dsn, &amp;dss_ack_opt.mdss_subflow_seqn,
		    &amp;dss_ack_opt.mdss_data_len, dss_valp);

		<span class="enscript-keyword">if</span> ((dss_ack_opt.mdss_data_len == 0) ||
		    (dss_ack_opt.mdss_dsn == 0)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_ack64_only</span>;
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN) {
			DO_FIN(dss_ack_opt);
		}

		dss_ack_opt.mdss_dsn = htonl(dss_ack_opt.mdss_dsn);
		dss_ack_opt.mdss_subflow_seqn =
		    htonl(dss_ack_opt.mdss_subflow_seqn);
		dss_ack_opt.mdss_data_len = htons(dss_ack_opt.mdss_data_len);
		*dss_lenp = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)(opt + optlen +
		    offsetof(<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt, mdss_data_len));
		memcpy(opt + optlen, &amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));
		<span class="enscript-keyword">if</span> (do_csum) {
			*sseqp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen +
			    offsetof(<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt,
			    mdss_subflow_seqn));
		}

		optlen += len;

		<span class="enscript-keyword">if</span> (optlen &gt; MAX_TCPOPTLEN)
			panic(<span class="enscript-string">&quot;optlen too large&quot;</span>);
		tp-&gt;t_mpflags &amp;= ~TMPF_MPTCP_ACKNOW;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SEND_DFIN) {
		<span class="enscript-type">struct</span> mptcp_dss_ack_opt dss_ack_opt;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss_ack_opt);

		<span class="enscript-keyword">if</span> (do_csum)
			len += 2;

		CHECK_OPTLEN;

		bzero(&amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));

		MPT_LOCK(mp_tp);
		<span class="enscript-comment">/*
		 * Data FIN occupies one sequence space.
		 * Don't send it if it has been Acked.
		 */</span>
		<span class="enscript-keyword">if</span> (((mp_tp-&gt;mpt_sndnxt + 1) != mp_tp-&gt;mpt_sndmax) ||
		    (mp_tp-&gt;mpt_snduna == mp_tp-&gt;mpt_sndmax)) {
			MPT_UNLOCK(mp_tp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ret_optlen</span>;
		}

		dss_ack_opt.mdss_copt.mdss_kind = TCPOPT_MULTIPATH;
		dss_ack_opt.mdss_copt.mdss_len = len;
		dss_ack_opt.mdss_copt.mdss_subtype = MPO_DSS;
		dss_ack_opt.mdss_copt.mdss_flags |= MDSS_A | MDSS_M | MDSS_F;
		dss_ack_opt.mdss_ack =
		    htonl(MPTCP_DATAACK_LOW32(mp_tp-&gt;mpt_rcvnxt));
		dss_ack_opt.mdss_dsn =
		    htonl(MPTCP_DATASEQ_LOW32(mp_tp-&gt;mpt_sndnxt));
		MPT_UNLOCK(mp_tp);
		dss_ack_opt.mdss_subflow_seqn = 0;
		dss_ack_opt.mdss_data_len = 1;
		dss_ack_opt.mdss_data_len = htons(dss_ack_opt.mdss_data_len);
		memcpy(opt + optlen, &amp;dss_ack_opt, <span class="enscript-keyword">sizeof</span> (dss_ack_opt));
		<span class="enscript-keyword">if</span> (do_csum) {
			*dss_valp = mp_tp-&gt;mpt_sndnxt;
			*sseqp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen +
			    offsetof(<span class="enscript-type">struct</span> mptcp_dss_ack_opt,
			    mdss_subflow_seqn));
		}
		optlen += len;
	}

<span class="enscript-reference">ret_optlen</span>:
	<span class="enscript-keyword">if</span> (TRUE == *p_mptcp_acknow ) {
		VERIFY(old_mpt_flags != 0);
		u_int32_t new_mpt_flags = tp-&gt;t_mpflags &amp;
		    (TMPF_SND_MPPRIO | TMPF_SND_REM_ADDR | TMPF_SND_MPFAIL |
		    TMPF_MPCAP_RETRANSMIT);

		<span class="enscript-comment">/*
		 * If none of the above mpflags were acted on by
		 * this routine, reset these flags and set p_mptcp_acknow
		 * to false.
		 * XXX The reset value of p_mptcp_acknow can be used 
		 * to communicate tcp_output to NOT send a pure ack without any
		 * MPTCP options as it will be treated as a dup ack.
		 * Since the instances of mptcp_setup_opts not acting on
		 * these options are mostly corner cases and sending a dup
		 * ack here would only have an impact if the system
		 * has sent consecutive dup acks before this false one,
		 * we haven't modified the logic in tcp_output to avoid
		 * that.
		 */</span>
		<span class="enscript-keyword">if</span> ((old_mpt_flags == new_mpt_flags) || (new_mpt_flags == 0)) {
			tp-&gt;t_mpflags &amp;= ~(TMPF_SND_MPPRIO
			    | TMPF_SND_REM_ADDR | TMPF_SND_MPFAIL |
			    TMPF_MPCAP_RETRANSMIT);
			*p_mptcp_acknow = FALSE;
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: %s: no action \n&quot;</span>,
			    __func__), MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
		} <span class="enscript-keyword">else</span> {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Sender: acknow set, &quot;</span>
			    <span class="enscript-string">&quot;old flags %x new flags %x \n&quot;</span>,
			    old_mpt_flags, new_mpt_flags),
			    MPTCP_SENDER_DBG, MPTCP_LOGLVL_LOG);
		}
	}

	<span class="enscript-keyword">return</span> optlen;
}

<span class="enscript-comment">/*
 * MPTCP Options Input Processing
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_sanitize_option</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> mptcp_subtype)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);
	<span class="enscript-type">int</span> ret = 1;

	<span class="enscript-keyword">if</span> (mp_tp == NULL) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: %s: NULL mpsocket \n&quot;</span>,
		    __func__), MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">switch</span> (mptcp_subtype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_CAPABLE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_JOIN</span>:		<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_DSS</span>:		<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_FASTCLOSE</span>:	<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_FAIL</span>:		<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_REMOVE_ADDR</span>:	<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_ADD_ADDR</span>:	<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_PRIO</span>:		<span class="enscript-comment">/* fall through */</span>
			<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED)
				ret = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ret = 0;
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: type = %d \n&quot;</span>, __func__,
			    mptcp_subtype),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_valid_mpcapable_common_opt</span>(u_char *cp)
{
	<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common *rsp =
	    (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common *)cp;

	<span class="enscript-comment">/* mmco_kind, mmco_len and mmco_subtype are validated before */</span>

	<span class="enscript-keyword">if</span> (!(rsp-&gt;mmco_flags &amp; MPCAP_PROPOSAL_SBIT))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (rsp-&gt;mmco_flags &amp; (MPCAP_BBIT | MPCAP_CBIT | MPCAP_DBIT |
	    MPCAP_EBIT | MPCAP_FBIT | MPCAP_GBIT))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (1);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_mpcapable_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th,
    <span class="enscript-type">int</span> optlen)
{
	<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1 *rsp1 = NULL;
	<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp *rsp = NULL;
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPTCP_OPT_ERROR_PATH</span>(tp) {					\
	tp-&gt;t_mpflags |= TMPF_RESET;					\
	tcpstat.tcps_invalid_mpcap++;					\
	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket != NULL) {				\
		soevent(tp-&gt;t_inpcb-&gt;inp_socket,			\
		    SO_FILT_HINT_LOCKED | SO_FILT_HINT_MUSTRST);	\
	}								\
}

	<span class="enscript-comment">/* Validate the kind, len, flags */</span>
	<span class="enscript-keyword">if</span> (mptcp_valid_mpcapable_common_opt(cp) != 1) {
		tcpstat.tcps_invalid_mpcap++;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* A SYN contains only the MP_CAPABLE option */</span>
	<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; (TH_SYN | TH_ACK)) == TH_SYN) {
		<span class="enscript-comment">/* XXX passive side not supported yet */</span>
		<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) {

		<span class="enscript-comment">/* Handle old duplicate SYN/ACK retransmission */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;rcv_nxt, (tp-&gt;irs + 1)))
			<span class="enscript-keyword">return</span>;

		<span class="enscript-comment">/* handle SYN/ACK retransmission by acknowledging with ACK */</span>
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt;= MPTCPS_ESTABLISHED) {
			tp-&gt;t_mpflags |= TMPF_MPCAP_RETRANSMIT;
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/* A SYN/ACK contains peer's key and flags */</span>
		<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp)) {
			<span class="enscript-comment">/* complain */</span>
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: SYN_ACK optlen = %d, sizeof mp opt = %lu \n&quot;</span>,
			    __func__, optlen,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp)),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			tcpstat.tcps_invalid_mpcap++;
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * If checksum flag is set, enable MPTCP checksum, even if
		 * it was not negotiated on the first SYN.
		 */</span>
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common *)cp)-&gt;mmco_flags &amp;
		    MPCAP_CHECKSUM_CBIT)
			mp_tp-&gt;mpt_flags |= MPTCPF_CHECKSUM;

		rsp = (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp *)cp;
		MPT_LOCK_SPIN(mp_tp);
		mp_tp-&gt;mpt_remotekey = rsp-&gt;mmc_localkey;
		<span class="enscript-comment">/* For now just downgrade to the peer's version */</span>
		mp_tp-&gt;mpt_peer_version = rsp-&gt;mmc_common.mmco_version;
		<span class="enscript-keyword">if</span> (rsp-&gt;mmc_common.mmco_version &lt; mp_tp-&gt;mpt_version) {
			mp_tp-&gt;mpt_version = rsp-&gt;mmc_common.mmco_version;
			tcpstat.tcps_mp_verdowngrade++;
		}
		MPT_UNLOCK(mp_tp);
		tp-&gt;t_mpflags |= TMPF_PREESTABLISHED;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; TH_ACK) &amp;&amp;
		(tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED)) {

		<span class="enscript-comment">/*
		 * Verify checksum flag is set, if we initially negotiated
		 * checksum.
		 */</span>
		<span class="enscript-keyword">if</span> ((mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM) &amp;&amp;
		    !(((<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common *)cp)-&gt;mmco_flags &amp;
		    MPCAP_CHECKSUM_CBIT)) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: checksum negotiation failure \n&quot;</span>, __func__),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			MPTCP_OPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-keyword">if</span> (!(mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM) &amp;&amp;
		    (((<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common *)cp)-&gt;mmco_flags &amp;
		    MPCAP_CHECKSUM_CBIT)) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: checksum negotiation failure 2.\n&quot;</span>, __func__),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			MPTCP_OPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * The ACK of a three way handshake contains peer's key and
		 * flags.
		 */</span>
		<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1)) {
			<span class="enscript-comment">/* complain */</span>
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: ACK optlen = %d , sizeof mp option = %lu, &quot;</span>
			    <span class="enscript-string">&quot; state = %d \n&quot;</span>, __func__,	optlen,
				<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1),
				tp-&gt;t_state), MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			MPTCP_OPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		rsp1 = (<span class="enscript-type">struct</span> mptcp_mpcapable_opt_rsp1 *)cp;

		<span class="enscript-comment">/* Skipping MPT_LOCK for invariant key */</span>
		<span class="enscript-keyword">if</span> (rsp1-&gt;mmc_remotekey != *mp_tp-&gt;mpt_localkey) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: key mismatch locally stored key. &quot;</span>
			    <span class="enscript-string">&quot;rsp = %llx local = %llx \n&quot;</span>, __func__, 
			    rsp1-&gt;mmc_remotekey, *mp_tp-&gt;mpt_localkey),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			MPTCP_OPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* We received both keys. Almost an MPTCP connection */</span>
			<span class="enscript-comment">/* Skipping MPT_LOCK for invariant key */</span>
			<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_remotekey != rsp1-&gt;mmc_localkey) {
				mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
				    <span class="enscript-string">&quot;%s: keys don't match\n&quot;</span>, __func__),
				    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
				tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
				MPTCP_OPT_ERROR_PATH(tp);
				<span class="enscript-keyword">return</span>;
			}
			tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
			tp-&gt;t_mpflags |= TMPF_MPTCP_RCVD_KEY;
			tp-&gt;t_mpflags |= TMPF_MPTCP_TRUE;
			tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_flags |= SOF_MPTCP_TRUE;
			MPT_LOCK(mp_tp);
			DTRACE_MPTCP2(state__change, <span class="enscript-type">struct</span> mptcb *, mp_tp, 
			    uint32_t, 0 <span class="enscript-comment">/* event */</span>);
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP State: &quot;</span>
				    <span class="enscript-string">&quot;MPTCPS_ESTABLISHED \n&quot;</span>),
				    MPTCP_STATE_DBG, MPTCP_LOGLVL_LOG);

			mp_tp-&gt;mpt_state = MPTCPS_ESTABLISHED;
			MPT_UNLOCK(mp_tp);
		}
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpuna) {
			tp-&gt;t_mpuna = 0;
		}
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_mpjoin_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">int</span> optlen)
{
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPTCP_JOPT_ERROR_PATH</span>(tp) {					\
	tp-&gt;t_mpflags |= TMPF_RESET;					\
	tcpstat.tcps_invalid_joins++;					\
	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket != NULL) {				\
		soevent(tp-&gt;t_inpcb-&gt;inp_socket,			\
		    SO_FILT_HINT_LOCKED | SO_FILT_HINT_MUSTRST);	\
	}								\
}
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; (TH_SYN | TH_ACK)) == TH_SYN) {
		<span class="enscript-comment">/* We won't accept join requests as an active opener */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_flags &amp; SOF_MPTCP_CLIENT) {
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_req)) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: SYN: unexpected optlen = %d, mp option&quot;</span>
			    <span class="enscript-string">&quot;= %lu\n&quot;</span>, __func__, optlen,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_req)),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			<span class="enscript-comment">/* send RST and close */</span>
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/* not supported yet */</span>
		<span class="enscript-keyword">return</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MPTCP_NOTYET</span>
		<span class="enscript-type">struct</span> mptcp_mpjoin_opt_req *join_req =
		    (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_req *)cp;
		mp_so = mptcp_find_mpso(join_req-&gt;mmjo_peer_token);
		<span class="enscript-keyword">if</span> (!mp_so) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;%s: cannot find mp_so token = %x\n&quot;</span>,
			    __func__, join_req-&gt;mmjo_peer_token),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			<span class="enscript-comment">/* send RST */</span>
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) {
			<span class="enscript-keyword">return</span>;
		}
		mp_so-&gt;ms_remote_addr_id = join_req-&gt;mmjo_addr_id;
		mp_so-&gt;ms_remote_rand = join_req-&gt;mmjo_rand;
		tp-&gt;t_mpflags |= TMPF_PREESTABLISHED | TMPF_JOINED_FLOW;
		tp-&gt;t_mpflags |= TMPF_RECVD_JOIN;
		tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_flags |= SOF_MP_SEC_SUBFLOW;
		<span class="enscript-keyword">if</span> (join_req-&gt;mmjo_subtype &amp; MPTCP_BACKUP) {
			tp-&gt;t_mpflags |= TMPF_BACKUP_PATH;
		}
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) {
		<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp *join_rsp =
		    (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp *)cp;

		<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp)) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>	
			    <span class="enscript-string">&quot;SYN_ACK: unexpected optlen = %d mp &quot;</span>
			    <span class="enscript-string">&quot;option = %lu\n&quot;</span>, optlen,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp)),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
			<span class="enscript-comment">/* send RST and close */</span>
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		mptcp_set_raddr_rand(tp-&gt;t_local_aid,
		    tptomptp(tp),
		    join_rsp-&gt;mmjo_addr_id, join_rsp-&gt;mmjo_rand);
		error = mptcp_validate_join_hmac(tp,
		    (u_char*)&amp;join_rsp-&gt;mmjo_mac, SHA1_TRUNCATED);
		<span class="enscript-keyword">if</span> (error) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: %s: &quot;</span>
			    <span class="enscript-string">&quot;SYN_ACK error = %d \n&quot;</span>, __func__, error),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
			<span class="enscript-comment">/* send RST and close */</span>
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}
		tp-&gt;t_mpflags |= TMPF_SENT_JOIN;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((th-&gt;th_flags &amp; TH_ACK) &amp;&amp;
	    (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED)) {
		<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2 *join_rsp2 =
		    (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2 *)cp;
		
		<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2)) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;ACK: unexpected optlen = %d mp option &quot;</span>
			    <span class="enscript-string">&quot;= %lu \n&quot;</span>,	optlen,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpjoin_opt_rsp2)),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);

			tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
			<span class="enscript-comment">/* send RST and close */</span>
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}

		error = mptcp_validate_join_hmac(tp, join_rsp2-&gt;mmjo_mac,
		    SHA1_RESULTLEN);
		<span class="enscript-keyword">if</span> (error) {
			mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: ACK error = %d\n&quot;</span>, __func__, error),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
			tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
			MPTCP_JOPT_ERROR_PATH(tp);
			<span class="enscript-keyword">return</span>;
		}
		tp-&gt;t_mpflags |= TMPF_MPTCP_TRUE;
		tp-&gt;t_mpflags &amp;= ~TMPF_PREESTABLISHED;
		tp-&gt;t_flags |= TF_ACKNOW;
		tp-&gt;t_mpflags |= TMPF_MPTCP_ACKNOW;
		tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_flags |= SOF_MPTCP_TRUE;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_validate_join_hmac</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char* hmac, <span class="enscript-type">int</span> mac_len)
{
	u_char digest[SHA1_RESULTLEN] = {0};
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	mptcp_key_t rem_key, loc_key;
	u_int32_t rem_rand, loc_rand;

	mp_tp = tp-&gt;t_mptcb;

	rem_rand = loc_rand = 0;

	MPT_LOCK(mp_tp);
	rem_key = mp_tp-&gt;mpt_remotekey;
	loc_key = *mp_tp-&gt;mpt_localkey;
	MPT_UNLOCK(mp_tp);

	mptcp_get_rands(tp-&gt;t_local_aid, mp_tp, &amp;loc_rand, &amp;rem_rand);
	<span class="enscript-keyword">if</span> ((rem_rand == 0) || (loc_rand == 0))
		<span class="enscript-keyword">return</span> (-1);

	mptcp_hmac_sha1(rem_key, loc_key, rem_rand, loc_rand,
	    digest, <span class="enscript-keyword">sizeof</span> (digest));

	<span class="enscript-keyword">if</span> (bcmp(digest, hmac, mac_len) == 0)
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* matches */</span>
	<span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;%s: remote key %llx local key %llx remote rand %x &quot;</span>
		    <span class="enscript-string">&quot;local rand %x \n&quot;</span>, __func__, rem_key, loc_key,
		    rem_rand, loc_rand);
		<span class="enscript-keyword">return</span> (-1);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_dss_opt_ack_meat</span>(u_int64_t full_dack, <span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);
	<span class="enscript-type">int</span> close_notify = 0;

	MPT_LOCK(mp_tp);
	<span class="enscript-keyword">if</span> (MPTCP_SEQ_LEQ(full_dack, mp_tp-&gt;mpt_sndmax) &amp;&amp;
	    MPTCP_SEQ_GEQ(full_dack, mp_tp-&gt;mpt_snduna)) {
		mptcp_data_ack_rcvd(mp_tp, tp, full_dack);
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt; MPTCPS_FIN_WAIT_2)
			close_notify = 1;
		MPT_UNLOCK(mp_tp);
		mptcp_notify_mpready(tp-&gt;t_inpcb-&gt;inp_socket);
		<span class="enscript-keyword">if</span> (close_notify)
			mptcp_notify_close(tp-&gt;t_inpcb-&gt;inp_socket);
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_RCVD_64BITACK) {
			mp_tp-&gt;mpt_flags &amp;= ~MPTCPF_RCVD_64BITACK;
			mp_tp-&gt;mpt_flags &amp;= ~MPTCPF_SND_64BITDSN;
		}
	} <span class="enscript-keyword">else</span> {
		MPT_UNLOCK(mp_tp);
		mptcplog((LOG_ERR,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: unexpected dack %llx snduna %llx &quot;</span>
		    <span class="enscript-string">&quot;sndmax %llx\n&quot;</span>, __func__, full_dack,
		    mp_tp-&gt;mpt_snduna, mp_tp-&gt;mpt_sndmax),
		    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
		    MPTCP_LOGLVL_LOG);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_dss_opt_meat</span>(u_char *cp, <span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> mptcp_dss_copt *dss_rsp = (<span class="enscript-type">struct</span> mptcp_dss_copt *)cp;
	u_int64_t full_dack = 0;
	<span class="enscript-type">struct</span> mptcb *mp_tp = tptomptp(tp);
	<span class="enscript-type">int</span> csum_len = 0;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPTCP_DSS_OPT_SZ_CHK</span>(len, expected_len) {		\
	<span class="enscript-keyword">if</span> (len != expected_len) {				\
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>		\
		    <span class="enscript-string">&quot;%s: bad len = %d dss: %x \n&quot;</span>, __func__,	\
		    len, dss_rsp-&gt;mdss_flags),			\
		    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),	\
		    MPTCP_LOGLVL_LOG);				\
		<span class="enscript-keyword">return</span>;						\
	}							\
}

	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp; MPTCPF_CHECKSUM)
		csum_len = 2;

	dss_rsp-&gt;mdss_flags &amp;= (MDSS_A|MDSS_a|MDSS_M|MDSS_m);
	<span class="enscript-keyword">switch</span> (dss_rsp-&gt;mdss_flags) {
		<span class="enscript-keyword">case</span> (MDSS_M):
		{
			<span class="enscript-comment">/* 32-bit DSS, No Data ACK */</span>
			<span class="enscript-type">struct</span> mptcp_dsn_opt *dss_rsp1;
			dss_rsp1 = (<span class="enscript-type">struct</span> mptcp_dsn_opt *)cp;

			MPTCP_DSS_OPT_SZ_CHK(dss_rsp1-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dsn_opt) + csum_len);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_dss_rcv_state(dss_rsp1, tp, 0);
			<span class="enscript-keyword">else</span>
				mptcp_update_dss_rcv_state(dss_rsp1, tp,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    (dss_rsp1-&gt;mdss_copt.mdss_len - csum_len)));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_A):
		{
			<span class="enscript-comment">/* 32-bit Data ACK, no DSS */</span>
			<span class="enscript-type">struct</span> mptcp_data_ack_opt *dack_opt;
			dack_opt = (<span class="enscript-type">struct</span> mptcp_data_ack_opt *)cp;

			MPTCP_DSS_OPT_SZ_CHK(dack_opt-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_data_ack_opt));

			u_int32_t dack = dack_opt-&gt;mdss_ack;
			NTOHL(dack);
			MPT_LOCK_SPIN(mp_tp);
			MPTCP_EXTEND_DSN(mp_tp-&gt;mpt_snduna, dack, full_dack);
			MPT_UNLOCK(mp_tp);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_M | MDSS_A):
		{
			<span class="enscript-comment">/* 32-bit Data ACK + 32-bit DSS */</span>
			<span class="enscript-type">struct</span> mptcp_dss_ack_opt *dss_ack_rsp;
			dss_ack_rsp = (<span class="enscript-type">struct</span> mptcp_dss_ack_opt *)cp;

			MPTCP_DSS_OPT_SZ_CHK(dss_ack_rsp-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss_ack_opt) + csum_len);

			u_int32_t dack = dss_ack_rsp-&gt;mdss_ack;
			NTOHL(dack);
			MPT_LOCK_SPIN(mp_tp);
			MPTCP_EXTEND_DSN(mp_tp-&gt;mpt_snduna, dack, full_dack);
			MPT_UNLOCK(mp_tp);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_rcv_state_f(dss_ack_rsp, tp, 0);
			<span class="enscript-keyword">else</span>
				mptcp_update_rcv_state_f(dss_ack_rsp, tp,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    (dss_ack_rsp-&gt;mdss_copt.mdss_len -
				    csum_len)));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_M | MDSS_m):
		{
			<span class="enscript-comment">/* 64-bit DSS , No Data ACK */</span>
			<span class="enscript-type">struct</span> mptcp_dsn64_opt *dsn64;
			dsn64 = (<span class="enscript-type">struct</span> mptcp_dsn64_opt *)cp;
			u_int64_t full_dsn;

			MPTCP_DSS_OPT_SZ_CHK(dsn64-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dsn64_opt) + csum_len);

			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: 64-bit M present.\n&quot;</span>, __func__),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);

			MPT_LOCK_SPIN(mp_tp);
			mp_tp-&gt;mpt_flags |= MPTCPF_SND_64BITACK;
			MPT_UNLOCK(mp_tp);

			full_dsn = mptcp_ntoh64(dsn64-&gt;mdss_dsn);
			NTOHL(dsn64-&gt;mdss_subflow_seqn);
			NTOHS(dsn64-&gt;mdss_data_len);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dsn64-&gt;mdss_subflow_seqn,
				    dsn64-&gt;mdss_data_len,
				    0);
			<span class="enscript-keyword">else</span>
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dsn64-&gt;mdss_subflow_seqn,
				    dsn64-&gt;mdss_data_len,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    dsn64-&gt;mdss_copt.mdss_len - csum_len));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_A | MDSS_a):
		{
			<span class="enscript-comment">/* 64-bit Data ACK, no DSS */</span>
			<span class="enscript-type">struct</span> mptcp_data_ack64_opt *dack64;
			dack64 = (<span class="enscript-type">struct</span> mptcp_data_ack64_opt *)cp;

			MPTCP_DSS_OPT_SZ_CHK(dack64-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_data_ack64_opt));

			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: 64-bit A present. \n&quot;</span>, __func__),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);

			MPT_LOCK_SPIN(mp_tp);
			mp_tp-&gt;mpt_flags |= MPTCPF_RCVD_64BITACK;
			MPT_UNLOCK(mp_tp);

			full_dack = mptcp_ntoh64(dack64-&gt;mdss_ack);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_M | MDSS_m | MDSS_A):
		{
			<span class="enscript-comment">/* 64-bit DSS + 32-bit Data ACK */</span>
			<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt *dss_ack_rsp;
			dss_ack_rsp = (<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt *)cp;

			MPTCP_DSS_OPT_SZ_CHK(dss_ack_rsp-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss64_ack32_opt) + csum_len);

			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: 64-bit M and 32-bit A present.\n&quot;</span>, __func__),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);

			u_int32_t dack = dss_ack_rsp-&gt;mdss_ack;
			NTOHL(dack);
			MPT_LOCK_SPIN(mp_tp);
			mp_tp-&gt;mpt_flags |= MPTCPF_SND_64BITACK;
			MPTCP_EXTEND_DSN(mp_tp-&gt;mpt_snduna, dack, full_dack);
			MPT_UNLOCK(mp_tp);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_rcv_state_g(dss_ack_rsp, tp, 0);
			<span class="enscript-keyword">else</span>
				mptcp_update_rcv_state_g(dss_ack_rsp, tp,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    dss_ack_rsp-&gt;mdss_copt.mdss_len -
				    csum_len));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_M | MDSS_A | MDSS_a):
		{
			<span class="enscript-comment">/* 32-bit DSS + 64-bit Data ACK */</span>
			<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt *dss32_ack64_opt;
			dss32_ack64_opt = (<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt *)cp;
			u_int64_t full_dsn;

			MPTCP_DSS_OPT_SZ_CHK(
			    dss32_ack64_opt-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss32_ack64_opt) + csum_len);

			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: 32-bit M and 64-bit A present.\n&quot;</span>, __func__),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);
			
			full_dack = mptcp_ntoh64(dss32_ack64_opt-&gt;mdss_ack);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			NTOHL(dss32_ack64_opt-&gt;mdss_dsn);
			MPT_LOCK_SPIN(mp_tp);
			mp_tp-&gt;mpt_flags |= MPTCPF_RCVD_64BITACK;
			MPTCP_EXTEND_DSN(mp_tp-&gt;mpt_rcvnxt,
				dss32_ack64_opt-&gt;mdss_dsn, full_dsn);
			MPT_UNLOCK(mp_tp);
			NTOHL(dss32_ack64_opt-&gt;mdss_subflow_seqn);
			NTOHS(dss32_ack64_opt-&gt;mdss_data_len);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dss32_ack64_opt-&gt;mdss_subflow_seqn,
				    dss32_ack64_opt-&gt;mdss_data_len, 0);
			<span class="enscript-keyword">else</span>
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dss32_ack64_opt-&gt;mdss_subflow_seqn,
				    dss32_ack64_opt-&gt;mdss_data_len,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    dss32_ack64_opt-&gt;mdss_copt.mdss_len -
				    csum_len));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> (MDSS_M | MDSS_m | MDSS_A | MDSS_a):
		{
			<span class="enscript-comment">/* 64-bit DSS + 64-bit Data ACK */</span>
			<span class="enscript-type">struct</span> mptcp_dss64_ack64_opt *dss64_ack64;
			dss64_ack64 = (<span class="enscript-type">struct</span> mptcp_dss64_ack64_opt *)cp;
			u_int64_t full_dsn;

			MPTCP_DSS_OPT_SZ_CHK(dss64_ack64-&gt;mdss_copt.mdss_len,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_dss64_ack64_opt) + csum_len);

			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: 64-bit M and 64-bit A present.\n&quot;</span>, __func__),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);

			MPT_LOCK_SPIN(mp_tp);
			mp_tp-&gt;mpt_flags |= MPTCPF_RCVD_64BITACK;
			mp_tp-&gt;mpt_flags |= MPTCPF_SND_64BITACK;
			MPT_UNLOCK(mp_tp);
			full_dsn = mptcp_ntoh64(dss64_ack64-&gt;mdss_dsn);
			full_dack = mptcp_ntoh64(dss64_ack64-&gt;mdss_dsn);
			mptcp_do_dss_opt_ack_meat(full_dack, tp);
			NTOHL(dss64_ack64-&gt;mdss_subflow_seqn);
			NTOHS(dss64_ack64-&gt;mdss_data_len);
			<span class="enscript-keyword">if</span> (csum_len == 0)
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dss64_ack64-&gt;mdss_subflow_seqn,
				    dss64_ack64-&gt;mdss_data_len, 0);
			<span class="enscript-keyword">else</span>
				mptcp_update_rcv_state_meat(mp_tp, tp, full_dsn,
				    dss64_ack64-&gt;mdss_subflow_seqn,
				    dss64_ack64-&gt;mdss_data_len,
				    *(uint16_t *)(<span class="enscript-type">void</span> *)(cp +
				    dss64_ack64-&gt;mdss_copt.mdss_len -
				    csum_len));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: File bug, DSS flags = %x\n&quot;</span>, __func__,
			    dss_rsp-&gt;mdss_flags),
			    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
			    MPTCP_LOGLVL_LOG);
			<span class="enscript-keyword">break</span>;
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_fin_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)tp-&gt;t_mptcb;

	mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: %s \n&quot;</span>, __func__),
	    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
	    MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_RECV_DFIN)) {
		<span class="enscript-keyword">if</span> (mp_tp != NULL) {
			MPT_LOCK(mp_tp);
			mptcp_close_fsm(mp_tp, MPCE_RECV_DATA_FIN);
			MPT_UNLOCK(mp_tp);

			<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket != NULL) {
				soevent(tp-&gt;t_inpcb-&gt;inp_socket,
				    SO_FILT_HINT_LOCKED |
				    SO_FILT_HINT_MPCANTRCVMORE);
			}

		}
		tp-&gt;t_mpflags |= TMPF_RECV_DFIN;
	}

	tp-&gt;t_mpflags |= TMPF_MPTCP_ACKNOW;
	<span class="enscript-comment">/*
	 * Since this is a data level FIN, TCP needs to be explicitly told
	 * to send back an ACK on which the Data ACK is piggybacked.
	 */</span>
	tp-&gt;t_flags |= TF_ACKNOW;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_dss_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">int</span> optlen)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">th</span>, <span class="enscript-variable-name">optlen</span>)
	<span class="enscript-type">struct</span> mptcb *mp_tp = (<span class="enscript-type">struct</span> mptcb *)tp-&gt;t_mptcb;

	<span class="enscript-keyword">if</span> (!mp_tp)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* We may get Data ACKs just during fallback, so don't ignore those */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) ||
	    (tp-&gt;t_mpflags &amp; TMPF_TCP_FALLBACK)) {
		<span class="enscript-type">struct</span> mptcp_dss_copt *dss_rsp = (<span class="enscript-type">struct</span> mptcp_dss_copt *)cp;

		<span class="enscript-keyword">if</span> (dss_rsp-&gt;mdss_subtype == MPO_DSS) {
			<span class="enscript-keyword">if</span> (dss_rsp-&gt;mdss_flags &amp; MDSS_F) {
				mptcp_do_fin_opt(tp);
			}

			mptcp_do_dss_opt_meat(cp, tp);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_fastclose_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	<span class="enscript-type">struct</span> mptcp_fastclose_opt *fc_opt = (<span class="enscript-type">struct</span> mptcp_fastclose_opt *)cp;

	<span class="enscript-keyword">if</span> (th-&gt;th_flags != TH_ACK)
		<span class="enscript-keyword">return</span>;

	mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: %s: \n&quot;</span>, __func__),
	    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG),
	    MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (fc_opt-&gt;mfast_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_fastclose_opt)) {
		tcpstat.tcps_invalid_opt++;
		<span class="enscript-keyword">return</span>;
	}

	mp_tp = (<span class="enscript-type">struct</span> mptcb *)tp-&gt;t_mptcb;
	<span class="enscript-keyword">if</span> (!mp_tp)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (fc_opt-&gt;mfast_key != mptcp_get_localkey(mp_tp)) {
		tcpstat.tcps_invalid_opt++;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * fastclose could make us more vulnerable to attacks, hence
	 * accept only those that are at the next expected sequence number.
	 */</span>
	<span class="enscript-keyword">if</span> (th-&gt;th_seq != tp-&gt;rcv_nxt) {
		tcpstat.tcps_invalid_opt++;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Reset this flow */</span>
	tp-&gt;t_mpflags |= TMPF_RESET;

	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket != NULL) {
		soevent(tp-&gt;t_inpcb-&gt;inp_socket,
		    SO_FILT_HINT_LOCKED | SO_FILT_HINT_MUSTRST);
	}
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_mpfail_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	<span class="enscript-type">struct</span> mptcp_mpfail_opt *fail_opt = (<span class="enscript-type">struct</span> mptcp_mpfail_opt *)cp;
	u_int32_t mdss_subflow_seqn = 0;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * mpfail could make us more vulnerable to attacks. Hence accept
	 * only those that are the next expected sequence number.
	 */</span>
	<span class="enscript-keyword">if</span> (th-&gt;th_seq != tp-&gt;rcv_nxt) {
		tcpstat.tcps_invalid_opt++;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* A packet without RST, must atleast have the ACK bit set */</span>
	<span class="enscript-keyword">if</span> ((th-&gt;th_flags != TH_ACK) &amp;&amp; (th-&gt;th_flags != TH_RST))
		<span class="enscript-keyword">return</span>;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s: \n&quot;</span>, __func__),
	    (MPTCP_SOCKET_DBG|MPTCP_RECEIVER_DBG), MPTCP_LOGLVL_LOG);

	<span class="enscript-keyword">if</span> (fail_opt-&gt;mfail_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpfail_opt))
		<span class="enscript-keyword">return</span>;

	mp_tp = (<span class="enscript-type">struct</span> mptcb *)tp-&gt;t_mptcb;
	MPT_LOCK(mp_tp);
	mp_tp-&gt;mpt_flags |= MPTCPF_RECVD_MPFAIL;
	mp_tp-&gt;mpt_dsn_at_csum_fail = mptcp_hton64(fail_opt-&gt;mfail_dsn);
	MPT_UNLOCK(mp_tp);
	error = mptcp_get_map_for_dsn(tp-&gt;t_inpcb-&gt;inp_socket, 
	    mp_tp-&gt;mpt_dsn_at_csum_fail, &amp;mdss_subflow_seqn);
	<span class="enscript-keyword">if</span> (error == 0) {
		mp_tp-&gt;mpt_ssn_at_csum_fail = mdss_subflow_seqn;
	}

	mptcp_notify_mpfail(tp-&gt;t_inpcb-&gt;inp_socket);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_do_mptcp_options</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th,
    <span class="enscript-type">struct</span> tcpopt *to, <span class="enscript-type">int</span> optlen)
{
	<span class="enscript-type">int</span> mptcp_subtype;

	<span class="enscript-comment">/* All MPTCP options have atleast 4 bytes */</span>
	<span class="enscript-keyword">if</span> (optlen &lt; 4)
		<span class="enscript-keyword">return</span>;

	mptcp_subtype = (cp[2] &gt;&gt; 4);

	<span class="enscript-keyword">if</span> (mptcp_sanitize_option(tp, mptcp_subtype) == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (mptcp_subtype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_CAPABLE</span>:
			mptcp_do_mpcapable_opt(tp, cp, th, optlen);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_JOIN</span>:
			mptcp_do_mpjoin_opt(tp, cp, th, optlen);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_DSS</span>:
			mptcp_do_dss_opt(tp, cp, th, optlen);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_FASTCLOSE</span>:
			mptcp_do_fastclose_opt(tp, cp, th);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_FAIL</span>:
			mptcp_do_mpfail_opt(tp, cp, th);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_ADD_ADDR</span>:	<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_REMOVE_ADDR</span>:	<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPO_PRIO</span>:
			to-&gt;to_flags |= TOF_MPTCP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * MPTCP ADD_ADDR and REMOVE_ADDR options
 */</span>

<span class="enscript-comment">/*
 * ADD_ADDR is only placeholder code - not sent on wire
 * The ADD_ADDR option is not sent on wire because of security issues
 * around connection hijacking.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_send_addaddr_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mptcp_addaddr_opt *opt)
{

	opt-&gt;ma_kind = TCPOPT_MULTIPATH;
	opt-&gt;ma_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_addaddr_opt);
	opt-&gt;ma_subtype = MPO_ADD_ADDR;
	opt-&gt;ma_addr_id = tp-&gt;t_local_aid;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MPTCP_NOTYET</span>
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag == AF_INET) {
		opt-&gt;ma_ipver = MA_IPVer_V4;
		bcopy((<span class="enscript-type">char</span> *)&amp;sin-&gt;sin_addr.s_addr, (<span class="enscript-type">char</span> *)opt + opt-&gt;ma_len,
		    <span class="enscript-keyword">sizeof</span> (in_addr_t));
		opt-&gt;ma_len += <span class="enscript-keyword">sizeof</span> (in_addr_t);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag == AF_INET6) {
		opt-&gt;ma_ipver = MA_IPVer_V6;
		bcopy((<span class="enscript-type">char</span> *)&amp;sin6-&gt;sin6_addr, (<span class="enscript-type">char</span> *)opt + opt-&gt;ma_len,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		opt-&gt;ma_len += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr);
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span> (tp-&gt;t_mp_port) {
		<span class="enscript-comment">/* add ports XXX */</span>
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* REMOVE_ADDR option is sent when a source address goes away */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_send_remaddr_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mptcp_remaddr_opt *opt)
{
	mptcplog((LOG_DEBUG,<span class="enscript-string">&quot;MPTCP Socket: %s: local id %d remove id %d \n&quot;</span>,
	    __func__, tp-&gt;t_local_aid, tp-&gt;t_rem_aid),
	    (MPTCP_SOCKET_DBG|MPTCP_SENDER_DBG), MPTCP_LOGLVL_LOG);

	bzero(opt, <span class="enscript-keyword">sizeof</span> (*opt));
	opt-&gt;mr_kind = TCPOPT_MULTIPATH;
	opt-&gt;mr_len = <span class="enscript-keyword">sizeof</span> (*opt);
	opt-&gt;mr_subtype = MPO_REMOVE_ADDR;
	opt-&gt;mr_addr_id = tp-&gt;t_rem_aid;
	tp-&gt;t_mpflags &amp;= ~TMPF_SND_REM_ADDR;
}

<span class="enscript-comment">/*
 * MPTCP MP_PRIO option
 */</span>

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * Current implementation drops incoming MP_PRIO option and this code is
 * just a placeholder. The option is dropped because only the mobile client can
 * decide which of the subflows is preferred (usually wifi is preferred
 * over Cellular).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_do_mpprio_opt</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">struct</span> tcphdr *th,
    <span class="enscript-type">int</span> optlen)
{
	<span class="enscript-type">int</span> bkp = 0;
	<span class="enscript-type">struct</span> mptcp_mpprio_opt *mpprio = (<span class="enscript-type">struct</span> mptcp_mpprio_opt *)cp;

	<span class="enscript-keyword">if</span> ((tp == NULL) || !(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((mpprio-&gt;mpprio_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpprio_addr_opt)) &amp;&amp;
	    (mpprio-&gt;mpprio_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mptcp_mpprio_opt)))
		<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* We send MP_PRIO option based on the values set by the SIOCSCONNORDER ioctl */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_snd_mpprio</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">int</span> optlen)
{
	<span class="enscript-type">struct</span> mptcp_mpprio_addr_opt mpprio;

	<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_ESTABLISHED) {
		tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPPRIO;
		<span class="enscript-keyword">return</span> (optlen);
	}

	<span class="enscript-keyword">if</span> (mptcp_mpprio_enable != 1) {
		tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPPRIO;
		<span class="enscript-keyword">return</span> (optlen);
	}

	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt;
	    (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (mpprio))
		<span class="enscript-keyword">return</span> (optlen);

	bzero(&amp;mpprio, <span class="enscript-keyword">sizeof</span> (mpprio));
	mpprio.mpprio_kind = TCPOPT_MULTIPATH;
	mpprio.mpprio_len = <span class="enscript-keyword">sizeof</span> (mpprio);
	mpprio.mpprio_subtype = MPO_PRIO;
	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_BACKUP_PATH)
		mpprio.mpprio_flags |= MPTCP_MPPRIO_BKP;
	mpprio.mpprio_addrid = tp-&gt;t_local_aid;
	memcpy(cp + optlen, &amp;mpprio, <span class="enscript-keyword">sizeof</span> (mpprio));
	optlen += <span class="enscript-keyword">sizeof</span> (mpprio);
	tp-&gt;t_mpflags &amp;= ~TMPF_SND_MPPRIO;
	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: %s: aid = %d \n&quot;</span>, __func__,
	    tp-&gt;t_local_aid), 
	    (MPTCP_SOCKET_DBG|MPTCP_SENDER_DBG), MPTCP_LOGLVL_LOG);
	<span class="enscript-keyword">return</span> (optlen);
}
</pre>
<hr />
</body></html>