<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_output.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_output.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_output.c	8.4 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/tcp_output.c,v 1.39.2.10 2001/07/07 04:30:38 silby Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_IP_VHL</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPOUTFLAGS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_debug.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/lro_ext.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_opt.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccaes.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETTCP, 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETTCP, 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_TCP_OUTPUT</span>	NETDBG_CODE(DBG_NETTCP, (4 &lt;&lt; 8) | 1)

<span class="enscript-type">int</span> path_mtu_discovery = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, path_mtu_discovery,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;path_mtu_discovery, 1,
	<span class="enscript-string">&quot;Enable Path MTU Discovery&quot;</span>);

<span class="enscript-type">int</span> ss_fltsz = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, slowstart_flightsize,
	CTLFLAG_RW | CTLFLAG_LOCKED,&amp;ss_fltsz, 1,
	<span class="enscript-string">&quot;Slow start flight size&quot;</span>);

<span class="enscript-type">int</span> ss_fltsz_local = 8; <span class="enscript-comment">/* starts with eight segments max */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, local_slowstart_flightsize,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ss_fltsz_local, 1,
	<span class="enscript-string">&quot;Slow start flight size for local networks&quot;</span>);

<span class="enscript-type">int</span>	tcp_do_tso = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tso, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;tcp_do_tso, 0, <span class="enscript-string">&quot;Enable TCP Segmentation Offload&quot;</span>);

<span class="enscript-type">int</span>     tcp_ecn_outbound = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, ecn_initiate_out,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_ecn_outbound, 0,
	<span class="enscript-string">&quot;Initiate ECN for outbound connections&quot;</span>);

<span class="enscript-type">int</span>     tcp_ecn_inbound = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, ecn_negotiate_in,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_ecn_inbound, 0,
	<span class="enscript-string">&quot;Allow ECN negotiation for inbound connections&quot;</span>);

<span class="enscript-type">int</span>	tcp_packet_chaining = 50;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, packetchain,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_packet_chaining, 0,
	<span class="enscript-string">&quot;Enable TCP output packet chaining&quot;</span>);

<span class="enscript-type">int</span>	tcp_output_unlocked = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, socket_unlocked_on_output,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_output_unlocked, 0,
	<span class="enscript-string">&quot;Unlock TCP when sending packets down to IP&quot;</span>);

<span class="enscript-type">int</span> tcp_do_rfc3390 = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rfc3390,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_do_rfc3390, 1,
	<span class="enscript-string">&quot;Calculate intial slowstart cwnd depending on MSS&quot;</span>);

<span class="enscript-type">int</span> tcp_min_iaj_win = MIN_IAJ_WIN;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, min_iaj_win,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_min_iaj_win, 1,
	<span class="enscript-string">&quot;Minimum recv win based on inter-packet arrival jitter&quot;</span>);

<span class="enscript-type">int</span> tcp_acc_iaj_react_limit = ACC_IAJ_REACT_LIMIT;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, acc_iaj_react_limit,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_acc_iaj_react_limit, 1,
	<span class="enscript-string">&quot;Accumulated IAJ when receiver starts to react&quot;</span>);

uint32_t tcp_do_autosendbuf = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, doautosndbuf,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_do_autosendbuf, 1,
	<span class="enscript-string">&quot;Enable send socket buffer auto-tuning&quot;</span>);

uint32_t tcp_autosndbuf_inc = 8 * 1024;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, autosndbufinc,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_autosndbuf_inc, 1,
	<span class="enscript-string">&quot;Increment in send socket bufffer size&quot;</span>);

uint32_t tcp_autosndbuf_max = 512 * 1024;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, autosndbufmax,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_autosndbuf_max, 1,
	<span class="enscript-string">&quot;Maximum send socket buffer size&quot;</span>);

uint32_t tcp_prioritize_acks = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, ack_prioritize,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_prioritize_acks, 1,
	<span class="enscript-string">&quot;Prioritize pure acks&quot;</span>);

uint32_t tcp_use_rtt_recvbg = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rtt_recvbg,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_use_rtt_recvbg, 1,
	<span class="enscript-string">&quot;Use RTT for bg recv algorithm&quot;</span>);

uint32_t tcp_recv_throttle_minwin = 16 * 1024;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, recv_throttle_minwin, 
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_recv_throttle_minwin, 1,
	<span class="enscript-string">&quot;Minimum recv win for throttling&quot;</span>);

int32_t tcp_enable_tlp = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, enable_tlp,
	CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;tcp_enable_tlp, 1, <span class="enscript-string">&quot;Enable Tail loss probe&quot;</span>);

<span class="enscript-type">static</span> int32_t packchain_newlist = 0;
<span class="enscript-type">static</span> int32_t packchain_looped = 0;
<span class="enscript-type">static</span> int32_t packchain_sent = 0;

<span class="enscript-comment">/* temporary: for testing */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> slowlink_wsize;	<span class="enscript-comment">/* window correction for slow links */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_enable; 		<span class="enscript-comment">/* firewall check for packet chaining */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_bypass; 		<span class="enscript-comment">/* firewall check: disable packet chaining if there is rules */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

<span class="enscript-type">extern</span> u_int32_t dlil_filter_disable_tso_count;
<span class="enscript-type">extern</span> u_int32_t kipf_count;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_recv_bg;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_ip_output</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, int32_t, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf* <span class="enscript-function-name">tcp_send_lroacks</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> tcphdr *th);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_recv_throttle</span>(<span class="enscript-type">struct</span> tcpcb *tp);

<span class="enscript-type">static</span> int32_t <span class="enscript-function-name">tcp_tfo_check</span>(<span class="enscript-type">struct</span> tcpcb *tp, int32_t len)
{
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> optlen = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cookie_len;

	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NOOPT)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fallback</span>;

	<span class="enscript-keyword">if</span> (!tcp_heuristic_do_tfo(tp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fallback</span>;

	optlen += TCPOLEN_MAXSEG;

	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_REQ_SCALE)
		optlen += 4;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp; mptcp_enable &amp;&amp;
	    tp-&gt;t_rxtshift &lt;= mptcp_mpcap_retries)
		optlen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mptcp_mpcapable_opt_common) + <span class="enscript-keyword">sizeof</span>(mptcp_key_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_REQ_TSTMP)
		optlen += TCPOLEN_TSTAMP_APPA;

	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp))
		optlen += TCPOLEN_SACK_PERMITTED;

	<span class="enscript-comment">/* Now, decide whether to use TFO or not */</span>

	<span class="enscript-comment">/* Don't even bother trying if there is no space at all... */</span>
	<span class="enscript-keyword">if</span> (MAX_TCPOPTLEN - optlen &lt; TCPOLEN_FASTOPEN_REQ)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fallback</span>;

	cookie_len = tcp_cache_get_cookie_len(tp);
	<span class="enscript-keyword">if</span> (cookie_len == 0)
		<span class="enscript-comment">/* No cookie, so we request one */</span>
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* Do not send SYN+data if there is more in the queue than MSS */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_cc &gt; (tp-&gt;t_maxopd - MAX_TCPOPTLEN))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fallback</span>;

	<span class="enscript-comment">/* Ok, everything looks good. We can go on and do TFO */</span>
	<span class="enscript-keyword">return</span> (len);

<span class="enscript-reference">fallback</span>:
	tp-&gt;t_flagsext &amp;= ~TF_FASTOPEN;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* Returns the number of bytes written to the TCP option-space */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>
<span class="enscript-function-name">tcp_tfo_write_cookie_rep</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">unsigned</span> optlen, u_char *opt)
{
	u_char out[CCAES_BLOCK_SIZE];
	<span class="enscript-type">unsigned</span> ret = 0;
	u_char *bp;

	<span class="enscript-keyword">if</span> ((MAX_TCPOPTLEN - optlen) &lt;
	    (TCPOLEN_FASTOPEN_REQ + TFO_COOKIE_LEN_DEFAULT))
		<span class="enscript-keyword">return</span> (ret);

	tcp_tfo_gen_cookie(tp-&gt;t_inpcb, out, <span class="enscript-keyword">sizeof</span>(out));

	bp = opt + optlen;

	*bp++ = TCPOPT_FASTOPEN;
	*bp++ = 2 + TFO_COOKIE_LEN_DEFAULT;
	memcpy(bp, out, TFO_COOKIE_LEN_DEFAULT);
	ret += 2 + TFO_COOKIE_LEN_DEFAULT;

	tp-&gt;t_tfo_stats |= TFO_S_COOKIE_SENT;
	tcpstat.tcps_tfo_cookie_sent++;

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span>
<span class="enscript-function-name">tcp_tfo_write_cookie</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">unsigned</span> optlen, int32_t *len,
		     u_char *opt)
{
	u_int8_t tfo_len = MAX_TCPOPTLEN - optlen - TCPOLEN_FASTOPEN_REQ;
	<span class="enscript-type">unsigned</span> ret = 0;
	<span class="enscript-type">int</span> res;
	u_char *bp;

	bp = opt + optlen;

	<span class="enscript-comment">/*
	 * The cookie will be copied in the appropriate place within the
	 * TCP-option space. That way we avoid the need for an intermediate
	 * variable.
	 */</span>
	res = tcp_cache_get_cookie(tp, bp + TCPOLEN_FASTOPEN_REQ, &amp;tfo_len);
	<span class="enscript-keyword">if</span> (res == 0) {
		*bp++ = TCPOPT_FASTOPEN;
		*bp++ = TCPOLEN_FASTOPEN_REQ;
		ret += TCPOLEN_FASTOPEN_REQ;

		tp-&gt;t_tfo_flags |= TFO_F_COOKIE_REQ;

		tp-&gt;t_tfo_stats |= TFO_S_COOKIE_REQ;
		tcpstat.tcps_tfo_cookie_req++;
	} <span class="enscript-keyword">else</span> {
		*bp++ = TCPOPT_FASTOPEN;
		*bp++ = TCPOLEN_FASTOPEN_REQ + tfo_len;

		ret += TCPOLEN_FASTOPEN_REQ + tfo_len;

		tp-&gt;t_tfo_flags |= TFO_F_COOKIE_SENT;

		<span class="enscript-comment">/* If there is some data, let's track it */</span>
		<span class="enscript-keyword">if</span> (*len) {
			tp-&gt;t_tfo_stats |= TFO_S_SYN_DATA_SENT;
			tcpstat.tcps_tfo_syn_data_sent++;
		}
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> inline bool
<span class="enscript-function-name">tcp_send_ecn_flags_on_syn</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span>(!((tp-&gt;ecn_flags &amp; TE_SETUPSENT) ||
	    (so-&gt;so_flags &amp; SOF_MP_SUBFLOW) ||
	    (tp-&gt;t_flagsext &amp; TF_FASTOPEN)));
}

<span class="enscript-comment">/*
 * Tcp output routine: figure out what should be sent and send it.
 *
 * Returns:	0			Success
 *		EADDRNOTAVAIL
 *		ENOBUFS
 *		EMSGSIZE
 *		EHOSTUNREACH
 *		ENETDOWN
 *	ip_output_list:ENOMEM
 *	ip_output_list:EADDRNOTAVAIL
 *	ip_output_list:ENETUNREACH
 *	ip_output_list:EHOSTUNREACH
 *	ip_output_list:EACCES
 *	ip_output_list:EMSGSIZE
 *	ip_output_list:ENOBUFS
 *	ip_output_list:???		[ignorable: mostly IPSEC/firewall/DLIL]
 *	ip6_output_list:EINVAL
 *	ip6_output_list:EOPNOTSUPP
 *	ip6_output_list:EHOSTUNREACH
 *	ip6_output_list:EADDRNOTAVAIL
 *	ip6_output_list:ENETUNREACH
 *	ip6_output_list:EMSGSIZE
 *	ip6_output_list:ENOBUFS
 *	ip6_output_list:???		[ignorable: mostly IPSEC/firewall/DLIL]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_output</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	int32_t len, recwin, sendwin, off;
	<span class="enscript-type">int</span> flags, error;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">struct</span> ipovly *ipov = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> tcphdr *th;
	u_char opt[TCP_MAXOLEN];
	<span class="enscript-type">unsigned</span> ipoptlen, optlen, hdrlen;
	<span class="enscript-type">int</span> idle, sendalot, lost = 0;
	<span class="enscript-type">int</span> i, sack_rxmit;
	<span class="enscript-type">int</span> tso = 0;
	<span class="enscript-type">int</span> sack_bytes_rxmt;
	tcp_seq old_snd_nxt = 0;
	<span class="enscript-type">struct</span> sackhole *p;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-type">unsigned</span> ipsec_optlen = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	<span class="enscript-type">int</span>    idle_time = 0;
	<span class="enscript-type">struct</span> mbuf *packetlist = NULL;
	<span class="enscript-type">struct</span> mbuf *tp_inp_options = inp-&gt;inp_depend4.inp4_options;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = inp-&gt;inp_vflag &amp; INP_IPV6 ;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">short</span> packchain_listadd = 0;
	<span class="enscript-type">int</span> so_options = so-&gt;so_options;
	<span class="enscript-type">struct</span> rtentry *rt;
	u_int32_t basertt, svc_flags = 0, allocated_len;
	u_int32_t lro_ackmore = (tp-&gt;t_lropktlen != 0) ? 1 : 0;
	<span class="enscript-type">struct</span> mbuf *mnext = NULL;
	<span class="enscript-type">int</span> sackoptlen = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *dlenp = NULL;
	u_int8_t *finp = NULL;
	u_int32_t *sseqp = NULL;
	u_int64_t dss_val = 0;
	boolean_t mptcp_acknow = FALSE;
	boolean_t early_data_sent = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	boolean_t cell = FALSE;
	boolean_t wifi = FALSE;
	boolean_t wired = FALSE;
	boolean_t sack_rescue_rxt = FALSE;

	<span class="enscript-comment">/*
	 * Determine length of data that should be transmitted,
	 * and flags that will be used.
	 * If there is some data or critical controls (SYN, RST)
	 * to send, then transmit; otherwise, investigate further.
	 */</span>
	idle = (tp-&gt;t_flags &amp; TF_LASTIDLE) || (tp-&gt;snd_max == tp-&gt;snd_una);

	<span class="enscript-comment">/* Since idle_time is signed integer, the following integer subtraction
	 * will take care of wrap around of tcp_now
	 */</span>
	idle_time = tcp_now - tp-&gt;t_rcvtime;
	<span class="enscript-keyword">if</span> (idle &amp;&amp; idle_time &gt;= TCP_IDLETIMEOUT(tp)) {
		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;after_idle != NULL &amp;&amp;
		    (tp-&gt;tcp_cc_index != TCP_CC_ALGO_CUBIC_INDEX ||
		    idle_time &gt;= TCP_CC_CWND_NONVALIDATED_PERIOD)) {
			CC_ALGO(tp)-&gt;after_idle(tp);
			tcp_ccdbg_trace(tp, NULL, TCP_CC_IDLE_TIMEOUT);
		}

		<span class="enscript-comment">/*
		 * Do some other tasks that need to be done after
		 * idle time
		 */</span>
		<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))
			tcp_rxtseg_clean(tp);

		<span class="enscript-comment">/* If stretch ack was auto-disabled, re-evaluate it */</span>
		tcp_cc_after_idle_stretchack(tp);
	}
	tp-&gt;t_flags &amp;= ~TF_LASTIDLE;
	<span class="enscript-keyword">if</span> (idle) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_MORETOCOME) {
			tp-&gt;t_flags |= TF_LASTIDLE;
			idle = 0;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span> 
	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_RESET) {
		tcp_check_timer_state(tp);
		<span class="enscript-comment">/* 
		 * Once a RST has been sent for an MPTCP subflow, 
		 * the subflow socket stays around until deleted.
		 * No packets such as FINs must be sent after RST.
		 */</span>
		<span class="enscript-keyword">return</span> (0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

<span class="enscript-reference">again</span>:
	KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_START, 0,0,0,0,0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		KERNEL_DEBUG(DBG_LAYER_BEG,
		     ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
		     (((inp-&gt;in6p_laddr.s6_addr16[0] &amp; 0xffff) &lt;&lt; 16) |
		      (inp-&gt;in6p_faddr.s6_addr16[0] &amp; 0xffff)),
		     sendalot,0,0);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>

	{
		KERNEL_DEBUG(DBG_LAYER_BEG,
		     ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
		     (((inp-&gt;inp_laddr.s_addr &amp; 0xffff) &lt;&lt; 16) |
		      (inp-&gt;inp_faddr.s_addr &amp; 0xffff)),
		     sendalot,0,0);
	}
	<span class="enscript-comment">/*
	 * If the route generation id changed, we need to check that our
	 * local (source) IP address is still valid. If it isn't either
	 * return error or silently do nothing (assuming the address will
	 * come back before the TCP connection times out).
	 */</span>
	rt = inp-&gt;inp_route.ro_rt;
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; ROUTE_UNUSABLE(&amp;tp-&gt;t_inpcb-&gt;inp_route)) {
		<span class="enscript-type">struct</span> ifnet *ifp;
		<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;
		<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL;
		<span class="enscript-type">int</span> found_srcaddr = 0;

		<span class="enscript-comment">/* disable multipages at the socket */</span>
		somultipages(so, FALSE);

		<span class="enscript-comment">/* Disable TSO for the socket until we know more */</span>
		tp-&gt;t_flags &amp;= ~TF_TSO;

		soif2kcl(so, FALSE);

		<span class="enscript-keyword">if</span> (isipv6) {
			ia6 = ifa_foraddr6(&amp;inp-&gt;in6p_laddr);
			<span class="enscript-keyword">if</span> (ia6 != NULL)
				found_srcaddr = 1;
		} <span class="enscript-keyword">else</span> {
			ia = ifa_foraddr(inp-&gt;inp_laddr.s_addr);
			<span class="enscript-keyword">if</span> (ia != NULL)
				found_srcaddr = 1;
		}

		<span class="enscript-comment">/* check that the source address is still valid */</span>
		<span class="enscript-keyword">if</span> (found_srcaddr == 0) {
			soevent(so,
			    (SO_FILT_HINT_LOCKED | SO_FILT_HINT_NOSRCADDR));

			<span class="enscript-keyword">if</span> (tp-&gt;t_state &gt;= TCPS_CLOSE_WAIT) {
				tcp_drop(tp, EADDRNOTAVAIL);
				<span class="enscript-keyword">return</span>(EADDRNOTAVAIL);
			}

			<span class="enscript-comment">/* Set retransmit  timer if it wasn't set,
			 * reset Persist timer and shift register as the
			 * advertised peer window may not be valid anymore
			 */</span>

			<span class="enscript-keyword">if</span> (!tp-&gt;t_timer[TCPT_REXMT]) {
				tp-&gt;t_timer[TCPT_REXMT] =
				    OFFSET_FROM_START(tp, tp-&gt;t_rxtcur);
				<span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_PERSIST]) {
					tp-&gt;t_timer[TCPT_PERSIST] = 0;
					tp-&gt;t_rxtshift = 0;
					tp-&gt;t_persist_stop = 0;
					tp-&gt;t_rxtstart = 0;
				}
			}

			<span class="enscript-keyword">if</span> (tp-&gt;t_pktlist_head != NULL)
				m_freem_list(tp-&gt;t_pktlist_head);
			TCP_PKTLIST_CLEAR(tp);

			<span class="enscript-comment">/* drop connection if source address isn't available */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_NOADDRAVAIL) { 
				tcp_drop(tp, EADDRNOTAVAIL);
				<span class="enscript-keyword">return</span>(EADDRNOTAVAIL);
			} <span class="enscript-keyword">else</span> {
				tcp_check_timer_state(tp);
				<span class="enscript-keyword">return</span>(0); <span class="enscript-comment">/* silently ignore, keep data in socket: address may be back */</span>
			}
		}
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);

		<span class="enscript-keyword">if</span> (ia6 != NULL)
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);

		<span class="enscript-comment">/*
		 * Address is still valid; check for multipages capability
		 * again in case the outgoing interface has changed.
		 */</span>
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> ((ifp = rt-&gt;rt_ifp) != NULL) {
			somultipages(so, (ifp-&gt;if_hwassist &amp; IFNET_MULTIPAGES));
			tcp_set_tso(tp, ifp);
			soif2kcl(so,
			    (ifp-&gt;if_eflags &amp; IFEF_2KCL));
		}
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_UP)
			RT_GENID_SYNC(rt);
		<span class="enscript-comment">/*
		 * See if we should do MTU discovery. Don't do it if:
		 *	1) it is disabled via the sysctl
		 *	2) the route isn't up
		 *	3) the MTU is locked (if it is, then discovery
		 *         has been disabled)
		 */</span>

	    	<span class="enscript-keyword">if</span> (!path_mtu_discovery || ((rt != NULL) &amp;&amp; 
		    (!(rt-&gt;rt_flags &amp; RTF_UP) ||
		    (rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU)))) 
			tp-&gt;t_flags &amp;= ~TF_PMTUD;
		<span class="enscript-keyword">else</span>
			tp-&gt;t_flags |= TF_PMTUD;

		RT_UNLOCK(rt);
	}

	<span class="enscript-keyword">if</span> (rt != NULL) {
		cell = IFNET_IS_CELLULAR(rt-&gt;rt_ifp);
		wifi = (!cell &amp;&amp; IFNET_IS_WIFI(rt-&gt;rt_ifp));
		wired = (!wifi &amp;&amp; IFNET_IS_WIRED(rt-&gt;rt_ifp));
	}

	<span class="enscript-comment">/*
	 * If we've recently taken a timeout, snd_max will be greater than
	 * snd_nxt.  There may be SACK information that allows us to avoid
	 * resending already delivered data.  Adjust snd_nxt accordingly.
	 */</span>
	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max))
		tcp_sack_adjust(tp);
	sendalot = 0;
	off = tp-&gt;snd_nxt - tp-&gt;snd_una;
	sendwin = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd);

	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_SLOWLINK &amp;&amp; slowlink_wsize &gt; 0)
		sendwin = min(sendwin, slowlink_wsize);

	flags = tcp_outflags[tp-&gt;t_state];
	<span class="enscript-comment">/*
	 * Send any SACK-generated retransmissions.  If we're explicitly
	 * trying to send out new data (when sendalot is 1), bypass this
	 * function. If we retransmit in fast recovery mode, decrement
	 * snd_cwnd, since we're replacing a (future) new transmission
	 * with a retransmission now, and we previously incremented
	 * snd_cwnd in tcp_input().
	 */</span>
	<span class="enscript-comment">/*
	 * Still in sack recovery , reset rxmit flag to zero.
	 */</span>
	sack_rxmit = 0;
	sack_bytes_rxmt = 0;
	len = 0;
	p = NULL;
	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; IN_FASTRECOVERY(tp) &amp;&amp;
	    (p = tcp_sack_output(tp, &amp;sack_bytes_rxmt))) {
		int32_t cwin;
		
		cwin = min(tp-&gt;snd_wnd, tp-&gt;snd_cwnd) - sack_bytes_rxmt;
		<span class="enscript-keyword">if</span> (cwin &lt; 0)
			cwin = 0;
		<span class="enscript-comment">/* Do not retransmit SACK segments beyond snd_recover */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(p-&gt;end, tp-&gt;snd_recover)) {
			<span class="enscript-comment">/*
			 * (At least) part of sack hole extends beyond
			 * snd_recover. Check to see if we can rexmit data
			 * for this hole.
			 */</span>
			<span class="enscript-keyword">if</span> (SEQ_GEQ(p-&gt;rxmit, tp-&gt;snd_recover)) {
				<span class="enscript-comment">/*
				 * Can't rexmit any more data for this hole.
				 * That data will be rexmitted in the next
				 * sack recovery episode, when snd_recover
				 * moves past p-&gt;rxmit.
				 */</span>
				p = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">after_sack_rexmit</span>;
			} <span class="enscript-keyword">else</span>
				<span class="enscript-comment">/* Can rexmit part of the current hole */</span>
				len = ((int32_t)min(cwin,
						   tp-&gt;snd_recover - p-&gt;rxmit));
		} <span class="enscript-keyword">else</span> {
			len = ((int32_t)min(cwin, p-&gt;end - p-&gt;rxmit));
		}
		<span class="enscript-keyword">if</span> (len &gt; 0) {
			off = p-&gt;rxmit - tp-&gt;snd_una; 
			sack_rxmit = 1;
			sendalot = 1;
			tcpstat.tcps_sack_rexmits++;
			tcpstat.tcps_sack_rexmit_bytes +=
			    min(len, tp-&gt;t_maxseg);
			<span class="enscript-keyword">if</span> (nstat_collect) {
				nstat_route_tx(inp-&gt;inp_route.ro_rt, 1,
					min(len, tp-&gt;t_maxseg),
					NSTAT_TX_FLAG_RETRANSMIT);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txpackets, 1);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txbytes, min(len, tp-&gt;t_maxseg));
				tp-&gt;t_stat.txretransmitbytes += min(len, tp-&gt;t_maxseg);
			}
		} <span class="enscript-keyword">else</span> {
			len = 0;
		}
	}
<span class="enscript-reference">after_sack_rexmit</span>:
	<span class="enscript-comment">/*
	 * Get standard flags, and add SYN or FIN if requested by 'hidden'
	 * state flags.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDFIN)
		flags |= TH_FIN;
	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDSYN)
		flags |= TH_SYN;

	<span class="enscript-comment">/*
	 * If in persist timeout with window of 0, send 1 byte.
	 * Otherwise, if window is small but nonzero
	 * and timer expired, we will send what we can
	 * and go to transmit state.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_FORCE) {
		<span class="enscript-keyword">if</span> (sendwin == 0) {
			<span class="enscript-comment">/*
			 * If we still have some data to send, then
			 * clear the FIN bit.  Usually this would
			 * happen below when it realizes that we
			 * aren't sending all the data.  However,
			 * if we have exactly 1 byte of unsent data,
			 * then it won't clear the FIN bit below,
			 * and if we are in persist state, we wind
			 * up sending the packet without recording
			 * that we sent the FIN bit.
			 *
			 * We can't just blindly clear the FIN bit,
			 * because if we don't have any more data
			 * to send then the probe will be the FIN
			 * itself.
			 */</span>
			<span class="enscript-keyword">if</span> (off &lt; so-&gt;so_snd.sb_cc)
				flags &amp;= ~TH_FIN;
			sendwin = 1;
		} <span class="enscript-keyword">else</span> {
			tp-&gt;t_timer[TCPT_PERSIST] = 0;
			tp-&gt;t_rxtshift = 0;
			tp-&gt;t_rxtstart = 0;
			tp-&gt;t_persist_stop = 0;
		}
	}

	<span class="enscript-comment">/*
	 * If snd_nxt == snd_max and we have transmitted a FIN, the
	 * offset will be &gt; 0 even if so_snd.sb_cc is 0, resulting in
	 * a negative length.  This can also occur when TCP opens up
	 * its congestion window while receiving additional duplicate
	 * acks after fast-retransmit because TCP will reset snd_nxt
	 * to snd_max after the fast-retransmit.
	 *
	 * In the normal retransmit-FIN-only case, however, snd_nxt will
	 * be set to snd_una, the offset will be 0, and the length may
	 * wind up 0.
	 *
	 * If sack_rxmit is true we are retransmitting from the scoreboard
	 * in which case len is already set.
	 */</span>
	<span class="enscript-keyword">if</span> (sack_rxmit == 0) {
		<span class="enscript-keyword">if</span> (sack_bytes_rxmt == 0) {
			len = min(so-&gt;so_snd.sb_cc, sendwin) - off;
		} <span class="enscript-keyword">else</span> {
			int32_t cwin;

			cwin = tp-&gt;snd_cwnd -
			    (tp-&gt;snd_nxt - tp-&gt;sack_newdata) -
			    sack_bytes_rxmt;
			<span class="enscript-keyword">if</span> (cwin &lt; 0)
				cwin = 0;
                        <span class="enscript-comment">/*
			 * We are inside of a SACK recovery episode and are
			 * sending new data, having retransmitted all the
			 * data possible in the scoreboard.
			 */</span>
			len = min(so-&gt;so_snd.sb_cc, tp-&gt;snd_wnd) 
			       - off;
			<span class="enscript-comment">/*
			 * Don't remove this (len &gt; 0) check !
			 * We explicitly check for len &gt; 0 here (although it 
			 * isn't really necessary), to work around a gcc 
			 * optimization issue - to force gcc to compute
			 * len above. Without this check, the computation
			 * of len is bungled by the optimizer.
			 */</span>
			<span class="enscript-keyword">if</span> (len &gt; 0) {
				len = imin(len, cwin);
			} <span class="enscript-keyword">else</span> {
				len = 0;
			}
			<span class="enscript-comment">/*
			 * At this point SACK recovery can not send any
			 * data from scoreboard or any new data. Check
			 * if we can do a rescue retransmit towards the
			 * tail end of recovery window.
			 */</span>
			<span class="enscript-keyword">if</span> (len == 0 &amp;&amp; cwin &gt; 0 &amp;&amp;
			    SEQ_LT(tp-&gt;snd_fack, tp-&gt;snd_recover) &amp;&amp;
			    !(tp-&gt;t_flagsext &amp; TF_RESCUE_RXT)) {
				len = min((tp-&gt;snd_recover - tp-&gt;snd_fack),
				    tp-&gt;t_maxseg);
				len = imin(len, cwin);
				old_snd_nxt = tp-&gt;snd_nxt;
				sack_rescue_rxt = TRUE;
				tp-&gt;snd_nxt = tp-&gt;snd_recover - len;
				<span class="enscript-comment">/*
				 * If FIN has been sent, snd_max
				 * must have been advanced to cover it.
				 */</span>
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_SENTFIN) &amp;&amp;
				    tp-&gt;snd_max == tp-&gt;snd_recover)
					tp-&gt;snd_nxt--;

				off = tp-&gt;snd_nxt - tp-&gt;snd_una;
				sendalot = 0;
				tp-&gt;t_flagsext |= TF_RESCUE_RXT;
			}
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_FASTJOIN_SEND) &amp;&amp;
	    (tp-&gt;t_state == TCPS_SYN_SENT) &amp;&amp;
	    (!(tp-&gt;t_flags &amp; TF_CLOSING)) &amp;&amp;
	    (so-&gt;so_snd.sb_cc != 0) &amp;&amp;
	    (tp-&gt;t_rxtshift == 0)) {
		flags &amp;= ~TH_SYN;
		flags |= TH_ACK;
		off = 0;
		len = min(so-&gt;so_snd.sb_cc, tp-&gt;t_maxseg);
		early_data_sent = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (early_data_sent) {
		<span class="enscript-comment">/* for now, we allow only one data segment to be sent */</span>
		<span class="enscript-keyword">return</span> (0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	<span class="enscript-comment">/*
	 * Lop off SYN bit if it has already been sent.  However, if this
	 * is SYN-SENT state and if segment contains data and if we don't
	 * know that foreign host supports TAO, suppress sending segment.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; TH_SYN) &amp;&amp; SEQ_GT(tp-&gt;snd_nxt, tp-&gt;snd_una)) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_SYN_RECEIVED || tfo_enabled(tp))
			flags &amp;= ~TH_SYN;
		off--, len++;
		<span class="enscript-keyword">if</span> (len &gt; 0 &amp;&amp; tp-&gt;t_state == TCPS_SYN_SENT) {
			<span class="enscript-keyword">while</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
				tp-&gt;t_pktlist_head != NULL) {
				packetlist = tp-&gt;t_pktlist_head;
				packchain_listadd = tp-&gt;t_lastchain;
				packchain_sent++;
				TCP_PKTLIST_CLEAR(tp);

				error = tcp_ip_output(so, tp, packetlist,
				    packchain_listadd, tp_inp_options,
				    (so_options &amp; SO_DONTROUTE),
				    (sack_rxmit | (sack_bytes_rxmt != 0)), 0,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				    isipv6);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
				    0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>


			}

			<span class="enscript-comment">/*
			 * tcp was closed while we were in ip,
			 * resume close 
			 */</span>
			<span class="enscript-keyword">if</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
				(tp-&gt;t_flags &amp; TF_CLOSING)) {
				tp-&gt;t_flags &amp;= ~TF_CLOSING;
				(<span class="enscript-type">void</span>) tcp_close(tp);
			} <span class="enscript-keyword">else</span> {
				tcp_check_timer_state(tp);
			}
			KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END,
			    0,0,0,0,0);
			<span class="enscript-keyword">return</span>(0);
		}
	}

	<span class="enscript-comment">/*
	 * Be careful not to send data and/or FIN on SYN segments.
	 * This measure is needed to prevent interoperability problems
	 * with not fully conformant TCP implementations.
	 *
	 * In case of TFO, we handle the setting of the len in
	 * tcp_tfo_check. In case TFO is not enabled, never ever send
	 * SYN+data.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; TH_SYN) &amp;&amp; !tfo_enabled(tp)) {
		len = 0;
		flags &amp;= ~TH_FIN;
	}

	<span class="enscript-keyword">if</span> ((flags &amp; TH_SYN) &amp;&amp; tp-&gt;t_state &lt;= TCPS_SYN_SENT &amp;&amp; tfo_enabled(tp))
		len = tcp_tfo_check(tp, len);

	<span class="enscript-comment">/*
	 * The check here used to be (len &lt; 0). Some times len is zero
	 * when the congestion window is closed and we need to check
	 * if persist timer has to be set in that case. But don't set 
	 * persist until connection is established.
	 */</span>  
	<span class="enscript-keyword">if</span> (len &lt;= 0 &amp;&amp; !(flags &amp; TH_SYN)) {
		<span class="enscript-comment">/*
		 * If FIN has been sent but not acked,
		 * but we haven't been called to retransmit,
		 * len will be &lt; 0.  Otherwise, window shrank
		 * after we sent into it.  If window shrank to 0,
		 * cancel pending retransmit, pull snd_nxt back
		 * to (closed) window, and set the persist timer
		 * if it isn't already going.  If the window didn't
		 * close completely, just wait for an ACK.
		 */</span>
		len = 0;
		<span class="enscript-keyword">if</span> (sendwin == 0) {
			tp-&gt;t_timer[TCPT_REXMT] = 0;
			tp-&gt;t_timer[TCPT_PTO] = 0;
			tp-&gt;t_rxtshift = 0;
			tp-&gt;t_rxtstart = 0;
			tp-&gt;snd_nxt = tp-&gt;snd_una;
			off = 0;
			<span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_PERSIST] == 0)
				tcp_setpersist(tp);
		}
	}

	<span class="enscript-comment">/*
	 * Automatic sizing of send socket buffer. Increase the send
	 * socket buffer size if all of the following criteria are met
	 *	1. the receiver has enough buffer space for this data
	 *	2. send buffer is filled to 7/8th with data (so we actually
	 *	   have data to make use of it);
	 *	3. our send window (slow start and congestion controlled) is
	 *	   larger than sent but unacknowledged data in send buffer.
	 */</span>
	basertt = get_base_rtt(tp);
	<span class="enscript-keyword">if</span> (tcp_do_autosendbuf == 1 &amp;&amp;
	    !INP_WAIT_FOR_IF_FEEDBACK(inp) &amp;&amp; !IN_FASTRECOVERY(tp) &amp;&amp;
	    (so-&gt;so_snd.sb_flags &amp; (SB_AUTOSIZE | SB_TRIM)) == SB_AUTOSIZE &amp;&amp;
	    tcp_cansbgrow(&amp;so-&gt;so_snd)) {
		<span class="enscript-keyword">if</span> ((tp-&gt;snd_wnd / 4 * 5) &gt;= so-&gt;so_snd.sb_hiwat &amp;&amp;
		    so-&gt;so_snd.sb_cc &gt;= (so-&gt;so_snd.sb_hiwat / 8 * 7) &amp;&amp;
		    sendwin &gt;= (so-&gt;so_snd.sb_cc - 
			(tp-&gt;snd_nxt - tp-&gt;snd_una))) {
			<span class="enscript-comment">/* Also increase the send buffer only if the 
			 * round-trip time is not increasing because we do
			 * not want to contribute to latency by filling
			 * buffers.
			 * We also do not want to hold onto application's
			 * old data for too long. Interactive applications
			 * would rather discard old data.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;t_rttcur &lt;= (basertt + 25)) {
				<span class="enscript-keyword">if</span> (sbreserve(&amp;so-&gt;so_snd,
				    min(so-&gt;so_snd.sb_hiwat + tcp_autosndbuf_inc,
					tcp_autosndbuf_max)) == 1) {
					so-&gt;so_snd.sb_idealsize = so-&gt;so_snd.sb_hiwat;
				}
			} <span class="enscript-keyword">else</span> {
				so-&gt;so_snd.sb_idealsize =
				    max(tcp_sendspace, so-&gt;so_snd.sb_hiwat -
					(2 * tcp_autosndbuf_inc));
				so-&gt;so_snd.sb_flags |= SB_TRIM;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Truncate to the maximum segment length or enable TCP Segmentation
	 * Offloading (if supported by hardware) and ensure that FIN is removed
	 * if the length no longer contains the last data byte.
	 *
	 * TSO may only be used if we are in a pure bulk sending state.
	 * The presence of TCP-MD5, SACK retransmits, SACK advertizements,
	 * ipfw rules and IP options, as well as disabling hardware checksum
	 * offload prevent using TSO.  With TSO the TCP header is the same
	 * (except for the sequence number) for all generated packets.  This
	 * makes it impossible to transmit any options which vary per generated
	 * segment or packet.
	 *
	 * The length of TSO bursts is limited to TCP_MAXWIN.  That limit and
	 * removal of FIN (if not already catched here) are handled later after
	 * the exact length of the TCP options are known.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * Pre-calculate here as we save another lookup into the darknesses
	 * of IPsec that way and can actually decide if TSO is ok.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0)
		ipsec_optlen = ipsec_hdrsiz_tcp(tp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (len &gt; tp-&gt;t_maxseg) {
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_TSO) &amp;&amp; tcp_do_tso &amp;&amp; hwcksum_tx &amp;&amp;
		    ip_use_randomid &amp;&amp; kipf_count == 0 &amp;&amp;
		    dlil_filter_disable_tso_count == 0 &amp;&amp;
		    tp-&gt;rcv_numsacks == 0 &amp;&amp; sack_rxmit == 0  &amp;&amp;
		    sack_bytes_rxmt == 0 &amp;&amp;
		    inp-&gt;inp_options == NULL &amp;&amp;
		    inp-&gt;in6p_options == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		    &amp;&amp; ipsec_optlen == 0
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		    &amp;&amp; (fw_enable == 0 || fw_bypass)
#<span class="enscript-reference">endif</span>
		    ) {
			tso = 1;
			sendalot = 0;
		} <span class="enscript-keyword">else</span> {
			len = tp-&gt;t_maxseg;
			sendalot = 1;
			tso = 0;
		}
	}

	<span class="enscript-comment">/* Send one segment or less as a tail loss probe */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_SENT_TLPROBE) {
		len = min(len, tp-&gt;t_maxseg);
		sendalot = 0;
		tso = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp; 
	    !(tp-&gt;t_mpflags &amp; TMPF_TCP_FALLBACK)) {
		<span class="enscript-type">int</span> newlen = len;
		<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
		    (tp-&gt;t_state &gt; TCPS_CLOSED) &amp;&amp;
		    ((tp-&gt;t_mpflags &amp; TMPF_SND_MPPRIO) ||
		    (tp-&gt;t_mpflags &amp; TMPF_SND_REM_ADDR) ||
		    (tp-&gt;t_mpflags &amp; TMPF_SND_MPFAIL) ||
		    (tp-&gt;t_mpflags &amp; TMPF_MPCAP_RETRANSMIT))) {
			<span class="enscript-keyword">if</span> (len &gt; 0) {
				len = 0;
			}
			sendalot = 1;
			mptcp_acknow = TRUE;
		} <span class="enscript-keyword">else</span> {
			mptcp_acknow = FALSE;
		}
		<span class="enscript-comment">/*
		 * The contiguous bytes in the subflow socket buffer can be
		 * discontiguous at the MPTCP level. Since only one DSS 
		 * option can be sent in one packet, reduce length to match
		 * the contiguous MPTCP level. Set sendalot to send remainder.
		 */</span>
		<span class="enscript-keyword">if</span> (len &gt; 0)
			newlen = mptcp_adj_sendlen(so, off, len);
		<span class="enscript-keyword">if</span> (newlen &lt; len) {
			len = newlen;
			sendalot = 1;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-comment">/*
	 * If the socket is capable of doing unordered send,
	 * pull the amount of data that can be sent from the
	 * unordered priority queues to the serial queue in
	 * the socket buffer. If bytes are not yet available
	 * in the highest priority message, we may not be able 
	 * to send any new data. 
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
		<span class="enscript-keyword">if</span> ((off + len) &gt;
		    so-&gt;so_msg_state-&gt;msg_serial_bytes) {
			sbpull_unordered_data(so, off, len);

			<span class="enscript-comment">/* check if len needs to be modified */</span>
			<span class="enscript-keyword">if</span> ((off + len) &gt; 
			    so-&gt;so_msg_state-&gt;msg_serial_bytes) {
				len = so-&gt;so_msg_state-&gt;msg_serial_bytes - off;
				<span class="enscript-keyword">if</span> (len &lt;= 0) {
					len = 0;
					tcpstat.tcps_msg_sndwaithipri++;
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (sack_rxmit) {
		<span class="enscript-keyword">if</span> (SEQ_LT(p-&gt;rxmit + len, tp-&gt;snd_una + so-&gt;so_snd.sb_cc))
			flags &amp;= ~TH_FIN;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt + len, tp-&gt;snd_una + so-&gt;so_snd.sb_cc))
			flags &amp;= ~TH_FIN;
	}

	recwin = tcp_sbspace(tp);

	<span class="enscript-comment">/*
	 * Sender silly window avoidance.   We transmit under the following
	 * conditions when len is non-zero:
	 *
	 *	- we've timed out (e.g. persist timer)
	 *	- we need to retransmit
	 *	- We have a full segment (or more with TSO)
	 *	- This is the last buffer in a write()/send() and we are
	 *	  either idle or running NODELAY
	 *	- we have more then 1/2 the maximum send window's worth of
	 *	  data (receiver may be limited the window size)
	 */</span>
	<span class="enscript-keyword">if</span> (len) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_FORCE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
		<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
		<span class="enscript-keyword">if</span> (sack_rxmit)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;

		<span class="enscript-comment">/*
		 * Send new data on the connection only if it is
		 * not flow controlled
		 */</span>
		<span class="enscript-keyword">if</span> (!INP_WAIT_FOR_IF_FEEDBACK(inp) ||
		    tp-&gt;t_state != TCPS_ESTABLISHED) {
			<span class="enscript-keyword">if</span> (len &gt;= tp-&gt;t_maxseg)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
			<span class="enscript-keyword">if</span> (!(tp-&gt;t_flags &amp; TF_MORETOCOME) &amp;&amp;
			    (idle || tp-&gt;t_flags &amp; TF_NODELAY || 
			    tp-&gt;t_flags &amp; TF_MAXSEGSNT ||
			    ALLOW_LIMITED_TRANSMIT(tp)) &amp;&amp;
			    (tp-&gt;t_flags &amp; TF_NOPUSH) == 0 &amp;&amp;
			    len + off &gt;= so-&gt;so_snd.sb_cc)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
			<span class="enscript-keyword">if</span> (len &gt;= tp-&gt;max_sndwnd / 2 &amp;&amp; tp-&gt;max_sndwnd &gt; 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
		} <span class="enscript-keyword">else</span> {
			tcpstat.tcps_fcholdpacket++;
		}
	}

	<span class="enscript-comment">/*
	 * Compare available window to amount of window
	 * known to peer (as advertised window less
	 * next expected input).  If the difference is at least two
	 * max size segments, or at least 25% of the maximum possible
	 * window, then want to send a window update to peer.
	 * Skip this if the connection is in T/TCP half-open state.
	 */</span>
	<span class="enscript-keyword">if</span> (recwin &gt; 0 &amp;&amp; !(tp-&gt;t_flags &amp; TF_NEEDSYN)) {
		<span class="enscript-comment">/*
		 * &quot;adv&quot; is the amount we can increase the window,
		 * taking into account that we are limited by
		 * TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale.
		 */</span>
		int32_t adv, oldwin = 0;
		adv = imin(recwin, (<span class="enscript-type">int</span>)TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale) -
			(tp-&gt;rcv_adv - tp-&gt;rcv_nxt);

		<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;rcv_adv, tp-&gt;rcv_nxt))
			oldwin = tp-&gt;rcv_adv - tp-&gt;rcv_nxt;

		<span class="enscript-keyword">if</span> (adv &gt;= (int32_t) (2 * tp-&gt;t_maxseg)) {
			<span class="enscript-comment">/*
			 * Update only if the resulting scaled value of
			 * the window changed, or if there is a change in
			 * the sequence since the last ack. This avoids 
			 * what appears as dupe ACKS (see rdar://5640997)
			 *
			 * If streaming is detected avoid sending too many
			 * window updates. We will depend on the delack 
			 * timer to send a window update when needed.
			 */</span>
			<span class="enscript-keyword">if</span> (!(tp-&gt;t_flags &amp; TF_STRETCHACK) &amp;&amp;
				(tp-&gt;last_ack_sent != tp-&gt;rcv_nxt || 
				((oldwin + adv) &gt;&gt; tp-&gt;rcv_scale) &gt;
				(oldwin &gt;&gt; tp-&gt;rcv_scale))) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
			}

			<span class="enscript-comment">/*
			 * Make sure that the delayed ack timer is set if
			 * we delayed sending a window update because of 
			 * streaming detection.
			 */</span>
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_STRETCHACK) &amp;&amp;
				!(tp-&gt;t_flags &amp; TF_DELACK)) { 
				tp-&gt;t_flags |= TF_DELACK;
				tp-&gt;t_timer[TCPT_DELACK] = 
					OFFSET_FROM_START(tp, tcp_delack);
			}
		}
		<span class="enscript-keyword">if</span> (4 * adv &gt;= (int32_t) so-&gt;so_rcv.sb_hiwat) 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
	}

	<span class="enscript-comment">/*
	 * Send if we owe the peer an ACK, RST, SYN, or urgent data. ACKNOW
	 * is also a catch-all for the retransmit timer timeout case.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_ACKNOW)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
	<span class="enscript-keyword">if</span> ((flags &amp; TH_RST) ||
	    ((flags &amp; TH_SYN) &amp;&amp; (tp-&gt;t_flags &amp; TF_NEEDSYN) == 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
	<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_up, tp-&gt;snd_una))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> (mptcp_acknow)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	<span class="enscript-comment">/*
	 * If our state indicates that FIN should be sent
	 * and we have not yet done so, then we need to send.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; TH_FIN) &amp;&amp;
	    (!(tp-&gt;t_flags &amp; TF_SENTFIN) || tp-&gt;snd_nxt == tp-&gt;snd_una))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">send</span>;
	<span class="enscript-comment">/*
	 * In SACK, it is possible for tcp_output to fail to send a segment
	 * after the retransmission timer has been turned off.  Make sure
	 * that the retransmission timer is set.
	 */</span>
	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; (tp-&gt;t_state &gt;= TCPS_ESTABLISHED) &amp;&amp; 
	    SEQ_GT(tp-&gt;snd_max, tp-&gt;snd_una) &amp;&amp;
	    tp-&gt;t_timer[TCPT_REXMT] == 0 &amp;&amp;
	    tp-&gt;t_timer[TCPT_PERSIST] == 0) {
		tp-&gt;t_timer[TCPT_REXMT] = OFFSET_FROM_START(tp,
			tp-&gt;t_rxtcur);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">just_return</span>;
	} 
	<span class="enscript-comment">/*
	 * TCP window updates are not reliable, rather a polling protocol
	 * using ``persist'' packets is used to insure receipt of window
	 * updates.  The three ``states'' for the output side are:
	 *	idle			not doing retransmits or persists
	 *	persisting		to move a small or zero window
	 *	(re)transmitting	and thereby not persisting
	 *
	 * tp-&gt;t_timer[TCPT_PERSIST]
	 *	is set when we are in persist state.
	 * tp-&gt;t_force
	 *	is set when we are called to send a persist packet.
	 * tp-&gt;t_timer[TCPT_REXMT]
	 *	is set when we are retransmitting
	 * The output side is idle when both timers are zero.
	 *
	 * If send window is too small, there is data to transmit, and no
	 * retransmit or persist is pending, then go to persist state.
	 * If nothing happens soon, send when timer expires:
	 * if window is nonzero, transmit what we can,
	 * otherwise force out a byte.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_cc &amp;&amp; tp-&gt;t_timer[TCPT_REXMT] == 0 &amp;&amp;
	    tp-&gt;t_timer[TCPT_PERSIST] == 0) {
		tp-&gt;t_rxtshift = 0;
		tp-&gt;t_rxtstart = 0;
		tcp_setpersist(tp);
	}
<span class="enscript-reference">just_return</span>:
	<span class="enscript-comment">/*
	 * If there is no reason to send a segment, just return.
	 * but if there is some packets left in the packet list, send them now.
	 */</span>
	<span class="enscript-keyword">while</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
		tp-&gt;t_pktlist_head != NULL) {
		packetlist = tp-&gt;t_pktlist_head;
		packchain_listadd = tp-&gt;t_lastchain;
		packchain_sent++;
		TCP_PKTLIST_CLEAR(tp);

		error = tcp_ip_output(so, tp, packetlist,
		    packchain_listadd,
		    tp_inp_options, (so_options &amp; SO_DONTROUTE),
		    (sack_rxmit | (sack_bytes_rxmt != 0)), recwin,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		    isipv6);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
		    0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
	}
	<span class="enscript-comment">/* tcp was closed while we were in ip; resume close */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
		(tp-&gt;t_flags &amp; TF_CLOSING)) {
		tp-&gt;t_flags &amp;= ~TF_CLOSING;
		(<span class="enscript-type">void</span>) tcp_close(tp);
	} <span class="enscript-keyword">else</span> {
		tcp_check_timer_state(tp);
	}
	KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END, 0,0,0,0,0);
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">send</span>:
	<span class="enscript-comment">/*
	 * Set TF_MAXSEGSNT flag if the segment size is greater than
	 * the max segment size.
	 */</span>
	<span class="enscript-keyword">if</span> (len &gt; 0) {
		<span class="enscript-keyword">if</span> (len &gt;= tp-&gt;t_maxseg)
			tp-&gt;t_flags |= TF_MAXSEGSNT;
		<span class="enscript-keyword">else</span>
			tp-&gt;t_flags &amp;= ~TF_MAXSEGSNT;
	}
	<span class="enscript-comment">/*
	 * Before ESTABLISHED, force sending of initial options
	 * unless TCP set not to do any options.
	 * NOTE: we assume that the IP/TCP header plus TCP options
	 * always fit in a single mbuf, leaving room for a maximum
	 * link header, i.e.
	 *	max_linkhdr + sizeof (struct tcpiphdr) + optlen &lt;= MCLBYTES
	 */</span>
	optlen = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		hdrlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		hdrlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr);
	<span class="enscript-keyword">if</span> (flags &amp; TH_SYN) {
		tp-&gt;snd_nxt = tp-&gt;iss;
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_NOOPT) == 0) {
			u_short mss;

			opt[0] = TCPOPT_MAXSEG;
			opt[1] = TCPOLEN_MAXSEG;
			mss = htons((u_short) tcp_mssopt(tp));
			(<span class="enscript-type">void</span>)memcpy(opt + 2, &amp;mss, <span class="enscript-keyword">sizeof</span>(mss));
			optlen = TCPOLEN_MAXSEG;

			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_REQ_SCALE) &amp;&amp;
			    ((flags &amp; TH_ACK) == 0 ||
			    (tp-&gt;t_flags &amp; TF_RCVD_SCALE))) {
				*((u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen)) = htonl(
					TCPOPT_NOP &lt;&lt; 24 |
					TCPOPT_WINDOW &lt;&lt; 16 |
					TCPOLEN_WINDOW &lt;&lt; 8 |
					tp-&gt;request_r_scale);
				optlen += 4;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
			<span class="enscript-keyword">if</span> (mptcp_enable) {
				optlen = mptcp_setup_syn_opts(so, flags, opt,
				    optlen);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
		}
	}

	<span class="enscript-comment">/*
	 * Send a timestamp and echo-reply if this is a SYN and our side
	 * wants to use timestamps (TF_REQ_TSTMP is set) or both our side
	 * and our peer have sent timestamps in our SYN's.
 	 */</span>
 	<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &amp;&amp;
 	    (flags &amp; TH_RST) == 0 &amp;&amp;
	    ((flags &amp; TH_ACK) == 0 ||
	     (tp-&gt;t_flags &amp; TF_RCVD_TSTMP))) {
		u_int32_t *lp = (u_int32_t *)(<span class="enscript-type">void</span> *)(opt + optlen);

 		<span class="enscript-comment">/* Form timestamp option as shown in appendix A of RFC 1323. */</span>
 		*lp++ = htonl(TCPOPT_TSTAMP_HDR);
 		*lp++ = htonl(tcp_now);
 		*lp   = htonl(tp-&gt;ts_recent);
 		optlen += TCPOLEN_TSTAMP_APPA;
 	}

	<span class="enscript-comment">/* Note the timestamp for receive buffer autosizing */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;rfbuf_ts == 0 &amp;&amp; (so-&gt;so_rcv.sb_flags &amp; SB_AUTOSIZE))
		tp-&gt;rfbuf_ts = tcp_now;

	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; ((tp-&gt;t_flags &amp; TF_NOOPT) == 0)) {
		<span class="enscript-comment">/* 
		 * Tack on the SACK permitted option *last*.
		 * And do padding of options after tacking this on.
		 * This is because of MSS, TS, WinScale and Signatures are
		 * all present, we have just 2 bytes left for the SACK
		 * permitted option, which is just enough.
		 */</span>
		<span class="enscript-comment">/*
		 * If this is the first SYN of connection (not a SYN
		 * ACK), include SACK permitted option.  If this is a
		 * SYN ACK, include SACK permitted option if peer has
		 * already done so. This is only for active connect,
		 * since the syncache takes care of the passive connect.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; TH_SYN) &amp;&amp;
		    (!(flags &amp; TH_ACK) || (tp-&gt;t_flags &amp; TF_SACK_PERMIT))) {
			u_char *bp;
			bp = (u_char *)opt + optlen;

			*bp++ = TCPOPT_SACK_PERMITTED;
			*bp++ = TCPOLEN_SACK_PERMITTED;
			optlen += TCPOLEN_SACK_PERMITTED;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW) {
		<span class="enscript-comment">/*
		 * Its important to piggyback acks with data as ack only packets
		 * may get lost and data packets that don't send Data ACKs
		 * still advance the subflow level ACK and therefore make it
		 * hard for the remote end to recover in low cwnd situations.
		 */</span>
		<span class="enscript-keyword">if</span> (len != 0) {
			tp-&gt;t_mpflags |= (TMPF_SEND_DSN |
			    TMPF_MPTCP_ACKNOW);
		} <span class="enscript-keyword">else</span> {
			tp-&gt;t_mpflags |= TMPF_MPTCP_ACKNOW;
		}
		optlen = mptcp_setup_opts(tp, off, &amp;opt[0], optlen, flags,
		    len, &amp;dlenp, &amp;finp, &amp;dss_val, &amp;sseqp, &amp;mptcp_acknow);
		tp-&gt;t_mpflags &amp;= ~TMPF_SEND_DSN;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-keyword">if</span> (tfo_enabled(tp) &amp;&amp; !(tp-&gt;t_flags &amp; TF_NOOPT) &amp;&amp;
	    (flags &amp; (TH_SYN | TH_ACK)) == TH_SYN)
		optlen += tcp_tfo_write_cookie(tp, optlen, &amp;len, opt);

	<span class="enscript-keyword">if</span> (tfo_enabled(tp) &amp;&amp;
	    (flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK) &amp;&amp;
	    (tp-&gt;t_tfo_flags &amp; TFO_F_OFFER_COOKIE))
		optlen += tcp_tfo_write_cookie_rep(tp, optlen, opt);

	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; ((tp-&gt;t_flags &amp; TF_NOOPT) == 0)) {
		<span class="enscript-comment">/*
		 * Send SACKs if necessary.  This should be the last
		 * option processed.  Only as many SACKs are sent as
		 * are permitted by the maximum options size.
		 *
		 * In general, SACK blocks consume 8*n+2 bytes.
		 * So a full size SACK blocks option is 34 bytes
		 * (to generate 4 SACK blocks).  At a minimum,
		 * we need 10 bytes (to generate 1 SACK block).
		 * If TCP Timestamps (12 bytes) and TCP Signatures
		 * (18 bytes) are both present, we'll just have
		 * 10 bytes for SACK options 40 - (12 + 18).
		 */</span>
		<span class="enscript-keyword">if</span> (TCPS_HAVEESTABLISHED(tp-&gt;t_state) &amp;&amp;
		    (tp-&gt;t_flags &amp; TF_SACK_PERMIT) &amp;&amp;
		    (tp-&gt;rcv_numsacks &gt; 0 || TCP_SEND_DSACK_OPT(tp)) &amp;&amp;
		    MAX_TCPOPTLEN - optlen - 2 &gt;= TCPOLEN_SACK) {
			<span class="enscript-type">int</span> nsack, padlen;
			u_char *bp = (u_char *)opt + optlen;
			u_int32_t *lp;

			nsack = (MAX_TCPOPTLEN - optlen - 2) / TCPOLEN_SACK;
			nsack = min(nsack, (tp-&gt;rcv_numsacks +
			    (TCP_SEND_DSACK_OPT(tp) ? 1 : 0)));
			sackoptlen = (2 + nsack * TCPOLEN_SACK);

			<span class="enscript-comment">/*
			 * First we need to pad options so that the
			 * SACK blocks can start at a 4-byte boundary
			 * (sack option and length are at a 2 byte offset).
			 */</span>
			padlen = (MAX_TCPOPTLEN - optlen - sackoptlen) % 4;
			optlen += padlen;
			<span class="enscript-keyword">while</span> (padlen-- &gt; 0)
				*bp++ = TCPOPT_NOP;

			tcpstat.tcps_sack_send_blocks++;
			*bp++ = TCPOPT_SACK;
			*bp++ = sackoptlen;
			lp = (u_int32_t *)(<span class="enscript-type">void</span> *)bp;

			<span class="enscript-comment">/*
			 * First block of SACK option should represent
			 * DSACK. Prefer to send SACK information if there
			 * is space for only one SACK block. This will
			 * allow for faster recovery.
			 */</span>
			<span class="enscript-keyword">if</span> (TCP_SEND_DSACK_OPT(tp) &amp;&amp; nsack &gt; 0 &amp;&amp;
			    (tp-&gt;rcv_numsacks == 0 || nsack &gt; 1)) {
				*lp++ = htonl(tp-&gt;t_dsack_lseq);
				*lp++ = htonl(tp-&gt;t_dsack_rseq);
				tcpstat.tcps_dsack_sent++;
				nsack--;
			}
			VERIFY(nsack == 0 || tp-&gt;rcv_numsacks &gt;= nsack);
			<span class="enscript-keyword">for</span> (i = 0; i &lt; nsack; i++) {
				<span class="enscript-type">struct</span> sackblk sack = tp-&gt;sackblks[i];
				*lp++ = htonl(sack.start);
				*lp++ = htonl(sack.end);
			}
			optlen += sackoptlen;
		}
	}

	<span class="enscript-comment">/* Pad TCP options to a 4 byte boundary */</span>
	<span class="enscript-keyword">if</span> (optlen &lt; MAX_TCPOPTLEN &amp;&amp; (optlen % <span class="enscript-keyword">sizeof</span>(u_int32_t))) {
		<span class="enscript-type">int</span> pad = <span class="enscript-keyword">sizeof</span>(u_int32_t) - (optlen % <span class="enscript-keyword">sizeof</span>(u_int32_t));
		u_char *bp = (u_char *)opt + optlen;

		optlen += pad;
		<span class="enscript-keyword">while</span> (pad) {
			*bp++ = TCPOPT_EOL;
			pad--;
		}
	}

	<span class="enscript-comment">/*
	 * RFC 3168 states that:
	 * - If you ever sent an ECN-setup SYN/SYN-ACK you must be prepared
	 * to handle the TCP ECE flag, even if you also later send a
	 * non-ECN-setup SYN/SYN-ACK.
	 * - If you ever send a non-ECN-setup SYN/SYN-ACK, you must not set
	 * the ip ECT flag.
	 *
	 * It is not clear how the ECE flag would ever be set if you never
	 * set the IP ECT flag on outbound packets. All the same, we use
	 * the TE_SETUPSENT to indicate that we have committed to handling
	 * the TCP ECE flag correctly. We use the TE_SENDIPECT to indicate
	 * whether or not we should set the IP ECT flag on outbound packet
	 *
	 * For a SYN-ACK, send an ECN setup SYN-ACK
	 */</span>
	<span class="enscript-keyword">if</span> ((tcp_ecn_inbound || (tp-&gt;t_flags &amp; TF_ENABLE_ECN))
	    &amp;&amp; (flags &amp; (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) {
		<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_SETUPRECEIVED) {
			<span class="enscript-keyword">if</span> (tcp_send_ecn_flags_on_syn(tp, so)) {
				<span class="enscript-comment">/*
				 * Setting TH_ECE makes this an ECN-setup
				 * SYN-ACK
				 */</span>
				flags |= TH_ECE;

				<span class="enscript-comment">/*
				 * Record that we sent the ECN-setup and
				 * default to setting IP ECT.
				 */</span>
				tp-&gt;ecn_flags |= (TE_SETUPSENT|TE_SENDIPECT);
				tcpstat.tcps_ecn_server_setup++;
				tcpstat.tcps_ecn_server_success++;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * We sent an ECN-setup SYN-ACK but it was
				 * dropped. Fallback to non-ECN-setup
				 * SYN-ACK and clear flag to indicate that
				 * we should not send data with IP ECT set
				 *
				 * Pretend we didn't receive an
				 * ECN-setup SYN.
				 *
				 * We already incremented the counter
				 * assuming that the ECN setup will
				 * succeed. Decrementing here
				 * tcps_ecn_server_success to correct it.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_SETUPSENT) {
					tcpstat.tcps_ecn_lost_synack++;
					tcpstat.tcps_ecn_server_success--;
				}

				tp-&gt;ecn_flags &amp;=
				    ~(TE_SETUPRECEIVED | TE_SENDIPECT |
				    TE_SENDCWR);
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((tcp_ecn_outbound || (tp-&gt;t_flags &amp; TF_ENABLE_ECN))
	    &amp;&amp; (flags &amp; (TH_SYN | TH_ACK)) == TH_SYN) {
		<span class="enscript-keyword">if</span> (tcp_send_ecn_flags_on_syn(tp, so)) {
			<span class="enscript-comment">/*
			 * Setting TH_ECE and TH_CWR makes this an
			 * ECN-setup SYN
			 */</span>
			flags |= (TH_ECE | TH_CWR);
			tcpstat.tcps_ecn_client_setup++;

			<span class="enscript-comment">/*
			 * Record that we sent the ECN-setup and default to
			 * setting IP ECT.
			 */</span>
			tp-&gt;ecn_flags |= (TE_SETUPSENT | TE_SENDIPECT);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We sent an ECN-setup SYN but it was dropped.
			 * Fall back to non-ECN and clear flag indicating
			 * we should send data with IP ECT set.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_SETUPSENT)
				tcpstat.tcps_ecn_lost_syn++;
			tp-&gt;ecn_flags &amp;= ~TE_SENDIPECT;
		}
	}

	<span class="enscript-comment">/*
	 * Check if we should set the TCP CWR flag.
	 * CWR flag is sent when we reduced the congestion window because
	 * we received a TCP ECE or we performed a fast retransmit. We
	 * never set the CWR flag on retransmitted packets. We only set
	 * the CWR flag on data packets. Pure acks don't have this set.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;ecn_flags &amp; TE_SENDCWR) != 0 &amp;&amp; len != 0 &amp;&amp;
	    !SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max) &amp;&amp; !sack_rxmit) {
		flags |= TH_CWR;
		tp-&gt;ecn_flags &amp;= ~TE_SENDCWR;
	}

	<span class="enscript-comment">/*
	 * Check if we should set the TCP ECE flag.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;ecn_flags &amp; TE_SENDECE) != 0 &amp;&amp; len == 0) {
		flags |= TH_ECE;
		tcpstat.tcps_ecn_sent_ece++;
	}


	hdrlen += optlen;

	<span class="enscript-comment">/* Reset DSACK sequence numbers */</span>
	tp-&gt;t_dsack_lseq = 0;
	tp-&gt;t_dsack_rseq = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		ipoptlen = ip6_optlen(inp);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		<span class="enscript-keyword">if</span> (tp_inp_options) {
			ipoptlen = tp_inp_options-&gt;m_len -
				offsetof(<span class="enscript-type">struct</span> ipoption, ipopt_list);
		} <span class="enscript-keyword">else</span> {
			ipoptlen = 0;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		ipoptlen += ipsec_optlen;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Adjust data length if insertion of options will
	 * bump the packet length beyond the t_maxopd length.
	 * Clear the FIN bit because we cut off the tail of
	 * the segment.
	 *
	 * When doing TSO limit a burst to TCP_MAXWIN minus the
	 * IP, TCP and Options length to keep ip-&gt;ip_len from
	 * overflowing.  Prevent the last segment from being
	 * fractional thus making them all equal sized and set
	 * the flag to continue sending.  TSO is disabled when
	 * IP options or IPSEC are present.
	 */</span>
	<span class="enscript-keyword">if</span> (len + optlen + ipoptlen &gt; tp-&gt;t_maxopd) {
		<span class="enscript-comment">/*
		 * If there is still more to send,
		 * don't close the connection.
		 */</span>
		flags &amp;= ~TH_FIN;
		<span class="enscript-keyword">if</span> (tso) {
			int32_t tso_maxlen;

			tso_maxlen = tp-&gt;tso_max_segment_size ?
				tp-&gt;tso_max_segment_size : TCP_MAXWIN;

			<span class="enscript-keyword">if</span> (len &gt; tso_maxlen - hdrlen - optlen) {
				len = tso_maxlen - hdrlen - optlen;
				len = len - (len % (tp-&gt;t_maxopd - optlen));
				sendalot = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDFIN) {
				sendalot = 1;
			}
		} <span class="enscript-keyword">else</span> {
			len = tp-&gt;t_maxopd - optlen - ipoptlen;
			sendalot = 1;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* Adjust the length in the DSS option, if it is lesser than len */</span>
	<span class="enscript-keyword">if</span> (dlenp) {
		<span class="enscript-comment">/*
		 * To test this path without SACK, artificially
		 * decrement len with something like
		 * if (len &gt; 10)
			len -= 10;
		 */</span>
		<span class="enscript-keyword">if</span> (ntohs(*dlenp) &gt; len) {
			*dlenp = htons(len);
			<span class="enscript-comment">/* Unset the FIN flag, if len was adjusted */</span>
			<span class="enscript-keyword">if</span> (finp) {
				*finp &amp;= ~MDSS_F;
			}
			sendalot = 1;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

 	<span class="enscript-keyword">if</span> (max_linkhdr + hdrlen &gt; MCLBYTES)
		panic(<span class="enscript-string">&quot;tcphdr too big&quot;</span>);

	<span class="enscript-comment">/* Check if there is enough data in the send socket
	 * buffer to start measuring bw 
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) != 0 &amp;&amp;
		(tp-&gt;t_bwmeas != NULL) &amp;&amp;
		(tp-&gt;t_flagsext &amp; TF_BWMEAS_INPROGRESS) == 0 &amp;&amp;
		(so-&gt;so_snd.sb_cc - (tp-&gt;snd_max - tp-&gt;snd_una)) &gt;= 
			tp-&gt;t_bwmeas-&gt;bw_minsize) {
		tp-&gt;t_bwmeas-&gt;bw_size = min(
			(so-&gt;so_snd.sb_cc - (tp-&gt;snd_max - tp-&gt;snd_una)),
			tp-&gt;t_bwmeas-&gt;bw_maxsize);
		tp-&gt;t_flagsext |= TF_BWMEAS_INPROGRESS;
		tp-&gt;t_bwmeas-&gt;bw_start = tp-&gt;snd_max;
		tp-&gt;t_bwmeas-&gt;bw_ts = tcp_now;
	}

	VERIFY(inp-&gt;inp_flowhash != 0);
	<span class="enscript-comment">/*
	 * Grab a header mbuf, attaching a copy of data to
	 * be transmitted, and initialize the header from
	 * the template for sends on this connection.
	 */</span>
	<span class="enscript-keyword">if</span> (len) {
		tp-&gt;t_pmtud_lastseg_size = len + optlen + ipoptlen;
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_FORCE) &amp;&amp; len == 1)
			tcpstat.tcps_sndprobe++;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max) || sack_rxmit) {
			tcpstat.tcps_sndrexmitpack++;
			tcpstat.tcps_sndrexmitbyte += len;
			<span class="enscript-keyword">if</span> (nstat_collect) {
				nstat_route_tx(inp-&gt;inp_route.ro_rt, 1,
					len, NSTAT_TX_FLAG_RETRANSMIT);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txpackets, 1);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txbytes, len);
				tp-&gt;t_stat.txretransmitbytes += len;
			}
		} <span class="enscript-keyword">else</span> {
			tcpstat.tcps_sndpack++;
			tcpstat.tcps_sndbyte += len;
			
			<span class="enscript-keyword">if</span> (nstat_collect) {
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txpackets, 1);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    txbytes, len);
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) {
			tcpstat.tcps_mp_sndpacks++;
			tcpstat.tcps_mp_sndbytes += len;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
		<span class="enscript-comment">/*
		 * try to use the new interface that allocates all 
		 * the necessary mbuf hdrs under 1 mbuf lock and 
		 * avoids rescanning the socket mbuf list if 
		 * certain conditions are met.  This routine can't
		 * be used in the following cases...
		 * 1) the protocol headers exceed the capacity of
		 * of a single mbuf header's data area (no cluster attached)
		 * 2) the length of the data being transmitted plus
		 * the protocol headers fits into a single mbuf header's
		 * data area (no cluster attached)
		 */</span>
		m = NULL;

		<span class="enscript-comment">/* minimum length we are going to allocate */</span>
		allocated_len = MHLEN;
 		<span class="enscript-keyword">if</span> (MHLEN &lt; hdrlen + max_linkhdr) {
			MGETHDR(m, M_DONTWAIT, MT_HEADER);
			<span class="enscript-keyword">if</span> (m == NULL) {
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
 			MCLGET(m, M_DONTWAIT);
 			<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
 				m_freem(m);
 				error = ENOBUFS;
 				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
 			}
			m-&gt;m_data += max_linkhdr;
			m-&gt;m_len = hdrlen;
			allocated_len = MCLBYTES;
		}
		<span class="enscript-keyword">if</span> (len &lt;= allocated_len - hdrlen - max_linkhdr) {
		        <span class="enscript-keyword">if</span> (m == NULL) {
				VERIFY(allocated_len &lt;= MHLEN);
				MGETHDR(m, M_DONTWAIT, MT_HEADER);
				<span class="enscript-keyword">if</span> (m == NULL) {
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				m-&gt;m_data += max_linkhdr;
				m-&gt;m_len = hdrlen;
			}
			<span class="enscript-comment">/* makes sure we still have data left to be sent at this point */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_mb == NULL || off &lt; 0) {
				<span class="enscript-keyword">if</span> (m != NULL) 	m_freem(m);
				error = 0; <span class="enscript-comment">/* should we return an error? */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			m_copydata(so-&gt;so_snd.sb_mb, off, (<span class="enscript-type">int</span>) len,
			    mtod(m, caddr_t) + hdrlen);
			m-&gt;m_len += len;
		} <span class="enscript-keyword">else</span> {
			uint32_t copymode;
			<span class="enscript-comment">/*
			 * Retain packet header metadata at the socket
			 * buffer if this is is an MPTCP subflow,
			 * otherwise move it.
			 */</span>
			copymode = M_COPYM_MOVE_HDR;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW) {
				copymode = M_COPYM_NOOP_HDR;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
			<span class="enscript-keyword">if</span> (m != NULL) {
				m-&gt;m_next = m_copym_mode(so-&gt;so_snd.sb_mb,
				    off, (<span class="enscript-type">int</span>)len, M_DONTWAIT, copymode);
				<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
					(<span class="enscript-type">void</span>) m_free(m);
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * make sure we still have data left
				 * to be sent at this point
				 */</span>
				<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_mb == NULL) {
					error = 0; <span class="enscript-comment">/* should we return an error? */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				
				<span class="enscript-comment">/*
				 * m_copym_with_hdrs will always return the
				 * last mbuf pointer and the offset into it that
				 * it acted on to fullfill the current request,
				 * whether a valid 'hint' was passed in or not.
				 */</span>
			        <span class="enscript-keyword">if</span> ((m = m_copym_with_hdrs(so-&gt;so_snd.sb_mb,
				    off, len, M_DONTWAIT, NULL, NULL,
				    copymode)) == NULL) {
				        error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				m-&gt;m_data += max_linkhdr;
				m-&gt;m_len = hdrlen;
			}
		}
		<span class="enscript-comment">/*
		 * If we're sending everything we've got, set PUSH.
		 * (This will keep happy those implementations which only
		 * give data to the user when a buffer fills or
		 * a PUSH comes in.)
		 *
		 * On SYN-segments we should not add the PUSH-flag.
		 */</span>
		<span class="enscript-keyword">if</span> (off + len == so-&gt;so_snd.sb_cc &amp;&amp; !(flags &amp; TH_SYN))
			flags |= TH_PUSH;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_ACKNOW)
			tcpstat.tcps_sndacks++;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; (TH_SYN|TH_FIN|TH_RST))
			tcpstat.tcps_sndctrl++;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_up, tp-&gt;snd_una))
			tcpstat.tcps_sndurg++;
		<span class="enscript-keyword">else</span>
			tcpstat.tcps_sndwinup++;

		MGETHDR(m, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (m == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (MHLEN &lt; (hdrlen + max_linkhdr)) {
 			MCLGET(m, M_DONTWAIT);
 			<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
 				m_freem(m);
 				error = ENOBUFS;
 				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
 			}
		}
		m-&gt;m_data += max_linkhdr;
		m-&gt;m_len = hdrlen;
	}
	m-&gt;m_pkthdr.rcvif = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* Before opt is copied to the mbuf, set the csum field */</span>
	mptcp_output_csum(tp, m, len, hdrlen, dss_val, sseqp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_mbuf_label_associate_inpcb(inp, m);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip6 + 1);
		tcp_fillheaders(tp, ip6, th);
		<span class="enscript-keyword">if</span> ((tp-&gt;ecn_flags &amp; TE_SENDIPECT) != 0 &amp;&amp; len &amp;&amp;
			!SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max) &amp;&amp; !sack_rxmit) {
			ip6-&gt;ip6_flow |= htonl(IPTOS_ECN_ECT0 &lt;&lt; 20);
		}
		svc_flags |= PKT_SCF_IPV6;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
		m-&gt;m_pkthdr.pf_mtag.pftag_hdr = (<span class="enscript-type">void</span> *)ip6;
		m-&gt;m_pkthdr.pf_mtag.pftag_flags |= PF_TAG_HDR_INET6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		ipov = (<span class="enscript-type">struct</span> ipovly *)ip;
		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip + 1);
		<span class="enscript-comment">/* this picks up the pseudo header (w/o the length) */</span>
		tcp_fillheaders(tp, ip, th);
		<span class="enscript-keyword">if</span> ((tp-&gt;ecn_flags &amp; TE_SENDIPECT) != 0 &amp;&amp; len &amp;&amp;
		    !SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max) &amp;&amp;
		    !sack_rxmit &amp;&amp; !(flags &amp; TH_SYN)) {
			ip-&gt;ip_tos |= IPTOS_ECN_ECT0;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
		m-&gt;m_pkthdr.pf_mtag.pftag_hdr = (<span class="enscript-type">void</span> *)ip;
		m-&gt;m_pkthdr.pf_mtag.pftag_flags |= PF_TAG_HDR_INET;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
	}

	<span class="enscript-comment">/*
	 * Fill in fields, remembering maximum advertised
	 * window for use in delaying messages about window sizes.
	 * If resending a FIN, be sure not to use a new sequence number.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; TH_FIN) &amp;&amp; (tp-&gt;t_flags &amp; TF_SENTFIN) &amp;&amp;
	    tp-&gt;snd_nxt == tp-&gt;snd_max)
		tp-&gt;snd_nxt--;
	<span class="enscript-comment">/*
	 * If we are doing retransmissions, then snd_nxt will
	 * not reflect the first unsent octet.  For ACK only
	 * packets, we do not want the sequence number of the
	 * retransmitted packet, we want the sequence number
	 * of the next unsent octet.  So, if there is no data
	 * (and no SYN or FIN), use snd_max instead of snd_nxt
	 * when filling in ti_seq.  But if we are in persist
	 * state, snd_max might reflect one byte beyond the
	 * right edge of the window, so use snd_nxt in that
	 * case, since we know we aren't doing a retransmission.
	 * (retransmit and persist are mutually exclusive...)
	 *
	 * Note the state of this retransmit segment to detect spurious
	 * retransmissions.
	 */</span>
	<span class="enscript-keyword">if</span> (sack_rxmit == 0) {
		<span class="enscript-keyword">if</span> (len || (flags &amp; (TH_SYN|TH_FIN)) ||
		    tp-&gt;t_timer[TCPT_PERSIST]) {
			th-&gt;th_seq = htonl(tp-&gt;snd_nxt);
			<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_max)) {
				<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; len &gt; 1) {
					tcp_rxtseg_insert(tp, tp-&gt;snd_nxt,
					    (tp-&gt;snd_nxt + len - 1));
				}
				m-&gt;m_pkthdr.pkt_flags |= PKTF_TCP_REXMT;
			}
		} <span class="enscript-keyword">else</span> {
			th-&gt;th_seq = htonl(tp-&gt;snd_max);
		}
	} <span class="enscript-keyword">else</span> {
		th-&gt;th_seq = htonl(p-&gt;rxmit);
		tcp_rxtseg_insert(tp, p-&gt;rxmit, (p-&gt;rxmit + len - 1));
		p-&gt;rxmit += len;
		tp-&gt;sackhint.sack_bytes_rexmit += len;
		m-&gt;m_pkthdr.pkt_flags |= PKTF_TCP_REXMT;
	}
	th-&gt;th_ack = htonl(tp-&gt;rcv_nxt);
	tp-&gt;last_ack_sent = tp-&gt;rcv_nxt;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* Initialize the ACK field to a value as 0 ack fields are dropped */</span>
	<span class="enscript-keyword">if</span> (early_data_sent) {
		th-&gt;th_ack = th-&gt;th_seq + 1;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	<span class="enscript-keyword">if</span> (optlen) {
		bcopy(opt, th + 1, optlen);
		th-&gt;th_off = (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) + optlen) &gt;&gt; 2;
	}
	th-&gt;th_flags = flags;
	<span class="enscript-comment">/*
	 * Calculate receive window.  Don't shrink window,
	 * but avoid silly window syndrome.
	 */</span>
	<span class="enscript-keyword">if</span> (recwin &lt; (int32_t)(so-&gt;so_rcv.sb_hiwat / 4) &amp;&amp; recwin &lt; (<span class="enscript-type">int</span>)tp-&gt;t_maxseg)
		recwin = 0;
	<span class="enscript-keyword">if</span> (recwin &lt; (int32_t)(tp-&gt;rcv_adv - tp-&gt;rcv_nxt))
		recwin = (int32_t)(tp-&gt;rcv_adv - tp-&gt;rcv_nxt);
	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_SLOWLINK &amp;&amp; slowlink_wsize &gt; 0) {
		<span class="enscript-keyword">if</span> (recwin &gt; (int32_t)slowlink_wsize) 
			recwin = slowlink_wsize;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
	<span class="enscript-keyword">if</span> (tcp_recv_bg == 1  || IS_TCP_RECV_BG(so)) {
		<span class="enscript-keyword">if</span> (tcp_recv_throttle(tp)) {
			uint32_t min_iaj_win = 
				tcp_min_iaj_win * tp-&gt;t_maxseg;
			<span class="enscript-keyword">if</span> (tp-&gt;iaj_rwintop == 0 ||
				SEQ_LT(tp-&gt;iaj_rwintop, tp-&gt;rcv_adv))
				tp-&gt;iaj_rwintop = tp-&gt;rcv_adv; 
			<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;iaj_rwintop, 
				tp-&gt;rcv_nxt + min_iaj_win))
				tp-&gt;iaj_rwintop =  tp-&gt;rcv_nxt + min_iaj_win;
			recwin = min(tp-&gt;iaj_rwintop - tp-&gt;rcv_nxt, recwin);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

	<span class="enscript-keyword">if</span> (recwin &gt; (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale))
		recwin = (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);
	th-&gt;th_win = htons((u_short) (recwin&gt;&gt;tp-&gt;rcv_scale));

	<span class="enscript-comment">/*
	 * Adjust the RXWIN0SENT flag - indicate that we have advertised
	 * a 0 window.  This may cause the remote transmitter to stall.  This
	 * flag tells soreceive() to disable delayed acknowledgements when
	 * draining the buffer.  This can occur if the receiver is attempting
	 * to read more data then can be buffered prior to transmitting on
	 * the connection.
	 */</span>
	<span class="enscript-keyword">if</span> (th-&gt;th_win == 0)
		tp-&gt;t_flags |= TF_RXWIN0SENT;
	<span class="enscript-keyword">else</span>
		tp-&gt;t_flags &amp;= ~TF_RXWIN0SENT;
	<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_up, tp-&gt;snd_nxt)) {
		th-&gt;th_urp = htons((u_short)(tp-&gt;snd_up - tp-&gt;snd_nxt));
		th-&gt;th_flags |= TH_URG;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If no urgent pointer to send, then we pull
		 * the urgent pointer to the left edge of the send window
		 * so that it doesn't drift into the send window on sequence
		 * number wraparound.
		 */</span>
		tp-&gt;snd_up = tp-&gt;snd_una;		<span class="enscript-comment">/* drag it along */</span>
	}

	<span class="enscript-comment">/*
	 * Put TCP length in extended header, and then
	 * checksum extended header and data.
	 */</span>
	m-&gt;m_pkthdr.len = hdrlen + len; <span class="enscript-comment">/* in6_cksum() need this */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-comment">/*
		 * ip6_plen is not need to be filled now, and will be filled
		 * in ip6_output.
		 */</span>
		m-&gt;m_pkthdr.csum_flags = CSUM_TCPIPV6;
		m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> tcphdr, th_sum);
		<span class="enscript-keyword">if</span> (len + optlen)
			th-&gt;th_sum = in_addword(th-&gt;th_sum, 
				htons((u_short)(optlen + len)));
	}
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		m-&gt;m_pkthdr.csum_flags = CSUM_TCP;
		m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> tcphdr, th_sum);
		<span class="enscript-keyword">if</span> (len + optlen)
			th-&gt;th_sum = in_addword(th-&gt;th_sum, 
				htons((u_short)(optlen + len)));
	}

	<span class="enscript-comment">/*
	 * Enable TSO and specify the size of the segments.
	 * The TCP pseudo header checksum is always provided.
	 */</span>
	<span class="enscript-keyword">if</span> (tso) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			m-&gt;m_pkthdr.csum_flags |= CSUM_TSO_IPV6;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			m-&gt;m_pkthdr.csum_flags |= CSUM_TSO_IPV4;

		m-&gt;m_pkthdr.tso_segsz = tp-&gt;t_maxopd - optlen;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.tso_segsz = 0;
	}

	<span class="enscript-comment">/*
	 * In transmit state, time the transmission and arrange for
	 * the retransmit.  In persist state, just set snd_max.
	 */</span>
	<span class="enscript-keyword">if</span> (!(tp-&gt;t_flagsext &amp; TF_FORCE)
	    || tp-&gt;t_timer[TCPT_PERSIST] == 0) {
		tcp_seq startseq = tp-&gt;snd_nxt;

		<span class="enscript-comment">/*
		 * Advance snd_nxt over sequence space of this segment.
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; (TH_SYN|TH_FIN)) {
			<span class="enscript-keyword">if</span> (flags &amp; TH_SYN)
				tp-&gt;snd_nxt++;
			<span class="enscript-keyword">if</span> ((flags &amp; TH_FIN) &amp;&amp; 
				!(tp-&gt;t_flags &amp; TF_SENTFIN)) {
				tp-&gt;snd_nxt++;
				tp-&gt;t_flags |= TF_SENTFIN;
			}
		}
		<span class="enscript-keyword">if</span> (sack_rxmit)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">timer</span>;
		<span class="enscript-keyword">if</span> (sack_rescue_rxt == TRUE) {
			tp-&gt;snd_nxt = old_snd_nxt;
			sack_rescue_rxt = FALSE;
			tcpstat.tcps_pto_in_recovery++;
		} <span class="enscript-keyword">else</span> {
			tp-&gt;snd_nxt += len;
		}
		<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_nxt, tp-&gt;snd_max)) {
			tp-&gt;snd_max = tp-&gt;snd_nxt;
			<span class="enscript-comment">/*
			 * Time this transmission if not a retransmission and
			 * not currently timing anything.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;t_rtttime == 0) {
				tp-&gt;t_rtttime = tcp_now;
				tp-&gt;t_rtseq = startseq;
				tcpstat.tcps_segstimed++;

				<span class="enscript-comment">/* update variables related to pipe ack */</span>
				tp-&gt;t_pipeack_lastuna = tp-&gt;snd_una;
			}
		}

		<span class="enscript-comment">/*
		 * Set retransmit timer if not currently set,
		 * and not doing an ack or a keep-alive probe.
		 */</span>
<span class="enscript-reference">timer</span>:
		<span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_REXMT] == 0 &amp;&amp;
		    ((sack_rxmit &amp;&amp; tp-&gt;snd_nxt != tp-&gt;snd_max) ||
			tp-&gt;snd_nxt != tp-&gt;snd_una || (flags &amp; TH_FIN))) {
			<span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_PERSIST]) {
				tp-&gt;t_timer[TCPT_PERSIST] = 0;
				tp-&gt;t_rxtshift = 0;
				tp-&gt;t_rxtstart = 0;
				tp-&gt;t_persist_stop = 0;
			}
			tp-&gt;t_timer[TCPT_REXMT] =
				OFFSET_FROM_START(tp, tp-&gt;t_rxtcur);
		}

		<span class="enscript-comment">/*
		 * Set tail loss probe timeout if new data is being
		 * transmitted. This will be supported only when
		 * SACK option is enabled on a connection.
		 *
		 * Every time new data is sent PTO will get reset.
		 */</span>
		<span class="enscript-keyword">if</span> (tcp_enable_tlp &amp;&amp; tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
		    SACK_ENABLED(tp) &amp;&amp; !IN_FASTRECOVERY(tp)
		    &amp;&amp; tp-&gt;snd_nxt == tp-&gt;snd_max
		    &amp;&amp; SEQ_GT(tp-&gt;snd_nxt, tp-&gt;snd_una)
		    &amp;&amp; tp-&gt;t_rxtshift == 0
		    &amp;&amp; (tp-&gt;t_flagsext &amp; (TF_SENT_TLPROBE|TF_PKTS_REORDERED)) == 0) {
			u_int32_t pto, srtt, new_rto = 0;

			<span class="enscript-comment">/*
			 * Using SRTT alone to set PTO can cause spurious
			 * retransmissions on wireless networks where there
			 * is a lot of variance in RTT. Taking variance 
			 * into account will avoid this.
			 */</span>
			srtt = tp-&gt;t_srtt &gt;&gt; TCP_RTT_SHIFT;
			pto = ((TCP_REXMTVAL(tp)) * 3) &gt;&gt; 1;
			pto = max (2 * srtt, pto);
			<span class="enscript-keyword">if</span> ((tp-&gt;snd_max - tp-&gt;snd_una) == tp-&gt;t_maxseg)
				pto = max(pto,
				    (((3 * pto) &gt;&gt; 2) + tcp_delack * 2));
			<span class="enscript-keyword">else</span>
				pto = max(10, pto);

			<span class="enscript-comment">/* if RTO is less than PTO, choose RTO instead */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;t_rxtcur &lt; pto) {
				<span class="enscript-comment">/*
				 * Schedule PTO instead of RTO in favor of
				 * fast recovery.
				 */</span>
				pto = tp-&gt;t_rxtcur;

 				<span class="enscript-comment">/* Reset the next RTO to be after PTO. */</span>
				TCPT_RANGESET(new_rto,
				    (pto + TCP_REXMTVAL(tp)),
				    max(tp-&gt;t_rttmin, tp-&gt;t_rttcur + 2),
				    TCPTV_REXMTMAX, 0);
				tp-&gt;t_timer[TCPT_REXMT] =
				    OFFSET_FROM_START(tp, new_rto);
			}
			tp-&gt;t_timer[TCPT_PTO] = OFFSET_FROM_START(tp, pto);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Persist case, update snd_max but since we are in
		 * persist mode (no window) we do not update snd_nxt.
		 */</span>
		<span class="enscript-type">int</span> xlen = len;
		<span class="enscript-keyword">if</span> (flags &amp; TH_SYN)
			++xlen;
		<span class="enscript-keyword">if</span> ((flags &amp; TH_FIN) &amp;&amp; 
			!(tp-&gt;t_flags &amp; TF_SENTFIN)) {
			++xlen;
			tp-&gt;t_flags |= TF_SENTFIN;
		}
		<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_nxt + xlen, tp-&gt;snd_max))
			tp-&gt;snd_max = tp-&gt;snd_nxt + len;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-comment">/*
	 * Trace.
	 */</span>
	<span class="enscript-keyword">if</span> (so_options &amp; SO_DEBUG)
		tcp_trace(TA_OUTPUT, tp-&gt;t_state, tp, mtod(m, <span class="enscript-type">void</span> *), th, 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Fill in IP length and desired time to live and
	 * send to IP level.  There should be a better way
	 * to handle ttl and tos; we could keep them in
	 * the template, but need a way to checksum without them.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-comment">/*
	 * m-&gt;m_pkthdr.len should have been set before cksum calcuration,
	 * because in6_cksum() need it.
	 */</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-comment">/*
		 * we separately set hoplimit for every segment, since the
		 * user might want to change the value via setsockopt.
		 * Also, desired default hop limit might be changed via
		 * Neighbor Discovery.
		 */</span>
		ip6-&gt;ip6_hlim = in6_selecthlim(inp, inp-&gt;in6p_route.ro_rt ?
		    inp-&gt;in6p_route.ro_rt-&gt;rt_ifp : NULL);

		<span class="enscript-comment">/* TODO: IPv6 IP6TOS_ECT bit on */</span>
		KERNEL_DEBUG(DBG_LAYER_BEG,
		    ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
		    (((inp-&gt;in6p_laddr.s6_addr16[0] &amp; 0xffff) &lt;&lt; 16) |
		    (inp-&gt;in6p_faddr.s6_addr16[0] &amp; 0xffff)),
		    sendalot,0,0);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		ip-&gt;ip_len = m-&gt;m_pkthdr.len;
		ip-&gt;ip_ttl = inp-&gt;inp_ip_ttl;	<span class="enscript-comment">/* XXX */</span>
		ip-&gt;ip_tos |= (inp-&gt;inp_ip_tos &amp; ~IPTOS_ECN_MASK);<span class="enscript-comment">/* XXX */</span>
 		KERNEL_DEBUG(DBG_LAYER_BEG,
 		    ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
 		    (((inp-&gt;inp_laddr.s_addr &amp; 0xffff) &lt;&lt; 16) |
 		    (inp-&gt;inp_faddr.s_addr &amp; 0xffff)), 0,0,0);
 	}

	<span class="enscript-comment">/*
	 * See if we should do MTU discovery.
	 * Look at the flag updated on the following criterias:
	 *	1) Path MTU discovery is authorized by the sysctl
	 *	2) The route isn't set yet (unlikely but could happen)
	 *	3) The route is up
	 *	4) the MTU is not locked (if it is, then discovery has been
	 *	   disabled for that route)
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (!isipv6)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (path_mtu_discovery &amp;&amp; (tp-&gt;t_flags &amp; TF_PMTUD))
			ip-&gt;ip_off |= IP_DF;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	{
		necp_kernel_policy_id policy_id;
		u_int32_t route_rule_id;
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv(inp, &amp;policy_id, &amp;route_rule_id)) {
			m_freem(m);
			error = EHOSTUNREACH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		necp_mark_packet_from_socket(m, inp, policy_id, route_rule_id);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp != NULL)
		ipsec_setsocket(m, so);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

	<span class="enscript-comment">/*
	 * The socket is kept locked while sending out packets in ip_output, even if packet chaining is not active.
	 */</span>
	lost = 0;

	<span class="enscript-comment">/*
	 * Embed the flow hash in pkt hdr and mark the packet as
	 * capable of flow controlling
	 */</span>
	m-&gt;m_pkthdr.pkt_flowsrc = FLOWSRC_INPCB;
	m-&gt;m_pkthdr.pkt_flowid = inp-&gt;inp_flowhash;
	m-&gt;m_pkthdr.pkt_flags |= PKTF_FLOW_ID | PKTF_FLOW_LOCALSRC;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* Disable flow advisory when using MPTCP. */</span>
	<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
		m-&gt;m_pkthdr.pkt_flags |= PKTF_FLOW_ADV;
	m-&gt;m_pkthdr.pkt_proto = IPPROTO_TCP;

	m-&gt;m_nextpkt = NULL;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_last_outifp != NULL &amp;&amp;
	    !(inp-&gt;inp_last_outifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
		<span class="enscript-comment">/* Hint to prioritize this packet if
		 * 1. if the packet has no data
		 * 2. the interface supports transmit-start model and did 
		 *    not disable ACK prioritization.
		 * 3. Only ACK flag is set.
		 * 4. there is no outstanding data on this connection.
		 */</span>
		<span class="enscript-keyword">if</span> (tcp_prioritize_acks != 0 &amp;&amp; len == 0 &amp;&amp;
		    (inp-&gt;inp_last_outifp-&gt;if_eflags &amp; 
			(IFEF_TXSTART | IFEF_NOACKPRI)) == IFEF_TXSTART &amp;&amp;
		    th-&gt;th_flags == TH_ACK &amp;&amp; tp-&gt;snd_una == tp-&gt;snd_max &amp;&amp;
		    tp-&gt;t_timer[TCPT_REXMT] == 0) {
			svc_flags |= PKT_SCF_TCP_ACK;
		}
		set_packet_service_class(m, so, MBUF_SC_UNSPEC, svc_flags);
	}

	tp-&gt;t_pktlist_sentlen += len;
	tp-&gt;t_lastchain++;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		DTRACE_TCP5(send, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, inp,
			<span class="enscript-type">struct</span> ip6 *, ip6, <span class="enscript-type">struct</span> tcpcb *, tp, <span class="enscript-type">struct</span> tcphdr *,
			th);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		DTRACE_TCP5(send, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, inp,
			<span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> tcpcb *, tp, <span class="enscript-type">struct</span> tcphdr *, th);
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_pktlist_head != NULL) {
		tp-&gt;t_pktlist_tail-&gt;m_nextpkt = m;
		tp-&gt;t_pktlist_tail = m;
	} <span class="enscript-keyword">else</span> {
		packchain_newlist++;
		tp-&gt;t_pktlist_head = tp-&gt;t_pktlist_tail = m;
	}

	<span class="enscript-keyword">if</span> ((lro_ackmore) &amp;&amp; (!sackoptlen) &amp;&amp; (!tp-&gt;t_timer[TCPT_PERSIST]) &amp;&amp;
			((th-&gt;th_flags &amp; TH_ACK) == TH_ACK) &amp;&amp; (!len) &amp;&amp;
			(tp-&gt;t_state == TCPS_ESTABLISHED)) {
		<span class="enscript-comment">/* For a pure ACK, see if you need to send more of them */</span>	
		mnext = tcp_send_lroacks(tp, m, th);
		<span class="enscript-keyword">if</span> (mnext) {
			tp-&gt;t_pktlist_tail-&gt;m_nextpkt = mnext;
			<span class="enscript-keyword">if</span> (mnext-&gt;m_nextpkt == NULL) {
				tp-&gt;t_pktlist_tail = mnext;
				tp-&gt;t_lastchain++;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> mbuf *tail, *next;
				next = mnext-&gt;m_nextpkt;
				tail = next-&gt;m_nextpkt;
				<span class="enscript-keyword">while</span> (tail) {
					next = tail;
					tail = tail-&gt;m_nextpkt;
					tp-&gt;t_lastchain++;
				}
				tp-&gt;t_pktlist_tail = next;
			}
		}
	}

	<span class="enscript-keyword">if</span> (sendalot == 0 || (tp-&gt;t_state != TCPS_ESTABLISHED) ||
	    (tp-&gt;snd_cwnd &lt;= (tp-&gt;snd_wnd / 8)) ||
	    (tp-&gt;t_flags &amp; (TH_PUSH | TF_ACKNOW)) ||
	    (tp-&gt;t_flagsext &amp; TF_FORCE) ||
	    tp-&gt;t_lastchain &gt;= tcp_packet_chaining) {
		error = 0;
		<span class="enscript-keyword">while</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
			tp-&gt;t_pktlist_head != NULL) {
			packetlist = tp-&gt;t_pktlist_head;
			packchain_listadd = tp-&gt;t_lastchain;
			packchain_sent++;
			lost = tp-&gt;t_pktlist_sentlen;
			TCP_PKTLIST_CLEAR(tp);

			error = tcp_ip_output(so, tp, packetlist,
			    packchain_listadd, tp_inp_options,
			    (so_options &amp; SO_DONTROUTE),
			    (sack_rxmit | (sack_bytes_rxmt != 0)), recwin,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			    isipv6);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
			    0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/*
				 * Take into account the rest of unsent
				 * packets in the packet list for this tcp
				 * into &quot;lost&quot;, since we're about to free
				 * the whole list below.
				 */</span>
				lost += tp-&gt;t_pktlist_sentlen;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				lost = 0;
			}
		}
		<span class="enscript-comment">/* tcp was closed while we were in ip; resume close */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_sndinprog_cnt == 0 &amp;&amp;
			(tp-&gt;t_flags &amp; TF_CLOSING)) {
			tp-&gt;t_flags &amp;= ~TF_CLOSING;
			(<span class="enscript-type">void</span>) tcp_close(tp);
			<span class="enscript-keyword">return</span> (0);
		}
	} <span class="enscript-keyword">else</span> {
		error = 0;
		packchain_looped++;
		tcpstat.tcps_sndtotal++;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/*
		 * Assume that the packets were lost, so back out the
		 * sequence number advance, if any.  Note that the &quot;lost&quot;
		 * variable represents the amount of user data sent during
		 * the recent call to ip_output_list() plus the amount of
		 * user data in the packet list for this tcp at the moment.
		 */</span>
		<span class="enscript-keyword">if</span> (!(tp-&gt;t_flagsext &amp; TF_FORCE)
		    || tp-&gt;t_timer[TCPT_PERSIST] == 0) {
			<span class="enscript-comment">/*
			 * No need to check for TH_FIN here because
			 * the TF_SENTFIN flag handles that case.
			 */</span>
			<span class="enscript-keyword">if</span> ((flags &amp; TH_SYN) == 0) {
				<span class="enscript-keyword">if</span> (sack_rxmit) {
					<span class="enscript-keyword">if</span> (SEQ_GT((p-&gt;rxmit - lost),
					    tp-&gt;snd_una)) {
						p-&gt;rxmit -= lost;
					} <span class="enscript-keyword">else</span> {
						lost = p-&gt;rxmit - tp-&gt;snd_una;
						p-&gt;rxmit = tp-&gt;snd_una;
					}
					tp-&gt;sackhint.sack_bytes_rexmit -= lost;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (SEQ_GT((tp-&gt;snd_nxt - lost),
						tp-&gt;snd_una))
						tp-&gt;snd_nxt -= lost;
					<span class="enscript-keyword">else</span>
						tp-&gt;snd_nxt = tp-&gt;snd_una;
				}
			}
		}
<span class="enscript-reference">out</span>:
		<span class="enscript-keyword">if</span> (tp-&gt;t_pktlist_head != NULL)
			m_freem_list(tp-&gt;t_pktlist_head);
		TCP_PKTLIST_CLEAR(tp);

		<span class="enscript-keyword">if</span> (error == ENOBUFS) {
			<span class="enscript-keyword">if</span> (!tp-&gt;t_timer[TCPT_REXMT] &amp;&amp;
				!tp-&gt;t_timer[TCPT_PERSIST])
				tp-&gt;t_timer[TCPT_REXMT] = 
					OFFSET_FROM_START(tp, tp-&gt;t_rxtcur);
			tp-&gt;snd_cwnd = tp-&gt;t_maxseg;
			tp-&gt;t_bytes_acked = 0;
			tcp_check_timer_state(tp);
			KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END, 0,0,0,0,0);

			tcp_ccdbg_trace(tp, NULL, TCP_CC_OUTPUT_ERROR);
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">if</span> (error == EMSGSIZE) {
			<span class="enscript-comment">/*
			 * ip_output() will have already fixed the route
			 * for us.  tcp_mtudisc() will, as its last action,
			 * initiate retransmission, so it is important to
			 * not do so here.
			 *
			 * If TSO was active we either got an interface
			 * without TSO capabilits or TSO was turned off.
			 * Disable it for this connection as too and
			 * immediatly retry with MSS sized segments generated
			 * by this function.
			 */</span>
			<span class="enscript-keyword">if</span> (tso)
				tp-&gt;t_flags &amp;= ~TF_TSO;

			tcp_mtudisc(inp, 0);
			tcp_check_timer_state(tp);

			KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END, 0,0,0,0,0);
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-comment">/*
		 * Unless this is due to interface restriction policy,
		 * treat EHOSTUNREACH/ENETDOWN as a soft error.
		 */</span>
		<span class="enscript-keyword">if</span> ((error == EHOSTUNREACH || error == ENETDOWN) &amp;&amp;
		    TCPS_HAVERCVDSYN(tp-&gt;t_state) &amp;&amp; 
		    !inp_restricted_send(inp, inp-&gt;inp_last_outifp)) {
				tp-&gt;t_softerror = error;
				error = 0;
		}
		tcp_check_timer_state(tp);
		KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END, 0,0,0,0,0);
		<span class="enscript-keyword">return</span> (error);
	}

	tcpstat.tcps_sndtotal++;

	KERNEL_DEBUG(DBG_FNC_TCP_OUTPUT | DBG_FUNC_END,0,0,0,0,0);
	<span class="enscript-keyword">if</span> (sendalot)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

	tcp_check_timer_state(tp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_ip_output</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mbuf *pkt,
    <span class="enscript-type">int</span> cnt, <span class="enscript-type">struct</span> mbuf *opt, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> sack_in_progress, <span class="enscript-type">int</span> recwin,
    boolean_t isipv6)
{
	<span class="enscript-type">int</span> error = 0;
	boolean_t chain;
	boolean_t unlocked = FALSE;
	boolean_t ifdenied = FALSE;
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> ip_out_args ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF|IPOAF_BOUND_SRCADDR, 0 };
	<span class="enscript-type">struct</span> route ro;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_out_args ip6oa =
	    { IFSCOPE_NONE, { 0 }, IP6OAF_SELECT_SRCIF|IP6OAF_BOUND_SRCADDR, 0 };
	<span class="enscript-type">struct</span> route_in6 ro6;
	<span class="enscript-type">struct</span> flowadv *adv =
	    (isipv6 ? &amp;ip6oa.ip6oa_flowadv : &amp;ipoa.ipoa_flowadv);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> flowadv *adv = &amp;ipoa.ipoa_flowadv;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>

	<span class="enscript-comment">/* If socket was bound to an ifindex, tell ip_output about it */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_BOUND_IF) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			ip6oa.ip6oa_boundif = inp-&gt;inp_boundifp-&gt;if_index;
			ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			ipoa.ipoa_boundif = inp-&gt;inp_boundifp-&gt;if_index;
			ipoa.ipoa_flags |= IPOAF_BOUND_IF;
		}
	}

	<span class="enscript-keyword">if</span> (INP_NO_CELLULAR(inp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			ip6oa.ip6oa_flags |=  IP6OAF_NO_CELLULAR;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			ipoa.ipoa_flags |=  IPOAF_NO_CELLULAR;
	} 
	<span class="enscript-keyword">if</span> (INP_NO_EXPENSIVE(inp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			ip6oa.ip6oa_flags |=  IP6OAF_NO_EXPENSIVE;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			ipoa.ipoa_flags |=  IPOAF_NO_EXPENSIVE;
	
	}
	<span class="enscript-keyword">if</span> (INP_AWDL_UNRESTRICTED(inp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			ip6oa.ip6oa_flags |=  IP6OAF_AWDL_UNRESTRICTED;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			ipoa.ipoa_flags |=  IPOAF_AWDL_UNRESTRICTED;
	
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		flags |= IPV6_OUTARGS;
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		flags |= IP_OUTARGS;

	<span class="enscript-comment">/* Copy the cached route and take an extra reference */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		in6p_route_copyout(inp, &amp;ro6);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		inp_route_copyout(inp, &amp;ro);

	<span class="enscript-comment">/*
	 * Data sent (as far as we can tell).
	 * If this advertises a larger window than any other segment,
	 * then remember the size of the advertised window.
	 * Make sure ACK/DELACK conditions are cleared before
	 * we unlock the socket.
	 */</span>
	<span class="enscript-keyword">if</span> (recwin &gt; 0 &amp;&amp; SEQ_GT(tp-&gt;rcv_nxt + recwin, tp-&gt;rcv_adv))
		tp-&gt;rcv_adv = tp-&gt;rcv_nxt + recwin;
	tp-&gt;last_ack_sent = tp-&gt;rcv_nxt;
	tp-&gt;t_flags &amp;= ~(TF_ACKNOW | TF_DELACK);
	tp-&gt;t_timer[TCPT_DELACK] = 0;
	tp-&gt;t_unacksegs = 0;

	<span class="enscript-comment">/* Increment the count of outstanding send operations */</span>
	inp-&gt;inp_sndinprog_cnt++;

	<span class="enscript-comment">/*
	 * If allowed, unlock TCP socket while in IP
	 * but only if the connection is established and
	 * in a normal mode where reentrancy on the tcpcb won't be
	 * an issue:
	 * - there is no SACK episode
	 * - we're not in Fast Recovery mode
	 * - if we're not sending from an upcall.
	 */</span>
	<span class="enscript-keyword">if</span> (tcp_output_unlocked &amp;&amp; !so-&gt;so_upcallusecount &amp;&amp;
	    (tp-&gt;t_state == TCPS_ESTABLISHED) &amp;&amp; (sack_in_progress == 0) &amp;&amp;
	    !IN_FASTRECOVERY(tp)) {

		unlocked = TRUE;
		socket_unlock(so, 0);
	}
	
	<span class="enscript-comment">/*
	 * Don't send down a chain of packets when:
	 * - TCP chaining is disabled
	 * - there is an IPsec rule set
	 * - there is a non default rule set for the firewall
	 */</span>

	chain = tcp_packet_chaining &gt; 1
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		&amp;&amp; ipsec_bypass
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		&amp;&amp; (fw_enable == 0 || fw_bypass)
#<span class="enscript-reference">endif</span>
		; <span class="enscript-comment">// I'm important, not extraneous
</span>

	<span class="enscript-keyword">while</span> (pkt != NULL) {
		<span class="enscript-type">struct</span> mbuf *npkt = pkt-&gt;m_nextpkt;

		<span class="enscript-keyword">if</span> (!chain) {
			pkt-&gt;m_nextpkt = NULL;
			<span class="enscript-comment">/*
			 * If we are not chaining, make sure to set the packet
			 * list count to 0 so that IP takes the right path;
			 * this is important for cases such as IPSec where a
			 * single mbuf might result in multiple mbufs as part
			 * of the encapsulation.  If a non-zero count is passed
			 * down to IP, the head of the chain might change and
			 * we could end up skipping it (thus generating bogus
			 * packets).  Fixing it in IP would be desirable, but
			 * for now this would do it.
			 */</span>
			cnt = 0;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			error = ip6_output_list(pkt, cnt,
			    inp-&gt;in6p_outputopts, &amp;ro6, flags, NULL, NULL,
			    &amp;ip6oa);
			ifdenied = (ip6oa.ip6oa_retflags &amp; IP6OARF_IFDENIED);
		} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			error = ip_output_list(pkt, cnt, opt, &amp;ro, flags, NULL,
			    &amp;ipoa);
			ifdenied = (ipoa.ipoa_retflags &amp; IPOARF_IFDENIED);
		}

		<span class="enscript-keyword">if</span> (chain || error) {
			<span class="enscript-comment">/*
			 * If we sent down a chain then we are done since
			 * the callee had taken care of everything; else
			 * we need to free the rest of the chain ourselves.
			 */</span>
			<span class="enscript-keyword">if</span> (!chain)
				m_freem_list(npkt);
			<span class="enscript-keyword">break</span>;
		}
		pkt = npkt;
	}

	<span class="enscript-keyword">if</span> (unlocked)
		socket_lock(so, 0);

	<span class="enscript-comment">/* 
	 * Enter flow controlled state if the connection is established
	 * and is not in recovery.
	 *
	 * A connection will enter suspended state even if it is in 
	 * recovery.
	 */</span>
	<span class="enscript-keyword">if</span> (((adv-&gt;code == FADV_FLOW_CONTROLLED &amp;&amp; !IN_FASTRECOVERY(tp)) ||
	    adv-&gt;code == FADV_SUSPENDED) &amp;&amp; 
	    !(tp-&gt;t_flags &amp; TF_CLOSING) &amp;&amp;
	    tp-&gt;t_state == TCPS_ESTABLISHED) {
		<span class="enscript-type">int</span> rc;
		rc = inp_set_fc_state(inp, adv-&gt;code);

		<span class="enscript-keyword">if</span> (rc == 1) 
			tcp_ccdbg_trace(tp, NULL, 
			    ((adv-&gt;code == FADV_FLOW_CONTROLLED) ?
			    TCP_CC_FLOW_CONTROL : TCP_CC_SUSPEND));
	}

	<span class="enscript-comment">/* 
	 * When an interface queue gets suspended, some of the
	 * packets are dropped. Return ENOBUFS, to update the
	 * pcb state.
	 */</span>
	<span class="enscript-keyword">if</span> (adv-&gt;code == FADV_SUSPENDED)
		error = ENOBUFS;

	VERIFY(inp-&gt;inp_sndinprog_cnt &gt; 0);
	<span class="enscript-keyword">if</span> ( --inp-&gt;inp_sndinprog_cnt == 0)
		inp-&gt;inp_flags &amp;= ~(INP_FC_FEEDBACK);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-keyword">if</span> (ro6.ro_rt != NULL &amp;&amp; (outif = ro6.ro_rt-&gt;rt_ifp) !=
		    inp-&gt;in6p_last_outifp)
			inp-&gt;in6p_last_outifp = outif;
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (ro.ro_rt != NULL &amp;&amp; (outif = ro.ro_rt-&gt;rt_ifp) !=
		    inp-&gt;inp_last_outifp)
			inp-&gt;inp_last_outifp = outif;

	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; ifdenied &amp;&amp; 
	    (INP_NO_CELLULAR(inp) || INP_NO_EXPENSIVE(inp)))
		soevent(inp-&gt;inp_socket,
		    (SO_FILT_HINT_LOCKED|SO_FILT_HINT_IFDENIED));

	<span class="enscript-comment">/* Synchronize cached PCB route &amp; options */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		in6p_route_copyin(inp, &amp;ro6);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		inp_route_copyin(inp, &amp;ro);

	<span class="enscript-keyword">if</span> (tp-&gt;t_state &lt; TCPS_ESTABLISHED &amp;&amp; tp-&gt;t_rxtshift == 0 &amp;&amp; 
		tp-&gt;t_inpcb-&gt;inp_route.ro_rt != NULL) {
		<span class="enscript-comment">/* If we found the route and there is an rtt on it
		 * reset the retransmit timer
		 */</span>
		tcp_getrt_rtt(tp, tp-&gt;t_inpcb-&gt;in6p_route.ro_rt);
		tp-&gt;t_timer[TCPT_REXMT] = OFFSET_FROM_START(tp, tp-&gt;t_rxtcur);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_setpersist</span>(tp)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">int</span> t = ((tp-&gt;t_srtt &gt;&gt; 2) + tp-&gt;t_rttvar) &gt;&gt; 1;

	<span class="enscript-comment">/* If a PERSIST_TIMER option was set we will limit the
	 * time the persist timer will be active for that connection
	 * in order to avoid DOS by using zero window probes.
	 * see rdar://5805356
	 */</span>

	<span class="enscript-keyword">if</span> ((tp-&gt;t_persist_timeout != 0) &amp;&amp;
       	    (tp-&gt;t_timer[TCPT_PERSIST] == 0) &amp;&amp;
       	    (tp-&gt;t_persist_stop == 0)) {
		tp-&gt;t_persist_stop = tcp_now + tp-&gt;t_persist_timeout;
	}

	<span class="enscript-comment">/*
	 * Start/restart persistance timer.
	 */</span>
	TCPT_RANGESET(tp-&gt;t_timer[TCPT_PERSIST],
	    t * tcp_backoff[tp-&gt;t_rxtshift],
	    TCPTV_PERSMIN, TCPTV_PERSMAX, 0);
	tp-&gt;t_timer[TCPT_PERSIST] = OFFSET_FROM_START(tp, tp-&gt;t_timer[TCPT_PERSIST]);

	<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &lt; TCP_MAXRXTSHIFT)
		tp-&gt;t_rxtshift++;
}

<span class="enscript-comment">/*
 * Send as many acks as data coalesced. Every other packet when stretch
 * ACK is not enabled. Every 8 packets, if stretch ACK is enabled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf*
<span class="enscript-function-name">tcp_send_lroacks</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-type">struct</span> mbuf *mnext = NULL, *ack_chain = NULL, *tail = NULL;
	<span class="enscript-type">int</span> count = 0;
	tcp_seq org_ack = ntohl(th-&gt;th_ack);
	tcp_seq prev_ack = 0;
	<span class="enscript-type">int</span> tack_offset = 28; <span class="enscript-comment">/* XXX IPv6 and IP options not supported */</span>
	<span class="enscript-type">int</span> twin_offset = 34; <span class="enscript-comment">/* XXX IPv6 and IP options not supported */</span>
	<span class="enscript-type">int</span> ack_size = (tp-&gt;t_flags &amp; TF_STRETCHACK) ?
			(maxseg_unacked * tp-&gt;t_maxseg) : (tp-&gt;t_maxseg &lt;&lt; 1);
	<span class="enscript-type">int</span> segs_acked = (tp-&gt;t_flags &amp; TF_STRETCHACK) ? maxseg_unacked : 2;
	<span class="enscript-type">struct</span> mbuf *prev_ack_pkt = NULL;
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> winsz = ntohs(th-&gt;th_win);
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scaled_win = winsz&lt;&lt;tp-&gt;rcv_scale;
	tcp_seq win_rtedge = org_ack + scaled_win;

	count = tp-&gt;t_lropktlen/tp-&gt;t_maxseg;

	prev_ack = (org_ack - tp-&gt;t_lropktlen) + ack_size;
	<span class="enscript-keyword">if</span> (prev_ack &lt; org_ack) {
		ack_chain = m_dup(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (ack_chain) {
			th-&gt;th_ack = htonl(prev_ack);
			<span class="enscript-comment">/* Keep adv window constant for duplicated ACK packets */</span>
			scaled_win = win_rtedge - prev_ack;
			<span class="enscript-keyword">if</span> (scaled_win &gt; (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale))
				scaled_win = (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);
			th-&gt;th_win = htons(scaled_win&gt;&gt;tp-&gt;rcv_scale);
			<span class="enscript-keyword">if</span> (lrodebug == 5) {
				printf(<span class="enscript-string">&quot;%s: win = %d winsz = %d sc = %d&quot;</span>
				    <span class="enscript-string">&quot; lro_len %d %d\n&quot;</span>,
				    __func__, scaled_win&gt;&gt;tp-&gt;rcv_scale, winsz,
				    tp-&gt;rcv_scale, tp-&gt;t_lropktlen, count);
			}
			tail = ack_chain;
			count -= segs_acked; <span class="enscript-comment">/* accounts for prev_ack packet */</span>
			count = (count &lt;= segs_acked) ? 0 : count - segs_acked;
			tcpstat.tcps_sndacks++;
			so_tc_update_stats(m, so, m_get_service_class(m));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	<span class="enscript-keyword">else</span> {
		tp-&gt;t_lropktlen = 0;
		<span class="enscript-keyword">return</span> NULL;
	}

	prev_ack_pkt = ack_chain;

	<span class="enscript-keyword">while</span> (count &gt; 0) {
		<span class="enscript-keyword">if</span> ((prev_ack + ack_size) &lt; org_ack) {
			prev_ack += ack_size;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * The last ACK sent must have the ACK number that TCP
			 * thinks is the last sent ACK number.
			 */</span>
			 prev_ack = org_ack;
		}
		mnext = m_dup(prev_ack_pkt, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (mnext) {
			<span class="enscript-comment">/* Keep adv window constant for duplicated ACK packets */</span>
			scaled_win = win_rtedge - prev_ack;
			<span class="enscript-keyword">if</span> (scaled_win &gt; (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale))
				scaled_win = (int32_t)(TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);
			winsz = htons(scaled_win&gt;&gt;tp-&gt;rcv_scale);
			<span class="enscript-keyword">if</span> (lrodebug == 5) {
				printf(<span class="enscript-string">&quot;%s: winsz = %d ack %x count %d\n&quot;</span>,
			    	    __func__, scaled_win&gt;&gt;tp-&gt;rcv_scale,
				    prev_ack, count);
			}
			bcopy(&amp;winsz, mtod(prev_ack_pkt, caddr_t) + twin_offset, 2);
			HTONL(prev_ack);
			bcopy(&amp;prev_ack, mtod(prev_ack_pkt, caddr_t) + tack_offset, 4);
			NTOHL(prev_ack);
			tail-&gt;m_nextpkt = mnext;
			tail = mnext;
			count -= segs_acked;
			tcpstat.tcps_sndacks++;
			so_tc_update_stats(m, so, m_get_service_class(m));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (lrodebug == 5) {
				printf(<span class="enscript-string">&quot;%s: failed to alloc mbuf.\n&quot;</span>, __func__);
			}
			<span class="enscript-keyword">break</span>;
		}
		prev_ack_pkt = mnext;
	}
	tp-&gt;t_lropktlen = 0;
	<span class="enscript-keyword">return</span> ack_chain;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_recv_throttle</span> (<span class="enscript-type">struct</span> tcpcb *tp)
{
	uint32_t base_rtt, newsize;
	int32_t qdelay;
	<span class="enscript-type">struct</span> sockbuf *sbrcv = &amp;tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_rcv;

	<span class="enscript-keyword">if</span> (tcp_use_rtt_recvbg == 1 &amp;&amp;
	    TSTMP_SUPPORTED(tp)) {
		<span class="enscript-comment">/* 
		 * Timestamps are supported on this connection. Use
		 * RTT to look for an increase in latency.
		 */</span>

		<span class="enscript-comment">/* 
		 * If the connection is already being throttled, leave it
		 * in that state until rtt comes closer to base rtt
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_RECV_THROTTLE)
			<span class="enscript-keyword">return</span> (1);

		base_rtt = get_base_rtt(tp);
		
		<span class="enscript-keyword">if</span> (base_rtt != 0 &amp;&amp; tp-&gt;t_rttcur != 0) {
			qdelay = tp-&gt;t_rttcur - base_rtt;
			<span class="enscript-comment">/*
			 * if latency increased on a background flow,
			 * return 1 to start throttling.
			 */</span>
			<span class="enscript-keyword">if</span> (qdelay &gt; target_qdelay) {
				tp-&gt;t_flagsext |= TF_RECV_THROTTLE;

				<span class="enscript-comment">/*
				 * Reduce the recv socket buffer size to
				 * minimize latecy.
				 */</span>
				<span class="enscript-keyword">if</span> (sbrcv-&gt;sb_idealsize &gt; 
				    tcp_recv_throttle_minwin) {
					newsize = sbrcv-&gt;sb_idealsize &gt;&gt; 1;
					<span class="enscript-comment">/* Set a minimum of 16 K */</span>
					newsize = 
					    max(newsize, 
					    tcp_recv_throttle_minwin);
					sbrcv-&gt;sb_idealsize = newsize;
				}
				<span class="enscript-keyword">return</span> (1);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> (0);
			}
		}
	}

	<span class="enscript-comment">/*
	 * Timestamps are not supported or there is no good RTT
	 * measurement. Use IPDV in this case.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;acc_iaj &gt; tcp_acc_iaj_react_limit)
		<span class="enscript-keyword">return</span> (1);
	
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>