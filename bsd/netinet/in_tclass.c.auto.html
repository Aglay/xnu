<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in_tclass.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in_tclass.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/lro_ext.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> tfp_count = 0;

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, tclass_for_proc) tfp_head =
    TAILQ_HEAD_INITIALIZER(tfp_head);

<span class="enscript-type">struct</span> tclass_for_proc {
	TAILQ_ENTRY(tclass_for_proc)	tfp_link;
	<span class="enscript-type">int</span>	tfp_class;
	pid_t	tfp_pid;
	<span class="enscript-type">char</span>	tfp_pname[MAXCOMLEN + 1];
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dscp_code_from_mbuf_tclass</span>(mbuf_traffic_class_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_pname_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">set_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">set_pname_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">flush_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">purge_tclass_for_proc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">flush_tclass_for_proc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">get_tclass_for_curr_proc</span>(<span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">so_throttle_best_effort</span>(<span class="enscript-type">struct</span> socket* ,<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> lck_grp_attr_t *tclass_lck_grp_attr = NULL; <span class="enscript-comment">/* mutex group attributes */</span>
<span class="enscript-type">static</span> lck_grp_t *tclass_lck_grp = NULL;	<span class="enscript-comment">/* mutex group definition */</span>
<span class="enscript-type">static</span> lck_attr_t *tclass_lck_attr = NULL;	<span class="enscript-comment">/* mutex attributes */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, tclass_lock_data);
<span class="enscript-type">static</span> lck_mtx_t *tclass_lock = &amp;tclass_lock_data;

<span class="enscript-comment">/*
 * If there is no foreground activity on the interface for bg_switch_time
 * seconds, the background connections can switch to foreground TCP
 * congestion control.
 */</span> 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_BG_SWITCH_TIME</span> 2 <span class="enscript-comment">/* seconds */</span>

<span class="enscript-comment">/*
 * Must be called with tclass_lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tclass_for_proc *
<span class="enscript-function-name">find_tfp_by_pid</span>(pid_t pid)
{
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;

	TAILQ_FOREACH(tfp, &amp;tfp_head, tfp_link) {
		<span class="enscript-keyword">if</span> (tfp-&gt;tfp_pid == pid)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (tfp);
}

<span class="enscript-comment">/*
 * Must be called with tclass_lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tclass_for_proc *
<span class="enscript-function-name">find_tfp_by_pname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *pname)
{
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;

	TAILQ_FOREACH(tfp, &amp;tfp_head, tfp_link) {
		<span class="enscript-keyword">if</span> (strncmp(pname, tfp-&gt;tfp_pname,
		    <span class="enscript-keyword">sizeof</span> (tfp-&gt;tfp_pname)) == 0)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (tfp);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">get_tclass_for_curr_proc</span>(<span class="enscript-type">int</span> *sotc)
{
	<span class="enscript-type">struct</span> tclass_for_proc *tfp = NULL;
	proc_t p = current_proc();	<span class="enscript-comment">/* Not ref counted */</span>
	pid_t pid = proc_pid(p);
	<span class="enscript-type">char</span> *pname = proc_name_address(p);

	*sotc = -1;

	lck_mtx_lock(tclass_lock);

	TAILQ_FOREACH(tfp, &amp;tfp_head, tfp_link) {
		<span class="enscript-keyword">if</span> ((tfp-&gt;tfp_pid == pid) || (tfp-&gt;tfp_pid == -1 &amp;&amp;
		    strncmp(pname, tfp-&gt;tfp_pname,
		    <span class="enscript-keyword">sizeof</span> (tfp-&gt;tfp_pname)) == 0)) {
			*sotc = tfp-&gt;tfp_class;
			<span class="enscript-keyword">break</span>;
		}
	}

	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">return</span> ((tfp == NULL) ? 0 : 1);
}

<span class="enscript-comment">/*
 * Purge entries with PIDs of exited processes
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">purge_tclass_for_proc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp, *tvar;

	lck_mtx_lock(tclass_lock);

	TAILQ_FOREACH_SAFE(tfp, &amp;tfp_head, tfp_link, tvar) {
		proc_t p;

		<span class="enscript-keyword">if</span> (tfp-&gt;tfp_pid == -1)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((p = proc_find(tfp-&gt;tfp_pid)) == NULL) {
			tfp_count--;
			TAILQ_REMOVE(&amp;tfp_head, tfp, tfp_link);

			_FREE(tfp, M_TEMP);
		} <span class="enscript-keyword">else</span> {
			proc_rele(p);
		}
	}

	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove one entry
 * Must be called with tclass_lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">free_tclass_for_proc</span>(<span class="enscript-type">struct</span> tclass_for_proc *tfp)
{
	<span class="enscript-keyword">if</span> (tfp == NULL)
		<span class="enscript-keyword">return</span>;
	tfp_count--;
	TAILQ_REMOVE(&amp;tfp_head, tfp, tfp_link);
	_FREE(tfp, M_TEMP);
}

<span class="enscript-comment">/*
 * Remove all entries
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">flush_tclass_for_proc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp, *tvar;

	lck_mtx_lock(tclass_lock);

	TAILQ_FOREACH_SAFE(tfp, &amp;tfp_head, tfp_link, tvar) {
		free_tclass_for_proc(tfp);
	}

	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">return</span> (error);

}

<span class="enscript-comment">/*
 * Must be called with tclass_lock held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tclass_for_proc *
<span class="enscript-function-name">alloc_tclass_for_proc</span>(pid_t pid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *pname)
{
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;

	<span class="enscript-keyword">if</span> (pid == -1 &amp;&amp; pname == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	tfp = _MALLOC(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tclass_for_proc), M_TEMP, M_NOWAIT|M_ZERO);
	<span class="enscript-keyword">if</span> (tfp == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	tfp-&gt;tfp_pid = pid;
	<span class="enscript-comment">/*
	 * Add per pid entries before per proc name so we can find
	 * a specific instance of a process before the general name base entry.
	 */</span>
	<span class="enscript-keyword">if</span> (pid != -1) {
		TAILQ_INSERT_HEAD(&amp;tfp_head, tfp, tfp_link);
	} <span class="enscript-keyword">else</span> {
		strlcpy(tfp-&gt;tfp_pname, pname, <span class="enscript-keyword">sizeof</span> (tfp-&gt;tfp_pname));
		TAILQ_INSERT_TAIL(&amp;tfp_head, tfp, tfp_link);
	}

	tfp_count++;

	<span class="enscript-keyword">return</span> (tfp);
}

<span class="enscript-comment">/*
 * -1 for tclass means to remove the entry
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">set_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = EINVAL;
	proc_t p = NULL;
	<span class="enscript-type">struct</span> filedesc *fdp;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;
	<span class="enscript-type">int</span> i;
	pid_t pid = so_tcdbg-&gt;so_tcdbg_pid;
	<span class="enscript-type">int</span> tclass = so_tcdbg-&gt;so_tcdbg_tclass;

	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p == NULL) {
		printf(<span class="enscript-string">&quot;%s proc_find(%d) failed\n&quot;</span>, __func__, pid);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Need a tfp */</span>
	lck_mtx_lock(tclass_lock);

	tfp = find_tfp_by_pid(pid);
	<span class="enscript-keyword">if</span> (tfp == NULL) {
		tfp = alloc_tclass_for_proc(pid, NULL);
		<span class="enscript-keyword">if</span> (tfp == NULL) {
			lck_mtx_unlock(tclass_lock);
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	tfp-&gt;tfp_class = tclass;

	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">if</span> (tfp != NULL) {
		proc_fdlock(p);

		fdp = p-&gt;p_fd;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_nfiles; i++) {
			<span class="enscript-type">struct</span> socket *so;

			fp = fdp-&gt;fd_ofiles[i];
			<span class="enscript-keyword">if</span> (fp == NULL ||
			    (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED) != 0 ||
			    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET)
				<span class="enscript-keyword">continue</span>;

			so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
			<span class="enscript-keyword">if</span> (SOCK_DOM(so) != PF_INET &amp;&amp; SOCK_DOM(so) != PF_INET6)
				<span class="enscript-keyword">continue</span>;
			socket_lock(so, 1);
			<span class="enscript-keyword">if</span> (tclass != -1) {
				error = so_set_traffic_class(so, tclass);
				<span class="enscript-keyword">if</span> (error != 0) {
					printf(<span class="enscript-string">&quot;%s: so_set_traffic_class&quot;</span>
					    <span class="enscript-string">&quot;(so=0x%llx, fd=%d, tclass=%d) &quot;</span>
					    <span class="enscript-string">&quot;failed %d\n&quot;</span>, __func__,
					    (uint64_t)VM_KERNEL_ADDRPERM(so),
					    i, tclass, error);
					error = 0;
				}
			}
			socket_unlock(so, 1);
		}

		proc_fdunlock(p);
	}

	error = 0;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (p != NULL)
		proc_rele(p);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">set_pname_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = EINVAL;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;

	lck_mtx_lock(tclass_lock);

	tfp = find_tfp_by_pname(so_tcdbg-&gt;so_tcdbg_pname);
	<span class="enscript-keyword">if</span> (tfp == NULL) {
		tfp = alloc_tclass_for_proc(-1, so_tcdbg-&gt;so_tcdbg_pname);
		<span class="enscript-keyword">if</span> (tfp == NULL) {
			lck_mtx_unlock(tclass_lock);
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	tfp-&gt;tfp_class = so_tcdbg-&gt;so_tcdbg_tclass;

	lck_mtx_unlock(tclass_lock);

	error = 0;
<span class="enscript-reference">done</span>:

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flush_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	pid_t pid = so_tcdbg-&gt;so_tcdbg_pid;
	<span class="enscript-type">int</span> tclass = so_tcdbg-&gt;so_tcdbg_tclass;
	<span class="enscript-type">struct</span> filedesc *fdp;
	<span class="enscript-type">int</span> error = EINVAL;
	proc_t p;
	<span class="enscript-type">int</span> i;

	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p == PROC_NULL) {
		printf(<span class="enscript-string">&quot;%s proc_find(%d) failed\n&quot;</span>, __func__, pid);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	proc_fdlock(p);
	fdp = p-&gt;p_fd;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_nfiles; i++) {
		<span class="enscript-type">struct</span> socket *so;
		<span class="enscript-type">struct</span> fileproc *fp;

		fp = fdp-&gt;fd_ofiles[i];
		<span class="enscript-keyword">if</span> (fp == NULL ||
		    (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED) != 0 ||
		    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET)
			<span class="enscript-keyword">continue</span>;

		so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
		error = sock_setsockopt(so, SOL_SOCKET, SO_FLUSH, &amp;tclass,
		    <span class="enscript-keyword">sizeof</span> (tclass));
		<span class="enscript-keyword">if</span> (error != 0) {
			printf(<span class="enscript-string">&quot;%s: setsockopt(SO_FLUSH) (so=0x%llx, fd=%d, &quot;</span>
			    <span class="enscript-string">&quot;tclass=%d) failed %d\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(so), i, tclass,
			    error);
			error = 0;
		}
	}
	proc_fdunlock(p);

	error = 0;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (p != PROC_NULL)
		proc_rele(p);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_pid_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = EINVAL;
	proc_t p = NULL;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;
	pid_t pid = so_tcdbg-&gt;so_tcdbg_pid;

	so_tcdbg-&gt;so_tcdbg_tclass = -1; <span class="enscript-comment">/* Means not set */</span>
	so_tcdbg-&gt;so_tcdbg_opportunistic = -1; <span class="enscript-comment">/* Means not set */</span>

	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p == NULL) {
		printf(<span class="enscript-string">&quot;%s proc_find(%d) failed\n&quot;</span>, __func__, pid);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Need a tfp */</span>
	lck_mtx_lock(tclass_lock);

	tfp = find_tfp_by_pid(pid);
	<span class="enscript-keyword">if</span> (tfp != NULL) {
		so_tcdbg-&gt;so_tcdbg_tclass = tfp-&gt;tfp_class;
		error = 0;
	}
	lck_mtx_unlock(tclass_lock);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (p != NULL)
		proc_rele(p);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_pname_tclass</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = EINVAL;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp;

	so_tcdbg-&gt;so_tcdbg_tclass = -1; <span class="enscript-comment">/* Means not set */</span>
	so_tcdbg-&gt;so_tcdbg_opportunistic = -1; <span class="enscript-comment">/* Means not set */</span>

	<span class="enscript-comment">/* Need a tfp */</span>
	lck_mtx_lock(tclass_lock);

	tfp = find_tfp_by_pname(so_tcdbg-&gt;so_tcdbg_pname);
	<span class="enscript-keyword">if</span> (tfp != NULL) {
		so_tcdbg-&gt;so_tcdbg_tclass = tfp-&gt;tfp_class;
		error = 0;
	}
	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">delete_tclass_for_pid_pname</span>(<span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = EINVAL;
	pid_t pid = so_tcdbg-&gt;so_tcdbg_pid;
	<span class="enscript-type">struct</span> tclass_for_proc *tfp = NULL;

	lck_mtx_lock(tclass_lock);

	<span class="enscript-keyword">if</span> (pid != -1)
		tfp = find_tfp_by_pid(pid);
	<span class="enscript-keyword">else</span>
		tfp = find_tfp_by_pname(so_tcdbg-&gt;so_tcdbg_pname);

	<span class="enscript-keyword">if</span> (tfp != NULL) {
		free_tclass_for_proc(tfp);
		error = 0;
	}

	lck_mtx_unlock(tclass_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Setting options requires privileges
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_tcdbg</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> so_tcdbg *so_tcdbg)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_PRIV) == 0)
		<span class="enscript-keyword">return</span> (EPERM);

	socket_unlock(so, 0);

	<span class="enscript-keyword">switch</span> (so_tcdbg-&gt;so_tcdbg_cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_PID</span>:
			error = set_pid_tclass(so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_PNAME</span>:
			error = set_pname_tclass(so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_PURGE</span>:
			error = purge_tclass_for_proc();
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_FLUSH</span>:
			error = flush_tclass_for_proc();
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_DELETE</span>:
			error = delete_tclass_for_pid_pname(so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_TCFLUSH_PID</span>:
			error = flush_pid_tclass(so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
	}

	socket_lock(so, 0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Not required to be privileged to get
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sogetopt_tcdbg</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> so_tcdbg so_tcdbg;
	<span class="enscript-type">void</span> *buf = NULL;
	size_t len = sopt-&gt;sopt_valsize;

	error = sooptcopyin(sopt, &amp;so_tcdbg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg),
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg));
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	sopt-&gt;sopt_valsize = len;

	socket_unlock(so, 0);

	<span class="enscript-keyword">switch</span> (so_tcdbg.so_tcdbg_cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_PID</span>:
			error = get_pid_tclass(&amp;so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_PNAME</span>:
			error = get_pname_tclass(&amp;so_tcdbg);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_COUNT</span>:
			lck_mtx_lock(tclass_lock);
			so_tcdbg.so_tcdbg_count = tfp_count;
			lck_mtx_unlock(tclass_lock);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TCDBG_LIST</span>: {
			<span class="enscript-type">struct</span> tclass_for_proc *tfp;
			<span class="enscript-type">int</span> n, alloc_count;
			<span class="enscript-type">struct</span> so_tcdbg *ptr;

			lck_mtx_lock(tclass_lock);
			<span class="enscript-keyword">if</span> ((alloc_count = tfp_count) == 0) {
				lck_mtx_unlock(tclass_lock);
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			len = alloc_count * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg);
			lck_mtx_unlock(tclass_lock);

			buf = _MALLOC(len, M_TEMP, M_WAITOK | M_ZERO);
			<span class="enscript-keyword">if</span> (buf == NULL) {
				error = ENOBUFS;
				<span class="enscript-keyword">break</span>;
			}

			lck_mtx_lock(tclass_lock);
			n = 0;
			ptr = (<span class="enscript-type">struct</span> so_tcdbg *)buf;
			TAILQ_FOREACH(tfp, &amp;tfp_head, tfp_link) {
				<span class="enscript-keyword">if</span> (++n &gt; alloc_count)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (tfp-&gt;tfp_pid != -1) {
					ptr-&gt;so_tcdbg_cmd = SO_TCDBG_PID;
					ptr-&gt;so_tcdbg_pid = tfp-&gt;tfp_pid;
				} <span class="enscript-keyword">else</span> {
					ptr-&gt;so_tcdbg_cmd = SO_TCDBG_PNAME;
					ptr-&gt;so_tcdbg_pid = -1;
					strlcpy(ptr-&gt;so_tcdbg_pname,
					    tfp-&gt;tfp_pname,
					    <span class="enscript-keyword">sizeof</span> (ptr-&gt;so_tcdbg_pname));
				}
				ptr-&gt;so_tcdbg_tclass = tfp-&gt;tfp_class;
				ptr++;
			}

			lck_mtx_unlock(tclass_lock);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
	}

	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (buf == NULL) {
			error = sooptcopyout(sopt, &amp;so_tcdbg,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg));
		} <span class="enscript-keyword">else</span> {
			error = sooptcopyout(sopt, buf, len);
			_FREE(buf, M_TEMP);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}


__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_traffic_class</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (optval &lt; SO_TC_BE || optval &gt; SO_TC_CTL) {
		error = EINVAL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (optval) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_BK</span>:
			optval = SO_TC_BK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_VI</span>:
			optval = SO_TC_VI;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_VO</span>:
			optval = SO_TC_VO;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (!SO_VALID_TC(optval))
				error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-type">int</span> oldval = so-&gt;so_traffic_class;

			VERIFY(SO_VALID_TC(optval));
			so-&gt;so_traffic_class = optval;

			<span class="enscript-keyword">if</span> ((SOCK_DOM(so) == PF_INET ||
			    SOCK_DOM(so) == PF_INET6) &amp;&amp;
			    SOCK_TYPE(so) == SOCK_STREAM)
				set_tcp_stream_priority(so);

			<span class="enscript-keyword">if</span> ((SOCK_DOM(so) == PF_INET ||
			    SOCK_DOM(so) == PF_INET6) &amp;&amp;
			    optval != oldval &amp;&amp; (optval == SO_TC_BK_SYS ||
			    oldval == SO_TC_BK_SYS)) {
				<span class="enscript-comment">/*
				 * If the app switches from BK_SYS to something
				 * else, resume the socket if it was suspended.
				 */</span>
				<span class="enscript-keyword">if</span> (oldval == SO_TC_BK_SYS)
					inp_reset_fc_state(so-&gt;so_pcb);

				SOTHROTTLELOG((<span class="enscript-string">&quot;throttle[%d]: so 0x%llx &quot;</span>
				    <span class="enscript-string">&quot;[%d,%d] opportunistic %s\n&quot;</span>, so-&gt;last_pid,
				    (uint64_t)VM_KERNEL_ADDRPERM(so),
				    SOCK_DOM(so), SOCK_TYPE(so),
				    (optval == SO_TC_BK_SYS) ? <span class="enscript-string">&quot;ON&quot;</span> : <span class="enscript-string">&quot;OFF&quot;</span>));
			}
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">so_set_default_traffic_class</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> sotc = -1;

	<span class="enscript-keyword">if</span> (tfp_count &gt; 0 &amp;&amp;
	    (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6)) {
		get_tclass_for_curr_proc(&amp;sotc);
	}

	so-&gt;so_traffic_class = (sotc != -1) ? sotc : SO_TC_BE;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_opportunistic</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-keyword">return</span> (so_set_traffic_class(so, (optval == 0) ?
	    SO_TC_BE : SO_TC_BK_SYS));
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_get_opportunistic</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span> (so-&gt;so_traffic_class == SO_TC_BK_SYS);
}

__private_extern__ mbuf_svc_class_t
<span class="enscript-function-name">mbuf_service_class_from_control</span>(<span class="enscript-type">struct</span> mbuf *control)
{
	<span class="enscript-type">struct</span> cmsghdr *cm;
	mbuf_svc_class_t msc = MBUF_SC_UNSPEC;

	<span class="enscript-keyword">for</span> (cm = M_FIRST_CMSGHDR(control); cm != NULL;
	    cm = M_NXT_CMSGHDR(control, cm)) {
		<span class="enscript-type">int</span> tc;

		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cmsghdr))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_level != SOL_SOCKET ||
		    cm-&gt;cmsg_type != SO_TRAFFIC_CLASS)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len != CMSG_LEN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)))
			<span class="enscript-keyword">continue</span>;

		tc = *(<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)CMSG_DATA(cm);
		msc = so_tc2msc(tc);
		<span class="enscript-keyword">if</span> (MBUF_VALID_SC(msc))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (msc);
}

__private_extern__  <span class="enscript-type">int</span>
<span class="enscript-function-name">dscp_code_from_mbuf_tclass</span>(mbuf_traffic_class_t mtc)
{
	<span class="enscript-type">int</span> dscp_code;

	<span class="enscript-keyword">switch</span> (mtc) {
		<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BE</span>:
			dscp_code = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_BK</span>:
			dscp_code = 0x08;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VI</span>:
			dscp_code = 0x20;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_TC_VO</span>:
			dscp_code = 0x30;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (dscp_code);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">so_recv_data_stat</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> mbuf *m, size_t off)
{
	uint32_t sotc = m_get_traffic_class(m);

	<span class="enscript-keyword">if</span> (sotc &gt;= SO_TC_STATS_MAX)
		sotc = SO_TC_BE;

	so-&gt;so_tc_stats[sotc].rxpackets += 1;
	so-&gt;so_tc_stats[sotc].rxbytes +=
	    ((m-&gt;m_flags &amp; M_PKTHDR) ? m-&gt;m_pkthdr.len : 0) + off;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">so_inc_recv_data_stat</span>(<span class="enscript-type">struct</span> socket *so, size_t pkts, size_t bytes, uint32_t tc)
{
	<span class="enscript-keyword">if</span> (tc &gt;= SO_TC_STATS_MAX)
		tc = SO_TC_BE;

	so-&gt;so_tc_stats[tc].rxpackets += pkts;
	so-&gt;so_tc_stats[tc].rxbytes +=bytes;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">so_throttle_best_effort</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> ifnet *ifp)
{
	u_int32_t uptime = net_uptime();
	<span class="enscript-keyword">return</span> (soissrcbesteffort(so) &amp;&amp;
	    net_io_policy_throttle_best_effort == 1 &amp;&amp;
	    ifp-&gt;if_rt_sendts &gt; 0 &amp;&amp;
	    (<span class="enscript-type">int</span>)(uptime - ifp-&gt;if_rt_sendts) &lt;= TCP_BG_SWITCH_TIME);
}
 
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">set_tcp_stream_priority</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(inp);
	<span class="enscript-type">struct</span> ifnet *outifp;
	u_char old_cc = tp-&gt;tcp_cc_index;
	<span class="enscript-type">int</span> recvbg = IS_TCP_RECV_BG(so);
	bool is_local = false, fg_active = false;
	u_int32_t uptime;

	VERIFY((SOCK_CHECK_DOM(so, PF_INET) 
	    || SOCK_CHECK_DOM(so, PF_INET6))
	    &amp;&amp; SOCK_CHECK_TYPE(so, SOCK_STREAM)
	    &amp;&amp; SOCK_CHECK_PROTO(so, IPPROTO_TCP));

	<span class="enscript-comment">/* Return if the socket is in a terminal state */</span>	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span>;

	outifp = inp-&gt;inp_last_outifp;
	uptime = net_uptime();

	<span class="enscript-comment">/*
	 * If the socket was marked as a background socket or if the
	 * traffic class is set to background with traffic class socket
	 * option then make both send and recv side of the stream to be
	 * background. The variable sotcdb which can be set with sysctl
	 * is used to disable these settings for testing.
	 */</span>
	<span class="enscript-keyword">if</span> (outifp == NULL || (outifp-&gt;if_flags &amp; IFF_LOOPBACK))
		is_local = true;

	<span class="enscript-comment">/* Check if there has been recent foreground activity */</span>
	<span class="enscript-keyword">if</span> (outifp != NULL) {
		<span class="enscript-comment">/*
		 * If the traffic source is background, check if
		 * if it can be switched to foreground. This can 
		 * happen when there is no indication of foreground
		 * activity.
		 */</span>
		<span class="enscript-keyword">if</span> (soissrcbackground(so) &amp;&amp; 
		    ((outifp-&gt;if_fg_sendts &gt; 0 &amp;&amp;
		    (<span class="enscript-type">int</span>)(uptime - outifp-&gt;if_fg_sendts) &lt;= 
		    TCP_BG_SWITCH_TIME) || net_io_policy_throttled))
			fg_active = true;

		<span class="enscript-comment">/*
		 * The traffic source is best-effort -- check if
		 * the policy to throttle best effort is enabled
		 * and there was realtime activity on this
		 * interface recently. If this is true, enable
		 * algorithms that respond to increased latency
		 * on best-effort traffic.
		 */</span> 
		<span class="enscript-keyword">if</span> (so_throttle_best_effort(so, outifp))
			fg_active = true;
	}

	<span class="enscript-comment">/*
	 * System initiated background traffic like cloud uploads should
	 * always use background delay sensitive algorithms. This will
	 * make the stream more responsive to other streams on the user's
	 * network and it will minimize latency induced.
	 */</span>
	<span class="enscript-keyword">if</span> (fg_active || IS_SO_TC_BACKGROUNDSYSTEM(so-&gt;so_traffic_class)) {
		<span class="enscript-comment">/*
		 * If the interface that the connection is using is
		 * loopback, do not use background congestion
		 * control algorithm.
		 *
		 * If there has been recent foreground activity or if 
		 * there was an indication that a foreground application 
		 * is going to use networking (net_io_policy_throttled),
		 * switch the backgroung streams to use background 
		 * congestion control algorithm. Otherwise, even background
		 * flows can move into foreground.
		 */</span>
		<span class="enscript-keyword">if</span> ((sotcdb &amp; SOTCDB_NO_SENDTCPBG) != 0 || is_local ||
		    !IS_SO_TC_BACKGROUNDSYSTEM(so-&gt;so_traffic_class)) {
			<span class="enscript-keyword">if</span> (old_cc == TCP_CC_ALGO_BACKGROUND_INDEX)
				tcp_set_foreground_cc(so);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (old_cc != TCP_CC_ALGO_BACKGROUND_INDEX)
				tcp_set_background_cc(so);
		}

		<span class="enscript-comment">/* Set receive side background flags */</span>
		<span class="enscript-keyword">if</span> ((sotcdb &amp; SOTCDB_NO_RECVTCPBG) != 0 || is_local ||
		    !IS_SO_TC_BACKGROUNDSYSTEM(so-&gt;so_traffic_class)) {
			tcp_clear_recv_bg(so);
		} <span class="enscript-keyword">else</span> {
			tcp_set_recv_bg(so);
		}
	} <span class="enscript-keyword">else</span> {
		tcp_clear_recv_bg(so);
		<span class="enscript-keyword">if</span> (old_cc == TCP_CC_ALGO_BACKGROUND_INDEX)
			tcp_set_foreground_cc(so);
	}

	<span class="enscript-keyword">if</span> (old_cc != tp-&gt;tcp_cc_index || recvbg != IS_TCP_RECV_BG(so)) {
		SOTHROTTLELOG((<span class="enscript-string">&quot;throttle[%d]: so 0x%llx [%d,%d] TCP %s send; &quot;</span>
		   <span class="enscript-string">&quot;%s recv\n&quot;</span>, so-&gt;last_pid, (uint64_t)VM_KERNEL_ADDRPERM(so),
		   SOCK_DOM(so), SOCK_TYPE(so),
		   (tp-&gt;tcp_cc_index == TCP_CC_ALGO_BACKGROUND_INDEX) ?
		   <span class="enscript-string">&quot;background&quot;</span> : <span class="enscript-string">&quot;foreground&quot;</span>,
		   IS_TCP_RECV_BG(so) ? <span class="enscript-string">&quot;background&quot;</span> : <span class="enscript-string">&quot;foreground&quot;</span>));
	}
}

<span class="enscript-comment">/*
 * Set traffic class to an IPv4 or IPv6 packet
 * - mark the mbuf
 * - set the DSCP code following the WMM mapping
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">set_packet_service_class</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> socket *so,
    mbuf_svc_class_t in_msc, u_int32_t flags)
{
	mbuf_svc_class_t msc = MBUF_SC_BE;	   <span class="enscript-comment">/* Best effort by default */</span>
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so); <span class="enscript-comment">/* in6pcb and inpcb are the same */</span>
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">int</span> isipv6 = ((flags &amp; PKT_SCF_IPV6) != 0) ? 1 : 0; 

	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Here is the precedence:
	 * 1) TRAFFIC_MGT_SO_BACKGROUND trumps all
	 * 2) Traffic class passed via ancillary data to sendmsdg(2)
	 * 3) Traffic class socket option last
	 */</span>
	<span class="enscript-keyword">if</span> (in_msc != MBUF_SC_UNSPEC) {
		<span class="enscript-keyword">if</span> (in_msc &gt;= MBUF_SC_BE &amp;&amp; in_msc &lt;= MBUF_SC_CTL)
			msc = in_msc;
	} <span class="enscript-keyword">else</span> {
		VERIFY(SO_VALID_TC(so-&gt;so_traffic_class));
		msc = so_tc2msc(so-&gt;so_traffic_class);
		<span class="enscript-comment">/* Assert because tc must have been valid */</span>
		VERIFY(MBUF_VALID_SC(msc));
	}

	<span class="enscript-comment">/*
	 * If TRAFFIC_MGT_SO_BACKGROUND is set or policy to throttle
	 * best effort is set, depress the priority.
	 */</span>
	<span class="enscript-keyword">if</span> (!IS_MBUF_SC_BACKGROUND(msc) &amp;&amp; soisthrottled(so))
		msc = MBUF_SC_BK;

	<span class="enscript-keyword">if</span> (IS_MBUF_SC_BESTEFFORT(msc) &amp;&amp; inp-&gt;inp_last_outifp != NULL &amp;&amp;
	    so_throttle_best_effort(so, inp-&gt;inp_last_outifp))
		msc = MBUF_SC_BK;

	<span class="enscript-keyword">if</span> (soissrcbackground(so))
		m-&gt;m_pkthdr.pkt_flags |= PKTF_SO_BACKGROUND;

	<span class="enscript-keyword">if</span> (soissrcrealtime(so) || IS_MBUF_SC_REALTIME(msc))
		m-&gt;m_pkthdr.pkt_flags |= PKTF_SO_REALTIME;
	<span class="enscript-comment">/*
	 * Set the traffic class in the mbuf packet header svc field
	 */</span>
	<span class="enscript-keyword">if</span> (sotcdb &amp; SOTCDB_NO_MTC)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbtc</span>;

	<span class="enscript-comment">/* Elevate service class if the packet is a pure TCP ACK.
	 * We can do this only when the flow is not a background
	 * flow and the outgoing interface supports 
	 * transmit-start model.
	 */</span>
	<span class="enscript-keyword">if</span> (!IS_MBUF_SC_BACKGROUND(msc) &amp;&amp; (flags &amp; PKT_SCF_TCP_ACK))
		msc = MBUF_SC_CTL;

	(<span class="enscript-type">void</span>) m_set_service_class(m, msc);

	<span class="enscript-comment">/*
	 * Set the privileged traffic auxiliary flag if applicable, 
	 * or clear it.
	 */</span>
	<span class="enscript-keyword">if</span> (!(sotcdb &amp; SOTCDB_NO_PRIVILEGED) &amp;&amp; soisprivilegedtraffic(so) &amp;&amp;
	    msc != MBUF_SC_UNSPEC)
		m-&gt;m_pkthdr.pkt_flags |= PKTF_PRIO_PRIVILEGED;
	<span class="enscript-keyword">else</span>
		m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_PRIO_PRIVILEGED;

<span class="enscript-reference">no_mbtc</span>:
	<span class="enscript-comment">/*
	 * Quick exit when best effort
	 */</span>
	<span class="enscript-keyword">if</span> (msc == MBUF_SC_BE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_dscp</span>;

	<span class="enscript-comment">/*
	 * The default behavior is for the networking stack to not set the
	 * DSCP code, based on SOTCDB_NO_DSCP being set.  If the flag is
	 * cleared, set the DSCP code in IPv4 or IPv6 header only for local
	 * traffic, if it is not already set.  &lt;rdar://problem/11277343&gt;
	 */</span>
	<span class="enscript-keyword">if</span> (sotcdb &amp; SOTCDB_NO_DSCP)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_dscp</span>;

	<span class="enscript-comment">/*
	 * Test if a IP TOS or IPV6 TCLASS has already been set
	 * on the socket or the raw packet.
	 */</span>
	<span class="enscript-keyword">if</span> (!(sotcdb &amp; SOTCDB_NO_DSCPTST)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			<span class="enscript-keyword">if</span> ((so-&gt;so_type == SOCK_RAW &amp;&amp;
			    (ip6-&gt;ip6_flow &amp; htonl(0xff &lt;&lt; 20)) != 0) ||
			    (inp-&gt;in6p_outputopts &amp;&amp;
			    inp-&gt;in6p_outputopts-&gt;ip6po_tclass != -1))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_dscp</span>;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> ((so-&gt;so_type == SOCK_RAW &amp;&amp;
		    (inp-&gt;inp_flags &amp; INP_HDRINCL)) ||
		    inp-&gt;inp_ip_tos != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_dscp</span>;
	}

	<span class="enscript-comment">/*
	 * Test if destination is local
	 */</span>
	<span class="enscript-keyword">if</span> (!(sotcdb &amp; SOTCDB_NO_LCLTST)) {
		<span class="enscript-type">int</span> islocal = 0;
		<span class="enscript-type">struct</span> rtentry *rt = inp-&gt;inp_route.ro_rt;

		<span class="enscript-keyword">if</span> (so-&gt;so_type == SOCK_STREAM) {
			<span class="enscript-keyword">if</span> (intotcpcb(inp)-&gt;t_flags &amp; TF_LOCAL)
				islocal = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt != NULL &amp;&amp;
		    (rt-&gt;rt_gateway-&gt;sa_family == AF_LINK ||
		    (rt-&gt;rt_ifp-&gt;if_flags &amp; (IFF_LOOPBACK|IFF_POINTOPOINT)))) {
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_POINTOPOINT))
				islocal = 1;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6 &amp;&amp; in6addr_local(&amp;ip6-&gt;ip6_dst)) {
			islocal = 1;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inaddr_local(ip-&gt;ip_dst)) {
			islocal = 1;
		}
		<span class="enscript-keyword">if</span> (islocal == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_dscp</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		ip6-&gt;ip6_flow |= htonl(dscp_code_from_mbuf_tclass(
		    m_get_traffic_class(m)) &lt;&lt; 20);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		ip-&gt;ip_tos |= dscp_code_from_mbuf_tclass(
		    m_get_traffic_class(m)) &lt;&lt; 2;

<span class="enscript-reference">no_dscp</span>:
	<span class="enscript-comment">/*
	 * For TCP with background traffic class switch CC algo based on sysctl
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_type == SOCK_STREAM)
		set_tcp_stream_priority(so);

	so_tc_update_stats(m, so, msc);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">so_tc_update_stats</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> socket *so, mbuf_svc_class_t msc)
{
	mbuf_traffic_class_t mtc;

	<span class="enscript-comment">/*
	 * Assume socket and mbuf traffic class values are the same
	 * Also assume the socket lock is held.  Note that the stats
	 * at the socket layer are reduced down to the legacy traffic
	 * classes; we could/should potentially expand so_tc_stats[].
	 */</span>
	mtc = MBUF_SC2TC(msc);
	VERIFY(mtc &lt; SO_TC_STATS_MAX);
	so-&gt;so_tc_stats[mtc].txpackets += 1;
	so-&gt;so_tc_stats[mtc].txbytes += m-&gt;m_pkthdr.len;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">socket_tclass_init</span>(<span class="enscript-type">void</span>)
{
        _CASSERT(_SO_TC_MAX == SO_TC_STATS_MAX);

	tclass_lck_grp_attr = lck_grp_attr_alloc_init();
	tclass_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tclass&quot;</span>, tclass_lck_grp_attr);
	tclass_lck_attr = lck_attr_alloc_init();
	lck_mtx_init(tclass_lock, tclass_lck_grp, tclass_lck_attr);
}

__private_extern__ mbuf_svc_class_t
<span class="enscript-function-name">so_tc2msc</span>(<span class="enscript-type">int</span> tc)
{
	mbuf_svc_class_t msc;

	<span class="enscript-keyword">switch</span> (tc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_BK_SYS</span>:
		msc = MBUF_SC_BK_SYS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_BK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_BK</span>:
		msc = MBUF_SC_BK;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_BE</span>:
		msc = MBUF_SC_BE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_RD</span>:
		msc = MBUF_SC_RD;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_OAM</span>:
		msc = MBUF_SC_OAM;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_AV</span>:
		msc = MBUF_SC_AV;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_RV</span>:
		msc = MBUF_SC_RV;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_VI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_VI</span>:
		msc = MBUF_SC_VI;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_VO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_SO_TC_VO</span>:
		msc = MBUF_SC_VO;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_CTL</span>:
		msc = MBUF_SC_CTL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TC_ALL</span>:
	<span class="enscript-reference">default</span>:
		msc = MBUF_SC_UNSPEC;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (msc);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_svc2tc</span>(mbuf_svc_class_t svc)
{
	<span class="enscript-keyword">switch</span> (svc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_UNSPEC</span>:
		<span class="enscript-keyword">return</span> SO_TC_BE;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_BK_SYS</span>:
		<span class="enscript-keyword">return</span> SO_TC_BK_SYS;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_BK</span>:
		<span class="enscript-keyword">return</span> SO_TC_BK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_BE</span>:
		<span class="enscript-keyword">return</span> SO_TC_BE;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_RD</span>:
		<span class="enscript-keyword">return</span> SO_TC_RD;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_OAM</span>:
		<span class="enscript-keyword">return</span> SO_TC_OAM;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_AV</span>:
		<span class="enscript-keyword">return</span> SO_TC_AV;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_RV</span>:
		<span class="enscript-keyword">return</span> SO_TC_RV;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_VI</span>:
		<span class="enscript-keyword">return</span> SO_TC_VI;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_VO</span>:
		<span class="enscript-keyword">return</span> SO_TC_VO;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MBUF_SC_CTL</span>:
		<span class="enscript-keyword">return</span> SO_TC_CTL;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> SO_TC_BE;
	}
}

<span class="enscript-comment">/*
 * LRO is turned on for AV streaming class.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">so_set_lro</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-keyword">if</span> (optval == SO_TC_AV) {
		so-&gt;so_flags |= SOF_USELRO;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_USELRO) {
			<span class="enscript-comment">/* transition to non LRO class */</span>
			so-&gt;so_flags &amp;= ~SOF_USELRO;
			<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
			<span class="enscript-type">struct</span> tcpcb *tp = NULL;
			<span class="enscript-keyword">if</span> (inp) {
				tp = intotcpcb(inp);
				<span class="enscript-keyword">if</span> (tp &amp;&amp; (tp-&gt;t_flagsext &amp; TF_LRO_OFFLOADED)) {
					tcp_lro_remove_state(inp-&gt;inp_laddr,
						inp-&gt;inp_faddr,
						inp-&gt;inp_lport, 
						inp-&gt;inp_fport);
					tp-&gt;t_flagsext &amp;= ~TF_LRO_OFFLOADED;	
				}
			}
		}
	}
}

</pre>
<hr />
</body></html>