<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>flow_divert.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">flow_divert.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/tree.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert_proto.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/sha1.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/crypto_internal.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_CONNECT_STARTED</span>		0x00000001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_READ_CLOSED</span>			0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_WRITE_CLOSED</span>		0x00000004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_TUNNEL_RD_CLOSED</span>	0x00000008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_TUNNEL_WR_CLOSED</span>	0x00000010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_TRANSFERRED</span>			0x00000020

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDLOG</span>(level, pcb, format, ...) do {											\
	<span class="enscript-keyword">if</span> (level &lt;= (pcb)-&gt;log_level) {												\
		log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s (%u): &quot;</span> format <span class="enscript-string">&quot;\n&quot;</span>, __FUNCTION__, (pcb)-&gt;hash, __VA_ARGS__); 	\
	}																				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDLOG0</span>(level, pcb, msg) do {												\
	<span class="enscript-keyword">if</span> (level &lt;= (pcb)-&gt;log_level) {												\
		log((level &gt; LOG_NOTICE ? LOG_NOTICE : level), <span class="enscript-string">&quot;%s (%u): %s\n&quot;</span>, __FUNCTION__, (pcb)-&gt;hash, msg);				\
	}																				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDRETAIN</span>(pcb)			if ((pcb) != NULL) OSIncrementAtomic(&amp;(pcb)-&gt;ref_count)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDRELEASE</span>(pcb)														\
	<span class="enscript-keyword">do</span> {																	\
		<span class="enscript-keyword">if</span> ((pcb) != NULL &amp;&amp; 1 == OSDecrementAtomic(&amp;(pcb)-&gt;ref_count)) {	\
			flow_divert_pcb_destroy(pcb);									\
		}																	\
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDLOCK</span>(pcb)						lck_mtx_lock(&amp;(pcb)-&gt;mtx)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FDUNLOCK</span>(pcb)					lck_mtx_unlock(&amp;(pcb)-&gt;mtx)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FD_CTL_SENDBUFF_SIZE</span>			(2 * FLOW_DIVERT_CHUNK_SIZE)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FD_CTL_RCVBUFF_SIZE</span>				(128 * 1024)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GROUP_BIT_CTL_ENQUEUE_BLOCKED</span>	0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GROUP_COUNT_MAX</span>					32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_MAX_NAME_SIZE</span>		4096
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FLOW_DIVERT_MAX_KEY_SIZE</span>		1024

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DNS_SERVICE_GROUP_UNIT</span>			(GROUP_COUNT_MAX + 1)

<span class="enscript-type">struct</span> flow_divert_trie_node
{
	uint16_t start;
	uint16_t length;
	uint16_t child_map;
	uint32_t group_unit;
};

<span class="enscript-type">struct</span> flow_divert_trie
{
	<span class="enscript-type">struct</span> flow_divert_trie_node *nodes;
	uint16_t *child_maps;
	uint8_t *bytes;
	<span class="enscript-type">void</span> *memory;
	size_t nodes_count;
	size_t child_maps_count;
	size_t bytes_count;
	size_t nodes_free_next;
	size_t child_maps_free_next;
	size_t bytes_free_next;
	uint16_t root;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHILD_MAP_SIZE</span>			256
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NULL_TRIE_IDX</span>			0xffff
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TRIE_NODE</span>(t, i)			((t)-&gt;nodes[(i)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TRIE_CHILD</span>(t, i, b)		(((t)-&gt;child_maps + (CHILD_MAP_SIZE * TRIE_NODE(t, i).child_map))[(b)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TRIE_BYTE</span>(t, i)			((t)-&gt;bytes[(i)])

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> flow_divert_pcb		nil_pcb;

<span class="enscript-function-name">decl_lck_rw_data</span>(<span class="enscript-type">static</span>, g_flow_divert_group_lck);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> flow_divert_group		**g_flow_divert_groups			= NULL;
<span class="enscript-type">static</span> uint32_t						g_active_group_count			= 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> flow_divert_trie		g_signing_id_trie;

<span class="enscript-type">static</span>	lck_grp_attr_t				*flow_divert_grp_attr			= NULL;
<span class="enscript-type">static</span>	lck_attr_t					*flow_divert_mtx_attr			= NULL;
<span class="enscript-type">static</span>	lck_grp_t					*flow_divert_mtx_grp			= NULL;
<span class="enscript-type">static</span>	errno_t						g_init_result					= 0;

<span class="enscript-type">static</span>	kern_ctl_ref				g_flow_divert_kctl_ref			= NULL;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw				g_flow_divert_in_protosw;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs			g_flow_divert_in_usrreqs;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw				g_flow_divert_in_udp_protosw;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs			g_flow_divert_in_udp_usrreqs;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6protosw			g_flow_divert_in6_protosw;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs			g_flow_divert_in6_usrreqs;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6protosw			g_flow_divert_in6_udp_protosw;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs			g_flow_divert_in6_udp_usrreqs;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw				*g_tcp_protosw					= NULL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6protosw			*g_tcp6_protosw					= NULL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw				*g_udp_protosw					= NULL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6protosw			*g_udp6_protosw					= NULL;

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_dup_addr</span>(sa_family_t family, <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> sockaddr **dup);

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_inp_to_sockaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr **local_socket);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">flow_divert_is_sockaddr_valid</span>(<span class="enscript-type">struct</span> sockaddr *addr);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_append_target_endpoint_tlv</span>(mbuf_t connect_packet, <span class="enscript-type">struct</span> sockaddr *toaddr);

<span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">flow_divert_get_buffered_target_address</span>(mbuf_t buffer);

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">flow_divert_has_pcb_local_address</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_disconnect_socket</span>(<span class="enscript-type">struct</span> socket *so);

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_pcb_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> flow_divert_pcb *pcb_a, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> flow_divert_pcb *pcb_b)
{
	<span class="enscript-keyword">return</span> memcmp(&amp;pcb_a-&gt;hash, &amp;pcb_b-&gt;hash, <span class="enscript-keyword">sizeof</span>(pcb_a-&gt;hash));
}

<span class="enscript-function-name">RB_PROTOTYPE</span>(fd_pcb_tree, flow_divert_pcb, rb_link, flow_divert_pcb_cmp);
<span class="enscript-function-name">RB_GENERATE</span>(fd_pcb_tree, flow_divert_pcb, rb_link, flow_divert_pcb_cmp);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">flow_divert_packet_type2str</span>(uint8_t packet_type)
{
	<span class="enscript-keyword">switch</span> (packet_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_CONNECT</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;connect&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_CONNECT_RESULT</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;connect result&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_DATA</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;data&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_CLOSE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;close&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_READ_NOTIFY</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;read notification&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_PROPERTIES_UPDATE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;properties update&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_APP_MAP_UPDATE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;app map update&quot;</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_APP_MAP_CREATE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;app map create&quot;</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;unknown&quot;</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> flow_divert_pcb *
<span class="enscript-function-name">flow_divert_pcb_lookup</span>(uint32_t hash, <span class="enscript-type">struct</span> flow_divert_group *group)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	key_item;
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb		= NULL;

	key_item.hash = hash;

	lck_rw_lock_shared(&amp;group-&gt;lck);
	fd_cb = RB_FIND(fd_pcb_tree, &amp;group-&gt;pcb_tree, &amp;key_item);
	FDRETAIN(fd_cb);
	lck_rw_done(&amp;group-&gt;lck);

	<span class="enscript-keyword">return</span> fd_cb;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_pcb_insert</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, uint32_t ctl_unit)
{
	errno_t							error						= 0;
	<span class="enscript-type">struct</span>						flow_divert_pcb	*exist		= NULL;
	<span class="enscript-type">struct</span> flow_divert_group	*group;
	<span class="enscript-type">static</span> uint32_t				g_nextkey					= 1;
	<span class="enscript-type">static</span> uint32_t				g_hash_seed					= 0;
	<span class="enscript-type">int</span>							try_count					= 0;

	<span class="enscript-keyword">if</span> (ctl_unit == 0 || ctl_unit &gt;= GROUP_COUNT_MAX) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	socket_unlock(fd_cb-&gt;so, 0);
	lck_rw_lock_shared(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (g_flow_divert_groups == NULL || g_active_group_count == 0) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;No active groups, flow divert cannot be used for this socket&quot;</span>);
		error = ENETUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	group = g_flow_divert_groups[ctl_unit];
	<span class="enscript-keyword">if</span> (group == NULL) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Group for control unit %u is NULL, flow divert cannot be used for this socket&quot;</span>, ctl_unit);
		error = ENETUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	socket_lock(fd_cb-&gt;so, 0);

	<span class="enscript-keyword">do</span> {
		uint32_t	key[2];
		uint32_t	idx;

		key[0] = g_nextkey++;
		key[1] = RandomULong();

		<span class="enscript-keyword">if</span> (g_hash_seed == 0) {
			g_hash_seed = RandomULong();
		}

		fd_cb-&gt;hash = net_flowhash(key, <span class="enscript-keyword">sizeof</span>(key), g_hash_seed);

		<span class="enscript-keyword">for</span> (idx = 1; idx &lt; GROUP_COUNT_MAX; idx++) {
			<span class="enscript-type">struct</span> flow_divert_group *curr_group = g_flow_divert_groups[idx];
			<span class="enscript-keyword">if</span> (curr_group != NULL &amp;&amp; curr_group != group) {
				lck_rw_lock_shared(&amp;curr_group-&gt;lck);
				exist = RB_FIND(fd_pcb_tree, &amp;curr_group-&gt;pcb_tree, fd_cb);
				lck_rw_done(&amp;curr_group-&gt;lck);
				<span class="enscript-keyword">if</span> (exist != NULL) {
					<span class="enscript-keyword">break</span>;
				}
			}
		}

		<span class="enscript-keyword">if</span> (exist == NULL) {
			lck_rw_lock_exclusive(&amp;group-&gt;lck);
			exist = RB_INSERT(fd_pcb_tree, &amp;group-&gt;pcb_tree, fd_cb);
			lck_rw_done(&amp;group-&gt;lck);
		}
	} <span class="enscript-keyword">while</span> (exist != NULL &amp;&amp; try_count++ &lt; 3);

	<span class="enscript-keyword">if</span> (exist == NULL) {
		fd_cb-&gt;group = group;
		FDRETAIN(fd_cb);		<span class="enscript-comment">/* The group now has a reference */</span>
	} <span class="enscript-keyword">else</span> {
		fd_cb-&gt;hash = 0;
		error = EEXIST;
	}

	socket_unlock(fd_cb-&gt;so, 0);

<span class="enscript-reference">done</span>:
	lck_rw_done(&amp;g_flow_divert_group_lck);
	socket_lock(fd_cb-&gt;so, 0);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> flow_divert_pcb *
<span class="enscript-function-name">flow_divert_pcb_create</span>(socket_t so)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*new_pcb	= NULL;

	MALLOC_ZONE(new_pcb, <span class="enscript-type">struct</span> flow_divert_pcb *, <span class="enscript-keyword">sizeof</span>(*new_pcb), M_FLOW_DIVERT_PCB, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_pcb == NULL) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to allocate a pcb&quot;</span>);
		<span class="enscript-keyword">return</span> NULL;
	}

	memset(new_pcb, 0, <span class="enscript-keyword">sizeof</span>(*new_pcb));

	lck_mtx_init(&amp;new_pcb-&gt;mtx, flow_divert_mtx_grp, flow_divert_mtx_attr);
	new_pcb-&gt;so = so;
	new_pcb-&gt;log_level = nil_pcb.log_level;

	FDRETAIN(new_pcb);	<span class="enscript-comment">/* Represents the socket's reference */</span>

	<span class="enscript-keyword">return</span> new_pcb;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_pcb_destroy</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Destroying, app tx %u, app rx %u, tunnel tx %u, tunnel rx %u&quot;</span>,
			fd_cb-&gt;bytes_written_by_app, fd_cb-&gt;bytes_read_by_app, fd_cb-&gt;bytes_sent, fd_cb-&gt;bytes_received);

	<span class="enscript-keyword">if</span> (fd_cb-&gt;local_address != NULL) {
		FREE(fd_cb-&gt;local_address, M_SONAME);
	}
	<span class="enscript-keyword">if</span> (fd_cb-&gt;remote_address != NULL) {
		FREE(fd_cb-&gt;remote_address, M_SONAME);
	}
	<span class="enscript-keyword">if</span> (fd_cb-&gt;connect_token != NULL) {
		mbuf_freem(fd_cb-&gt;connect_token);
	}
	FREE_ZONE(fd_cb, <span class="enscript-keyword">sizeof</span>(*fd_cb), M_FLOW_DIVERT_PCB);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_pcb_remove</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-keyword">if</span> (fd_cb-&gt;group != NULL) {
		<span class="enscript-type">struct</span> flow_divert_group *group = fd_cb-&gt;group;
		lck_rw_lock_exclusive(&amp;group-&gt;lck);
		FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Removing from group %d, ref count = %d&quot;</span>, group-&gt;ctl_unit, fd_cb-&gt;ref_count);
		RB_REMOVE(fd_pcb_tree, &amp;group-&gt;pcb_tree, fd_cb);
		fd_cb-&gt;group = NULL;
		FDRELEASE(fd_cb);				<span class="enscript-comment">/* Release the group's reference */</span>
		lck_rw_done(&amp;group-&gt;lck);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_init</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, uint8_t packet_type, mbuf_t *packet)
{
	<span class="enscript-type">struct</span> flow_divert_packet_header	hdr;
	<span class="enscript-type">int</span>					error		= 0;

	error = mbuf_gethdr(MBUF_DONTWAIT, MBUF_TYPE_HEADER, packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to allocate the header mbuf: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}

	hdr.packet_type = packet_type;
	hdr.conn_id = htonl(fd_cb-&gt;hash);

	<span class="enscript-comment">/* Lay down the header */</span>
	error = mbuf_copyback(*packet, 0, <span class="enscript-keyword">sizeof</span>(hdr), &amp;hdr, MBUF_DONTWAIT);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;mbuf_copyback(hdr) failed: %d&quot;</span>, error);
		mbuf_freem(*packet);
		*packet = NULL;
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_append_tlv</span>(mbuf_t packet, uint8_t type, uint32_t length, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *value)
{
	uint32_t	net_length	= htonl(length);
	<span class="enscript-type">int</span>			error		= 0;

	error = mbuf_copyback(packet, mbuf_pkthdr_len(packet), <span class="enscript-keyword">sizeof</span>(type), &amp;type, MBUF_DONTWAIT);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to append the type (%d)&quot;</span>, type);
		<span class="enscript-keyword">return</span> error;
	}

	error = mbuf_copyback(packet, mbuf_pkthdr_len(packet), <span class="enscript-keyword">sizeof</span>(net_length), &amp;net_length, MBUF_DONTWAIT);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to append the length (%lu)&quot;</span>, length);
		<span class="enscript-keyword">return</span> error;
	}

	error = mbuf_copyback(packet, mbuf_pkthdr_len(packet), length, value, MBUF_DONTWAIT);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to append the value&quot;</span>);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_find_tlv</span>(mbuf_t packet, <span class="enscript-type">int</span> offset, uint8_t type, <span class="enscript-type">int</span> *err, <span class="enscript-type">int</span> next)
{
	size_t		cursor			= offset;
	<span class="enscript-type">int</span>			error			= 0;
	uint32_t	curr_length;
	uint8_t		curr_type;

	*err = 0;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (!next) {
			error = mbuf_copydata(packet, cursor, <span class="enscript-keyword">sizeof</span>(curr_type), &amp;curr_type);
			<span class="enscript-keyword">if</span> (error) {
				*err = ENOENT;
				<span class="enscript-keyword">return</span> -1;
			}
		} <span class="enscript-keyword">else</span> {
			next = 0;
			curr_type = FLOW_DIVERT_TLV_NIL;
		}

		<span class="enscript-keyword">if</span> (curr_type != type) {
			cursor += <span class="enscript-keyword">sizeof</span>(curr_type);
			error = mbuf_copydata(packet, cursor, <span class="enscript-keyword">sizeof</span>(curr_length), &amp;curr_length);
			<span class="enscript-keyword">if</span> (error) {
				*err = error;
				<span class="enscript-keyword">return</span> -1;
			}

			cursor += (<span class="enscript-keyword">sizeof</span>(curr_length) + ntohl(curr_length));
		}
	} <span class="enscript-keyword">while</span> (curr_type != type);

	<span class="enscript-keyword">return</span> cursor;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_get_tlv</span>(mbuf_t packet, <span class="enscript-type">int</span> offset, uint8_t type, size_t buff_len, <span class="enscript-type">void</span> *buff, uint32_t *val_size)
{
	<span class="enscript-type">int</span>			error		= 0;
	uint32_t	length;
	<span class="enscript-type">int</span>			tlv_offset;

	tlv_offset = flow_divert_packet_find_tlv(packet, offset, type, &amp;error, 0);
	<span class="enscript-keyword">if</span> (tlv_offset &lt; 0) {
		<span class="enscript-keyword">return</span> error;
	}

	error = mbuf_copydata(packet, tlv_offset + <span class="enscript-keyword">sizeof</span>(type), <span class="enscript-keyword">sizeof</span>(length), &amp;length);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	length = ntohl(length);

	<span class="enscript-keyword">if</span> (val_size != NULL) {
		*val_size = length;
	}

	<span class="enscript-keyword">if</span> (buff != NULL &amp;&amp; buff_len &gt; 0) {
		size_t to_copy = (length &lt; buff_len) ? length : buff_len;
		error = mbuf_copydata(packet, tlv_offset + <span class="enscript-keyword">sizeof</span>(type) + <span class="enscript-keyword">sizeof</span>(length), to_copy, buff);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> error;
		}
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_compute_hmac</span>(mbuf_t packet, <span class="enscript-type">struct</span> flow_divert_group *group, uint8_t *hmac)
{
	mbuf_t	curr_mbuf	= packet;

	<span class="enscript-keyword">if</span> (g_crypto_funcs == NULL || group-&gt;token_key == NULL) {
		<span class="enscript-keyword">return</span> ENOPROTOOPT;
	}

	cchmac_di_decl(g_crypto_funcs-&gt;ccsha1_di, hmac_ctx);
	g_crypto_funcs-&gt;cchmac_init_fn(g_crypto_funcs-&gt;ccsha1_di, hmac_ctx, group-&gt;token_key_size, group-&gt;token_key);

	<span class="enscript-keyword">while</span> (curr_mbuf != NULL) {
		g_crypto_funcs-&gt;cchmac_update_fn(g_crypto_funcs-&gt;ccsha1_di, hmac_ctx, mbuf_len(curr_mbuf), mbuf_data(curr_mbuf));
		curr_mbuf = mbuf_next(curr_mbuf);
	}

	g_crypto_funcs-&gt;cchmac_final_fn(g_crypto_funcs-&gt;ccsha1_di, hmac_ctx, hmac);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_packet_verify_hmac</span>(mbuf_t packet, uint32_t ctl_unit)
{
	<span class="enscript-type">int</span>							error = 0;
	<span class="enscript-type">struct</span> flow_divert_group	*group = NULL;
	<span class="enscript-type">int</span>							hmac_offset;
	uint8_t						packet_hmac[SHA_DIGEST_LENGTH];
	uint8_t						computed_hmac[SHA_DIGEST_LENGTH];
	mbuf_t						tail;

	lck_rw_lock_shared(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (g_flow_divert_groups != NULL &amp;&amp; g_active_group_count &gt; 0) {
		group = g_flow_divert_groups[ctl_unit];
	}

	<span class="enscript-keyword">if</span> (group == NULL) {
		lck_rw_done(&amp;g_flow_divert_group_lck);
		<span class="enscript-keyword">return</span> ENOPROTOOPT;
	}

	lck_rw_lock_shared(&amp;group-&gt;lck);

	<span class="enscript-keyword">if</span> (group-&gt;token_key == NULL) {
		error = ENOPROTOOPT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	hmac_offset = flow_divert_packet_find_tlv(packet, 0, FLOW_DIVERT_TLV_HMAC, &amp;error, 0);
	<span class="enscript-keyword">if</span> (hmac_offset &lt; 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_get_tlv(packet, hmac_offset, FLOW_DIVERT_TLV_HMAC, <span class="enscript-keyword">sizeof</span>(packet_hmac), packet_hmac, NULL);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Chop off the HMAC TLV */</span>
	error = mbuf_split(packet, hmac_offset, MBUF_WAITOK, &amp;tail);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	mbuf_free(tail);

	error = flow_divert_packet_compute_hmac(packet, group, computed_hmac);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (memcmp(packet_hmac, computed_hmac, <span class="enscript-keyword">sizeof</span>(packet_hmac))) {
		FDLOG0(LOG_WARNING, &amp;nil_pcb, <span class="enscript-string">&quot;HMAC in token does not match computed HMAC&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	lck_rw_done(&amp;group-&gt;lck);
	lck_rw_done(&amp;g_flow_divert_group_lck);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_add_data_statistics</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, <span class="enscript-type">int</span> data_len, Boolean send)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	Boolean cell = FALSE;
	Boolean wifi = FALSE;
	Boolean wired = FALSE;
	
	inp = sotoinpcb(fd_cb-&gt;so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span>;
	}

	ifp = inp-&gt;inp_last_outifp;
	<span class="enscript-keyword">if</span> (ifp != NULL) {
		cell = IFNET_IS_CELLULAR(ifp);
		wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
		wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));
	}
	
	<span class="enscript-keyword">if</span> (send) {
		INP_ADD_STAT(inp, cell, wifi, wired, txpackets, 1);
		INP_ADD_STAT(inp, cell, wifi, wired, txbytes, data_len);
	} <span class="enscript-keyword">else</span> {
		INP_ADD_STAT(inp, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(inp, cell, wifi, wired, rxbytes, data_len);
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_check_no_cellular</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;

	inp = sotoinpcb(fd_cb-&gt;so);
	<span class="enscript-keyword">if</span> (inp &amp;&amp; INP_NO_CELLULAR(inp) &amp;&amp; inp-&gt;inp_last_outifp &amp;&amp;
	    IFNET_IS_CELLULAR(inp-&gt;inp_last_outifp))
		<span class="enscript-keyword">return</span> EHOSTUNREACH;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_check_no_expensive</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;

	inp = sotoinpcb(fd_cb-&gt;so);
	<span class="enscript-keyword">if</span> (inp &amp;&amp; INP_NO_EXPENSIVE(inp) &amp;&amp; inp-&gt;inp_last_outifp &amp;&amp;
	    IFNET_IS_EXPENSIVE(inp-&gt;inp_last_outifp))
		<span class="enscript-keyword">return</span> EHOSTUNREACH;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_update_closed_state</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, <span class="enscript-type">int</span> how, Boolean tunnel)
{
	<span class="enscript-keyword">if</span> (how != SHUT_RD) {
		fd_cb-&gt;flags |= FLOW_DIVERT_WRITE_CLOSED;
		<span class="enscript-keyword">if</span> (tunnel || !(fd_cb-&gt;flags &amp; FLOW_DIVERT_CONNECT_STARTED)) {
			fd_cb-&gt;flags |= FLOW_DIVERT_TUNNEL_WR_CLOSED;
			<span class="enscript-comment">/* If the tunnel is not accepting writes any more, then flush the send buffer */</span>
			sbflush(&amp;fd_cb-&gt;so-&gt;so_snd);
		}
	}
	<span class="enscript-keyword">if</span> (how != SHUT_WR) {
		fd_cb-&gt;flags |= FLOW_DIVERT_READ_CLOSED;
		<span class="enscript-keyword">if</span> (tunnel || !(fd_cb-&gt;flags &amp; FLOW_DIVERT_CONNECT_STARTED)) {
			fd_cb-&gt;flags |= FLOW_DIVERT_TUNNEL_RD_CLOSED;
		}
	}
}

<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">trie_node_alloc</span>(<span class="enscript-type">struct</span> flow_divert_trie *trie)
{
	<span class="enscript-keyword">if</span> (trie-&gt;nodes_free_next &lt; trie-&gt;nodes_count) {
		uint16_t node_idx = trie-&gt;nodes_free_next++;
		TRIE_NODE(trie, node_idx).child_map = NULL_TRIE_IDX;
		<span class="enscript-keyword">return</span> node_idx;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
	}
}

<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">trie_child_map_alloc</span>(<span class="enscript-type">struct</span> flow_divert_trie *trie)
{
	<span class="enscript-keyword">if</span> (trie-&gt;child_maps_free_next &lt; trie-&gt;child_maps_count) {
		<span class="enscript-keyword">return</span> trie-&gt;child_maps_free_next++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
	}
}

<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">trie_bytes_move</span>(<span class="enscript-type">struct</span> flow_divert_trie *trie, uint16_t bytes_idx, size_t bytes_size)
{
	uint16_t start = trie-&gt;bytes_free_next;
	<span class="enscript-keyword">if</span> (start + bytes_size &lt;= trie-&gt;bytes_count) {
		<span class="enscript-keyword">if</span> (start != bytes_idx) {
			memmove(&amp;TRIE_BYTE(trie, start), &amp;TRIE_BYTE(trie, bytes_idx), bytes_size);
		}
		trie-&gt;bytes_free_next += bytes_size;
		<span class="enscript-keyword">return</span> start;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
	}
}

<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">flow_divert_trie_insert</span>(<span class="enscript-type">struct</span> flow_divert_trie *trie, uint16_t string_start, size_t string_len)
{
	uint16_t current = trie-&gt;root;
	uint16_t child = trie-&gt;root;
	uint16_t string_end = string_start + string_len;
	uint16_t string_idx = string_start;
	uint16_t string_remainder = string_len;

	<span class="enscript-keyword">while</span> (child != NULL_TRIE_IDX) {
		uint16_t parent = current;
		uint16_t node_idx;
		uint16_t current_end;

		current = child;
		child = NULL_TRIE_IDX;

		current_end = TRIE_NODE(trie, current).start + TRIE_NODE(trie, current).length;

		<span class="enscript-keyword">for</span> (node_idx = TRIE_NODE(trie, current).start;
		     node_idx &lt; current_end &amp;&amp;
		     string_idx &lt; string_end &amp;&amp;
		     TRIE_BYTE(trie, node_idx) == TRIE_BYTE(trie, string_idx);
		     node_idx++, string_idx++);

		string_remainder = string_end - string_idx;

		<span class="enscript-keyword">if</span> (node_idx &lt; (TRIE_NODE(trie, current).start + TRIE_NODE(trie, current).length)) {
			<span class="enscript-comment">/*
			 * We did not reach the end of the current node's string.
			 * We need to split the current node into two:
			 *   1. A new node that contains the prefix of the node that matches
			 *      the prefix of the string being inserted.
			 *   2. The current node modified to point to the remainder
			 *      of the current node's string.
			 */</span>
			uint16_t prefix = trie_node_alloc(trie);
			<span class="enscript-keyword">if</span> (prefix == NULL_TRIE_IDX) {
				FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Ran out of trie nodes while splitting an existing node&quot;</span>);
				<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
			}

			<span class="enscript-comment">/*
			 * Prefix points to the portion of the current nodes's string that has matched
			 * the input string thus far.
			 */</span>
			TRIE_NODE(trie, prefix).start = TRIE_NODE(trie, current).start;
			TRIE_NODE(trie, prefix).length = (node_idx - TRIE_NODE(trie, current).start);

			<span class="enscript-comment">/*
			 * Prefix has the current node as the child corresponding to the first byte
			 * after the split.
			 */</span>
			TRIE_NODE(trie, prefix).child_map = trie_child_map_alloc(trie);
			<span class="enscript-keyword">if</span> (TRIE_NODE(trie, prefix).child_map == NULL_TRIE_IDX) {
				FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Ran out of child maps while splitting an existing node&quot;</span>);
				<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
			}
			TRIE_CHILD(trie, prefix, TRIE_BYTE(trie, node_idx)) = current;

			<span class="enscript-comment">/* Parent has the prefix as the child correspoding to the first byte in the prefix */</span>
			TRIE_CHILD(trie, parent, TRIE_BYTE(trie, TRIE_NODE(trie, prefix).start)) = prefix;

			<span class="enscript-comment">/* Current node is adjusted to point to the remainder */</span>
			TRIE_NODE(trie, current).start = node_idx;
			TRIE_NODE(trie, current).length -= TRIE_NODE(trie, prefix).length;

			<span class="enscript-comment">/* We want to insert the new leaf (if any) as a child of the prefix */</span>
			current = prefix;
		}

		<span class="enscript-keyword">if</span> (string_remainder &gt; 0) {
			<span class="enscript-comment">/*
			 * We still have bytes in the string that have not been matched yet.
			 * If the current node has children, iterate to the child corresponding
			 * to the next byte in the string.
			 */</span>
			<span class="enscript-keyword">if</span> (TRIE_NODE(trie, current).child_map != NULL_TRIE_IDX) {
				child = TRIE_CHILD(trie, current, TRIE_BYTE(trie, string_idx));
			}
		}
	} <span class="enscript-comment">/* while (child != NULL_TRIE_IDX) */</span>

	<span class="enscript-keyword">if</span> (string_remainder &gt; 0) {
		<span class="enscript-comment">/* Add a new leaf containing the remainder of the string */</span>
		uint16_t leaf = trie_node_alloc(trie);
		<span class="enscript-keyword">if</span> (leaf == NULL_TRIE_IDX) {
			FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Ran out of trie nodes while inserting a new leaf&quot;</span>);
			<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
		}

		TRIE_NODE(trie, leaf).start = trie_bytes_move(trie, string_idx, string_remainder);
		<span class="enscript-keyword">if</span> (TRIE_NODE(trie, leaf).start == NULL_TRIE_IDX) {
			FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Ran out of bytes while inserting a new leaf&quot;</span>);
			<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
		}
		TRIE_NODE(trie, leaf).length = string_remainder;

		<span class="enscript-comment">/* Set the new leaf as the child of the current node */</span>
		<span class="enscript-keyword">if</span> (TRIE_NODE(trie, current).child_map == NULL_TRIE_IDX) {
			TRIE_NODE(trie, current).child_map = trie_child_map_alloc(trie);
			<span class="enscript-keyword">if</span> (TRIE_NODE(trie, current).child_map == NULL_TRIE_IDX) {
				FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Ran out of child maps while inserting a new leaf&quot;</span>);
				<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
			}
		}
		TRIE_CHILD(trie, current, TRIE_BYTE(trie, TRIE_NODE(trie, leaf).start)) = leaf;
		current = leaf;
	} <span class="enscript-comment">/* else duplicate or this string is a prefix of one of the existing strings */</span>

	<span class="enscript-keyword">return</span> current;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_WEBCLIP_ID_PREFIX</span>	<span class="enscript-string">&quot;com.apple.webapp&quot;</span>
<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">flow_divert_trie_search</span>(<span class="enscript-type">struct</span> flow_divert_trie *trie, uint8_t *string_bytes)
{
	uint16_t current = trie-&gt;root;
	uint16_t string_idx = 0;

	<span class="enscript-keyword">while</span> (current != NULL_TRIE_IDX) {
		uint16_t next = NULL_TRIE_IDX;
		uint16_t node_end = TRIE_NODE(trie, current).start + TRIE_NODE(trie, current).length;
		uint16_t node_idx;

		<span class="enscript-keyword">for</span> (node_idx = TRIE_NODE(trie, current).start;
		     node_idx &lt; node_end &amp;&amp; string_bytes[string_idx] != <span class="enscript-string">'\0'</span> &amp;&amp; string_bytes[string_idx] == TRIE_BYTE(trie, node_idx);
		     node_idx++, string_idx++);

		<span class="enscript-keyword">if</span> (node_idx == node_end) {
			<span class="enscript-keyword">if</span> (string_bytes[string_idx] == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-keyword">return</span> current; <span class="enscript-comment">/* Got an exact match */</span>
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (string_idx == strlen(APPLE_WEBCLIP_ID_PREFIX) &amp;&amp;
				   0 == strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)string_bytes, APPLE_WEBCLIP_ID_PREFIX, string_idx)) {
				string_bytes[string_idx] = <span class="enscript-string">'\0'</span>; 
				<span class="enscript-keyword">return</span> current; <span class="enscript-comment">/* Got an apple webclip id prefix match */</span>
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TRIE_NODE(trie, current).child_map != NULL_TRIE_IDX) {
				next = TRIE_CHILD(trie, current, string_bytes[string_idx]);
			}
		}
		current = next;
	}

	<span class="enscript-keyword">return</span> NULL_TRIE_IDX;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_get_src_proc</span>(<span class="enscript-type">struct</span> socket *so, proc_t *proc, boolean_t match_delegate)
{
	<span class="enscript-type">int</span> release = 0;

	<span class="enscript-keyword">if</span> (!match_delegate &amp;&amp; 
	    (so-&gt;so_flags &amp; SOF_DELEGATED) &amp;&amp;
	    (*proc == PROC_NULL || (*proc)-&gt;p_pid != so-&gt;e_pid))
	{
		*proc = proc_find(so-&gt;e_pid);
		release = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*proc == PROC_NULL) {
		*proc = current_proc();
	}

	<span class="enscript-keyword">if</span> (*proc != PROC_NULL) {
		<span class="enscript-keyword">if</span> ((*proc)-&gt;p_pid == 0) {
			<span class="enscript-keyword">if</span> (release) {
				proc_rele(*proc);
			}
			release = 0;
			*proc = PROC_NULL;
		}
	}

	<span class="enscript-keyword">return</span> release;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_packet</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, Boolean enqueue)
{
	<span class="enscript-type">int</span>		error;

	<span class="enscript-keyword">if</span> (fd_cb-&gt;group == NULL) {
		fd_cb-&gt;so-&gt;so_error = ECONNABORTED;
		flow_divert_disconnect_socket(fd_cb-&gt;so);
		<span class="enscript-keyword">return</span> ECONNABORTED;
	}

	lck_rw_lock_shared(&amp;fd_cb-&gt;group-&gt;lck);

	<span class="enscript-keyword">if</span> (MBUFQ_EMPTY(&amp;fd_cb-&gt;group-&gt;send_queue)) {
		error = ctl_enqueuembuf(g_flow_divert_kctl_ref, fd_cb-&gt;group-&gt;ctl_unit, packet, CTL_DATA_EOR);
	} <span class="enscript-keyword">else</span> {
		error = ENOBUFS;
	}

	<span class="enscript-keyword">if</span> (error == ENOBUFS) {
		<span class="enscript-keyword">if</span> (enqueue) {
			<span class="enscript-keyword">if</span> (!lck_rw_lock_shared_to_exclusive(&amp;fd_cb-&gt;group-&gt;lck)) {
				lck_rw_lock_exclusive(&amp;fd_cb-&gt;group-&gt;lck);
			}
			MBUFQ_ENQUEUE(&amp;fd_cb-&gt;group-&gt;send_queue, packet);
			error = 0;
		}
		OSTestAndSet(GROUP_BIT_CTL_ENQUEUE_BLOCKED, &amp;fd_cb-&gt;group-&gt;atomic_bits);
	}

	lck_rw_done(&amp;fd_cb-&gt;group-&gt;lck);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_connect</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, <span class="enscript-type">struct</span> sockaddr *to, mbuf_t connect_packet)
{
	<span class="enscript-type">int</span>				error			= 0;
	<span class="enscript-type">int</span>				flow_type		= 0;

	error = flow_divert_packet_append_tlv(connect_packet,
	                                      FLOW_DIVERT_TLV_TRAFFIC_CLASS,
	                                      <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;so-&gt;so_traffic_class),
	                                      &amp;fd_cb-&gt;so-&gt;so_traffic_class);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_STREAM) {
		flow_type = FLOW_DIVERT_FLOW_TYPE_TCP;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_DGRAM) {
		flow_type = FLOW_DIVERT_FLOW_TYPE_UDP;
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	error = flow_divert_packet_append_tlv(connect_packet,
	                                      FLOW_DIVERT_TLV_FLOW_TYPE,
	                                      <span class="enscript-keyword">sizeof</span>(flow_type),
	                                      &amp;flow_type);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;so-&gt;so_flags &amp; SOF_DELEGATED) {
		error = flow_divert_packet_append_tlv(connect_packet,
		                                      FLOW_DIVERT_TLV_PID,
		                                      <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;so-&gt;e_pid),
		                                      &amp;fd_cb-&gt;so-&gt;e_pid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		error = flow_divert_packet_append_tlv(connect_packet,
		                                      FLOW_DIVERT_TLV_UUID,
		                                      <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;so-&gt;e_uuid),
		                                      &amp;fd_cb-&gt;so-&gt;e_uuid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	} <span class="enscript-keyword">else</span> {
		error = flow_divert_packet_append_tlv(connect_packet,
		                                      FLOW_DIVERT_TLV_PID,
		                                      <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;so-&gt;e_pid),
		                                      &amp;fd_cb-&gt;so-&gt;last_pid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		error = flow_divert_packet_append_tlv(connect_packet,
		                                      FLOW_DIVERT_TLV_UUID,
		                                      <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;so-&gt;e_uuid),
		                                      &amp;fd_cb-&gt;so-&gt;last_uuid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;connect_token != NULL) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> token_len = m_length(fd_cb-&gt;connect_token);
		mbuf_concatenate(connect_packet, fd_cb-&gt;connect_token);
		mbuf_pkthdr_adjustlen(connect_packet, token_len);
		fd_cb-&gt;connect_token = NULL;
	} <span class="enscript-keyword">else</span> {
		uint32_t ctl_unit = htonl(fd_cb-&gt;control_group_unit);

		error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_CTL_UNIT, <span class="enscript-keyword">sizeof</span>(ctl_unit), &amp;ctl_unit);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		error = flow_divert_append_target_endpoint_tlv(connect_packet, to);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;local_address != NULL) {
		<span class="enscript-comment">/* socket is bound. */</span>
                error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_LOCAL_ADDR,
							<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage), fd_cb-&gt;local_address);
                <span class="enscript-keyword">if</span> (error) {
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                }
        }

	error = flow_divert_send_packet(fd_cb, connect_packet, TRUE);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_connect_result</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-type">int</span>		error	 		= 0;
	mbuf_t	packet			= NULL;
	<span class="enscript-type">int</span>		rbuff_space		= 0;

	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_CONNECT_RESULT, &amp;packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to create a connect result packet: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	rbuff_space = fd_cb-&gt;so-&gt;so_rcv.sb_hiwat;
	<span class="enscript-keyword">if</span> (rbuff_space &lt; 0) {
		rbuff_space = 0;
	}
	rbuff_space = htonl(rbuff_space);
	error = flow_divert_packet_append_tlv(packet,
	                                      FLOW_DIVERT_TLV_SPACE_AVAILABLE,
	                                      <span class="enscript-keyword">sizeof</span>(rbuff_space),
	                                      &amp;rbuff_space);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_send_packet(fd_cb, packet, TRUE);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; packet != NULL) {
		mbuf_freem(packet);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_close</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span>		error	= 0;
	mbuf_t	packet	= NULL;
	uint32_t	zero	= 0;

	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_CLOSE, &amp;packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to create a close packet: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_append_tlv(packet, FLOW_DIVERT_TLV_ERROR_CODE, <span class="enscript-keyword">sizeof</span>(zero), &amp;zero);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to add the error code TLV: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	how = htonl(how);
	error = flow_divert_packet_append_tlv(packet, FLOW_DIVERT_TLV_HOW, <span class="enscript-keyword">sizeof</span>(how), &amp;how);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to add the how flag: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_send_packet(fd_cb, packet, TRUE);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; packet != NULL) {
		mbuf_free(packet);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_tunnel_how_closed</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-keyword">if</span> ((fd_cb-&gt;flags &amp; (FLOW_DIVERT_TUNNEL_RD_CLOSED|FLOW_DIVERT_TUNNEL_WR_CLOSED)) == 
			(FLOW_DIVERT_TUNNEL_RD_CLOSED|FLOW_DIVERT_TUNNEL_WR_CLOSED))
	{
		<span class="enscript-keyword">return</span> SHUT_RDWR;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fd_cb-&gt;flags &amp; FLOW_DIVERT_TUNNEL_RD_CLOSED) {
		<span class="enscript-keyword">return</span> SHUT_RD;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fd_cb-&gt;flags &amp; FLOW_DIVERT_TUNNEL_WR_CLOSED) {
		<span class="enscript-keyword">return</span> SHUT_WR;
	}

	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">/*
 * Determine what close messages if any need to be sent to the tunnel. Returns TRUE if the tunnel is closed for both reads and
 * writes. Returns FALSE otherwise.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_send_close_if_needed</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-type">int</span>		how		= -1;

	<span class="enscript-comment">/* Do not send any close messages if there is still data in the send buffer */</span>
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so-&gt;so_snd.sb_cc == 0) {
		<span class="enscript-keyword">if</span> ((fd_cb-&gt;flags &amp; (FLOW_DIVERT_READ_CLOSED|FLOW_DIVERT_TUNNEL_RD_CLOSED)) == FLOW_DIVERT_READ_CLOSED) {
			<span class="enscript-comment">/* Socket closed reads, but tunnel did not. Tell tunnel to close reads */</span>
			how = SHUT_RD;
		}
		<span class="enscript-keyword">if</span> ((fd_cb-&gt;flags &amp; (FLOW_DIVERT_WRITE_CLOSED|FLOW_DIVERT_TUNNEL_WR_CLOSED)) == FLOW_DIVERT_WRITE_CLOSED) {
			<span class="enscript-comment">/* Socket closed writes, but tunnel did not. Tell tunnel to close writes */</span>
			<span class="enscript-keyword">if</span> (how == SHUT_RD) {
				how = SHUT_RDWR;
			} <span class="enscript-keyword">else</span> {
				how = SHUT_WR;
			}
		}
	}

	<span class="enscript-keyword">if</span> (how != -1) {
		FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;sending close, how = %d&quot;</span>, how);
		<span class="enscript-keyword">if</span> (flow_divert_send_close(fd_cb, how) != ENOBUFS) {
			<span class="enscript-comment">/* Successfully sent the close packet. Record the ways in which the tunnel has been closed */</span>
			<span class="enscript-keyword">if</span> (how != SHUT_RD) {
				fd_cb-&gt;flags |= FLOW_DIVERT_TUNNEL_WR_CLOSED;
			}
			<span class="enscript-keyword">if</span> (how != SHUT_WR) {
				fd_cb-&gt;flags |= FLOW_DIVERT_TUNNEL_RD_CLOSED;
			}
		}
	}

	<span class="enscript-keyword">if</span> (flow_divert_tunnel_how_closed(fd_cb) == SHUT_RDWR) {
		flow_divert_disconnect_socket(fd_cb-&gt;so);
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_send_data_packet</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t data, size_t data_len, <span class="enscript-type">struct</span> sockaddr *toaddr, Boolean force)
{
	mbuf_t	packet;
	mbuf_t	last;
	<span class="enscript-type">int</span>		error	= 0;

	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_DATA, &amp;packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;flow_divert_packet_init failed: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">if</span> (toaddr != NULL) {
		error = flow_divert_append_target_endpoint_tlv(packet, toaddr);
		<span class="enscript-keyword">if</span> (error) {
			FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;flow_divert_append_target_endpoint_tlv() failed: %d&quot;</span>, error);
			<span class="enscript-keyword">return</span> error;
		}
	}

	last = m_last(packet);
	mbuf_setnext(last, data);
	mbuf_pkthdr_adjustlen(packet, data_len);
	error = flow_divert_send_packet(fd_cb, packet, force);

	<span class="enscript-keyword">if</span> (error) {
		mbuf_setnext(last, NULL);
		mbuf_freem(packet);
	} <span class="enscript-keyword">else</span> {
		fd_cb-&gt;bytes_sent += data_len;
		flow_divert_add_data_statistics(fd_cb, data_len, TRUE);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_send_buffered_data</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, Boolean force)
{
	size_t	to_send;
	size_t	sent	= 0;
	<span class="enscript-type">int</span>		error	= 0;
	mbuf_t	buffer;

	to_send = fd_cb-&gt;so-&gt;so_snd.sb_cc;
	buffer = fd_cb-&gt;so-&gt;so_snd.sb_mb;

	<span class="enscript-keyword">if</span> (buffer == NULL &amp;&amp; to_send &gt; 0) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;Send buffer is NULL, but size is supposed to be %lu&quot;</span>, to_send);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Ignore the send window if force is enabled */</span>
	<span class="enscript-keyword">if</span> (!force &amp;&amp; (to_send &gt; fd_cb-&gt;send_window)) {
		to_send = fd_cb-&gt;send_window;
	}

	<span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_STREAM) {
		<span class="enscript-keyword">while</span> (sent &lt; to_send) {
			mbuf_t	data;
			size_t	data_len;

			data_len = to_send - sent;
			<span class="enscript-keyword">if</span> (data_len &gt; FLOW_DIVERT_CHUNK_SIZE) {
				data_len = FLOW_DIVERT_CHUNK_SIZE;
			}

			error = mbuf_copym(buffer, sent, data_len, MBUF_DONTWAIT, &amp;data);
			<span class="enscript-keyword">if</span> (error) {
				FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;mbuf_copym failed: %d&quot;</span>, error);
				<span class="enscript-keyword">break</span>;
			}

			error = flow_divert_send_data_packet(fd_cb, data, data_len, NULL, force);
			<span class="enscript-keyword">if</span> (error) {
				mbuf_freem(data);
				<span class="enscript-keyword">break</span>;
			}

			sent += data_len;
		}
		sbdrop(&amp;fd_cb-&gt;so-&gt;so_snd, sent);
		sowwakeup(fd_cb-&gt;so);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_DGRAM) {
		mbuf_t data;
		mbuf_t m;
		size_t data_len;

		<span class="enscript-keyword">while</span>(buffer) {
			<span class="enscript-type">struct</span> sockaddr *toaddr = flow_divert_get_buffered_target_address(buffer);

			m = buffer;
			<span class="enscript-keyword">if</span> (toaddr != NULL) {
				<span class="enscript-comment">/* look for data in the chain */</span>
				<span class="enscript-keyword">do</span> {
					m = m-&gt;m_next;
					<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; m-&gt;m_type == MT_DATA) {
						<span class="enscript-keyword">break</span>;
					}
				} <span class="enscript-keyword">while</span>(m);
				<span class="enscript-keyword">if</span> (m == NULL) {
					<span class="enscript-comment">/* unexpected */</span>
					FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to find type MT_DATA in the mbuf chain.&quot;</span>);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">move_on</span>;
				}
			}
			data_len = mbuf_pkthdr_len(m);
			FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;mbuf_copym() data_len = %u&quot;</span>, data_len);
			error = mbuf_copym(m, 0, data_len, MBUF_DONTWAIT, &amp;data);
			<span class="enscript-keyword">if</span> (error) {
				FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;mbuf_copym failed: %d&quot;</span>, error);
				<span class="enscript-keyword">break</span>;
			}
			error = flow_divert_send_data_packet(fd_cb, data, data_len, toaddr, force);
			<span class="enscript-keyword">if</span> (error) {
				mbuf_freem(data);
				<span class="enscript-keyword">break</span>;
			}
			sent += data_len;
<span class="enscript-reference">move_on</span>:
			buffer = buffer-&gt;m_nextpkt;
			(<span class="enscript-type">void</span>) sbdroprecord(&amp;(fd_cb-&gt;so-&gt;so_snd));
		}
	}

	<span class="enscript-keyword">if</span> (sent &gt; 0) {
		FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;sent %lu bytes of buffered data&quot;</span>, sent);
		<span class="enscript-keyword">if</span> (fd_cb-&gt;send_window &gt;= sent) {
			fd_cb-&gt;send_window -= sent;
		} <span class="enscript-keyword">else</span> {
			fd_cb-&gt;send_window = 0;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_app_data</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t data, <span class="enscript-type">struct</span> sockaddr *toaddr)
{
	size_t	to_send		= mbuf_pkthdr_len(data);
	<span class="enscript-type">int</span>	error		= 0;

	<span class="enscript-keyword">if</span> (to_send &gt; fd_cb-&gt;send_window) {
		to_send = fd_cb-&gt;send_window;
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;so-&gt;so_snd.sb_cc &gt; 0) {
		to_send = 0;	<span class="enscript-comment">/* If the send buffer is non-empty, then we can't send anything */</span>
	}

	<span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_STREAM) {
		size_t	sent		= 0;
		mbuf_t	remaining_data	= data;
		mbuf_t	pkt_data	= NULL;
		<span class="enscript-keyword">while</span> (sent &lt; to_send) {
			size_t	pkt_data_len;

			pkt_data = remaining_data;

			<span class="enscript-keyword">if</span> ((to_send - sent) &gt; FLOW_DIVERT_CHUNK_SIZE) {
				pkt_data_len = FLOW_DIVERT_CHUNK_SIZE;
			} <span class="enscript-keyword">else</span> {
				pkt_data_len = to_send - sent;
			}

			<span class="enscript-keyword">if</span> (pkt_data_len &lt; mbuf_pkthdr_len(pkt_data)) {
				error = mbuf_split(pkt_data, pkt_data_len, MBUF_DONTWAIT, &amp;remaining_data);
				<span class="enscript-keyword">if</span> (error) {
					FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;mbuf_split failed: %d&quot;</span>, error);
					pkt_data = NULL;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">else</span> {
				remaining_data = NULL;
			}

			error = flow_divert_send_data_packet(fd_cb, pkt_data, pkt_data_len, NULL, FALSE);

			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">break</span>;
			}

			pkt_data = NULL;
			sent += pkt_data_len;
		}

		fd_cb-&gt;send_window -= sent;

		error = 0;

		<span class="enscript-keyword">if</span> (pkt_data != NULL) {
			<span class="enscript-keyword">if</span> (sbspace(&amp;fd_cb-&gt;so-&gt;so_snd) &gt; 0) {
				<span class="enscript-keyword">if</span> (!sbappendstream(&amp;fd_cb-&gt;so-&gt;so_snd, pkt_data)) {
					FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;sbappendstream failed with pkt_data, send buffer size = %u, send_window = %u\n&quot;</span>,
							fd_cb-&gt;so-&gt;so_snd.sb_cc, fd_cb-&gt;send_window);
				}
			} <span class="enscript-keyword">else</span> {
				error = ENOBUFS;
			}
		}

		<span class="enscript-keyword">if</span> (remaining_data != NULL) {
			<span class="enscript-keyword">if</span> (sbspace(&amp;fd_cb-&gt;so-&gt;so_snd) &gt; 0) {
				<span class="enscript-keyword">if</span> (!sbappendstream(&amp;fd_cb-&gt;so-&gt;so_snd, remaining_data)) {
					FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;sbappendstream failed with remaining_data, send buffer size = %u, send_window = %u\n&quot;</span>,
							fd_cb-&gt;so-&gt;so_snd.sb_cc, fd_cb-&gt;send_window);
				}
			} <span class="enscript-keyword">else</span> {
				error = ENOBUFS;
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_DGRAM) {
		<span class="enscript-keyword">if</span> (to_send) {
			error = flow_divert_send_data_packet(fd_cb, data, to_send, toaddr, FALSE);
			<span class="enscript-keyword">if</span> (error) {
				FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;flow_divert_send_data_packet failed. send data size = %u&quot;</span>, to_send);
			} <span class="enscript-keyword">else</span> {
				fd_cb-&gt;send_window -= to_send;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* buffer it */</span>
			<span class="enscript-keyword">if</span> (sbspace(&amp;fd_cb-&gt;so-&gt;so_snd) &gt;= (<span class="enscript-type">int</span>)mbuf_pkthdr_len(data)) {
				<span class="enscript-keyword">if</span> (toaddr != NULL) {
					<span class="enscript-keyword">if</span> (!sbappendaddr(&amp;fd_cb-&gt;so-&gt;so_snd, toaddr, data, NULL, &amp;error)) {
						FDLOG(LOG_ERR, fd_cb,
							<span class="enscript-string">&quot;sbappendaddr failed. send buffer size = %u, send_window = %u, error = %d\n&quot;</span>,
							fd_cb-&gt;so-&gt;so_snd.sb_cc, fd_cb-&gt;send_window, error);
					}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (!sbappendrecord(&amp;fd_cb-&gt;so-&gt;so_snd, data)) {
						FDLOG(LOG_ERR, fd_cb,
							<span class="enscript-string">&quot;sbappendrecord failed. send buffer size = %u, send_window = %u, error = %d\n&quot;</span>,
							fd_cb-&gt;so-&gt;so_snd.sb_cc, fd_cb-&gt;send_window, error);
					}
				}
			} <span class="enscript-keyword">else</span> {
				error = ENOBUFS;
			}
		}
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_read_notification</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, uint32_t read_count)
{
	<span class="enscript-type">int</span>		error		= 0;
	mbuf_t	packet		= NULL;
	uint32_t	net_read_count	= htonl(read_count);

	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_READ_NOTIFY, &amp;packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to create a read notification packet: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_append_tlv(packet, FLOW_DIVERT_TLV_READ_COUNT, <span class="enscript-keyword">sizeof</span>(net_read_count), &amp;net_read_count);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to add the read count: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_send_packet(fd_cb, packet, TRUE);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; packet != NULL) {
		mbuf_free(packet);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_send_traffic_class_update</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, <span class="enscript-type">int</span> traffic_class)
{
	<span class="enscript-type">int</span>		error		= 0;
	mbuf_t	packet		= NULL;

	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_PROPERTIES_UPDATE, &amp;packet);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to create a properties update packet: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_append_tlv(packet, FLOW_DIVERT_TLV_TRAFFIC_CLASS, <span class="enscript-keyword">sizeof</span>(traffic_class), &amp;traffic_class);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to add the traffic class: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_send_packet(fd_cb, packet, TRUE);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; packet != NULL) {
		mbuf_free(packet);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_connect_result</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	uint32_t					connect_error;
	uint32_t					ctl_unit			= 0;
	<span class="enscript-type">int</span>							error				= 0;
	<span class="enscript-type">struct</span> flow_divert_group 	*grp				= NULL;
	<span class="enscript-type">struct</span> sockaddr_storage		local_address;
	<span class="enscript-type">int</span>							out_if_index		= 0;
	<span class="enscript-type">struct</span> sockaddr_storage		remote_address;
	uint32_t					send_window;

	memset(&amp;local_address, 0, <span class="enscript-keyword">sizeof</span>(local_address));
	memset(&amp;remote_address, 0, <span class="enscript-keyword">sizeof</span>(remote_address));

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_ERROR_CODE, <span class="enscript-keyword">sizeof</span>(connect_error), &amp;connect_error, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the connect result: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;received connect result %u&quot;</span>, connect_error);

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_SPACE_AVAILABLE, <span class="enscript-keyword">sizeof</span>(send_window), &amp;send_window, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the send window: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_CTL_UNIT, <span class="enscript-keyword">sizeof</span>(ctl_unit), &amp;ctl_unit, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the control unit: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_LOCAL_ADDR, <span class="enscript-keyword">sizeof</span>(local_address), &amp;local_address, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_NOTICE, fd_cb, <span class="enscript-string">&quot;No local address provided&quot;</span>);
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_REMOTE_ADDR, <span class="enscript-keyword">sizeof</span>(remote_address), &amp;remote_address, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_NOTICE, fd_cb, <span class="enscript-string">&quot;No remote address provided&quot;</span>);
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_OUT_IF_INDEX, <span class="enscript-keyword">sizeof</span>(out_if_index), &amp;out_if_index, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_NOTICE, fd_cb, <span class="enscript-string">&quot;No output if index provided&quot;</span>);
	}

	connect_error	= ntohl(connect_error);
	ctl_unit		= ntohl(ctl_unit);

	lck_rw_lock_shared(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (connect_error == 0) {
		<span class="enscript-keyword">if</span> (ctl_unit == 0 || ctl_unit &gt;= GROUP_COUNT_MAX) {
			FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;Connect result contains an invalid control unit: %u&quot;</span>, ctl_unit);
			error = EINVAL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (g_flow_divert_groups == NULL || g_active_group_count == 0) {
			FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;No active groups, dropping connection&quot;</span>);
			error = EINVAL;
		} <span class="enscript-keyword">else</span> {
			grp = g_flow_divert_groups[ctl_unit];
			<span class="enscript-keyword">if</span> (grp == NULL) {
				error = ECONNRESET;
			}
		}
	}

	FDLOCK(fd_cb);
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
		<span class="enscript-type">struct</span> inpcb				*inp = NULL;
		<span class="enscript-type">struct</span> ifnet				*ifp = NULL;
		<span class="enscript-type">struct</span> flow_divert_group	*old_group;

		socket_lock(fd_cb-&gt;so, 0);

		<span class="enscript-keyword">if</span> (!(fd_cb-&gt;so-&gt;so_state &amp; SS_ISCONNECTING)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		inp = sotoinpcb(fd_cb-&gt;so);

		<span class="enscript-keyword">if</span> (connect_error || error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">set_socket_state</span>;
		}

		<span class="enscript-keyword">if</span> (local_address.ss_family == 0 &amp;&amp; fd_cb-&gt;local_address == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">set_socket_state</span>;
		}
		<span class="enscript-keyword">if</span> (local_address.ss_family != 0 &amp;&amp; fd_cb-&gt;local_address == NULL) {
			<span class="enscript-keyword">if</span> (local_address.ss_len &gt; <span class="enscript-keyword">sizeof</span>(local_address)) {
				local_address.ss_len = <span class="enscript-keyword">sizeof</span>(local_address);
			}
			fd_cb-&gt;local_address = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;local_address, 1);
		}

		<span class="enscript-keyword">if</span> (remote_address.ss_family != 0) {
			<span class="enscript-keyword">if</span> (remote_address.ss_len &gt; <span class="enscript-keyword">sizeof</span>(remote_address)) {
				remote_address.ss_len = <span class="enscript-keyword">sizeof</span>(remote_address);
			}
			fd_cb-&gt;remote_address = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_address, 1);
		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">set_socket_state</span>;
		}

		ifnet_head_lock_shared();
		<span class="enscript-keyword">if</span> (out_if_index &gt; 0 &amp;&amp; out_if_index &lt;= if_index) {
			ifp = ifindex2ifnet[out_if_index];
		}

		<span class="enscript-keyword">if</span> (ifp != NULL) {
			inp-&gt;inp_last_outifp = ifp;
		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
		}
		ifnet_head_done();

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">set_socket_state</span>;
		}

		<span class="enscript-keyword">if</span> (fd_cb-&gt;group == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">set_socket_state</span>;
		}

		old_group = fd_cb-&gt;group;

		lck_rw_lock_exclusive(&amp;old_group-&gt;lck);
		lck_rw_lock_exclusive(&amp;grp-&gt;lck);

		RB_REMOVE(fd_pcb_tree, &amp;old_group-&gt;pcb_tree, fd_cb);
		<span class="enscript-keyword">if</span> (RB_INSERT(fd_pcb_tree, &amp;grp-&gt;pcb_tree, fd_cb) != NULL) {
			panic(<span class="enscript-string">&quot;group with unit %u already contains a connection with hash %u&quot;</span>, grp-&gt;ctl_unit, fd_cb-&gt;hash);
		}

		fd_cb-&gt;group = grp;

		lck_rw_done(&amp;grp-&gt;lck);
		lck_rw_done(&amp;old_group-&gt;lck);

		fd_cb-&gt;send_window = ntohl(send_window);
		flow_divert_send_buffered_data(fd_cb, FALSE);

<span class="enscript-reference">set_socket_state</span>:
		<span class="enscript-keyword">if</span> (!connect_error &amp;&amp; !error) {
			FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;sending connect result&quot;</span>);
			error = flow_divert_send_connect_result(fd_cb);
		}

		<span class="enscript-keyword">if</span> (connect_error || error) {
			<span class="enscript-keyword">if</span> (!connect_error) {
				flow_divert_update_closed_state(fd_cb, SHUT_RDWR, FALSE);
				fd_cb-&gt;so-&gt;so_error = error;
				flow_divert_send_close_if_needed(fd_cb);
			} <span class="enscript-keyword">else</span> {
				flow_divert_update_closed_state(fd_cb, SHUT_RDWR, TRUE);
				fd_cb-&gt;so-&gt;so_error = connect_error;
			}
			flow_divert_disconnect_socket(fd_cb-&gt;so);
		} <span class="enscript-keyword">else</span> {
			soisconnected(fd_cb-&gt;so);
		}

<span class="enscript-reference">done</span>:
		socket_unlock(fd_cb-&gt;so, 0);
	}
	FDUNLOCK(fd_cb);

	lck_rw_done(&amp;g_flow_divert_group_lck);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_close</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	uint32_t	close_error;
	<span class="enscript-type">int</span>			error			= 0;
	<span class="enscript-type">int</span>			how;

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_ERROR_CODE, <span class="enscript-keyword">sizeof</span>(close_error), &amp;close_error, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the close error: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_HOW, <span class="enscript-keyword">sizeof</span>(how), &amp;how, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the close how flag: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	how = ntohl(how);

	FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;close received, how = %d&quot;</span>, how);

	FDLOCK(fd_cb);
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
		socket_lock(fd_cb-&gt;so, 0);

		fd_cb-&gt;so-&gt;so_error = ntohl(close_error);

		flow_divert_update_closed_state(fd_cb, how, TRUE);
		
		how = flow_divert_tunnel_how_closed(fd_cb);
		<span class="enscript-keyword">if</span> (how == SHUT_RDWR) {
			flow_divert_disconnect_socket(fd_cb-&gt;so);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (how == SHUT_RD) {
			socantrcvmore(fd_cb-&gt;so);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (how == SHUT_WR) {
			socantsendmore(fd_cb-&gt;so);
		}

		socket_unlock(fd_cb-&gt;so, 0);
	}
	FDUNLOCK(fd_cb);
}

<span class="enscript-type">static</span> mbuf_t
<span class="enscript-function-name">flow_divert_get_control_mbuf</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(fd_cb-&gt;so);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4 &amp;&amp; inp-&gt;inp_flags &amp; INP_RECVDSTADDR) {
		<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)fd_cb-&gt;local_address;

		<span class="enscript-keyword">return</span> sbcreatecontrol((caddr_t) &amp;sin-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr), IP_RECVDSTADDR, IPPROTO_IP);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6 &amp;&amp; (inp-&gt;inp_flags &amp; IN6P_PKTINFO) != 0) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)fd_cb-&gt;local_address;
		<span class="enscript-type">struct</span> in6_pktinfo pi6;

		bcopy(&amp;sin6-&gt;sin6_addr, &amp;pi6.ipi6_addr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		pi6.ipi6_ifindex = 0;
		<span class="enscript-keyword">return</span> sbcreatecontrol((caddr_t)&amp;pi6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_pktinfo), IPV6_PKTINFO, IPPROTO_IPV6);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_data</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, size_t offset)
{
	FDLOCK(fd_cb);
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
		<span class="enscript-type">int</span>		error		= 0;
		mbuf_t	data		= NULL;
		size_t	data_size;
		<span class="enscript-type">struct</span> sockaddr_storage remote_address;
		boolean_t got_remote_sa = FALSE;

		socket_lock(fd_cb-&gt;so, 0);

		<span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_DGRAM) {
			uint32_t val_size = 0;

			<span class="enscript-comment">/* check if we got remote address with data */</span>
			memset(&amp;remote_address, 0, <span class="enscript-keyword">sizeof</span>(remote_address));
			error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_REMOTE_ADDR, <span class="enscript-keyword">sizeof</span>(remote_address), &amp;remote_address, &amp;val_size);
			<span class="enscript-keyword">if</span> (error || val_size &gt; <span class="enscript-keyword">sizeof</span>(remote_address)) {
				FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;No remote address provided&quot;</span>);
				error = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* validate the address */</span>
				<span class="enscript-keyword">if</span> (flow_divert_is_sockaddr_valid((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_address)) {
					got_remote_sa = TRUE;
				}
				offset += (<span class="enscript-keyword">sizeof</span>(uint8_t) + <span class="enscript-keyword">sizeof</span>(uint32_t) + val_size);
			}
		}

		data_size = (mbuf_pkthdr_len(packet) - offset);

		FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;received %lu bytes of data&quot;</span>, data_size);

		error = mbuf_split(packet, offset, MBUF_DONTWAIT, &amp;data);
		<span class="enscript-keyword">if</span> (error || data == NULL) {
			FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;mbuf_split failed: %d&quot;</span>, error);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (flow_divert_check_no_cellular(fd_cb) || 
			    flow_divert_check_no_expensive(fd_cb))
			{
				flow_divert_update_closed_state(fd_cb, SHUT_RDWR, TRUE);
				flow_divert_send_close(fd_cb, SHUT_RDWR);
				flow_divert_disconnect_socket(fd_cb-&gt;so);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(fd_cb-&gt;so-&gt;so_state &amp; SS_CANTRCVMORE)) {
				<span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_STREAM) {
					<span class="enscript-keyword">if</span> (sbappendstream(&amp;fd_cb-&gt;so-&gt;so_rcv, data)) {
						fd_cb-&gt;bytes_received += data_size;
						flow_divert_add_data_statistics(fd_cb, data_size, FALSE);
						fd_cb-&gt;sb_size = fd_cb-&gt;so-&gt;so_rcv.sb_cc;
						sorwakeup(fd_cb-&gt;so);
						data = NULL;
					} <span class="enscript-keyword">else</span> {
						FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;received data, but appendstream failed&quot;</span>);
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(fd_cb-&gt;so) == SOCK_DGRAM) {
					<span class="enscript-type">struct</span> sockaddr *append_sa;
					mbuf_t mctl;

					<span class="enscript-keyword">if</span> (got_remote_sa == TRUE) {
						error = flow_divert_dup_addr(fd_cb-&gt;so-&gt;so_proto-&gt;pr_domain-&gt;dom_family,
								(<span class="enscript-type">struct</span> sockaddr *)&amp;remote_address, &amp;append_sa);
					} <span class="enscript-keyword">else</span> {
						error = flow_divert_dup_addr(fd_cb-&gt;so-&gt;so_proto-&gt;pr_domain-&gt;dom_family,
								fd_cb-&gt;remote_address, &amp;append_sa);
					}
					<span class="enscript-keyword">if</span> (error) {
						FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to dup the socket address.&quot;</span>);
					}

					mctl = flow_divert_get_control_mbuf(fd_cb);
					<span class="enscript-keyword">if</span> (sbappendaddr(&amp;fd_cb-&gt;so-&gt;so_rcv, append_sa, data, mctl, NULL)) {
						fd_cb-&gt;bytes_received += data_size;
						flow_divert_add_data_statistics(fd_cb, data_size, FALSE);
						fd_cb-&gt;sb_size = fd_cb-&gt;so-&gt;so_rcv.sb_cc;
						sorwakeup(fd_cb-&gt;so);
						data = NULL;
					} <span class="enscript-keyword">else</span> {
						FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;received data, but sbappendaddr failed&quot;</span>);
					}
					<span class="enscript-keyword">if</span> (!error) {
						FREE(append_sa, M_TEMP);
					}
				}
			}
		}
		socket_unlock(fd_cb-&gt;so, 0);

		<span class="enscript-keyword">if</span> (data != NULL) {
			mbuf_freem(data);
		}
	}
	FDUNLOCK(fd_cb);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_read_notification</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	uint32_t	read_count;
	<span class="enscript-type">int</span>		error			= 0;

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_READ_COUNT, <span class="enscript-keyword">sizeof</span>(read_count), &amp;read_count, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the read count: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;received a read notification for %u bytes&quot;</span>, ntohl(read_count));

	FDLOCK(fd_cb);
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
		socket_lock(fd_cb-&gt;so, 0);
		fd_cb-&gt;send_window += ntohl(read_count);
		flow_divert_send_buffered_data(fd_cb, FALSE);
		socket_unlock(fd_cb-&gt;so, 0);
	}
	FDUNLOCK(fd_cb);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_group_init</span>(<span class="enscript-type">struct</span> flow_divert_group *group, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t key_size = 0;
	<span class="enscript-type">int</span> log_level;

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_TOKEN_KEY, 0, NULL, &amp;key_size);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to get the key size: %d&quot;</span>, error);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (key_size == 0 || key_size &gt; FLOW_DIVERT_MAX_KEY_SIZE) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Invalid key size: %lu&quot;</span>, key_size);
		<span class="enscript-keyword">return</span>;
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_LOG_LEVEL, <span class="enscript-keyword">sizeof</span>(log_level), &amp;log_level, NULL);
	<span class="enscript-keyword">if</span> (!error) {
		nil_pcb.log_level = log_level;
	}

	lck_rw_lock_exclusive(&amp;group-&gt;lck);

	MALLOC(group-&gt;token_key, uint8_t *, key_size, M_TEMP, M_WAITOK);
	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_TOKEN_KEY, key_size, group-&gt;token_key, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;failed to get the token key: %d&quot;</span>, error);
		FREE(group-&gt;token_key, M_TEMP);
		group-&gt;token_key = NULL;
		lck_rw_done(&amp;group-&gt;lck);
		<span class="enscript-keyword">return</span>;
	}

	group-&gt;token_key_size = key_size;

	lck_rw_done(&amp;group-&gt;lck);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_properties_update</span>(<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span>							error				= 0;
	<span class="enscript-type">struct</span> sockaddr_storage		local_address;
	<span class="enscript-type">int</span>							out_if_index		= 0;
	<span class="enscript-type">struct</span> sockaddr_storage		remote_address;

	FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;received a properties update&quot;</span>);

	memset(&amp;local_address, 0, <span class="enscript-keyword">sizeof</span>(local_address));
	memset(&amp;remote_address, 0, <span class="enscript-keyword">sizeof</span>(remote_address));

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_LOCAL_ADDR, <span class="enscript-keyword">sizeof</span>(local_address), &amp;local_address, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;No local address provided&quot;</span>);
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_REMOTE_ADDR, <span class="enscript-keyword">sizeof</span>(remote_address), &amp;remote_address, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;No remote address provided&quot;</span>);
	}

	error = flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_OUT_IF_INDEX, <span class="enscript-keyword">sizeof</span>(out_if_index), &amp;out_if_index, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;No output if index provided&quot;</span>);
	}

	FDLOCK(fd_cb);
	<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
		<span class="enscript-type">struct</span> inpcb				*inp = NULL;
		<span class="enscript-type">struct</span> ifnet				*ifp = NULL;

		socket_lock(fd_cb-&gt;so, 0);

		inp = sotoinpcb(fd_cb-&gt;so);

		<span class="enscript-keyword">if</span> (local_address.ss_family != 0) {
			<span class="enscript-keyword">if</span> (local_address.ss_len &gt; <span class="enscript-keyword">sizeof</span>(local_address)) {
				local_address.ss_len = <span class="enscript-keyword">sizeof</span>(local_address);
			}
			fd_cb-&gt;local_address = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;local_address, 1);
		}

		<span class="enscript-keyword">if</span> (remote_address.ss_family != 0) {
			<span class="enscript-keyword">if</span> (remote_address.ss_len &gt; <span class="enscript-keyword">sizeof</span>(remote_address)) {
				remote_address.ss_len = <span class="enscript-keyword">sizeof</span>(remote_address);
			}
			fd_cb-&gt;remote_address = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;remote_address, 1);
		}

		ifnet_head_lock_shared();
		<span class="enscript-keyword">if</span> (out_if_index &gt; 0 &amp;&amp; out_if_index &lt;= if_index) {
			ifp = ifindex2ifnet[out_if_index];
		}

		<span class="enscript-keyword">if</span> (ifp != NULL) {
			inp-&gt;inp_last_outifp = ifp;
		}
		ifnet_head_done();

		socket_unlock(fd_cb-&gt;so, 0);
	}
	FDUNLOCK(fd_cb);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_app_map_create</span>(mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	size_t bytes_mem_size;
	size_t child_maps_mem_size;
	<span class="enscript-type">int</span> cursor;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> flow_divert_trie new_trie;
	<span class="enscript-type">int</span> insert_error = 0;
	size_t nodes_mem_size;
	<span class="enscript-type">int</span> prefix_count = 0;
	<span class="enscript-type">int</span> signing_id_count = 0;

	lck_rw_lock_exclusive(&amp;g_flow_divert_group_lck);

	<span class="enscript-comment">/* Re-set the current trie */</span>
	<span class="enscript-keyword">if</span> (g_signing_id_trie.memory != NULL) {
		FREE(g_signing_id_trie.memory, M_TEMP);
	}
	memset(&amp;g_signing_id_trie, 0, <span class="enscript-keyword">sizeof</span>(g_signing_id_trie));
	g_signing_id_trie.root = NULL_TRIE_IDX;

	memset(&amp;new_trie, 0, <span class="enscript-keyword">sizeof</span>(new_trie));

	<span class="enscript-comment">/* Get the number of shared prefixes in the new set of signing ID strings */</span>
	flow_divert_packet_get_tlv(packet, offset, FLOW_DIVERT_TLV_PREFIX_COUNT, <span class="enscript-keyword">sizeof</span>(prefix_count), &amp;prefix_count, NULL);

	<span class="enscript-comment">/* Compute the number of signing IDs and the total amount of bytes needed to store them */</span>
	<span class="enscript-keyword">for</span> (cursor = flow_divert_packet_find_tlv(packet, offset, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 0);
	     cursor &gt;= 0;
	     cursor = flow_divert_packet_find_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 1))
	{
		uint32_t sid_size = 0;
		flow_divert_packet_get_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, 0, NULL, &amp;sid_size);
		new_trie.bytes_count += sid_size;
		signing_id_count++;
	}

	<span class="enscript-keyword">if</span> (signing_id_count == 0) {
		lck_rw_done(&amp;g_flow_divert_group_lck);
		<span class="enscript-keyword">return</span>;
	}

	new_trie.nodes_count = (prefix_count + signing_id_count + 1); <span class="enscript-comment">/* + 1 for the root node */</span>
	new_trie.child_maps_count = (prefix_count + 1); <span class="enscript-comment">/* + 1 for the root node */</span>

	FDLOG(LOG_INFO, &amp;nil_pcb, <span class="enscript-string">&quot;Nodes count = %lu, child maps count = %lu, bytes_count = %lu&quot;</span>,
			new_trie.nodes_count, new_trie.child_maps_count, new_trie.bytes_count);

	nodes_mem_size = (<span class="enscript-keyword">sizeof</span>(*new_trie.nodes) * new_trie.nodes_count);
	child_maps_mem_size = (<span class="enscript-keyword">sizeof</span>(*new_trie.child_maps) * CHILD_MAP_SIZE * new_trie.child_maps_count);
	bytes_mem_size = (<span class="enscript-keyword">sizeof</span>(*new_trie.bytes) * new_trie.bytes_count);

	MALLOC(new_trie.memory, <span class="enscript-type">void</span> *, nodes_mem_size + child_maps_mem_size + bytes_mem_size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_trie.memory == NULL) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to allocate %lu bytes of memory for the signing ID trie&quot;</span>,
		      nodes_mem_size + child_maps_mem_size + bytes_mem_size);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Initialize the free lists */</span>
	new_trie.nodes = (<span class="enscript-type">struct</span> flow_divert_trie_node *)new_trie.memory;
	new_trie.nodes_free_next = 0;
	memset(new_trie.nodes, 0, nodes_mem_size);

	new_trie.child_maps = (uint16_t *)(<span class="enscript-type">void</span> *)((uint8_t *)new_trie.memory + nodes_mem_size);
	new_trie.child_maps_free_next = 0;
	memset(new_trie.child_maps, 0xff, child_maps_mem_size);

	new_trie.bytes = (uint8_t *)(<span class="enscript-type">void</span> *)((uint8_t *)new_trie.memory + nodes_mem_size + child_maps_mem_size);
	new_trie.bytes_free_next = 0;

	<span class="enscript-comment">/* The root is an empty node */</span>
	new_trie.root = trie_node_alloc(&amp;new_trie);

	<span class="enscript-comment">/* Add each signing ID to the trie */</span>
	<span class="enscript-keyword">for</span> (cursor = flow_divert_packet_find_tlv(packet, offset, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 0);
	     cursor &gt;= 0;
	     cursor = flow_divert_packet_find_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 1))
	{
		uint32_t sid_size = 0;
		flow_divert_packet_get_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, 0, NULL, &amp;sid_size);
		<span class="enscript-keyword">if</span> (new_trie.bytes_free_next + sid_size &lt;= new_trie.bytes_count) {
			boolean_t is_dns;
			uint16_t new_node_idx;
			flow_divert_packet_get_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, sid_size, &amp;TRIE_BYTE(&amp;new_trie, new_trie.bytes_free_next), NULL);
			is_dns = (sid_size == <span class="enscript-keyword">sizeof</span>(FLOW_DIVERT_DNS_SERVICE_SIGNING_ID) - 1 &amp;&amp; 
			          !memcmp(&amp;TRIE_BYTE(&amp;new_trie, new_trie.bytes_free_next),
			                  FLOW_DIVERT_DNS_SERVICE_SIGNING_ID,
			                  sid_size));
			new_node_idx = flow_divert_trie_insert(&amp;new_trie, new_trie.bytes_free_next, sid_size);
			<span class="enscript-keyword">if</span> (new_node_idx != NULL_TRIE_IDX) {
				<span class="enscript-keyword">if</span> (is_dns) {
					FDLOG(LOG_INFO, &amp;nil_pcb, <span class="enscript-string">&quot;Setting group unit for %s to %d&quot;</span>, FLOW_DIVERT_DNS_SERVICE_SIGNING_ID, DNS_SERVICE_GROUP_UNIT);
					TRIE_NODE(&amp;new_trie, new_node_idx).group_unit = DNS_SERVICE_GROUP_UNIT;
				}
			} <span class="enscript-keyword">else</span> {
				insert_error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;No place to put signing ID for insertion&quot;</span>);
			insert_error = ENOBUFS;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!insert_error) {
		g_signing_id_trie = new_trie;
	} <span class="enscript-keyword">else</span> {
		FREE(new_trie.memory, M_TEMP);
	}

	lck_rw_done(&amp;g_flow_divert_group_lck);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_handle_app_map_update</span>(<span class="enscript-type">struct</span> flow_divert_group *group, mbuf_t packet, <span class="enscript-type">int</span> offset)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> cursor;
	size_t max_size = 0;
	uint8_t *signing_id;
	uint32_t ctl_unit;

	lck_rw_lock_shared(&amp;group-&gt;lck);
	ctl_unit = group-&gt;ctl_unit;
	lck_rw_done(&amp;group-&gt;lck);

	<span class="enscript-keyword">for</span> (cursor = flow_divert_packet_find_tlv(packet, offset, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 0);
	     cursor &gt;= 0;
	     cursor = flow_divert_packet_find_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 1))
	{
		uint32_t sid_size = 0;
		flow_divert_packet_get_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, 0, NULL, &amp;sid_size);
		<span class="enscript-keyword">if</span> (sid_size &gt; max_size) {
			max_size = sid_size;
		}
	}

	MALLOC(signing_id, uint8_t *, max_size + 1, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (signing_id == NULL) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to allocate a string to hold the signing ID (size %lu)&quot;</span>, max_size);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (cursor = flow_divert_packet_find_tlv(packet, offset, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 0);
	     cursor &gt;= 0;
	     cursor = flow_divert_packet_find_tlv(packet, cursor, FLOW_DIVERT_TLV_SIGNING_ID, &amp;error, 1))
	{
		uint32_t signing_id_len = 0;
		uint16_t node;

		flow_divert_packet_get_tlv(packet,
				cursor, FLOW_DIVERT_TLV_SIGNING_ID, max_size, signing_id, &amp;signing_id_len);

		signing_id[signing_id_len] = <span class="enscript-string">'\0'</span>;

		lck_rw_lock_exclusive(&amp;g_flow_divert_group_lck);

		node = flow_divert_trie_search(&amp;g_signing_id_trie, signing_id);
		<span class="enscript-keyword">if</span> (node != NULL_TRIE_IDX) {
			<span class="enscript-keyword">if</span> (TRIE_NODE(&amp;g_signing_id_trie, node).group_unit != DNS_SERVICE_GROUP_UNIT) {
				FDLOG(LOG_INFO, &amp;nil_pcb, <span class="enscript-string">&quot;Setting %s to ctl unit %u&quot;</span>, signing_id, group-&gt;ctl_unit);
				TRIE_NODE(&amp;g_signing_id_trie, node).group_unit = ctl_unit;
			}
		} <span class="enscript-keyword">else</span> {
			FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to find signing ID %s&quot;</span>, signing_id);
		}

		lck_rw_done(&amp;g_flow_divert_group_lck);
	}

	FREE(signing_id, M_TEMP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_input</span>(mbuf_t packet, <span class="enscript-type">struct</span> flow_divert_group *group)
{
	<span class="enscript-type">struct</span> flow_divert_packet_header	hdr;
	<span class="enscript-type">int</span>									error		= 0;
	<span class="enscript-type">struct</span> flow_divert_pcb				*fd_cb;

	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(packet) &lt; <span class="enscript-keyword">sizeof</span>(hdr)) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;got a bad packet, length (%lu) &lt; sizeof hdr (%lu)&quot;</span>, mbuf_pkthdr_len(packet), <span class="enscript-keyword">sizeof</span>(hdr));
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(packet) &gt; FD_CTL_RCVBUFF_SIZE) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;got a bad packet, length (%lu) &gt; %lu&quot;</span>, mbuf_pkthdr_len(packet), FD_CTL_RCVBUFF_SIZE);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = mbuf_copydata(packet, 0, <span class="enscript-keyword">sizeof</span>(hdr), &amp;hdr);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;mbuf_copydata failed for the header: %d&quot;</span>, error);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	hdr.conn_id = ntohl(hdr.conn_id);

	<span class="enscript-keyword">if</span> (hdr.conn_id == 0) {
		<span class="enscript-keyword">switch</span> (hdr.packet_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_GROUP_INIT</span>:
				flow_divert_handle_group_init(group, packet, <span class="enscript-keyword">sizeof</span>(hdr));
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_APP_MAP_CREATE</span>:
				flow_divert_handle_app_map_create(packet, <span class="enscript-keyword">sizeof</span>(hdr));
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_APP_MAP_UPDATE</span>:
				flow_divert_handle_app_map_update(group, packet, <span class="enscript-keyword">sizeof</span>(hdr));
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				FDLOG(LOG_WARNING, &amp;nil_pcb, <span class="enscript-string">&quot;got an unknown message type: %d&quot;</span>, hdr.packet_type);
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	fd_cb = flow_divert_pcb_lookup(hdr.conn_id, group);		<span class="enscript-comment">/* This retains the PCB */</span>
	<span class="enscript-keyword">if</span> (fd_cb == NULL) {
		<span class="enscript-keyword">if</span> (hdr.packet_type != FLOW_DIVERT_PKT_CLOSE &amp;&amp; hdr.packet_type != FLOW_DIVERT_PKT_READ_NOTIFY) {
			FDLOG(LOG_NOTICE, &amp;nil_pcb, <span class="enscript-string">&quot;got a %s message from group %d for an unknown pcb: %u&quot;</span>, flow_divert_packet_type2str(hdr.packet_type), group-&gt;ctl_unit, hdr.conn_id);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">switch</span> (hdr.packet_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_CONNECT_RESULT</span>:
			flow_divert_handle_connect_result(fd_cb, packet, <span class="enscript-keyword">sizeof</span>(hdr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_CLOSE</span>:
			flow_divert_handle_close(fd_cb, packet, <span class="enscript-keyword">sizeof</span>(hdr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_DATA</span>:
			flow_divert_handle_data(fd_cb, packet, <span class="enscript-keyword">sizeof</span>(hdr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_READ_NOTIFY</span>:
			flow_divert_handle_read_notification(fd_cb, packet, <span class="enscript-keyword">sizeof</span>(hdr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FLOW_DIVERT_PKT_PROPERTIES_UPDATE</span>:
			flow_divert_handle_properties_update(fd_cb, packet, <span class="enscript-keyword">sizeof</span>(hdr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			FDLOG(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;got an unknown message type: %d&quot;</span>, hdr.packet_type);
			<span class="enscript-keyword">break</span>;
	}

	FDRELEASE(fd_cb);

<span class="enscript-reference">done</span>:
	mbuf_freem(packet);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_close_all</span>(<span class="enscript-type">struct</span> flow_divert_group *group)
{
	<span class="enscript-type">struct</span> flow_divert_pcb			*fd_cb;
	SLIST_HEAD(, flow_divert_pcb)	tmp_list;

	SLIST_INIT(&amp;tmp_list);

	lck_rw_lock_exclusive(&amp;group-&gt;lck);

	MBUFQ_DRAIN(&amp;group-&gt;send_queue);

	RB_FOREACH(fd_cb, fd_pcb_tree, &amp;group-&gt;pcb_tree) {
		FDRETAIN(fd_cb);
		SLIST_INSERT_HEAD(&amp;tmp_list, fd_cb, tmp_list_entry);
	}

	lck_rw_done(&amp;group-&gt;lck);

	<span class="enscript-keyword">while</span> (!SLIST_EMPTY(&amp;tmp_list)) {
		fd_cb = SLIST_FIRST(&amp;tmp_list);
		FDLOCK(fd_cb);
		SLIST_REMOVE_HEAD(&amp;tmp_list, tmp_list_entry);
		<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
			socket_lock(fd_cb-&gt;so, 0);
			flow_divert_pcb_remove(fd_cb);
			flow_divert_update_closed_state(fd_cb, SHUT_RDWR, TRUE);
			fd_cb-&gt;so-&gt;so_error = ECONNABORTED;
			socket_unlock(fd_cb-&gt;so, 0);
		}
		FDUNLOCK(fd_cb);
		FDRELEASE(fd_cb);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb		= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	so-&gt;so_flags &amp;= ~SOF_FLOW_DIVERT;
	so-&gt;so_fd_pcb = NULL;

	FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Detaching, ref count = %d&quot;</span>, fd_cb-&gt;ref_count);

	<span class="enscript-keyword">if</span> (fd_cb-&gt;group != NULL) {
		<span class="enscript-comment">/* Last-ditch effort to send any buffered data */</span>
		flow_divert_send_buffered_data(fd_cb, TRUE);

		flow_divert_update_closed_state(fd_cb, SHUT_RDWR, FALSE);
		flow_divert_send_close_if_needed(fd_cb);
		<span class="enscript-comment">/* Remove from the group */</span>
		flow_divert_pcb_remove(fd_cb);
	}

	socket_unlock(so, 0);
	FDLOCK(fd_cb);
	fd_cb-&gt;so = NULL;
	FDUNLOCK(fd_cb);
	socket_lock(so, 0);

	FDRELEASE(fd_cb);	<span class="enscript-comment">/* Release the socket's reference */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_close</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb		= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Closing&quot;</span>);

	<span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_STREAM) {
		soisdisconnecting(so);
		sbflush(&amp;so-&gt;so_rcv);
	}

	flow_divert_send_buffered_data(fd_cb, TRUE);
	flow_divert_update_closed_state(fd_cb, SHUT_RDWR, FALSE);
	flow_divert_send_close_if_needed(fd_cb);

	<span class="enscript-comment">/* Remove from the group */</span>
	flow_divert_pcb_remove(fd_cb);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_disconnectx</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid,
    sae_connid_t cid __unused)
{
	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">return</span> (flow_divert_close(so));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_shutdown</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb		= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Can't send more&quot;</span>);

	socantsendmore(so);

	flow_divert_update_closed_state(fd_cb, SHUT_WR, FALSE);
	flow_divert_send_close_if_needed(fd_cb);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_rcvd</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags __unused)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb			= so-&gt;so_fd_pcb;
	uint32_t				latest_sb_size;
	uint32_t				read_count;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	latest_sb_size = fd_cb-&gt;so-&gt;so_rcv.sb_cc;

	<span class="enscript-keyword">if</span> (fd_cb-&gt;sb_size &lt; latest_sb_size) {
		panic(<span class="enscript-string">&quot;flow divert rcvd event handler (%u): saved rcv buffer size (%u) is less than latest rcv buffer size (%u)&quot;</span>,
				fd_cb-&gt;hash, fd_cb-&gt;sb_size, latest_sb_size);
	}

	read_count = fd_cb-&gt;sb_size - latest_sb_size;

	FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;app read %u bytes&quot;</span>, read_count);

	<span class="enscript-keyword">if</span> (read_count &gt; 0 &amp;&amp; flow_divert_send_read_notification(fd_cb, read_count) == 0) {
		fd_cb-&gt;bytes_read_by_app += read_count;
		fd_cb-&gt;sb_size = latest_sb_size;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_append_target_endpoint_tlv</span>(mbuf_t connect_packet, <span class="enscript-type">struct</span> sockaddr *toaddr)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> port  = 0;

	error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_TARGET_ADDRESS, toaddr-&gt;sa_len, toaddr);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (toaddr-&gt;sa_family == AF_INET) {
		port = ntohs((satosin(toaddr))-&gt;sin_port);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> {
		port = ntohs((satosin6(toaddr))-&gt;sin6_port);
	}
#<span class="enscript-reference">endif</span>

	error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_TARGET_PORT, <span class="enscript-keyword">sizeof</span>(port), &amp;port);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">flow_divert_get_buffered_target_address</span>(mbuf_t buffer)
{
	<span class="enscript-keyword">if</span> (buffer != NULL &amp;&amp; buffer-&gt;m_type == MT_SONAME) {
		<span class="enscript-type">struct</span> sockaddr *toaddr = mtod(buffer, <span class="enscript-type">struct</span> sockaddr *);
		<span class="enscript-keyword">if</span> (toaddr != NULL &amp;&amp; flow_divert_is_sockaddr_valid(toaddr)) {
			<span class="enscript-keyword">return</span> toaddr;
		}
	}
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">flow_divert_is_sockaddr_valid</span>(<span class="enscript-type">struct</span> sockaddr *addr)
{
	<span class="enscript-keyword">switch</span>(addr-&gt;sa_family)
	{
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (addr-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in)) {
				<span class="enscript-keyword">return</span> FALSE;
			}
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (addr-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6)) {
				<span class="enscript-keyword">return</span> FALSE;
			}
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> FALSE;
	}
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_inp_to_sockaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr **local_socket)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">union</span> sockaddr_in_4_6 sin46;

	bzero(&amp;sin46, <span class="enscript-keyword">sizeof</span>(sin46));
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		<span class="enscript-type">struct</span> sockaddr_in  *sin = &amp;sin46.sin;

		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
		sin-&gt;sin_port = inp-&gt;inp_lport;
		sin-&gt;sin_addr = inp-&gt;inp_laddr;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = &amp;sin46.sin6;

		sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
		sin6-&gt;sin6_family = AF_INET6;
		sin6-&gt;sin6_port = inp-&gt;inp_lport;
		sin6-&gt;sin6_addr = inp-&gt;in6p_laddr;
	}
	*local_socket = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sin46, 1);
	<span class="enscript-keyword">if</span> (*local_socket == NULL) {
		error = ENOBUFS;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">flow_divert_has_pcb_local_address</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">return</span> (inp-&gt;inp_lport != 0
		&amp;&amp; (inp-&gt;inp_laddr.s_addr != INADDR_ANY || !IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)));
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_dup_addr</span>(sa_family_t family, <span class="enscript-type">struct</span> sockaddr *addr,
                     <span class="enscript-type">struct</span> sockaddr **dup)
{
	<span class="enscript-type">int</span>						error		= 0;
	<span class="enscript-type">struct</span> sockaddr			*result;
	<span class="enscript-type">struct</span> sockaddr_storage	ss;

	<span class="enscript-keyword">if</span> (addr != NULL) {
		result = addr;
	} <span class="enscript-keyword">else</span> {
		memset(&amp;ss, 0, <span class="enscript-keyword">sizeof</span>(ss));
		ss.ss_family = family;
		<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET) {
			ss.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6) {
			ss.ss_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">else</span> {
			error = EINVAL;
		}
		result = (<span class="enscript-type">struct</span> sockaddr *)&amp;ss;
	}

	<span class="enscript-keyword">if</span> (!error) {
		*dup = dup_sockaddr(result, 1);
		<span class="enscript-keyword">if</span> (*dup == NULL) {
			error = ENOBUFS;
		}
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_disconnect_socket</span>(<span class="enscript-type">struct</span> socket *so)
{
	soisdisconnected(so);
	<span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_DGRAM) {
		<span class="enscript-type">struct</span> inpcb *inp = NULL;

		inp = sotoinpcb(so);
		<span class="enscript-keyword">if</span> (inp != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
				in6_pcbdetach(inp);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				in_pcbdetach(inp);
		}
	}
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_getpeername</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **sa)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	<span class="enscript-keyword">return</span> flow_divert_dup_addr(so-&gt;so_proto-&gt;pr_domain-&gt;dom_family, 
	                            fd_cb-&gt;remote_address,
	                            sa);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_getsockaddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **sa)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	<span class="enscript-keyword">return</span> flow_divert_dup_addr(so-&gt;so_proto-&gt;pr_domain-&gt;dom_family, 
	                            fd_cb-&gt;local_address,
	                            sa);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == SO_TRAFFIC_CLASS) {
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_dir == SOPT_SET &amp;&amp; fd_cb-&gt;flags &amp; FLOW_DIVERT_CONNECT_STARTED) {
			flow_divert_send_traffic_class_update(fd_cb, so-&gt;so_traffic_class);
		}
	}

	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
		<span class="enscript-keyword">return</span> g_tcp_protosw-&gt;pr_ctloutput(so, sopt);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET6) {
		<span class="enscript-keyword">return</span> g_tcp6_protosw-&gt;pr_ctloutput(so, sopt);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">flow_divert_connect_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *to, proc_t p)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;
	<span class="enscript-type">int</span>						error	= 0;
	<span class="enscript-type">struct</span> inpcb			*inp	= sotoinpcb(so);
	<span class="enscript-type">struct</span> sockaddr_in		*sinp;
	mbuf_t					connect_packet = NULL;
	<span class="enscript-type">char</span>					*signing_id = NULL;
	<span class="enscript-type">int</span>						free_signing_id = 0;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	<span class="enscript-keyword">if</span> (fd_cb-&gt;group == NULL) {
		error = ENETUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (inp == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD) {
		<span class="enscript-keyword">if</span> (so-&gt;so_error) {
			error = so-&gt;so_error;
			so-&gt;so_error = 0;
		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	sinp = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)to;
	<span class="enscript-keyword">if</span> (sinp-&gt;sin_family == AF_INET &amp;&amp; IN_MULTICAST(ntohl(sinp-&gt;sin_addr.s_addr))) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((fd_cb-&gt;flags &amp; FLOW_DIVERT_CONNECT_STARTED) &amp;&amp; !(fd_cb-&gt;flags &amp; FLOW_DIVERT_TRANSFERRED)) {
		error = EALREADY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;flags &amp; FLOW_DIVERT_TRANSFERRED) {
		FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;fully transferred&quot;</span>);
		fd_cb-&gt;flags &amp;= ~FLOW_DIVERT_TRANSFERRED;
		<span class="enscript-keyword">if</span> (fd_cb-&gt;remote_address != NULL) {
			soisconnected(fd_cb-&gt;so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;local_address != NULL) {
                error = EALREADY;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        } <span class="enscript-keyword">else</span> {
                <span class="enscript-keyword">if</span> (flow_divert_has_pcb_local_address(inp)) {
                        error = flow_divert_inp_to_sockaddr(inp, &amp;fd_cb-&gt;local_address);
                        <span class="enscript-keyword">if</span> (error) {
                                FDLOG0(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the local socket address.&quot;</span>);
                                <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                        }
                }
        }


	error = flow_divert_packet_init(fd_cb, FLOW_DIVERT_PKT_CONNECT, &amp;connect_packet);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = EPERM;

	<span class="enscript-keyword">if</span> (fd_cb-&gt;connect_token != NULL) {
		uint32_t sid_size = 0;
		<span class="enscript-type">int</span> find_error = flow_divert_packet_get_tlv(fd_cb-&gt;connect_token, 0, FLOW_DIVERT_TLV_SIGNING_ID, 0, NULL, &amp;sid_size);
		<span class="enscript-keyword">if</span> (find_error == 0 &amp;&amp; sid_size &gt; 0) {
			MALLOC(signing_id, <span class="enscript-type">char</span> *, sid_size + 1, M_TEMP, M_WAITOK | M_ZERO);
			<span class="enscript-keyword">if</span> (signing_id != NULL) {
				flow_divert_packet_get_tlv(fd_cb-&gt;connect_token, 0, FLOW_DIVERT_TLV_SIGNING_ID, sid_size, signing_id, NULL);
				FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Got %s from token&quot;</span>, signing_id);
				free_signing_id = 1;
			}
		}
	}

	socket_unlock(so, 0);
	<span class="enscript-keyword">if</span> (g_signing_id_trie.root != NULL_TRIE_IDX) {
		proc_t src_proc = p;
		<span class="enscript-type">int</span> release_proc = 0;
			
		<span class="enscript-keyword">if</span> (signing_id == NULL) {
			release_proc = flow_divert_get_src_proc(so, &amp;src_proc, FALSE);
			<span class="enscript-keyword">if</span> (src_proc != PROC_NULL) {
				proc_lock(src_proc);
				<span class="enscript-keyword">if</span> (src_proc-&gt;p_csflags &amp; CS_VALID) {
                    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * cs_id;
                    cs_id = cs_identity_get(src_proc);
                    signing_id = __DECONST(<span class="enscript-type">char</span> *, cs_id);
				} <span class="enscript-keyword">else</span> {
					FDLOG0(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;Signature is invalid&quot;</span>);
				}
			} <span class="enscript-keyword">else</span> {
				FDLOG0(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;Failed to determine the current proc&quot;</span>);
			}
		} <span class="enscript-keyword">else</span> {
			src_proc = PROC_NULL;
		}

		<span class="enscript-keyword">if</span> (signing_id != NULL) {
			uint16_t result = NULL_TRIE_IDX;
			lck_rw_lock_shared(&amp;g_flow_divert_group_lck);
			result = flow_divert_trie_search(&amp;g_signing_id_trie, (uint8_t *)signing_id);
			lck_rw_done(&amp;g_flow_divert_group_lck);
			<span class="enscript-keyword">if</span> (result != NULL_TRIE_IDX) {
				error = 0;
				FDLOG(LOG_INFO, fd_cb, <span class="enscript-string">&quot;%s matched&quot;</span>, signing_id);

				error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_SIGNING_ID, strlen(signing_id), signing_id);
				<span class="enscript-keyword">if</span> (error == 0) {
					<span class="enscript-keyword">if</span> (src_proc != PROC_NULL) {
						<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> cdhash[SHA1_RESULTLEN];
						error = proc_getcdhash(src_proc, cdhash);
						<span class="enscript-keyword">if</span> (error == 0) {
							error = flow_divert_packet_append_tlv(connect_packet, FLOW_DIVERT_TLV_CDHASH, <span class="enscript-keyword">sizeof</span>(cdhash), cdhash);
							<span class="enscript-keyword">if</span> (error) {
								FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to append the cdhash: %d&quot;</span>, error);
							}
						} <span class="enscript-keyword">else</span> {
							FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to get the cdhash: %d&quot;</span>, error);
						}
					}
				} <span class="enscript-keyword">else</span> {
					FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to append the signing ID: %d&quot;</span>, error);
				}
			} <span class="enscript-keyword">else</span> {
				FDLOG(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;%s did not match&quot;</span>, signing_id);
			}
		} <span class="enscript-keyword">else</span> {
			FDLOG0(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;Failed to get the code signing identity&quot;</span>);
		}

		<span class="enscript-keyword">if</span> (src_proc != PROC_NULL) {
			proc_unlock(src_proc);
			<span class="enscript-keyword">if</span> (release_proc) {
				proc_rele(src_proc);
			}
		}
	} <span class="enscript-keyword">else</span> {
		FDLOG0(LOG_WARNING, fd_cb, <span class="enscript-string">&quot;The signing ID trie is empty&quot;</span>);
	}
	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (free_signing_id) {
		FREE(signing_id, M_TEMP);
	}

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Connecting&quot;</span>);

	error = flow_divert_send_connect(fd_cb, to, connect_packet);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	fd_cb-&gt;flags |= FLOW_DIVERT_CONNECT_STARTED;

	soisconnecting(so);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; connect_packet != NULL) {
		mbuf_freem(connect_packet);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_connectx_out_common</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> af,
    <span class="enscript-type">struct</span> sockaddr_list **src_sl, <span class="enscript-type">struct</span> sockaddr_list **dst_sl,
    <span class="enscript-type">struct</span> proc *p, uint32_t ifscope __unused, sae_associd_t aid __unused,
    sae_connid_t *pcid, uint32_t flags __unused, <span class="enscript-type">void</span> *arg __unused,
    uint32_t arglen __unused)
{
	<span class="enscript-type">struct</span> sockaddr_entry *src_se = NULL, *dst_se = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	VERIFY(dst_sl != NULL);

	<span class="enscript-comment">/* select source (if specified) and destination addresses */</span>
	error = in_selectaddrs(af, src_sl, &amp;src_se, dst_sl, &amp;dst_se);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> (error);
	}

	VERIFY(*dst_sl != NULL &amp;&amp; dst_se != NULL);
	VERIFY(src_se == NULL || *src_sl != NULL);
	VERIFY(dst_se-&gt;se_addr-&gt;sa_family == af);
	VERIFY(src_se == NULL || src_se-&gt;se_addr-&gt;sa_family == af);

	error = flow_divert_connect_out(so, dst_se-&gt;se_addr, p);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pcid != NULL) {
		*pcid = 1;	<span class="enscript-comment">/* there is only 1 connection for a TCP */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_connectx_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">uio</span>, <span class="enscript-variable-name">bytes_written</span>)
	<span class="enscript-keyword">return</span> (flow_divert_connectx_out_common(so, AF_INET, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_connectx6_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">uio</span>, <span class="enscript-variable-name">bytes_written</span>)
	<span class="enscript-keyword">return</span> (flow_divert_connectx_out_common(so, AF_INET6, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_getconninfo</span>(<span class="enscript-type">struct</span> socket *so, sae_connid_t cid, uint32_t *flags,
                        uint32_t *ifindex, int32_t *soerror, user_addr_t src, socklen_t *src_len,
                        user_addr_t dst, socklen_t *dst_len, uint32_t *aux_type,
                        user_addr_t aux_data __unused, uint32_t *aux_len)
{
	<span class="enscript-type">int</span>						error	= 0;
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;
	<span class="enscript-type">struct</span> ifnet			*ifp	= NULL;
	<span class="enscript-type">struct</span> inpcb			*inp	= sotoinpcb(so);

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT));

	<span class="enscript-keyword">if</span> (so-&gt;so_fd_pcb == NULL || inp == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (cid != SAE_CONNID_ANY &amp;&amp; cid != SAE_CONNID_ALL &amp;&amp; cid != 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	ifp = inp-&gt;inp_last_outifp;
	*ifindex = ((ifp != NULL) ? ifp-&gt;if_index : 0);
	*soerror = so-&gt;so_error;
	*flags = 0;

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED) {
		*flags |= (CIF_CONNECTED | CIF_PREFERRED);
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;local_address == NULL) {
		<span class="enscript-type">struct</span> sockaddr_in sin;
		bzero(&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
		sin.sin_len = <span class="enscript-keyword">sizeof</span>(sin);
		sin.sin_family = AF_INET;
		*src_len = sin.sin_len;
		<span class="enscript-keyword">if</span> (src != USER_ADDR_NULL) {
			error = copyout(&amp;sin, src, sin.sin_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		*src_len = fd_cb-&gt;local_address-&gt;sa_len;
		<span class="enscript-keyword">if</span> (src != USER_ADDR_NULL) {
			error = copyout(fd_cb-&gt;local_address, src, fd_cb-&gt;local_address-&gt;sa_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (fd_cb-&gt;remote_address == NULL) {
		<span class="enscript-type">struct</span> sockaddr_in sin;
		bzero(&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
		sin.sin_len = <span class="enscript-keyword">sizeof</span>(sin);
		sin.sin_family = AF_INET;
		*dst_len = sin.sin_len;
		<span class="enscript-keyword">if</span> (dst != USER_ADDR_NULL) {
			error = copyout(&amp;sin, dst, sin.sin_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		*dst_len = fd_cb-&gt;remote_address-&gt;sa_len;
		<span class="enscript-keyword">if</span> (dst != USER_ADDR_NULL) {
			error = copyout(fd_cb-&gt;remote_address, dst, fd_cb-&gt;remote_address-&gt;sa_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	*aux_type = 0;
	*aux_len = 0;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_control</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> ifnet *ifp __unused, <span class="enscript-type">struct</span> proc *p __unused)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>: {
			<span class="enscript-type">struct</span> so_cinforeq32 cifr;
			bcopy(data, &amp;cifr, <span class="enscript-keyword">sizeof</span> (cifr));
			error = flow_divert_getconninfo(so, cifr.scir_cid, &amp;cifr.scir_flags,
			                                &amp;cifr.scir_ifindex, &amp;cifr.scir_error, cifr.scir_src,
			                                &amp;cifr.scir_src_len, cifr.scir_dst, &amp;cifr.scir_dst_len,
			                                &amp;cifr.scir_aux_type, cifr.scir_aux_data,
			                                &amp;cifr.scir_aux_len);
			<span class="enscript-keyword">if</span> (error == 0) {
				bcopy(&amp;cifr, data, <span class="enscript-keyword">sizeof</span> (cifr));
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>: {
			<span class="enscript-type">struct</span> so_cinforeq64 cifr;
			bcopy(data, &amp;cifr, <span class="enscript-keyword">sizeof</span> (cifr));
			error = flow_divert_getconninfo(so, cifr.scir_cid, &amp;cifr.scir_flags,
			                                &amp;cifr.scir_ifindex, &amp;cifr.scir_error, cifr.scir_src,
			                                &amp;cifr.scir_src_len, cifr.scir_dst, &amp;cifr.scir_dst_len,
			                                &amp;cifr.scir_aux_type, cifr.scir_aux_data,
			                                &amp;cifr.scir_aux_len);
			<span class="enscript-keyword">if</span> (error == 0) {
				bcopy(&amp;cifr, data, <span class="enscript-keyword">sizeof</span> (cifr));
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-reference">default</span>:
			error = EOPNOTSUPP;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_in_control</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = flow_divert_control(so, cmd, data, ifp, p);

	<span class="enscript-keyword">if</span> (error == EOPNOTSUPP) {
		error = in_control(so, cmd, data, ifp, p);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_in6_control</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = flow_divert_control(so, cmd, data, ifp, p);

	<span class="enscript-keyword">if</span> (error == EOPNOTSUPP) {
		error = in6_control(so, cmd, data, ifp, p);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_data_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, mbuf_t data, <span class="enscript-type">struct</span> sockaddr *to, mbuf_t control, <span class="enscript-type">struct</span> proc *p __unused)
{
	<span class="enscript-type">struct</span> flow_divert_pcb	*fd_cb	= so-&gt;so_fd_pcb;
	<span class="enscript-type">int</span>						error	= 0;
	<span class="enscript-type">struct</span> inpcb *inp;

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD) {
		error = ECONNRESET;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (control &amp;&amp; mbuf_len(control) &gt; 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (flags &amp; MSG_OOB) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; <span class="enscript-comment">/* We don't support OOB data */</span>
	}
	
	error = flow_divert_check_no_cellular(fd_cb) || 
	    flow_divert_check_no_expensive(fd_cb);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Implicit connect */</span>
	<span class="enscript-keyword">if</span> (!(fd_cb-&gt;flags &amp; FLOW_DIVERT_CONNECT_STARTED)) {
		FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;implicit connect&quot;</span>);
		error = flow_divert_connect_out(so, to, NULL);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	FDLOG(LOG_DEBUG, fd_cb, <span class="enscript-string">&quot;app wrote %lu bytes&quot;</span>, mbuf_pkthdr_len(data));

	fd_cb-&gt;bytes_written_by_app += mbuf_pkthdr_len(data);
	error = flow_divert_send_app_data(fd_cb, data, to);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	data = NULL;

	<span class="enscript-keyword">if</span> (flags &amp; PRUS_EOF) {
		flow_divert_shutdown(so);
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (data) {
		mbuf_freem(data);
	}
	<span class="enscript-keyword">if</span> (control) {
		mbuf_free(control);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_set_protosw</span>(<span class="enscript-type">struct</span> socket *so)
{
	so-&gt;so_flags |= SOF_FLOW_DIVERT;
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
		so-&gt;so_proto = &amp;g_flow_divert_in_protosw;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> {
		so-&gt;so_proto = (<span class="enscript-type">struct</span> protosw *)&amp;g_flow_divert_in6_protosw;
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_set_udp_protosw</span>(<span class="enscript-type">struct</span> socket *so)
{
        so-&gt;so_flags |= SOF_FLOW_DIVERT;
        <span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
                so-&gt;so_proto = &amp;g_flow_divert_in_udp_protosw;
        }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
        <span class="enscript-keyword">else</span> {
                so-&gt;so_proto = (<span class="enscript-type">struct</span> protosw *)&amp;g_flow_divert_in6_udp_protosw;
        }
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* INET6 */</span>
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_attach</span>(<span class="enscript-type">struct</span> socket *so, uint32_t flow_id, uint32_t ctl_unit)
{
	<span class="enscript-type">int</span>									error		= 0;
	<span class="enscript-type">struct</span> flow_divert_pcb				*fd_cb		= NULL;
	<span class="enscript-type">struct</span> ifnet						*ifp		= NULL;
	<span class="enscript-type">struct</span> inpcb						*inp		= NULL;
	<span class="enscript-type">struct</span> socket						*old_so;
	mbuf_t								recv_data	= NULL;

	socket_unlock(so, 0);

	FDLOG(LOG_INFO, &amp;nil_pcb, <span class="enscript-string">&quot;Attaching socket to flow %u&quot;</span>, flow_id);

	<span class="enscript-comment">/* Find the flow divert control block */</span>
	lck_rw_lock_shared(&amp;g_flow_divert_group_lck);
	<span class="enscript-keyword">if</span> (g_flow_divert_groups != NULL &amp;&amp; g_active_group_count &gt; 0) {
		<span class="enscript-type">struct</span> flow_divert_group *group = g_flow_divert_groups[ctl_unit];
		<span class="enscript-keyword">if</span> (group != NULL) {
			fd_cb = flow_divert_pcb_lookup(flow_id, group);
		}
	}
	lck_rw_done(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (fd_cb == NULL) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	FDLOCK(fd_cb);

	<span class="enscript-comment">/* Dis-associate the flow divert control block from its current socket */</span>
	old_so = fd_cb-&gt;so;

	inp = sotoinpcb(old_so); 

	VERIFY(inp != NULL);

	socket_lock(old_so, 0);
	flow_divert_disconnect_socket(old_so);
	old_so-&gt;so_flags &amp;= ~SOF_FLOW_DIVERT;
	old_so-&gt;so_fd_pcb = NULL;
	<span class="enscript-keyword">if</span> (SOCK_TYPE(old_so) == SOCK_STREAM) {
		old_so-&gt;so_proto = pffindproto(SOCK_DOM(old_so), IPPROTO_TCP, SOCK_STREAM);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(old_so) == SOCK_DGRAM) {
		old_so-&gt;so_proto = pffindproto(SOCK_DOM(old_so), IPPROTO_UDP, SOCK_DGRAM);
	}
	fd_cb-&gt;so = NULL;
	<span class="enscript-comment">/* Save the output interface */</span>
	ifp = inp-&gt;inp_last_outifp;
	<span class="enscript-keyword">if</span> (old_so-&gt;so_rcv.sb_cc &gt; 0) {
		error = mbuf_dup(old_so-&gt;so_rcv.sb_mb, MBUF_DONTWAIT, &amp;recv_data);
		sbflush(&amp;old_so-&gt;so_rcv);
	}
	socket_unlock(old_so, 0);

	<span class="enscript-comment">/* Associate the new socket with the flow divert control block */</span>
	socket_lock(so, 0);
	so-&gt;so_fd_pcb = fd_cb;
	inp = sotoinpcb(so);
	inp-&gt;inp_last_outifp = ifp;
	<span class="enscript-keyword">if</span> (recv_data != NULL) {
		<span class="enscript-keyword">if</span> (sbappendstream(&amp;so-&gt;so_rcv, recv_data)) {
			sorwakeup(so);
		}
	}
	flow_divert_set_protosw(so);
	socket_unlock(so, 0);

	fd_cb-&gt;so = so;
	fd_cb-&gt;flags |= FLOW_DIVERT_TRANSFERRED;

	FDUNLOCK(fd_cb);

<span class="enscript-reference">done</span>:
	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (fd_cb != NULL) {
		FDRELEASE(fd_cb);	<span class="enscript-comment">/* Release the reference obtained via flow_divert_pcb_lookup */</span>
	}

	<span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">flow_divert_implicit_data_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, mbuf_t data, <span class="enscript-type">struct</span> sockaddr *to, mbuf_t control, <span class="enscript-type">struct</span> proc *p)
{
        <span class="enscript-type">struct</span> flow_divert_pcb  *fd_cb  = so-&gt;so_fd_pcb;
	<span class="enscript-type">struct</span> inpcb *inp;
        <span class="enscript-type">int</span> error = 0;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

        <span class="enscript-keyword">if</span> (fd_cb == NULL) {
                uint32_t fd_ctl_unit = necp_socket_get_flow_divert_control_unit(inp);
                <span class="enscript-keyword">if</span> (fd_ctl_unit &gt; 0) {
                        error = flow_divert_pcb_init(so, fd_ctl_unit);
                        fd_cb  = so-&gt;so_fd_pcb;
                        <span class="enscript-keyword">if</span> (error != 0 || fd_cb == NULL) {
                                <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                        }
                } <span class="enscript-keyword">else</span> {
                        error = ENETDOWN;
                        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
                }
        }
        <span class="enscript-keyword">return</span> flow_divert_data_out(so, flags, data, to, control, p);

<span class="enscript-reference">done</span>:
        <span class="enscript-keyword">if</span> (data) {
                mbuf_freem(data);
        }
        <span class="enscript-keyword">if</span> (control) {
                mbuf_free(control);
        }

        <span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">flow_divert_pcb_init</span>(<span class="enscript-type">struct</span> socket *so, uint32_t ctl_unit)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb;

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_FLOW_DIVERT) {
		<span class="enscript-keyword">return</span> EALREADY;
	}
		
	fd_cb = flow_divert_pcb_create(so);
	<span class="enscript-keyword">if</span> (fd_cb != NULL) {
		error = flow_divert_pcb_insert(fd_cb, ctl_unit);
		<span class="enscript-keyword">if</span> (error) {
			FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;pcb insert failed: %d&quot;</span>, error);
			FDRELEASE(fd_cb);
		} <span class="enscript-keyword">else</span> {
			fd_cb-&gt;control_group_unit = ctl_unit;
			so-&gt;so_fd_pcb = fd_cb;

			<span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_STREAM) {
				flow_divert_set_protosw(so);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_DGRAM) {
				flow_divert_set_udp_protosw(so);
			}

			FDLOG0(LOG_INFO, fd_cb, <span class="enscript-string">&quot;Created&quot;</span>);
		}
	} <span class="enscript-keyword">else</span> {
		error = ENOMEM;
	}

	<span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">flow_divert_token_set</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	uint32_t					ctl_unit		= 0;
	uint32_t					key_unit		= 0;
	uint32_t					flow_id			= 0;
	<span class="enscript-type">int</span>							error			= 0;
	mbuf_t						token			= NULL;

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_FLOW_DIVERT) {
		error = EALREADY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (g_init_result) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;flow_divert_init failed (%d), cannot use flow divert&quot;</span>, g_init_result);
		error = ENOPROTOOPT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> ((SOCK_TYPE(so) != SOCK_STREAM &amp;&amp; SOCK_TYPE(so) != SOCK_DGRAM) ||
	    (SOCK_PROTO(so) != IPPROTO_TCP &amp;&amp; SOCK_PROTO(so) != IPPROTO_UDP) ||
	    (SOCK_DOM(so) != PF_INET
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	     &amp;&amp; SOCK_DOM(so) != PF_INET6
#<span class="enscript-reference">endif</span>
		))
	{
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_STREAM &amp;&amp; SOCK_PROTO(so) == IPPROTO_TCP) {
			<span class="enscript-type">struct</span> tcpcb *tp = sototcpcb(so);
			<span class="enscript-keyword">if</span> (tp == NULL || tp-&gt;t_state != TCPS_CLOSED) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
	}

	error = soopt_getm(sopt, &amp;token);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = soopt_mcopyin(sopt, token);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_get_tlv(token, 0, FLOW_DIVERT_TLV_KEY_UNIT, <span class="enscript-keyword">sizeof</span>(key_unit), (<span class="enscript-type">void</span> *)&amp;key_unit, NULL);
	<span class="enscript-keyword">if</span> (!error) {
		key_unit = ntohl(key_unit);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != ENOENT) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to get the key unit from the token: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> {
		key_unit = 0;
	}

	error = flow_divert_packet_get_tlv(token, 0, FLOW_DIVERT_TLV_CTL_UNIT, <span class="enscript-keyword">sizeof</span>(ctl_unit), (<span class="enscript-type">void</span> *)&amp;ctl_unit, NULL);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to get the control socket unit from the token: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* A valid kernel control unit is required */</span>
	ctl_unit = ntohl(ctl_unit);
	<span class="enscript-keyword">if</span> (ctl_unit == 0 || ctl_unit &gt;= GROUP_COUNT_MAX) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Got an invalid control socket unit: %u&quot;</span>, ctl_unit);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	socket_unlock(so, 0);
	error = flow_divert_packet_verify_hmac(token, (key_unit != 0 ? key_unit : ctl_unit));
	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;HMAC verfication failed: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_get_tlv(token, 0, FLOW_DIVERT_TLV_FLOW_ID, <span class="enscript-keyword">sizeof</span>(flow_id), (<span class="enscript-type">void</span> *)&amp;flow_id, NULL);
	<span class="enscript-keyword">if</span> (error &amp;&amp; error != ENOENT) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;Failed to get the flow ID from the token: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (flow_id == 0) {
		error = flow_divert_pcb_init(so, ctl_unit);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-type">struct</span> flow_divert_pcb *fd_cb = so-&gt;so_fd_pcb;
			<span class="enscript-type">int</span> log_level = LOG_NOTICE;

			error = flow_divert_packet_get_tlv(token, 0, FLOW_DIVERT_TLV_LOG_LEVEL,
				                               <span class="enscript-keyword">sizeof</span>(log_level), &amp;log_level, NULL);
			<span class="enscript-keyword">if</span> (error == 0) {
				fd_cb-&gt;log_level = log_level;
			}
			error = 0;

			fd_cb-&gt;connect_token = token;
			token = NULL;
		}
	} <span class="enscript-keyword">else</span> {
		error = flow_divert_attach(so, flow_id, ctl_unit);
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (token != NULL) {
		mbuf_freem(token);
	}

	<span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">flow_divert_token_get</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	uint32_t					ctl_unit;
	<span class="enscript-type">int</span>							error						= 0;
	uint8_t						hmac[SHA_DIGEST_LENGTH];
	<span class="enscript-type">struct</span> flow_divert_pcb		*fd_cb						= so-&gt;so_fd_pcb;
	mbuf_t						token						= NULL;
	<span class="enscript-type">struct</span> flow_divert_group	*control_group				= NULL;

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_FLOW_DIVERT)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	VERIFY((so-&gt;so_flags &amp; SOF_FLOW_DIVERT) &amp;&amp; so-&gt;so_fd_pcb != NULL);

	<span class="enscript-keyword">if</span> (fd_cb-&gt;group == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = mbuf_gethdr(MBUF_DONTWAIT, MBUF_TYPE_HEADER, &amp;token);
	<span class="enscript-keyword">if</span> (error) {
		FDLOG(LOG_ERR, fd_cb, <span class="enscript-string">&quot;failed to allocate the header mbuf: %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	ctl_unit = htonl(fd_cb-&gt;group-&gt;ctl_unit);

	error = flow_divert_packet_append_tlv(token, FLOW_DIVERT_TLV_CTL_UNIT, <span class="enscript-keyword">sizeof</span>(ctl_unit), &amp;ctl_unit);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_append_tlv(token, FLOW_DIVERT_TLV_FLOW_ID, <span class="enscript-keyword">sizeof</span>(fd_cb-&gt;hash), &amp;fd_cb-&gt;hash);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	socket_unlock(so, 0);
	lck_rw_lock_shared(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (g_flow_divert_groups != NULL &amp;&amp; g_active_group_count &gt; 0 &amp;&amp;
	    fd_cb-&gt;control_group_unit &gt; 0 &amp;&amp; fd_cb-&gt;control_group_unit &lt; GROUP_COUNT_MAX)
	{
		control_group = g_flow_divert_groups[fd_cb-&gt;control_group_unit];
	}

	<span class="enscript-keyword">if</span> (control_group != NULL) {
		lck_rw_lock_shared(&amp;control_group-&gt;lck);
		ctl_unit = htonl(control_group-&gt;ctl_unit);
		error = flow_divert_packet_append_tlv(token, FLOW_DIVERT_TLV_KEY_UNIT, <span class="enscript-keyword">sizeof</span>(ctl_unit), &amp;ctl_unit);
		<span class="enscript-keyword">if</span> (!error) {
			error = flow_divert_packet_compute_hmac(token, control_group, hmac);
		}
		lck_rw_done(&amp;control_group-&gt;lck);
	} <span class="enscript-keyword">else</span> {
		error = ENOPROTOOPT;
	}

	lck_rw_done(&amp;g_flow_divert_group_lck);
	socket_lock(so, 0);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = flow_divert_packet_append_tlv(token, FLOW_DIVERT_TLV_HMAC, <span class="enscript-keyword">sizeof</span>(hmac), hmac);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = soopt_mcopyout(sopt, token);
	<span class="enscript-keyword">if</span> (error) {
		token = NULL;	<span class="enscript-comment">/* For some reason, soopt_mcopyout() frees the mbuf if it fails */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (token != NULL) {
		mbuf_freem(token);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_kctl_connect</span>(kern_ctl_ref kctlref __unused, <span class="enscript-type">struct</span> sockaddr_ctl *sac, <span class="enscript-type">void</span> **unitinfo)
{
	<span class="enscript-type">struct</span> flow_divert_group	*new_group	= NULL;
	<span class="enscript-type">int</span>				error		= 0;

	<span class="enscript-keyword">if</span> (sac-&gt;sc_unit &gt;= GROUP_COUNT_MAX) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	*unitinfo = NULL;

	MALLOC_ZONE(new_group, <span class="enscript-type">struct</span> flow_divert_group *, <span class="enscript-keyword">sizeof</span>(*new_group), M_FLOW_DIVERT_GROUP, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_group == NULL) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	memset(new_group, 0, <span class="enscript-keyword">sizeof</span>(*new_group));

	lck_rw_init(&amp;new_group-&gt;lck, flow_divert_mtx_grp, flow_divert_mtx_attr);
	RB_INIT(&amp;new_group-&gt;pcb_tree);
	new_group-&gt;ctl_unit = sac-&gt;sc_unit;
	MBUFQ_INIT(&amp;new_group-&gt;send_queue);

	lck_rw_lock_exclusive(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (g_flow_divert_groups == NULL) {
		MALLOC(g_flow_divert_groups,
		       <span class="enscript-type">struct</span> flow_divert_group **,
		       GROUP_COUNT_MAX * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> flow_divert_group *),
		       M_TEMP,
		       M_WAITOK | M_ZERO);
	}

	<span class="enscript-keyword">if</span> (g_flow_divert_groups == NULL) {
		error = ENOBUFS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (g_flow_divert_groups[sac-&gt;sc_unit] != NULL) {
		error = EALREADY;
	} <span class="enscript-keyword">else</span> {
		g_flow_divert_groups[sac-&gt;sc_unit] = new_group;
		g_active_group_count++;
	}

	lck_rw_done(&amp;g_flow_divert_group_lck);

	*unitinfo = new_group;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; new_group != NULL) {
		FREE_ZONE(new_group, <span class="enscript-keyword">sizeof</span>(*new_group), M_FLOW_DIVERT_GROUP);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_kctl_disconnect</span>(kern_ctl_ref kctlref __unused, uint32_t unit, <span class="enscript-type">void</span> *unitinfo)
{
	<span class="enscript-type">struct</span> flow_divert_group	*group	= NULL;
	errno_t						error	= 0;
	uint16_t					node	= 0;

	<span class="enscript-keyword">if</span> (unit &gt;= GROUP_COUNT_MAX) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	FDLOG(LOG_INFO, &amp;nil_pcb, <span class="enscript-string">&quot;disconnecting group %d&quot;</span>, unit);

	lck_rw_lock_exclusive(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">if</span> (g_flow_divert_groups == NULL || g_active_group_count == 0) {
		panic(<span class="enscript-string">&quot;flow divert group %u is disconnecting, but no groups are active (groups = %p, active count = %u&quot;</span>, unit,
		      g_flow_divert_groups, g_active_group_count);
	}

	group = g_flow_divert_groups[unit];

	<span class="enscript-keyword">if</span> (group != (<span class="enscript-type">struct</span> flow_divert_group *)unitinfo) {
		panic(<span class="enscript-string">&quot;group with unit %d (%p) != unit info (%p)&quot;</span>, unit, group, unitinfo);
	}

	<span class="enscript-keyword">if</span> (group != NULL) {
		flow_divert_close_all(group);
		<span class="enscript-keyword">if</span> (group-&gt;token_key != NULL) {
			memset(group-&gt;token_key, 0, group-&gt;token_key_size);
			FREE(group-&gt;token_key, M_TEMP);
			group-&gt;token_key = NULL;
			group-&gt;token_key_size = 0;
		}
		FREE_ZONE(group, <span class="enscript-keyword">sizeof</span>(*group), M_FLOW_DIVERT_GROUP);
		g_flow_divert_groups[unit] = NULL;
		g_active_group_count--;
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
	}

	<span class="enscript-keyword">if</span> (g_active_group_count == 0) {
		FREE(g_flow_divert_groups, M_TEMP);
		g_flow_divert_groups = NULL;
	}

	<span class="enscript-comment">/* Remove all signing IDs that point to this unit */</span>
	<span class="enscript-keyword">for</span> (node = 0; node &lt; g_signing_id_trie.nodes_count; node++) {
		<span class="enscript-keyword">if</span> (TRIE_NODE(&amp;g_signing_id_trie, node).group_unit == unit) {
			TRIE_NODE(&amp;g_signing_id_trie, node).group_unit = 0;
		}
	}

	lck_rw_done(&amp;g_flow_divert_group_lck);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">flow_divert_kctl_send</span>(kern_ctl_ref kctlref __unused, uint32_t unit __unused, <span class="enscript-type">void</span> *unitinfo, mbuf_t m, <span class="enscript-type">int</span> flags __unused)
{
	<span class="enscript-keyword">return</span> flow_divert_input(m, (<span class="enscript-type">struct</span> flow_divert_group *)unitinfo);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_kctl_rcvd</span>(kern_ctl_ref kctlref __unused, uint32_t unit __unused, <span class="enscript-type">void</span> *unitinfo, <span class="enscript-type">int</span> flags __unused)
{
	<span class="enscript-type">struct</span> flow_divert_group	*group	= (<span class="enscript-type">struct</span> flow_divert_group *)unitinfo;

	<span class="enscript-keyword">if</span> (!OSTestAndClear(GROUP_BIT_CTL_ENQUEUE_BLOCKED, &amp;group-&gt;atomic_bits)) {
		<span class="enscript-type">struct</span> flow_divert_pcb			*fd_cb;
		SLIST_HEAD(, flow_divert_pcb) 	tmp_list;

		lck_rw_lock_shared(&amp;g_flow_divert_group_lck);
		lck_rw_lock_exclusive(&amp;group-&gt;lck);

		<span class="enscript-keyword">while</span> (!MBUFQ_EMPTY(&amp;group-&gt;send_queue)) {
			mbuf_t next_packet;
			FDLOG0(LOG_DEBUG, &amp;nil_pcb, <span class="enscript-string">&quot;trying ctl_enqueuembuf again&quot;</span>);
			next_packet = MBUFQ_FIRST(&amp;group-&gt;send_queue);
			<span class="enscript-type">int</span> error = ctl_enqueuembuf(g_flow_divert_kctl_ref, group-&gt;ctl_unit, next_packet, CTL_DATA_EOR);
			<span class="enscript-keyword">if</span> (error) {
				FDLOG(LOG_DEBUG, &amp;nil_pcb, <span class="enscript-string">&quot;ctl_enqueuembuf returned an error: %d&quot;</span>, error);
				OSTestAndSet(GROUP_BIT_CTL_ENQUEUE_BLOCKED, &amp;group-&gt;atomic_bits);
				lck_rw_done(&amp;group-&gt;lck);
				lck_rw_done(&amp;g_flow_divert_group_lck);
				<span class="enscript-keyword">return</span>;
			}
			MBUFQ_DEQUEUE(&amp;group-&gt;send_queue, next_packet);
		}

		SLIST_INIT(&amp;tmp_list);

		RB_FOREACH(fd_cb, fd_pcb_tree, &amp;group-&gt;pcb_tree) {
			FDRETAIN(fd_cb);
			SLIST_INSERT_HEAD(&amp;tmp_list, fd_cb, tmp_list_entry);
		}

		lck_rw_done(&amp;group-&gt;lck);

		SLIST_FOREACH(fd_cb, &amp;tmp_list, tmp_list_entry) {
			FDLOCK(fd_cb);
			<span class="enscript-keyword">if</span> (fd_cb-&gt;so != NULL) {
				socket_lock(fd_cb-&gt;so, 0);
				<span class="enscript-keyword">if</span> (fd_cb-&gt;group != NULL) {
					flow_divert_send_buffered_data(fd_cb, FALSE);
				}
				socket_unlock(fd_cb-&gt;so, 0);
			}
			FDUNLOCK(fd_cb);
			FDRELEASE(fd_cb);
		}

		lck_rw_done(&amp;g_flow_divert_group_lck);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flow_divert_kctl_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> kern_ctl_reg	ctl_reg;
	<span class="enscript-type">int</span>			result;

	memset(&amp;ctl_reg, 0, <span class="enscript-keyword">sizeof</span>(ctl_reg));

	strlcpy(ctl_reg.ctl_name, FLOW_DIVERT_CONTROL_NAME, <span class="enscript-keyword">sizeof</span>(ctl_reg.ctl_name));
	ctl_reg.ctl_name[<span class="enscript-keyword">sizeof</span>(ctl_reg.ctl_name)-1] = <span class="enscript-string">'\0'</span>;
	ctl_reg.ctl_flags = CTL_FLAG_PRIVILEGED | CTL_FLAG_REG_EXTENDED;
	ctl_reg.ctl_sendsize = FD_CTL_SENDBUFF_SIZE;
	ctl_reg.ctl_recvsize = FD_CTL_RCVBUFF_SIZE;

	ctl_reg.ctl_connect = flow_divert_kctl_connect;
	ctl_reg.ctl_disconnect = flow_divert_kctl_disconnect;
	ctl_reg.ctl_send = flow_divert_kctl_send;
	ctl_reg.ctl_rcvd = flow_divert_kctl_rcvd;

	result = ctl_register(&amp;ctl_reg, &amp;g_flow_divert_kctl_ref);

	<span class="enscript-keyword">if</span> (result) {
		FDLOG(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;flow_divert_kctl_init - ctl_register failed: %d\n&quot;</span>, result);
		<span class="enscript-keyword">return</span> result;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">flow_divert_init</span>(<span class="enscript-type">void</span>)
{
	memset(&amp;nil_pcb, 0, <span class="enscript-keyword">sizeof</span>(nil_pcb));
	nil_pcb.log_level = LOG_NOTICE;

	g_tcp_protosw = pffindproto(AF_INET, IPPROTO_TCP, SOCK_STREAM);

	VERIFY(g_tcp_protosw != NULL);

	memcpy(&amp;g_flow_divert_in_protosw, g_tcp_protosw, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in_protosw));
	memcpy(&amp;g_flow_divert_in_usrreqs, g_tcp_protosw-&gt;pr_usrreqs, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in_usrreqs));

	g_flow_divert_in_usrreqs.pru_connect = flow_divert_connect_out;
	g_flow_divert_in_usrreqs.pru_connectx = flow_divert_connectx_out;
	g_flow_divert_in_usrreqs.pru_control = flow_divert_in_control;
	g_flow_divert_in_usrreqs.pru_disconnect = flow_divert_close;
	g_flow_divert_in_usrreqs.pru_disconnectx = flow_divert_disconnectx;
	g_flow_divert_in_usrreqs.pru_peeraddr = flow_divert_getpeername;
	g_flow_divert_in_usrreqs.pru_rcvd = flow_divert_rcvd;
	g_flow_divert_in_usrreqs.pru_send = flow_divert_data_out;
	g_flow_divert_in_usrreqs.pru_shutdown = flow_divert_shutdown;
	g_flow_divert_in_usrreqs.pru_sockaddr = flow_divert_getsockaddr;

	g_flow_divert_in_protosw.pr_usrreqs = &amp;g_flow_divert_in_usrreqs;
	g_flow_divert_in_protosw.pr_ctloutput = flow_divert_ctloutput;

	<span class="enscript-comment">/*
	 * Socket filters shouldn't attach/detach to/from this protosw
	 * since pr_protosw is to be used instead, which points to the
	 * real protocol; if they do, it is a bug and we should panic.
	 */</span>
	g_flow_divert_in_protosw.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	g_flow_divert_in_protosw.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;

	<span class="enscript-comment">/* UDP */</span>
	g_udp_protosw = pffindproto(AF_INET, IPPROTO_UDP, SOCK_DGRAM);
	VERIFY(g_udp_protosw != NULL);

	memcpy(&amp;g_flow_divert_in_udp_protosw, g_udp_protosw, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in_udp_protosw));
	memcpy(&amp;g_flow_divert_in_udp_usrreqs, g_udp_protosw-&gt;pr_usrreqs, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in_udp_usrreqs));

	g_flow_divert_in_udp_usrreqs.pru_connect = flow_divert_connect_out;
	g_flow_divert_in_udp_usrreqs.pru_connectx = flow_divert_connectx_out;
	g_flow_divert_in_udp_usrreqs.pru_control = flow_divert_in_control;
	g_flow_divert_in_udp_usrreqs.pru_disconnect = flow_divert_close;
	g_flow_divert_in_udp_usrreqs.pru_disconnectx = flow_divert_disconnectx;
	g_flow_divert_in_udp_usrreqs.pru_peeraddr = flow_divert_getpeername;
	g_flow_divert_in_udp_usrreqs.pru_rcvd = flow_divert_rcvd;
	g_flow_divert_in_udp_usrreqs.pru_send = flow_divert_data_out;
	g_flow_divert_in_udp_usrreqs.pru_shutdown = flow_divert_shutdown;
	g_flow_divert_in_udp_usrreqs.pru_sockaddr = flow_divert_getsockaddr;
	g_flow_divert_in_udp_usrreqs.pru_sosend_list = pru_sosend_list_notsupp;
	g_flow_divert_in_udp_usrreqs.pru_soreceive_list = pru_soreceive_list_notsupp;

	g_flow_divert_in_udp_protosw.pr_usrreqs = &amp;g_flow_divert_in_usrreqs;
	g_flow_divert_in_udp_protosw.pr_ctloutput = flow_divert_ctloutput;

	<span class="enscript-comment">/*
	* Socket filters shouldn't attach/detach to/from this protosw
	* since pr_protosw is to be used instead, which points to the
	* real protocol; if they do, it is a bug and we should panic.
	*/</span>
	g_flow_divert_in_udp_protosw.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	g_flow_divert_in_udp_protosw.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	g_tcp6_protosw = (<span class="enscript-type">struct</span> ip6protosw *)pffindproto(AF_INET6, IPPROTO_TCP, SOCK_STREAM);

	VERIFY(g_tcp6_protosw != NULL);

	memcpy(&amp;g_flow_divert_in6_protosw, g_tcp6_protosw, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in6_protosw));
	memcpy(&amp;g_flow_divert_in6_usrreqs, g_tcp6_protosw-&gt;pr_usrreqs, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in6_usrreqs));

	g_flow_divert_in6_usrreqs.pru_connect = flow_divert_connect_out;
	g_flow_divert_in6_usrreqs.pru_connectx = flow_divert_connectx6_out;
	g_flow_divert_in6_usrreqs.pru_control = flow_divert_in6_control;
	g_flow_divert_in6_usrreqs.pru_disconnect = flow_divert_close;
	g_flow_divert_in6_usrreqs.pru_disconnectx = flow_divert_disconnectx;
	g_flow_divert_in6_usrreqs.pru_peeraddr = flow_divert_getpeername;
	g_flow_divert_in6_usrreqs.pru_rcvd = flow_divert_rcvd;
	g_flow_divert_in6_usrreqs.pru_send = flow_divert_data_out;
	g_flow_divert_in6_usrreqs.pru_shutdown = flow_divert_shutdown;
	g_flow_divert_in6_usrreqs.pru_sockaddr = flow_divert_getsockaddr;

	g_flow_divert_in6_protosw.pr_usrreqs = &amp;g_flow_divert_in6_usrreqs;
	g_flow_divert_in6_protosw.pr_ctloutput = flow_divert_ctloutput;
	<span class="enscript-comment">/*
	 * Socket filters shouldn't attach/detach to/from this protosw
	 * since pr_protosw is to be used instead, which points to the
	 * real protocol; if they do, it is a bug and we should panic.
	 */</span>
	g_flow_divert_in6_protosw.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	g_flow_divert_in6_protosw.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;

	<span class="enscript-comment">/* UDP6 */</span>
	g_udp6_protosw = (<span class="enscript-type">struct</span> ip6protosw *)pffindproto(AF_INET6, IPPROTO_UDP, SOCK_DGRAM);

	VERIFY(g_udp6_protosw != NULL);

	memcpy(&amp;g_flow_divert_in6_udp_protosw, g_udp6_protosw, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in6_udp_protosw));
	memcpy(&amp;g_flow_divert_in6_udp_usrreqs, g_udp6_protosw-&gt;pr_usrreqs, <span class="enscript-keyword">sizeof</span>(g_flow_divert_in6_udp_usrreqs));

	g_flow_divert_in6_udp_usrreqs.pru_connect = flow_divert_connect_out;
	g_flow_divert_in6_udp_usrreqs.pru_connectx = flow_divert_connectx6_out;
	g_flow_divert_in6_udp_usrreqs.pru_control = flow_divert_in6_control;
	g_flow_divert_in6_udp_usrreqs.pru_disconnect = flow_divert_close;
	g_flow_divert_in6_udp_usrreqs.pru_disconnectx = flow_divert_disconnectx;
	g_flow_divert_in6_udp_usrreqs.pru_peeraddr = flow_divert_getpeername;
	g_flow_divert_in6_udp_usrreqs.pru_rcvd = flow_divert_rcvd;
	g_flow_divert_in6_udp_usrreqs.pru_send = flow_divert_data_out;
	g_flow_divert_in6_udp_usrreqs.pru_shutdown = flow_divert_shutdown;
	g_flow_divert_in6_udp_usrreqs.pru_sockaddr = flow_divert_getsockaddr;
	g_flow_divert_in6_udp_usrreqs.pru_sosend_list = pru_sosend_list_notsupp;
	g_flow_divert_in6_udp_usrreqs.pru_soreceive_list = pru_soreceive_list_notsupp;

	g_flow_divert_in6_udp_protosw.pr_usrreqs = &amp;g_flow_divert_in6_udp_usrreqs;
	g_flow_divert_in6_udp_protosw.pr_ctloutput = flow_divert_ctloutput;
	<span class="enscript-comment">/*
	* Socket filters shouldn't attach/detach to/from this protosw
	* since pr_protosw is to be used instead, which points to the
	* real protocol; if they do, it is a bug and we should panic.
	*/</span>
	g_flow_divert_in6_udp_protosw.pr_filter_head.tqh_first =
	    (<span class="enscript-type">struct</span> socket_filter *)(uintptr_t)0xdeadbeefdeadbeef;
	g_flow_divert_in6_udp_protosw.pr_filter_head.tqh_last =
	    (<span class="enscript-type">struct</span> socket_filter **)(uintptr_t)0xdeadbeefdeadbeef;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* INET6 */</span>

	flow_divert_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (flow_divert_grp_attr == NULL) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;lck_grp_attr_alloc_init failed&quot;</span>);
		g_init_result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	flow_divert_mtx_grp = lck_grp_alloc_init(FLOW_DIVERT_CONTROL_NAME, flow_divert_grp_attr);
	<span class="enscript-keyword">if</span> (flow_divert_mtx_grp == NULL) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;lck_grp_alloc_init failed&quot;</span>);
		g_init_result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	flow_divert_mtx_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (flow_divert_mtx_attr == NULL) {
		FDLOG0(LOG_ERR, &amp;nil_pcb, <span class="enscript-string">&quot;lck_attr_alloc_init failed&quot;</span>);
		g_init_result = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	g_init_result = flow_divert_kctl_init();
	<span class="enscript-keyword">if</span> (g_init_result) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	lck_rw_init(&amp;g_flow_divert_group_lck, flow_divert_mtx_grp, flow_divert_mtx_attr);

	memset(&amp;g_signing_id_trie, 0, <span class="enscript-keyword">sizeof</span>(g_signing_id_trie));
	g_signing_id_trie.root = NULL_TRIE_IDX;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (g_init_result != 0) {
		<span class="enscript-keyword">if</span> (flow_divert_mtx_attr != NULL) {
			lck_attr_free(flow_divert_mtx_attr);
			flow_divert_mtx_attr = NULL;
		}
		<span class="enscript-keyword">if</span> (flow_divert_mtx_grp != NULL) {
			lck_grp_free(flow_divert_mtx_grp);
			flow_divert_mtx_grp = NULL;
		}
		<span class="enscript-keyword">if</span> (flow_divert_grp_attr != NULL) {
			lck_grp_attr_free(flow_divert_grp_attr);
			flow_divert_grp_attr = NULL;
		}

		<span class="enscript-keyword">if</span> (g_flow_divert_kctl_ref != NULL) {
			ctl_deregister(g_flow_divert_kctl_ref);
			g_flow_divert_kctl_ref = NULL;
		}
	}
}
</pre>
<hr />
</body></html>