<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_var.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_var.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_var.h	8.4 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/tcp_var.h,v 1.56.2.8 2001/08/22 00:59:13 silby Exp $
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NETINET_TCP_VAR_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NETINET_TCP_VAR_H_</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_TCPCB_PTR</span>(x)			u_int32_t
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_TCPCB_LIST_HEAD</span>(name, type)	\
<span class="enscript-type">struct</span> name {				\
	u_int32_t	lh_first;	\
};
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_TCPCB_PTR</span>(x)			x
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_TCPCB_LIST_HEAD</span>(name, type)	LIST_HEAD(name, type)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_RETRANSHZ</span>	1000	<span class="enscript-comment">/* granularity of TCP timestamps, 1ms */</span>		
<span class="enscript-comment">/* Minimum time quantum within which the timers are coalesced */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_TIMER_10MS_QUANTUM</span>	(TCP_RETRANSHZ/100) <span class="enscript-comment">/* every 10ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_TIMER_100MS_QUANTUM</span>   (TCP_RETRANSHZ/10) <span class="enscript-comment">/* every 100ms */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_TIMER_500MS_QUANTUM</span>   (TCP_RETRANSHZ/2) <span class="enscript-comment">/* every 500ms */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_RETRANSHZ_TO_USEC</span> 1000

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_TIME_WAIT_SLOTS</span>   128     	<span class="enscript-comment">/* must be power of 2 */</span>

<span class="enscript-comment">/* Base RTT is stored for N_MIN_RTT_HISTORY slots. This is used to
 * estimate expected minimum RTT for delay based congestion control
 * algorithms.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_RTT_BASE</span>	5

<span class="enscript-comment">/* Always allow at least 4 packets worth of recv window when adjusting
 * recv window using inter-packet arrival jitter.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MIN_IAJ_WIN</span> 4

<span class="enscript-comment">/* A variation in delay of this many milliseconds is tolerable. This limit has to 
 * be low but greater than zero. We also use standard deviation on jitter to adjust
 * this limit for different link and connection types.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ALLOWED_IAJ</span> 5

<span class="enscript-comment">/* Ignore the first few packets on a connection until the ACK clock gets going
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IAJ_IGNORE_PKTCNT</span> 40

<span class="enscript-comment">/* Let the accumulated IAJ value increase by this threshold at most. This limit
 * will control how many ALLOWED_IAJ measurements a receiver will have to see
 * before opening the receive window
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ACC_IAJ_HIGH_THRESH</span> 100

<span class="enscript-comment">/* When accumulated IAJ reaches this value, the receiver starts to react by 
 * closing the window
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ACC_IAJ_REACT_LIMIT</span> 200

<span class="enscript-comment">/* If the number of small packets (smaller than IAJ packet size) seen on a 
 * connection is more than this threshold, reset the size and learn it again.
 * This is needed because the sender might send smaller segments after PMTU
 * discovery and the receiver has to learn the new size.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RESET_IAJ_SIZE_THRESH</span> 20

<span class="enscript-comment">/*
 * Adaptive timeout is a read/write timeout specified by the application to
 * get a socket event when the transport layer detects a stall in data 
 * transfer. The value specified is the number of probes that can be sent 
 * to the peer before generating an event. Since it is not specified as
 * a time value, the timeout will adjust based on the RTT seen on the link.
 * The timeout will start only when there is an indication that the read/write 
 * operation is not making progress. 
 *
 * If a write operation stalls, the probe will be retransmission of data.
 * If a read operation stalls, the probe will be a keep-alive packet.
 *
 * The maximum value of adaptive timeout is set to 10 which will allow
 * transmission of enough number of probes to the peer.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_ADAPTIVE_TIMEOUT_MAX</span>	10

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_CONNECTIVITY_PROBES_MAX</span>	5

<span class="enscript-comment">/*
 * Kernel variables for tcp.
 */</span>

<span class="enscript-comment">/* TCP segment queue entry */</span>
<span class="enscript-type">struct</span> tseg_qent {
	LIST_ENTRY(tseg_qent) tqe_q;
	<span class="enscript-type">int</span>	tqe_len;		<span class="enscript-comment">/* TCP segment data length */</span>
	<span class="enscript-type">struct</span>	tcphdr *tqe_th;		<span class="enscript-comment">/* a pointer to tcp header */</span>
	<span class="enscript-type">struct</span>	mbuf	*tqe_m;		<span class="enscript-comment">/* mbuf contains packet */</span>
};
<span class="enscript-function-name">LIST_HEAD</span>(tsegqe_head, tseg_qent);

<span class="enscript-type">struct</span> sackblk {
	tcp_seq start;		<span class="enscript-comment">/* start seq no. of sack block */</span>
	tcp_seq end;		<span class="enscript-comment">/* end seq no. */</span>
};

<span class="enscript-type">struct</span> sackhole {
	tcp_seq start;		<span class="enscript-comment">/* start seq no. of hole */</span>
	tcp_seq end;		<span class="enscript-comment">/* end seq no. */</span>
	tcp_seq rxmit;		<span class="enscript-comment">/* next seq. no in hole to be retransmitted */</span>
	u_int32_t rxmit_start;	<span class="enscript-comment">/* timestamp of first retransmission */</span>
	TAILQ_ENTRY(sackhole) scblink;	<span class="enscript-comment">/* scoreboard linkage */</span>
};

<span class="enscript-type">struct</span> sackhint {
	<span class="enscript-type">struct</span> sackhole	*nexthole;
	<span class="enscript-type">int</span>	sack_bytes_rexmit;
};

<span class="enscript-type">struct</span> tcp_rxt_seg {
	tcp_seq rx_start;
	tcp_seq rx_end;
	u_int16_t rx_count;
	u_int16_t rx_flags;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RXT_SPURIOUS</span>	0x1	<span class="enscript-comment">/* received DSACK notification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RXT_DSACK_FOR_TLP</span>	0x2
	SLIST_ENTRY(tcp_rxt_seg) rx_link;
};

<span class="enscript-type">struct</span> tcptemp {
	u_char	tt_ipgen[40]; <span class="enscript-comment">/* the size must be of max ip header, now IPv6 */</span>
	<span class="enscript-type">struct</span>	tcphdr tt_t;
};

<span class="enscript-type">struct</span> bwmeas {
	tcp_seq bw_start;		<span class="enscript-comment">/* start of bw measurement */</span>
	uint32_t bw_ts;		<span class="enscript-comment">/* timestamp when bw measurement started */</span>
	uint32_t bw_size;		<span class="enscript-comment">/* burst size in bytes for this bw measurement */</span>
	uint32_t bw_minsizepkts;	<span class="enscript-comment">/* Min burst size as segments */</span>
	uint32_t bw_maxsizepkts;	<span class="enscript-comment">/* Max burst size as segments */</span>
	uint32_t bw_minsize;	<span class="enscript-comment">/* Min size in bytes */</span>
	uint32_t bw_maxsize;	<span class="enscript-comment">/* Max size in bytes */</span>
	uint32_t bw_sndbw;		<span class="enscript-comment">/* Measured send bw */</span>
};

<span class="enscript-comment">/* MPTCP Data sequence map entry */</span>
<span class="enscript-type">struct</span> mpt_dsn_map {
	uint64_t		mpt_dsn;	<span class="enscript-comment">/* data seq num recvd */</span>
	uint32_t		mpt_sseq;	<span class="enscript-comment">/* relative subflow # */</span>
	uint16_t		mpt_len;	<span class="enscript-comment">/* length of mapping */</span>
	uint16_t		mpt_csum;	<span class="enscript-comment">/* checksum value if on */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">tcp6cb</span>		tcpcb  <span class="enscript-comment">/* for KAME src sync over BSD*'s */</span>

<span class="enscript-type">struct</span> tcp_ccstate {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> tcp_cubic_state {
			u_int32_t tc_last_max;  <span class="enscript-comment">/* cwnd at last loss */</span>
			u_int32_t tc_epoch_start; <span class="enscript-comment">/* TS of last loss */</span>
			u_int32_t tc_origin_point; <span class="enscript-comment">/* window at the start of an epoch */</span>
			u_int32_t tc_tcp_win; <span class="enscript-comment">/* computed tcp win */</span>
			u_int32_t tc_tcp_bytes_acked; <span class="enscript-comment">/* bytes acked */</span>
			u_int32_t tc_target_win; <span class="enscript-comment">/* cubic target win */</span>
			u_int32_t tc_avg_lastmax; <span class="enscript-comment">/* Average of last max */</span>
			u_int32_t tc_mean_deviation; <span class="enscript-comment">/* Mean absolute deviation */</span>
			<span class="enscript-type">float</span>     tc_epoch_period; <span class="enscript-comment">/* K parameter */</span>
		} _cubic_state_;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_last_max</span> __u__._cubic_state_.tc_last_max
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_epoch_start</span> __u__._cubic_state_.tc_epoch_start
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_origin_point</span> __u__._cubic_state_.tc_origin_point
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_tcp_win</span> __u__._cubic_state_.tc_tcp_win
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_tcp_bytes_acked</span> __u__._cubic_state_.tc_tcp_bytes_acked
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_epoch_period</span> __u__._cubic_state_.tc_epoch_period
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_target_win</span> __u__._cubic_state_.tc_target_win
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_avg_lastmax</span> __u__._cubic_state_.tc_avg_lastmax
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cub_mean_dev</span> __u__._cubic_state_.tc_mean_deviation
	} __u__;
};

<span class="enscript-comment">/*
 * Tcp control block, one per tcp; fields:
 * Organized for 16 byte cacheline efficiency.
 */</span>
<span class="enscript-type">struct</span> tcpcb {
	<span class="enscript-type">struct</span>	tsegqe_head t_segq;
	<span class="enscript-type">int</span>	t_dupacks;		<span class="enscript-comment">/* consecutive dup acks recd */</span>
	<span class="enscript-type">int</span>	t_state;		<span class="enscript-comment">/* state of this connection */</span>
	uint32_t t_timer[TCPT_NTIMERS];	<span class="enscript-comment">/* tcp timers */</span>
	<span class="enscript-type">struct</span> tcptimerentry tentry;	<span class="enscript-comment">/* entry in timer list */</span>

	<span class="enscript-type">struct</span>	inpcb *t_inpcb;		<span class="enscript-comment">/* back pointer to internet pcb */</span>
	uint32_t	t_flags;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_ACKNOW</span>	0x00001		<span class="enscript-comment">/* ack peer immediately */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_DELACK</span>	0x00002		<span class="enscript-comment">/* ack, but try to delay it */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NODELAY</span>	0x00004		<span class="enscript-comment">/* don't delay packets to coalesce */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOOPT</span>	0x00008		<span class="enscript-comment">/* don't use tcp options */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SENTFIN</span>	0x00010		<span class="enscript-comment">/* have sent FIN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_SCALE</span>	0x00020		<span class="enscript-comment">/* have/will request window scaling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_SCALE</span>	0x00040		<span class="enscript-comment">/* other side has requested scaling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_TSTMP</span>	0x00080		<span class="enscript-comment">/* have/will request timestamps */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_TSTMP</span>	0x00100		<span class="enscript-comment">/* a timestamp was received in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SACK_PERMIT</span>	0x00200		<span class="enscript-comment">/* other side said I could SACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NEEDSYN</span>	0x00400		<span class="enscript-comment">/* send SYN (implicit state) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NEEDFIN</span>	0x00800		<span class="enscript-comment">/* send FIN (implicit state) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOPUSH</span>	0x01000		<span class="enscript-comment">/* don't push */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_CC</span>	0x02000		<span class="enscript-comment">/* have/will request CC */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_CC</span>	0x04000		<span class="enscript-comment">/* a CC was received in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SENDCCNEW</span>	0x08000		<span class="enscript-comment">/* send CCnew instead of CC in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_MORETOCOME</span>	0x10000		<span class="enscript-comment">/* More data to be appended to sock */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_LOCAL</span>	0x20000		<span class="enscript-comment">/* connection to a host on local link */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RXWIN0SENT</span>	0x40000		<span class="enscript-comment">/* sent a receiver win 0 in response */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SLOWLINK</span>	0x80000		<span class="enscript-comment">/* route is a on a modem speed link */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_LASTIDLE</span>	0x100000	<span class="enscript-comment">/* connection was previously idle */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_FASTRECOVERY</span>	0x200000	<span class="enscript-comment">/* in NewReno Fast Recovery */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_WASFRECOVERY</span>	0x400000	<span class="enscript-comment">/* was in NewReno Fast Recovery */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SIGNATURE</span>	0x800000	<span class="enscript-comment">/* require MD5 digests (RFC2385) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_MAXSEGSNT</span>	0x1000000	<span class="enscript-comment">/* last segment sent was a full segment */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_ENABLE_ECN</span>	0x2000000	<span class="enscript-comment">/* Enable ECN */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_PMTUD</span>	0x4000000	<span class="enscript-comment">/* Perform Path MTU Discovery for this connection */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_CLOSING</span>	0x8000000	<span class="enscript-comment">/* pending tcp close */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_TSO</span>		0x10000000	<span class="enscript-comment">/* TCP Segment Offloading is enable on this connection */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_BLACKHOLE</span>	0x20000000	<span class="enscript-comment">/* Path MTU Discovery Black Hole detection */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_TIMER_ONLIST</span> 0x40000000	<span class="enscript-comment">/* pcb is on tcp_timer_list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_STRETCHACK</span>	0x80000000	<span class="enscript-comment">/* receiver is going to delay acks */</span>

	tcp_seq	snd_una;		<span class="enscript-comment">/* send unacknowledged */</span>
	tcp_seq	snd_max;		<span class="enscript-comment">/* highest sequence number sent;
					 * used to recognize retransmits
					 */</span>
	tcp_seq	snd_nxt;		<span class="enscript-comment">/* send next */</span>
	tcp_seq	snd_up;			<span class="enscript-comment">/* send urgent pointer */</span>

	tcp_seq	snd_wl1;		<span class="enscript-comment">/* window update seg seq number */</span>
	tcp_seq	snd_wl2;		<span class="enscript-comment">/* window update seg ack number */</span>
	tcp_seq	iss;			<span class="enscript-comment">/* initial send sequence number */</span>
	tcp_seq	irs;			<span class="enscript-comment">/* initial receive sequence number */</span>

	tcp_seq	rcv_nxt;		<span class="enscript-comment">/* receive next */</span>
	tcp_seq	rcv_adv;		<span class="enscript-comment">/* advertised window */</span>
	u_int32_t	rcv_wnd;		<span class="enscript-comment">/* receive window */</span>
	tcp_seq	rcv_up;			<span class="enscript-comment">/* receive urgent pointer */</span>

	u_int32_t	snd_wnd;	<span class="enscript-comment">/* send window */</span>
	u_int32_t	snd_cwnd;	<span class="enscript-comment">/* congestion-controlled window */</span>
	u_int32_t	snd_ssthresh;	<span class="enscript-comment">/* snd_cwnd size threshold for
					 * for slow start exponential to
					 * linear switch
					 */</span>
	tcp_seq	snd_recover;		<span class="enscript-comment">/* for use in NewReno Fast Recovery */</span>

	u_int	t_maxopd;		<span class="enscript-comment">/* mss plus options */</span>

	u_int32_t	t_rcvtime;	<span class="enscript-comment">/* time at which a packet was received */</span>
	u_int32_t	t_starttime;	<span class="enscript-comment">/* time connection was established */</span>
	<span class="enscript-type">int</span>	t_rtttime;		<span class="enscript-comment">/* tcp clock when rtt calculation was started */</span>
	tcp_seq	t_rtseq;		<span class="enscript-comment">/* sequence number being timed */</span>

	u_int32_t rfbuf_ts;		<span class="enscript-comment">/* recv buffer autoscaling timestamp */</span>
	u_int32_t rfbuf_cnt;		<span class="enscript-comment">/* recv buffer autoscaling byte count */</span>

	<span class="enscript-type">int</span>	t_rxtcur;		<span class="enscript-comment">/* current retransmit value (ticks) */</span>
	u_int	t_maxseg;		<span class="enscript-comment">/* maximum segment size */</span>
	<span class="enscript-type">int</span>	t_srtt;			<span class="enscript-comment">/* smoothed round-trip time */</span>
	<span class="enscript-type">int</span>	t_rttvar;		<span class="enscript-comment">/* variance in round-trip time */</span>

	u_int64_t	t_accsleep_ms;	<span class="enscript-comment">/* accumulated sleep time since last boot */</span>
	u_int16_t	t_reassqlen;	<span class="enscript-comment">/* length of reassembly queue */</span>
	u_int16_t	t_rxtshift;	<span class="enscript-comment">/* log(2) of rexmt exp. backoff */</span>
	u_int32_t	t_rttmin;	<span class="enscript-comment">/* minimum rtt allowed */</span>
	u_int32_t	t_rttbest;	<span class="enscript-comment">/* best rtt we've seen */</span>
	u_int32_t	t_rttcur;	<span class="enscript-comment">/* most recent value of rtt */</span>
	u_int32_t	t_rttupdated;	<span class="enscript-comment">/* number of times rtt sampled */</span>
	u_int32_t	t_rxt_conndroptime;	<span class="enscript-comment">/* retxmt conn gets dropped after this time, when set */</span>
	u_int32_t	t_rxtstart;	<span class="enscript-comment">/* time at which retransmission started */</span>
	u_int32_t	max_sndwnd;	<span class="enscript-comment">/* largest window peer has offered */</span>

	<span class="enscript-type">int</span>	t_softerror;		<span class="enscript-comment">/* possible error not yet reported */</span>
<span class="enscript-comment">/* out-of-band data */</span>
	<span class="enscript-type">char</span>	t_oobflags;		<span class="enscript-comment">/* have some */</span>
	<span class="enscript-type">char</span>	t_iobc;			<span class="enscript-comment">/* input character */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPOOB_HAVEDATA</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPOOB_HADDATA</span>	0x02
<span class="enscript-comment">/* RFC 1323 variables */</span>
	u_int8_t	snd_scale;	<span class="enscript-comment">/* window scaling for send window */</span>
	u_int8_t	rcv_scale;	<span class="enscript-comment">/* window scaling for recv window */</span>
	u_int8_t	request_r_scale; <span class="enscript-comment">/* pending window scaling */</span>
	u_int8_t	requested_s_scale;
	u_int8_t	tcp_cc_index;	<span class="enscript-comment">/* index of congestion control algorithm */</span>
	u_int8_t	t_adaptive_rtimo;	<span class="enscript-comment">/* Read timeout used as a multiple of RTT */</span>
	u_int8_t	t_adaptive_wtimo;	<span class="enscript-comment">/* Write timeout used as a multiple of RTT */</span>
	u_int8_t	t_stretchack_delayed;	<span class="enscript-comment">/* stretch ack delayed */</span>

<span class="enscript-comment">/* State for limiting early retransmits when SACK is not enabled */</span>
	u_int16_t	t_early_rexmt_count; <span class="enscript-comment">/* count of early rexmts */</span>
	u_int32_t	t_early_rexmt_win; <span class="enscript-comment">/* window for limiting early rexmts */</span> 

	u_int32_t	ts_recent;	<span class="enscript-comment">/* timestamp echo data */</span>

	u_int32_t	ts_recent_age;	<span class="enscript-comment">/* when last updated */</span>
	tcp_seq	last_ack_sent;
<span class="enscript-comment">/* RFC 1644 variables */</span>
	tcp_cc	cc_send;		<span class="enscript-comment">/* send connection count */</span>
	tcp_cc	cc_recv;		<span class="enscript-comment">/* receive connection count */</span>
<span class="enscript-comment">/* RFC 3465 variables */</span>
	u_int32_t	t_bytes_acked;	<span class="enscript-comment">/* ABC &quot;bytes_acked&quot; parameter */</span>

	<span class="enscript-type">int</span>	t_lastchain;		<span class="enscript-comment">/* amount of packets chained last time around */</span>
	u_int16_t	t_unacksegs;	<span class="enscript-comment">/* received but unacked segments for delaying acks */</span>
	u_int8_t	t_rexmtthresh;	<span class="enscript-comment">/* duplicate ack threshold for entering fast recovery */</span>
	u_int8_t	t_rtimo_probes; <span class="enscript-comment">/* number of adaptive rtimo probes sent */</span>
	u_int32_t	t_persist_timeout; <span class="enscript-comment">/* ZWP persistence limit as set by PERSIST_TIMEOUT */</span>
	u_int32_t	t_persist_stop;		<span class="enscript-comment">/* persistence limit deadline if triggered by ZWP */</span>
	u_int32_t	t_notsent_lowat;	<span class="enscript-comment">/* Low water for not sent data */</span>

<span class="enscript-comment">/* Receiver state for stretch-ack algorithm */</span>
	u_int32_t	rcv_unackwin;	<span class="enscript-comment">/* to measure win for stretching acks */</span>
	u_int32_t	rcv_by_unackwin; <span class="enscript-comment">/* bytes seen during the last ack-stretching win */</span>
	u_int32_t	rcv_nostrack_ts; <span class="enscript-comment">/* timestamp when stretch ack was disabled automatically */</span>
	u_int16_t	rcv_waitforss;	<span class="enscript-comment">/* wait for packets during slow-start */</span>
	u_int16_t		ecn_flags;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_SETUPSENT</span>		0x01	<span class="enscript-comment">/* Indicate we have sent ECN-SETUP SYN or SYN-ACK */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_SETUPRECEIVED</span>	0x02	<span class="enscript-comment">/* Indicate we have received ECN-SETUP SYN or SYN-ACK */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_SENDIPECT</span>		0x04	<span class="enscript-comment">/* Indicate we haven't sent or received non-ECN-setup SYN or SYN-ACK */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_SENDCWR</span>		0x08	<span class="enscript-comment">/* Indicate that the next non-retransmit should have the TCP CWR flag set */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_SENDECE</span>		0x10	<span class="enscript-comment">/* Indicate that the next packet should have the TCP ECE flag set */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_INRECOVERY</span>		0x20	<span class="enscript-comment">/* connection entered recovery after receiving ECE */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_RECV_ECN_CE</span>		0x40	<span class="enscript-comment">/* Received IPTOS_ECN_CE marking atleast once */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_RECV_ECN_ECE</span>	0x80	<span class="enscript-comment">/* Received ECE marking atleast once */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TE_ECN_ON</span>		(TE_SETUPSENT | TE_SETUPRECEIVED) <span class="enscript-comment">/* Indicate ECN was successfully negotiated on a connection) */</span>

<span class="enscript-comment">/* state for bad retransmit recovery */</span>
	u_int32_t	snd_cwnd_prev;	<span class="enscript-comment">/* cwnd prior to retransmit */</span>
	u_int32_t	snd_ssthresh_prev; <span class="enscript-comment">/* ssthresh prior to retransmit */</span>
	tcp_seq	snd_recover_prev;	<span class="enscript-comment">/* snd_recover prior to retransmit */</span>
	<span class="enscript-type">int</span>	t_srtt_prev;		<span class="enscript-comment">/* srtt prior to retransmit */</span>
	<span class="enscript-type">int</span>	t_rttvar_prev;		<span class="enscript-comment">/* rttvar prior to retransmit */</span>
	u_int32_t	t_badrexmt_time; <span class="enscript-comment">/* bad rexmt detection time */</span>
	
<span class="enscript-comment">/* Packet reordering metric */</span>
	u_int16_t	t_reorderwin; <span class="enscript-comment">/* Reordering late time offset */</span>

<span class="enscript-comment">/* SACK related state */</span>
	int16_t	snd_numholes;		<span class="enscript-comment">/* number of holes seen by sender */</span>
	tcp_seq sack_newdata;		<span class="enscript-comment">/* New data xmitted in this recovery
					   episode starts at this seq number */</span>
	TAILQ_HEAD(sackhole_head, sackhole) snd_holes;
						<span class="enscript-comment">/* SACK scoreboard (sorted) */</span>
	tcp_seq	snd_fack;		<span class="enscript-comment">/* last seq number(+1) sack'd by rcv'r*/</span>
	<span class="enscript-type">int</span>	rcv_numsacks;		<span class="enscript-comment">/* # distinct sack blks present */</span>
	<span class="enscript-type">struct</span> sackblk sackblks[MAX_SACK_BLKS]; <span class="enscript-comment">/* seq nos. of sack blocks */</span>
	<span class="enscript-type">struct</span> sackhint	sackhint;	<span class="enscript-comment">/* SACK scoreboard hint */</span>
	
	<span class="enscript-type">struct</span> mbuf	*t_pktlist_head; <span class="enscript-comment">/* First packet in transmit chain */</span>
	<span class="enscript-type">struct</span> mbuf	*t_pktlist_tail; <span class="enscript-comment">/* Last packet in transmit chain */</span>
	u_int32_t	t_pktlist_sentlen; <span class="enscript-comment">/* total bytes in transmit chain */</span>

	u_int32_t	t_keepidle;	<span class="enscript-comment">/* keepalive idle timer (override global if &gt; 0) */</span>
	u_int32_t	t_keepinit;	<span class="enscript-comment">/* connection timeout, i.e. idle time 
					in SYN_SENT or SYN_RECV state */</span>
	u_int32_t	t_keepintvl;	<span class="enscript-comment">/* interval between keepalives */</span>
	u_int32_t	t_keepcnt;	<span class="enscript-comment">/* number of keepalives before close */</span>

	u_int32_t	tso_max_segment_size;	<span class="enscript-comment">/* TSO maximum segment unit for NIC */</span>
	u_int16_t	t_pmtud_lastseg_size;	<span class="enscript-comment">/* size of the last sent segment */</span>
	u_int16_t	t_pmtud_saved_maxopd;	<span class="enscript-comment">/* MSS saved before performing PMTU-D BlackHole detection */</span>
	u_int32_t	t_pmtud_start_ts;	<span class="enscript-comment">/* Time of PMTUD blackhole detection */</span>
	
	<span class="enscript-type">struct</span>
	{
		u_int32_t	rxduplicatebytes;
		u_int32_t	rxoutoforderbytes;
		u_int32_t	txretransmitbytes;
		u_int8_t	synrxtshift;
		u_int8_t	unused;
		u_int16_t	unused_pad_to_8;
	} t_stat;
	
	<span class="enscript-comment">/* Background congestion related state */</span>
	uint32_t	rtt_hist[N_RTT_BASE];	<span class="enscript-comment">/* history of minimum RTT */</span>
	uint32_t	rtt_count;		<span class="enscript-comment">/* Number of RTT samples in recent base history */</span>
	uint32_t	bg_ssthresh;		<span class="enscript-comment">/* Slow start threshold until delay increases */</span>
	uint32_t	t_flagsext;		<span class="enscript-comment">/* Another field to accommodate more flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_RXTFINDROP</span>	0x1			<span class="enscript-comment">/* Drop conn after retransmitting FIN 3 times */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_RCVUNACK_WAITSS</span>	0x2		<span class="enscript-comment">/* set when the receiver should not stretch acks */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_BWMEAS_INPROGRESS</span>	0x4		<span class="enscript-comment">/* Indicate BW meas is happening */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_MEASURESNDBW</span>		0x8		<span class="enscript-comment">/* Measure send bw on this connection */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_LRO_OFFLOADED</span>	0x10		<span class="enscript-comment">/* Connection LRO offloaded */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_SACK_ENABLE</span>		0x20		<span class="enscript-comment">/* SACK is enabled */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_RECOMPUTE_RTT</span>	0x40		<span class="enscript-comment">/* recompute RTT after spurious retransmit */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_DETECT_READSTALL</span>	0x80		<span class="enscript-comment">/* Used to detect a stall during read operation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_RECV_THROTTLE</span>	0x100		<span class="enscript-comment">/* Input throttling active */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOSTRETCHACK</span>		0x200		<span class="enscript-comment">/* ack every other packet */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_STREAMEOW</span>		0x400		<span class="enscript-comment">/* Last packet was small indicating end of write */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOTIMEWAIT</span>		0x800		<span class="enscript-comment">/* Avoid going into time-wait */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SENT_TLPROBE</span>		0x1000		<span class="enscript-comment">/* Sent data in PTO */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_PKTS_REORDERED</span>	0x2000		<span class="enscript-comment">/* Detected reordering */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_DELAY_RECOVERY</span>	0x4000		<span class="enscript-comment">/* delay fast recovery */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TF_FORCE</span>		0x8000		<span class="enscript-comment">/* force 1 byte out */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_DISABLE_STRETCHACK</span>	0x10000		<span class="enscript-comment">/* auto-disable stretch ack */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOBLACKHOLE_DETECTION</span> 0x20000	<span class="enscript-comment">/* Disable PMTU blackhole detection */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_DISABLE_DSACK</span>	0x40000		<span class="enscript-comment">/* Ignore DSACK due to n/w duplication */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RESCUE_RXT</span>		0x80000		<span class="enscript-comment">/* SACK rescue retransmit */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_CWND_NONVALIDATED</span>	0x100000	<span class="enscript-comment">/* cwnd non validated */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_PROBING</span>		0x200000	<span class="enscript-comment">/* Trigger probe timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_FASTOPEN</span>		0x400000	<span class="enscript-comment">/* TCP Fastopen is enabled */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
	<span class="enscript-comment">/* Inter-arrival jitter related state */</span>
	uint32_t 	iaj_rcv_ts;		<span class="enscript-comment">/* tcp clock when the first packet was received */</span>
	uint16_t	iaj_size;		<span class="enscript-comment">/* Size of packet for iaj measurement */</span>
	uint8_t		iaj_small_pkt;		<span class="enscript-comment">/* Count of packets smaller than iaj_size */</span>
	uint8_t		t_pipeack_ind;		<span class="enscript-comment">/* index for next pipeack sample */</span>
	uint16_t	iaj_pktcnt;		<span class="enscript-comment">/* packet count, to avoid throttling initially */</span>
	uint16_t	acc_iaj;		<span class="enscript-comment">/* Accumulated iaj */</span>
	tcp_seq 	iaj_rwintop;		<span class="enscript-comment">/* recent max advertised window */</span>
	uint32_t	avg_iaj;		<span class="enscript-comment">/* Mean */</span>
	uint32_t	std_dev_iaj;		<span class="enscript-comment">/* Standard deviation */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>
	<span class="enscript-type">struct</span> bwmeas	*t_bwmeas;		<span class="enscript-comment">/* State for bandwidth measurement */</span> 
	uint32_t	t_lropktlen;		<span class="enscript-comment">/* Bytes in a LRO frame */</span>
	tcp_seq		t_idleat;		<span class="enscript-comment">/* rcv_nxt at idle time */</span>
	TAILQ_ENTRY(tcpcb) t_twentry;		<span class="enscript-comment">/* link for time wait queue */</span>
	<span class="enscript-type">struct</span> tcp_ccstate	*t_ccstate;	<span class="enscript-comment">/* congestion control related state */</span>
<span class="enscript-comment">/* Tail loss probe related state */</span>
	tcp_seq		t_tlphighrxt;		<span class="enscript-comment">/* snd_nxt after PTO */</span>
	u_int32_t	t_tlpstart;		<span class="enscript-comment">/* timestamp at PTO */</span>
<span class="enscript-comment">/* DSACK data receiver state */</span>
	tcp_seq		t_dsack_lseq;		<span class="enscript-comment">/* DSACK left sequence */</span>
	tcp_seq		t_dsack_rseq;		<span class="enscript-comment">/* DSACK right sequence */</span>
<span class="enscript-comment">/* DSACK data sender state */</span>
	SLIST_HEAD(tcp_rxt_seghead, tcp_rxt_seg) t_rxt_segments;
	tcp_seq		t_dsack_lastuna;	<span class="enscript-comment">/* snd_una when last recovery episode started */</span>
<span class="enscript-comment">/* state for congestion window validation (draft-ietf-tcpm-newcwv-07) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_PIPEACK_SAMPLE_COUNT</span>	3
	u_int32_t	t_pipeack_sample[TCP_PIPEACK_SAMPLE_COUNT];	<span class="enscript-comment">/* pipeack, bytes acked within RTT */</span>
	tcp_seq		t_pipeack_lastuna; <span class="enscript-comment">/* una when pipeack measurement started */</span>
	u_int32_t	t_pipeack;
	u_int32_t	t_lossflightsize;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	u_int32_t	t_mpflags;		<span class="enscript-comment">/* flags for multipath TCP */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_PREESTABLISHED</span> 	0x00000001 <span class="enscript-comment">/* conn in pre-established state */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SENT_KEYS</span>		0x00000002 <span class="enscript-comment">/* indicates that keys were sent */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_MPTCP_TRUE</span>		0x00000004 <span class="enscript-comment">/* negotiated MPTCP successfully */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_MPTCP_RCVD_KEY</span>	0x00000008 <span class="enscript-comment">/* state for 3-way handshake */</span>	
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SND_MPPRIO</span>		0x00000010 <span class="enscript-comment">/* send priority of subflow */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SND_REM_ADDR</span>	0x00000020 <span class="enscript-comment">/* initiate address removal */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_UNUSED</span>		0x00000040 <span class="enscript-comment">/* address addition acked by peer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_JOINED_FLOW</span>	0x00000080 <span class="enscript-comment">/* Indicates additional flow */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_BACKUP_PATH</span>	0x00000100 <span class="enscript-comment">/* Indicates backup path */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_MPTCP_ACKNOW</span>	0x00000200 <span class="enscript-comment">/* Send Data ACK */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SEND_DSN</span>		0x00000400 <span class="enscript-comment">/* Send DSN mapping */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SEND_DFIN</span>		0x00000800 <span class="enscript-comment">/* Send Data FIN */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_RECV_DFIN</span>		0x00001000 <span class="enscript-comment">/* Recv Data FIN */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SENT_JOIN</span>		0x00002000 <span class="enscript-comment">/* Sent Join */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_RECVD_JOIN</span>		0x00004000 <span class="enscript-comment">/* Received Join */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_RESET</span>		0x00008000 <span class="enscript-comment">/* Send RST */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_TCP_FALLBACK</span>	0x00010000 <span class="enscript-comment">/* Fallback to TCP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_FASTCLOSE</span>		0x00020000 <span class="enscript-comment">/* Send Fastclose option */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_EMBED_DSN</span>		0x00040000 <span class="enscript-comment">/* tp has DSN mapping */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_MPTCP_READY</span>	0x00080000 <span class="enscript-comment">/* Can send DSS options on data */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_INFIN_SENT</span>		0x00100000 <span class="enscript-comment">/* Sent infinite mapping */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_SND_MPFAIL</span>		0x00200000 <span class="enscript-comment">/* Received mapping csum failure */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_FASTJOIN_SEND</span>	0x00400000 <span class="enscript-comment">/* Fast join early data send */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_FASTJOINBY2_SEND</span>	0x00800000 <span class="enscript-comment">/* Fast join send after 3 WHS */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TMPF_MPCAP_RETRANSMIT</span>	0x01000000 <span class="enscript-comment">/* Retransmission of 3rd ACK */</span>

	tcp_seq			t_mpuna;	<span class="enscript-comment">/* unacknowledged sequence */</span>
	<span class="enscript-type">void</span>			*t_mptcb;	<span class="enscript-comment">/* pointer to MPTCP TCB */</span>
	<span class="enscript-type">struct</span> mpt_dsn_map	t_rcv_map;	<span class="enscript-comment">/* Receive mapping list */</span>
	u_int8_t		t_local_aid;	<span class="enscript-comment">/* Addr Id for authentication */</span>
	u_int8_t		t_rem_aid;	<span class="enscript-comment">/* Addr ID of another subflow */</span>
	u_int8_t		t_mprxtshift;	<span class="enscript-comment">/* join retransmission */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_OFFER_COOKIE</span>	0x01 <span class="enscript-comment">/* We will offer a cookie */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_COOKIE_VALID</span>	0x02 <span class="enscript-comment">/* The received cookie is valid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_COOKIE_REQ</span>	0x04 <span class="enscript-comment">/* Client requested a new cookie */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_COOKIE_SENT</span>	0x08 <span class="enscript-comment">/* Client did send a cookie in the SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_SYN_LOSS</span>		0x10 <span class="enscript-comment">/* A SYN-loss triggered a fallback to regular TCP on the client-side */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_NO_RCVPROBING</span>	0x20 <span class="enscript-comment">/* This network is guaranteed to support TFO in the downstream direction */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_F_NO_SNDPROBING</span>	0x40 <span class="enscript-comment">/* This network is guaranteed to support TFO in the upstream direction */</span>
	u_int8_t		t_tfo_flags;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_SYNDATA_RCV</span>	0x01 <span class="enscript-comment">/* SYN+data has been received */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_COOKIEREQ_RECV</span>	0x02 <span class="enscript-comment">/* TFO-cookie request received */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_COOKIE_SENT</span>	0x04 <span class="enscript-comment">/* TFO-cookie announced in SYN/ACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_COOKIE_INVALID</span>	0x08 <span class="enscript-comment">/* Received TFO-cookie is invalid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_COOKIE_REQ</span>	0x10 <span class="enscript-comment">/* TFO-cookie requested within the SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_COOKIE_RCV</span>	0x20 <span class="enscript-comment">/* TFO-cookie received in SYN/ACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_SYN_DATA_SENT</span>	0x40 <span class="enscript-comment">/* SYN+data sent */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_SYN_DATA_ACKED</span>	0x80 <span class="enscript-comment">/* SYN+data has been acknowledged in SYN/ACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_S_SYN_LOSS</span>		0x0100 <span class="enscript-comment">/* SYN+TFO has been lost - fallback to regular TCP */</span>
	u_int16_t		t_tfo_stats;

	u_int8_t		t_tfo_probes; <span class="enscript-comment">/* TFO-probes we did send */</span>
<span class="enscript-comment">/*
 * This here is the TFO-probing state-machine. Transitions are as follows:
 *
 * Current state: PROBE_NONE
 *		  Event: SYN+DATA acknowledged
 *			 Action: Transition to PROBE_PROBING and set keepalive-timer
 *
 * Current state: PROBE_PROBING (initial state)
 *		  Event: Receive data
 *			 Action: Transition to PROBE_NONE and cancel keepalive-timer
 *		  Event: Receive ACK that does not indicate a hole
 *			 Action: Transition to PROBE_NONE and cancel keepalive-timer
 *		  Event: Receive ACK that indicates a hole
 *			 Action: Transition to PROBE_WAIT_DATA and set a short timer
 *				 to wait for the final segment.
 *		  Event: Keepalive-timeout (did not receive any segment)
 *			 Action: Signal ETIMEDOUT as with regular keepalive-timers
 *
 * Current state: PROBE_WAIT_DATA
 *		  Event: Receive data
 *			 Action: Transition to PROBE_NONE and cancel keepalive-timer
 *		  Event: Data-timeout (did not receive the expected data)
 *			 Action: Signal ENODATA up to the app and close everything.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_PROBE_NONE</span>		0 <span class="enscript-comment">/* Not probing now */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_PROBE_PROBING</span>	1 <span class="enscript-comment">/* Sending out TCP-keepalives waiting for reply */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_PROBE_WAIT_DATA</span>	2 <span class="enscript-comment">/* Received reply, waiting for data */</span>
	u_int8_t		t_tfo_probe_state;
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IN_FASTRECOVERY</span>(tp)	(tp-&gt;t_flags &amp; TF_FASTRECOVERY)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SACK_ENABLED</span>(tp)	(tp-&gt;t_flagsext &amp; TF_SACK_ENABLE)

<span class="enscript-comment">/*
 * If the connection is in a throttled state due to advisory feedback from 
 * the interface output queue, reset that state. We do this in favor
 * of entering recovery because the data transfer during recovery 
 * should be just a trickle and it will help to improve performance.
 * We also do not want to back off twice in the same RTT.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ENTER_FASTRECOVERY</span>(_tp_) do {				\
	(_tp_)-&gt;t_flags |= TF_FASTRECOVERY;			\
	<span class="enscript-keyword">if</span> (INP_IS_FLOW_CONTROLLED((_tp_)-&gt;t_inpcb))		\
		inp_reset_fc_state((_tp_)-&gt;t_inpcb);		\
	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))			\
		tcp_rxtseg_clean(tp);				\
} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">EXIT_FASTRECOVERY</span>(_tp_) do {		\
	(_tp_)-&gt;t_flags &amp;= ~TF_FASTRECOVERY;	\
	(_tp_)-&gt;t_dupacks = 0;			\
	(_tp_)-&gt;t_rexmtthresh = tcprexmtthresh;	\
	(_tp_)-&gt;t_bytes_acked = 0;		\
	(_tp_)-&gt;ecn_flags &amp;= ~TE_INRECOVERY;	\
	(_tp_)-&gt;t_timer[TCPT_PTO] = 0;		\
	(_tp_)-&gt;t_flagsext &amp;= ~TF_RESCUE_RXT;	\
	(_tp_)-&gt;t_lossflightsize = 0;		\
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/*
 * When the number of duplicate acks received is less than 
 * the retransmit threshold, use Limited Transmit algorithm
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcprexmtthresh;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ALLOW_LIMITED_TRANSMIT</span>(_tp_) \
	((_tp_)-&gt;t_dupacks &gt; 0 &amp;&amp; \
	(_tp_)-&gt;t_dupacks &lt; (_tp_)-&gt;t_rexmtthresh &amp;&amp; \
	((_tp_)-&gt;t_flagsext &amp; (TF_PKTS_REORDERED|TF_DELAY_RECOVERY)) \
	    != (TF_PKTS_REORDERED|TF_DELAY_RECOVERY))

<span class="enscript-comment">/*
 * This condition is true is timestamp option is supported
 * on a connection.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TSTMP_SUPPORTED</span>(_tp_) \
	(((_tp_)-&gt;t_flags &amp; (TF_REQ_TSTMP|TF_RCVD_TSTMP)) == \
		(TF_REQ_TSTMP|TF_RCVD_TSTMP))

<span class="enscript-comment">/*
 * This condition is true if window scale option is supported
 * on a connection
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_WINDOW_SCALE_ENABLED</span>(_tp_) \
	(((_tp_)-&gt;t_flags &amp; (TF_RCVD_SCALE|TF_REQ_SCALE)) == \
		(TF_RCVD_SCALE|TF_REQ_SCALE))

<span class="enscript-comment">/* Is ECN enabled end-to-end */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_ECN_ENABLED</span>(_tp_) \
	(((_tp_)-&gt;ecn_flags &amp; (TE_ECN_ON)) == (TE_ECN_ON))

<span class="enscript-comment">/*
 * Gives number of bytes acked by this ack
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BYTES_ACKED</span>(_th_, _tp_) \
	((_th_)-&gt;th_ack - (_tp_)-&gt;snd_una)

<span class="enscript-comment">/* Returns true if a DSACK option should be sent */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_SEND_DSACK_OPT</span>(_tp_) \
	((_tp_)-&gt;t_dsack_lseq &gt; 0 &amp;&amp; (_tp_)-&gt;t_dsack_rseq &gt; 0)

<span class="enscript-comment">/* Check if DSACK option should be processed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_DSACK_ENABLED</span>(tp)	(tcp_dsack_enable == 1 &amp;&amp; \
    !(tp-&gt;t_flagsext &amp; TF_DISABLE_DSACK))

<span class="enscript-comment">/*
 * Returns true if a DSACK sequence is within the max send window that will
 * be accepted. In order to set a window to validate sequence numbers, the
 * max send window within which a DSACK option is processed is limited.
 *
 * We need to choose a maximum window to check if the sequence number is
 * within the window. One arbitrary choice is 256 * MSS because if the
 * window is as large as 256 segments it might be big enough to ignore the
 * DSACK option. Choosing a much larger limit means that the memory for
 * retransmit segments can be held for a longer time.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_DSACK_MAX_SEND_WINDOW</span>(_tp_) ((_tp_)-&gt;t_maxseg &lt;&lt; 8)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCP_DSACK_SEQ_IN_WINDOW</span>(_tp_, _seq_, _una_) \
    (SEQ_LEQ((_seq_), (_tp_)-&gt;snd_max) &amp;&amp; \
    SEQ_GEQ((_seq_), ((_una_) - TCP_DSACK_MAX_SEND_WINDOW(_tp_))))


<span class="enscript-type">enum</span> tcp_cc_event {
	TCP_CC_CWND_INIT,	<span class="enscript-comment">/* 0 */</span>
	TCP_CC_INSEQ_ACK_RCVD,	<span class="enscript-comment">/* 1 */</span>
	TCP_CC_ACK_RCVD,	<span class="enscript-comment">/* 2 */</span>
	TCP_CC_ENTER_FASTRECOVERY, <span class="enscript-comment">/* 3 */</span>
	TCP_CC_IN_FASTRECOVERY,	<span class="enscript-comment">/* 4 */</span>
	TCP_CC_EXIT_FASTRECOVERY,  <span class="enscript-comment">/* 5 */</span>
	TCP_CC_PARTIAL_ACK,	<span class="enscript-comment">/* 6 */</span>
	TCP_CC_IDLE_TIMEOUT,	<span class="enscript-comment">/* 7 */</span>
	TCP_CC_REXMT_TIMEOUT,	<span class="enscript-comment">/* 8 */</span>
	TCP_CC_ECN_RCVD,	<span class="enscript-comment">/* 9 */</span>
	TCP_CC_BAD_REXMT_RECOVERY, <span class="enscript-comment">/* 10 */</span>
	TCP_CC_OUTPUT_ERROR,	<span class="enscript-comment">/* 11 */</span>
	TCP_CC_CHANGE_ALGO,	<span class="enscript-comment">/* 12 */</span>
	TCP_CC_FLOW_CONTROL,	<span class="enscript-comment">/* 13 */</span>
	TCP_CC_SUSPEND,		<span class="enscript-comment">/* 14 */</span>
	TCP_CC_LIMITED_TRANSMIT, <span class="enscript-comment">/* 15 */</span>
	TCP_CC_EARLY_RETRANSMIT, <span class="enscript-comment">/* 16 */</span>
	TCP_CC_TLP_RECOVERY,	<span class="enscript-comment">/* 17 */</span>
	TCP_CC_TLP_RECOVER_LASTPACKET, <span class="enscript-comment">/* 18 */</span>
	TCP_CC_DELAY_FASTRECOVERY, <span class="enscript-comment">/* 19 */</span>
	TCP_CC_TLP_IN_FASTRECOVERY, <span class="enscript-comment">/* 20 */</span>
	TCP_CC_DSACK_BAD_REXMT	<span class="enscript-comment">/* 21 */</span>
};

<span class="enscript-comment">/*
 * Structure to hold TCP options that are only used during segment
 * processing (in tcp_input), but not held in the tcpcb.
 * It's basically used to reduce the number of parameters
 * to tcp_dooptions.
 */</span>
<span class="enscript-type">struct</span> tcpopt {
	u_int32_t	to_flags;		<span class="enscript-comment">/* which options are present */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TOF_TS</span>		0x0001		<span class="enscript-comment">/* timestamp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_MSS</span>		0x0010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_SCALE</span>	0x0020
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_SIGNATURE</span>	0x0040	<span class="enscript-comment">/* signature option present */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_SIGLEN</span>	0x0080	<span class="enscript-comment">/* signature length valid (RFC2385) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_SACK</span>	0x0100		<span class="enscript-comment">/* Peer sent SACK option */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_MPTCP</span>	0x0200	<span class="enscript-comment">/* MPTCP options to be dropped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TOF_TFO</span>		0x0400  <span class="enscript-comment">/* TFO cookie option present */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TOF_TFOREQ</span>	0x0800  <span class="enscript-comment">/* TFO cookie request present */</span>
	u_int32_t		to_tsval;
	u_int32_t		to_tsecr;
	u_int16_t	to_mss;
	u_int8_t	to_requested_s_scale;
	u_int8_t	to_nsacks;	<span class="enscript-comment">/* number of SACK blocks */</span>
	u_char		*to_sacks;	<span class="enscript-comment">/* pointer to the first SACK blocks */</span>
	u_char		*to_tfo;	<span class="enscript-comment">/* pointer to the TFO cookie */</span>
};

<span class="enscript-comment">/*
 * The TAO cache entry which is stored in the protocol family specific
 * portion of the route metrics.
 */</span>
<span class="enscript-type">struct</span> rmxp_tao {
	tcp_cc	tao_cc;			<span class="enscript-comment">/* latest CC in valid SYN */</span>
	tcp_cc	tao_ccsent;		<span class="enscript-comment">/* latest CC sent to peer */</span>
	u_short	tao_mssopt;		<span class="enscript-comment">/* peer's cached MSS */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
	u_short	tao_flags;		<span class="enscript-comment">/* cache status flags */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TAOF_DONT</span>	0x0001		<span class="enscript-comment">/* peer doesn't understand rfc1644 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TAOF_OK</span>		0x0002		<span class="enscript-comment">/* peer does understand rfc1644 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TAOF_UNDEF</span>	0		<span class="enscript-comment">/* we don't know yet */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* notyet */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-function-name">rmx_taop</span>(r)	((struct rmxp_tao *)(r).rmx_filler)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">intotcpcb</span>(ip)	((struct tcpcb *)(ip)-&gt;inp_ppcb)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">sototcpcb</span>(so)	(intotcpcb(sotoinpcb(so)))

<span class="enscript-comment">/*
 * The rtt measured is in milliseconds as the timestamp granularity is 
 * a millisecond. The smoothed round-trip time and estimated variance
 * are stored as fixed point numbers scaled by the values below.
 * For convenience, these scales are also used in smoothing the average
 * (smoothed = (1/scale)sample + ((scale-1)/scale)smoothed).
 * With these scales, srtt has 5 bits to the right of the binary point,
 * and thus an &quot;ALPHA&quot; of 0.875.  rttvar has 4 bits to the right of the
 * binary point, and is smoothed with an ALPHA of 0.75.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RTT_SCALE</span>		32	<span class="enscript-comment">/* multiplier for srtt; 3 bits frac. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RTT_SHIFT</span>		5	<span class="enscript-comment">/* shift for srtt; 5 bits frac. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RTTVAR_SCALE</span>	16	<span class="enscript-comment">/* multiplier for rttvar; 4 bits */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_RTTVAR_SHIFT</span>	4	<span class="enscript-comment">/* shift for rttvar; 4 bits */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_DELTA_SHIFT</span>		2	<span class="enscript-comment">/* see tcp_input.c */</span>

<span class="enscript-comment">/* TFO-specific defines */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_COOKIE_LEN_MIN</span>	4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_COOKIE_LEN_DEFAULT</span>	8
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TFO_COOKIE_LEN_MAX</span>	16

<span class="enscript-comment">/*
 * The initial retransmission should happen at rtt + 4 * rttvar.
 * Because of the way we do the smoothing, srtt and rttvar
 * will each average +1/2 tick of bias.  When we compute
 * the retransmit timer, we want 1/2 tick of rounding and
 * 1 extra tick because of +-1/2 tick uncertainty in the
 * firing of the timer.  The bias will give us exactly the
 * 1.5 tick we need.  But, because the bias is
 * statistical, we have to test that we don't drop below
 * the minimum feasible timer (which is 2 ticks).
 * This version of the macro adapted from a paper by Lawrence
 * Brakmo and Larry Peterson which outlines a problem caused
 * by insufficient precision in the original implementation,
 * which results in inappropriately large RTO values for very
 * fast networks.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_REXMTVAL</span>(tp) \
	max((tp)-&gt;t_rttmin, (((tp)-&gt;t_srtt &gt;&gt; (TCP_RTT_SHIFT - TCP_DELTA_SHIFT))  \
	  + (tp)-&gt;t_rttvar) &gt;&gt; TCP_DELTA_SHIFT)

<span class="enscript-comment">/*
 * Jaguar compatible TCP control block, for xtcpcb
 * Does not have the old fields
 */</span>
<span class="enscript-type">struct</span> otcpcb {
#<span class="enscript-reference">else</span>
<span class="enscript-type">struct</span> tseg_qent;
<span class="enscript-function-name">_TCPCB_LIST_HEAD</span>(tsegqe_head, tseg_qent);

<span class="enscript-type">struct</span> tcpcb {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL_PRIVATE</span>)
	u_int32_t t_segq;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span>	tsegqe_head t_segq;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL_PRIVATE */</span>
	<span class="enscript-type">int</span>	t_dupacks;		<span class="enscript-comment">/* consecutive dup acks recd */</span>
	u_int32_t unused;		<span class="enscript-comment">/* unused now: was t_template */</span>

	<span class="enscript-type">int</span>	t_timer[TCPT_NTIMERS_EXT];	<span class="enscript-comment">/* tcp timers */</span>

	_TCPCB_PTR(<span class="enscript-type">struct</span> inpcb *) t_inpcb;	<span class="enscript-comment">/* back pointer to internet pcb */</span>
	<span class="enscript-type">int</span>	t_state;		<span class="enscript-comment">/* state of this connection */</span>
	u_int	t_flags;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_ACKNOW</span>	0x00001		<span class="enscript-comment">/* ack peer immediately */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_DELACK</span>	0x00002		<span class="enscript-comment">/* ack, but try to delay it */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NODELAY</span>	0x00004		<span class="enscript-comment">/* don't delay packets to coalesce */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOOPT</span>	0x00008		<span class="enscript-comment">/* don't use tcp options */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SENTFIN</span>	0x00010		<span class="enscript-comment">/* have sent FIN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_SCALE</span>	0x00020		<span class="enscript-comment">/* have/will request window scaling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_SCALE</span>	0x00040		<span class="enscript-comment">/* other side has requested scaling */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_TSTMP</span>	0x00080		<span class="enscript-comment">/* have/will request timestamps */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_TSTMP</span>	0x00100		<span class="enscript-comment">/* a timestamp was received in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SACK_PERMIT</span>	0x00200		<span class="enscript-comment">/* other side said I could SACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NEEDSYN</span>	0x00400		<span class="enscript-comment">/* send SYN (implicit state) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NEEDFIN</span>	0x00800		<span class="enscript-comment">/* send FIN (implicit state) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_NOPUSH</span>	0x01000		<span class="enscript-comment">/* don't push */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_REQ_CC</span>	0x02000		<span class="enscript-comment">/* have/will request CC */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RCVD_CC</span>	0x04000		<span class="enscript-comment">/* a CC was received in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SENDCCNEW</span>	0x08000		<span class="enscript-comment">/* send CCnew instead of CC in SYN */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_MORETOCOME</span>	0x10000		<span class="enscript-comment">/* More data to be appended to sock */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_LQ_OVERFLOW</span>	0x20000		<span class="enscript-comment">/* listen queue overflow */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_RXWIN0SENT</span>	0x40000		<span class="enscript-comment">/* sent a receiver win 0 in response */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TF_SLOWLINK</span>	0x80000		<span class="enscript-comment">/* route is a on a modem speed link */</span>

	<span class="enscript-type">int</span>	t_force;		<span class="enscript-comment">/* 1 if forcing out a byte */</span>

	tcp_seq	snd_una;		<span class="enscript-comment">/* send unacknowledged */</span>
	tcp_seq	snd_max;		<span class="enscript-comment">/* highest sequence number sent;
					 * used to recognize retransmits
					 */</span>
	tcp_seq	snd_nxt;		<span class="enscript-comment">/* send next */</span>
	tcp_seq	snd_up;			<span class="enscript-comment">/* send urgent pointer */</span>

	tcp_seq	snd_wl1;		<span class="enscript-comment">/* window update seg seq number */</span>
	tcp_seq	snd_wl2;		<span class="enscript-comment">/* window update seg ack number */</span>
	tcp_seq	iss;			<span class="enscript-comment">/* initial send sequence number */</span>
	tcp_seq	irs;			<span class="enscript-comment">/* initial receive sequence number */</span>

	tcp_seq	rcv_nxt;		<span class="enscript-comment">/* receive next */</span>
	tcp_seq	rcv_adv;		<span class="enscript-comment">/* advertised window */</span>
	u_int32_t rcv_wnd;		<span class="enscript-comment">/* receive window */</span>
	tcp_seq	rcv_up;			<span class="enscript-comment">/* receive urgent pointer */</span>

	u_int32_t snd_wnd;		<span class="enscript-comment">/* send window */</span>
	u_int32_t snd_cwnd;		<span class="enscript-comment">/* congestion-controlled window */</span>
	u_int32_t snd_ssthresh;		<span class="enscript-comment">/* snd_cwnd size threshold for
					 * for slow start exponential to
					 * linear switch
					 */</span>
	u_int	t_maxopd;		<span class="enscript-comment">/* mss plus options */</span>

	u_int32_t t_rcvtime;		<span class="enscript-comment">/* time at which a packet was received */</span>
	u_int32_t t_starttime;		<span class="enscript-comment">/* time connection was established */</span>
	<span class="enscript-type">int</span>	t_rtttime;		<span class="enscript-comment">/* round trip time */</span>
	tcp_seq	t_rtseq;		<span class="enscript-comment">/* sequence number being timed */</span>

	<span class="enscript-type">int</span>	t_rxtcur;		<span class="enscript-comment">/* current retransmit value (ticks) */</span>
	u_int	t_maxseg;		<span class="enscript-comment">/* maximum segment size */</span>
	<span class="enscript-type">int</span>	t_srtt;			<span class="enscript-comment">/* smoothed round-trip time */</span>
	<span class="enscript-type">int</span>	t_rttvar;		<span class="enscript-comment">/* variance in round-trip time */</span>

	<span class="enscript-type">int</span>	t_rxtshift;		<span class="enscript-comment">/* log(2) of rexmt exp. backoff */</span>
	u_int	t_rttmin;		<span class="enscript-comment">/* minimum rtt allowed */</span>
	u_int32_t t_rttupdated;		<span class="enscript-comment">/* number of times rtt sampled */</span>
	u_int32_t max_sndwnd;		<span class="enscript-comment">/* largest window peer has offered */</span>

	<span class="enscript-type">int</span>	t_softerror;		<span class="enscript-comment">/* possible error not yet reported */</span>
<span class="enscript-comment">/* out-of-band data */</span>
	<span class="enscript-type">char</span>	t_oobflags;		<span class="enscript-comment">/* have some */</span>
	<span class="enscript-type">char</span>	t_iobc;			<span class="enscript-comment">/* input character */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPOOB_HAVEDATA</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPOOB_HADDATA</span>	0x02
<span class="enscript-comment">/* RFC 1323 variables */</span>
	u_char	snd_scale;		<span class="enscript-comment">/* window scaling for send window */</span>
	u_char	rcv_scale;		<span class="enscript-comment">/* window scaling for recv window */</span>
	u_char	request_r_scale;	<span class="enscript-comment">/* pending window scaling */</span>
	u_char	requested_s_scale;
	u_int32_t ts_recent;		<span class="enscript-comment">/* timestamp echo data */</span>

	u_int32_t ts_recent_age;	<span class="enscript-comment">/* when last updated */</span>
	tcp_seq	last_ack_sent;
<span class="enscript-comment">/* RFC 1644 variables */</span>
	tcp_cc	cc_send;		<span class="enscript-comment">/* send connection count */</span>
	tcp_cc	cc_recv;		<span class="enscript-comment">/* receive connection count */</span>
	tcp_seq	snd_recover;		<span class="enscript-comment">/* for use in fast recovery */</span>
<span class="enscript-comment">/* experimental */</span>
	u_int32_t snd_cwnd_prev;	<span class="enscript-comment">/* cwnd prior to retransmit */</span>
	u_int32_t snd_ssthresh_prev;	<span class="enscript-comment">/* ssthresh prior to retransmit */</span>
	u_int32_t t_badrxtwin;		<span class="enscript-comment">/* window for retransmit recovery */</span>
};

#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">tcps_ecn_setup</span>  tcps_ecn_client_success
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">tcps_sent_cwr</span>   tcps_ecn_recv_ece
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">tcps_sent_ece</span>   tcps_ecn_sent_ece

<span class="enscript-comment">/*
 * TCP statistics.
 * Many of these should be kept per connection,
 * but that's inconvenient at the moment.
 */</span>
<span class="enscript-type">struct</span>	tcpstat {
	u_int32_t	tcps_connattempt;	<span class="enscript-comment">/* connections initiated */</span>
	u_int32_t	tcps_accepts;		<span class="enscript-comment">/* connections accepted */</span>
	u_int32_t	tcps_connects;		<span class="enscript-comment">/* connections established */</span>
	u_int32_t	tcps_drops;		<span class="enscript-comment">/* connections dropped */</span>
	u_int32_t	tcps_conndrops;		<span class="enscript-comment">/* embryonic connections dropped */</span>
	u_int32_t	tcps_closed;		<span class="enscript-comment">/* conn. closed (includes drops) */</span>
	u_int32_t	tcps_segstimed;		<span class="enscript-comment">/* segs where we tried to get rtt */</span>
	u_int32_t	tcps_rttupdated;	<span class="enscript-comment">/* times we succeeded */</span>
	u_int32_t	tcps_delack;		<span class="enscript-comment">/* delayed acks sent */</span>
	u_int32_t	tcps_timeoutdrop;	<span class="enscript-comment">/* conn. dropped in rxmt timeout */</span>
	u_int32_t	tcps_rexmttimeo;	<span class="enscript-comment">/* retransmit timeouts */</span>
	u_int32_t	tcps_persisttimeo;	<span class="enscript-comment">/* persist timeouts */</span>
	u_int32_t	tcps_keeptimeo;		<span class="enscript-comment">/* keepalive timeouts */</span>
	u_int32_t	tcps_keepprobe;		<span class="enscript-comment">/* keepalive probes sent */</span>
	u_int32_t	tcps_keepdrops;		<span class="enscript-comment">/* connections dropped in keepalive */</span>

	u_int32_t	tcps_sndtotal;		<span class="enscript-comment">/* total packets sent */</span>
	u_int32_t	tcps_sndpack;		<span class="enscript-comment">/* data packets sent */</span>
	u_int32_t	tcps_sndbyte;		<span class="enscript-comment">/* data bytes sent */</span>
	u_int32_t	tcps_sndrexmitpack;	<span class="enscript-comment">/* data packets retransmitted */</span>
	u_int32_t	tcps_sndrexmitbyte;	<span class="enscript-comment">/* data bytes retransmitted */</span>
	u_int32_t	tcps_sndacks;		<span class="enscript-comment">/* ack-only packets sent */</span>
	u_int32_t	tcps_sndprobe;		<span class="enscript-comment">/* window probes sent */</span>
	u_int32_t	tcps_sndurg;		<span class="enscript-comment">/* packets sent with URG only */</span>
	u_int32_t	tcps_sndwinup;		<span class="enscript-comment">/* window update-only packets sent */</span>
	u_int32_t	tcps_sndctrl;		<span class="enscript-comment">/* control (SYN|FIN|RST) packets sent */</span>

	u_int32_t	tcps_rcvtotal;		<span class="enscript-comment">/* total packets received */</span>
	u_int32_t	tcps_rcvpack;		<span class="enscript-comment">/* packets received in sequence */</span>
	u_int32_t	tcps_rcvbyte;		<span class="enscript-comment">/* bytes received in sequence */</span>
	u_int32_t	tcps_rcvbadsum;		<span class="enscript-comment">/* packets received with ccksum errs */</span>
	u_int32_t	tcps_rcvbadoff;		<span class="enscript-comment">/* packets received with bad offset */</span>
	u_int32_t	tcps_rcvmemdrop;	<span class="enscript-comment">/* packets dropped for lack of memory */</span>
	u_int32_t	tcps_rcvshort;		<span class="enscript-comment">/* packets received too short */</span>
	u_int32_t	tcps_rcvduppack;	<span class="enscript-comment">/* duplicate-only packets received */</span>
	u_int32_t	tcps_rcvdupbyte;	<span class="enscript-comment">/* duplicate-only bytes received */</span>
	u_int32_t	tcps_rcvpartduppack;	<span class="enscript-comment">/* packets with some duplicate data */</span>
	u_int32_t	tcps_rcvpartdupbyte;	<span class="enscript-comment">/* dup. bytes in part-dup. packets */</span>
	u_int32_t	tcps_rcvoopack;		<span class="enscript-comment">/* out-of-order packets received */</span>
	u_int32_t	tcps_rcvoobyte;		<span class="enscript-comment">/* out-of-order bytes received */</span>
	u_int32_t	tcps_rcvpackafterwin;	<span class="enscript-comment">/* packets with data after window */</span>
	u_int32_t	tcps_rcvbyteafterwin;	<span class="enscript-comment">/* bytes rcvd after window */</span>
	u_int32_t	tcps_rcvafterclose;	<span class="enscript-comment">/* packets rcvd after &quot;close&quot; */</span>
	u_int32_t	tcps_rcvwinprobe;	<span class="enscript-comment">/* rcvd window probe packets */</span>
	u_int32_t	tcps_rcvdupack;		<span class="enscript-comment">/* rcvd duplicate acks */</span>
	u_int32_t	tcps_rcvacktoomuch;	<span class="enscript-comment">/* rcvd acks for unsent data */</span>
	u_int32_t	tcps_rcvackpack;	<span class="enscript-comment">/* rcvd ack packets */</span>
	u_int32_t	tcps_rcvackbyte;	<span class="enscript-comment">/* bytes acked by rcvd acks */</span>
	u_int32_t	tcps_rcvwinupd;		<span class="enscript-comment">/* rcvd window update packets */</span>
	u_int32_t	tcps_pawsdrop;		<span class="enscript-comment">/* segments dropped due to PAWS */</span>
	u_int32_t	tcps_predack;		<span class="enscript-comment">/* times hdr predict ok for acks */</span>
	u_int32_t	tcps_preddat;		<span class="enscript-comment">/* times hdr predict ok for data pkts */</span>
	u_int32_t	tcps_pcbcachemiss;
	u_int32_t	tcps_cachedrtt;		<span class="enscript-comment">/* times cached RTT in route updated */</span>
	u_int32_t	tcps_cachedrttvar;	<span class="enscript-comment">/* times cached rttvar updated */</span>
	u_int32_t	tcps_cachedssthresh;	<span class="enscript-comment">/* times cached ssthresh updated */</span>
	u_int32_t	tcps_usedrtt;		<span class="enscript-comment">/* times RTT initialized from route */</span>
	u_int32_t	tcps_usedrttvar;	<span class="enscript-comment">/* times RTTVAR initialized from rt */</span>
	u_int32_t	tcps_usedssthresh;	<span class="enscript-comment">/* times ssthresh initialized from rt*/</span>
	u_int32_t	tcps_persistdrop;	<span class="enscript-comment">/* timeout in persist state */</span>
	u_int32_t	tcps_badsyn;		<span class="enscript-comment">/* bogus SYN, e.g. premature ACK */</span>
	u_int32_t	tcps_mturesent;		<span class="enscript-comment">/* resends due to MTU discovery */</span>
	u_int32_t	tcps_listendrop;	<span class="enscript-comment">/* listen queue overflows */</span>

	<span class="enscript-comment">/* new stats from FreeBSD 5.4 sync up */</span>
	u_int32_t	tcps_minmssdrops;	<span class="enscript-comment">/* average minmss too low drops */</span>
	u_int32_t	tcps_sndrexmitbad;	<span class="enscript-comment">/* unnecessary packet retransmissions */</span>
	u_int32_t	tcps_badrst;		<span class="enscript-comment">/* ignored RSTs in the window */</span>

	u_int32_t	tcps_sc_added;		<span class="enscript-comment">/* entry added to syncache */</span>
	u_int32_t	tcps_sc_retransmitted;	<span class="enscript-comment">/* syncache entry was retransmitted */</span>
	u_int32_t	tcps_sc_dupsyn;		<span class="enscript-comment">/* duplicate SYN packet */</span>
	u_int32_t	tcps_sc_dropped;	<span class="enscript-comment">/* could not reply to packet */</span>
	u_int32_t	tcps_sc_completed;	<span class="enscript-comment">/* successful extraction of entry */</span>
	u_int32_t	tcps_sc_bucketoverflow;	<span class="enscript-comment">/* syncache per-bucket limit hit */</span>
	u_int32_t	tcps_sc_cacheoverflow;	<span class="enscript-comment">/* syncache cache limit hit */</span>
	u_int32_t	tcps_sc_reset;		<span class="enscript-comment">/* RST removed entry from syncache */</span>
	u_int32_t	tcps_sc_stale;		<span class="enscript-comment">/* timed out or listen socket gone */</span>
	u_int32_t	tcps_sc_aborted;	<span class="enscript-comment">/* syncache entry aborted */</span>
	u_int32_t	tcps_sc_badack;		<span class="enscript-comment">/* removed due to bad ACK */</span>
	u_int32_t	tcps_sc_unreach;	<span class="enscript-comment">/* ICMP unreachable received */</span>
	u_int32_t	tcps_sc_zonefail;	<span class="enscript-comment">/* zalloc() failed */</span>
	u_int32_t	tcps_sc_sendcookie;	<span class="enscript-comment">/* SYN cookie sent */</span>
	u_int32_t	tcps_sc_recvcookie;	<span class="enscript-comment">/* SYN cookie received */</span>

	u_int32_t	tcps_hc_added;		<span class="enscript-comment">/* entry added to hostcache */</span>
	u_int32_t	tcps_hc_bucketoverflow;	<span class="enscript-comment">/* hostcache per bucket limit hit */</span>

	<span class="enscript-comment">/* SACK related stats */</span>
	u_int32_t	tcps_sack_recovery_episode; <span class="enscript-comment">/* SACK recovery episodes */</span>
	u_int32_t 	tcps_sack_rexmits;	    <span class="enscript-comment">/* SACK rexmit segments   */</span>
	u_int32_t 	tcps_sack_rexmit_bytes;	    <span class="enscript-comment">/* SACK rexmit bytes      */</span>
	u_int32_t 	tcps_sack_rcv_blocks;	    <span class="enscript-comment">/* SACK blocks (options) received */</span>
	u_int32_t 	tcps_sack_send_blocks;	    <span class="enscript-comment">/* SACK blocks (options) sent     */</span>
	u_int32_t 	tcps_sack_sboverflow;	    <span class="enscript-comment">/* SACK sendblock overflow   */</span>

	u_int32_t	tcps_bg_rcvtotal;	<span class="enscript-comment">/* total background packets received */</span>
	u_int32_t	tcps_rxtfindrop;	<span class="enscript-comment">/* drop conn after retransmitting FIN */</span>
	u_int32_t	tcps_fcholdpacket;	<span class="enscript-comment">/* packets withheld because of flow control */</span>

	<span class="enscript-comment">/* LRO related stats */</span>
	u_int32_t	tcps_coalesced_pack;	<span class="enscript-comment">/* number of coalesced packets */</span>
	u_int32_t	tcps_flowtbl_full;	<span class="enscript-comment">/* times flow table was full */</span>
	u_int32_t	tcps_flowtbl_collision;	<span class="enscript-comment">/* collisions in flow tbl */</span>
	u_int32_t	tcps_lro_twopack;	<span class="enscript-comment">/* 2 packets coalesced */</span>
	u_int32_t	tcps_lro_multpack;	<span class="enscript-comment">/* 3 or 4 pkts coalesced */</span>
	u_int32_t	tcps_lro_largepack;	<span class="enscript-comment">/* 5 or more pkts coalesced */</span>

	u_int32_t	tcps_limited_txt;	<span class="enscript-comment">/* Limited transmit used */</span>
	u_int32_t	tcps_early_rexmt;	<span class="enscript-comment">/* Early retransmit used */</span>
	u_int32_t	tcps_sack_ackadv;	<span class="enscript-comment">/* Cumulative ack advanced along with sack */</span>

	<span class="enscript-comment">/* Checksum related stats */</span>
	u_int32_t	tcps_rcv_swcsum;	<span class="enscript-comment">/* tcp swcksum (inbound), packets */</span>
	u_int32_t	tcps_rcv_swcsum_bytes;	<span class="enscript-comment">/* tcp swcksum (inbound), bytes */</span>
	u_int32_t	tcps_rcv6_swcsum;	<span class="enscript-comment">/* tcp6 swcksum (inbound), packets */</span>
	u_int32_t	tcps_rcv6_swcsum_bytes;	<span class="enscript-comment">/* tcp6 swcksum (inbound), bytes */</span>
	u_int32_t	tcps_snd_swcsum;	<span class="enscript-comment">/* tcp swcksum (outbound), packets */</span>
	u_int32_t	tcps_snd_swcsum_bytes;	<span class="enscript-comment">/* tcp swcksum (outbound), bytes */</span>
	u_int32_t	tcps_snd6_swcsum;	<span class="enscript-comment">/* tcp6 swcksum (outbound), packets */</span>
	u_int32_t	tcps_snd6_swcsum_bytes;	<span class="enscript-comment">/* tcp6 swcksum (outbound), bytes */</span>
	u_int32_t	tcps_msg_unopkts;	<span class="enscript-comment">/* unordered packet on TCP msg stream */</span>
	u_int32_t	tcps_msg_unoappendfail; <span class="enscript-comment">/* failed to append unordered pkt */</span>
	u_int32_t	tcps_msg_sndwaithipri; <span class="enscript-comment">/* send is waiting for high priority data */</span>

	<span class="enscript-comment">/* MPTCP Related stats */</span>
	u_int32_t	tcps_invalid_mpcap;	<span class="enscript-comment">/* Invalid MPTCP capable opts */</span>
	u_int32_t	tcps_invalid_joins;	<span class="enscript-comment">/* Invalid MPTCP joins */</span>
	u_int32_t	tcps_mpcap_fallback;	<span class="enscript-comment">/* TCP fallback in primary */</span>
	u_int32_t	tcps_join_fallback;	<span class="enscript-comment">/* No MPTCP in secondary */</span>
	u_int32_t	tcps_estab_fallback;	<span class="enscript-comment">/* DSS option dropped */</span>
	u_int32_t	tcps_invalid_opt;	<span class="enscript-comment">/* Catchall error stat */</span>
	u_int32_t	tcps_mp_outofwin;	<span class="enscript-comment">/* Packet lies outside the
						   shared recv window */</span>
	u_int32_t	tcps_mp_reducedwin;	<span class="enscript-comment">/* Reduced subflow window */</span>
	u_int32_t	tcps_mp_badcsum;	<span class="enscript-comment">/* Bad DSS csum */</span>
	u_int32_t	tcps_mp_oodata;		<span class="enscript-comment">/* Out of order data */</span>
	u_int32_t	tcps_mp_switches;	<span class="enscript-comment">/* number of subflow switch */</span>
	u_int32_t	tcps_mp_rcvtotal;	<span class="enscript-comment">/* number of rcvd packets */</span>
	u_int32_t	tcps_mp_rcvbytes;	<span class="enscript-comment">/* number of bytes received */</span>
	u_int32_t	tcps_mp_sndpacks;	<span class="enscript-comment">/* number of data packs sent */</span>
	u_int32_t	tcps_mp_sndbytes;	<span class="enscript-comment">/* number of bytes sent */</span>
	u_int32_t	tcps_join_rxmts;	<span class="enscript-comment">/* join ack retransmits */</span>
	u_int32_t	tcps_tailloss_rto;	<span class="enscript-comment">/* RTO due to tail loss */</span>
	u_int32_t	tcps_reordered_pkts;	<span class="enscript-comment">/* packets reorderd */</span>
	u_int32_t	tcps_recovered_pkts;	<span class="enscript-comment">/* recovered after loss */</span>
	u_int32_t	tcps_pto;		<span class="enscript-comment">/* probe timeout */</span>
	u_int32_t	tcps_rto_after_pto;	<span class="enscript-comment">/* RTO after a probe */</span>
	u_int32_t	tcps_tlp_recovery;	<span class="enscript-comment">/* TLP induced fast recovery */</span>
	u_int32_t	tcps_tlp_recoverlastpkt; <span class="enscript-comment">/* TLP recoverd last pkt */</span>
	u_int32_t	tcps_ecn_client_success; <span class="enscript-comment">/* client-side connection negotiated ECN */</span>
	u_int32_t	tcps_ecn_recv_ece;	<span class="enscript-comment">/* ECE received, sent CWR */</span>
	u_int32_t	tcps_ecn_sent_ece;	<span class="enscript-comment">/* Sent ECE notification */</span>
	u_int32_t	tcps_detect_reordering; <span class="enscript-comment">/* Detect pkt reordering */</span>
	u_int32_t	tcps_delay_recovery;	<span class="enscript-comment">/* Delay fast recovery */</span>
	u_int32_t	tcps_avoid_rxmt;	<span class="enscript-comment">/* Retransmission was avoided */</span>
	u_int32_t	tcps_unnecessary_rxmt;	<span class="enscript-comment">/* Retransmission was not needed */</span>
	u_int32_t	tcps_nostretchack;	<span class="enscript-comment">/* disabled stretch ack algorithm on a connection */</span>
	u_int32_t	tcps_rescue_rxmt;	<span class="enscript-comment">/* SACK rescue retransmit */</span>
	u_int32_t	tcps_pto_in_recovery;	<span class="enscript-comment">/* rescue retransmit in fast recovery */</span>
	u_int32_t	tcps_pmtudbh_reverted;	<span class="enscript-comment">/* PMTU Blackhole detection, segment size reverted */</span>

	<span class="enscript-comment">/* DSACK related statistics */</span>
	u_int32_t	tcps_dsack_disable;	<span class="enscript-comment">/* DSACK disabled due to n/w duplication */</span>
	u_int32_t	tcps_dsack_ackloss;	<span class="enscript-comment">/* ignore DSACK due to ack loss */</span>
	u_int32_t	tcps_dsack_badrexmt;	<span class="enscript-comment">/* DSACK based bad rexmt recovery */</span>
	u_int32_t	tcps_dsack_sent;	<span class="enscript-comment">/* Sent DSACK notification */</span>
	u_int32_t	tcps_dsack_recvd;	<span class="enscript-comment">/* Received a valid DSACK option */</span>
	u_int32_t	tcps_dsack_recvd_old;	<span class="enscript-comment">/* Received an out of window DSACK option */</span>

	<span class="enscript-comment">/* MPTCP Subflow selection stats */</span>
	u_int32_t	tcps_mp_sel_symtomsd;	<span class="enscript-comment">/* By symptomsd */</span>
	u_int32_t	tcps_mp_sel_rtt;	<span class="enscript-comment">/* By RTT comparison */</span>
	u_int32_t	tcps_mp_sel_rto;	<span class="enscript-comment">/* By RTO comparison */</span>
	u_int32_t	tcps_mp_sel_peer;	<span class="enscript-comment">/* By peer's output pattern */</span>
	u_int32_t	tcps_mp_num_probes;	<span class="enscript-comment">/* Number of probes sent */</span>
	u_int32_t	tcps_mp_verdowngrade;	<span class="enscript-comment">/* MPTCP version downgrade */</span>
	u_int32_t	tcps_drop_after_sleep;	<span class="enscript-comment">/* drop after long AP sleep */</span>
	u_int32_t	tcps_probe_if;		<span class="enscript-comment">/* probe packets after interface availability */</span>
	u_int32_t	tcps_probe_if_conflict; <span class="enscript-comment">/* Can't send probe packets for interface */</span>

	u_int32_t	tcps_ecn_client_setup;	<span class="enscript-comment">/* Attempted ECN setup from client side */</span>
	u_int32_t	tcps_ecn_server_setup;	<span class="enscript-comment">/* Attempted ECN setup from server side */</span>
	u_int32_t	tcps_ecn_server_success; <span class="enscript-comment">/* server-side connection negotiated ECN */</span>
	u_int32_t	tcps_ecn_lost_synack;	<span class="enscript-comment">/* Lost SYN-ACK with ECN setup */</span>
	u_int32_t	tcps_ecn_lost_syn;	<span class="enscript-comment">/* Lost SYN with ECN setup */</span>
	u_int32_t	tcps_ecn_not_supported;	<span class="enscript-comment">/* Server did not support ECN setup */</span>
	u_int32_t	tcps_ecn_recv_ce;	<span class="enscript-comment">/* Received CE from the network */</span>
	u_int32_t	tcps_ecn_conn_recv_ce;	<span class="enscript-comment">/* Number of connections received CE atleast once */</span>
	u_int32_t	tcps_ecn_conn_recv_ece;	<span class="enscript-comment">/* Number of connections received ECE atleast once */</span>
	u_int32_t	tcps_ecn_conn_plnoce;	<span class="enscript-comment">/* Number of connections that received no CE and sufferred packet loss */</span>
	u_int32_t	tcps_ecn_conn_pl_ce;	<span class="enscript-comment">/* Number of connections that received CE and sufferred packet loss */</span>
	u_int32_t	tcps_ecn_conn_nopl_ce;	<span class="enscript-comment">/* Number of connections that received CE and sufferred no packet loss */</span>

	<span class="enscript-comment">/* TFO-related statistics */</span>
	u_int32_t	tcps_tfo_syn_data_rcv;	<span class="enscript-comment">/* Received a SYN+data with valid cookie */</span>
	u_int32_t	tcps_tfo_cookie_req_rcv;<span class="enscript-comment">/* Received a TFO cookie-request */</span>
	u_int32_t	tcps_tfo_cookie_sent;	<span class="enscript-comment">/* Offered a TFO-cookie to the client */</span>
	u_int32_t	tcps_tfo_cookie_invalid;<span class="enscript-comment">/* Received an invalid TFO-cookie */</span>
	u_int32_t	tcps_tfo_cookie_req;	<span class="enscript-comment">/* Cookie requested with the SYN */</span>
	u_int32_t	tcps_tfo_cookie_rcv;	<span class="enscript-comment">/* Cookie received in a SYN/ACK */</span>
	u_int32_t	tcps_tfo_syn_data_sent;	<span class="enscript-comment">/* SYN+data+cookie sent */</span>
	u_int32_t	tcps_tfo_syn_data_acked;<span class="enscript-comment">/* SYN+data has been acknowledged */</span>
	u_int32_t	tcps_tfo_syn_loss;	<span class="enscript-comment">/* SYN+TFO has been lost and we fallback */</span>
	u_int32_t	tcps_tfo_blackhole;	<span class="enscript-comment">/* TFO got blackholed by a middlebox. */</span>
};

<span class="enscript-type">struct</span> tcpstat_local {
	u_int64_t badformat;
	u_int64_t unspecv6;
	u_int64_t synfin;
	u_int64_t badformatipsec;
	u_int64_t noconnnolist;
	u_int64_t noconnlist;
	u_int64_t listbadsyn;
	u_int64_t icmp6unreach;
	u_int64_t deprecate6;
	u_int64_t ooopacket;
	u_int64_t rstinsynrcv;
	u_int64_t dospacket;
	u_int64_t cleanup;
	u_int64_t synwindow;
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)

<span class="enscript-comment">/*
 * TCB structure exported to user-land via sysctl(3).
 * Evil hack: declare only if in_pcb.h and sys/socketvar.h have been
 * included.  Not all of our clients do.
 */</span>

<span class="enscript-type">struct</span>  xtcpcb {
        u_int32_t       xt_len;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
        <span class="enscript-type">struct</span>  inpcb_compat    xt_inp;
#<span class="enscript-reference">else</span>
        <span class="enscript-type">struct</span>  inpcb   xt_inp;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>
        <span class="enscript-type">struct</span>  otcpcb  xt_tp;
#<span class="enscript-reference">else</span>
        <span class="enscript-type">struct</span>  tcpcb   xt_tp;
#<span class="enscript-reference">endif</span>
        <span class="enscript-type">struct</span>  xsocket xt_socket;
        u_quad_t        xt_alignment_hack;
};


<span class="enscript-type">struct</span>  xtcpcb64 {
        u_int32_t      		xt_len;
        <span class="enscript-type">struct</span> xinpcb64		xt_inpcb;

        u_int64_t t_segq;
        <span class="enscript-type">int</span>     t_dupacks;              <span class="enscript-comment">/* consecutive dup acks recd */</span>

        <span class="enscript-type">int</span> t_timer[TCPT_NTIMERS_EXT];  <span class="enscript-comment">/* tcp timers */</span>

        <span class="enscript-type">int</span>     t_state;                <span class="enscript-comment">/* state of this connection */</span>
        u_int   t_flags;

        <span class="enscript-type">int</span>     t_force;                <span class="enscript-comment">/* 1 if forcing out a byte */</span>

        tcp_seq snd_una;                <span class="enscript-comment">/* send unacknowledged */</span>
        tcp_seq snd_max;                <span class="enscript-comment">/* highest sequence number sent;
                                         * used to recognize retransmits
                                         */</span>
        tcp_seq snd_nxt;                <span class="enscript-comment">/* send next */</span>
        tcp_seq snd_up;                 <span class="enscript-comment">/* send urgent pointer */</span>

        tcp_seq snd_wl1;                <span class="enscript-comment">/* window update seg seq number */</span>
        tcp_seq snd_wl2;                <span class="enscript-comment">/* window update seg ack number */</span>
        tcp_seq iss;                    <span class="enscript-comment">/* initial send sequence number */</span>
        tcp_seq irs;                    <span class="enscript-comment">/* initial receive sequence number */</span>

        tcp_seq rcv_nxt;                <span class="enscript-comment">/* receive next */</span>
        tcp_seq rcv_adv;                <span class="enscript-comment">/* advertised window */</span>
        u_int32_t rcv_wnd;              <span class="enscript-comment">/* receive window */</span>
        tcp_seq rcv_up;                 <span class="enscript-comment">/* receive urgent pointer */</span>

        u_int32_t snd_wnd;              <span class="enscript-comment">/* send window */</span>
        u_int32_t snd_cwnd;             <span class="enscript-comment">/* congestion-controlled window */</span>
        u_int32_t snd_ssthresh;         <span class="enscript-comment">/* snd_cwnd size threshold for
                                         * for slow start exponential to
                                         * linear switch
                                         */</span>
        u_int   t_maxopd;               <span class="enscript-comment">/* mss plus options */</span>

        u_int32_t t_rcvtime;            <span class="enscript-comment">/* time at which a packet was received */</span>
        u_int32_t t_starttime;          <span class="enscript-comment">/* time connection was established */</span>
        <span class="enscript-type">int</span>     t_rtttime;              <span class="enscript-comment">/* round trip time */</span>
        tcp_seq t_rtseq;                <span class="enscript-comment">/* sequence number being timed */</span>

        <span class="enscript-type">int</span>     t_rxtcur;               <span class="enscript-comment">/* current retransmit value (ticks) */</span>
        u_int   t_maxseg;               <span class="enscript-comment">/* maximum segment size */</span>
        <span class="enscript-type">int</span>     t_srtt;                 <span class="enscript-comment">/* smoothed round-trip time */</span>
        <span class="enscript-type">int</span>     t_rttvar;               <span class="enscript-comment">/* variance in round-trip time */</span>

        <span class="enscript-type">int</span>     t_rxtshift;             <span class="enscript-comment">/* log(2) of rexmt exp. backoff */</span>
        u_int   t_rttmin;               <span class="enscript-comment">/* minimum rtt allowed */</span>
        u_int32_t t_rttupdated;         <span class="enscript-comment">/* number of times rtt sampled */</span>
        u_int32_t max_sndwnd;           <span class="enscript-comment">/* largest window peer has offered */</span>

        <span class="enscript-type">int</span>     t_softerror;            <span class="enscript-comment">/* possible error not yet reported */</span>
<span class="enscript-comment">/* out-of-band data */</span>
        <span class="enscript-type">char</span>    t_oobflags;             <span class="enscript-comment">/* have some */</span>
        <span class="enscript-type">char</span>    t_iobc;                 <span class="enscript-comment">/* input character */</span>
<span class="enscript-comment">/* RFC 1323 variables */</span>
        u_char  snd_scale;              <span class="enscript-comment">/* window scaling for send window */</span>
        u_char  rcv_scale;              <span class="enscript-comment">/* window scaling for recv window */</span>
        u_char  request_r_scale;        <span class="enscript-comment">/* pending window scaling */</span>
        u_char  requested_s_scale;
        u_int32_t ts_recent;            <span class="enscript-comment">/* timestamp echo data */</span>

        u_int32_t ts_recent_age;        <span class="enscript-comment">/* when last updated */</span>
        tcp_seq last_ack_sent;
<span class="enscript-comment">/* RFC 1644 variables */</span>
        tcp_cc  cc_send;                <span class="enscript-comment">/* send connection count */</span>
        tcp_cc  cc_recv;                <span class="enscript-comment">/* receive connection count */</span>
        tcp_seq snd_recover;            <span class="enscript-comment">/* for use in fast recovery */</span>
<span class="enscript-comment">/* experimental */</span>
        u_int32_t snd_cwnd_prev;        <span class="enscript-comment">/* cwnd prior to retransmit */</span>
        u_int32_t snd_ssthresh_prev;    <span class="enscript-comment">/* ssthresh prior to retransmit */</span>
        u_int32_t t_badrxtwin;          <span class="enscript-comment">/* window for retransmit recovery */</span>

        u_quad_t		xt_alignment_hack;
};


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>

<span class="enscript-type">struct</span>  xtcpcb_n {
	u_int32_t      		xt_len;
	u_int32_t			xt_kind;		<span class="enscript-comment">/* XSO_TCPCB */</span>

	u_int64_t t_segq;
	<span class="enscript-type">int</span>     t_dupacks;              <span class="enscript-comment">/* consecutive dup acks recd */</span>
	
	<span class="enscript-type">int</span> t_timer[TCPT_NTIMERS_EXT];  <span class="enscript-comment">/* tcp timers */</span>
	
	<span class="enscript-type">int</span>     t_state;                <span class="enscript-comment">/* state of this connection */</span>
	u_int   t_flags;
	
	<span class="enscript-type">int</span>     t_force;                <span class="enscript-comment">/* 1 if forcing out a byte */</span>
	
	tcp_seq snd_una;                <span class="enscript-comment">/* send unacknowledged */</span>
	tcp_seq snd_max;                <span class="enscript-comment">/* highest sequence number sent;
									 * used to recognize retransmits
									 */</span>
	tcp_seq snd_nxt;                <span class="enscript-comment">/* send next */</span>
	tcp_seq snd_up;                 <span class="enscript-comment">/* send urgent pointer */</span>
	
	tcp_seq snd_wl1;                <span class="enscript-comment">/* window update seg seq number */</span>
	tcp_seq snd_wl2;                <span class="enscript-comment">/* window update seg ack number */</span>
	tcp_seq iss;                    <span class="enscript-comment">/* initial send sequence number */</span>
	tcp_seq irs;                    <span class="enscript-comment">/* initial receive sequence number */</span>
	
	tcp_seq rcv_nxt;                <span class="enscript-comment">/* receive next */</span>
	tcp_seq rcv_adv;                <span class="enscript-comment">/* advertised window */</span>
	u_int32_t rcv_wnd;              <span class="enscript-comment">/* receive window */</span>
	tcp_seq rcv_up;                 <span class="enscript-comment">/* receive urgent pointer */</span>
	
	u_int32_t snd_wnd;              <span class="enscript-comment">/* send window */</span>
	u_int32_t snd_cwnd;             <span class="enscript-comment">/* congestion-controlled window */</span>
	u_int32_t snd_ssthresh;         <span class="enscript-comment">/* snd_cwnd size threshold for
									 * for slow start exponential to
									 * linear switch
									 */</span>
	u_int   t_maxopd;               <span class="enscript-comment">/* mss plus options */</span>
	
	u_int32_t t_rcvtime;            <span class="enscript-comment">/* time at which a packet was received */</span>
	u_int32_t t_starttime;          <span class="enscript-comment">/* time connection was established */</span>
	<span class="enscript-type">int</span>     t_rtttime;              <span class="enscript-comment">/* round trip time */</span>
	tcp_seq t_rtseq;                <span class="enscript-comment">/* sequence number being timed */</span>
	
	<span class="enscript-type">int</span>     t_rxtcur;               <span class="enscript-comment">/* current retransmit value (ticks) */</span>
	u_int   t_maxseg;               <span class="enscript-comment">/* maximum segment size */</span>
	<span class="enscript-type">int</span>     t_srtt;                 <span class="enscript-comment">/* smoothed round-trip time */</span>
	<span class="enscript-type">int</span>     t_rttvar;               <span class="enscript-comment">/* variance in round-trip time */</span>
	
	<span class="enscript-type">int</span>     t_rxtshift;             <span class="enscript-comment">/* log(2) of rexmt exp. backoff */</span>
	u_int   t_rttmin;               <span class="enscript-comment">/* minimum rtt allowed */</span>
	u_int32_t t_rttupdated;         <span class="enscript-comment">/* number of times rtt sampled */</span>
	u_int32_t max_sndwnd;           <span class="enscript-comment">/* largest window peer has offered */</span>
	
	<span class="enscript-type">int</span>     t_softerror;            <span class="enscript-comment">/* possible error not yet reported */</span>
	<span class="enscript-comment">/* out-of-band data */</span>
	<span class="enscript-type">char</span>    t_oobflags;             <span class="enscript-comment">/* have some */</span>
	<span class="enscript-type">char</span>    t_iobc;                 <span class="enscript-comment">/* input character */</span>
	<span class="enscript-comment">/* RFC 1323 variables */</span>
	u_char  snd_scale;              <span class="enscript-comment">/* window scaling for send window */</span>
	u_char  rcv_scale;              <span class="enscript-comment">/* window scaling for recv window */</span>
	u_char  request_r_scale;        <span class="enscript-comment">/* pending window scaling */</span>
	u_char  requested_s_scale;
	u_int32_t ts_recent;            <span class="enscript-comment">/* timestamp echo data */</span>
	
	u_int32_t ts_recent_age;        <span class="enscript-comment">/* when last updated */</span>
	tcp_seq last_ack_sent;
	<span class="enscript-comment">/* RFC 1644 variables */</span>
	tcp_cc  cc_send;                <span class="enscript-comment">/* send connection count */</span>
	tcp_cc  cc_recv;                <span class="enscript-comment">/* receive connection count */</span>
	tcp_seq snd_recover;            <span class="enscript-comment">/* for use in fast recovery */</span>
	<span class="enscript-comment">/* experimental */</span>
	u_int32_t snd_cwnd_prev;        <span class="enscript-comment">/* cwnd prior to retransmit */</span>
	u_int32_t snd_ssthresh_prev;    <span class="enscript-comment">/* ssthresh prior to retransmit */</span>
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PRIVATE */</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

<span class="enscript-comment">/*
 * Names for TCP sysctl objects
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_DO_RFC1323</span>	1	<span class="enscript-comment">/* use RFC-1323 extensions */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_DO_RFC1644</span>	2	<span class="enscript-comment">/* use RFC-1644 extensions */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_MSSDFLT</span>		3	<span class="enscript-comment">/* MSS default */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCPCTL_STATS</span>		4	<span class="enscript-comment">/* statistics (read-only) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_RTTDFLT</span>		5	<span class="enscript-comment">/* default RTT estimate */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_KEEPIDLE</span>		6	<span class="enscript-comment">/* keepalive idle timer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_KEEPINTVL</span>	7	<span class="enscript-comment">/* interval to send keepalives */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_SENDSPACE</span>	8	<span class="enscript-comment">/* send buffer space */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_RECVSPACE</span>	9	<span class="enscript-comment">/* receive buffer space */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_KEEPINIT</span>		10	<span class="enscript-comment">/* timeout for establishing syn */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_PCBLIST</span>		11	<span class="enscript-comment">/* list of all outstanding PCBs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_DELACKTIME</span>	12	<span class="enscript-comment">/* time before sending delayed ACK */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_V6MSSDFLT</span>	13	<span class="enscript-comment">/* MSS default for IPv6 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPCTL_MAXID</span>		14

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/bitstring.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCP_PKTLIST_CLEAR</span>(tp) {						\
	(tp)-&gt;t_pktlist_head = (tp)-&gt;t_pktlist_tail = NULL;		\
	(tp)-&gt;t_lastchain = (tp)-&gt;t_pktlist_sentlen = 0;		\
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCPCTL_NAMES</span> { \
	{ 0, 0 }, \
	{ <span class="enscript-string">&quot;rfc1323&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;rfc1644&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;mssdflt&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;stats&quot;</span>, CTLTYPE_STRUCT }, \
	{ <span class="enscript-string">&quot;rttdflt&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;keepidle&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;keepintvl&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;sendspace&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;recvspace&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;keepinit&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;pcblist&quot;</span>, CTLTYPE_STRUCT }, \
	{ <span class="enscript-string">&quot;delacktime&quot;</span>, CTLTYPE_INT }, \
	{ <span class="enscript-string">&quot;v6mssdflt&quot;</span>, CTLTYPE_INT }, \
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SYSCTL_DECL</span>
<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet_tcp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SYSCTL_DECL */</span>

<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> inpcbhead tcb;		<span class="enscript-comment">/* head of queue of active tcpcb's */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> inpcbinfo tcbinfo;
<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> tcpstat tcpstat;	<span class="enscript-comment">/* tcp statistics */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_mssdflt;	<span class="enscript-comment">/* XXX */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_minmss;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_FASTOPEN_SERVER</span> 0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_FASTOPEN_CLIENT</span> 0x02

<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_tfo_halfcnt;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_tfo_backlog;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_fastopen;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_tfo_fallback_min;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> ss_fltsz;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> ss_fltsz_local;
<span class="enscript-type">extern</span> 	<span class="enscript-type">int</span> tcp_do_rfc3390;		<span class="enscript-comment">/* Calculate ss_fltsz according to RFC 3390 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_do_rfc1323;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> target_qdelay;
<span class="enscript-type">extern</span>	u_int32_t tcp_now;		<span class="enscript-comment">/* for RFC 1323 timestamps */</span> 
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> timeval tcp_uptime;
<span class="enscript-type">extern</span> lck_spin_t *tcp_uptime_lock;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_delack_enabled;
<span class="enscript-type">extern</span>	<span class="enscript-type">int</span> tcp_do_sack;	<span class="enscript-comment">/* SACK enabled/disabled */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_do_rfc3465;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_do_rfc3465_lim2;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> maxseg_unacked;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_use_newreno;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> zone *tcp_reass_zone;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> zone *tcp_rxt_seg_zone;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_ecn_outbound;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_ecn_inbound;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IFEF_NOWINDOWSCALE</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_obey_ifef_nowindowscale;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> protosw;
<span class="enscript-type">struct</span> domain;

<span class="enscript-type">struct</span> tcp_respond_args {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nocell:1,
	             <span class="enscript-reference">noexpensive</span>:1,
		     <span class="enscript-reference">awdl_unrestricted</span>:1;
};

<span class="enscript-type">void</span>	 tcp_canceltimers(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">struct</span> tcpcb *
	 tcp_close(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">void</span>	 tcp_ctlinput(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	 tcp_ctloutput(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">struct</span> tcpcb *
	 tcp_drop(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	 tcp_drain(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	 tcp_getrt_rtt(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> rtentry *rt);
<span class="enscript-type">struct</span> rmxp_tao *
	 tcp_gettaocache(<span class="enscript-type">struct</span> inpcb *);
<span class="enscript-type">void</span>	 tcp_init(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);
<span class="enscript-type">void</span>	 tcp_input(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	 tcp_mss(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	 tcp_mssopt(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">void</span>	 tcp_drop_syn_sent(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	 tcp_mtudisc(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>);
<span class="enscript-type">struct</span> tcpcb *
	 tcp_newtcpcb(<span class="enscript-type">struct</span> inpcb *);
<span class="enscript-type">int</span>	 tcp_output(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">void</span>	 tcp_respond(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">struct</span> mbuf *,
    tcp_seq, tcp_seq, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> tcp_respond_args *);
<span class="enscript-type">struct</span> rtentry *
	 tcp_rtlookup(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	 tcp_setpersist(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">void</span>	 tcp_gc(<span class="enscript-type">struct</span> inpcbinfo *);
<span class="enscript-type">void</span>     <span class="enscript-function-name">tcp_itimer</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi);
<span class="enscript-type">void</span> 	 tcp_check_timer_state(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">void</span>	 tcp_run_timerlist(<span class="enscript-type">void</span> *arg1, <span class="enscript-type">void</span> *arg2);

<span class="enscript-type">struct</span> tcptemp *<span class="enscript-function-name">tcp_maketemplate</span>(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">void</span>	 tcp_fillheaders(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">struct</span> tcpcb *<span class="enscript-function-name">tcp_timers</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	 tcp_trace(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sack_doack</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcpopt *, <span class="enscript-type">struct</span> tcphdr *,
    u_int32_t *);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">tcp_sack_process_dsack</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcpopt *,
    <span class="enscript-type">struct</span> tcphdr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">tcp_detect_bad_rexmt</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">struct</span> tcpopt *,
    u_int32_t rxtime);
<span class="enscript-type">void</span>	 tcp_update_sack_list(<span class="enscript-type">struct</span> tcpcb *tp, tcp_seq rcv_laststart, tcp_seq rcv_lastend);
<span class="enscript-type">void</span>	 tcp_clean_sackreport(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">void</span>	 tcp_sack_adjust(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">struct</span> sackhole *<span class="enscript-function-name">tcp_sack_output</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> *sack_bytes_rexmt);
<span class="enscript-type">void</span>	 tcp_sack_partialack(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcphdr *);
<span class="enscript-type">void</span>	 tcp_free_sackholes(<span class="enscript-type">struct</span> tcpcb *tp);
int32_t	 tcp_sbspace(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">void</span>	 tcp_set_tso(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> ifnet *ifp);
<span class="enscript-type">void</span>	 tcp_reset_stretch_ack(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_get_ports_used</span>(u_int32_t, <span class="enscript-type">int</span>, u_int32_t, bitstr_t *);
uint32_t <span class="enscript-function-name">tcp_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, u_int32_t flags);
uint32_t <span class="enscript-function-name">tcp_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa);
<span class="enscript-type">void</span>	 tcp_set_max_rwinscale(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> socket *so);
<span class="enscript-type">struct</span> bwmeas* <span class="enscript-function-name">tcp_bwmeas_alloc</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_bwmeas_free</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> int32_t <span class="enscript-function-name">timer_diff</span>(uint32_t t1, uint32_t toff1, uint32_t t2, uint32_t toff2);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_background_cc</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_foreground_cc</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_recv_bg</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_clear_recv_bg</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">tcp_sack_byte_islost</span>(<span class="enscript-type">struct</span> tcpcb *tp);
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IS_TCP_RECV_BG</span>(_so)	\
	((_so)-&gt;so_traffic_mgt_flags &amp; TRAFFIC_MGT_TCP_RECVBG)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CLEAR_IAJ_STATE</span>(_tp_) (_tp_)-&gt;iaj_rcv_ts = 0
<span class="enscript-type">void</span>	 reset_acc_iaj(<span class="enscript-type">struct</span> tcpcb *tp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

<span class="enscript-type">int</span>	 tcp_lock (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	 tcp_unlock (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span>	 calculate_tcp_clock(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_keepalive_reset</span>(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">get_base_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_KERN_LOCKS_H_</span>
lck_mtx_t *	 tcp_getlock (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span> *	 tcp_getlock (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>


<span class="enscript-type">extern</span>	<span class="enscript-type">struct</span> pr_usrreqs tcp_usrreqs;
<span class="enscript-type">extern</span>	u_int32_t tcp_sendspace;
<span class="enscript-type">extern</span>	u_int32_t tcp_recvspace;
tcp_seq <span class="enscript-function-name">tcp_new_isn</span>(<span class="enscript-type">struct</span> tcpcb *);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_input_checksum</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_getconninfo</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> conninfo_tcp *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">add_to_time_wait</span>(<span class="enscript-type">struct</span> tcpcb *, uint32_t delay);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_pmtud_revert_segment_size</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_rxtseg_insert</span>(<span class="enscript-type">struct</span> tcpcb *, tcp_seq, tcp_seq);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> tcp_rxt_seg *<span class="enscript-function-name">tcp_rxtseg_find</span>(<span class="enscript-type">struct</span> tcpcb *, tcp_seq, tcp_seq);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_rxtseg_clean</span>(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">tcp_rxtseg_detect_bad_rexmt</span>(<span class="enscript-type">struct</span> tcpcb *, tcp_seq);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">tcp_rxtseg_dsack_for_tlp</span>(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">tcp_rxtseg_total_size</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_rexmt_save_state</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_interface_send_probe</span>(u_int16_t if_index_available);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_probe_connectivity</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t enable);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_get_connectivity_status</span>(<span class="enscript-type">struct</span> tcpcb *,
    <span class="enscript-type">struct</span> tcp_conn_status *);

<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">tfo_enabled</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_disable_tfo</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_tfo_gen_cookie</span>(<span class="enscript-type">struct</span> inpcb *inp, u_char *out, size_t blk_size);
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_FASTOPEN_KEYLEN</span> 16

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_input_preproc</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_output_csum</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> mbuf *, int32_t, <span class="enscript-type">unsigned</span>, 
    u_int64_t, u_int32_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_adj_mss</span>(<span class="enscript-type">struct</span> tcpcb *, boolean_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_insert_rmap</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> mbuf *);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_RPIVATE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NETINET_TCP_VAR_H_ */</span>
</pre>
<hr />
</body></html>