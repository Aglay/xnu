<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>udp_usrreq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">udp_usrreq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)udp_usrreq.c	8.6 (Berkeley) 5/23/95
 * $FreeBSD: src/sys/netinet/udp_usrreq.c,v 1.64.2.13 2001/08/08 18:59:54 ghelmer Exp $
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/udp6_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> esp_udp_encap_port;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_IN_BEG</span>	NETDBG_CODE(DBG_NETUDP, 0)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_IN_END</span>	NETDBG_CODE(DBG_NETUDP, 2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_OUT_BEG</span>	NETDBG_CODE(DBG_NETUDP, 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_OUT_END</span>	NETDBG_CODE(DBG_NETUDP, 3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_UDP_INPUT</span>	NETDBG_CODE(DBG_NETUDP, (5 &lt;&lt; 8))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_UDP_OUTPUT</span>	NETDBG_CODE(DBG_NETUDP, (6 &lt;&lt; 8) | 1)

<span class="enscript-comment">/*
 * UDP protocol implementation.
 * Per RFC 768, August, 1980.
 */</span>
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">COMPAT_42</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> udpcksum = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> udpcksum = 0;		<span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_udp, UDPCTL_CHECKSUM, checksum,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;udpcksum, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> udp_log_in_vain = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_udp, OID_AUTO, log_in_vain, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;udp_log_in_vain, 0, <span class="enscript-string">&quot;Log all incoming UDP packets&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> blackhole = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_udp, OID_AUTO, blackhole, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;blackhole, 0, <span class="enscript-string">&quot;Do not send port unreachables for refused connects&quot;</span>);

<span class="enscript-type">struct</span> inpcbhead udb;		<span class="enscript-comment">/* from udp_var.h */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">udb6</span>	udb  <span class="enscript-comment">/* for KAME src sync over BSD*'s */</span>
<span class="enscript-type">struct</span> inpcbinfo udbinfo;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">UDBHASHSIZE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UDBHASHSIZE</span> 16
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Garbage collection performed during most recent udp_gc() run */</span>
<span class="enscript-type">static</span> boolean_t udp_gc_done = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_verbose;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfwsyslog</span>( <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format,...);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udp</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* Apple logging, log to ipfw.log */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>(a) {						\
	<span class="enscript-keyword">if</span> ((udp_log_in_vain == 3) &amp;&amp; (fw_verbose == 2)) {		\
		ipfwsyslog a;						\
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((udp_log_in_vain == 4) &amp;&amp; (fw_verbose == 2)) {       \
	        ipfw_stealth_stats_incr_udp();				\
	} <span class="enscript-keyword">else</span> {							\
		log a;							\
	}								\
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>( a ) { log a; }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> udp_getstat SYSCTL_HANDLER_ARGS;
<span class="enscript-type">struct</span>	udpstat udpstat;	<span class="enscript-comment">/* from udp_var.h */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, UDPCTL_STATS, stats,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, udp_getstat, <span class="enscript-string">&quot;S,udpstat&quot;</span>,
    <span class="enscript-string">&quot;UDP statistics (struct udpstat, netinet/udp_var.h)&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_udp, OID_AUTO, pcbcount,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;udbinfo.ipi_count, 0,
    <span class="enscript-string">&quot;Number of active PCBs&quot;</span>);

__private_extern__ <span class="enscript-type">int</span> udp_use_randomport = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_udp, OID_AUTO, randomize_ports,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;udp_use_randomport, 0,
    <span class="enscript-string">&quot;Randomize UDP port numbers&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> udp_in6 {
	<span class="enscript-type">struct</span> sockaddr_in6	uin6_sin;
	u_char			uin6_init_done : 1;
};
<span class="enscript-type">struct</span> udp_ip6 {
	<span class="enscript-type">struct</span> ip6_hdr		uip6_ip6;
	u_char			uip6_init_done : 1;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_abort</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_bind</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_connect</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_connectx</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_list **, <span class="enscript-type">struct</span> proc *, uint32_t, sae_associd_t,
    sae_connid_t *, uint32_t, <span class="enscript-type">void</span> *, uint32_t, <span class="enscript-type">struct</span> uio *, user_ssize_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_detach</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_disconnectx</span>(<span class="enscript-type">struct</span> socket *, sae_associd_t, sae_connid_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_send</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udp_append</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> ip *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-type">struct</span> udp_in6 *, <span class="enscript-type">struct</span> udp_ip6 *, <span class="enscript-type">struct</span> ifnet *);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !INET6 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udp_append</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> ip *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-type">struct</span> ifnet *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_input_checksum</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> udphdr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_output</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_2_ip6_hdr</span>(<span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> ip *ip);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udp_gc</span>(<span class="enscript-type">struct</span> inpcbinfo *);

<span class="enscript-type">struct</span> pr_usrreqs udp_usrreqs = {
	.pru_abort =		udp_abort,
	.pru_attach =		udp_attach,
	.pru_bind =		udp_bind,
	.pru_connect =		udp_connect,
	.pru_connectx =		udp_connectx,
	.pru_control =		in_control,
	.pru_detach =		udp_detach,
	.pru_disconnect =	udp_disconnect,
	.pru_disconnectx =	udp_disconnectx,
	.pru_peeraddr =		in_getpeeraddr,
	.pru_send =		udp_send,
	.pru_shutdown =		udp_shutdown,
	.pru_sockaddr =		in_getsockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
	.pru_soreceive_list =	soreceive_list,
};

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> udp_initialized = 0;
	vm_size_t		str_size;
	<span class="enscript-type">struct</span> inpcbinfo	*pcbinfo;

	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-keyword">if</span> (udp_initialized)
		<span class="enscript-keyword">return</span>;
	udp_initialized = 1;

	LIST_INIT(&amp;udb);
	udbinfo.ipi_listhead = &amp;udb;
	udbinfo.ipi_hashbase = hashinit(UDBHASHSIZE, M_PCB,
	    &amp;udbinfo.ipi_hashmask);
	udbinfo.ipi_porthashbase = hashinit(UDBHASHSIZE, M_PCB,
	    &amp;udbinfo.ipi_porthashmask);
	str_size = (vm_size_t) <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> inpcb);
	udbinfo.ipi_zone = zinit(str_size, 80000*str_size, 8192, <span class="enscript-string">&quot;udpcb&quot;</span>);

	pcbinfo = &amp;udbinfo;
	<span class="enscript-comment">/*
	 * allocate lock group attribute and group for udp pcb mutexes
	 */</span>
	pcbinfo-&gt;ipi_lock_grp_attr = lck_grp_attr_alloc_init();
	pcbinfo-&gt;ipi_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;udppcb&quot;</span>,
	    pcbinfo-&gt;ipi_lock_grp_attr);
	pcbinfo-&gt;ipi_lock_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> ((pcbinfo-&gt;ipi_lock = lck_rw_alloc_init(pcbinfo-&gt;ipi_lock_grp,
	    pcbinfo-&gt;ipi_lock_attr)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate PCB lock\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	udbinfo.ipi_gc = udp_gc;
	in_pcbinfo_attach(&amp;udbinfo);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> iphlen)
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> udphdr *uh;
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> mbuf *opts = NULL;
	<span class="enscript-type">int</span> len, isbroadcast;
	<span class="enscript-type">struct</span> ip save_ip;
	<span class="enscript-type">struct</span> sockaddr *append_sa;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = &amp;udbinfo;
	<span class="enscript-type">struct</span> sockaddr_in udp_in;
	<span class="enscript-type">struct</span> ip_moptions *imo = NULL;
	<span class="enscript-type">int</span> foundmembership = 0, ret = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> udp_in6 udp_in6;
	<span class="enscript-type">struct</span> udp_ip6 udp_ip6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	boolean_t cell = IFNET_IS_CELLULAR(ifp);
	boolean_t wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	boolean_t wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));

	bzero(&amp;udp_in, <span class="enscript-keyword">sizeof</span> (udp_in));
	udp_in.sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
	udp_in.sin_family = AF_INET;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	bzero(&amp;udp_in6, <span class="enscript-keyword">sizeof</span> (udp_in6));
	udp_in6.uin6_sin.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	udp_in6.uin6_sin.sin6_family = AF_INET6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	udpstat.udps_ipackets++;

	KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_START, 0,0,0,0,0);

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-comment">/*
	 * Strip IP options, if any; should skip this,
	 * make available to user, and use on returned packets,
	 * but we don't yet have a way to check the checksum
	 * with options still present.
	 */</span>
	<span class="enscript-keyword">if</span> (iphlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		ip_stripoptions(m, (<span class="enscript-type">struct</span> mbuf *)0);
		iphlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	}

	<span class="enscript-comment">/*
	 * Get IP and UDP header together in first mbuf.
	 */</span>
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) {
		m = m_pullup(m, iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr));
		<span class="enscript-keyword">if</span> (m == NULL) {
			udpstat.udps_hdrops++;
			KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END,
			    0,0,0,0,0);
			<span class="enscript-keyword">return</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	}
	uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip + iphlen);

	<span class="enscript-comment">/* destination port of 0 is illegal, based on RFC768. */</span>
	<span class="enscript-keyword">if</span> (uh-&gt;uh_dport == 0) {
		IF_UDP_STATINC(ifp, port0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	KERNEL_DEBUG(DBG_LAYER_IN_BEG, uh-&gt;uh_dport, uh-&gt;uh_sport,
	    ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr, uh-&gt;uh_ulen);

	<span class="enscript-comment">/*
	 * Make mbuf data length reflect UDP length.
	 * If not enough data to reflect UDP length, drop.
	 */</span>
	len = ntohs((u_short)uh-&gt;uh_ulen);
	<span class="enscript-keyword">if</span> (ip-&gt;ip_len != len) {
		<span class="enscript-keyword">if</span> (len &gt; ip-&gt;ip_len || len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) {
			udpstat.udps_badlen++;
			IF_UDP_STATINC(ifp, badlength);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		m_adj(m, len - ip-&gt;ip_len);
		<span class="enscript-comment">/* ip-&gt;ip_len = len; */</span>
	}
	<span class="enscript-comment">/*
	 * Save a copy of the IP header in case we want restore it
	 * for sending an ICMP error message in response.
	 */</span>
	save_ip = *ip;

	<span class="enscript-comment">/*
	 * Checksum extended UDP header and data.
	 */</span>
	<span class="enscript-keyword">if</span> (udp_input_checksum(m, uh, iphlen, len))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	isbroadcast = in_broadcast(ip-&gt;ip_dst, ifp);

	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr)) || isbroadcast) {
		<span class="enscript-type">int</span> reuse_sock = 0, mcast_delivered = 0;

		lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
		<span class="enscript-comment">/*
		 * Deliver a multicast or broadcast datagram to *all* sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multi/broadcasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */</span>

		<span class="enscript-comment">/*
		 * Construct sockaddr format source address.
		 */</span>
		udp_in.sin_port = uh-&gt;uh_sport;
		udp_in.sin_addr = ip-&gt;ip_src;
		<span class="enscript-comment">/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		udp_in6.uin6_init_done = udp_ip6.uip6_init_done = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		LIST_FOREACH(inp, &amp;udb, inp_list) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-type">int</span> skipit;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

			<span class="enscript-keyword">if</span> (inp-&gt;inp_socket == NULL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (inp != sotoinpcb(inp-&gt;inp_socket)) {
				panic(<span class="enscript-string">&quot;%s: bad so back ptr inp=%p\n&quot;</span>,
				    __func__, inp);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
                        <span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV4) == 0)
                                <span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> ((inp-&gt;inp_moptions == NULL) &amp;&amp;
			    (ntohl(ip-&gt;ip_dst.s_addr) !=
			    INADDR_ALLHOSTS_GROUP) &amp;&amp; (isbroadcast == 0))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) ==
			    WNT_STOPUSING)
				<span class="enscript-keyword">continue</span>;

			udp_lock(inp-&gt;inp_socket, 1, 0);

			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) ==
			    WNT_STOPUSING) {
				udp_unlock(inp-&gt;inp_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (inp-&gt;inp_lport != uh-&gt;uh_dport) {
				udp_unlock(inp-&gt;inp_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY) {
				<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr !=
				    ip-&gt;ip_dst.s_addr) {
					udp_unlock(inp-&gt;inp_socket, 1, 0);
					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != INADDR_ANY) {
				<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr !=
				    ip-&gt;ip_src.s_addr ||
				    inp-&gt;inp_fport != uh-&gt;uh_sport) {
					udp_unlock(inp-&gt;inp_socket, 1, 0);
					<span class="enscript-keyword">continue</span>;
				}
			}

			<span class="enscript-keyword">if</span> (isbroadcast == 0 &amp;&amp; (ntohl(ip-&gt;ip_dst.s_addr) !=
			    INADDR_ALLHOSTS_GROUP)) {
				<span class="enscript-type">struct</span> sockaddr_in group;
				<span class="enscript-type">int</span> blocked;

				<span class="enscript-keyword">if</span> ((imo = inp-&gt;inp_moptions) == NULL) {
					udp_unlock(inp-&gt;inp_socket, 1, 0);
					<span class="enscript-keyword">continue</span>;
				}
				IMO_LOCK(imo);

				bzero(&amp;group, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in));
				group.sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
				group.sin_family = AF_INET;
				group.sin_addr = ip-&gt;ip_dst;

				blocked = imo_multi_filter(imo, ifp,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;group,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;udp_in);
				<span class="enscript-keyword">if</span> (blocked == MCAST_PASS)
					foundmembership = 1;

				IMO_UNLOCK(imo);
				<span class="enscript-keyword">if</span> (!foundmembership) {
					udp_unlock(inp-&gt;inp_socket, 1, 0);
					<span class="enscript-keyword">if</span> (blocked == MCAST_NOTSMEMBER ||
					    blocked == MCAST_MUTED)
						udpstat.udps_filtermcast++;
					<span class="enscript-keyword">continue</span>;
				}
				foundmembership = 0;
			}

			reuse_sock = (inp-&gt;inp_socket-&gt;so_options &amp;
			    (SO_REUSEPORT|SO_REUSEADDR));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
			skipit = 0;
			<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v4(inp, 
			    uh-&gt;uh_dport, uh-&gt;uh_sport, &amp;ip-&gt;ip_dst,
			    &amp;ip-&gt;ip_src, ifp, NULL, NULL)) {
				<span class="enscript-comment">/* do not inject data to pcb */</span>
				skipit = 1;
			}
			<span class="enscript-keyword">if</span> (skipit == 0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
			{
				<span class="enscript-type">struct</span> mbuf *n = NULL;

				<span class="enscript-keyword">if</span> (reuse_sock)
					n = m_copy(m, 0, M_COPYALL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				udp_append(inp, ip, m,
				    iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr),
				    &amp;udp_in, &amp;udp_in6, &amp;udp_ip6, ifp);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !INET6 */</span>
				udp_append(inp, ip, m,
				    iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr),
				    &amp;udp_in, ifp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
				mcast_delivered++;

				m = n;
			}
			udp_unlock(inp-&gt;inp_socket, 1, 0);

			<span class="enscript-comment">/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It assumes that an application will never
			 * clear these options after setting them.
			 */</span>
			<span class="enscript-keyword">if</span> (reuse_sock == 0 || m == NULL)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * Expect 32-bit aligned data pointer on strict-align
			 * platforms.
			 */</span>
			MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);
			<span class="enscript-comment">/*
			 * Recompute IP and UDP header pointers for new mbuf
			 */</span>
			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip + iphlen);
		}
		lck_rw_done(pcbinfo-&gt;ipi_lock);

		<span class="enscript-keyword">if</span> (mcast_delivered == 0) {
			<span class="enscript-comment">/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */</span>
			udpstat.udps_noportbcast++;
			IF_UDP_STATINC(ifp, port_unreach);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/* free the extra copy of mbuf or skipped by IPSec */</span>
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END, 0,0,0,0,0);
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * UDP to port 4500 with a payload where the first four bytes are
	 * not zero is a UDP encapsulated IPSec packet. Packets where
	 * the payload is one byte and that byte is 0xFF are NAT keepalive
	 * packets. Decapsulate the ESP packet and carry on with IPSec input
	 * or discard the NAT keep-alive.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; (esp_udp_encap_port &amp; 0xFFFF) != 0 &amp;&amp;
	    uh-&gt;uh_dport == ntohs((u_short)esp_udp_encap_port)) {
		<span class="enscript-type">int</span> payload_len = len - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) &gt; 4 ? 4 :
		    len - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr);

		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) + payload_len) {
			<span class="enscript-keyword">if</span> ((m = m_pullup(m, iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) +
			    payload_len)) == NULL) {
				udpstat.udps_hdrops++;
				KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END,
				    0,0,0,0,0);
				<span class="enscript-keyword">return</span>;
			}
			<span class="enscript-comment">/*
			 * Expect 32-bit aligned data pointer on strict-align
			 * platforms.
			 */</span>
			MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip + iphlen);
		}
		<span class="enscript-comment">/* Check for NAT keepalive packet */</span>
		<span class="enscript-keyword">if</span> (payload_len == 1 &amp;&amp; *(u_int8_t*)
		    ((caddr_t)uh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) == 0xFF) {
			m_freem(m);
			KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END,
			    0,0,0,0,0);
			<span class="enscript-keyword">return</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (payload_len == 4 &amp;&amp; *(u_int32_t*)(<span class="enscript-type">void</span> *)
		    ((caddr_t)uh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) != 0) {
			<span class="enscript-comment">/* UDP encapsulated IPSec packet to pass through NAT */</span>
			KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END,
			    0,0,0,0,0);
			<span class="enscript-comment">/* preserve the udp header */</span>
			esp4_input(m, iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr));
			<span class="enscript-keyword">return</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Locate pcb for datagram.
	 */</span>
	inp = in_pcblookup_hash(&amp;udbinfo, ip-&gt;ip_src, uh-&gt;uh_sport,
	    ip-&gt;ip_dst, uh-&gt;uh_dport, 1, ifp);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		IF_UDP_STATINC(ifp, port_unreach);

		<span class="enscript-keyword">if</span> (udp_log_in_vain) {
			<span class="enscript-type">char</span> buf[MAX_IPv4_STR_LEN];
			<span class="enscript-type">char</span> buf2[MAX_IPv4_STR_LEN];

			<span class="enscript-comment">/* check src and dst address */</span>
			<span class="enscript-keyword">if</span> (udp_log_in_vain &lt; 3) {
				log(LOG_INFO, <span class="enscript-string">&quot;Connection attempt to &quot;</span>
				    <span class="enscript-string">&quot;UDP %s:%d from %s:%d\n&quot;</span>, inet_ntop(AF_INET,
				        &amp;ip-&gt;ip_dst, buf, <span class="enscript-keyword">sizeof</span> (buf)),
					ntohs(uh-&gt;uh_dport), inet_ntop(AF_INET,
					&amp;ip-&gt;ip_src, buf2, <span class="enscript-keyword">sizeof</span> (buf2)),
					ntohs(uh-&gt;uh_sport));
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) &amp;&amp;
			    ip-&gt;ip_dst.s_addr != ip-&gt;ip_src.s_addr) {
				log_in_vain_log((LOG_INFO,
				    <span class="enscript-string">&quot;Stealth Mode connection attempt to &quot;</span>
				    <span class="enscript-string">&quot;UDP %s:%d from %s:%d\n&quot;</span>, inet_ntop(AF_INET,
				    &amp;ip-&gt;ip_dst, buf, <span class="enscript-keyword">sizeof</span> (buf)),
				    ntohs(uh-&gt;uh_dport), inet_ntop(AF_INET,
				    &amp;ip-&gt;ip_src, buf2, <span class="enscript-keyword">sizeof</span> (buf2)),
				    ntohs(uh-&gt;uh_sport)))
			}
		}
		udpstat.udps_noport++;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) {
			udpstat.udps_noportbcast++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ICMP_BANDLIM</span>
		<span class="enscript-keyword">if</span> (badport_bandlim(BANDLIM_ICMP_UNREACH) &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ICMP_BANDLIM */</span>
		<span class="enscript-keyword">if</span> (blackhole)
			<span class="enscript-keyword">if</span> (ifp &amp;&amp; ifp-&gt;if_type != IFT_LOOP)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		*ip = save_ip;
		ip-&gt;ip_len += iphlen;
		icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_PORT, 0, 0);
		KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END, 0,0,0,0,0);
		<span class="enscript-keyword">return</span>;
	}
	udp_lock(inp-&gt;inp_socket, 1, 0);

	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
		udp_unlock(inp-&gt;inp_socket, 1, 0);
		IF_UDP_STATINC(ifp, cleanup);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v4(inp, uh-&gt;uh_dport,
	    uh-&gt;uh_sport, &amp;ip-&gt;ip_dst, &amp;ip-&gt;ip_src, ifp, NULL, NULL)) {
		udp_unlock(inp-&gt;inp_socket, 1, 0);
		IF_UDP_STATINC(ifp, badipsec);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * Construct sockaddr format source address.
	 * Stuff source address and datagram in user buffer.
	 */</span>
	udp_in.sin_port = uh-&gt;uh_sport;
	udp_in.sin_addr = ip-&gt;ip_src;
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; INP_CONTROLOPTS) != 0 ||
	    (inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
	    (inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
			<span class="enscript-type">int</span> savedflags;

			ip_2_ip6_hdr(&amp;udp_ip6.uip6_ip6, ip);
			savedflags = inp-&gt;inp_flags;
			inp-&gt;inp_flags &amp;= ~INP_UNMAPPABLEOPTS;
			ret = ip6_savecontrol(inp, m, &amp;opts);
			inp-&gt;inp_flags = savedflags;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			ret = ip_savecontrol(inp, &amp;opts, ip, m);
		}
		<span class="enscript-keyword">if</span> (ret != 0) {
			udp_unlock(inp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	m_adj(m, iphlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr));

	KERNEL_DEBUG(DBG_LAYER_IN_END, uh-&gt;uh_dport, uh-&gt;uh_sport,
	    save_ip.ip_src.s_addr, save_ip.ip_dst.s_addr, uh-&gt;uh_ulen);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		in6_sin_2_v4mapsin6(&amp;udp_in, &amp;udp_in6.uin6_sin);
		append_sa = (<span class="enscript-type">struct</span> sockaddr *)&amp;udp_in6.uin6_sin;
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		append_sa = (<span class="enscript-type">struct</span> sockaddr *)&amp;udp_in;
	}
	<span class="enscript-keyword">if</span> (nstat_collect) {
		INP_ADD_STAT(inp, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(inp, cell, wifi, wired, rxbytes, m-&gt;m_pkthdr.len);
	}
	so_recv_data_stat(inp-&gt;inp_socket, m, 0);
	<span class="enscript-keyword">if</span> (sbappendaddr(&amp;inp-&gt;inp_socket-&gt;so_rcv, append_sa,
	    m, opts, NULL) == 0) {
		udpstat.udps_fullsock++;
	} <span class="enscript-keyword">else</span> {
		sorwakeup(inp-&gt;inp_socket);
	}
	udp_unlock(inp-&gt;inp_socket, 1, 0);
	KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END, 0,0,0,0,0);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">if</span> (opts)
		m_freem(opts);
	KERNEL_DEBUG(DBG_FNC_UDP_INPUT | DBG_FUNC_END, 0,0,0,0,0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_2_ip6_hdr</span>(<span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> ip *ip)
{
	bzero(ip6, <span class="enscript-keyword">sizeof</span> (*ip6));

	ip6-&gt;ip6_vfc = IPV6_VERSION;
	ip6-&gt;ip6_plen = ip-&gt;ip_len;
	ip6-&gt;ip6_nxt = ip-&gt;ip_p;
	ip6-&gt;ip6_hlim = ip-&gt;ip_ttl;
	<span class="enscript-keyword">if</span> (ip-&gt;ip_src.s_addr) {
		ip6-&gt;ip6_src.s6_addr32[2] = IPV6_ADDR_INT32_SMP;
		ip6-&gt;ip6_src.s6_addr32[3] = ip-&gt;ip_src.s_addr;
	}
	<span class="enscript-keyword">if</span> (ip-&gt;ip_dst.s_addr) {
		ip6-&gt;ip6_dst.s6_addr32[2] = IPV6_ADDR_INT32_SMP;
		ip6-&gt;ip6_dst.s6_addr32[3] = ip-&gt;ip_dst.s_addr;
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * subroutine of udp_input(), mainly for source code readability.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-function-name">udp_append</span>(<span class="enscript-type">struct</span> inpcb *last, <span class="enscript-type">struct</span> ip *ip, <span class="enscript-type">struct</span> mbuf *n, <span class="enscript-type">int</span> off,
    <span class="enscript-type">struct</span> sockaddr_in *pudp_in, <span class="enscript-type">struct</span> udp_in6 *pudp_in6,
    <span class="enscript-type">struct</span> udp_ip6 *pudp_ip6, <span class="enscript-type">struct</span> ifnet *ifp)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !INET6 */</span>
<span class="enscript-function-name">udp_append</span>(<span class="enscript-type">struct</span> inpcb *last, <span class="enscript-type">struct</span> ip *ip, <span class="enscript-type">struct</span> mbuf *n, <span class="enscript-type">int</span> off,
    <span class="enscript-type">struct</span> sockaddr_in *pudp_in, <span class="enscript-type">struct</span> ifnet *ifp)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
{
	<span class="enscript-type">struct</span> sockaddr *append_sa;
	<span class="enscript-type">struct</span> mbuf *opts = 0;
	boolean_t cell = IFNET_IS_CELLULAR(ifp);
	boolean_t wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	boolean_t wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));
	<span class="enscript-type">int</span> ret = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">if</span> (mac_inpcb_check_deliver(last, n, AF_INET, SOCK_DGRAM) != 0) {
		m_freem(n);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
	<span class="enscript-keyword">if</span> ((last-&gt;inp_flags &amp; INP_CONTROLOPTS) != 0 ||
	    (last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
	    (last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (last-&gt;inp_vflag &amp; INP_IPV6) {
			<span class="enscript-type">int</span> savedflags;

			<span class="enscript-keyword">if</span> (pudp_ip6-&gt;uip6_init_done == 0) {
				ip_2_ip6_hdr(&amp;pudp_ip6-&gt;uip6_ip6, ip);
				pudp_ip6-&gt;uip6_init_done = 1;
			}
			savedflags = last-&gt;inp_flags;
			last-&gt;inp_flags &amp;= ~INP_UNMAPPABLEOPTS;
			ret = ip6_savecontrol(last, n, &amp;opts);
			<span class="enscript-keyword">if</span> (ret != 0) {
				last-&gt;inp_flags = savedflags;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
			}
			last-&gt;inp_flags = savedflags;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			ret = ip_savecontrol(last, &amp;opts, ip, n);
			<span class="enscript-keyword">if</span> (ret != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
			}
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (last-&gt;inp_vflag &amp; INP_IPV6) {
		<span class="enscript-keyword">if</span> (pudp_in6-&gt;uin6_init_done == 0) {
			in6_sin_2_v4mapsin6(pudp_in, &amp;pudp_in6-&gt;uin6_sin);
			pudp_in6-&gt;uin6_init_done = 1;
		}
		append_sa = (<span class="enscript-type">struct</span> sockaddr *)&amp;pudp_in6-&gt;uin6_sin;
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	append_sa = (<span class="enscript-type">struct</span> sockaddr *)pudp_in;
	<span class="enscript-keyword">if</span> (nstat_collect) {
		INP_ADD_STAT(last, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(last, cell, wifi, wired, rxbytes, 
		    n-&gt;m_pkthdr.len);
	}
	so_recv_data_stat(last-&gt;inp_socket, n, 0);
	m_adj(n, off);
	<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;inp_socket-&gt;so_rcv, append_sa,
	    n, opts, NULL) == 0) {
		udpstat.udps_fullsock++;
	} <span class="enscript-keyword">else</span> {
		sorwakeup(last-&gt;inp_socket);
	}
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">error</span>:
	m_freem(n);
	m_freem(opts);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Notify a udp user of an asynchronous error;
 * just wake up so that he can collect error status.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_notify</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> errno)
{
	inp-&gt;inp_socket-&gt;so_error = errno;
	sorwakeup(inp-&gt;inp_socket);
	sowwakeup(inp-&gt;inp_socket);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_ctlinput</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">void</span> *vip)
{
	<span class="enscript-type">struct</span> ip *ip = vip;
	<span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>) = udp_notify;
        <span class="enscript-type">struct</span> in_addr faddr;
	<span class="enscript-type">struct</span> inpcb *inp;

	faddr = ((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)sa)-&gt;sin_addr;
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_INET || faddr.s_addr == INADDR_ANY)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (PRC_IS_REDIRECT(cmd)) {
		ip = 0;
		notify = in_rtchange;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == PRC_HOSTDEAD) {
		ip = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cmd &gt;= PRC_NCMDS || inetctlerrmap[cmd] == 0) {
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (ip) {
		<span class="enscript-type">struct</span> udphdr uh;

		bcopy(((caddr_t)ip + (ip-&gt;ip_hl &lt;&lt; 2)), &amp;uh, <span class="enscript-keyword">sizeof</span> (uh));
		inp = in_pcblookup_hash(&amp;udbinfo, faddr, uh.uh_dport,
                    ip-&gt;ip_src, uh.uh_sport, 0, NULL);
		<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; inp-&gt;inp_socket != NULL) {
			udp_lock(inp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) ==
			    WNT_STOPUSING)  {
				udp_unlock(inp-&gt;inp_socket, 1, 0);
				<span class="enscript-keyword">return</span>;
			}
			(*notify)(inp, inetctlerrmap[cmd]);
			udp_unlock(inp-&gt;inp_socket, 1, 0);
		}
	} <span class="enscript-keyword">else</span> {
		in_pcbnotifyall(&amp;udbinfo, faddr, inetctlerrmap[cmd], notify);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span>	error, optval;
	<span class="enscript-type">struct</span>	inpcb *inp;

	<span class="enscript-comment">/* Allow &lt;SOL_SOCKET,SO_FLUSH&gt; at this level */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_UDP &amp;&amp;
	    !(sopt-&gt;sopt_level == SOL_SOCKET &amp;&amp; sopt-&gt;sopt_name == SO_FLUSH))
		<span class="enscript-keyword">return</span> (ip_ctloutput(so, sopt));

	error = 0;
	inp = sotoinpcb(so);

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UDP_NOCKSUM</span>:
			<span class="enscript-comment">/* This option is settable only for UDP over IPv4 */</span>
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (optval != 0)
				inp-&gt;inp_flags |= INP_UDP_NOCKSUM;
			<span class="enscript-keyword">else</span>
				inp-&gt;inp_flags &amp;= ~INP_UDP_NOCKSUM;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UDP_KEEPALIVE_OFFLOAD</span>:
		{
			<span class="enscript-type">struct</span> udp_keepalive_offload ka;
			<span class="enscript-comment">/*
			 * If the socket is not connected, the stack will
			 * not know the destination address to put in the
			 * keepalive datagram. Return an error now instead
			 * of failing later.
			 */</span>
			<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; SS_ISCONNECTED)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize != <span class="enscript-keyword">sizeof</span>(ka)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;ka, <span class="enscript-keyword">sizeof</span>(ka),
			    <span class="enscript-keyword">sizeof</span>(ka))) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* application should specify the type */</span>
			<span class="enscript-keyword">if</span> (ka.ka_type == 0)
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-keyword">if</span> (ka.ka_interval == 0) {
				<span class="enscript-comment">/*
				 * if interval is 0, disable the offload
				 * mechanism
				 */</span>
				<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_data != NULL)
					FREE(inp-&gt;inp_keepalive_data,
					    M_TEMP);
				inp-&gt;inp_keepalive_data = NULL;
				inp-&gt;inp_keepalive_datalen = 0;
				inp-&gt;inp_keepalive_interval = 0;
				inp-&gt;inp_keepalive_type = 0;
				inp-&gt;inp_flags2 &amp;= ~INP2_KEEPALIVE_OFFLOAD;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_data != NULL) {
					FREE(inp-&gt;inp_keepalive_data,
					    M_TEMP);
					inp-&gt;inp_keepalive_data = NULL;
				}

				inp-&gt;inp_keepalive_datalen = min(
				    ka.ka_data_len,
				    UDP_KEEPALIVE_OFFLOAD_DATA_SIZE);
				<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_datalen &gt; 0) {
					MALLOC(inp-&gt;inp_keepalive_data,
					    u_int8_t *, 
					    inp-&gt;inp_keepalive_datalen,
					    M_TEMP, M_WAITOK);
					<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_data == NULL) {
						inp-&gt;inp_keepalive_datalen = 0;
						error = ENOMEM;
						<span class="enscript-keyword">break</span>;
					}
					bcopy(ka.ka_data,
					    inp-&gt;inp_keepalive_data,
					    inp-&gt;inp_keepalive_datalen);
				} <span class="enscript-keyword">else</span> {
					inp-&gt;inp_keepalive_datalen = 0;
				}
				inp-&gt;inp_keepalive_interval =
				    min(UDP_KEEPALIVE_INTERVAL_MAX_SECONDS,
				    ka.ka_interval);
				inp-&gt;inp_keepalive_type = ka.ka_type;
				inp-&gt;inp_flags2 |= INP2_KEEPALIVE_OFFLOAD;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			error = inp_flush(inp, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">UDP_NOCKSUM</span>:
			optval = inp-&gt;inp_flags &amp; INP_UDP_NOCKSUM;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (error == 0)
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
udp_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i, n;
	<span class="enscript-type">struct</span> inpcb *inp, **inp_list;
	inp_gen_t gencnt;
	<span class="enscript-type">struct</span> xinpgen xig;

	<span class="enscript-comment">/*
	 * The process of preparing the TCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */</span>
	lck_rw_lock_exclusive(udbinfo.ipi_lock);
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		n = udbinfo.ipi_count;
		req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> (xig))
			+ (n + n/8) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xinpcb);
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">/*
	 * OK, now we're committed to doing something.
	 */</span>
	gencnt = udbinfo.ipi_gencnt;
	n = udbinfo.ipi_count;

	bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> (*inp_list), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (inp_list == 0) {
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-keyword">for</span> (inp = LIST_FIRST(udbinfo.ipi_listhead), i = 0; inp &amp;&amp; i &lt; n;
	     inp = LIST_NEXT(inp, inp_list)) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
	}
	n = i;

	error = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
		inp = inp_list[i];
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD) {
			<span class="enscript-type">struct</span> xinpcb xi;

			bzero(&amp;xi, <span class="enscript-keyword">sizeof</span> (xi));
			xi.xi_len = <span class="enscript-keyword">sizeof</span> (xi);
			<span class="enscript-comment">/* XXX should avoid extra copy */</span>
			inpcb_to_compat(inp, &amp;xi.xi_inp);
			<span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
				sotoxsocket(inp-&gt;inp_socket, &amp;xi.xi_socket);
			error = SYSCTL_OUT(req, &amp;xi, <span class="enscript-keyword">sizeof</span> (xi));
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
		xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
		xig.xig_gen = udbinfo.ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = udbinfo.ipi_count;
		error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	}
	FREE(inp_list, M_TEMP);
	lck_rw_done(udbinfo.ipi_lock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, UDPCTL_PCBLIST, pcblist,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, udp_pcblist,
    <span class="enscript-string">&quot;S,xinpcb&quot;</span>, <span class="enscript-string">&quot;List of active UDP sockets&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
udp_pcblist64 SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
        <span class="enscript-type">int</span> error, i, n;
        <span class="enscript-type">struct</span> inpcb *inp, **inp_list;
        inp_gen_t gencnt;
        <span class="enscript-type">struct</span> xinpgen xig;

        <span class="enscript-comment">/*
         * The process of preparing the TCB list is too time-consuming and
         * resource-intensive to repeat twice on every request.
         */</span>
        lck_rw_lock_shared(udbinfo.ipi_lock);
        <span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
                n = udbinfo.ipi_count;
                req-&gt;oldidx =
		    2 * (<span class="enscript-keyword">sizeof</span> (xig)) + (n + n/8) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xinpcb64);
                lck_rw_done(udbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> (0);
        }

        <span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
                lck_rw_done(udbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> (EPERM);
        }

        <span class="enscript-comment">/*
         * OK, now we're committed to doing something.
         */</span>
        gencnt = udbinfo.ipi_gencnt;
        n = udbinfo.ipi_count;

        bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
        xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
        xig.xig_count = n;
        xig.xig_gen = gencnt;
        xig.xig_sogen = so_gencnt;
        error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
        <span class="enscript-keyword">if</span> (error) {
                lck_rw_done(udbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> (error);
        }
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		lck_rw_done(udbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> (0);
	}

        inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> (*inp_list), M_TEMP, M_WAITOK);
        <span class="enscript-keyword">if</span> (inp_list == 0) {
                lck_rw_done(udbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> (ENOMEM);
        }

        <span class="enscript-keyword">for</span> (inp = LIST_FIRST(udbinfo.ipi_listhead), i = 0; inp &amp;&amp; i &lt; n;
             inp = LIST_NEXT(inp, inp_list)) {
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD)
                        inp_list[i++] = inp;
        }
        n = i;

        error = 0;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
                inp = inp_list[i];
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD) {
                        <span class="enscript-type">struct</span> xinpcb64 xi;

                        bzero(&amp;xi, <span class="enscript-keyword">sizeof</span> (xi));
                        xi.xi_len = <span class="enscript-keyword">sizeof</span> (xi);
                        inpcb_to_xinpcb64(inp, &amp;xi);
                        <span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
                                sotoxsocket64(inp-&gt;inp_socket, &amp;xi.xi_socket);
                        error = SYSCTL_OUT(req, &amp;xi, <span class="enscript-keyword">sizeof</span> (xi));
                }
        }
        <span class="enscript-keyword">if</span> (!error) {
                <span class="enscript-comment">/*
                 * Give the user an updated idea of our state.
                 * If the generation differs from what we told
                 * her before, she knows that something happened
                 * while we were processing this request, and it
                 * might be necessary to retry.
                 */</span>
                bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
                xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
                xig.xig_gen = udbinfo.ipi_gencnt;
                xig.xig_sogen = so_gencnt;
                xig.xig_count = udbinfo.ipi_count;
                error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
        }
        FREE(inp_list, M_TEMP);
        lck_rw_done(udbinfo.ipi_lock);
        <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, OID_AUTO, pcblist64,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, udp_pcblist64,
    <span class="enscript-string">&quot;S,xinpcb64&quot;</span>, <span class="enscript-string">&quot;List of active UDP sockets&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
udp_pcblist_n SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">return</span> (get_pcblist_n(IPPROTO_UDP, req, &amp;udbinfo));
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, OID_AUTO, pcblist_n,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, udp_pcblist_n,
    <span class="enscript-string">&quot;S,xinpcb_n&quot;</span>, <span class="enscript-string">&quot;List of active UDP sockets&quot;</span>);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_get_ports_used</span>(uint32_t ifindex, <span class="enscript-type">int</span> protocol, uint32_t flags,
    bitstr_t *bitfield)
{
	inpcb_get_ports_used(ifindex, protocol, flags, bitfield, &amp;udbinfo);
}

__private_extern__ uint32_t
<span class="enscript-function-name">udp_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, u_int32_t flags)
{
	<span class="enscript-keyword">return</span> (inpcb_count_opportunistic(ifindex, &amp;udbinfo, flags));
}

__private_extern__ uint32_t
<span class="enscript-function-name">udp_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-keyword">return</span> (inpcb_find_anypcb_byaddr(ifa, &amp;udbinfo));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_check_pktinfo</span>(<span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> ifnet **outif,
    <span class="enscript-type">struct</span> in_addr *laddr)
{
	<span class="enscript-type">struct</span> cmsghdr *cm = 0;
	<span class="enscript-type">struct</span> in_pktinfo *pktinfo;
	<span class="enscript-type">struct</span> ifnet *ifp;

	<span class="enscript-keyword">if</span> (outif != NULL)
		*outif = NULL;

	<span class="enscript-comment">/*
	 * XXX: Currently, we assume all the optional information is stored
	 * in a single mbuf.
	 */</span>
	<span class="enscript-keyword">if</span> (control-&gt;m_next)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (control-&gt;m_len &lt; CMSG_LEN(0))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">for</span> (cm = M_FIRST_CMSGHDR(control); cm;
	    cm = M_NXT_CMSGHDR(control, cm)) {
		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cmsghdr) ||
		    cm-&gt;cmsg_len &gt; control-&gt;m_len)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_level != IPPROTO_IP || cm-&gt;cmsg_type != IP_PKTINFO)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len != CMSG_LEN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_pktinfo)))
			<span class="enscript-keyword">return</span> (EINVAL);

		pktinfo =  (<span class="enscript-type">struct</span> in_pktinfo *)(<span class="enscript-type">void</span> *)CMSG_DATA(cm);

		<span class="enscript-comment">/* Check for a valid ifindex in pktinfo */</span>
		ifnet_head_lock_shared();

		<span class="enscript-keyword">if</span> (pktinfo-&gt;ipi_ifindex &gt; if_index) {
			ifnet_head_done();
			<span class="enscript-keyword">return</span> (ENXIO);
		}

		<span class="enscript-comment">/*
		 * If ipi_ifindex is specified it takes precedence
		 * over ipi_spec_dst.
		 */</span>
		<span class="enscript-keyword">if</span> (pktinfo-&gt;ipi_ifindex) {
			ifp = ifindex2ifnet[pktinfo-&gt;ipi_ifindex];
			<span class="enscript-keyword">if</span> (ifp == NULL) {
				ifnet_head_done();
				<span class="enscript-keyword">return</span> (ENXIO);
			}
			<span class="enscript-keyword">if</span> (outif != NULL) {
				ifnet_reference(ifp);
				*outif = ifp;
			}
			ifnet_head_done();
			laddr-&gt;s_addr = INADDR_ANY;
			<span class="enscript-keyword">break</span>;
		}

		ifnet_head_done();

		<span class="enscript-comment">/*
		 * Use the provided ipi_spec_dst address for temp
		 * source address.
		 */</span>
		*laddr = pktinfo-&gt;ipi_spec_dst;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_output</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> sockaddr *addr,
    <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> udpiphdr *ui;
	<span class="enscript-type">int</span> len = m-&gt;m_pkthdr.len;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	<span class="enscript-type">struct</span> in_addr origladdr, laddr, faddr, pi_laddr;
	u_short lport, fport;
	<span class="enscript-type">int</span> error = 0, udp_dodisconnect = 0, pktinfo = 0;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> soopts = 0;
	<span class="enscript-type">struct</span> mbuf *inpopts;
	<span class="enscript-type">struct</span> ip_moptions *mopts;
	<span class="enscript-type">struct</span> route ro;
	<span class="enscript-type">struct</span> ip_out_args ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF, 0 };
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> flowadv *adv = &amp;ipoa.ipoa_flowadv;
	mbuf_svc_class_t msc = MBUF_SC_UNSPEC;
	<span class="enscript-type">struct</span> ifnet *origoutifp = NULL;
	<span class="enscript-type">int</span> flowadv = 0;

	<span class="enscript-comment">/* Enable flow advisory only when connected */</span>
	flowadv = (so-&gt;so_state &amp; SS_ISCONNECTED) ? 1 : 0;
	pi_laddr.s_addr = INADDR_ANY;

	KERNEL_DEBUG(DBG_FNC_UDP_OUTPUT | DBG_FUNC_START, 0,0,0,0,0);

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (control != NULL) {
		msc = mbuf_service_class_from_control(control);
		VERIFY(outif == NULL);
		error = udp_check_pktinfo(control, &amp;outif, &amp;pi_laddr);
		m_freem(control);
		control = NULL;
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		pktinfo++;
		<span class="enscript-keyword">if</span> (outif != NULL)
			ipoa.ipoa_boundif = outif-&gt;if_index;
	}

	KERNEL_DEBUG(DBG_LAYER_OUT_BEG, inp-&gt;inp_fport, inp-&gt;inp_lport,
	    inp-&gt;inp_laddr.s_addr, inp-&gt;inp_faddr.s_addr,
	    (htons((u_short)len + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr))));

	<span class="enscript-keyword">if</span> (len + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr) &gt; IP_MAXPACKET) {
		error = EMSGSIZE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	<span class="enscript-keyword">if</span> (flowadv &amp;&amp; INP_WAIT_FOR_IF_FEEDBACK(inp)) {
		<span class="enscript-comment">/*
		 * The socket is flow-controlled, drop the packets
		 * until the inp is not flow controlled
		 */</span>
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}
	<span class="enscript-comment">/*
	 * If socket was bound to an ifindex, tell ip_output about it.
	 * If the ancillary IP_PKTINFO option contains an interface index,
	 * it takes precedence over the one specified by IP_BOUND_IF.
	 */</span>
	<span class="enscript-keyword">if</span> (ipoa.ipoa_boundif == IFSCOPE_NONE &amp;&amp;
	    (inp-&gt;inp_flags &amp; INP_BOUND_IF)) {
		VERIFY(inp-&gt;inp_boundifp != NULL);
		ifnet_reference(inp-&gt;inp_boundifp);	<span class="enscript-comment">/* for this routine */</span>
		<span class="enscript-keyword">if</span> (outif != NULL)
			ifnet_release(outif);
		outif = inp-&gt;inp_boundifp;
		ipoa.ipoa_boundif = outif-&gt;if_index;
	}
	<span class="enscript-keyword">if</span> (INP_NO_CELLULAR(inp))
		ipoa.ipoa_flags |=  IPOAF_NO_CELLULAR;
	<span class="enscript-keyword">if</span> (INP_NO_EXPENSIVE(inp))
		ipoa.ipoa_flags |=  IPOAF_NO_EXPENSIVE;
	<span class="enscript-keyword">if</span> (INP_AWDL_UNRESTRICTED(inp))
		ipoa.ipoa_flags |=  IPOAF_AWDL_UNRESTRICTED;
	soopts |= IP_OUTARGS;

	<span class="enscript-comment">/*
	 * If there was a routing change, discard cached route and check
	 * that we have a valid source address.  Reacquire a new source
	 * address if INADDR_ANY was specified.
	 */</span>
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;inp-&gt;inp_route)) {
		<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;

		ROUTE_RELEASE(&amp;inp-&gt;inp_route);

		<span class="enscript-comment">/* src address is gone? */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY &amp;&amp;
		    (ia = ifa_foraddr(inp-&gt;inp_laddr.s_addr)) == NULL) {
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; INP_INADDR_ANY) ||
			    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
				<span class="enscript-comment">/*
				 * Rdar://5448998
				 * If the source address is gone, return an
				 * error if:
				 * - the source was specified
				 * - the socket was already connected
				 */</span>
				soevent(so, (SO_FILT_HINT_LOCKED |
				    SO_FILT_HINT_NOSRCADDR));
				error = EADDRNOTAVAIL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* new src will be set later */</span>
				inp-&gt;inp_laddr.s_addr = INADDR_ANY;
				inp-&gt;inp_last_outifp = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
	}

	<span class="enscript-comment">/*
	 * IP_PKTINFO option check.  If a temporary scope or src address
	 * is provided, use it for this packet only and make sure we forget
	 * it after sending this datagram.
	 */</span>
	<span class="enscript-keyword">if</span> (pi_laddr.s_addr != INADDR_ANY ||
	    (ipoa.ipoa_boundif != IFSCOPE_NONE &amp;&amp; pktinfo)) {
		<span class="enscript-comment">/* temp src address for this datagram only */</span>
		laddr = pi_laddr;
		origladdr.s_addr = INADDR_ANY;
		<span class="enscript-comment">/* we don't want to keep the laddr or route */</span>
		udp_dodisconnect = 1;
		<span class="enscript-comment">/* remember we don't care about src addr.*/</span>
		inp-&gt;inp_flags |= INP_INADDR_ANY;
	} <span class="enscript-keyword">else</span> {
		origladdr = laddr = inp-&gt;inp_laddr;
	}

	origoutifp = inp-&gt;inp_last_outifp;
	faddr = inp-&gt;inp_faddr;
	lport = inp-&gt;inp_lport;
	fport = inp-&gt;inp_fport;

	<span class="enscript-keyword">if</span> (addr) {
		sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)addr;
		<span class="enscript-keyword">if</span> (faddr.s_addr != INADDR_ANY) {
			error = EISCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> (lport == 0) {
			<span class="enscript-comment">/*
			 * In case we don't have a local port set, go through
			 * the full connect.  We don't have a local port yet
			 * (i.e., we can't be looked up), so it's not an issue
			 * if the input runs at the same time we do this.
			 */</span>
			<span class="enscript-comment">/* if we have a source address specified, use that */</span>
			<span class="enscript-keyword">if</span> (pi_laddr.s_addr != INADDR_ANY)
				inp-&gt;inp_laddr = pi_laddr;
			<span class="enscript-comment">/*
			 * If a scope is specified, use it.  Scope from
			 * IP_PKTINFO takes precendence over the the scope
			 * set via INP_BOUND_IF.
			 */</span>
			error = in_pcbconnect(inp, addr, p, ipoa.ipoa_boundif,
			    &amp;outif);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

			laddr = inp-&gt;inp_laddr;
			lport = inp-&gt;inp_lport;
			faddr = inp-&gt;inp_faddr;
			fport = inp-&gt;inp_fport;
			udp_dodisconnect = 1;

			<span class="enscript-comment">/* synch up in case in_pcbladdr() overrides */</span>
			<span class="enscript-keyword">if</span> (outif != NULL &amp;&amp; ipoa.ipoa_boundif != IFSCOPE_NONE)
				ipoa.ipoa_boundif = outif-&gt;if_index;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Fast path case
			 *
			 * We have a full address and a local port; use those
			 * info to build the packet without changing the pcb
			 * and interfering with the input path. See 3851370.
			 *
			 * Scope from IP_PKTINFO takes precendence over the
			 * the scope set via INP_BOUND_IF.
			 */</span>
			<span class="enscript-keyword">if</span> (laddr.s_addr == INADDR_ANY) {
				<span class="enscript-keyword">if</span> ((error = in_pcbladdr(inp, addr, &amp;laddr,
				    ipoa.ipoa_boundif, &amp;outif)) != 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
				<span class="enscript-comment">/*
				 * from pcbconnect: remember we don't
				 * care about src addr.
				 */</span>
				inp-&gt;inp_flags |= INP_INADDR_ANY;

				<span class="enscript-comment">/* synch up in case in_pcbladdr() overrides */</span>
				<span class="enscript-keyword">if</span> (outif != NULL &amp;&amp;
				    ipoa.ipoa_boundif != IFSCOPE_NONE)
					ipoa.ipoa_boundif = outif-&gt;if_index;
			}

			faddr = sin-&gt;sin_addr;
			fport = sin-&gt;sin_port;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (faddr.s_addr == INADDR_ANY) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_mbuf_label_associate_inpcb(inp, m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
		inp-&gt;inp_flowhash = inp_calc_flowhash(inp);

	<span class="enscript-comment">/*
	 * Calculate data length and get a mbuf
	 * for UDP and IP headers.
	 */</span>
	M_PREPEND(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr), M_DONTWAIT, 1);
	<span class="enscript-keyword">if</span> (m == 0) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort</span>;
	}

	<span class="enscript-comment">/*
	 * Fill in mbuf with extended UDP header
	 * and addresses and length put into network format.
	 */</span>
	ui = mtod(m, <span class="enscript-type">struct</span> udpiphdr *);
	bzero(ui-&gt;ui_x1, <span class="enscript-keyword">sizeof</span> (ui-&gt;ui_x1));	<span class="enscript-comment">/* XXX still needed? */</span>
	ui-&gt;ui_pr = IPPROTO_UDP;
	ui-&gt;ui_src = laddr;
	ui-&gt;ui_dst = faddr;
	ui-&gt;ui_sport = lport;
	ui-&gt;ui_dport = fport;
	ui-&gt;ui_ulen = htons((u_short)len + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr));

	<span class="enscript-comment">/*
	 * Set up checksum and output datagram.
	 */</span>
	<span class="enscript-keyword">if</span> (udpcksum &amp;&amp; !(inp-&gt;inp_flags &amp; INP_UDP_NOCKSUM)) {
		ui-&gt;ui_sum = in_pseudo(ui-&gt;ui_src.s_addr, ui-&gt;ui_dst.s_addr,
		    htons((u_short)len + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) + IPPROTO_UDP));
		m-&gt;m_pkthdr.csum_flags = CSUM_UDP;
		m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> udphdr, uh_sum);
	} <span class="enscript-keyword">else</span> {
		ui-&gt;ui_sum = 0;
	}
	((<span class="enscript-type">struct</span> ip *)ui)-&gt;ip_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr) + len;
	((<span class="enscript-type">struct</span> ip *)ui)-&gt;ip_ttl = inp-&gt;inp_ip_ttl;	<span class="enscript-comment">/* XXX */</span>
	((<span class="enscript-type">struct</span> ip *)ui)-&gt;ip_tos = inp-&gt;inp_ip_tos;	<span class="enscript-comment">/* XXX */</span>
	udpstat.udps_opackets++;

	KERNEL_DEBUG(DBG_LAYER_OUT_END, ui-&gt;ui_dport, ui-&gt;ui_sport,
		     ui-&gt;ui_src.s_addr, ui-&gt;ui_dst.s_addr, ui-&gt;ui_ulen);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	{
		necp_kernel_policy_id policy_id;
		u_int32_t route_rule_id;
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v4(inp, lport, fport,
		    &amp;laddr, &amp;faddr, NULL, &amp;policy_id, &amp;route_rule_id)) {
			error = EHOSTUNREACH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort</span>;
		}

		necp_mark_packet_from_socket(m, inp, policy_id, route_rule_id);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp != NULL &amp;&amp; ipsec_setsocket(m, inp-&gt;inp_socket) != 0) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">abort</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	inpopts = inp-&gt;inp_options;
	soopts |= (inp-&gt;inp_socket-&gt;so_options &amp; (SO_DONTROUTE | SO_BROADCAST));
	mopts = inp-&gt;inp_moptions;
	<span class="enscript-keyword">if</span> (mopts != NULL) {
		IMO_LOCK(mopts);
		IMO_ADDREF_LOCKED(mopts);
		<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ui-&gt;ui_dst.s_addr)) &amp;&amp;
		    mopts-&gt;imo_multicast_ifp != NULL) {
			<span class="enscript-comment">/* no reference needed */</span>
			inp-&gt;inp_last_outifp = mopts-&gt;imo_multicast_ifp;
		}
		IMO_UNLOCK(mopts);
	}

	<span class="enscript-comment">/* Copy the cached route and take an extra reference */</span>
	inp_route_copyout(inp, &amp;ro);

	set_packet_service_class(m, so, msc, 0);
	m-&gt;m_pkthdr.pkt_flowsrc = FLOWSRC_INPCB;
	m-&gt;m_pkthdr.pkt_flowid = inp-&gt;inp_flowhash;
	m-&gt;m_pkthdr.pkt_proto = IPPROTO_UDP;
	m-&gt;m_pkthdr.pkt_flags |= (PKTF_FLOW_ID | PKTF_FLOW_LOCALSRC);
	<span class="enscript-keyword">if</span> (flowadv)
		m-&gt;m_pkthdr.pkt_flags |= PKTF_FLOW_ADV;

	<span class="enscript-keyword">if</span> (ipoa.ipoa_boundif != IFSCOPE_NONE)
		ipoa.ipoa_flags |= IPOAF_BOUND_IF;

	<span class="enscript-keyword">if</span> (laddr.s_addr != INADDR_ANY)
		ipoa.ipoa_flags |= IPOAF_BOUND_SRCADDR;

	inp-&gt;inp_sndinprog_cnt++;

	socket_unlock(so, 0);
	error = ip_output(m, inpopts, &amp;ro, soopts, mopts, &amp;ipoa);
	m = NULL;
	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (mopts != NULL)
		IMO_REMREF(mopts);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; nstat_collect) {
		boolean_t cell, wifi, wired;

		<span class="enscript-keyword">if</span> (ro.ro_rt != NULL) {
			cell = IFNET_IS_CELLULAR(ro.ro_rt-&gt;rt_ifp);
			wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ro.ro_rt-&gt;rt_ifp));
			wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ro.ro_rt-&gt;rt_ifp));
		} <span class="enscript-keyword">else</span> {
			cell = wifi = wired = FALSE;
		}
		INP_ADD_STAT(inp, cell, wifi, wired, txpackets, 1);
		INP_ADD_STAT(inp, cell, wifi, wired, txbytes, len);
	}

	<span class="enscript-keyword">if</span> (flowadv &amp;&amp; (adv-&gt;code == FADV_FLOW_CONTROLLED ||
	    adv-&gt;code == FADV_SUSPENDED)) {
		<span class="enscript-comment">/* return a hint to the application that 
		 * the packet has been dropped
		 */</span>
		error = ENOBUFS;
		inp_set_fc_state(inp, adv-&gt;code);
	}

	VERIFY(inp-&gt;inp_sndinprog_cnt &gt; 0);
	<span class="enscript-keyword">if</span> ( --inp-&gt;inp_sndinprog_cnt == 0)
		inp-&gt;inp_flags &amp;= ~(INP_FC_FEEDBACK);

	<span class="enscript-comment">/* Synchronize PCB cached route */</span>
	inp_route_copyin(inp, &amp;ro);

<span class="enscript-reference">abort</span>:
	<span class="enscript-keyword">if</span> (udp_dodisconnect) {
		<span class="enscript-comment">/* Always discard the cached route for unconnected socket */</span>
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
		in_pcbdisconnect(inp);
		inp-&gt;inp_laddr = origladdr;	<span class="enscript-comment">/* XXX rehash? */</span>
		<span class="enscript-comment">/* no reference needed */</span>
		inp-&gt;inp_last_outifp = origoutifp;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_route.ro_rt != NULL) {
		<span class="enscript-type">struct</span> rtentry *rt = inp-&gt;inp_route.ro_rt;
		<span class="enscript-type">struct</span> ifnet *outifp;

		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; (RTF_MULTICAST|RTF_BROADCAST))
			rt = NULL;	<span class="enscript-comment">/* unusable */</span>
		<span class="enscript-comment">/*
		 * Always discard if it is a multicast or broadcast route.
		 */</span>
		<span class="enscript-keyword">if</span> (rt == NULL)
			ROUTE_RELEASE(&amp;inp-&gt;inp_route);

		<span class="enscript-comment">/*
		 * If the destination route is unicast, update outifp with
		 * that of the route interface used by IP.
		 */</span>
		<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp;
		    (outifp = rt-&gt;rt_ifp) != inp-&gt;inp_last_outifp) {
			inp-&gt;inp_last_outifp = outifp; <span class="enscript-comment">/* no reference needed */</span>

			so-&gt;so_pktheadroom = P2ROUNDUP(
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) +
			    ifnet_hdrlen(outifp) +
			    ifnet_packetpreamblelen(outifp),
			    <span class="enscript-keyword">sizeof</span>(u_int32_t));
		}
	} <span class="enscript-keyword">else</span> {
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
	}

	<span class="enscript-comment">/*
	 * If output interface was cellular/expensive, and this socket is
	 * denied access to it, generate an event.
	 */</span>
	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; (ipoa.ipoa_retflags &amp; IPOARF_IFDENIED) &amp;&amp;
	    (INP_NO_CELLULAR(inp) || INP_NO_EXPENSIVE(inp)))
		soevent(so, (SO_FILT_HINT_LOCKED|SO_FILT_HINT_IFDENIED));

<span class="enscript-reference">release</span>:
	KERNEL_DEBUG(DBG_FNC_UDP_OUTPUT | DBG_FUNC_END, error, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);

	<span class="enscript-keyword">if</span> (outif != NULL)
		ifnet_release(outif);

	<span class="enscript-keyword">return</span> (error);
}

u_int32_t	udp_sendspace = 9216;		<span class="enscript-comment">/* really max datagram size */</span>
<span class="enscript-comment">/* 187 1K datagrams (approx 192 KB) */</span>
u_int32_t	udp_recvspace = 187 * (1024 +
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !INET6 */</span>
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		);

<span class="enscript-comment">/* Check that the values of udp send and recv space do not exceed sb_max */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_udp_sospace</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2,
    <span class="enscript-type">struct</span> sysctl_req *req)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	u_int32_t new_value = 0, *space_p = NULL;
	<span class="enscript-type">int</span> changed = 0, error = 0;
	u_quad_t sb_effective_max = (sb_max/(MSIZE+MCLBYTES)) * MCLBYTES;

	<span class="enscript-keyword">switch</span> (oidp-&gt;oid_number) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UDPCTL_RECVSPACE</span>:
		space_p = &amp;udp_recvspace;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UDPCTL_MAXDGRAM</span>:
		space_p = &amp;udp_sendspace;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	}
        error = sysctl_io_number(req, *space_p, <span class="enscript-keyword">sizeof</span> (u_int32_t),
	    &amp;new_value, &amp;changed);
        <span class="enscript-keyword">if</span> (changed) {
                <span class="enscript-keyword">if</span> (new_value &gt; 0 &amp;&amp; new_value &lt;= sb_effective_max)
                        *space_p = new_value;
                <span class="enscript-keyword">else</span>
                        error = ERANGE;
        }
        <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, UDPCTL_RECVSPACE, recvspace,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;udp_recvspace, 0,
    &amp;sysctl_udp_sospace, <span class="enscript-string">&quot;IU&quot;</span>, <span class="enscript-string">&quot;Maximum incoming UDP datagram size&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_udp, UDPCTL_MAXDGRAM, maxdgram,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;udp_sendspace, 0,
    &amp;sysctl_udp_sospace, <span class="enscript-string">&quot;IU&quot;</span>, <span class="enscript-string">&quot;Maximum outgoing UDP datagram size&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_abort</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p null inp\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	soisdisconnected(so);
	in_pcbdetach(inp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp != NULL) {
		panic (<span class="enscript-string">&quot;%s so=%p inp=%p\n&quot;</span>, __func__, so, inp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	error = in_pcballoc(so, &amp;udbinfo, p);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);
	error = soreserve(so, udp_sendspace, udp_recvspace);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);
	inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
	inp-&gt;inp_vflag |= INP_IPV4;
	inp-&gt;inp_ip_ttl = ip_defttl;
	<span class="enscript-keyword">if</span> (nstat_collect)
		nstat_udp_new_pcb(inp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (nam-&gt;sa_family != 0 &amp;&amp; nam-&gt;sa_family != AF_INET &amp;&amp;
	    nam-&gt;sa_family != AF_INET6)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	error = in_pcbbind(inp, nam, p);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != INADDR_ANY)
		<span class="enscript-keyword">return</span> (EISCONN);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	<span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp)) {
		uint32_t fd_ctl_unit =
		    necp_socket_get_flow_divert_control_unit(inp);
		<span class="enscript-keyword">if</span> (fd_ctl_unit &gt; 0) {
			error = flow_divert_pcb_init(so, fd_ctl_unit);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = flow_divert_connect_out(so, nam, p);
			}
		} <span class="enscript-keyword">else</span> {
			error = ENETDOWN;
		}
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	error = in_pcbconnect(inp, nam, p, IFSCOPE_NONE, NULL);
	<span class="enscript-keyword">if</span> (error == 0) {
		soisconnected(so);
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
			inp-&gt;inp_flowhash = inp_calc_flowhash(inp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp_connectx_common</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> af,
    <span class="enscript-type">struct</span> sockaddr_list **src_sl, <span class="enscript-type">struct</span> sockaddr_list **dst_sl,
    <span class="enscript-type">struct</span> proc *p, uint32_t ifscope, sae_associd_t aid, sae_connid_t *pcid,
    uint32_t flags, <span class="enscript-type">void</span> *arg, uint32_t arglen,
    <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">aid</span>, <span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">arglen</span>)
	<span class="enscript-type">struct</span> sockaddr_entry *src_se = NULL, *dst_se = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span> error;
	user_ssize_t datalen = 0;

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	VERIFY(dst_sl != NULL);

	<span class="enscript-comment">/* select source (if specified) and destination addresses */</span>
	error = in_selectaddrs(af, src_sl, &amp;src_se, dst_sl, &amp;dst_se);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	VERIFY(*dst_sl != NULL &amp;&amp; dst_se != NULL);
	VERIFY(src_se == NULL || *src_sl != NULL);
	VERIFY(dst_se-&gt;se_addr-&gt;sa_family == af);
	VERIFY(src_se == NULL || src_se-&gt;se_addr-&gt;sa_family == af);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	inp_update_necp_policy(inp, src_se ? src_se-&gt;se_addr : NULL,
	    dst_se ? dst_se-&gt;se_addr : NULL, ifscope);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	
	<span class="enscript-comment">/* bind socket to the specified interface, if requested */</span>
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp;
	    (error = inp_bindif(inp, ifscope, NULL)) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* if source address and/or port is specified, bind to it */</span>
	<span class="enscript-keyword">if</span> (src_se != NULL) {
		<span class="enscript-type">struct</span> sockaddr *sa = src_se-&gt;se_addr;
		error = sobindlock(so, sa, 0);	<span class="enscript-comment">/* already locked */</span>
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		error = udp_connect(so, dst_se-&gt;se_addr, p);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		error = udp6_connect(so, dst_se-&gt;se_addr, p);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * If there is data, copy it. DATA_IDEMPOTENT is ignored.
	 * CONNECT_RESUME_ON_READ_WRITE is ignored. 
	 */</span>
	<span class="enscript-keyword">if</span> (uio != NULL) {
		socket_unlock(so, 0);

		VERIFY(bytes_written != NULL);

		datalen = uio_resid(uio);
		error = so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sosend(so, NULL,
	            (uio_t)uio, NULL, NULL, 0);
		socket_lock(so, 0);

		<span class="enscript-comment">/* If error returned is EMSGSIZE, for example, disconnect */</span>
		<span class="enscript-keyword">if</span> (error == 0 || error == EWOULDBLOCK)
			*bytes_written = datalen - uio_resid(uio);
		<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>)so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_disconnectx(so,
			    SAE_ASSOCID_ANY, SAE_CONNID_ANY);
		<span class="enscript-comment">/*
		 * mask the EWOULDBLOCK error so that the caller
		 * knows that atleast the connect was successful.
		 */</span>
		<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
			error = 0;
	}

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pcid != NULL)
		*pcid = 1;	<span class="enscript-comment">/* there is only 1 connection for UDP */</span>

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_connectx</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
	<span class="enscript-keyword">return</span> (udp_connectx_common(so, AF_INET, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen, uio, bytes_written));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p null inp\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * If this is a socket that does not want to wakeup the device
	 * for it's traffic, the application might be waiting for 
	 * close to complete before going to sleep. Send a notification 
	 * for this kind of sockets
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_NOWAKEFROMSLEEP)
		socket_post_kev_msg_closed(so);

	in_pcbdetach(inp);
	inp-&gt;inp_state = INPCB_STATE_DEAD;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == INADDR_ANY)
		<span class="enscript-keyword">return</span> (ENOTCONN);

	in_pcbdisconnect(inp);

	<span class="enscript-comment">/* reset flow controlled state, just in case */</span>
	inp_reset_fc_state(inp);

	inp-&gt;inp_laddr.s_addr = INADDR_ANY;
	so-&gt;so_state &amp;= ~SS_ISCONNECTED;		<span class="enscript-comment">/* XXX */</span>
	inp-&gt;inp_last_outifp = NULL;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_disconnectx</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, sae_connid_t cid)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cid</span>)
	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (udp_disconnect(so));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !(FLOW_DIVERT) */</span>
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		<span class="enscript-keyword">if</span> (control != NULL)
			m_freem(control);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	<span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp)) {
		<span class="enscript-comment">/* Implicit connect */</span>
		<span class="enscript-keyword">return</span> (flow_divert_implicit_data_out(so, flags, m, addr, control, p));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-keyword">return</span> (udp_output(inp, m, addr, control, p));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp_shutdown</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	socantsendmore(so);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp_lock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *debug)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (debug == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = debug;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL) {
		lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
		    LCK_MTX_ASSERT_NOTOWNED);
		lck_mtx_lock(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>, __func__,
		    so, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount++;

	so-&gt;lock_lr[so-&gt;next_lock_lr] = lr_saved;
	so-&gt;next_lock_lr = (so-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *debug)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (debug == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = debug;

	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount--;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>, __func__,
		    so, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> {
		lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
		    LCK_MTX_ASSERT_OWNED);
		so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
		so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;
		lck_mtx_unlock(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx);
	}
	<span class="enscript-keyword">return</span> (0);
}

lck_mtx_t *
<span class="enscript-function-name">udp_getlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> locktype)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">locktype</span>)
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NULL so_pcb lrh= %s\n&quot;</span>, __func__,
		    so, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">return</span> (&amp;inp-&gt;inpcb_mtx);
}

<span class="enscript-comment">/*
 * UDP garbage collector callback (inpcb_timer_func_t).
 *
 * Returns &gt; 0 to keep timer active.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_gc</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi)
{
	<span class="enscript-type">struct</span> inpcb *inp, *inpnxt;
	<span class="enscript-type">struct</span> socket *so;

	<span class="enscript-keyword">if</span> (lck_rw_try_lock_exclusive(ipi-&gt;ipi_lock) == FALSE) {
		<span class="enscript-keyword">if</span> (udp_gc_done == TRUE) {
			udp_gc_done = FALSE;
			<span class="enscript-comment">/* couldn't get the lock, must lock next time */</span>
			atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
			<span class="enscript-keyword">return</span>;
		}
		lck_rw_lock_exclusive(ipi-&gt;ipi_lock);
	}

	udp_gc_done = TRUE;

	<span class="enscript-keyword">for</span> (inp = udb.lh_first; inp != NULL; inp = inpnxt) {
		inpnxt = inp-&gt;inp_list.le_next;

		<span class="enscript-comment">/*
		 * Skip unless it's STOPUSING; garbage collector will
		 * be triggered by in_pcb_checkstate() upon setting
		 * wantcnt to that value.  If the PCB is already dead,
		 * keep gc active to anticipate wantcnt changing.
		 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt != WNT_STOPUSING)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Skip if busy, no hurry for cleanup.  Keep gc active
		 * and try the lock again during next round.
		 */</span>
		<span class="enscript-keyword">if</span> (!lck_mtx_try_lock(&amp;inp-&gt;inpcb_mtx)) {
			atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Keep gc active unless usecount is 0.
		 */</span>
		so = inp-&gt;inp_socket;
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
					in6_pcbdetach(inp);
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					in_pcbdetach(inp);
			}
			in_pcbdispose(inp);
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
			atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
		}
	}
	lck_rw_done(ipi-&gt;ipi_lock);

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
udp_getstat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;udpstat, MIN(<span class="enscript-keyword">sizeof</span> (udpstat), req-&gt;oldlen)));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_in_cksum_stats</span>(u_int32_t len)
{
	udpstat.udps_rcv_swcsum++;
	udpstat.udps_rcv_swcsum_bytes += len;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_out_cksum_stats</span>(u_int32_t len)
{
	udpstat.udps_snd_swcsum++;
	udpstat.udps_snd_swcsum_bytes += len;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_in6_cksum_stats</span>(u_int32_t len)
{
	udpstat.udps_rcv6_swcsum++;
	udpstat.udps_rcv6_swcsum_bytes += len;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_out6_cksum_stats</span>(u_int32_t len)
{
	udpstat.udps_snd6_swcsum++;
	udpstat.udps_snd6_swcsum_bytes += len;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Checksum extended UDP header and data.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp_input_checksum</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> udphdr *uh, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> ulen)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-type">struct</span> ipovly *ipov = (<span class="enscript-type">struct</span> ipovly *)ip;

	<span class="enscript-keyword">if</span> (uh-&gt;uh_sum == 0) {
		udpstat.udps_nosum++;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> ((hwcksum_rx || (ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) &amp;&amp;
	    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID)) {
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_PSEUDO_HDR) {
			uh-&gt;uh_sum = m-&gt;m_pkthdr.csum_rx_val;
		} <span class="enscript-keyword">else</span> {
			uint16_t sum = m-&gt;m_pkthdr.csum_rx_val;
			uint16_t start = m-&gt;m_pkthdr.csum_rx_start;

			<span class="enscript-comment">/*
			 * Perform 1's complement adjustment of octets
			 * that got included/excluded in the hardware-
			 * calculated checksum value.  Ignore cases
			 * where the value includes or excludes the
			 * IP header span, as the sum for those octets
			 * would already be 0xffff and thus no-op.
			 */</span>
			<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_PARTIAL) &amp;&amp;
			    start != 0 &amp;&amp; (off - start) != off) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
				<span class="enscript-keyword">if</span> (start &lt; off) {
					HTONS(ip-&gt;ip_len);
					HTONS(ip-&gt;ip_off);
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BYTE_ORDER != BIG_ENDIAN */</span>
				<span class="enscript-comment">/* callee folds in sum */</span>
				sum = m_adj_sum16(m, start, off, sum);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
				<span class="enscript-keyword">if</span> (start &lt; off) {
					NTOHS(ip-&gt;ip_off);
					NTOHS(ip-&gt;ip_len);
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BYTE_ORDER != BIG_ENDIAN */</span>
			}

			<span class="enscript-comment">/* callee folds in sum */</span>
			uh-&gt;uh_sum = in_pseudo(ip-&gt;ip_src.s_addr,
			    ip-&gt;ip_dst.s_addr, sum + htonl(ulen + IPPROTO_UDP));
		}
		uh-&gt;uh_sum ^= 0xffff;
	} <span class="enscript-keyword">else</span> {
		uint16_t ip_sum;
		<span class="enscript-type">char</span> b[9];

		bcopy(ipov-&gt;ih_x1, b, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
		bzero(ipov-&gt;ih_x1, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
		ip_sum = ipov-&gt;ih_len;
		ipov-&gt;ih_len = uh-&gt;uh_ulen;
		uh-&gt;uh_sum = in_cksum(m, ulen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip));
		bcopy(b, ipov-&gt;ih_x1, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
		ipov-&gt;ih_len = ip_sum;

		udp_in_cksum_stats(ulen);
	}

	<span class="enscript-keyword">if</span> (uh-&gt;uh_sum != 0) {
		udpstat.udps_badsum++;
		IF_UDP_STATINC(ifp, badchksum);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp_fill_keepalive_offload_frames</span>(ifnet_t ifp,
     <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
     u_int32_t frames_array_count, size_t frame_data_offset,
     u_int32_t *used_frames_count);

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp_fill_keepalive_offload_frames</span>(ifnet_t ifp,
    <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
    u_int32_t frames_array_count, size_t frame_data_offset,
    u_int32_t *used_frames_count)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	inp_gen_t gencnt;
	u_int32_t frame_index = *used_frames_count;

	<span class="enscript-keyword">if</span> (ifp == NULL || frames_array == NULL ||
	    frames_array_count == 0 ||
	    frame_index &gt;= frames_array_count ||
	    frame_data_offset &gt;= IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE)
		<span class="enscript-keyword">return</span>;

	lck_rw_lock_shared(udbinfo.ipi_lock);
	gencnt = udbinfo.ipi_gencnt;
	LIST_FOREACH(inp, udbinfo.ipi_listhead, inp_list) {
		<span class="enscript-type">struct</span> socket *so;
		u_int8_t *data;
		<span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frame;
		<span class="enscript-type">struct</span> mbuf *m = NULL;

		<span class="enscript-keyword">if</span> (frame_index &gt;= frames_array_count)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &gt; gencnt ||
		    inp-&gt;inp_state == INPCB_STATE_DEAD)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((so = inp-&gt;inp_socket) == NULL ||
		    (so-&gt;so_state &amp; SS_DEFUNCT))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/*
		 * check for keepalive offload flag without socket
		 * lock to avoid a deadlock
		 */</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags2 &amp; INP2_KEEPALIVE_OFFLOAD)) {
			<span class="enscript-keyword">continue</span>;
		}

		udp_lock(so, 1, 0);
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; (INP_IPV4 | INP_IPV6))) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV4) &amp;&amp;
		    (inp-&gt;inp_laddr.s_addr == INADDR_ANY ||
		    inp-&gt;inp_faddr.s_addr == INADDR_ANY)) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) &amp;&amp;
		    (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr) ||
		    IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr))) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0 || inp-&gt;inp_fport == 0) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (inp-&gt;inp_last_outifp == NULL ||
		    inp-&gt;inp_last_outifp-&gt;if_index != ifp-&gt;if_index) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV4)) {
			<span class="enscript-keyword">if</span> ((frame_data_offset + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) + 
			    inp-&gt;inp_keepalive_datalen) &gt;
			    IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE) {
				udp_unlock(so, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) +
			    inp-&gt;inp_keepalive_datalen) &gt; _MHLEN) {
				udp_unlock(so, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((frame_data_offset + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    inp-&gt;inp_keepalive_datalen) &gt;
			    IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE) {
				udp_unlock(so, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    inp-&gt;inp_keepalive_datalen) &gt; _MHLEN) {
				udp_unlock(so, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
		}
		MGETHDR(m, M_WAIT, MT_HEADER);
		<span class="enscript-keyword">if</span> (m == NULL) {
			udp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * This inp has all the information that is needed to
		 * generate an offload frame.
		 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
			<span class="enscript-type">struct</span> ip *ip;
			<span class="enscript-type">struct</span> udphdr *udp;

			frame = &amp;frames_array[frame_index];
			frame-&gt;length = frame_data_offset +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) +
			    inp-&gt;inp_keepalive_datalen;
			frame-&gt;ether_type =
			    IFNET_KEEPALIVE_OFFLOAD_FRAME_ETHERTYPE_IPV4;
			frame-&gt;interval = inp-&gt;inp_keepalive_interval;
			<span class="enscript-keyword">switch</span> (inp-&gt;inp_keepalive_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">UDP_KEEPALIVE_OFFLOAD_TYPE_AIRPLAY</span>:
				frame-&gt;type =
				    IFNET_KEEPALIVE_OFFLOAD_FRAME_AIRPLAY;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
			data = mtod(m, u_int8_t *);
			bzero(data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr));
			ip = (__typeof__(ip))(<span class="enscript-type">void</span> *)data;
			udp = (__typeof__(udp))(<span class="enscript-type">void</span> *) (data +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
			m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr);
			data = data + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr);
			<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_datalen &gt; 0 &amp;&amp;
			    inp-&gt;inp_keepalive_data != NULL) {
				bcopy(inp-&gt;inp_keepalive_data, data,
				    inp-&gt;inp_keepalive_datalen);
				m-&gt;m_len += inp-&gt;inp_keepalive_datalen;
			}
			m-&gt;m_pkthdr.len = m-&gt;m_len;

			ip-&gt;ip_v = IPVERSION;
			ip-&gt;ip_hl = (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt;&gt; 2);
			ip-&gt;ip_p = IPPROTO_UDP;
			ip-&gt;ip_len = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) +
			    (u_short)inp-&gt;inp_keepalive_datalen);
			ip-&gt;ip_ttl = inp-&gt;inp_ip_ttl;
			ip-&gt;ip_tos = inp-&gt;inp_ip_tos;
			ip-&gt;ip_src = inp-&gt;inp_laddr;
			ip-&gt;ip_dst = inp-&gt;inp_faddr;
			ip-&gt;ip_sum = in_cksum_hdr_opt(ip);

			udp-&gt;uh_sport = inp-&gt;inp_lport;
			udp-&gt;uh_dport = inp-&gt;inp_fport;
			udp-&gt;uh_ulen = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    (u_short)inp-&gt;inp_keepalive_datalen);

			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; INP_UDP_NOCKSUM)) {
				udp-&gt;uh_sum = in_pseudo(ip-&gt;ip_src.s_addr,
				    ip-&gt;ip_dst.s_addr,
				    htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
				    (u_short)inp-&gt;inp_keepalive_datalen +
				    IPPROTO_UDP));
				m-&gt;m_pkthdr.csum_flags = CSUM_UDP;
				m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> udphdr,
				    uh_sum);
			}
			m-&gt;m_pkthdr.pkt_proto = IPPROTO_UDP;
			in_delayed_cksum(m);
			bcopy(m-&gt;m_data, frame-&gt;data + frame_data_offset,
			    m-&gt;m_len);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> ip6_hdr *ip6;
			<span class="enscript-type">struct</span> udphdr *udp6;

			VERIFY(inp-&gt;inp_vflag &amp; INP_IPV6);
			frame = &amp;frames_array[frame_index];
			frame-&gt;length = frame_data_offset +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    inp-&gt;inp_keepalive_datalen;
			frame-&gt;ether_type =
			    IFNET_KEEPALIVE_OFFLOAD_FRAME_ETHERTYPE_IPV6;
			frame-&gt;interval = inp-&gt;inp_keepalive_interval;
			<span class="enscript-keyword">switch</span> (inp-&gt;inp_keepalive_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">UDP_KEEPALIVE_OFFLOAD_TYPE_AIRPLAY</span>:
				frame-&gt;type =
				    IFNET_KEEPALIVE_OFFLOAD_FRAME_AIRPLAY;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
			data = mtod(m, u_int8_t *);
			bzero(data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
			ip6 = (__typeof__(ip6))(<span class="enscript-type">void</span> *)data;
			udp6 = (__typeof__(udp6))(<span class="enscript-type">void</span> *)(data +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
			m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
			data = data + (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
			<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_datalen &gt; 0 &amp;&amp;
			    inp-&gt;inp_keepalive_data != NULL) {
				bcopy(inp-&gt;inp_keepalive_data, data,
				    inp-&gt;inp_keepalive_datalen);
				m-&gt;m_len += inp-&gt;inp_keepalive_datalen;
			}
			m-&gt;m_pkthdr.len = m-&gt;m_len;
			ip6-&gt;ip6_flow = inp-&gt;inp_flow &amp; IPV6_FLOWINFO_MASK;
			ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
			ip6-&gt;ip6_vfc |= IPV6_VERSION;
			ip6-&gt;ip6_nxt = IPPROTO_UDP;
			ip6-&gt;ip6_hlim = ip6_defhlim;
			ip6-&gt;ip6_plen = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    (u_short)inp-&gt;inp_keepalive_datalen);
			ip6-&gt;ip6_src = inp-&gt;in6p_laddr;
			<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src))
				ip6-&gt;ip6_src.s6_addr16[1] = 0;

			ip6-&gt;ip6_dst = inp-&gt;in6p_faddr;
			<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))
				ip6-&gt;ip6_dst.s6_addr16[1] = 0;

			udp6-&gt;uh_sport = inp-&gt;in6p_lport;
			udp6-&gt;uh_dport = inp-&gt;in6p_fport;
			udp6-&gt;uh_ulen = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
			    (u_short)inp-&gt;inp_keepalive_datalen);
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; INP_UDP_NOCKSUM)) {
				udp6-&gt;uh_sum = in6_pseudo(&amp;ip6-&gt;ip6_src,
				    &amp;ip6-&gt;ip6_dst,
				    htonl(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) +
				    (u_short)inp-&gt;inp_keepalive_datalen +
				    IPPROTO_UDP));
				m-&gt;m_pkthdr.csum_flags = CSUM_UDPIPV6;
				m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> udphdr,
				    uh_sum);
			}
			m-&gt;m_pkthdr.pkt_proto = IPPROTO_UDP;
			in6_delayed_cksum(m);
			bcopy(m-&gt;m_data, frame-&gt;data + frame_data_offset,
			    m-&gt;m_len);
		}
		<span class="enscript-keyword">if</span> (m != NULL) {
			m_freem(m);
			m = NULL;
		}
		frame_index++;
		udp_unlock(so, 1, 0);
	}
	lck_rw_done(udbinfo.ipi_lock);
	*used_frames_count = frame_index;
}
</pre>
<hr />
</body></html>