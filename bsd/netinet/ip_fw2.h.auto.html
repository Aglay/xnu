<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip_fw2.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip_fw2.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2002 Luigi Rizzo, Universita` di Pisa
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/netinet/ip_fw2.h,v 1.1.2.4 2003/07/17 06:03:39 luigi Exp $
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_IPFW2_H</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IPFW2_H</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_OBSOLETE</span>

<span class="enscript-comment">/*
 * Define IP Firewall event subclass, and associated events.
 */</span>

<span class="enscript-comment">/*!
	@defined KEV_IPFW_SUBCLASS
	@discussion The kernel event subclass for IP Firewall.
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_IPFW_SUBCLASS</span>	1

<span class="enscript-comment">/*!
	@defined KEV_IPFW_ADD
	@discussion The event code indicating a rule has been added.
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_IPFW_ADD</span>		1

<span class="enscript-comment">/*!
	@defined KEV_IPFW_DEL
	@discussion The event code indicating a rule has been removed.
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_IPFW_DEL</span>		2

<span class="enscript-comment">/*!
	@defined KEV_IPFW_FLUSH
	@discussion The event code indicating the rule set has been flushed.
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_IPFW_FLUSH</span>		3

<span class="enscript-comment">/*!
	@defined KEV_IPFW_ENABLE
	@discussion The event code indicating the enable flag has been changed 
*/</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_IPFW_ENABLE</span>		4



<span class="enscript-comment">/*
 * The kernel representation of ipfw rules is made of a list of
 * 'instructions' (for all practical purposes equivalent to BPF
 * instructions), which specify which fields of the packet
 * (or its metadata) should be analysed.
 *
 * Each instruction is stored in a structure which begins with
 * &quot;ipfw_insn&quot;, and can contain extra fields depending on the
 * instruction type (listed below).
 * Note that the code is written so that individual instructions
 * have a size which is a multiple of 32 bits. This means that, if
 * such structures contain pointers or other 64-bit entities,
 * (there is just one instance now) they may end up unaligned on
 * 64-bit architectures, so the must be handled with care.
 *
 * &quot;enum ipfw_opcodes&quot; are the opcodes supported. We can have up
 * to 256 different opcodes.
 */</span>

<span class="enscript-type">enum</span> ipfw_opcodes {		<span class="enscript-comment">/* arguments (4 byte each)	*/</span>
	O_NOP,

	O_IP_SRC,		<span class="enscript-comment">/* u32 = IP			*/</span>
	O_IP_SRC_MASK,		<span class="enscript-comment">/* ip = IP/mask			*/</span>
	O_IP_SRC_ME,		<span class="enscript-comment">/* none				*/</span>
	O_IP_SRC_SET,		<span class="enscript-comment">/* u32=base, arg1=len, bitmap	*/</span>

	O_IP_DST,		<span class="enscript-comment">/* u32 = IP			*/</span>
	O_IP_DST_MASK,		<span class="enscript-comment">/* ip = IP/mask			*/</span>
	O_IP_DST_ME,		<span class="enscript-comment">/* none				*/</span>
	O_IP_DST_SET,		<span class="enscript-comment">/* u32=base, arg1=len, bitmap	*/</span>

	O_IP_SRCPORT,		<span class="enscript-comment">/* (n)port list:mask 4 byte ea	*/</span>
	O_IP_DSTPORT,		<span class="enscript-comment">/* (n)port list:mask 4 byte ea	*/</span>
	O_PROTO,		<span class="enscript-comment">/* arg1=protocol		*/</span>

	O_MACADDR2,		<span class="enscript-comment">/* 2 mac addr:mask		*/</span>
	O_MAC_TYPE,		<span class="enscript-comment">/* same as srcport		*/</span>

	O_LAYER2,		<span class="enscript-comment">/* none				*/</span>
	O_IN,			<span class="enscript-comment">/* none				*/</span>
	O_FRAG,			<span class="enscript-comment">/* none				*/</span>

	O_RECV,			<span class="enscript-comment">/* none				*/</span>
	O_XMIT,			<span class="enscript-comment">/* none				*/</span>
	O_VIA,			<span class="enscript-comment">/* none				*/</span>

	O_IPOPT,		<span class="enscript-comment">/* arg1 = 2*u8 bitmap		*/</span>
	O_IPLEN,		<span class="enscript-comment">/* arg1 = len			*/</span>
	O_IPID,			<span class="enscript-comment">/* arg1 = id			*/</span>

	O_IPTOS,		<span class="enscript-comment">/* arg1 = id			*/</span>
	O_IPPRECEDENCE,		<span class="enscript-comment">/* arg1 = precedence &lt;&lt; 5	*/</span>
	O_IPTTL,		<span class="enscript-comment">/* arg1 = TTL			*/</span>

	O_IPVER,		<span class="enscript-comment">/* arg1 = version		*/</span>
	O_UID,			<span class="enscript-comment">/* u32 = id			*/</span>
	O_GID,			<span class="enscript-comment">/* u32 = id			*/</span>
	O_ESTAB,		<span class="enscript-comment">/* none (tcp established)	*/</span>
	O_TCPFLAGS,		<span class="enscript-comment">/* arg1 = 2*u8 bitmap		*/</span>
	O_TCPWIN,		<span class="enscript-comment">/* arg1 = desired win		*/</span>
	O_TCPSEQ,		<span class="enscript-comment">/* u32 = desired seq.		*/</span>
	O_TCPACK,		<span class="enscript-comment">/* u32 = desired seq.		*/</span>
	O_ICMPTYPE,		<span class="enscript-comment">/* u32 = icmp bitmap		*/</span>
	O_TCPOPTS,		<span class="enscript-comment">/* arg1 = 2*u8 bitmap		*/</span>

	O_VERREVPATH,		<span class="enscript-comment">/* none				*/</span>

	O_PROBE_STATE,		<span class="enscript-comment">/* none				*/</span>
	O_KEEP_STATE,		<span class="enscript-comment">/* none				*/</span>
	O_LIMIT,		<span class="enscript-comment">/* ipfw_insn_limit		*/</span>
	O_LIMIT_PARENT,		<span class="enscript-comment">/* dyn_type, not an opcode.	*/</span>

	<span class="enscript-comment">/*
	 * These are really 'actions'.
	 */</span>

	O_LOG,			<span class="enscript-comment">/* ipfw_insn_log		*/</span>
	O_PROB,			<span class="enscript-comment">/* u32 = match probability	*/</span>

	O_CHECK_STATE,		<span class="enscript-comment">/* none				*/</span>
	O_ACCEPT,		<span class="enscript-comment">/* none				*/</span>
	O_DENY,			<span class="enscript-comment">/* none 			*/</span>
	O_REJECT,		<span class="enscript-comment">/* arg1=icmp arg (same as deny)	*/</span>
	O_COUNT,		<span class="enscript-comment">/* none				*/</span>
	O_SKIPTO,		<span class="enscript-comment">/* arg1=next rule number	*/</span>
	O_PIPE,			<span class="enscript-comment">/* arg1=pipe number		*/</span>
	O_QUEUE,		<span class="enscript-comment">/* arg1=queue number		*/</span>
	O_DIVERT,		<span class="enscript-comment">/* arg1=port number		*/</span>
	O_TEE,			<span class="enscript-comment">/* arg1=port number		*/</span>
	O_FORWARD_IP,		<span class="enscript-comment">/* fwd sockaddr			*/</span>
	O_FORWARD_MAC,		<span class="enscript-comment">/* fwd mac			*/</span>

	<span class="enscript-comment">/*
	 * More opcodes.
	 */</span>
	O_IPSEC,		<span class="enscript-comment">/* has ipsec history		*/</span>

	O_LAST_OPCODE		<span class="enscript-comment">/* not an opcode!		*/</span>
};

<span class="enscript-comment">/*
 * Template for instructions.
 *
 * ipfw_insn is used for all instructions which require no operands,
 * a single 16-bit value (arg1), or a couple of 8-bit values.
 *
 * For other instructions which require different/larger arguments
 * we have derived structures, ipfw_insn_*.
 *
 * The size of the instruction (in 32-bit words) is in the low
 * 6 bits of &quot;len&quot;. The 2 remaining bits are used to implement
 * NOT and OR on individual instructions. Given a type, you can
 * compute the length to be put in &quot;len&quot; using F_INSN_SIZE(t)
 *
 * F_NOT	negates the match result of the instruction.
 *
 * F_OR		is used to build or blocks. By default, instructions
 *		are evaluated as part of a logical AND. An &quot;or&quot; block
 *		{ X or Y or Z } contains F_OR set in all but the last
 *		instruction of the block. A match will cause the code
 *		to skip past the last instruction of the block.
 *
 * NOTA BENE: in a couple of places we assume that
 *	sizeof(ipfw_insn) == sizeof(u_int32_t)
 * this needs to be fixed.
 *
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn {	<span class="enscript-comment">/* template for instructions */</span>
	<span class="enscript-type">enum</span> ipfw_opcodes	opcode:8;
	u_int8_t	len;	<span class="enscript-comment">/* numer of 32-byte words */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">F_NOT</span>		0x80
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">F_OR</span>		0x40
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">F_LEN_MASK</span>	0x3f
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">F_LEN</span>(cmd)	((cmd)-&gt;len &amp; F_LEN_MASK)

	u_int16_t	arg1;
} ipfw_insn;

<span class="enscript-comment">/*
 * The F_INSN_SIZE(type) computes the size, in 4-byte words, of
 * a given type.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">F_INSN_SIZE</span>(t)	((sizeof (t))/sizeof(u_int32_t))

<span class="enscript-comment">/*
 * This is used to store an array of 16-bit entries (ports etc.)
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_u16 {
	ipfw_insn o;
	u_int16_t ports[2];	<span class="enscript-comment">/* there may be more */</span>
} ipfw_insn_u16;

<span class="enscript-comment">/*
 * This is used to store an array of 32-bit entries
 * (uid, single IPv4 addresses etc.)
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_u32 {
	ipfw_insn o;
	u_int32_t d[1];	<span class="enscript-comment">/* one or more */</span>
} ipfw_insn_u32;

<span class="enscript-comment">/*
 * This is used to store IP addr-mask pairs.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_ip {
	ipfw_insn o;
	<span class="enscript-type">struct</span> in_addr	addr;
	<span class="enscript-type">struct</span> in_addr	mask;
} ipfw_insn_ip;

<span class="enscript-comment">/*
 * This is used to forward to a given address (ip).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>  _ipfw_insn_sa {
	ipfw_insn o;
	<span class="enscript-type">struct</span> sockaddr_in sa;
} ipfw_insn_sa;

<span class="enscript-comment">/*
 * This is used for MAC addr-mask pairs.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_mac {
	ipfw_insn o;
	u_char addr[12];	<span class="enscript-comment">/* dst[6] + src[6] */</span>
	u_char mask[12];	<span class="enscript-comment">/* dst[6] + src[6] */</span>
} ipfw_insn_mac;

<span class="enscript-comment">/*
 * This is used for interface match rules (recv xx, xmit xx).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_if {
	ipfw_insn o;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> in_addr ip;
		int32_t unit;
	} p;
	<span class="enscript-type">char</span> name[IFNAMSIZ];
} ipfw_insn_if;

<span class="enscript-comment">/*
 * This is used for pipe and queue actions, which need to store
 * a single pointer (which can have different size on different
 * architectures.
 * Note that, because of previous instructions, pipe_ptr might
 * be unaligned in the overall structure, so it needs to be
 * manipulated with care.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_pipe {
	ipfw_insn	o;
	<span class="enscript-type">void</span>		*pipe_ptr;	<span class="enscript-comment">/* XXX */</span>
} ipfw_insn_pipe;

<span class="enscript-comment">/*
 * This is used for limit rules.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>	_ipfw_insn_limit {
	ipfw_insn o;
	u_int8_t _pad;
	u_int8_t limit_mask;	<span class="enscript-comment">/* combination of DYN_* below	*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DYN_SRC_ADDR</span>	0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DYN_SRC_PORT</span>	0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DYN_DST_ADDR</span>	0x4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DYN_DST_PORT</span>	0x8

	u_int16_t conn_limit;
} ipfw_insn_limit;

<span class="enscript-comment">/*
 * This is used for log instructions.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>  _ipfw_insn_log {
        ipfw_insn o;
	u_int32_t max_log;	<span class="enscript-comment">/* how many do we log -- 0 = all */</span>
	u_int32_t log_left;	<span class="enscript-comment">/* how many left to log 	*/</span>
} ipfw_insn_log;

<span class="enscript-comment">/* Version of this API */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FW_VERSION_NONE</span> 0 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FW_VERSION_0</span> 10	<span class="enscript-comment">/* old ipfw */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FW_VERSION_1</span> 20	<span class="enscript-comment">/* ipfw in Jaguar/Panther */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FW_VERSION_2</span> 30	<span class="enscript-comment">/* ipfw2 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FW_CURRENT_API_VERSION</span> IP_FW_VERSION_2 

<span class="enscript-comment">/*
 * Here we have the structure representing an ipfw rule.
 *
 * It starts with a general area (with link fields and counters)
 * followed by an array of one or more instructions, which the code
 * accesses as an array of 32-bit values.
 *
 * Given a rule pointer  r:
 *
 *  r-&gt;cmd		is the start of the first instruction.
 *  ACTION_PTR(r)	is the start of the first action (things to do
 *			once a rule matched).
 *
 * When assembling instruction, remember the following:
 *
 *  + if a rule has a &quot;keep-state&quot; (or &quot;limit&quot;) option, then the
 *	first instruction (at r-&gt;cmd) MUST BE an O_PROBE_STATE
 *  + if a rule has a &quot;log&quot; option, then the first action
 *	(at ACTION_PTR(r)) MUST be O_LOG
 *
 * NOTE: we use a simple linked list of rules because we never need
 * 	to delete a rule without scanning the list. We do not use
 *	queue(3) macros for portability and readability.
 */</span>

<span class="enscript-type">struct</span> ip_fw {
	u_int32_t version;		<span class="enscript-comment">/* Version of this structure. MUST be set */</span>
							<span class="enscript-comment">/* by clients. Should always be */</span>
							<span class="enscript-comment">/* set to IP_FW_CURRENT_API_VERSION. */</span>
	<span class="enscript-type">void</span> *context;			<span class="enscript-comment">/* Context that is usable by user processes to */</span>
							<span class="enscript-comment">/* identify this rule. */</span>
	<span class="enscript-type">struct</span> ip_fw	*next;		<span class="enscript-comment">/* linked list of rules		*/</span>
	<span class="enscript-type">struct</span> ip_fw	*next_rule;	<span class="enscript-comment">/* ptr to next [skipto] rule	*/</span>
	<span class="enscript-comment">/* 'next_rule' is used to pass up 'set_disable' status		*/</span>

	u_int16_t	act_ofs;	<span class="enscript-comment">/* offset of action in 32-bit units */</span>
	u_int16_t	cmd_len;	<span class="enscript-comment">/* # of 32-bit words in cmd	*/</span>
	u_int16_t	rulenum;	<span class="enscript-comment">/* rule number			*/</span>
	u_int8_t	set;		<span class="enscript-comment">/* rule set (0..31)		*/</span>
	u_int32_t	set_masks[2];	<span class="enscript-comment">/* masks for manipulating sets atomically */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RESVD_SET</span>	31	<span class="enscript-comment">/* set for default and persistent rules */</span>
	u_int8_t	_pad;		<span class="enscript-comment">/* padding			*/</span>

	<span class="enscript-comment">/* These fields are present in all rules.			*/</span>
	u_int64_t	pcnt;		<span class="enscript-comment">/* Packet counter		*/</span>
	u_int64_t	bcnt;		<span class="enscript-comment">/* Byte counter			*/</span>
	u_int32_t	timestamp;	<span class="enscript-comment">/* tv_sec of last match		*/</span>
	
	u_int32_t	reserved_1;	<span class="enscript-comment">/* reserved - set to 0 */</span>
	u_int32_t	reserved_2;	<span class="enscript-comment">/* reserved - set to 0 */</span>

	ipfw_insn	cmd[1];		<span class="enscript-comment">/* storage for commands		*/</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ACTION_PTR</span>(rule)				\
	(ipfw_insn *)( (u_int32_t *)((rule)-&gt;cmd) + ((rule)-&gt;act_ofs) )

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RULESIZE</span>(rule)  (sizeof(struct ip_fw) + \
	((<span class="enscript-type">struct</span> ip_fw *)(rule))-&gt;cmd_len * 4 - 4)

<span class="enscript-comment">/*
 * This structure is used as a flow mask and a flow id for various
 * parts of the code.
 */</span>
<span class="enscript-type">struct</span> ipfw_flow_id {
	u_int32_t	dst_ip;
	u_int32_t	src_ip;
	u_int16_t	dst_port;
	u_int16_t	src_port;
	u_int8_t	proto;
	u_int8_t	flags;	<span class="enscript-comment">/* protocol-specific flags */</span>
};

<span class="enscript-comment">/*
 * Dynamic ipfw rule.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _ipfw_dyn_rule ipfw_dyn_rule;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">XNU_KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_flowid.h&gt;</span>

<span class="enscript-comment">/*
 * Note: 
 * The internal version of &quot;struct _ipfw_dyn_rule&quot; differs from 
 * its external version because the field &quot;id&quot; is of type
 * &quot;struct ip_flow_id&quot; in the internal version. The type of the
 * field &quot;id&quot; for the external version is &quot;ipfw_dyn_rule for
 * backwards compatibility reasons.
 */</span>

<span class="enscript-type">struct</span> _ipfw_dyn_rule {
	ipfw_dyn_rule	*next;		<span class="enscript-comment">/* linked list of rules.	*/</span>
	<span class="enscript-type">struct</span> ip_fw *rule;		<span class="enscript-comment">/* pointer to rule		*/</span>
	<span class="enscript-comment">/* 'rule' is used to pass up the rule number (from the parent)	*/</span>

	ipfw_dyn_rule *parent;		<span class="enscript-comment">/* pointer to parent rule	*/</span>
	u_int64_t	pcnt;		<span class="enscript-comment">/* packet match counter		*/</span>
	u_int64_t	bcnt;		<span class="enscript-comment">/* byte match counter		*/</span>
	<span class="enscript-type">struct</span> ip_flow_id id;		<span class="enscript-comment">/* (masked) flow id		*/</span>
	u_int32_t	expire;		<span class="enscript-comment">/* expire time			*/</span>
	u_int32_t	bucket;		<span class="enscript-comment">/* which bucket in hash table	*/</span>
	u_int32_t	state;		<span class="enscript-comment">/* state of this rule (typically a
					 * combination of TCP flags)
					 */</span>
	u_int32_t	ack_fwd;	<span class="enscript-comment">/* most recent ACKs in forward	*/</span>
	u_int32_t	ack_rev;	<span class="enscript-comment">/* and reverse directions (used	*/</span>
					<span class="enscript-comment">/* to generate keepalives)	*/</span>
	u_int16_t	dyn_type;	<span class="enscript-comment">/* rule type			*/</span>
	u_int16_t	count;		<span class="enscript-comment">/* refcount			*/</span>
};
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>
<span class="enscript-type">struct</span> _ipfw_dyn_rule {
	ipfw_dyn_rule	*next;		<span class="enscript-comment">/* linked list of rules.	*/</span>
	<span class="enscript-type">struct</span> ip_fw *rule;		<span class="enscript-comment">/* pointer to rule		*/</span>
	<span class="enscript-comment">/* 'rule' is used to pass up the rule number (from the parent)	*/</span>

	ipfw_dyn_rule *parent;		<span class="enscript-comment">/* pointer to parent rule	*/</span>
	u_int64_t	pcnt;		<span class="enscript-comment">/* packet match counter		*/</span>
	u_int64_t	bcnt;		<span class="enscript-comment">/* byte match counter		*/</span>
	<span class="enscript-type">struct</span> ipfw_flow_id id;		<span class="enscript-comment">/* (masked) flow id		*/</span>
	u_int32_t	expire;		<span class="enscript-comment">/* expire time			*/</span>
	u_int32_t	bucket;		<span class="enscript-comment">/* which bucket in hash table	*/</span>
	u_int32_t	state;		<span class="enscript-comment">/* state of this rule (typically a
					 * combination of TCP flags)
					 */</span>
	u_int32_t	ack_fwd;	<span class="enscript-comment">/* most recent ACKs in forward	*/</span>
	u_int32_t	ack_rev;	<span class="enscript-comment">/* and reverse directions (used	*/</span>
					<span class="enscript-comment">/* to generate keepalives)	*/</span>
	u_int16_t	dyn_type;	<span class="enscript-comment">/* rule type			*/</span>
	u_int16_t	count;		<span class="enscript-comment">/* refcount			*/</span>
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* XNU_KERNEL_PRIVATE */</span>

<span class="enscript-comment">/*
 * Definitions for IP option names.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_IPOPT_LSRR</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_IPOPT_SSRR</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_IPOPT_RR</span>		0x04
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_IPOPT_TS</span>		0x08

<span class="enscript-comment">/*
 * Definitions for TCP option names.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_TCPOPT_MSS</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_TCPOPT_WINDOW</span>	0x02
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_TCPOPT_SACK</span>	0x04
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_TCPOPT_TS</span>		0x08
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_TCPOPT_CC</span>		0x10

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ICMP_REJECT_RST</span>		0x100	<span class="enscript-comment">/* fake ICMP code (send a TCP RST) */</span>

<span class="enscript-comment">/*
 * Main firewall chains definitions and global var's definitions.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)
<span class="enscript-type">struct</span> ip_fw_32{
        u_int32_t version;              <span class="enscript-comment">/* Version of this structure. MUST be set */</span>
 										<span class="enscript-comment">/* by clients. Should always be */</span>
										<span class="enscript-comment">/* set to IP_FW_CURRENT_API_VERSION. */</span>
		user32_addr_t 	context;		<span class="enscript-comment">/* Context that is usable by user processes to */</span>
										<span class="enscript-comment">/* identify this rule. */</span>
        user32_addr_t	next;			<span class="enscript-comment">/* linked list of rules         */</span>
        user32_addr_t	next_rule;<span class="enscript-comment">/* ptr to next [skipto] rule    */</span>
										<span class="enscript-comment">/* 'next_rule' is used to pass up 'set_disable' status          */</span>

        u_int16_t       act_ofs;		<span class="enscript-comment">/* offset of action in 32-bit units */</span>
        u_int16_t       cmd_len;        <span class="enscript-comment">/* # of 32-bit words in cmd     */</span>
        u_int16_t       rulenum;        <span class="enscript-comment">/* rule number                  */</span>
        u_int8_t        set;            <span class="enscript-comment">/* rule set (0..31)             */</span>
        u_int32_t       set_masks[2];   <span class="enscript-comment">/* masks for manipulating sets atomically */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RESVD_SET</span>       31      <span class="enscript-comment">/* set for default and persistent rules */</span>
        u_int8_t        _pad;           <span class="enscript-comment">/* padding                      */</span>

        <span class="enscript-comment">/* These fields are present in all rules.                       */</span>
        u_int64_t       pcnt;           <span class="enscript-comment">/* Packet counter               */</span>
        u_int64_t       bcnt;           <span class="enscript-comment">/* Byte counter                 */</span>
        u_int32_t       timestamp;      <span class="enscript-comment">/* tv_sec of last match         */</span>

        u_int32_t       reserved_1;     <span class="enscript-comment">/* reserved - set to 0 */</span>
        u_int32_t       reserved_2;     <span class="enscript-comment">/* reserved - set to 0 */</span>

        ipfw_insn       cmd[1];         <span class="enscript-comment">/* storage for commands         */</span>
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

<span class="enscript-type">struct</span> ip_fw_64{
        u_int32_t version;              <span class="enscript-comment">/* Version of this structure. MUST be set */</span>
										<span class="enscript-comment">/* by clients. Should always be */</span>
										<span class="enscript-comment">/* set to IP_FW_CURRENT_API_VERSION. */</span>
		__uint64_t context __attribute__((aligned(8))); <span class="enscript-comment">/* Context that is usable by user processes to */</span>
                                                        <span class="enscript-comment">/* identify this rule. */</span>
        user64_addr_t	next;          <span class="enscript-comment">/* linked list of rules         */</span>
        user64_addr_t	next_rule;     <span class="enscript-comment">/* ptr to next [skipto] rule    */</span>
        <span class="enscript-comment">/* 'next_rule' is used to pass up 'set_disable' status          */</span>

        u_int16_t       act_ofs;        <span class="enscript-comment">/* offset of action in 32-bit units */</span>
        u_int16_t       cmd_len;        <span class="enscript-comment">/* # of 32-bit words in cmd     */</span>
        u_int16_t       rulenum;        <span class="enscript-comment">/* rule number                  */</span>
        u_int8_t        set;            <span class="enscript-comment">/* rule set (0..31)             */</span>
        u_int32_t       set_masks[2];   <span class="enscript-comment">/* masks for manipulating sets atomically */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RESVD_SET</span>       31      <span class="enscript-comment">/* set for default and persistent rules */</span>
        u_int8_t        _pad;           <span class="enscript-comment">/* padding                      */</span>

        <span class="enscript-comment">/* These fields are present in all rules.                       */</span>
        u_int64_t       pcnt __attribute__((aligned(8)));	<span class="enscript-comment">/* Packet counter               */</span>
        u_int64_t       bcnt __attribute__((aligned(8)));      <span class="enscript-comment">/* Byte counter                 */</span>
        u_int32_t       timestamp;      <span class="enscript-comment">/* tv_sec of last match         */</span>

        u_int32_t       reserved_1;     <span class="enscript-comment">/* reserved - set to 0 */</span>
        u_int32_t       reserved_2;     <span class="enscript-comment">/* reserved - set to 0 */</span>

        ipfw_insn       cmd[1];         <span class="enscript-comment">/* storage for commands         */</span>
};


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _ipfw_dyn_rule_64 ipfw_dyn_rule_64;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> _ipfw_dyn_rule_32 ipfw_dyn_rule_32;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>(4)
<span class="enscript-type">struct</span> _ipfw_dyn_rule_32 {
        user32_addr_t	next;			<span class="enscript-comment">/* linked list of rules.        */</span>
        user32_addr_t	rule;			<span class="enscript-comment">/* pointer to rule              */</span>
        <span class="enscript-comment">/* 'rule' is used to pass up the rule number (from the parent)  */</span>

        user32_addr_t	parent;          <span class="enscript-comment">/* pointer to parent rule       */</span>
        u_int64_t       pcnt;           <span class="enscript-comment">/* packet match counter         */</span>
        u_int64_t       bcnt;           <span class="enscript-comment">/* byte match counter           */</span>
        <span class="enscript-type">struct</span> ipfw_flow_id id;         <span class="enscript-comment">/* (masked) flow id             */</span>
        u_int32_t       expire;         <span class="enscript-comment">/* expire time                  */</span>
        u_int32_t       bucket;         <span class="enscript-comment">/* which bucket in hash table   */</span>
        u_int32_t       state;          <span class="enscript-comment">/* state of this rule (typically a
                                         * combination of TCP flags)
                                         */</span>
        u_int32_t       ack_fwd;        <span class="enscript-comment">/* most recent ACKs in forward  */</span>
        u_int32_t       ack_rev;        <span class="enscript-comment">/* and reverse directions (used */</span>
                                        <span class="enscript-comment">/* to generate keepalives)      */</span>
        u_int16_t       dyn_type;       <span class="enscript-comment">/* rule type                    */</span>
        u_int16_t       count;          <span class="enscript-comment">/* refcount                     */</span>
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">pack</span>()

<span class="enscript-type">struct</span> _ipfw_dyn_rule_64 {
        user64_addr_t	next;          <span class="enscript-comment">/* linked list of rules.        */</span>
        user64_addr_t	rule;             <span class="enscript-comment">/* pointer to rule              */</span>
        <span class="enscript-comment">/* 'rule' is used to pass up the rule number (from the parent)  */</span>

        user64_addr_t	parent;          <span class="enscript-comment">/* pointer to parent rule       */</span>
        u_int64_t       pcnt;           <span class="enscript-comment">/* packet match counter         */</span>
        u_int64_t       bcnt;           <span class="enscript-comment">/* byte match counter           */</span>
        <span class="enscript-type">struct</span> ipfw_flow_id id;         <span class="enscript-comment">/* (masked) flow id             */</span>
        u_int32_t       expire;         <span class="enscript-comment">/* expire time                  */</span>
        u_int32_t       bucket;         <span class="enscript-comment">/* which bucket in hash table   */</span>
        u_int32_t       state;          <span class="enscript-comment">/* state of this rule (typically a
                                         * combination of TCP flags)
                                         */</span>
        u_int32_t       ack_fwd;        <span class="enscript-comment">/* most recent ACKs in forward  */</span>
        u_int32_t       ack_rev;        <span class="enscript-comment">/* and reverse directions (used */</span>
                                        <span class="enscript-comment">/* to generate keepalives)      */</span>
        u_int16_t       dyn_type;       <span class="enscript-comment">/* rule type                    */</span>
        u_int16_t       count;          <span class="enscript-comment">/* refcount                     */</span>
};


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>  _ipfw_insn_pipe_64 {
        ipfw_insn       o;
        user64_addr_t	pipe_ptr;      <span class="enscript-comment">/* XXX */</span>
} ipfw_insn_pipe_64;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span>  _ipfw_insn_pipe_32{
        ipfw_insn       o;
        user32_addr_t	pipe_ptr;      <span class="enscript-comment">/* XXX */</span>
} ipfw_insn_pipe_32;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPFW_DEFAULT_RULE</span>       65535

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_PORT_DYNT_FLAG</span>	0x10000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_PORT_TEE_FLAG</span>	0x20000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IP_FW_PORT_DENY_FLAG</span>	0x40000

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_flowid.h&gt;</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">struct</span> ip_fw_args;
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/*
 * Function definitions.
 */</span>

<span class="enscript-comment">/* Firewall hooks */</span>
<span class="enscript-type">struct</span> sockopt;
<span class="enscript-type">struct</span> dn_flow_set;

<span class="enscript-type">void</span> <span class="enscript-function-name">flush_pipe_ptrs</span>(<span class="enscript-type">struct</span> dn_flow_set *match); <span class="enscript-comment">/* used by dummynet */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_init</span>(<span class="enscript-type">void</span>);	<span class="enscript-comment">/* called from raw_ip.c: load_ipfw() */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip_fw_chk_t</span> (<span class="enscript-type">struct</span> ip_fw_args *args);
<span class="enscript-type">typedef</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip_fw_ctl_t</span> (<span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">extern</span> ip_fw_chk_t *ip_fw_chk_ptr;
<span class="enscript-type">extern</span> ip_fw_ctl_t *ip_fw_ctl_ptr;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_one_pass;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_enable;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPFW_LOADED</span>	(ip_fw_chk_ptr != NULL)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_OBSOLETE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _IPFW2_H */</span>
</pre>
<hr />
</body></html>