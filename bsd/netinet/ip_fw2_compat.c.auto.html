<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip_fw2_compat.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip_fw2_compat.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* IPFW2 Backward Compatibility */</span>

<span class="enscript-comment">/* Convert to and from IPFW2 structures. */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ip_fw2_compat.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span> 0

<span class="enscript-comment">/*
 * _s_x is a structure that stores a string &lt;-&gt; token pairs, used in
 * various places in the parser. Entries are stored in arrays,
 * with an entry with s=NULL as terminator.
 * The search routines are match_token() and match_value().
 * Often, an element with x=0 contains an error string.
 *
 */</span>
<span class="enscript-type">struct</span> _s_x {
	<span class="enscript-type">char</span> <span class="enscript-type">const</span> *s;
	<span class="enscript-type">int</span> x;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_VERSION_STR</span> <span class="enscript-string">&quot;IP_FW_VERSION_NONE&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VERSION_ZERO_STR</span> <span class="enscript-string">&quot;IP_FW_VERSION_0&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VERSION_ONE_STR</span> <span class="enscript-string">&quot;IP_FW_VERSION_1&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CURRENT_API_VERSION_STR</span> <span class="enscript-string">&quot;IP_FW_CURRENT_API_VERSION&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _s_x f_tcpflags[] = {
	{ <span class="enscript-string">&quot;syn&quot;</span>, TH_SYN },
	{ <span class="enscript-string">&quot;fin&quot;</span>, TH_FIN },
	{ <span class="enscript-string">&quot;ack&quot;</span>, TH_ACK },
	{ <span class="enscript-string">&quot;psh&quot;</span>, TH_PUSH },
	{ <span class="enscript-string">&quot;rst&quot;</span>, TH_RST },
	{ <span class="enscript-string">&quot;urg&quot;</span>, TH_URG },
	{ <span class="enscript-string">&quot;tcp flag&quot;</span>, 0 },
	{ NULL,	0 }
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _s_x f_tcpopts[] = {
	{ <span class="enscript-string">&quot;mss&quot;</span>,	IP_FW_TCPOPT_MSS },
	{ <span class="enscript-string">&quot;maxseg&quot;</span>,	IP_FW_TCPOPT_MSS },
	{ <span class="enscript-string">&quot;window&quot;</span>,	IP_FW_TCPOPT_WINDOW },
	{ <span class="enscript-string">&quot;sack&quot;</span>,	IP_FW_TCPOPT_SACK },
	{ <span class="enscript-string">&quot;ts&quot;</span>,		IP_FW_TCPOPT_TS },
	{ <span class="enscript-string">&quot;timestamp&quot;</span>,	IP_FW_TCPOPT_TS },
	{ <span class="enscript-string">&quot;cc&quot;</span>,		IP_FW_TCPOPT_CC },
	{ <span class="enscript-string">&quot;tcp option&quot;</span>,	0 },
	{ NULL,	0 }
};


<span class="enscript-comment">/*
 * IP options span the range 0 to 255 so we need to remap them
 * (though in fact only the low 5 bits are significant).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _s_x f_ipopts[] = {
	{ <span class="enscript-string">&quot;ssrr&quot;</span>,	IP_FW_IPOPT_SSRR},
	{ <span class="enscript-string">&quot;lsrr&quot;</span>,	IP_FW_IPOPT_LSRR},
	{ <span class="enscript-string">&quot;rr&quot;</span>,		IP_FW_IPOPT_RR},
	{ <span class="enscript-string">&quot;ts&quot;</span>,		IP_FW_IPOPT_TS},
	{ <span class="enscript-string">&quot;ip option&quot;</span>,	0 },
	{ NULL,	0 }
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _s_x f_iptos[] = {
	{ <span class="enscript-string">&quot;lowdelay&quot;</span>,	IPTOS_LOWDELAY},
	{ <span class="enscript-string">&quot;throughput&quot;</span>,	IPTOS_THROUGHPUT},
	{ <span class="enscript-string">&quot;reliability&quot;</span>, IPTOS_RELIABILITY},
	{ <span class="enscript-string">&quot;mincost&quot;</span>,	IPTOS_MINCOST},
	{ <span class="enscript-string">&quot;congestion&quot;</span>,	IPTOS_CE},
	{ <span class="enscript-string">&quot;ecntransport&quot;</span>, IPTOS_ECT},
	{ <span class="enscript-string">&quot;ip tos option&quot;</span>, 0},
	{ NULL,	0 }
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _s_x limit_masks[] = {
	{<span class="enscript-string">&quot;all&quot;</span>,		DYN_SRC_ADDR|DYN_SRC_PORT|DYN_DST_ADDR|DYN_DST_PORT},
	{<span class="enscript-string">&quot;src-addr&quot;</span>,	DYN_SRC_ADDR},
	{<span class="enscript-string">&quot;src-port&quot;</span>,	DYN_SRC_PORT},
	{<span class="enscript-string">&quot;dst-addr&quot;</span>,	DYN_DST_ADDR},
	{<span class="enscript-string">&quot;dst-port&quot;</span>,	DYN_DST_PORT},
	{NULL,		0}
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !FW2_DEBUG_VERBOSE */</span>

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* version #1 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_print_fw_flags</span>(u_int flags)
{
	<span class="enscript-comment">/* print action */</span>
	<span class="enscript-keyword">switch</span> (flags &amp; IP_FW_F_COMMAND_COMPAT) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_ACCEPT_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_ACCEPT_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_COUNT_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_COUNT_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_PIPE_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_PIPE_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_QUEUE_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_QUEUE_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_SKIPTO_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_SKIPTO_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DIVERT_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_DIVERT_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_TEE_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_TEE_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_FWD_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_FWD_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DENY_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_DENY_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_REJECT_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_REJECT_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_CHECK_S_COMPAT</span>:
			printf(<span class="enscript-string">&quot;IP_FW_F_CHECK_S_COMPAT\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;No action given\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* print commands */</span>
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_IN_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_IN_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_OUT_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_OUT_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_IIFACE_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_IIFACE_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_OIFACE_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_OIFACE_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_PRN_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_PRN_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_SRNG_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_SRNG_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_DRNG_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_DRNG_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_FRAG_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_FRAG_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_IIFNAME_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_IIFNAME_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_OIFNAME_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_OIFNAME_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_INVSRC_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_INVSRC_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_INVDST_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_INVDST_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_ICMPBIT_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_ICMPBIT_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_UID_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_UID_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_RND_MATCH_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_RND_MATCH_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_SMSK_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_SMSK_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_DMSK_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_DMSK_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_BRIDGED_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_BRIDGED_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_KEEP_S_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_KEEP_S_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_CHECK_S_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_CHECK_S_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_SME_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_SME_COMPAT\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (flags &amp; IP_FW_F_DME_COMPAT) {
		printf(<span class="enscript-string">&quot;IP_FW_F_DME_COMPAT\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_fw_version</span>(u_int32_t api_version)
{
	<span class="enscript-keyword">switch</span> (api_version) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_0</span>:
			printf(<span class="enscript-string">&quot;Version: %s\n&quot;</span>, VERSION_ZERO_STR);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_1</span>:
			printf(<span class="enscript-string">&quot;Version: %s\n&quot;</span>, VERSION_ONE_STR);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_CURRENT_API_VERSION</span>:
			printf(<span class="enscript-string">&quot;Version: %s\n&quot;</span>, CURRENT_API_VERSION_STR);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_NONE</span>:
			printf(<span class="enscript-string">&quot;Version: %s\n&quot;</span>, NO_VERSION_STR);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;Unrecognized version\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_icmptypes</span>(ipfw_insn_u32 *cmd)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">char</span> sep= <span class="enscript-string">' '</span>;

	printf(<span class="enscript-string">&quot; icmptypes&quot;</span>);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 32; i++) {
		<span class="enscript-keyword">if</span> ( (cmd-&gt;d[0] &amp; (1 &lt;&lt; (i))) == 0)
			<span class="enscript-keyword">continue</span>;
		printf(<span class="enscript-string">&quot;%c%d&quot;</span>, sep, i);
		sep = <span class="enscript-string">','</span>;
	}
}

<span class="enscript-comment">/*
 * print flags set/clear in the two bitmasks passed as parameters.
 * There is a specialized check for f_tcpflags.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_flags</span>(<span class="enscript-type">char</span> <span class="enscript-type">const</span> *name, ipfw_insn *cmd, <span class="enscript-type">struct</span> _s_x *list)
{
	<span class="enscript-type">char</span> <span class="enscript-type">const</span> *comma = <span class="enscript-string">&quot;&quot;</span>;
	<span class="enscript-type">int</span> i;
	uint8_t set = cmd-&gt;arg1 &amp; 0xff;
	uint8_t clear = (cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff;

	<span class="enscript-keyword">if</span> (list == f_tcpflags &amp;&amp; set == TH_SYN &amp;&amp; clear == TH_ACK) {
		printf(<span class="enscript-string">&quot; setup&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	printf(<span class="enscript-string">&quot; %s &quot;</span>, name);
	<span class="enscript-keyword">for</span> (i=0; list[i].x != 0; i++) {
		<span class="enscript-keyword">if</span> (set &amp; list[i].x) {
			set &amp;= ~list[i].x;
			printf(<span class="enscript-string">&quot;%s%s&quot;</span>, comma, list[i].s);
			comma = <span class="enscript-string">&quot;,&quot;</span>;
		}
		<span class="enscript-keyword">if</span> (clear &amp; list[i].x) {
			clear &amp;= ~list[i].x;
			printf(<span class="enscript-string">&quot;%s!%s&quot;</span>, comma, list[i].s);
			comma = <span class="enscript-string">&quot;,&quot;</span>;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">contigmask</span>(uint8_t *p, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">int</span> i, n;

	<span class="enscript-keyword">for</span> (i=0; i&lt;len ; i++)
		<span class="enscript-keyword">if</span> ( (p[i/8] &amp; (1 &lt;&lt; (7 - (i%8)))) == 0) <span class="enscript-comment">/* first bit unset */</span>
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">for</span> (n=i+1; n &lt; len; n++)
		<span class="enscript-keyword">if</span> ( (p[n/8] &amp; (1 &lt;&lt; (7 - (n%8)))) != 0)
			<span class="enscript-keyword">return</span> -1; <span class="enscript-comment">/* mask not contiguous */</span>
	<span class="enscript-keyword">return</span> i;
}

<span class="enscript-comment">/*
 * Print the ip address contained in a command.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_ip</span>(ipfw_insn_ip *cmd)
{
	<span class="enscript-type">int</span> len = F_LEN((ipfw_insn *)cmd);
	uint32_t *a = ((ipfw_insn_u32 *)cmd)-&gt;d;
	<span class="enscript-type">char</span> ipv4str[MAX_IPv4_STR_LEN];

	printf(<span class="enscript-string">&quot;%s &quot;</span>, cmd-&gt;o.len &amp; F_NOT ? <span class="enscript-string">&quot; not&quot;</span>: <span class="enscript-string">&quot;&quot;</span>);

	<span class="enscript-keyword">if</span> (cmd-&gt;o.opcode == O_IP_SRC_ME || cmd-&gt;o.opcode == O_IP_DST_ME) {
		printf(<span class="enscript-string">&quot;me&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * len == 2 indicates a single IP, whereas lists of 1 or more
	 * addr/mask pairs have len = (2n+1). We convert len to n so we
	 * use that to count the number of entries.
	 */</span>
    <span class="enscript-keyword">for</span> (len = len / 2; len &gt; 0; len--, a += 2) {
	<span class="enscript-type">int</span> mb =	<span class="enscript-comment">/* mask length */</span>
	    (cmd-&gt;o.opcode == O_IP_SRC || cmd-&gt;o.opcode == O_IP_DST) ?
		32 : contigmask((uint8_t *)&amp;(a[1]), 32);
	<span class="enscript-keyword">if</span> (mb == 0) {	<span class="enscript-comment">/* any */</span>
		printf(<span class="enscript-string">&quot;any&quot;</span>);
	} <span class="enscript-keyword">else</span> {		<span class="enscript-comment">/* numeric IP followed by some kind of mask */</span>
		printf(<span class="enscript-string">&quot;%s&quot;</span>, inet_ntop(AF_INET, &amp;a[0], ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
		<span class="enscript-keyword">if</span> (mb &lt; 0)
			printf(<span class="enscript-string">&quot;:%s&quot;</span>, inet_ntop(AF_INET, &amp;a[1], ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mb &lt; 32)
			printf(<span class="enscript-string">&quot;/%d&quot;</span>, mb);
	}
	<span class="enscript-keyword">if</span> (len &gt; 1)
		printf(<span class="enscript-string">&quot;,&quot;</span>);
    }
}

<span class="enscript-comment">/*
 * prints a MAC address/mask pair
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_mac</span>(uint8_t *addr, uint8_t *mask)
{
	<span class="enscript-type">int</span> l = contigmask(mask, 48);

	<span class="enscript-keyword">if</span> (l == 0)
		printf(<span class="enscript-string">&quot; any&quot;</span>);
	<span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot; %02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,
		    addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
		<span class="enscript-keyword">if</span> (l == -1)
			printf(<span class="enscript-string">&quot;&amp;%02x:%02x:%02x:%02x:%02x:%02x&quot;</span>,
			    mask[0], mask[1], mask[2],
			    mask[3], mask[4], mask[5]);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (l &lt; 48)
			printf(<span class="enscript-string">&quot;/%d&quot;</span>, l);
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !version #1 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_print_vers2_struct</span>(<span class="enscript-type">struct</span> ip_fw *vers2_rule)
{
	<span class="enscript-type">int</span>			l;
	ipfw_insn		*cmd;
	ipfw_insn_log	*logptr = NULL;
	<span class="enscript-type">char</span>			ipv4str[MAX_IPv4_STR_LEN];
	
	print_fw_version(vers2_rule-&gt;version);

	printf(<span class="enscript-string">&quot;act_ofs: %d\n&quot;</span>, vers2_rule-&gt;act_ofs);
	printf(<span class="enscript-string">&quot;cmd_len: %d\n&quot;</span>, vers2_rule-&gt;cmd_len);
	printf(<span class="enscript-string">&quot;rulenum: %d\n&quot;</span>, vers2_rule-&gt;rulenum);
	printf(<span class="enscript-string">&quot;set: %d\n&quot;</span>, vers2_rule-&gt;set);
	printf(<span class="enscript-string">&quot;pcnt: %llu\n&quot;</span>, vers2_rule-&gt;pcnt);
	printf(<span class="enscript-string">&quot;bcnt: %llu\n&quot;</span>, vers2_rule-&gt;bcnt);
	printf(<span class="enscript-string">&quot;timestamp: %d\n&quot;</span>, vers2_rule-&gt;timestamp);
	
	<span class="enscript-comment">/*
	 * first print actions
	 */</span>
	<span class="enscript-keyword">for</span> (l = vers2_rule-&gt;cmd_len - vers2_rule-&gt;act_ofs, cmd = ACTION_PTR(vers2_rule);
			l &gt; 0 ; l -= F_LEN(cmd), cmd += F_LEN(cmd)) {
		<span class="enscript-keyword">switch</span>(cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_CHECK_STATE</span>:
				printf(<span class="enscript-string">&quot;check-state&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
				printf(<span class="enscript-string">&quot;allow&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
				printf(<span class="enscript-string">&quot;count&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
				printf(<span class="enscript-string">&quot;deny&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
				<span class="enscript-keyword">if</span> (cmd-&gt;arg1 == ICMP_REJECT_RST)
					printf(<span class="enscript-string">&quot;reset&quot;</span>);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;arg1 == ICMP_UNREACH_HOST)
					printf(<span class="enscript-string">&quot;reject&quot;</span>);
				<span class="enscript-keyword">else</span>
					printf(<span class="enscript-string">&quot;unreach %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
				printf(<span class="enscript-string">&quot;skipto %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
				printf(<span class="enscript-string">&quot;pipe %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
				printf(<span class="enscript-string">&quot;queue %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
				printf(<span class="enscript-string">&quot;divert %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
				printf(<span class="enscript-string">&quot;tee %u&quot;</span>, cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
			{
				ipfw_insn_sa *s = (ipfw_insn_sa *)cmd;
	
				printf(<span class="enscript-string">&quot;fwd %s&quot;</span>,
					   inet_ntop(AF_INET, &amp;s-&gt;sa.sin_addr, ipv4str,
					   			 <span class="enscript-keyword">sizeof</span>(ipv4str)));
				<span class="enscript-keyword">if</span> (s-&gt;sa.sin_port)
					printf(<span class="enscript-string">&quot;,%d&quot;</span>, s-&gt;sa.sin_port);
				<span class="enscript-keyword">break</span>;
			}
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>: <span class="enscript-comment">/* O_LOG is printed last */</span>
				logptr = (ipfw_insn_log *)cmd;
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;** unrecognized action %d len %d&quot;</span>,
					cmd-&gt;opcode, cmd-&gt;len);
		}
	}
	<span class="enscript-keyword">if</span> (logptr) {
		<span class="enscript-keyword">if</span> (logptr-&gt;max_log &gt; 0)
			printf(<span class="enscript-string">&quot; log logamount %d&quot;</span>, logptr-&gt;max_log);
		<span class="enscript-keyword">else</span>
			printf(<span class="enscript-string">&quot; log&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * then print the body.
	 */</span>
	<span class="enscript-keyword">for</span> (l = vers2_rule-&gt;act_ofs, cmd = vers2_rule-&gt;cmd ;
		l &gt; 0 ; l -= F_LEN(cmd) , cmd += F_LEN(cmd)) {
		<span class="enscript-comment">/* useful alias */</span>
		ipfw_insn_u32 *cmd32 = (ipfw_insn_u32 *)cmd;

		<span class="enscript-keyword">switch</span>(cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROB</span>:
				<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* done already */</span>
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROBE_STATE</span>:
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* no need to print anything here */</span>
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MACADDR2</span>: 
			{
				ipfw_insn_mac *m = (ipfw_insn_mac *)cmd;
	
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT)
					printf(<span class="enscript-string">&quot; not&quot;</span>);
				printf(<span class="enscript-string">&quot; MAC&quot;</span>);
				print_mac(m-&gt;addr, m-&gt;mask);
				print_mac(m-&gt;addr + 6, m-&gt;mask + 6);
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MAC_TYPE</span>:
			{
				uint16_t *p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
				<span class="enscript-type">int</span> i;
	
				<span class="enscript-keyword">for</span> (i = F_LEN((ipfw_insn *)cmd) - 1; i &gt; 0; i--, p += 2) {
					printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[0]);
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						printf(<span class="enscript-string">&quot;-&quot;</span>);
						printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[1]);
					}
					printf(<span class="enscript-string">&quot;,&quot;</span>);
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_MASK</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_ME</span>:
				print_ip((ipfw_insn_ip *)cmd);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_MASK</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_ME</span>:
				print_ip((ipfw_insn_ip *)cmd);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DSTPORT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRCPORT</span>:
			{
				uint16_t *p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
				<span class="enscript-type">int</span> i;
	
				<span class="enscript-keyword">for</span> (i = F_LEN((ipfw_insn *)cmd) - 1; i &gt; 0; i--, p += 2) {
					printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[0]);
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						printf(<span class="enscript-string">&quot;-&quot;</span>);
						printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[1]);
					}
					printf(<span class="enscript-string">&quot;,&quot;</span>);
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROTO</span>: 
			{
				printf(<span class="enscript-string">&quot;O_PROTO&quot;</span>);
				
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT)
					printf(<span class="enscript-string">&quot; not&quot;</span>);
	
				printf(<span class="enscript-string">&quot; %u&quot;</span>, cmd-&gt;arg1);
					
				<span class="enscript-keyword">break</span>;
			}
	
			<span class="enscript-reference">default</span>: <span class="enscript-comment">/*options ... */</span>
			{
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT &amp;&amp; cmd-&gt;opcode != O_IN)
					printf(<span class="enscript-string">&quot; not&quot;</span>);
				<span class="enscript-keyword">switch</span>(cmd-&gt;opcode) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FRAG</span>:
						printf(<span class="enscript-string">&quot;O_FRAG&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IN</span>:
						printf(cmd-&gt;len &amp; F_NOT ? <span class="enscript-string">&quot; out&quot;</span> : <span class="enscript-string">&quot; O_IN&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LAYER2</span>:
						printf(<span class="enscript-string">&quot; O_LAYER2&quot;</span>);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_XMIT</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RECV</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VIA</span>: 
					{
						<span class="enscript-type">char</span> <span class="enscript-type">const</span> *s;
						ipfw_insn_if *cmdif = (ipfw_insn_if *)cmd;
		
						<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_XMIT)
							s = <span class="enscript-string">&quot;O_XMIT&quot;</span>;
						<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_RECV)
							s = <span class="enscript-string">&quot;O_RECV&quot;</span>;
						<span class="enscript-keyword">else</span> <span class="enscript-comment">/* if (cmd-&gt;opcode == O_VIA) */</span>
							s = <span class="enscript-string">&quot;O_VIA&quot;</span>;
						<span class="enscript-keyword">if</span> (cmdif-&gt;name[0] == <span class="enscript-string">'\0'</span>) {
							printf(<span class="enscript-string">&quot; %s %s&quot;</span>, s,
								   inet_ntop(AF_INET, &amp;cmdif-&gt;p.ip, ipv4str,
								   			 <span class="enscript-keyword">sizeof</span>(ipv4str)));
						}
						<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmdif-&gt;p.unit == -1)
							printf(<span class="enscript-string">&quot; %s %s*&quot;</span>, s, cmdif-&gt;name);
						<span class="enscript-keyword">else</span>
							printf(<span class="enscript-string">&quot; %s %s%d&quot;</span>, s, cmdif-&gt;name,
								cmdif-&gt;p.unit);
					}
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPID</span>:
						<span class="enscript-keyword">if</span> (F_LEN(cmd) == 1)
							printf(<span class="enscript-string">&quot; ipid %u&quot;</span>, cmd-&gt;arg1 );
						<span class="enscript-keyword">else</span> {
							uint16_t *p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
							<span class="enscript-type">int</span> i;
				
							<span class="enscript-keyword">for</span> (i = F_LEN((ipfw_insn *)cmd) - 1; i &gt; 0; i--, p += 2) {
								printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[0]);
								<span class="enscript-keyword">if</span> (p[0] != p[1]) {
									printf(<span class="enscript-string">&quot;-&quot;</span>);
									printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[1]);
								}
								printf(<span class="enscript-string">&quot;,&quot;</span>);
							}
						}
						
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTTL</span>:
						<span class="enscript-keyword">if</span> (F_LEN(cmd) == 1)
							printf(<span class="enscript-string">&quot; ipttl %u&quot;</span>, cmd-&gt;arg1 );
						<span class="enscript-keyword">else</span> {
							uint16_t *p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
							<span class="enscript-type">int</span> i;
				
							<span class="enscript-keyword">for</span> (i = F_LEN((ipfw_insn *)cmd) - 1; i &gt; 0; i--, p += 2) {
								printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[0]);
								<span class="enscript-keyword">if</span> (p[0] != p[1]) {
									printf(<span class="enscript-string">&quot;-&quot;</span>);
									printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[1]);
								}
								printf(<span class="enscript-string">&quot;,&quot;</span>);
							}
						}
						
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPVER</span>:
						printf(<span class="enscript-string">&quot; ipver %u&quot;</span>, cmd-&gt;arg1 );
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPPRECEDENCE</span>:
						printf(<span class="enscript-string">&quot; ipprecedence %u&quot;</span>, (cmd-&gt;arg1) &gt;&gt; 5 );
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPLEN</span>:
						<span class="enscript-keyword">if</span> (F_LEN(cmd) == 1)
							printf(<span class="enscript-string">&quot; iplen %u&quot;</span>, cmd-&gt;arg1 );
						<span class="enscript-keyword">else</span> {
							uint16_t *p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
							<span class="enscript-type">int</span> i;
				
							<span class="enscript-keyword">for</span> (i = F_LEN((ipfw_insn *)cmd) - 1; i &gt; 0; i--, p += 2) {
								printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[0]);
								<span class="enscript-keyword">if</span> (p[0] != p[1]) {
									printf(<span class="enscript-string">&quot;-&quot;</span>);
									printf(<span class="enscript-string">&quot;0x%04x&quot;</span>, p[1]);
								}
								printf(<span class="enscript-string">&quot;,&quot;</span>);
							}
						}
						
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPOPT</span>:
						print_flags(<span class="enscript-string">&quot;ipoptions&quot;</span>, cmd, f_ipopts);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTOS</span>:
						print_flags(<span class="enscript-string">&quot;iptos&quot;</span>, cmd, f_iptos);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ICMPTYPE</span>:
						print_icmptypes((ipfw_insn_u32 *)cmd);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ESTAB</span>:
						printf(<span class="enscript-string">&quot; established&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPFLAGS</span>:
						print_flags(<span class="enscript-string">&quot;tcpflags&quot;</span>, cmd, f_tcpflags);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPOPTS</span>:
						print_flags(<span class="enscript-string">&quot;tcpoptions&quot;</span>, cmd, f_tcpopts);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPWIN</span>:
						printf(<span class="enscript-string">&quot; tcpwin %d&quot;</span>, ntohs(cmd-&gt;arg1));
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPACK</span>:
						printf(<span class="enscript-string">&quot; tcpack %u&quot;</span>, ntohl(cmd32-&gt;d[0]));
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPSEQ</span>:
						printf(<span class="enscript-string">&quot; tcpseq %u&quot;</span>, ntohl(cmd32-&gt;d[0]));
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_UID</span>:
						printf(<span class="enscript-string">&quot; uid %u&quot;</span>, cmd32-&gt;d[0]);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_GID</span>:
						printf(<span class="enscript-string">&quot; gid %u&quot;</span>, cmd32-&gt;d[0]);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VERREVPATH</span>:
						printf(<span class="enscript-string">&quot; verrevpath&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPSEC</span>:
						printf(<span class="enscript-string">&quot; ipsec&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_NOP</span>:
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
						printf(<span class="enscript-string">&quot; keep-state&quot;</span>);
						<span class="enscript-keyword">break</span>;
		
					<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LIMIT</span>:
					{
						<span class="enscript-type">struct</span> _s_x *p = limit_masks;
						ipfw_insn_limit *c = (ipfw_insn_limit *)cmd;
						uint8_t x = c-&gt;limit_mask;
						<span class="enscript-type">char</span> <span class="enscript-type">const</span> *comma = <span class="enscript-string">&quot; &quot;</span>;
		
						printf(<span class="enscript-string">&quot; limit&quot;</span>);
						<span class="enscript-keyword">for</span> (; p-&gt;x != 0 ; p++)
							<span class="enscript-keyword">if</span> ((x &amp; p-&gt;x) == p-&gt;x) {
								x &amp;= ~p-&gt;x;
								printf(<span class="enscript-string">&quot;%s%s&quot;</span>, comma, p-&gt;s);
								comma = <span class="enscript-string">&quot;,&quot;</span>;
							}
						printf(<span class="enscript-string">&quot; %d&quot;</span>, c-&gt;conn_limit);
						
						<span class="enscript-keyword">break</span>;
					}
		
					<span class="enscript-reference">default</span>:
						printf(<span class="enscript-string">&quot; [opcode %d len %d]&quot;</span>,
							cmd-&gt;opcode, cmd-&gt;len);
				} <span class="enscript-comment">/* switch */</span>
			} <span class="enscript-comment">/* default */</span>
		} <span class="enscript-comment">/* switch */</span>
	} <span class="enscript-comment">/* for */</span>
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !FW2_DEBUG_VERBOSE */</span>


<span class="enscript-comment">/*
 * helper function, updates the pointer to cmd with the length
 * of the current command, and also cleans up the first word of
 * the new command in case it has been clobbered before.
 * from ipfw2.c
 */</span>
<span class="enscript-type">static</span> ipfw_insn *
<span class="enscript-function-name">next_cmd</span>(ipfw_insn *cmd)
{
	cmd += F_LEN(cmd);
	bzero(cmd, <span class="enscript-keyword">sizeof</span>(*cmd));
	<span class="enscript-keyword">return</span> cmd;
}

<span class="enscript-comment">/*
 * A function to fill simple commands of size 1.
 * Existing flags are preserved.
 * from ipfw2.c
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_cmd</span>(ipfw_insn *cmd, <span class="enscript-type">enum</span> ipfw_opcodes opcode, uint16_t arg)
{
	cmd-&gt;opcode = opcode;
	cmd-&gt;len =  ((cmd-&gt;len) &amp; (F_NOT | F_OR)) | 1;
	cmd-&gt;arg1 = arg;
}


<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">fill_compat_tcpflags</span>(u_int32_t flags) {
	u_int32_t	flags_compat = 0;
	
	<span class="enscript-keyword">if</span> (flags &amp; TH_FIN)
		flags_compat |= IP_FW_TCPF_FIN_COMPAT;
	<span class="enscript-keyword">if</span> (flags &amp; TH_SYN)
		flags_compat |= IP_FW_TCPF_SYN_COMPAT;
	<span class="enscript-keyword">if</span> (flags &amp; TH_RST)
		flags_compat |= IP_FW_TCPF_RST_COMPAT;
	<span class="enscript-keyword">if</span> (flags &amp; TH_PUSH)
		flags_compat |= IP_FW_TCPF_PSH_COMPAT;
	<span class="enscript-keyword">if</span> (flags &amp; TH_ACK)
		flags_compat |= IP_FW_TCPF_ACK_COMPAT;
	<span class="enscript-keyword">if</span> (flags &amp; TH_URG)
		flags_compat |= IP_FW_TCPF_URG_COMPAT;
		
	<span class="enscript-keyword">return</span> flags_compat;
}


<span class="enscript-comment">/* ********************************************
 * *********** Convert from Latest ************
 * ********************************************/</span>

<span class="enscript-comment">/*
 * Things we're actively ignoring:
 *	sets, sets of addresses, blocks (NOT, OR)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_map_from_cmds_32</span>(<span class="enscript-type">struct</span> ip_fw_32 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_32 *compat_rule)
{
	<span class="enscript-type">int</span> 		l;
	ipfw_insn	*cmd;

	<span class="enscript-keyword">for</span> (l = curr_rule-&gt;act_ofs, cmd = curr_rule-&gt;cmd ;
		l &gt; 0 ; 
		l -= F_LEN(cmd) , cmd += F_LEN(cmd)) {
		<span class="enscript-comment">/* useful alias */</span>
		ipfw_insn_u32 *cmd32 = (ipfw_insn_u32 *)cmd;

		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROTO</span>:
				<span class="enscript-comment">/* protocol */</span>
				compat_rule-&gt;fw_prot = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_ME</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_SME_COMPAT;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_MASK</span>:
			{
				<span class="enscript-comment">/* addr/mask */</span>
				ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
				
				compat_rule-&gt;fw_src = ip-&gt;addr;
				compat_rule-&gt;fw_smsk = ip-&gt;mask;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC</span>:
				<span class="enscript-comment">/* one IP */</span>
				<span class="enscript-comment">/* source - 
				 * for now we only deal with one address
				 * per rule and ignore sets of addresses
				 */</span>
				compat_rule-&gt;fw_src.s_addr = cmd32-&gt;d[0];
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRCPORT</span>:
			{
				<span class="enscript-comment">/* source ports */</span>
				ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
				uint16_t		*p = ports-&gt;ports;
				<span class="enscript-type">int</span>				i, j;
				
				<span class="enscript-comment">/* copy list of ports */</span>
				<span class="enscript-keyword">for</span> (i = F_LEN(cmd) - 1, j = 0; i &gt; 0; i--, j++, p += 2) {
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						<span class="enscript-comment">/* this is a range */</span>
						compat_rule-&gt;fw_flg |= IP_FW_F_SRNG_COMPAT;
						compat_rule-&gt;fw_uar_compat.fw_pts[j++] = p[0];
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[1];
					} <span class="enscript-keyword">else</span> {
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[0];
					}
				}
				IP_FW_SETNSRCP_COMPAT(compat_rule, j);
				
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_ME</span>:
			<span class="enscript-comment">/* destination */</span>
				compat_rule-&gt;fw_flg |= IP_FW_F_DME_COMPAT;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_MASK</span>:
			{
				<span class="enscript-comment">/* addr/mask */</span>
				ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
				
				compat_rule-&gt;fw_dst = ip-&gt;addr;
				compat_rule-&gt;fw_dmsk = ip-&gt;mask;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST</span>:
				<span class="enscript-comment">/* one IP */</span>
				<span class="enscript-comment">/* dest - 
				 * for now we only deal with one address
				 * per rule, and ignore sets of addresses
				 */</span>
				compat_rule-&gt;fw_dst.s_addr = cmd32-&gt;d[0];
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DSTPORT</span>:
			{
				<span class="enscript-comment">/* dest. ports */</span>
				ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
				uint16_t		*p = ports-&gt;ports;
				<span class="enscript-type">int</span>				i, 
								j = IP_FW_GETNSRCP_COMPAT(compat_rule);
				
				<span class="enscript-comment">/* copy list of ports */</span>
				<span class="enscript-keyword">for</span> (i = F_LEN(cmd) - 1; i &gt; 0; i--, j++, p += 2) {
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						<span class="enscript-comment">/* this is a range */</span>
						compat_rule-&gt;fw_flg |= IP_FW_F_DRNG_COMPAT;
						compat_rule-&gt;fw_uar_compat.fw_pts[j++] = p[0];
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[1];
					} <span class="enscript-keyword">else</span> {
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[0];
					}
				}
				IP_FW_SETNDSTP_COMPAT(compat_rule, (j - IP_FW_GETNSRCP_COMPAT(compat_rule)));
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
			{
				ipfw_insn_log *c = (ipfw_insn_log *)cmd;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_PRN_COMPAT;
				compat_rule-&gt;fw_logamount = c-&gt;max_log;
				<span class="enscript-keyword">break</span>;
			}	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_UID</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_UID_COMPAT;
				compat_rule-&gt;fw_uid = cmd32-&gt;d[0];
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IN</span>:
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_OUT_COMPAT;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_IN_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_KEEP_S_COMPAT;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LAYER2</span>:
				compat_rule-&gt;fw_flg |= IP_FW_BRIDGED_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_XMIT</span>:
			{
				ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFACE_COMPAT;
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;p.ip.s_addr != 0) {
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFACE_COMPAT;
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				}
				compat_rule-&gt;fw_out_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RECV</span>:
			{
				ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFACE_COMPAT;
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;p.ip.s_addr != 0) {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFACE_COMPAT;
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				}
				compat_rule-&gt;fw_in_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VIA</span>:
			{
				ipfw_insn_if			*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;name[0] != <span class="enscript-string">'\0'</span>) {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				} <span class="enscript-keyword">else</span> {
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				}
				compat_rule-&gt;fw_flg |= IF_FW_F_VIAHACK_COMPAT;
				compat_rule-&gt;fw_out_if = compat_rule-&gt;fw_in_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FRAG</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_FRAG_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPOPT</span>:
				<span class="enscript-comment">/* IP options */</span>
				compat_rule-&gt;fw_ipopt = (cmd-&gt;arg1 &amp; 0xff);
				compat_rule-&gt;fw_ipnopt = ((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPFLAGS</span>:
				<span class="enscript-comment">/* check for &quot;setup&quot; */</span>
				<span class="enscript-keyword">if</span> ((cmd-&gt;arg1 &amp; 0xff) == TH_SYN &amp;&amp;
					((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff) == TH_ACK) {
					compat_rule-&gt;fw_tcpf = IP_FW_TCPF_SYN_COMPAT;
					compat_rule-&gt;fw_tcpnf = IP_FW_TCPF_ACK_COMPAT;
				}
				<span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_tcpf = fill_compat_tcpflags(cmd-&gt;arg1 &amp; 0xff);
					compat_rule-&gt;fw_tcpnf = fill_compat_tcpflags((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				}
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPOPTS</span>:
				<span class="enscript-comment">/* TCP options */</span>
				compat_rule-&gt;fw_tcpopt = (cmd-&gt;arg1 &amp; 0xff);
				compat_rule-&gt;fw_tcpnopt = ((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ESTAB</span>:
				compat_rule-&gt;fw_ipflg |= IP_FW_IF_TCPEST_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ICMPTYPE</span>:
			{
				<span class="enscript-comment">/* ICMP */</span>
				<span class="enscript-comment">/* XXX: check this */</span>
				<span class="enscript-type">int</span>	i, type;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_ICMPBIT_COMPAT;
				<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(uint32_t) ; i++) {
					type = cmd32-&gt;d[0] &amp; i;
					
					compat_rule-&gt;fw_uar_compat.fw_icmptypes[type / (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8)] |= 
						1 &lt;&lt; (type % (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8));
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-comment">/* switch */</span>
	} <span class="enscript-comment">/* for */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_map_from_cmds_64</span>(<span class="enscript-type">struct</span> ip_fw_64 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_64 *compat_rule)
{
	<span class="enscript-type">int</span> 		l;
	ipfw_insn	*cmd;
	<span class="enscript-keyword">for</span> (l = curr_rule-&gt;act_ofs, cmd = curr_rule-&gt;cmd ;
		l &gt; 0 ; 
		l -= F_LEN(cmd) , cmd += F_LEN(cmd)) {
		<span class="enscript-comment">/* useful alias */</span>
		ipfw_insn_u32 *cmd32 = (ipfw_insn_u32 *)cmd;

		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROTO</span>:
				<span class="enscript-comment">/* protocol */</span>
				compat_rule-&gt;fw_prot = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_ME</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_SME_COMPAT;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_MASK</span>:
			{
				<span class="enscript-comment">/* addr/mask */</span>
				ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
				
				compat_rule-&gt;fw_src = ip-&gt;addr;
				compat_rule-&gt;fw_smsk = ip-&gt;mask;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC</span>:
				<span class="enscript-comment">/* one IP */</span>
				<span class="enscript-comment">/* source - 
				 * for now we only deal with one address
				 * per rule and ignore sets of addresses
				 */</span>
				compat_rule-&gt;fw_src.s_addr = cmd32-&gt;d[0];
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVSRC_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRCPORT</span>:
			{
				<span class="enscript-comment">/* source ports */</span>
				ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
				uint16_t		*p = ports-&gt;ports;
				<span class="enscript-type">int</span>				i, j;
				
				<span class="enscript-comment">/* copy list of ports */</span>
				<span class="enscript-keyword">for</span> (i = F_LEN(cmd) - 1, j = 0; i &gt; 0; i--, j++, p += 2) {
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						<span class="enscript-comment">/* this is a range */</span>
						compat_rule-&gt;fw_flg |= IP_FW_F_SRNG_COMPAT;
						compat_rule-&gt;fw_uar_compat.fw_pts[j++] = p[0];
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[1];
					} <span class="enscript-keyword">else</span> {
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[0];
					}
				}
				IP_FW_SETNSRCP_COMPAT(compat_rule, j);
				
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_ME</span>:
			<span class="enscript-comment">/* destination */</span>
				compat_rule-&gt;fw_flg |= IP_FW_F_DME_COMPAT;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_MASK</span>:
			{
				<span class="enscript-comment">/* addr/mask */</span>
				ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
				
				compat_rule-&gt;fw_dst = ip-&gt;addr;
				compat_rule-&gt;fw_dmsk = ip-&gt;mask;
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST</span>:
				<span class="enscript-comment">/* one IP */</span>
				<span class="enscript-comment">/* dest - 
				 * for now we only deal with one address
				 * per rule, and ignore sets of addresses
				 */</span>
				compat_rule-&gt;fw_dst.s_addr = cmd32-&gt;d[0];
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_INVDST_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DSTPORT</span>:
			{
				<span class="enscript-comment">/* dest. ports */</span>
				ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
				uint16_t		*p = ports-&gt;ports;
				<span class="enscript-type">int</span>				i, 
								j = IP_FW_GETNSRCP_COMPAT(compat_rule);
				
				<span class="enscript-comment">/* copy list of ports */</span>
				<span class="enscript-keyword">for</span> (i = F_LEN(cmd) - 1; i &gt; 0; i--, j++, p += 2) {
					<span class="enscript-keyword">if</span> (p[0] != p[1]) {
						<span class="enscript-comment">/* this is a range */</span>
						compat_rule-&gt;fw_flg |= IP_FW_F_DRNG_COMPAT;
						compat_rule-&gt;fw_uar_compat.fw_pts[j++] = p[0];
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[1];
					} <span class="enscript-keyword">else</span> {
						compat_rule-&gt;fw_uar_compat.fw_pts[j] = p[0];
					}
				}
				IP_FW_SETNDSTP_COMPAT(compat_rule, (j - IP_FW_GETNSRCP_COMPAT(compat_rule)));
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
			{
				ipfw_insn_log *c = (ipfw_insn_log *)cmd;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_PRN_COMPAT;
				compat_rule-&gt;fw_logamount = c-&gt;max_log;
				<span class="enscript-keyword">break</span>;
			}	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_UID</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_UID_COMPAT;
				compat_rule-&gt;fw_uid = cmd32-&gt;d[0];
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IN</span>:
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT) {
					compat_rule-&gt;fw_flg |= IP_FW_F_OUT_COMPAT;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_IN_COMPAT;
				}
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_KEEP_S_COMPAT;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LAYER2</span>:
				compat_rule-&gt;fw_flg |= IP_FW_BRIDGED_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_XMIT</span>:
			{
				ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFACE_COMPAT;
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;p.ip.s_addr != 0) {
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFACE_COMPAT;
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_OIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				}
				compat_rule-&gt;fw_out_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RECV</span>:
			{
				ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFACE_COMPAT;
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;p.ip.s_addr != 0) {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFACE_COMPAT;
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				} <span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				}
				compat_rule-&gt;fw_in_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VIA</span>:
			{
				ipfw_insn_if			*ifcmd = (ipfw_insn_if *)cmd;
				<span class="enscript-type">union</span> ip_fw_if_compat	ifu;
				
				<span class="enscript-keyword">if</span> ((ifcmd-&gt;o.len == 0) &amp;&amp; (ifcmd-&gt;name[0] == <span class="enscript-string">'\0'</span>)) {
					<span class="enscript-comment">/* any */</span>
					ifu.fu_via_ip.s_addr = 0;
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifcmd-&gt;name[0] != <span class="enscript-string">'\0'</span>) {
					compat_rule-&gt;fw_flg |= IP_FW_F_IIFNAME_COMPAT;
					strncpy(ifu.fu_via_if_compat.name, ifcmd-&gt;name, <span class="enscript-keyword">sizeof</span>(ifu.fu_via_if_compat.name));
					ifu.fu_via_if_compat.unit = ifcmd-&gt;p.unit;
				} <span class="enscript-keyword">else</span> {
					ifu.fu_via_ip = ifcmd-&gt;p.ip;
				}
				compat_rule-&gt;fw_flg |= IF_FW_F_VIAHACK_COMPAT;
				compat_rule-&gt;fw_out_if = compat_rule-&gt;fw_in_if = ifu;
				
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FRAG</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_FRAG_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPOPT</span>:
				<span class="enscript-comment">/* IP options */</span>
				compat_rule-&gt;fw_ipopt = (cmd-&gt;arg1 &amp; 0xff);
				compat_rule-&gt;fw_ipnopt = ((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPFLAGS</span>:
				<span class="enscript-comment">/* check for &quot;setup&quot; */</span>
				<span class="enscript-keyword">if</span> ((cmd-&gt;arg1 &amp; 0xff) == TH_SYN &amp;&amp;
					((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff) == TH_ACK) {
					compat_rule-&gt;fw_tcpf = IP_FW_TCPF_SYN_COMPAT;
					compat_rule-&gt;fw_tcpnf = IP_FW_TCPF_ACK_COMPAT;
				}
				<span class="enscript-keyword">else</span> {
					compat_rule-&gt;fw_tcpf = fill_compat_tcpflags(cmd-&gt;arg1 &amp; 0xff);
					compat_rule-&gt;fw_tcpnf = fill_compat_tcpflags((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				}
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPOPTS</span>:
				<span class="enscript-comment">/* TCP options */</span>
				compat_rule-&gt;fw_tcpopt = (cmd-&gt;arg1 &amp; 0xff);
				compat_rule-&gt;fw_tcpnopt = ((cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff);
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ESTAB</span>:
				compat_rule-&gt;fw_ipflg |= IP_FW_IF_TCPEST_COMPAT;
				<span class="enscript-keyword">break</span>;
			
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ICMPTYPE</span>:
			{
				<span class="enscript-comment">/* ICMP */</span>
				<span class="enscript-comment">/* XXX: check this */</span>
				<span class="enscript-type">int</span>	i, type;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_ICMPBIT_COMPAT;
				<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(uint32_t) ; i++) {
					type = cmd32-&gt;d[0] &amp; i;
					
					compat_rule-&gt;fw_uar_compat.fw_icmptypes[type / (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8)] |= 
						1 &lt;&lt; (type % (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8));
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-comment">/* switch */</span>
	} <span class="enscript-comment">/* for */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_map_from_actions_32</span>(<span class="enscript-type">struct</span> ip_fw_32 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_32 *compat_rule)
{
	<span class="enscript-type">int</span> l;
	ipfw_insn	*cmd;
	
	<span class="enscript-keyword">for</span> (l = curr_rule-&gt;cmd_len - curr_rule-&gt;act_ofs, cmd = ACTION_PTR(curr_rule);
			l &gt; 0 ; 
			l -= F_LEN(cmd), cmd += F_LEN(cmd)) {
		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_ACCEPT_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_COUNT_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_PIPE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_QUEUE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_SKIPTO_COMPAT;
				compat_rule-&gt;fw_skipto_rule_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_DIVERT_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_TEE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
			{
				ipfw_insn_sa	*p = (ipfw_insn_sa *)cmd;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_FWD_COMPAT;
				compat_rule-&gt;fw_fwd_ip_compat.sin_len = p-&gt;sa.sin_len;
				compat_rule-&gt;fw_fwd_ip_compat.sin_family = p-&gt;sa.sin_family;
				compat_rule-&gt;fw_fwd_ip_compat.sin_port = p-&gt;sa.sin_port;
				compat_rule-&gt;fw_fwd_ip_compat.sin_addr = p-&gt;sa.sin_addr;

				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_DENY_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_REJECT_COMPAT;
				compat_rule-&gt;fw_reject_code_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_CHECK_STATE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_CHECK_S_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_map_from_actions_64</span>(<span class="enscript-type">struct</span> ip_fw_64 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_64 *compat_rule)
{
	<span class="enscript-type">int</span> l;
	ipfw_insn	*cmd;
	<span class="enscript-keyword">for</span> (l = curr_rule-&gt;cmd_len - curr_rule-&gt;act_ofs, cmd = ACTION_PTR(curr_rule);
			l &gt; 0 ; 
			l -= F_LEN(cmd), cmd += F_LEN(cmd)) {
		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_ACCEPT_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_COUNT_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_PIPE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_QUEUE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_SKIPTO_COMPAT;
				compat_rule-&gt;fw_skipto_rule_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_DIVERT_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_TEE_COMPAT;
				compat_rule-&gt;fw_divert_port_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
			{
				ipfw_insn_sa	*p = (ipfw_insn_sa *)cmd;
				
				compat_rule-&gt;fw_flg |= IP_FW_F_FWD_COMPAT;
				compat_rule-&gt;fw_fwd_ip_compat.sin_len = p-&gt;sa.sin_len;
				compat_rule-&gt;fw_fwd_ip_compat.sin_family = p-&gt;sa.sin_family;
				compat_rule-&gt;fw_fwd_ip_compat.sin_port = p-&gt;sa.sin_port;
				compat_rule-&gt;fw_fwd_ip_compat.sin_addr = p-&gt;sa.sin_addr;

				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_DENY_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_REJECT_COMPAT;
				compat_rule-&gt;fw_reject_code_compat = cmd-&gt;arg1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_CHECK_STATE</span>:
				compat_rule-&gt;fw_flg |= IP_FW_F_CHECK_S_COMPAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_version_latest_to_one_32</span>(<span class="enscript-type">struct</span> ip_fw_32 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_32 *rule_vers1)
{
	<span class="enscript-keyword">if</span> (!rule_vers1)
		<span class="enscript-keyword">return</span>;
		
	bzero(rule_vers1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_32));
	
	rule_vers1-&gt;version = IP_FW_VERSION_1;
	rule_vers1-&gt;context = CAST_DOWN_EXPLICIT(user32_addr_t,curr_rule-&gt;context);
	rule_vers1-&gt;fw_number = curr_rule-&gt;rulenum;
	rule_vers1-&gt;fw_pcnt = curr_rule-&gt;pcnt;
	rule_vers1-&gt;fw_bcnt = curr_rule-&gt;bcnt;
	rule_vers1-&gt;timestamp = curr_rule-&gt;timestamp;
	
	<span class="enscript-comment">/* convert actions */</span>
	ipfw_map_from_actions_32(curr_rule, rule_vers1);

	<span class="enscript-comment">/* convert commands */</span>
	ipfw_map_from_cmds_32(curr_rule, rule_vers1);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>
	ipfw_print_vers1_struct_32(rule_vers1);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_version_latest_to_one_64</span>(<span class="enscript-type">struct</span> ip_fw_64 *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_64 *rule_vers1)
{
	<span class="enscript-keyword">if</span> (!rule_vers1)
		<span class="enscript-keyword">return</span>;
		
	bzero(rule_vers1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_64));
	
	rule_vers1-&gt;version = IP_FW_VERSION_1;
	rule_vers1-&gt;context = CAST_DOWN_EXPLICIT(__uint64_t, curr_rule-&gt;context);
	rule_vers1-&gt;fw_number = curr_rule-&gt;rulenum;
	rule_vers1-&gt;fw_pcnt = curr_rule-&gt;pcnt;
	rule_vers1-&gt;fw_bcnt = curr_rule-&gt;bcnt;
	rule_vers1-&gt;timestamp = curr_rule-&gt;timestamp;
	
	<span class="enscript-comment">/* convert actions */</span>
	ipfw_map_from_actions_64(curr_rule, rule_vers1);

	<span class="enscript-comment">/* convert commands */</span>
	ipfw_map_from_cmds_64(curr_rule, rule_vers1);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>
	ipfw_print_vers1_struct_64(rule_vers1);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/* first convert to version one then to version zero */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_version_latest_to_zero</span>(<span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">struct</span> ip_old_fw *rule_vers0, <span class="enscript-type">int</span> is64user)
{
	
	<span class="enscript-keyword">if</span> ( is64user ){
		<span class="enscript-type">struct</span> ip_fw_compat_64	rule_vers1;
		ipfw_version_latest_to_one_64((<span class="enscript-type">struct</span> ip_fw_64*)curr_rule, &amp;rule_vers1);
		bzero(rule_vers0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_old_fw));
		bcopy(&amp;rule_vers1.fw_uar_compat, &amp;rule_vers0-&gt;fw_uar, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_uar_compat));
		bcopy(&amp;rule_vers1.fw_in_if, &amp;rule_vers0-&gt;fw_in_if, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_in_if));
		bcopy(&amp;rule_vers1.fw_out_if, &amp;rule_vers0-&gt;fw_out_if, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_out_if));
		bcopy(&amp;rule_vers1.fw_un_compat, &amp;rule_vers0-&gt;fw_un, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_un_compat));
		rule_vers0-&gt;fw_pcnt       = rule_vers1.fw_pcnt;
		rule_vers0-&gt;fw_bcnt       = rule_vers1.fw_bcnt;
		rule_vers0-&gt;fw_src        = rule_vers1.fw_src;
		rule_vers0-&gt;fw_dst        = rule_vers1.fw_dst;
		rule_vers0-&gt;fw_smsk       = rule_vers1.fw_smsk;
		rule_vers0-&gt;fw_dmsk       = rule_vers1.fw_dmsk;
		rule_vers0-&gt;fw_number     = rule_vers1.fw_number;
		rule_vers0-&gt;fw_flg        = rule_vers1.fw_flg;
		rule_vers0-&gt;fw_ipopt      = rule_vers1.fw_ipopt;
		rule_vers0-&gt;fw_ipnopt     = rule_vers1.fw_ipnopt;
		rule_vers0-&gt;fw_tcpf       = rule_vers1.fw_tcpf;
		rule_vers0-&gt;fw_tcpnf      = rule_vers1.fw_tcpnf;
		rule_vers0-&gt;timestamp     = rule_vers1.timestamp;
		rule_vers0-&gt;fw_prot       = rule_vers1.fw_prot;
		rule_vers0-&gt;fw_nports     = rule_vers1.fw_nports;
		rule_vers0-&gt;pipe_ptr      = CAST_DOWN_EXPLICIT(<span class="enscript-type">void</span>*, rule_vers1.pipe_ptr);
		rule_vers0-&gt;next_rule_ptr = CAST_DOWN_EXPLICIT(<span class="enscript-type">void</span>*, rule_vers1.next_rule_ptr);

		<span class="enscript-keyword">if</span> (rule_vers1.fw_ipflg &amp; IP_FW_IF_TCPEST_COMPAT) rule_vers0-&gt;fw_tcpf |= IP_OLD_FW_TCPF_ESTAB;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ip_fw_compat_32	rule_vers1;
		ipfw_version_latest_to_one_32( (<span class="enscript-type">struct</span> ip_fw_32*)curr_rule, &amp;rule_vers1);
		bzero(rule_vers0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_old_fw));
		bcopy(&amp;rule_vers1.fw_uar_compat, &amp;rule_vers0-&gt;fw_uar, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_uar_compat));
		bcopy(&amp;rule_vers1.fw_in_if, &amp;rule_vers0-&gt;fw_in_if, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_in_if));
		bcopy(&amp;rule_vers1.fw_out_if, &amp;rule_vers0-&gt;fw_out_if, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_out_if));
		bcopy(&amp;rule_vers1.fw_un_compat, &amp;rule_vers0-&gt;fw_un, <span class="enscript-keyword">sizeof</span>(rule_vers1.fw_un_compat));
		rule_vers0-&gt;fw_pcnt       = rule_vers1.fw_pcnt;
		rule_vers0-&gt;fw_bcnt       = rule_vers1.fw_bcnt;
		rule_vers0-&gt;fw_src        = rule_vers1.fw_src;
		rule_vers0-&gt;fw_dst        = rule_vers1.fw_dst;
		rule_vers0-&gt;fw_smsk       = rule_vers1.fw_smsk;
		rule_vers0-&gt;fw_dmsk       = rule_vers1.fw_dmsk;
		rule_vers0-&gt;fw_number     = rule_vers1.fw_number;
		rule_vers0-&gt;fw_flg        = rule_vers1.fw_flg;
		rule_vers0-&gt;fw_ipopt      = rule_vers1.fw_ipopt;
		rule_vers0-&gt;fw_ipnopt     = rule_vers1.fw_ipnopt;
		rule_vers0-&gt;fw_tcpf       = rule_vers1.fw_tcpf;
		rule_vers0-&gt;fw_tcpnf      = rule_vers1.fw_tcpnf;
		rule_vers0-&gt;timestamp     = rule_vers1.timestamp;
		rule_vers0-&gt;fw_prot       = rule_vers1.fw_prot;
		rule_vers0-&gt;fw_nports     = rule_vers1.fw_nports;
		rule_vers0-&gt;pipe_ptr      = CAST_DOWN_EXPLICIT(<span class="enscript-type">void</span>*, rule_vers1.pipe_ptr);
		rule_vers0-&gt;next_rule_ptr = CAST_DOWN_EXPLICIT(<span class="enscript-type">void</span>*, rule_vers1.next_rule_ptr);

		<span class="enscript-keyword">if</span> (rule_vers1.fw_ipflg &amp; IP_FW_IF_TCPEST_COMPAT) rule_vers0-&gt;fw_tcpf |= IP_OLD_FW_TCPF_ESTAB;
	}

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_convert_from_latest</span>(<span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">void</span> *old_rule, u_int32_t api_version, <span class="enscript-type">int</span> is64user)
{
	<span class="enscript-keyword">switch</span> (api_version) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_0</span>:
		{
			<span class="enscript-type">struct</span> ip_old_fw	*rule_vers0 = old_rule;
			
			ipfw_version_latest_to_zero(curr_rule, rule_vers0, is64user);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_1</span>:
		{			
			<span class="enscript-keyword">if</span> ( is64user )
				ipfw_version_latest_to_one_64((<span class="enscript-type">struct</span> ip_fw_64*)curr_rule, (<span class="enscript-type">struct</span> ip_fw_compat_64 *)old_rule);
			<span class="enscript-keyword">else</span>
				ipfw_version_latest_to_one_32((<span class="enscript-type">struct</span> ip_fw_32*)curr_rule, (<span class="enscript-type">struct</span> ip_fw_compat_32 *)old_rule);

			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_CURRENT_API_VERSION</span>:
			<span class="enscript-comment">/* ipfw2 for now, don't need to do anything */</span>
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* unknown version */</span>
			<span class="enscript-keyword">break</span>;
	}
}


<span class="enscript-comment">/* ********************************************
 * *********** Convert to Latest **************
 * ********************************************/</span>

<span class="enscript-comment">/* from ip_fw.c */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_check_vers1_struct_32</span>(<span class="enscript-type">struct</span> ip_fw_compat_32 *frwl)
{
	<span class="enscript-comment">/* Check for invalid flag bits */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; ~IP_FW_F_MASK_COMPAT) != 0) {
		<span class="enscript-comment">/* 
		printf((&quot;%s undefined flag bits set (flags=%x)\n&quot;,
		    err_prefix, frwl-&gt;fw_flg));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (frwl-&gt;fw_flg == IP_FW_F_CHECK_S_COMPAT) {
		<span class="enscript-comment">/* check-state */</span>
		<span class="enscript-keyword">return</span> 0 ;
	}
	<span class="enscript-comment">/* Must apply to incoming or outgoing (or both) */</span>
	<span class="enscript-keyword">if</span> (!(frwl-&gt;fw_flg &amp; (IP_FW_F_IN_COMPAT | IP_FW_F_OUT_COMPAT))) {
		<span class="enscript-comment">/*
		printf((&quot;%s neither in nor out\n&quot;, err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Empty interface name is no good */</span>
	<span class="enscript-keyword">if</span> (((frwl-&gt;fw_flg &amp; IP_FW_F_IIFNAME_COMPAT)
	      &amp;&amp; !*frwl-&gt;fw_in_if.fu_via_if_compat.name)
	    || ((frwl-&gt;fw_flg &amp; IP_FW_F_OIFNAME_COMPAT)
	      &amp;&amp; !*frwl-&gt;fw_out_if.fu_via_if_compat.name)) {
		<span class="enscript-comment">/*
		printf((&quot;%s empty interface name\n&quot;, err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Sanity check interface matching */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IF_FW_F_VIAHACK_COMPAT) == IF_FW_F_VIAHACK_COMPAT) {
		;		<span class="enscript-comment">/* allow &quot;via&quot; backwards compatibility */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_IN_COMPAT)
	    &amp;&amp; (frwl-&gt;fw_flg &amp; IP_FW_F_OIFACE_COMPAT)) {
		<span class="enscript-comment">/*
		printf((&quot;%s outgoing interface check on incoming\n&quot;,
		    err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Sanity check port ranges */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_SRNG_COMPAT) &amp;&amp; IP_FW_GETNSRCP_COMPAT(frwl) &lt; 2) {
		<span class="enscript-comment">/*
		printf((&quot;%s src range set but n_src_p=%d\n&quot;,
		    err_prefix, IP_FW_GETNSRCP_COMPAT(frwl)));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_DRNG_COMPAT) &amp;&amp; IP_FW_GETNDSTP_COMPAT(frwl) &lt; 2) {
		<span class="enscript-comment">/*
		printf((&quot;%s dst range set but n_dst_p=%d\n&quot;,
		    err_prefix, IP_FW_GETNDSTP_COMPAT(frwl)));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (IP_FW_GETNSRCP_COMPAT(frwl) + IP_FW_GETNDSTP_COMPAT(frwl) &gt; IP_FW_MAX_PORTS_COMPAT) {
		<span class="enscript-comment">/*
		printf((&quot;%s too many ports (%d+%d)\n&quot;,
		    err_prefix, IP_FW_GETNSRCP_COMPAT(frwl), IP_FW_GETNDSTP_COMPAT(frwl)));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/*
	 *	Protocols other than TCP/UDP don't use port range
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_prot != IPPROTO_TCP) &amp;&amp;
	    (frwl-&gt;fw_prot != IPPROTO_UDP) &amp;&amp;
	    (IP_FW_GETNSRCP_COMPAT(frwl) || IP_FW_GETNDSTP_COMPAT(frwl))) {
		<span class="enscript-comment">/*
		printf((&quot;%s port(s) specified for non TCP/UDP rule\n&quot;,
		    err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 *	Rather than modify the entry to make such entries work, 
	 *	we reject this rule and require user level utilities
	 *	to enforce whatever policy they deem appropriate.
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_src.s_addr &amp; (~frwl-&gt;fw_smsk.s_addr)) || 
		(frwl-&gt;fw_dst.s_addr &amp; (~frwl-&gt;fw_dmsk.s_addr))) {
		<span class="enscript-comment">/*
		printf((&quot;%s rule never matches\n&quot;, err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_FRAG_COMPAT) &amp;&amp;
		(frwl-&gt;fw_prot == IPPROTO_UDP || frwl-&gt;fw_prot == IPPROTO_TCP)) {
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_nports) {
		<span class="enscript-comment">/*
			printf((&quot;%s cannot mix 'frag' and ports\n&quot;, err_prefix));
		*/</span>
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_prot == IPPROTO_TCP &amp;&amp;
			frwl-&gt;fw_tcpf != frwl-&gt;fw_tcpnf) {
		<span class="enscript-comment">/*
			printf((&quot;%s cannot mix 'frag' and TCP flags\n&quot;, err_prefix));
		*/</span>
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	}

	<span class="enscript-comment">/* Check command specific stuff */</span>
	<span class="enscript-keyword">switch</span> (frwl-&gt;fw_flg &amp; IP_FW_F_COMMAND_COMPAT)
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_REJECT_COMPAT</span>:
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_reject_code_compat &gt;= 0x100
		    &amp;&amp; !(frwl-&gt;fw_prot == IPPROTO_TCP
		      &amp;&amp; frwl-&gt;fw_reject_code_compat == IP_FW_REJECT_RST_COMPAT)) {
		<span class="enscript-comment">/*
			printf((&quot;%s unknown reject code\n&quot;, err_prefix));
		*/</span>
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DIVERT_COMPAT</span>:		<span class="enscript-comment">/* Diverting to port zero is invalid */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_TEE_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_PIPE_COMPAT</span>:              <span class="enscript-comment">/* piping through 0 is invalid */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_QUEUE_COMPAT</span>:             <span class="enscript-comment">/* piping through 0 is invalid */</span>
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_divert_port_compat == 0) {
		<span class="enscript-comment">/*
			printf((&quot;%s can't divert to port 0\n&quot;, err_prefix));
		*/</span>
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DENY_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_ACCEPT_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_COUNT_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_SKIPTO_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_FWD_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_UID_COMPAT</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		printf((&quot;%s invalid command\n&quot;, err_prefix));
		*/</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_check_vers1_struct_64</span>(<span class="enscript-type">struct</span> ip_fw_compat_64 *frwl)
{
	<span class="enscript-comment">/* Check for invalid flag bits */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; ~IP_FW_F_MASK_COMPAT) != 0) {
		<span class="enscript-comment">/* 
		printf((&quot;%s undefined flag bits set (flags=%x)\n&quot;,
		    err_prefix, frwl-&gt;fw_flg));
		*/</span>
		 
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (frwl-&gt;fw_flg == IP_FW_F_CHECK_S_COMPAT) {
		<span class="enscript-comment">/* check-state */</span>
		<span class="enscript-keyword">return</span> 0 ;
	}
	<span class="enscript-comment">/* Must apply to incoming or outgoing (or both) */</span>
	<span class="enscript-keyword">if</span> (!(frwl-&gt;fw_flg &amp; (IP_FW_F_IN_COMPAT | IP_FW_F_OUT_COMPAT))) {
		<span class="enscript-comment">/*
		printf((&quot;%s neither in nor out\n&quot;, err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Empty interface name is no good */</span>
	<span class="enscript-keyword">if</span> (((frwl-&gt;fw_flg &amp; IP_FW_F_IIFNAME_COMPAT)
	      &amp;&amp; !*frwl-&gt;fw_in_if.fu_via_if_compat.name)
	    || ((frwl-&gt;fw_flg &amp; IP_FW_F_OIFNAME_COMPAT)
	      &amp;&amp; !*frwl-&gt;fw_out_if.fu_via_if_compat.name)) {
		<span class="enscript-comment">/*
		printf((&quot;%s empty interface name\n&quot;, err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Sanity check interface matching */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IF_FW_F_VIAHACK_COMPAT) == IF_FW_F_VIAHACK_COMPAT) {
		;		<span class="enscript-comment">/* allow &quot;via&quot; backwards compatibility */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_IN_COMPAT)
	    &amp;&amp; (frwl-&gt;fw_flg &amp; IP_FW_F_OIFACE_COMPAT)) {
		<span class="enscript-comment">/*
		printf((&quot;%s outgoing interface check on incoming\n&quot;,
		    err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* Sanity check port ranges */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_SRNG_COMPAT) &amp;&amp; IP_FW_GETNSRCP_COMPAT(frwl) &lt; 2) {
		<span class="enscript-comment">/*
		printf((&quot;%s src range set but n_src_p=%d\n&quot;,
		    err_prefix, IP_FW_GETNSRCP_COMPAT(frwl)));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_DRNG_COMPAT) &amp;&amp; IP_FW_GETNDSTP_COMPAT(frwl) &lt; 2) {
		<span class="enscript-comment">/*
		printf((&quot;%s dst range set but n_dst_p=%d\n&quot;,
		    err_prefix, IP_FW_GETNDSTP_COMPAT(frwl)));
		*/</span>

		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (IP_FW_GETNSRCP_COMPAT(frwl) + IP_FW_GETNDSTP_COMPAT(frwl) &gt; IP_FW_MAX_PORTS_COMPAT) {
		<span class="enscript-comment">/*
		printf((&quot;%s too many ports (%d+%d)\n&quot;,
		    err_prefix, IP_FW_GETNSRCP_COMPAT(frwl), IP_FW_GETNDSTP_COMPAT(frwl)));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/*
	 *	Protocols other than TCP/UDP don't use port range
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_prot != IPPROTO_TCP) &amp;&amp;
	    (frwl-&gt;fw_prot != IPPROTO_UDP) &amp;&amp;
	    (IP_FW_GETNSRCP_COMPAT(frwl) || IP_FW_GETNDSTP_COMPAT(frwl))) {
		<span class="enscript-comment">/*
		printf((&quot;%s port(s) specified for non TCP/UDP rule\n&quot;,
		    err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 *	Rather than modify the entry to make such entries work, 
	 *	we reject this rule and require user level utilities
	 *	to enforce whatever policy they deem appropriate.
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_src.s_addr &amp; (~frwl-&gt;fw_smsk.s_addr)) || 
		(frwl-&gt;fw_dst.s_addr &amp; (~frwl-&gt;fw_dmsk.s_addr))) {
		<span class="enscript-comment">/*
		printf((&quot;%s rule never matches\n&quot;, err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IP_FW_F_FRAG_COMPAT) &amp;&amp;
		(frwl-&gt;fw_prot == IPPROTO_UDP || frwl-&gt;fw_prot == IPPROTO_TCP)) {
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_nports) {
		<span class="enscript-comment">/*
			printf((&quot;%s cannot mix 'frag' and ports\n&quot;, err_prefix));
		*/</span>
		
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_prot == IPPROTO_TCP &amp;&amp;
			frwl-&gt;fw_tcpf != frwl-&gt;fw_tcpnf) {
		<span class="enscript-comment">/*
			printf((&quot;%s cannot mix 'frag' and TCP flags\n&quot;, err_prefix));
		*/</span>
		
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	}

	<span class="enscript-comment">/* Check command specific stuff */</span>
	<span class="enscript-keyword">switch</span> (frwl-&gt;fw_flg &amp; IP_FW_F_COMMAND_COMPAT)
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_REJECT_COMPAT</span>:
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_reject_code_compat &gt;= 0x100
		    &amp;&amp; !(frwl-&gt;fw_prot == IPPROTO_TCP
		      &amp;&amp; frwl-&gt;fw_reject_code_compat == IP_FW_REJECT_RST_COMPAT)) {
		<span class="enscript-comment">/*
			printf((&quot;%s unknown reject code\n&quot;, err_prefix));
		*/</span>
		
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DIVERT_COMPAT</span>:		<span class="enscript-comment">/* Diverting to port zero is invalid */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_TEE_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_PIPE_COMPAT</span>:              <span class="enscript-comment">/* piping through 0 is invalid */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_QUEUE_COMPAT</span>:             <span class="enscript-comment">/* piping through 0 is invalid */</span>
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_divert_port_compat == 0) {
		<span class="enscript-comment">/*
			printf((&quot;%s can't divert to port 0\n&quot;, err_prefix));
		*/</span>
		
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DENY_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_ACCEPT_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_COUNT_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_SKIPTO_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_FWD_COMPAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_UID_COMPAT</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		printf((&quot;%s invalid command\n&quot;, err_prefix));
		*/</span>
		
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_convert_to_cmds_32</span>(<span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_32 *compat_rule)
{
	<span class="enscript-type">int</span>			k;	
	uint32_t	actbuf[255], cmdbuf[255];
	ipfw_insn	*action, *cmd, *src, *dst;
	ipfw_insn	*have_state = NULL;	<span class="enscript-comment">/* track check-state or keep-state */</span>
	
	<span class="enscript-keyword">if</span> (!compat_rule || !curr_rule) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* preemptively check the old ip_fw rule to
	 * make sure it's valid before starting to copy stuff
	 */</span>
	<span class="enscript-keyword">if</span> (ipfw_check_vers1_struct_32(compat_rule)) {
		<span class="enscript-comment">/* bad rule */</span>
		<span class="enscript-keyword">return</span>;
	}
	
	bzero(actbuf, <span class="enscript-keyword">sizeof</span>(actbuf));		<span class="enscript-comment">/* actions go here */</span>
	bzero(cmdbuf, <span class="enscript-keyword">sizeof</span>(cmdbuf));

	<span class="enscript-comment">/* fill in action */</span>
	action = (ipfw_insn *)actbuf;
	{
	u_int	flag = compat_rule-&gt;fw_flg;
	
	action-&gt;len = 1;	<span class="enscript-comment">/* default */</span>
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_CHECK_S_COMPAT) {
		have_state = action;
		action-&gt;opcode = O_CHECK_STATE;
	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (flag &amp; IP_FW_F_COMMAND_COMPAT) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_ACCEPT_COMPAT</span>:
				action-&gt;opcode = O_ACCEPT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_COUNT_COMPAT</span>:
				action-&gt;opcode = O_COUNT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_PIPE_COMPAT</span>:
				action-&gt;opcode = O_PIPE;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_QUEUE_COMPAT</span>:
				action-&gt;opcode = O_QUEUE;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_SKIPTO_COMPAT</span>:
				action-&gt;opcode = O_SKIPTO;
				action-&gt;arg1 = compat_rule-&gt;fw_skipto_rule_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DIVERT_COMPAT</span>:
				action-&gt;opcode = O_DIVERT;
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_TEE_COMPAT</span>:
				action-&gt;opcode = O_TEE;
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_FWD_COMPAT</span>:
			{
				ipfw_insn_sa *p = (ipfw_insn_sa *)action;
				
				action-&gt;opcode = O_FORWARD_IP;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_sa);
				
				p-&gt;sa.sin_len = compat_rule-&gt;fw_fwd_ip_compat.sin_len;
				p-&gt;sa.sin_family = compat_rule-&gt;fw_fwd_ip_compat.sin_family;
				p-&gt;sa.sin_port = compat_rule-&gt;fw_fwd_ip_compat.sin_port;
				p-&gt;sa.sin_addr = compat_rule-&gt;fw_fwd_ip_compat.sin_addr;
				
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DENY_COMPAT</span>:
				action-&gt;opcode = O_DENY;
				action-&gt;arg1 = 0;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_REJECT_COMPAT</span>:
				action-&gt;opcode = O_REJECT;
				action-&gt;arg1 = compat_rule-&gt;fw_reject_code_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				action-&gt;opcode = O_NOP;
				<span class="enscript-keyword">break</span>;
		}
	}
	
	<span class="enscript-comment">/* action is mandatory */</span>
	<span class="enscript-keyword">if</span> (action-&gt;opcode == O_NOP) {
			<span class="enscript-keyword">return</span>;
	}
	
	action = next_cmd(action);
	} <span class="enscript-comment">/* end actions */</span>
	
	cmd = (ipfw_insn *)cmdbuf;

	<span class="enscript-comment">/* this is O_CHECK_STATE, we're done */</span>
	<span class="enscript-keyword">if</span> (have_state) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	{
	ipfw_insn		*prev = NULL;
	u_int			flag = compat_rule-&gt;fw_flg;
	
	<span class="enscript-comment">/* logging */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_PRN_COMPAT) {
		ipfw_insn_log *c = (ipfw_insn_log *)cmd;
		
		cmd-&gt;opcode = O_LOG;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_log);
		c-&gt;max_log = compat_rule-&gt;fw_logamount;

		prev = cmd;
		cmd = next_cmd(cmd);
	}

	<span class="enscript-comment">/* protocol */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_prot != 0) {
		fill_cmd(cmd, O_PROTO, compat_rule-&gt;fw_prot);
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* source */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_SME_COMPAT) {
		cmd-&gt;opcode = O_IP_SRC_ME;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn);
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVSRC_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_smsk.s_addr != 0) {
			<span class="enscript-comment">/* addr/mask */</span>
			ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
			
			ip-&gt;addr = compat_rule-&gt;fw_src;
			ip-&gt;mask = compat_rule-&gt;fw_smsk;
			cmd-&gt;opcode = O_IP_SRC_MASK;
			cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_ip); <span class="enscript-comment">/* double check this */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* one IP */</span>
			ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
			<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_src.s_addr == 0) {
				<span class="enscript-comment">/* any */</span>
				cmd32-&gt;o.len &amp;= ~F_LEN_MASK;	<span class="enscript-comment">/* zero len */</span>
			} <span class="enscript-keyword">else</span> {
				cmd32-&gt;d[0] = compat_rule-&gt;fw_src.s_addr;
				cmd32-&gt;o.opcode = O_IP_SRC;
				cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
			}
		}
		
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVSRC_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		<span class="enscript-keyword">if</span> (F_LEN(cmd) != 0) { <span class="enscript-comment">/* !any */</span>
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* source ports */</span>
	{
		ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
		uint16_t		*p = ports-&gt;ports;
		<span class="enscript-type">int</span>				i, j = 0, 
						nports = IP_FW_GETNSRCP_COMPAT(compat_rule),
						have_range = 0;
		
		cmd-&gt;opcode = O_IP_SRCPORT;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; nports; i++) {
			<span class="enscript-keyword">if</span> (((flag &amp; IP_FW_F_SRNG_COMPAT) ||
				(flag &amp; IP_FW_F_SMSK_COMPAT)) &amp;&amp; !have_range) {
				p[0] = compat_rule-&gt;fw_uar_compat.fw_pts[i++];
				p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
				have_range = 1;
			} <span class="enscript-keyword">else</span> {
				p[0] = p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
			}
			p += 2;
			j++;
		}
		
		<span class="enscript-keyword">if</span> (j &gt; 0) {
			ports-&gt;o.len |= j+1; <span class="enscript-comment">/* leave F_NOT and F_OR untouched */</span>
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* destination */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_DME_COMPAT) {
		cmd-&gt;opcode = O_IP_DST_ME;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn);
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVDST_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_dmsk.s_addr != 0) {
			<span class="enscript-comment">/* addr/mask */</span>
			ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
			
			ip-&gt;addr = compat_rule-&gt;fw_dst;
			ip-&gt;mask = compat_rule-&gt;fw_dmsk;
			cmd-&gt;opcode = O_IP_DST_MASK;
			cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_ip); <span class="enscript-comment">/* double check this */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* one IP */</span>
			ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
			<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_dst.s_addr == 0) {
				<span class="enscript-comment">/* any */</span>
				cmd32-&gt;o.len &amp;= ~F_LEN_MASK;	<span class="enscript-comment">/* zero len */</span>
			} <span class="enscript-keyword">else</span> {
				cmd32-&gt;d[0] = compat_rule-&gt;fw_dst.s_addr;
				cmd32-&gt;o.opcode = O_IP_DST;
				cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
			}
		}
		
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVDST_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		<span class="enscript-keyword">if</span> (F_LEN(cmd) != 0) { <span class="enscript-comment">/* !any */</span>
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* dest. ports */</span>
	{
		ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
		uint16_t		*p = ports-&gt;ports;
		<span class="enscript-type">int</span>				i = IP_FW_GETNSRCP_COMPAT(compat_rule), 
						j = 0, 
						nports = (IP_FW_GETNDSTP_COMPAT(compat_rule) + i),
						have_range = 0;
		
		cmd-&gt;opcode = O_IP_DSTPORT;
		<span class="enscript-keyword">for</span> (; i &lt; nports; i++, p += 2) {
			<span class="enscript-keyword">if</span> (((flag &amp; IP_FW_F_DRNG_COMPAT) ||
				(flag &amp; IP_FW_F_DMSK_COMPAT)) &amp;&amp; !have_range) {
				<span class="enscript-comment">/* range */</span>
				p[0] = compat_rule-&gt;fw_uar_compat.fw_pts[i++];
				p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
				have_range = 1;
			} <span class="enscript-keyword">else</span> {
				p[0] = p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
			}
			j++;
		}
		
		<span class="enscript-keyword">if</span> (j &gt; 0) {
			ports-&gt;o.len |= j+1; <span class="enscript-comment">/* leave F_NOT and F_OR untouched */</span>
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_UID_COMPAT) {
		ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
		cmd32-&gt;o.opcode = O_UID;
		cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
		cmd32-&gt;d[0] = compat_rule-&gt;fw_uid;

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_KEEP_S_COMPAT) {
		have_state = cmd;
		fill_cmd(cmd, O_KEEP_STATE, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_BRIDGED_COMPAT) {
		fill_cmd(cmd, O_LAYER2, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> ((flag &amp; IF_FW_F_VIAHACK_COMPAT) == IF_FW_F_VIAHACK_COMPAT) {
		<span class="enscript-comment">/* via */</span>
		ipfw_insn_if			*ifcmd = (ipfw_insn_if *)cmd;
		<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_in_if;
		
		cmd-&gt;opcode = O_VIA;
		ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
		
		<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
			<span class="enscript-comment">/* &quot;any&quot; */</span>
			ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
			ifcmd-&gt;o.len = 0;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compat_rule-&gt;fw_flg &amp; IP_FW_F_IIFNAME_COMPAT) {
			<span class="enscript-comment">/* by name */</span>
			strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
			ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* by addr */</span>
			ifcmd-&gt;p.ip = ifu.fu_via_ip;
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IN_COMPAT) {
			fill_cmd(cmd, O_IN, 0);
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OUT_COMPAT) {
			<span class="enscript-comment">/* if the previous command was O_IN, and this
			 * is being set as well, it's equivalent to not
			 * having either command, so let's back up prev 
			 * to the cmd before it and move cmd to prev.
			 */</span>
			<span class="enscript-keyword">if</span> (prev-&gt;opcode == O_IN) {
				cmd = prev;
				bzero(cmd, <span class="enscript-keyword">sizeof</span>(*cmd));
			} <span class="enscript-keyword">else</span> {
				cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>
				fill_cmd(cmd, O_IN, 0);
		
				prev = cmd;
				cmd = next_cmd(cmd);
			}
		}
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OIFACE_COMPAT) {
			<span class="enscript-comment">/* xmit */</span>
			ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
			<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_out_if;
			
			cmd-&gt;opcode = O_XMIT;
			ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
	
			<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
				<span class="enscript-comment">/* &quot;any&quot; */</span>
				ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
				ifcmd-&gt;o.len = 0;
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OIFNAME_COMPAT) {
				<span class="enscript-comment">/* by name */</span>
				strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
				ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* by addr */</span>
				ifcmd-&gt;p.ip = ifu.fu_via_ip;
			}
	
			prev = cmd;
			cmd = next_cmd(cmd);
		} 
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IIFACE_COMPAT) {
			<span class="enscript-comment">/* recv */</span>
			ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
			<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_in_if;
			
			cmd-&gt;opcode = O_RECV;
			ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
	
			<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
				<span class="enscript-comment">/* &quot;any&quot; */</span>
				ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
				ifcmd-&gt;o.len = 0;
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IIFNAME_COMPAT) {
				<span class="enscript-comment">/* by name */</span>
				strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
				ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* by addr */</span>
				ifcmd-&gt;p.ip = ifu.fu_via_ip;
			}
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_FRAG_COMPAT) {
		fill_cmd(cmd, O_FRAG, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* IP options */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_ipopt != 0 || compat_rule-&gt;fw_ipnopt != 0) {
		fill_cmd(cmd, O_IPOPT, (compat_rule-&gt;fw_ipopt &amp; 0xff) |
								(compat_rule-&gt;fw_ipnopt &amp; 0xff) &lt;&lt; 8);
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_prot == IPPROTO_TCP) {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_ipflg &amp; IP_FW_IF_TCPEST_COMPAT) {
			fill_cmd(cmd, O_ESTAB, 0);
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	
		<span class="enscript-comment">/* TCP options and flags */</span>
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_tcpf != 0 || compat_rule-&gt;fw_tcpnf != 0) {
			<span class="enscript-keyword">if</span> ((compat_rule-&gt;fw_tcpf &amp; IP_FW_TCPF_SYN_COMPAT) &amp;&amp;
				compat_rule-&gt;fw_tcpnf &amp; IP_FW_TCPF_ACK_COMPAT) {
				fill_cmd(cmd, O_TCPFLAGS, (TH_SYN) | ( (TH_ACK) &amp; 0xff) &lt;&lt;8);
				
				prev = cmd;
				cmd = next_cmd(cmd);
			}
			<span class="enscript-keyword">else</span> {
				fill_cmd(cmd, O_TCPFLAGS, (compat_rule-&gt;fw_tcpf &amp; 0xff) |
											(compat_rule-&gt;fw_tcpnf &amp; 0xff) &lt;&lt; 8);
				
				prev = cmd;
				cmd = next_cmd(cmd);
			}
		}
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_tcpopt != 0 || compat_rule-&gt;fw_tcpnopt != 0) {
			fill_cmd(cmd, O_TCPOPTS, (compat_rule-&gt;fw_tcpopt &amp; 0xff) |
										(compat_rule-&gt;fw_tcpnopt &amp; 0xff) &lt;&lt; 8);
			
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* ICMP */</span>
	<span class="enscript-comment">/* XXX: check this */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_ICMPBIT_COMPAT) {
		<span class="enscript-type">int</span>	i;
		ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
		
		cmd32-&gt;o.opcode = O_ICMPTYPE;
		cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
		
		<span class="enscript-keyword">for</span> (i = 0; i &lt; IP_FW_ICMPTYPES_DIM_COMPAT; i++) {
			cmd32-&gt;d[0] |= compat_rule-&gt;fw_uar_compat.fw_icmptypes[i];
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	} <span class="enscript-comment">/* end commands */</span>
	
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* finally, copy everything into the current 
	 * rule buffer in the right order.
	 */</span>
	dst = curr_rule-&gt;cmd;
	
	<span class="enscript-comment">/* first, do match probability */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_flg &amp; IP_FW_F_RND_MATCH_COMPAT) {
		dst-&gt;opcode = O_PROB;
		dst-&gt;len = 2;
		*((int32_t *)(dst+1)) = compat_rule-&gt;pipe_ptr;
		dst += dst-&gt;len;
	}
	
	<span class="enscript-comment">/* generate O_PROBE_STATE if necessary */</span>
	<span class="enscript-keyword">if</span> (have_state &amp;&amp; have_state-&gt;opcode != O_CHECK_STATE) {
		fill_cmd(dst, O_PROBE_STATE, 0);
		dst = next_cmd(dst);
	}
	
	<span class="enscript-comment">/*
	 * copy all commands but O_LOG, O_KEEP_STATE
	 */</span>
	<span class="enscript-keyword">for</span> (src = (ipfw_insn *)cmdbuf; src != cmd; src += k) {
		k = F_LEN(src);

		<span class="enscript-keyword">switch</span> (src-&gt;opcode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
			dst += k;
		}
	}

	<span class="enscript-comment">/*
	 * put back the have_state command as last opcode
	 */</span>
	<span class="enscript-keyword">if</span> (have_state &amp;&amp; have_state-&gt;opcode != O_CHECK_STATE) {
		k = F_LEN(have_state);
		bcopy(have_state, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}
	
	<span class="enscript-comment">/*
	 * start action section
	 */</span>
	curr_rule-&gt;act_ofs = dst - curr_rule-&gt;cmd;

	<span class="enscript-comment">/*
	 * put back O_LOG if necessary
	 */</span>
	src = (ipfw_insn *)cmdbuf;
	<span class="enscript-keyword">if</span> (src-&gt;opcode == O_LOG) {
		k = F_LEN(src);
		bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}
	
	<span class="enscript-comment">/*
	 * copy all other actions
	 */</span>
	<span class="enscript-keyword">for</span> (src = (ipfw_insn *)actbuf; src != action; src += k) {
		k = F_LEN(src);
		bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}

	curr_rule-&gt;cmd_len = (uint32_t *)dst - (uint32_t *)(curr_rule-&gt;cmd);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_convert_to_cmds_64</span>(<span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_64 *compat_rule)
{
	<span class="enscript-type">int</span>			k;	
	uint32_t	actbuf[255], cmdbuf[255];
	ipfw_insn	*action, *cmd, *src, *dst;
	ipfw_insn	*have_state = NULL;	<span class="enscript-comment">/* track check-state or keep-state */</span>
	
	<span class="enscript-keyword">if</span> (!compat_rule || !curr_rule) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* preemptively check the old ip_fw rule to
	 * make sure it's valid before starting to copy stuff
	 */</span>
	<span class="enscript-keyword">if</span> (ipfw_check_vers1_struct_64(compat_rule)) {
		<span class="enscript-comment">/* bad rule */</span>
		<span class="enscript-keyword">return</span>;
	}
	
	bzero(actbuf, <span class="enscript-keyword">sizeof</span>(actbuf));		<span class="enscript-comment">/* actions go here */</span>
	bzero(cmdbuf, <span class="enscript-keyword">sizeof</span>(cmdbuf));
	<span class="enscript-comment">/* fill in action */</span>
	action = (ipfw_insn *)actbuf;
	{
	u_int	flag = compat_rule-&gt;fw_flg;
	
	action-&gt;len = 1;	<span class="enscript-comment">/* default */</span>
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_CHECK_S_COMPAT) {
		have_state = action;
		action-&gt;opcode = O_CHECK_STATE;
	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (flag &amp; IP_FW_F_COMMAND_COMPAT) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_ACCEPT_COMPAT</span>:
				action-&gt;opcode = O_ACCEPT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_COUNT_COMPAT</span>:
				action-&gt;opcode = O_COUNT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_PIPE_COMPAT</span>:
				action-&gt;opcode = O_PIPE;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_QUEUE_COMPAT</span>:
				action-&gt;opcode = O_QUEUE;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_SKIPTO_COMPAT</span>:
				action-&gt;opcode = O_SKIPTO;
				action-&gt;arg1 = compat_rule-&gt;fw_skipto_rule_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DIVERT_COMPAT</span>:
				action-&gt;opcode = O_DIVERT;
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_TEE_COMPAT</span>:
				action-&gt;opcode = O_TEE;
				action-&gt;arg1 = compat_rule-&gt;fw_divert_port_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_FWD_COMPAT</span>:
			{
				ipfw_insn_sa *p = (ipfw_insn_sa *)action;
				
				action-&gt;opcode = O_FORWARD_IP;
				action-&gt;len = F_INSN_SIZE(ipfw_insn_sa);
				
				p-&gt;sa.sin_len = compat_rule-&gt;fw_fwd_ip_compat.sin_len;
				p-&gt;sa.sin_family = compat_rule-&gt;fw_fwd_ip_compat.sin_family;
				p-&gt;sa.sin_port = compat_rule-&gt;fw_fwd_ip_compat.sin_port;
				p-&gt;sa.sin_addr = compat_rule-&gt;fw_fwd_ip_compat.sin_addr;
				
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_DENY_COMPAT</span>:
				action-&gt;opcode = O_DENY;
				action-&gt;arg1 = 0;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_F_REJECT_COMPAT</span>:
				action-&gt;opcode = O_REJECT;
				action-&gt;arg1 = compat_rule-&gt;fw_reject_code_compat;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				action-&gt;opcode = O_NOP;
				<span class="enscript-keyword">break</span>;
		}
	}
	
	<span class="enscript-comment">/* action is mandatory */</span>
	<span class="enscript-keyword">if</span> (action-&gt;opcode == O_NOP) {
			<span class="enscript-keyword">return</span>;
	}
	
	action = next_cmd(action);
	} <span class="enscript-comment">/* end actions */</span>
	
	cmd = (ipfw_insn *)cmdbuf;

	<span class="enscript-comment">/* this is O_CHECK_STATE, we're done */</span>
	<span class="enscript-keyword">if</span> (have_state) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	{
	ipfw_insn		*prev = NULL;
	u_int			flag = compat_rule-&gt;fw_flg;
	
	<span class="enscript-comment">/* logging */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_PRN_COMPAT) {
		ipfw_insn_log *c = (ipfw_insn_log *)cmd;
		
		cmd-&gt;opcode = O_LOG;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_log);
		c-&gt;max_log = compat_rule-&gt;fw_logamount;

		prev = cmd;
		cmd = next_cmd(cmd);
	}

	<span class="enscript-comment">/* protocol */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_prot != 0) {
		fill_cmd(cmd, O_PROTO, compat_rule-&gt;fw_prot);
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* source */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_SME_COMPAT) {
		cmd-&gt;opcode = O_IP_SRC_ME;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn);
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVSRC_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_smsk.s_addr != 0) {
			<span class="enscript-comment">/* addr/mask */</span>
			ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
			
			ip-&gt;addr = compat_rule-&gt;fw_src;
			ip-&gt;mask = compat_rule-&gt;fw_smsk;
			cmd-&gt;opcode = O_IP_SRC_MASK;
			cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_ip); <span class="enscript-comment">/* double check this */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* one IP */</span>
			ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
			<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_src.s_addr == 0) {
				<span class="enscript-comment">/* any */</span>
				cmd32-&gt;o.len &amp;= ~F_LEN_MASK;	<span class="enscript-comment">/* zero len */</span>
			} <span class="enscript-keyword">else</span> {
				cmd32-&gt;d[0] = compat_rule-&gt;fw_src.s_addr;
				cmd32-&gt;o.opcode = O_IP_SRC;
				cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
			}
		}
		
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVSRC_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		<span class="enscript-keyword">if</span> (F_LEN(cmd) != 0) { <span class="enscript-comment">/* !any */</span>
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* source ports */</span>
	{
		ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
		uint16_t		*p = ports-&gt;ports;
		<span class="enscript-type">int</span>				i, j = 0, 
						nports = IP_FW_GETNSRCP_COMPAT(compat_rule),
						have_range = 0;
		
		cmd-&gt;opcode = O_IP_SRCPORT;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; nports; i++) {
			<span class="enscript-keyword">if</span> (((flag &amp; IP_FW_F_SRNG_COMPAT) ||
				(flag &amp; IP_FW_F_SMSK_COMPAT)) &amp;&amp; !have_range) {
				p[0] = compat_rule-&gt;fw_uar_compat.fw_pts[i++];
				p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
				have_range = 1;
			} <span class="enscript-keyword">else</span> {
				p[0] = p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
			}
			p += 2;
			j++;
		}
		
		<span class="enscript-keyword">if</span> (j &gt; 0) {
			ports-&gt;o.len |= j+1; <span class="enscript-comment">/* leave F_NOT and F_OR untouched */</span>
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* destination */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_DME_COMPAT) {
		cmd-&gt;opcode = O_IP_DST_ME;
		cmd-&gt;len |= F_INSN_SIZE(ipfw_insn);
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVDST_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_dmsk.s_addr != 0) {
			<span class="enscript-comment">/* addr/mask */</span>
			ipfw_insn_ip	*ip = (ipfw_insn_ip *)cmd;
			
			ip-&gt;addr = compat_rule-&gt;fw_dst;
			ip-&gt;mask = compat_rule-&gt;fw_dmsk;
			cmd-&gt;opcode = O_IP_DST_MASK;
			cmd-&gt;len |= F_INSN_SIZE(ipfw_insn_ip); <span class="enscript-comment">/* double check this */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* one IP */</span>
			ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
			<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_dst.s_addr == 0) {
				<span class="enscript-comment">/* any */</span>
				cmd32-&gt;o.len &amp;= ~F_LEN_MASK;	<span class="enscript-comment">/* zero len */</span>
			} <span class="enscript-keyword">else</span> {
				cmd32-&gt;d[0] = compat_rule-&gt;fw_dst.s_addr;
				cmd32-&gt;o.opcode = O_IP_DST;
				cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
			}
		}
		
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_INVDST_COMPAT) {
			cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>			
		}

		<span class="enscript-keyword">if</span> (F_LEN(cmd) != 0) { <span class="enscript-comment">/* !any */</span>
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* dest. ports */</span>
	{
		ipfw_insn_u16	*ports = (ipfw_insn_u16 *)cmd;
		uint16_t		*p = ports-&gt;ports;
		<span class="enscript-type">int</span>				i = IP_FW_GETNSRCP_COMPAT(compat_rule), 
						j = 0, 
						nports = (IP_FW_GETNDSTP_COMPAT(compat_rule) + i),
						have_range = 0;
		
		cmd-&gt;opcode = O_IP_DSTPORT;
		<span class="enscript-keyword">for</span> (; i &lt; nports; i++, p += 2) {
			<span class="enscript-keyword">if</span> (((flag &amp; IP_FW_F_DRNG_COMPAT) ||
				(flag &amp; IP_FW_F_DMSK_COMPAT)) &amp;&amp; !have_range) {
				<span class="enscript-comment">/* range */</span>
				p[0] = compat_rule-&gt;fw_uar_compat.fw_pts[i++];
				p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
				have_range = 1;
			} <span class="enscript-keyword">else</span> {
				p[0] = p[1] = compat_rule-&gt;fw_uar_compat.fw_pts[i];
			}
			j++;
		}
		
		<span class="enscript-keyword">if</span> (j &gt; 0) {
			ports-&gt;o.len |= j+1; <span class="enscript-comment">/* leave F_NOT and F_OR untouched */</span>
		}
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_UID_COMPAT) {
		ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
			
		cmd32-&gt;o.opcode = O_UID;
		cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
		cmd32-&gt;d[0] = compat_rule-&gt;fw_uid;

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_KEEP_S_COMPAT) {
		have_state = cmd;
		fill_cmd(cmd, O_KEEP_STATE, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_BRIDGED_COMPAT) {
		fill_cmd(cmd, O_LAYER2, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> ((flag &amp; IF_FW_F_VIAHACK_COMPAT) == IF_FW_F_VIAHACK_COMPAT) {
		<span class="enscript-comment">/* via */</span>
		ipfw_insn_if			*ifcmd = (ipfw_insn_if *)cmd;
		<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_in_if;
		
		cmd-&gt;opcode = O_VIA;
		ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
		
		<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
			<span class="enscript-comment">/* &quot;any&quot; */</span>
			ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
			ifcmd-&gt;o.len = 0;
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compat_rule-&gt;fw_flg &amp; IP_FW_F_IIFNAME_COMPAT) {
			<span class="enscript-comment">/* by name */</span>
			strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
			ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* by addr */</span>
			ifcmd-&gt;p.ip = ifu.fu_via_ip;
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IN_COMPAT) {
			fill_cmd(cmd, O_IN, 0);
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OUT_COMPAT) {
			<span class="enscript-comment">/* if the previous command was O_IN, and this
			 * is being set as well, it's equivalent to not
			 * having either command, so let's back up prev 
			 * to the cmd before it and move cmd to prev.
			 */</span>
			<span class="enscript-keyword">if</span> (prev-&gt;opcode == O_IN) {
				cmd = prev;
				bzero(cmd, <span class="enscript-keyword">sizeof</span>(*cmd));
			} <span class="enscript-keyword">else</span> {
				cmd-&gt;len ^= F_NOT; <span class="enscript-comment">/* toggle F_NOT */</span>
				fill_cmd(cmd, O_IN, 0);
		
				prev = cmd;
				cmd = next_cmd(cmd);
			}
		}
		<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OIFACE_COMPAT) {
			<span class="enscript-comment">/* xmit */</span>
			ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
			<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_out_if;
			
			cmd-&gt;opcode = O_XMIT;
			ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
	
			<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
				<span class="enscript-comment">/* &quot;any&quot; */</span>
				ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
				ifcmd-&gt;o.len = 0;
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_OIFNAME_COMPAT) {
				<span class="enscript-comment">/* by name */</span>
				strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
				ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* by addr */</span>
				ifcmd-&gt;p.ip = ifu.fu_via_ip;
			}
	
			prev = cmd;
			cmd = next_cmd(cmd);
		} 
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IIFACE_COMPAT) {
			<span class="enscript-comment">/* recv */</span>
			ipfw_insn_if	*ifcmd = (ipfw_insn_if *)cmd;
			<span class="enscript-type">union</span> ip_fw_if_compat	ifu = compat_rule-&gt;fw_in_if;
			
			cmd-&gt;opcode = O_RECV;
			ifcmd-&gt;o.len |= F_INSN_SIZE(ipfw_insn_if);
	
			<span class="enscript-keyword">if</span> (ifu.fu_via_ip.s_addr == 0) {
				<span class="enscript-comment">/* &quot;any&quot; */</span>
				ifcmd-&gt;name[0] = <span class="enscript-string">'\0'</span>;
				ifcmd-&gt;o.len = 0;
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_IIFNAME_COMPAT) {
				<span class="enscript-comment">/* by name */</span>
				strncpy(ifcmd-&gt;name, ifu.fu_via_if_compat.name, <span class="enscript-keyword">sizeof</span>(ifcmd-&gt;name));
				ifcmd-&gt;p.unit = ifu.fu_via_if_compat.unit;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* by addr */</span>
				ifcmd-&gt;p.ip = ifu.fu_via_ip;
			}
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_FRAG_COMPAT) {
		fill_cmd(cmd, O_FRAG, 0);

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-comment">/* IP options */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_ipopt != 0 || compat_rule-&gt;fw_ipnopt != 0) {
		fill_cmd(cmd, O_IPOPT, (compat_rule-&gt;fw_ipopt &amp; 0xff) |
								(compat_rule-&gt;fw_ipnopt &amp; 0xff) &lt;&lt; 8);
		
		prev = cmd;
		cmd = next_cmd(cmd);
	}
	
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_prot == IPPROTO_TCP) {
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_ipflg &amp; IP_FW_IF_TCPEST_COMPAT) {
			fill_cmd(cmd, O_ESTAB, 0);
	
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	
		<span class="enscript-comment">/* TCP options and flags */</span>
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_tcpf != 0 || compat_rule-&gt;fw_tcpnf != 0) {
			<span class="enscript-keyword">if</span> ((compat_rule-&gt;fw_tcpf &amp; IP_FW_TCPF_SYN_COMPAT) &amp;&amp;
				compat_rule-&gt;fw_tcpnf &amp; IP_FW_TCPF_ACK_COMPAT) {
				fill_cmd(cmd, O_TCPFLAGS, (TH_SYN) | ( (TH_ACK) &amp; 0xff) &lt;&lt;8);
				
				prev = cmd;
				cmd = next_cmd(cmd);
			}
			<span class="enscript-keyword">else</span> {
				fill_cmd(cmd, O_TCPFLAGS, (compat_rule-&gt;fw_tcpf &amp; 0xff) |
											(compat_rule-&gt;fw_tcpnf &amp; 0xff) &lt;&lt; 8);
				
				prev = cmd;
				cmd = next_cmd(cmd);
			}
		}
		<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_tcpopt != 0 || compat_rule-&gt;fw_tcpnopt != 0) {
			fill_cmd(cmd, O_TCPOPTS, (compat_rule-&gt;fw_tcpopt &amp; 0xff) |
										(compat_rule-&gt;fw_tcpnopt &amp; 0xff) &lt;&lt; 8);
			
			prev = cmd;
			cmd = next_cmd(cmd);
		}
	}
	
	<span class="enscript-comment">/* ICMP */</span>
	<span class="enscript-comment">/* XXX: check this */</span>
	<span class="enscript-keyword">if</span> (flag &amp; IP_FW_F_ICMPBIT_COMPAT) {
		<span class="enscript-type">int</span>	i;
		ipfw_insn_u32	*cmd32 = (ipfw_insn_u32 *)cmd;	<span class="enscript-comment">/* alias for cmd */</span>
		cmd32-&gt;o.opcode = O_ICMPTYPE;
		cmd32-&gt;o.len |= F_INSN_SIZE(ipfw_insn_u32);
		
		<span class="enscript-keyword">for</span> (i = 0; i &lt; IP_FW_ICMPTYPES_DIM_COMPAT; i++) {
			cmd32-&gt;d[0] |= compat_rule-&gt;fw_uar_compat.fw_icmptypes[i];
		}

		prev = cmd;
		cmd = next_cmd(cmd);
	}
	} <span class="enscript-comment">/* end commands */</span>
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* finally, copy everything into the current 
	 * rule buffer in the right order.
	 */</span>
	dst = curr_rule-&gt;cmd;
	
	<span class="enscript-comment">/* first, do match probability */</span>
	<span class="enscript-keyword">if</span> (compat_rule-&gt;fw_flg &amp; IP_FW_F_RND_MATCH_COMPAT) {
		dst-&gt;opcode = O_PROB;
		dst-&gt;len = 2;
		*((int32_t *)(dst+1)) = compat_rule-&gt;pipe_ptr;
		dst += dst-&gt;len;
	}
	
	<span class="enscript-comment">/* generate O_PROBE_STATE if necessary */</span>
	<span class="enscript-keyword">if</span> (have_state &amp;&amp; have_state-&gt;opcode != O_CHECK_STATE) {
		fill_cmd(dst, O_PROBE_STATE, 0);
		dst = next_cmd(dst);
	}
	
	<span class="enscript-comment">/*
	 * copy all commands but O_LOG, O_KEEP_STATE
	 */</span>
	<span class="enscript-keyword">for</span> (src = (ipfw_insn *)cmdbuf; src != cmd; src += k) {
		k = F_LEN(src);
		<span class="enscript-keyword">switch</span> (src-&gt;opcode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
			dst += k;
		}
	}

	<span class="enscript-comment">/*
	 * put back the have_state command as last opcode
	 */</span>
	<span class="enscript-keyword">if</span> (have_state &amp;&amp; have_state-&gt;opcode != O_CHECK_STATE) {
		k = F_LEN(have_state);
		bcopy(have_state, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}
	
	<span class="enscript-comment">/*
	 * start action section
	 */</span>
	curr_rule-&gt;act_ofs = dst - curr_rule-&gt;cmd;

	<span class="enscript-comment">/*
	 * put back O_LOG if necessary
	 */</span>
	src = (ipfw_insn *)cmdbuf;
	<span class="enscript-keyword">if</span> (src-&gt;opcode == O_LOG) {
		k = F_LEN(src);
		bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}
	
	<span class="enscript-comment">/*
	 * copy all other actions
	 */</span>
	<span class="enscript-keyword">for</span> (src = (ipfw_insn *)actbuf; src != action; src += k) {
		k = F_LEN(src);
		bcopy(src, dst, k * <span class="enscript-keyword">sizeof</span>(uint32_t));
		dst += k;
	}

	curr_rule-&gt;cmd_len = (uint32_t *)dst - (uint32_t *)(curr_rule-&gt;cmd);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_version_one_to_version_two_32</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *curr_rule, 
								<span class="enscript-type">struct</span> ip_fw_compat_32 *rule_vers1)
{
	<span class="enscript-type">int</span>	err = EINVAL;
	<span class="enscript-type">struct</span> ip_fw_compat_32	*rule_ptr;
	<span class="enscript-type">struct</span> ip_fw_compat_32	rule;
	
	<span class="enscript-keyword">if</span> (rule_vers1) {
		rule_ptr = rule_vers1;
		err = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* do some basic size checking here, more extensive checking later */</span>
		<span class="enscript-keyword">if</span> (!sopt-&gt;sopt_val || sopt-&gt;sopt_valsize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_32))
			<span class="enscript-keyword">return</span> err;
	
		<span class="enscript-keyword">if</span> ((err = sooptcopyin(sopt, &amp;rule, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_32), 
							<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_32)))) {
			<span class="enscript-keyword">return</span> err;
		}
		
		rule_ptr = &amp;rule;
	}

	<span class="enscript-comment">/* deal with commands */</span>
	ipfw_convert_to_cmds_32(curr_rule, rule_ptr);

	curr_rule-&gt;version = IP_FW_CURRENT_API_VERSION;
	curr_rule-&gt;context = CAST_DOWN_EXPLICIT(<span class="enscript-type">void</span>*, rule_ptr-&gt;context);
	curr_rule-&gt;rulenum = rule_ptr-&gt;fw_number;
	curr_rule-&gt;pcnt = rule_ptr-&gt;fw_pcnt;
	curr_rule-&gt;bcnt = rule_ptr-&gt;fw_bcnt;
	curr_rule-&gt;timestamp = rule_ptr-&gt;timestamp;

	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>
	ipfw_print_vers2_struct(curr_rule);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_version_one_to_version_two_64</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *curr_rule, 
								<span class="enscript-type">struct</span> ip_fw_compat_64 *rule_vers1)
{
	<span class="enscript-type">int</span>	err = EINVAL;
	<span class="enscript-type">struct</span> ip_fw_compat_64	*rule_ptr;
	<span class="enscript-type">struct</span> ip_fw_compat_64	rule;
	
	<span class="enscript-keyword">if</span> (rule_vers1) {
		rule_ptr = rule_vers1;
		err = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* do some basic size checking here, more extensive checking later */</span>
		<span class="enscript-keyword">if</span> (!sopt-&gt;sopt_val || sopt-&gt;sopt_valsize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_64))
			<span class="enscript-keyword">return</span> err;
	
		<span class="enscript-keyword">if</span> ((err = sooptcopyin(sopt, &amp;rule, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_64), 
							<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_64)))) {
			<span class="enscript-keyword">return</span> err;
		}
		rule_ptr = &amp;rule;
	}

	<span class="enscript-comment">/* deal with commands */</span>
	ipfw_convert_to_cmds_64(curr_rule, rule_ptr);

	curr_rule-&gt;version = IP_FW_CURRENT_API_VERSION;
	curr_rule-&gt;context = CAST_DOWN_EXPLICIT( <span class="enscript-type">void</span> *, rule_ptr-&gt;context);
	curr_rule-&gt;rulenum = rule_ptr-&gt;fw_number;
	curr_rule-&gt;pcnt = rule_ptr-&gt;fw_pcnt;
	curr_rule-&gt;bcnt = rule_ptr-&gt;fw_bcnt;
	curr_rule-&gt;timestamp = rule_ptr-&gt;timestamp;

	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FW2_DEBUG_VERBOSE</span>
	ipfw_print_vers2_struct(curr_rule);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/* This converts to whatever the latest version is. Currently the 
 * latest version of the firewall is ipfw2.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_version_one_to_latest_32</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_32 *rule_vers1)
{
	<span class="enscript-type">int</span> err;
	
	<span class="enscript-comment">/* if rule_vers1 is not null then this is coming from
	 * ipfw_version_zero_to_latest(), so pass that along;
	 * otherwise let ipfw_version_one_to_version_two()
	 * get the rule from sopt.
	 */</span>
	err = ipfw_version_one_to_version_two_32(sopt, curr_rule, rule_vers1);
	
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_version_one_to_latest_64</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">struct</span> ip_fw_compat_64 *rule_vers1)
{
	<span class="enscript-type">int</span> err;
	
	<span class="enscript-comment">/* if rule_vers1 is not null then this is coming from
	 * ipfw_version_zero_to_latest(), so pass that along;
	 * otherwise let ipfw_version_one_to_version_two()
	 * get the rule from sopt.
	 */</span>
	err = ipfw_version_one_to_version_two_64(sopt, curr_rule, rule_vers1);
	
	<span class="enscript-keyword">return</span> err;
}


#<span class="enscript-reference">if</span> 0

<span class="enscript-comment">/* 
 * XXX - ipfw_version_zero_to_one
 * 
 * This function is only used in version #1 of ipfw, which is now deprecated.
 *
 */</span> 

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_version_zero_to_one</span>(<span class="enscript-type">struct</span> ip_old_fw *rule_vers0, <span class="enscript-type">struct</span> ip_fw_compat *rule_vers1)
{
	bzero(rule_vers1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat));
	bcopy(&amp;rule_vers0-&gt;fw_uar, &amp;rule_vers1-&gt;fw_uar_compat, <span class="enscript-keyword">sizeof</span>(rule_vers0-&gt;fw_uar));
	bcopy(&amp;rule_vers0-&gt;fw_in_if, &amp;rule_vers1-&gt;fw_in_if, <span class="enscript-keyword">sizeof</span>(rule_vers0-&gt;fw_in_if));
	bcopy(&amp;rule_vers0-&gt;fw_out_if, &amp;rule_vers1-&gt;fw_out_if, <span class="enscript-keyword">sizeof</span>(rule_vers0-&gt;fw_out_if));
	bcopy(&amp;rule_vers0-&gt;fw_un, &amp;rule_vers1-&gt;fw_un_compat, <span class="enscript-keyword">sizeof</span>(rule_vers0-&gt;fw_un));

	rule_vers1-&gt;version       = 10;
	rule_vers1-&gt;fw_pcnt       = rule_vers0-&gt;fw_pcnt;
	rule_vers1-&gt;fw_bcnt       = rule_vers0-&gt;fw_bcnt;
	rule_vers1-&gt;fw_src        = rule_vers0-&gt;fw_src;
	rule_vers1-&gt;fw_dst        = rule_vers0-&gt;fw_dst;
	rule_vers1-&gt;fw_smsk       = rule_vers0-&gt;fw_smsk;
	rule_vers1-&gt;fw_dmsk       = rule_vers0-&gt;fw_dmsk;
	rule_vers1-&gt;fw_number     = rule_vers0-&gt;fw_number;
	rule_vers1-&gt;fw_flg        = rule_vers0-&gt;fw_flg;
	rule_vers1-&gt;fw_ipopt      = rule_vers0-&gt;fw_ipopt;
	rule_vers1-&gt;fw_ipnopt     = rule_vers0-&gt;fw_ipnopt;
	rule_vers1-&gt;fw_tcpf       = rule_vers0-&gt;fw_tcpf &amp; ~IP_OLD_FW_TCPF_ESTAB;
	rule_vers1-&gt;fw_tcpnf      = rule_vers0-&gt;fw_tcpnf;
	rule_vers1-&gt;timestamp     = rule_vers0-&gt;timestamp;
	rule_vers1-&gt;fw_prot       = rule_vers0-&gt;fw_prot;
	rule_vers1-&gt;fw_nports     = rule_vers0-&gt;fw_nports;
	rule_vers1-&gt;pipe_ptr      = rule_vers0-&gt;pipe_ptr;
	rule_vers1-&gt;next_rule_ptr = rule_vers0-&gt;next_rule_ptr;
	rule_vers1-&gt;fw_ipflg      = (rule_vers0-&gt;fw_tcpf &amp; IP_OLD_FW_TCPF_ESTAB) ? IP_FW_IF_TCPEST_COMPAT : 0;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !ipfw_version_zero_to_one  */</span>

<span class="enscript-comment">/* rule is a u_int32_t buffer[255] into which the converted 
 * (if necessary) rules go.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_convert_to_latest</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *curr_rule, <span class="enscript-type">int</span> api_version, <span class="enscript-type">int</span> is64user)
{
	<span class="enscript-type">int</span>	err = 0;
	
	<span class="enscript-comment">/* the following functions copy the rules passed in and
	 * convert to latest structures based on version
	 */</span>
	<span class="enscript-keyword">switch</span> (api_version) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_0</span>:
			<span class="enscript-comment">/* we're not supporting VERSION 0 */</span>
			err = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_VERSION_1</span>:
			<span class="enscript-comment">/* this is the version supported in Panther */</span>
			<span class="enscript-keyword">if</span> ( is64user )
				err = ipfw_version_one_to_latest_64(sopt, curr_rule, NULL);
			<span class="enscript-keyword">else</span>
				err = ipfw_version_one_to_latest_32(sopt, curr_rule, NULL);
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_CURRENT_API_VERSION</span>:
			<span class="enscript-comment">/* IPFW2 for now */</span>
			<span class="enscript-comment">/* do nothing here... */</span>
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* unrecognized/unsupported version */</span>
			err = EINVAL;
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_get_command_and_version</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">int</span> *command, u_int32_t *api_version)
{
	<span class="enscript-type">int</span> cmd;
	<span class="enscript-type">int</span> err = 0;
	u_int32_t	vers = IP_FW_VERSION_NONE;
	
	<span class="enscript-comment">/* first deal with the oldest version */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_GET) { 
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_GET;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_FLUSH) {
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_FLUSH;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_ZERO) { 
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_ZERO;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_ADD) { 
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_ADD;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_DEL) { 
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_DEL;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_OLD_FW_RESETLOG) { 
		vers = IP_FW_VERSION_0;
		cmd = IP_FW_RESETLOG;
	}
	<span class="enscript-keyword">else</span> { 
		cmd = sopt-&gt;sopt_name;
	}
	
	<span class="enscript-keyword">if</span> (vers == IP_FW_VERSION_NONE) {
		<span class="enscript-comment">/* working off the fact that the offset
		 * is the same in both structs.
		 */</span>
		<span class="enscript-type">struct</span> ip_fw_64 rule;
                size_t  copyinsize;

                <span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p))
                        copyinsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64);
                <span class="enscript-keyword">else</span>
                        copyinsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32);
	
		<span class="enscript-keyword">if</span> (!sopt-&gt;sopt_val || sopt-&gt;sopt_valsize &lt; copyinsize)
			<span class="enscript-keyword">return</span> EINVAL;
		<span class="enscript-keyword">if</span> ((err = sooptcopyin(sopt, &amp;rule, copyinsize, copyinsize))) {
			<span class="enscript-keyword">return</span> err;
		}
		
		vers = rule.version;
	}

	<span class="enscript-keyword">if</span> (command) {
		*command = cmd;
	}
	<span class="enscript-keyword">if</span> (api_version) {
		*api_version = vers;
	}
	
	<span class="enscript-keyword">return</span> err;
}

</pre>
<hr />
</body></html>