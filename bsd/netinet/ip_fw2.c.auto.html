<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip_fw2.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip_fw2.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 2002 Luigi Rizzo, Universita` di Pisa
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/netinet/ip_fw2.c,v 1.6.2.18 2003/10/17 11:01:03 scottl Exp $
 */</span>

#<span class="enscript-reference">define</span>        <span class="enscript-function-name">DEB</span>(x)
#<span class="enscript-reference">define</span>        <span class="enscript-function-name">DDB</span>(x) x

<span class="enscript-comment">/*
 * Implement IP packet firewall (new version)
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">IPFIREWALL</span> <span class="enscript-variable-name">requires</span> <span class="enscript-variable-name">INET</span>.
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_divert.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span> <span class="enscript-comment">/* XXX for ETHERTYPE_IP */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ip_fw2_compat.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>

<span class="enscript-comment">/*
#include &lt;machine/in_cksum.h&gt;
*/</span>	<span class="enscript-comment">/* XXX for in_cksum */</span>

<span class="enscript-comment">/*
 * XXX This one should go in sys/mbuf.h. It is used to avoid that
 * a firewall-generated packet loops forever through the firewall.
 */</span>
#<span class="enscript-reference">ifndef</span>	<span class="enscript-variable-name">M_SKIP_FIREWALL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_SKIP_FIREWALL</span>         0x4000
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * set_disable contains one bit per set value (0..31).
 * If the bit is set, all rules with the corresponding set
 * are disabled. Set RESVD_SET(31) is reserved for the default rule
 * and rules that are not deleted by the flush command,
 * and CANNOT be disabled.
 * Rules in set RESVD_SET can only be deleted explicitly.
 */</span>
<span class="enscript-type">static</span> u_int32_t set_disable;

<span class="enscript-type">int</span> fw_verbose;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> verbose_limit;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_bypass;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPFW_RULE_INACTIVE</span> 1

<span class="enscript-comment">/*
 * list of rules for layer 3
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip_fw *layer3_chain;

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_IPFW, <span class="enscript-string">&quot;IpFw/IpAcct&quot;</span>, <span class="enscript-string">&quot;IpFw/IpAcct chain's&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw_debug = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> autoinc_step = 100; <span class="enscript-comment">/* bounded to 1..1000 in add_rule() */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_kev_post_msg</span>(u_int32_t );

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">Get32static_len</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">Get64static_len</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SYSCTL_NODE</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipfw_sysctl SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_ip, OID_AUTO, fw, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Firewall&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_fw, OID_AUTO, enable,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;fw_enable, 0, ipfw_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Enable ipfw&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, autoinc_step, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;autoinc_step, 0, <span class="enscript-string">&quot;Rule number autincrement step&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, one_pass,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;fw_one_pass, 0,
    <span class="enscript-string">&quot;Only do a single pass through ipfw when using dummynet(4)&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, debug,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;fw_debug, 0, <span class="enscript-string">&quot;Enable printing of debug ip_fw statements&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, verbose,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;fw_verbose, 0, <span class="enscript-string">&quot;Log matches to ipfw rules&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, verbose_limit, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;verbose_limit, 0, <span class="enscript-string">&quot;Set upper limit of matches of ipfw rules logged&quot;</span>);

<span class="enscript-comment">/*
 * IP FW Stealth Logging:
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> ipfw_stealth_stats_type {
  IPFW_STEALTH_STATS_UDP,
  IPFW_STEALTH_STATS_TCP,
  IPFW_STEALTH_STATS_UDPv6,
  IPFW_STEALTH_STATS_TCPv6,
  IPFW_STEALTH_STATS_MAX,
} ipfw_stealth_stats_type_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPFW_STEALTH_TIMEOUT_SEC</span> 30

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DYN_KEEPALIVE_LEEWAY</span>	15

<span class="enscript-comment">// Piggybagging Stealth stats with ipfw_tick().
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPFW_STEALTH_TIMEOUT_FREQUENCY</span> (30 / dyn_keepalive_period)

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span>* ipfw_stealth_stats_str [IPFW_STEALTH_STATS_MAX] = {
  <span class="enscript-string">&quot;UDP&quot;</span>, <span class="enscript-string">&quot;TCP&quot;</span>, <span class="enscript-string">&quot;UDP v6&quot;</span>, <span class="enscript-string">&quot;TCP v6&quot;</span>,
};

<span class="enscript-type">static</span> uint32_t ipfw_stealth_stats_needs_flush = FALSE;
<span class="enscript-type">static</span> uint32_t ipfw_stealth_stats[IPFW_STEALTH_STATS_MAX];

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_flush_stats</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udp</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_tcp</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udpv6</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_tcpv6</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Description of dynamic rules.
 *
 * Dynamic rules are stored in lists accessed through a hash table
 * (ipfw_dyn_v) whose size is curr_dyn_buckets. This value can
 * be modified through the sysctl variable dyn_buckets which is
 * updated when the table becomes empty.
 *
 * XXX currently there is only one list, ipfw_dyn.
 *
 * When a packet is received, its address fields are first masked
 * with the mask defined for the rule, then hashed, then matched
 * against the entries in the corresponding list.
 * Dynamic rules can be used for different purposes:
 *  + stateful rules;
 *  + enforcing limits on the number of sessions;
 *  + in-kernel NAT (not implemented yet)
 *
 * The lifetime of dynamic rules is regulated by dyn_*_lifetime,
 * measured in seconds and depending on the flags.
 *
 * The total number of dynamic rules is stored in dyn_count.
 * The max number of dynamic rules is dyn_max. When we reach
 * the maximum number of rules we do not create anymore. This is
 * done to avoid consuming too much memory, but also too much
 * time when searching on each packet (ideally, we should try instead
 * to put a limit on the length of the list on each bucket...).
 *
 * Each dynamic rule holds a pointer to the parent ipfw rule so
 * we know what action to perform. Dynamic rules are removed when
 * the parent rule is deleted. XXX we should make them survive.
 *
 * There are some limitations with dynamic rules -- we do not
 * obey the 'randomized match', and we do not do multiple
 * passes through the firewall. XXX check the latter!!!
 */</span>
<span class="enscript-type">static</span> ipfw_dyn_rule **ipfw_dyn_v = NULL;
<span class="enscript-type">static</span> u_int32_t dyn_buckets = 256; <span class="enscript-comment">/* must be power of 2 */</span>
<span class="enscript-type">static</span> u_int32_t curr_dyn_buckets = 256; <span class="enscript-comment">/* must be power of 2 */</span>

<span class="enscript-comment">/*
 * Timeouts for various events in handing dynamic rules.
 */</span>
<span class="enscript-type">static</span> u_int32_t dyn_ack_lifetime = 300;
<span class="enscript-type">static</span> u_int32_t dyn_syn_lifetime = 20;
<span class="enscript-type">static</span> u_int32_t dyn_fin_lifetime = 1;
<span class="enscript-type">static</span> u_int32_t dyn_rst_lifetime = 1;
<span class="enscript-type">static</span> u_int32_t dyn_udp_lifetime = 10;
<span class="enscript-type">static</span> u_int32_t dyn_short_lifetime = 5;

<span class="enscript-comment">/*
 * Keepalives are sent if dyn_keepalive is set. They are sent every
 * dyn_keepalive_period seconds, in the last dyn_keepalive_interval
 * seconds of lifetime of a rule.
 * dyn_rst_lifetime and dyn_fin_lifetime should be strictly lower
 * than dyn_keepalive_period.
 */</span>

<span class="enscript-type">static</span> u_int32_t dyn_keepalive_interval = 25;
<span class="enscript-type">static</span> u_int32_t dyn_keepalive_period = 5;
<span class="enscript-type">static</span> u_int32_t dyn_keepalive = 1;	<span class="enscript-comment">/* do send keepalives */</span>

<span class="enscript-type">static</span> u_int32_t static_count;	<span class="enscript-comment">/* # of static rules */</span>
<span class="enscript-type">static</span> u_int32_t static_len;	<span class="enscript-comment">/* size in bytes of static rules */</span>
<span class="enscript-type">static</span> u_int32_t static_len_32;	<span class="enscript-comment">/* size in bytes of static rules for 32 bit client */</span>
<span class="enscript-type">static</span> u_int32_t static_len_64;	<span class="enscript-comment">/* size in bytes of static rules for 64 bit client */</span>
<span class="enscript-type">static</span> u_int32_t dyn_count;		<span class="enscript-comment">/* # of dynamic rules */</span>
<span class="enscript-type">static</span> u_int32_t dyn_max = 4096;	<span class="enscript-comment">/* max # of dynamic rules */</span>

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_buckets, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_buckets, 0, <span class="enscript-string">&quot;Number of dyn. buckets&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, curr_dyn_buckets, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;curr_dyn_buckets, 0, <span class="enscript-string">&quot;Current Number of dyn. buckets&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_count, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;dyn_count, 0, <span class="enscript-string">&quot;Number of dyn. rules&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_max, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_max, 0, <span class="enscript-string">&quot;Max number of dyn. rules&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, static_count, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;static_count, 0, <span class="enscript-string">&quot;Number of static rules&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_ack_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_ack_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for acks&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_syn_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_syn_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for syn&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_fin_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_fin_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for fin&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_rst_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_rst_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for rst&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_udp_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_udp_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for UDP&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_short_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_short_lifetime, 0, <span class="enscript-string">&quot;Lifetime of dyn. rules for other situations&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_fw, OID_AUTO, dyn_keepalive, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;dyn_keepalive, 0, <span class="enscript-string">&quot;Enable keepalives for dyn. rules&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
ipfw_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	
	error = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);
	
	ipfw_kev_post_msg(KEV_IPFW_ENABLE);
	
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SYSCTL_NODE */</span>


<span class="enscript-type">static</span> ip_fw_chk_t	ipfw_chk;

<span class="enscript-comment">/* firewall lock */</span>
lck_grp_t         *ipfw_mutex_grp;
lck_grp_attr_t    *ipfw_mutex_grp_attr;
lck_attr_t        *ipfw_mutex_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(,ipfw_mutex_data);
lck_mtx_t         *ipfw_mutex = &amp;ipfw_mutex_data;

<span class="enscript-type">extern</span>  <span class="enscript-type">void</span>    <span class="enscript-function-name">ipfwsyslog</span>( <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format,...);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KEV_LOG_SUBCLASS</span> 10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPFWLOGEVENT</span>    0

#<span class="enscript-reference">define</span>         <span class="enscript-variable-name">ipfwstring</span>      <span class="enscript-string">&quot;ipfw:&quot;</span>
<span class="enscript-type">static</span>          size_t		ipfwstringlen;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">dolog</span>( a ) {		\
	<span class="enscript-keyword">if</span> ( fw_verbose == 2 )  	<span class="enscript-comment">/* Apple logging, log to ipfw.log */</span> \
		ipfwsyslog a ; 	\
	<span class="enscript-keyword">else</span> log a ;		\
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RULESIZE64</span>(rule)  (sizeof(struct ip_fw_64) + \
							((<span class="enscript-type">struct</span> ip_fw *)(rule))-&gt;cmd_len * 4 - 4)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RULESIZE32</span>(rule)  (sizeof(struct ip_fw_32) + \
							((<span class="enscript-type">struct</span> ip_fw *)(rule))-&gt;cmd_len * 4 - 4)

<span class="enscript-type">void</span>    <span class="enscript-function-name">ipfwsyslog</span>( <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format,...)
{
#<span class="enscript-reference">define</span>		<span class="enscript-variable-name">msgsize</span>		100

    <span class="enscript-type">struct</span> kev_msg        ev_msg;
    va_list             ap;
    <span class="enscript-type">char</span>                msgBuf[msgsize];
    <span class="enscript-type">char</span>                *dptr = msgBuf;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>       pri;
    <span class="enscript-type">int</span>			loglen;

	bzero(msgBuf, msgsize);
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_msg));
	va_start( ap, format );
        loglen = vsnprintf(msgBuf, msgsize, format, ap);
        va_end( ap );

        ev_msg.vendor_code    = KEV_VENDOR_APPLE;
        ev_msg.kev_class      = KEV_NETWORK_CLASS;
        ev_msg.kev_subclass   = KEV_LOG_SUBCLASS;
        ev_msg.event_code         = IPFWLOGEVENT;

	<span class="enscript-comment">/* get rid of the trailing \n */</span>
	<span class="enscript-keyword">if</span> (loglen &lt; msgsize)
		dptr[loglen-1] = 0;
	<span class="enscript-keyword">else</span>
		dptr[msgsize-1] = 0;

        pri = LOG_PRI(level);

        <span class="enscript-comment">/* remove &quot;ipfw:&quot; prefix if logging to ipfw log */</span>
        <span class="enscript-keyword">if</span> ( !(strncmp( ipfwstring, msgBuf, ipfwstringlen))){
                dptr = msgBuf+ipfwstringlen;
        }
	
        ev_msg.dv[0].data_ptr = &amp;pri;
        ev_msg.dv[0].data_length = 1;
        ev_msg.dv[1].data_ptr    = dptr;
        ev_msg.dv[1].data_length = 100; <span class="enscript-comment">/* bug in kern_post_msg, it can't handle size &gt; 256-msghdr */</span>
        ev_msg.dv[2].data_length = 0;

        kev_post_msg(&amp;ev_msg);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr</span>(uint32_t type)
{
    <span class="enscript-keyword">if</span> (type &gt;= IPFW_STEALTH_STATS_MAX)
        <span class="enscript-keyword">return</span>;

    ipfw_stealth_stats[type]++;

    <span class="enscript-keyword">if</span> (!ipfw_stealth_stats_needs_flush) {
        ipfw_stealth_stats_needs_flush = TRUE;
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udp</span>(<span class="enscript-type">void</span>)
{
    ipfw_stealth_stats_incr(IPFW_STEALTH_STATS_UDP);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_tcp</span>(<span class="enscript-type">void</span>)
{
    ipfw_stealth_stats_incr(IPFW_STEALTH_STATS_TCP);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udpv6</span>(<span class="enscript-type">void</span>)
{
    ipfw_stealth_stats_incr(IPFW_STEALTH_STATS_UDPv6);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_tcpv6</span>(<span class="enscript-type">void</span>)
{
    ipfw_stealth_stats_incr(IPFW_STEALTH_STATS_TCPv6);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_flush_stats</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> i;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; IPFW_STEALTH_STATS_MAX; i++) {
        <span class="enscript-keyword">if</span> (ipfw_stealth_stats[i]) {
           ipfwsyslog (LOG_INFO, <span class="enscript-string">&quot;Stealth Mode connection attempt to %s %d times&quot;</span>,
                       ipfw_stealth_stats_str[i], ipfw_stealth_stats[i]);
           ipfw_stealth_stats[i] = 0;
       }
    }
    ipfw_stealth_stats_needs_flush = FALSE;
}

<span class="enscript-comment">/*
 * This macro maps an ip pointer into a layer3 header pointer of type T
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">L3HDR</span>(T, ip) ((T *)((u_int32_t *)(ip) + (ip)-&gt;ip_hl))

<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">icmptype_match</span>(<span class="enscript-type">struct</span> ip *ip, ipfw_insn_u32 *cmd)
{
	<span class="enscript-type">int</span> type = L3HDR(<span class="enscript-type">struct</span> icmp,ip)-&gt;icmp_type;

	<span class="enscript-keyword">return</span> (type &lt;= ICMP_MAXTYPE &amp;&amp; (cmd-&gt;d[0] &amp; (1&lt;&lt;type)) );
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TT</span>	( (1 &lt;&lt; ICMP_ECHO) | (1 &lt;&lt; ICMP_ROUTERSOLICIT) | \
    (1 &lt;&lt; ICMP_TSTAMP) | (1 &lt;&lt; ICMP_IREQ) | (1 &lt;&lt; ICMP_MASKREQ) )

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_icmp_query</span>(<span class="enscript-type">struct</span> ip *ip)
{
	<span class="enscript-type">int</span> type = L3HDR(<span class="enscript-type">struct</span> icmp, ip)-&gt;icmp_type;
	<span class="enscript-keyword">return</span> (type &lt;= ICMP_MAXTYPE &amp;&amp; (TT &amp; (1&lt;&lt;type)) );
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">TT</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">Get32static_len</span>()
{
	<span class="enscript-type">int</span>	diff;
	<span class="enscript-type">int</span> len = static_len_32;
	<span class="enscript-type">struct</span> ip_fw *rule;
	<span class="enscript-type">char</span>		 *useraction;

	<span class="enscript-keyword">for</span> (rule = layer3_chain; rule ; rule = rule-&gt;next) {
		<span class="enscript-keyword">if</span> (rule-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ( rule-&gt;act_ofs ){
			useraction =  (<span class="enscript-type">char</span>*)ACTION_PTR( rule ); 
			<span class="enscript-keyword">if</span> ( ((ipfw_insn*)useraction)-&gt;opcode == O_QUEUE || ((ipfw_insn*)useraction)-&gt;opcode == O_PIPE){
				diff = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe) - <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe_32);
				<span class="enscript-keyword">if</span> (diff)
					len -= diff;
			}
		}
	}
	<span class="enscript-keyword">return</span> len;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">Get64static_len</span>()
{
	<span class="enscript-type">int</span>	diff;
	<span class="enscript-type">int</span> len = static_len_64;
	<span class="enscript-type">struct</span> ip_fw *rule;
	<span class="enscript-type">char</span>		 *useraction;

	<span class="enscript-keyword">for</span> (rule = layer3_chain; rule ; rule = rule-&gt;next) {
		<span class="enscript-keyword">if</span> (rule-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ( rule-&gt;act_ofs ){
			useraction =  (<span class="enscript-type">char</span> *)ACTION_PTR( rule ); 
			<span class="enscript-keyword">if</span> ( ((ipfw_insn*)useraction)-&gt;opcode == O_QUEUE || ((ipfw_insn*)useraction)-&gt;opcode == O_PIPE){
				diff = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe_64) - <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe);
				<span class="enscript-keyword">if</span> (diff)
					len += diff;
			}
		}
	}
	<span class="enscript-keyword">return</span> len;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">copyto32fw_insn</span>( <span class="enscript-type">struct</span> ip_fw_32 *fw32 , <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">int</span> cmdsize)
{
	<span class="enscript-type">char</span>		*end;
	<span class="enscript-type">char</span>		*fw32action;
	<span class="enscript-type">char</span>		*useraction;
	<span class="enscript-type">int</span>			justcmdsize;
	<span class="enscript-type">int</span>			diff=0;
	<span class="enscript-type">int</span>			actioncopysize;

	end = ((<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd) + cmdsize;
	useraction = (<span class="enscript-type">char</span>*)ACTION_PTR( user_ip_fw );
	fw32action = (<span class="enscript-type">char</span>*)fw32-&gt;cmd + (user_ip_fw-&gt;act_ofs * <span class="enscript-keyword">sizeof</span>(uint32_t));
	<span class="enscript-keyword">if</span> ( ( justcmdsize = ( fw32action - (<span class="enscript-type">char</span>*)fw32-&gt;cmd)))
		bcopy( user_ip_fw-&gt;cmd, fw32-&gt;cmd, justcmdsize); 
	<span class="enscript-keyword">while</span> ( useraction &lt; end ){
		<span class="enscript-keyword">if</span> ( ((ipfw_insn*)useraction)-&gt;opcode == O_QUEUE || ((ipfw_insn*)useraction)-&gt;opcode == O_PIPE){
			actioncopysize = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe_32);
			((ipfw_insn*)fw32action)-&gt;opcode = ((ipfw_insn*)useraction)-&gt;opcode;
			((ipfw_insn*)fw32action)-&gt;arg1 = ((ipfw_insn*)useraction)-&gt;arg1;
			((ipfw_insn*)fw32action)-&gt;len = F_INSN_SIZE(ipfw_insn_pipe_32);
			diff = ((ipfw_insn*)useraction)-&gt;len - ((ipfw_insn*)fw32action)-&gt;len;
			<span class="enscript-keyword">if</span> ( diff ){
				fw32-&gt;cmd_len -= diff;
			}
		} <span class="enscript-keyword">else</span>{
			actioncopysize =  (F_LEN((ipfw_insn*)useraction) ? (F_LEN((ipfw_insn*)useraction)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
			bcopy( useraction, fw32action, actioncopysize );
		}
		useraction += (F_LEN((ipfw_insn*)useraction) ? (F_LEN((ipfw_insn*)useraction)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
		fw32action += actioncopysize;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">copyto64fw_insn</span>( <span class="enscript-type">struct</span> ip_fw_64 *fw64 , <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">int</span> cmdsize)
{
	<span class="enscript-type">char</span>		*end;
	<span class="enscript-type">char</span>		*fw64action;
	<span class="enscript-type">char</span>		*useraction;
	<span class="enscript-type">int</span>			justcmdsize;
	<span class="enscript-type">int</span>			diff;
	<span class="enscript-type">int</span>			actioncopysize;

	end = ((<span class="enscript-type">char</span> *)user_ip_fw-&gt;cmd) + cmdsize;
	useraction = (<span class="enscript-type">char</span>*)ACTION_PTR( user_ip_fw );
	<span class="enscript-keyword">if</span> ( (justcmdsize = (useraction - (<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd)))
		bcopy( user_ip_fw-&gt;cmd, fw64-&gt;cmd, justcmdsize); 
	fw64action = (<span class="enscript-type">char</span>*)fw64-&gt;cmd + justcmdsize;
	<span class="enscript-keyword">while</span> ( useraction &lt; end ){
		<span class="enscript-keyword">if</span> ( ((ipfw_insn*)user_ip_fw)-&gt;opcode == O_QUEUE || ((ipfw_insn*)user_ip_fw)-&gt;opcode == O_PIPE){
			actioncopysize = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe_64);
			((ipfw_insn*)fw64action)-&gt;opcode = ((ipfw_insn*)useraction)-&gt;opcode;
			((ipfw_insn*)fw64action)-&gt;arg1 = ((ipfw_insn*)useraction)-&gt;arg1;
			((ipfw_insn*)fw64action)-&gt;len = F_INSN_SIZE(ipfw_insn_pipe_64);
			diff = ((ipfw_insn*)fw64action)-&gt;len - ((ipfw_insn*)useraction)-&gt;len;
			<span class="enscript-keyword">if</span> (diff)
				fw64-&gt;cmd_len += diff;
			
		} <span class="enscript-keyword">else</span>{
			actioncopysize = (F_LEN((ipfw_insn*)useraction) ? (F_LEN((ipfw_insn*)useraction)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
			bcopy( useraction, fw64action, actioncopysize );
		}
		useraction += (F_LEN((ipfw_insn*)useraction) ? (F_LEN((ipfw_insn*)useraction)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
		fw64action += actioncopysize;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">copyto32fw</span>( <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">struct</span> ip_fw_32 *fw32 , __unused size_t copysize)
{
	size_t	rulesize, cmdsize;
	
	fw32-&gt;version = user_ip_fw-&gt;version;
	fw32-&gt;context = CAST_DOWN_EXPLICIT( user32_addr_t, user_ip_fw-&gt;context);
	fw32-&gt;next = CAST_DOWN_EXPLICIT(user32_addr_t, user_ip_fw-&gt;next);
	fw32-&gt;next_rule = CAST_DOWN_EXPLICIT(user32_addr_t, user_ip_fw-&gt;next_rule);
	fw32-&gt;act_ofs = user_ip_fw-&gt;act_ofs;
	fw32-&gt;cmd_len = user_ip_fw-&gt;cmd_len;
	fw32-&gt;rulenum = user_ip_fw-&gt;rulenum;
	fw32-&gt;set = user_ip_fw-&gt;set;
	fw32-&gt;set_masks[0] = user_ip_fw-&gt;set_masks[0];
	fw32-&gt;set_masks[1] = user_ip_fw-&gt;set_masks[1];
	fw32-&gt;pcnt = user_ip_fw-&gt;pcnt;
	fw32-&gt;bcnt = user_ip_fw-&gt;bcnt;
	fw32-&gt;timestamp = user_ip_fw-&gt;timestamp;
	fw32-&gt;reserved_1 = user_ip_fw-&gt;reserved_1;
	fw32-&gt;reserved_2 = user_ip_fw-&gt;reserved_2;
	rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32) + (user_ip_fw-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn) - 4);
	cmdsize = user_ip_fw-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(u_int32_t);
	copyto32fw_insn( fw32, user_ip_fw, cmdsize );
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">copyto64fw</span>( <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">struct</span> ip_fw_64	*fw64, size_t copysize)
{
	size_t	rulesize, cmdsize;

	fw64-&gt;version = user_ip_fw-&gt;version;
	fw64-&gt;context = CAST_DOWN_EXPLICIT(__uint64_t, user_ip_fw-&gt;context);
	fw64-&gt;next = CAST_DOWN_EXPLICIT(user64_addr_t, user_ip_fw-&gt;next);
	fw64-&gt;next_rule = CAST_DOWN_EXPLICIT(user64_addr_t, user_ip_fw-&gt;next_rule);
	fw64-&gt;act_ofs = user_ip_fw-&gt;act_ofs;
	fw64-&gt;cmd_len = user_ip_fw-&gt;cmd_len;
	fw64-&gt;rulenum = user_ip_fw-&gt;rulenum;
	fw64-&gt;set = user_ip_fw-&gt;set;
	fw64-&gt;set_masks[0] = user_ip_fw-&gt;set_masks[0];
	fw64-&gt;set_masks[1] = user_ip_fw-&gt;set_masks[1];
	fw64-&gt;pcnt = user_ip_fw-&gt;pcnt;
	fw64-&gt;bcnt = user_ip_fw-&gt;bcnt;
	fw64-&gt;timestamp = user_ip_fw-&gt;timestamp;
	fw64-&gt;reserved_1 = user_ip_fw-&gt;reserved_1;
	fw64-&gt;reserved_2 = user_ip_fw-&gt;reserved_2;
	rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) + (user_ip_fw-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn) - 4);
	<span class="enscript-keyword">if</span> (rulesize &gt; copysize)
		cmdsize = copysize - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) + 4;
	<span class="enscript-keyword">else</span>
		cmdsize = user_ip_fw-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(u_int32_t);
	copyto64fw_insn( fw64, user_ip_fw, cmdsize);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copyfrom32fw_insn</span>( <span class="enscript-type">struct</span> ip_fw_32 *fw32 , <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">int</span> cmdsize)
{
	<span class="enscript-type">char</span>		*end;
	<span class="enscript-type">char</span>		*fw32action;
	<span class="enscript-type">char</span>		*useraction;
	<span class="enscript-type">int</span>			justcmdsize;
	<span class="enscript-type">int</span>			diff;
	<span class="enscript-type">int</span>			actioncopysize;

	end = ((<span class="enscript-type">char</span>*)fw32-&gt;cmd) + cmdsize;
	fw32action = (<span class="enscript-type">char</span>*)ACTION_PTR( fw32 );
	<span class="enscript-keyword">if</span> ((justcmdsize = (fw32action - (<span class="enscript-type">char</span>*)fw32-&gt;cmd)))
		bcopy( fw32-&gt;cmd, user_ip_fw-&gt;cmd, justcmdsize); 
	useraction = (<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd + justcmdsize;
	<span class="enscript-keyword">while</span> ( fw32action &lt; end ){
		<span class="enscript-keyword">if</span> ( ((ipfw_insn*)fw32action)-&gt;opcode == O_QUEUE || ((ipfw_insn*)fw32action)-&gt;opcode == O_PIPE){
			actioncopysize = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe);
			((ipfw_insn*)useraction)-&gt;opcode = ((ipfw_insn*)fw32action)-&gt;opcode;
			((ipfw_insn*)useraction)-&gt;arg1 = ((ipfw_insn*)fw32action)-&gt;arg1;
			((ipfw_insn*)useraction)-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
			diff = ((ipfw_insn*)useraction)-&gt;len - ((ipfw_insn*)fw32action)-&gt;len;
			<span class="enscript-keyword">if</span> (diff){
				<span class="enscript-comment">/* readjust the cmd_len */</span>
				user_ip_fw-&gt;cmd_len += diff;
			}
		} <span class="enscript-keyword">else</span>{
			actioncopysize = (F_LEN((ipfw_insn*)fw32action) ? (F_LEN((ipfw_insn*)fw32action)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
			bcopy( fw32action, useraction, actioncopysize );
		}
		fw32action += (F_LEN((ipfw_insn*)fw32action) ? (F_LEN((ipfw_insn*)fw32action)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
		useraction += actioncopysize;
	}

	<span class="enscript-keyword">return</span>( useraction - (<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd );
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copyfrom64fw_insn</span>( <span class="enscript-type">struct</span> ip_fw_64 *fw64 , <span class="enscript-type">struct</span> ip_fw *user_ip_fw, <span class="enscript-type">int</span> cmdsize)
{
	<span class="enscript-type">char</span>		*end;
	<span class="enscript-type">char</span>		*fw64action;
	<span class="enscript-type">char</span>		*useraction;
	<span class="enscript-type">int</span>			justcmdsize;
	<span class="enscript-type">int</span>			diff;
	<span class="enscript-type">int</span>			actioncopysize;

	end = ((<span class="enscript-type">char</span> *)fw64-&gt;cmd) + cmdsize ;
	fw64action = (<span class="enscript-type">char</span>*)ACTION_PTR( fw64 );
	<span class="enscript-keyword">if</span> ( (justcmdsize = (fw64action - (<span class="enscript-type">char</span>*)fw64-&gt;cmd)))
		bcopy( fw64-&gt;cmd, user_ip_fw-&gt;cmd, justcmdsize); 
	useraction = (<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd + justcmdsize;
	<span class="enscript-keyword">while</span> ( fw64action &lt; end ){
		<span class="enscript-keyword">if</span> ( ((ipfw_insn*)fw64action)-&gt;opcode == O_QUEUE || ((ipfw_insn*)fw64action)-&gt;opcode == O_PIPE){
			actioncopysize = <span class="enscript-keyword">sizeof</span>(ipfw_insn_pipe);
			((ipfw_insn*)useraction)-&gt;opcode = ((ipfw_insn*)fw64action)-&gt;opcode;
			((ipfw_insn*)useraction)-&gt;arg1 = ((ipfw_insn*)fw64action)-&gt;arg1;
			((ipfw_insn*)useraction)-&gt;len = F_INSN_SIZE(ipfw_insn_pipe);
			diff = ((ipfw_insn*)fw64action)-&gt;len - ((ipfw_insn*)useraction)-&gt;len; 
			<span class="enscript-keyword">if</span> (diff) {
				<span class="enscript-comment">/* readjust the cmd_len */</span>
				user_ip_fw-&gt;cmd_len -= diff;
			}
		} <span class="enscript-keyword">else</span>{
			actioncopysize = (F_LEN((ipfw_insn*)fw64action) ? (F_LEN((ipfw_insn*)fw64action)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t);
			bcopy( fw64action, useraction, actioncopysize );
		}
		fw64action += (F_LEN((ipfw_insn*)fw64action) ? (F_LEN((ipfw_insn*)fw64action)) : 1 ) * <span class="enscript-keyword">sizeof</span>(uint32_t); 
		useraction += actioncopysize;
	}
	<span class="enscript-keyword">return</span>( useraction - (<span class="enscript-type">char</span>*)user_ip_fw-&gt;cmd );
}

<span class="enscript-type">static</span> size_t 
<span class="enscript-function-name">copyfrom32fw</span>( <span class="enscript-type">struct</span> ip_fw_32	*fw32, <span class="enscript-type">struct</span> ip_fw *user_ip_fw, size_t copysize)
{
	size_t rulesize, cmdsize;
	 
	user_ip_fw-&gt;version = fw32-&gt;version;
	user_ip_fw-&gt;context = CAST_DOWN(<span class="enscript-type">void</span> *, fw32-&gt;context);
	user_ip_fw-&gt;next = CAST_DOWN(<span class="enscript-type">struct</span> ip_fw*, fw32-&gt;next);
	user_ip_fw-&gt;next_rule = CAST_DOWN_EXPLICIT(<span class="enscript-type">struct</span> ip_fw*, fw32-&gt;next_rule);
	user_ip_fw-&gt;act_ofs = fw32-&gt;act_ofs;
	user_ip_fw-&gt;cmd_len = fw32-&gt;cmd_len;
	user_ip_fw-&gt;rulenum = fw32-&gt;rulenum;
	user_ip_fw-&gt;set = fw32-&gt;set;
	user_ip_fw-&gt;set_masks[0] = fw32-&gt;set_masks[0];
	user_ip_fw-&gt;set_masks[1] = fw32-&gt;set_masks[1];
	user_ip_fw-&gt;pcnt = fw32-&gt;pcnt;
	user_ip_fw-&gt;bcnt = fw32-&gt;bcnt;
	user_ip_fw-&gt;timestamp = fw32-&gt;timestamp;
	user_ip_fw-&gt;reserved_1 = fw32-&gt;reserved_1;
	user_ip_fw-&gt;reserved_2 = fw32-&gt;reserved_2;
	rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32) + (fw32-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn) - 4);
	<span class="enscript-keyword">if</span> ( rulesize &gt; copysize )
		cmdsize = copysize - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32)-4;
	<span class="enscript-keyword">else</span>
		cmdsize = fw32-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn);
	cmdsize = copyfrom32fw_insn( fw32, user_ip_fw, cmdsize);
	<span class="enscript-keyword">return</span>( <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw) + cmdsize - 4);
}

<span class="enscript-type">static</span> size_t 
<span class="enscript-function-name">copyfrom64fw</span>( <span class="enscript-type">struct</span> ip_fw_64 *fw64, <span class="enscript-type">struct</span> ip_fw *user_ip_fw, size_t copysize)
{
	size_t rulesize, cmdsize;
	
	user_ip_fw-&gt;version = fw64-&gt;version;
	user_ip_fw-&gt;context = CAST_DOWN_EXPLICIT( <span class="enscript-type">void</span> *, fw64-&gt;context);
	user_ip_fw-&gt;next = CAST_DOWN_EXPLICIT(<span class="enscript-type">struct</span> ip_fw*, fw64-&gt;next);
	user_ip_fw-&gt;next_rule = CAST_DOWN_EXPLICIT(<span class="enscript-type">struct</span> ip_fw*, fw64-&gt;next_rule);
	user_ip_fw-&gt;act_ofs = fw64-&gt;act_ofs;
	user_ip_fw-&gt;cmd_len = fw64-&gt;cmd_len;
	user_ip_fw-&gt;rulenum = fw64-&gt;rulenum;
	user_ip_fw-&gt;set = fw64-&gt;set;
	user_ip_fw-&gt;set_masks[0] = fw64-&gt;set_masks[0];
	user_ip_fw-&gt;set_masks[1] = fw64-&gt;set_masks[1];
	user_ip_fw-&gt;pcnt = fw64-&gt;pcnt;
	user_ip_fw-&gt;bcnt = fw64-&gt;bcnt;
	user_ip_fw-&gt;timestamp = fw64-&gt;timestamp;
	user_ip_fw-&gt;reserved_1 = fw64-&gt;reserved_1;
	user_ip_fw-&gt;reserved_2 = fw64-&gt;reserved_2;
	<span class="enscript-comment">//bcopy( fw64-&gt;cmd, user_ip_fw-&gt;cmd, fw64-&gt;cmd_len * sizeof(ipfw_insn));
</span>	rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) + (fw64-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn) - 4);
	<span class="enscript-keyword">if</span> ( rulesize &gt; copysize )
		cmdsize = copysize - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64)-4;
	<span class="enscript-keyword">else</span>
		cmdsize = fw64-&gt;cmd_len * <span class="enscript-keyword">sizeof</span>(ipfw_insn);
	cmdsize = copyfrom64fw_insn( fw64, user_ip_fw, cmdsize);
	<span class="enscript-keyword">return</span>( <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw) + cmdsize - 4);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">externalize_flow_id</span>(<span class="enscript-type">struct</span> ipfw_flow_id *dst, <span class="enscript-type">struct</span> ip_flow_id *src);
<span class="enscript-type">void</span>
<span class="enscript-function-name">externalize_flow_id</span>(<span class="enscript-type">struct</span> ipfw_flow_id *dst, <span class="enscript-type">struct</span> ip_flow_id *src)
{
	dst-&gt;dst_ip = src-&gt;dst_ip;
	dst-&gt;src_ip = src-&gt;src_ip;
	dst-&gt;dst_port = src-&gt;dst_port;
	dst-&gt;src_port = src-&gt;src_port;
	dst-&gt;proto = src-&gt;proto;
	dst-&gt;flags = src-&gt;flags;
}

<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">cp_dyn_to_comp_32</span>( <span class="enscript-type">struct</span> ipfw_dyn_rule_compat_32 *dyn_rule_vers1, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_32 *dyn_last=NULL;
	ipfw_dyn_rule 	*p;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (ipfw_dyn_v) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; curr_dyn_buckets; i++) {
			<span class="enscript-keyword">for</span> ( p = ipfw_dyn_v[i] ; p != NULL ; p = p-&gt;next) {
				dyn_rule_vers1-&gt;chain = (user32_addr_t)(p-&gt;rule-&gt;rulenum);
				externalize_flow_id(&amp;dyn_rule_vers1-&gt;id, &amp;p-&gt;id);
				externalize_flow_id(&amp;dyn_rule_vers1-&gt;mask, &amp;p-&gt;id);
				dyn_rule_vers1-&gt;type = p-&gt;dyn_type;
				dyn_rule_vers1-&gt;expire = p-&gt;expire;
				dyn_rule_vers1-&gt;pcnt = p-&gt;pcnt;
				dyn_rule_vers1-&gt;bcnt = p-&gt;bcnt;
				dyn_rule_vers1-&gt;bucket = p-&gt;bucket;
				dyn_rule_vers1-&gt;state = p-&gt;state;
				
				dyn_rule_vers1-&gt;next = CAST_DOWN_EXPLICIT( user32_addr_t, p-&gt;next);
				dyn_last = dyn_rule_vers1;
				
				*len += <span class="enscript-keyword">sizeof</span>(*dyn_rule_vers1);
				dyn_rule_vers1++;
			}
		}
		
		<span class="enscript-keyword">if</span> (dyn_last != NULL) {
			dyn_last-&gt;next = ((user32_addr_t)0);
		}
	}
}


<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">cp_dyn_to_comp_64</span>( <span class="enscript-type">struct</span> ipfw_dyn_rule_compat_64 *dyn_rule_vers1, <span class="enscript-type">int</span> *len)
{
	<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_64 *dyn_last=NULL;
	ipfw_dyn_rule 	*p;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (ipfw_dyn_v) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; curr_dyn_buckets; i++) {
			<span class="enscript-keyword">for</span> ( p = ipfw_dyn_v[i] ; p != NULL ; p = p-&gt;next) {
				dyn_rule_vers1-&gt;chain = (user64_addr_t) p-&gt;rule-&gt;rulenum;
				externalize_flow_id(&amp;dyn_rule_vers1-&gt;id, &amp;p-&gt;id);
				externalize_flow_id(&amp;dyn_rule_vers1-&gt;mask, &amp;p-&gt;id);
				dyn_rule_vers1-&gt;type = p-&gt;dyn_type;
				dyn_rule_vers1-&gt;expire = p-&gt;expire;
				dyn_rule_vers1-&gt;pcnt = p-&gt;pcnt;
				dyn_rule_vers1-&gt;bcnt = p-&gt;bcnt;
				dyn_rule_vers1-&gt;bucket = p-&gt;bucket;
				dyn_rule_vers1-&gt;state = p-&gt;state;
				
				dyn_rule_vers1-&gt;next = CAST_DOWN(user64_addr_t, p-&gt;next);
				dyn_last = dyn_rule_vers1;
				
				*len += <span class="enscript-keyword">sizeof</span>(*dyn_rule_vers1);
				dyn_rule_vers1++;
			}
		}
		
		<span class="enscript-keyword">if</span> (dyn_last != NULL) {
			dyn_last-&gt;next = CAST_DOWN(user64_addr_t, NULL);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sooptcopyin_fw</span>( <span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> ip_fw *user_ip_fw, size_t *size )
{
	size_t	valsize, copyinsize = 0;
	<span class="enscript-type">int</span>	error = 0;

	valsize = sopt-&gt;sopt_valsize;	
	<span class="enscript-keyword">if</span> ( size )
		copyinsize = *size;
	<span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p)) {
		<span class="enscript-type">struct</span> ip_fw_64	*fw64=NULL;
		
		<span class="enscript-keyword">if</span> ( valsize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) ) {
			<span class="enscript-keyword">return</span>(EINVAL);
		}
		<span class="enscript-keyword">if</span> ( !copyinsize )
			copyinsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64);
		<span class="enscript-keyword">if</span> ( valsize &gt; copyinsize )
			sopt-&gt;sopt_valsize = valsize = copyinsize;
			
		<span class="enscript-keyword">if</span> ( sopt-&gt;sopt_p != 0) {
			fw64 = _MALLOC(copyinsize, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> ( fw64 == NULL )
				<span class="enscript-keyword">return</span>(ENOBUFS);
			<span class="enscript-keyword">if</span> ((error = copyin(sopt-&gt;sopt_val, fw64, valsize)) != 0){
				_FREE(fw64, M_TEMP);
				<span class="enscript-keyword">return</span> error;
			}
		}
		<span class="enscript-keyword">else</span> {
			bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val), fw64, valsize);
		}
		valsize = copyfrom64fw( fw64, user_ip_fw, valsize );
		_FREE( fw64, M_TEMP);
	}<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ip_fw_32 *fw32=NULL;
	
		<span class="enscript-keyword">if</span> ( valsize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32) ) {
			<span class="enscript-keyword">return</span>(EINVAL);
		}
		<span class="enscript-keyword">if</span> ( !copyinsize)
			copyinsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32);
		<span class="enscript-keyword">if</span> ( valsize &gt; copyinsize)
			sopt-&gt;sopt_valsize = valsize = copyinsize;
			
		<span class="enscript-keyword">if</span> ( sopt-&gt;sopt_p != 0) {
			fw32 = _MALLOC(copyinsize, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> ( fw32 == NULL )
				<span class="enscript-keyword">return</span>(ENOBUFS);
			<span class="enscript-keyword">if</span> ( (error = copyin(sopt-&gt;sopt_val, fw32, valsize)) != 0){
				_FREE( fw32, M_TEMP);
				<span class="enscript-keyword">return</span>( error );
			}
		}
		<span class="enscript-keyword">else</span> {
			bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val), fw32, valsize);
		}
		valsize = copyfrom32fw( fw32, user_ip_fw, valsize);
		_FREE( fw32, M_TEMP);
	}
	<span class="enscript-keyword">if</span> ( size )
		*size = valsize;
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * The following checks use two arrays of 8 or 16 bits to store the
 * bits that we want set or clear, respectively. They are in the
 * low and high half of cmd-&gt;arg1 or cmd-&gt;d[0].
 *
 * We scan options and store the bits we find set. We succeed if
 *
 *	(want_set &amp; ~bits) == 0 &amp;&amp; (want_clear &amp; ~bits) == want_clear
 *
 * The code is sometimes optimized not to store additional variables.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flags_match</span>(ipfw_insn *cmd, u_int8_t bits)
{
	u_char want_clear;
	bits = ~bits;

	<span class="enscript-keyword">if</span> ( ((cmd-&gt;arg1 &amp; 0xff) &amp; bits) != 0)
		<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* some bits we want set were clear */</span>
	want_clear = (cmd-&gt;arg1 &gt;&gt; 8) &amp; 0xff;
	<span class="enscript-keyword">if</span> ( (want_clear &amp; bits) != want_clear)
		<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* some bits we want clear were set */</span>
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipopts_match</span>(<span class="enscript-type">struct</span> ip *ip, ipfw_insn *cmd)
{
	<span class="enscript-type">int</span> optlen, bits = 0;
	u_char *cp = (u_char *)(ip + 1);
	<span class="enscript-type">int</span> x = (ip-&gt;ip_hl &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);

	<span class="enscript-keyword">for</span> (; x &gt; 0; x -= optlen, cp += optlen) {
		<span class="enscript-type">int</span> opt = cp[IPOPT_OPTVAL];

		<span class="enscript-keyword">if</span> (opt == IPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == IPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			optlen = cp[IPOPT_OLEN];
			<span class="enscript-keyword">if</span> (optlen &lt;= 0 || optlen &gt; x)
				<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* invalid or truncated */</span>
		}
		<span class="enscript-keyword">switch</span> (opt) {

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_LSRR</span>:
			bits |= IP_FW_IPOPT_LSRR;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_SSRR</span>:
			bits |= IP_FW_IPOPT_SSRR;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_RR</span>:
			bits |= IP_FW_IPOPT_RR;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_TS</span>:
			bits |= IP_FW_IPOPT_TS;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (flags_match(cmd, bits));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcpopts_match</span>(<span class="enscript-type">struct</span> ip *ip, ipfw_insn *cmd)
{
	<span class="enscript-type">int</span> optlen, bits = 0;
	<span class="enscript-type">struct</span> tcphdr *tcp = L3HDR(<span class="enscript-type">struct</span> tcphdr,ip);
	u_char *cp = (u_char *)(tcp + 1);
	<span class="enscript-type">int</span> x = (tcp-&gt;th_off &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr);

	<span class="enscript-keyword">for</span> (; x &gt; 0; x -= optlen, cp += optlen) {
		<span class="enscript-type">int</span> opt = cp[0];
		<span class="enscript-keyword">if</span> (opt == TCPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == TCPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			optlen = cp[1];
			<span class="enscript-keyword">if</span> (optlen &lt;= 0)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">switch</span> (opt) {

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_MAXSEG</span>:
			bits |= IP_FW_TCPOPT_MSS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_WINDOW</span>:
			bits |= IP_FW_TCPOPT_WINDOW;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_SACK_PERMITTED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_SACK</span>:
			bits |= IP_FW_TCPOPT_SACK;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_TIMESTAMP</span>:
			bits |= IP_FW_TCPOPT_TS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_CC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_CCNEW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_CCECHO</span>:
			bits |= IP_FW_TCPOPT_CC;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (flags_match(cmd, bits));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iface_match</span>(<span class="enscript-type">struct</span> ifnet *ifp, ipfw_insn_if *cmd)
{
	<span class="enscript-keyword">if</span> (ifp == NULL)	<span class="enscript-comment">/* no iface with this packet, match fails */</span>
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-comment">/* Check by name or by IP address */</span>
	<span class="enscript-keyword">if</span> (cmd-&gt;name[0] != <span class="enscript-string">'\0'</span>) { <span class="enscript-comment">/* match by name */</span>
		<span class="enscript-comment">/* Check unit number (-1 is wildcard) */</span>
		<span class="enscript-keyword">if</span> (cmd-&gt;p.unit != -1 &amp;&amp; cmd-&gt;p.unit != ifp-&gt;if_unit)
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-comment">/* Check name */</span>
		<span class="enscript-keyword">if</span> (!strncmp(ifp-&gt;if_name, cmd-&gt;name, IFNAMSIZ))
			<span class="enscript-keyword">return</span>(1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ifaddr *ia;

		ifnet_lock_shared(ifp);
		TAILQ_FOREACH(ia, &amp;ifp-&gt;if_addrhead, ifa_link) {
			IFA_LOCK(ia);
			<span class="enscript-keyword">if</span> (ia-&gt;ifa_addr-&gt;sa_family != AF_INET) {
				IFA_UNLOCK(ia);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (cmd-&gt;p.ip.s_addr == ((<span class="enscript-type">struct</span> sockaddr_in *)
			    (ia-&gt;ifa_addr))-&gt;sin_addr.s_addr) {
				IFA_UNLOCK(ia);
				ifnet_lock_done(ifp);
				<span class="enscript-keyword">return</span>(1);	<span class="enscript-comment">/* match */</span>
			}
			IFA_UNLOCK(ia);
		}
		ifnet_lock_done(ifp);
	}
	<span class="enscript-keyword">return</span>(0);	<span class="enscript-comment">/* no match, fail ... */</span>
}

<span class="enscript-comment">/*
 * The 'verrevpath' option checks that the interface that an IP packet
 * arrives on is the same interface that traffic destined for the
 * packet's source address would be routed out of. This is a measure
 * to block forged packets. This is also commonly known as &quot;anti-spoofing&quot;
 * or Unicast Reverse Path Forwarding (Unicast RFP) in Cisco-ese. The
 * name of the knob is purposely reminisent of the Cisco IOS command,
 *
 *   ip verify unicast reverse-path
 *
 * which implements the same functionality. But note that syntax is
 * misleading. The check may be performed on all IP packets whether unicast,
 * multicast, or broadcast.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">verify_rev_path</span>(<span class="enscript-type">struct</span> in_addr src, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> route ro;
	<span class="enscript-type">struct</span> sockaddr_in *dst;

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
	dst = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;(ro.ro_dst);

	<span class="enscript-comment">/* Check if we've cached the route from the previous call. */</span>
	<span class="enscript-keyword">if</span> (src.s_addr != dst-&gt;sin_addr.s_addr) {
		dst-&gt;sin_family = AF_INET;
		dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*dst);
		dst-&gt;sin_addr = src;

		rtalloc_ign(&amp;ro, RTF_CLONING|RTF_PRCLONING);
	}
	<span class="enscript-keyword">if</span> (ro.ro_rt != NULL) {
		RT_LOCK_SPIN(ro.ro_rt);
	} <span class="enscript-keyword">else</span> {
		ROUTE_RELEASE(&amp;ro);
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* No route */</span>
	}
	<span class="enscript-keyword">if</span> ((ifp == NULL) ||
	    (ro.ro_rt-&gt;rt_ifp-&gt;if_index != ifp-&gt;if_index)) {
		RT_UNLOCK(ro.ro_rt);
		ROUTE_RELEASE(&amp;ro);
		<span class="enscript-keyword">return</span> 0;
        }
	RT_UNLOCK(ro.ro_rt);
	ROUTE_RELEASE(&amp;ro);
	<span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">static</span> u_int64_t norule_counter;	<span class="enscript-comment">/* counter for ipfw_log(NULL...) */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SNPARGS</span>(buf, len) buf + len, sizeof(buf) &gt; len ? sizeof(buf) - len : 0
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SNP</span>(buf) buf, sizeof(buf)

<span class="enscript-comment">/*
 * We enter here when we have a rule with O_LOG.
 * XXX this function alone takes about 2Kbytes of code!
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_log</span>(<span class="enscript-type">struct</span> ip_fw *f, u_int hlen, <span class="enscript-type">struct</span> ether_header *eh,
	<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *oif)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *action;
	<span class="enscript-type">int</span> limit_reached = 0;
	<span class="enscript-type">char</span> ipv4str[MAX_IPv4_STR_LEN];
	<span class="enscript-type">char</span> action2[40], proto[48], fragment[28];
	
	fragment[0] = <span class="enscript-string">'\0'</span>;
	proto[0] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (f == NULL) {	<span class="enscript-comment">/* bogus pkt */</span>
		<span class="enscript-keyword">if</span> (verbose_limit != 0 &amp;&amp; norule_counter &gt;= verbose_limit)
			<span class="enscript-keyword">return</span>;
		norule_counter++;
		<span class="enscript-keyword">if</span> (norule_counter == verbose_limit)
			limit_reached = verbose_limit;
		action = <span class="enscript-string">&quot;Refuse&quot;</span>;
	} <span class="enscript-keyword">else</span> {	<span class="enscript-comment">/* O_LOG is the first action, find the real one */</span>
		ipfw_insn *cmd = ACTION_PTR(f);
		ipfw_insn_log *l = (ipfw_insn_log *)cmd;

		<span class="enscript-keyword">if</span> (l-&gt;max_log != 0 &amp;&amp; l-&gt;log_left == 0)
			<span class="enscript-keyword">return</span>;
		l-&gt;log_left--;
		<span class="enscript-keyword">if</span> (l-&gt;log_left == 0)
			limit_reached = l-&gt;max_log;
		cmd += F_LEN(cmd);	<span class="enscript-comment">/* point to first action */</span>
		<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_PROB)
			cmd += F_LEN(cmd);

		action = action2;
		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
			action = <span class="enscript-string">&quot;Deny&quot;</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
			<span class="enscript-keyword">if</span> (cmd-&gt;arg1==ICMP_REJECT_RST)
				action = <span class="enscript-string">&quot;Reset&quot;</span>;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;arg1==ICMP_UNREACH_HOST)
				action = <span class="enscript-string">&quot;Reject&quot;</span>;
			<span class="enscript-keyword">else</span>
				snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Unreach %d&quot;</span>,
					cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
			action = <span class="enscript-string">&quot;Accept&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
			action = <span class="enscript-string">&quot;Count&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Divert %d&quot;</span>,
				cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Tee %d&quot;</span>,
				cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;SkipTo %d&quot;</span>,
				cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Pipe %d&quot;</span>,
				cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Queue %d&quot;</span>,
				cmd-&gt;arg1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>: {
			ipfw_insn_sa *sa = (ipfw_insn_sa *)cmd;
			<span class="enscript-type">int</span> len;

			<span class="enscript-keyword">if</span> (f-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
				<span class="enscript-keyword">break</span>;
			}
			len = snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Forward to %s&quot;</span>,
				inet_ntop(AF_INET, &amp;sa-&gt;sa.sin_addr, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">if</span> (sa-&gt;sa.sin_port)
				snprintf(SNPARGS(action2, len), <span class="enscript-string">&quot;:%d&quot;</span>,
				    sa-&gt;sa.sin_port);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			action = <span class="enscript-string">&quot;UNKNOWN&quot;</span>;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (hlen == 0) {	<span class="enscript-comment">/* non-ip */</span>
		snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;MAC&quot;</span>);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-comment">/* these three are all aliases to the same thing */</span>
		<span class="enscript-type">struct</span> icmp *<span class="enscript-type">const</span> icmp = L3HDR(<span class="enscript-type">struct</span> icmp, ip);
		<span class="enscript-type">struct</span> tcphdr *<span class="enscript-type">const</span> tcp = (<span class="enscript-type">struct</span> tcphdr *)icmp;
		<span class="enscript-type">struct</span> udphdr *<span class="enscript-type">const</span> udp = (<span class="enscript-type">struct</span> udphdr *)icmp;

		<span class="enscript-type">int</span> ip_off, offset, ip_len;

		<span class="enscript-type">int</span> len;

		<span class="enscript-keyword">if</span> (eh != NULL) { <span class="enscript-comment">/* layer 2 packets are as on the wire */</span>
			ip_off = ntohs(ip-&gt;ip_off);
			ip_len = ntohs(ip-&gt;ip_len);
		} <span class="enscript-keyword">else</span> {
			ip_off = ip-&gt;ip_off;
			ip_len = ip-&gt;ip_len;
		}
		offset = ip_off &amp; IP_OFFMASK;
		<span class="enscript-keyword">switch</span> (ip-&gt;ip_p) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;TCP %s&quot;</span>,
			    inet_ntop(AF_INET, &amp;ip-&gt;ip_src, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">if</span> (offset == 0)
				snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d %s:%d&quot;</span>,
				    ntohs(tcp-&gt;th_sport),
				    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)),
				    ntohs(tcp-&gt;th_dport));
			<span class="enscript-keyword">else</span>
				snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; %s&quot;</span>,
				    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;UDP %s&quot;</span>,
				inet_ntop(AF_INET, &amp;ip-&gt;ip_src, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">if</span> (offset == 0)
				snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d %s:%d&quot;</span>,
				    ntohs(udp-&gt;uh_sport),
				    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)),
				    ntohs(udp-&gt;uh_dport));
			<span class="enscript-keyword">else</span>
				snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; %s&quot;</span>,
				    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			<span class="enscript-keyword">if</span> (offset == 0)
				len = snprintf(SNPARGS(proto, 0),
				    <span class="enscript-string">&quot;ICMP:%u.%u &quot;</span>,
				    icmp-&gt;icmp_type, icmp-&gt;icmp_code);
			<span class="enscript-keyword">else</span>
				len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;ICMP &quot;</span>);
			len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;%s&quot;</span>,
			    inet_ntop(AF_INET, &amp;ip-&gt;ip_src, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; %s&quot;</span>,
			    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;P:%d %s&quot;</span>, ip-&gt;ip_p,
			    inet_ntop(AF_INET, &amp;ip-&gt;ip_src, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; %s&quot;</span>,
			    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, ipv4str, <span class="enscript-keyword">sizeof</span>(ipv4str)));
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (ip_off &amp; (IP_MF | IP_OFFMASK))
			snprintf(SNPARGS(fragment, 0), <span class="enscript-string">&quot; (frag %d:%d@%d%s)&quot;</span>,
			     ntohs(ip-&gt;ip_id), ip_len - (ip-&gt;ip_hl &lt;&lt; 2),
			     offset &lt;&lt; 3,
			     (ip_off &amp; IP_MF) ? <span class="enscript-string">&quot;+&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (oif || m-&gt;m_pkthdr.rcvif)
	{
		dolog((LOG_AUTHPRIV | LOG_INFO,
		    <span class="enscript-string">&quot;ipfw: %d %s %s %s via %s%d%s\n&quot;</span>,
		    f ? f-&gt;rulenum : -1,
		    action, proto, oif ? <span class="enscript-string">&quot;out&quot;</span> : <span class="enscript-string">&quot;in&quot;</span>,
		    oif ? oif-&gt;if_name : m-&gt;m_pkthdr.rcvif-&gt;if_name,
		    oif ? oif-&gt;if_unit : m-&gt;m_pkthdr.rcvif-&gt;if_unit,
		    fragment)); 
	}
	<span class="enscript-keyword">else</span>{
		dolog((LOG_AUTHPRIV | LOG_INFO,
		    <span class="enscript-string">&quot;ipfw: %d %s %s [no if info]%s\n&quot;</span>,
		    f ? f-&gt;rulenum : -1,
		    action, proto, fragment));
	}
	<span class="enscript-keyword">if</span> (limit_reached){
		dolog((LOG_AUTHPRIV | LOG_NOTICE,
		    <span class="enscript-string">&quot;ipfw: limit %d reached on entry %d\n&quot;</span>,
		    limit_reached, f ? f-&gt;rulenum : -1));
	}
}

<span class="enscript-comment">/*
 * IMPORTANT: the hash function for dynamic rules must be commutative
 * in source and destination (ip,port), because rules are bidirectional
 * and we want to find both in the same bucket.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">hash_packet</span>(<span class="enscript-type">struct</span> ip_flow_id *id)
{
	u_int32_t i;

	i = (id-&gt;dst_ip) ^ (id-&gt;src_ip) ^ (id-&gt;dst_port) ^ (id-&gt;src_port);
	i &amp;= (curr_dyn_buckets - 1);
	<span class="enscript-keyword">return</span> i;
}

<span class="enscript-comment">/**
 * unlink a dynamic rule from a chain. prev is a pointer to
 * the previous one, q is a pointer to the rule to delete,
 * head is a pointer to the head of the queue.
 * Modifies q and potentially also head.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">UNLINK_DYN_RULE</span>(prev, head, q) {				\
	ipfw_dyn_rule *old_q = q;					\
									\
	<span class="enscript-comment">/* remove a refcount to the parent */</span>				\
	<span class="enscript-keyword">if</span> (q-&gt;dyn_type == O_LIMIT)					\
		q-&gt;parent-&gt;count--;					\
	DEB(printf(<span class="enscript-string">&quot;ipfw: unlink entry 0x%08x %d -&gt; 0x%08x %d, %d left\n&quot;</span>,\
		(q-&gt;id.src_ip), (q-&gt;id.src_port),			\
		(q-&gt;id.dst_ip), (q-&gt;id.dst_port), dyn_count-1 ); )	\
	<span class="enscript-keyword">if</span> (prev != NULL)						\
		prev-&gt;next = q = q-&gt;next;				\
	<span class="enscript-keyword">else</span>								\
		head = q = q-&gt;next;					\
	dyn_count--;							\
	_FREE(old_q, M_IPFW); }

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIME_LEQ</span>(a,b)       ((int)((a)-(b)) &lt;= 0)

<span class="enscript-comment">/**
 * Remove dynamic rules pointing to &quot;rule&quot;, or all of them if rule == NULL.
 *
 * If keep_me == NULL, rules are deleted even if not expired,
 * otherwise only expired rules are removed.
 *
 * The value of the second parameter is also used to point to identify
 * a rule we absolutely do not want to remove (e.g. because we are
 * holding a reference to it -- this is the case with O_LIMIT_PARENT
 * rules). The pointer is only used for comparison, so any non-null
 * value will do.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">remove_dyn_rule</span>(<span class="enscript-type">struct</span> ip_fw *rule, ipfw_dyn_rule *keep_me)
{
	<span class="enscript-type">static</span> u_int32_t last_remove = 0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FORCE</span> (keep_me == NULL)

	ipfw_dyn_rule *prev, *q;
	<span class="enscript-type">int</span> i, pass = 0, max_pass = 0;
	<span class="enscript-type">struct</span> timeval timenow;

	getmicrotime(&amp;timenow);

	<span class="enscript-keyword">if</span> (ipfw_dyn_v == NULL || dyn_count == 0)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/* do not expire more than once per second, it is useless */</span>
	<span class="enscript-keyword">if</span> (!FORCE &amp;&amp; last_remove == timenow.tv_sec)
		<span class="enscript-keyword">return</span>;
	last_remove = timenow.tv_sec;

	<span class="enscript-comment">/*
	 * because O_LIMIT refer to parent rules, during the first pass only
	 * remove child and mark any pending LIMIT_PARENT, and remove
	 * them in a second pass.
	 */</span>
<span class="enscript-reference">next_pass</span>:
	<span class="enscript-keyword">for</span> (i = 0 ; i &lt; curr_dyn_buckets ; i++) {
		<span class="enscript-keyword">for</span> (prev=NULL, q = ipfw_dyn_v[i] ; q ; ) {
			<span class="enscript-comment">/*
			 * Logic can become complex here, so we split tests.
			 */</span>
			<span class="enscript-keyword">if</span> (q == keep_me)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			<span class="enscript-keyword">if</span> (rule != NULL &amp;&amp; rule != q-&gt;rule)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>; <span class="enscript-comment">/* not the one we are looking for */</span>
			<span class="enscript-keyword">if</span> (q-&gt;dyn_type == O_LIMIT_PARENT) {
				<span class="enscript-comment">/*
				 * handle parent in the second pass,
				 * record we need one.
				 */</span>
				max_pass = 1;
				<span class="enscript-keyword">if</span> (pass == 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
				<span class="enscript-keyword">if</span> (FORCE &amp;&amp; q-&gt;count != 0 ) {
					<span class="enscript-comment">/* XXX should not happen! */</span>
					printf(<span class="enscript-string">&quot;ipfw: OUCH! cannot remove rule,&quot;</span>
					     <span class="enscript-string">&quot; count %d\n&quot;</span>, q-&gt;count);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!FORCE &amp;&amp;
				    !TIME_LEQ( q-&gt;expire, timenow.tv_sec ))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
			<span class="enscript-keyword">if</span> (q-&gt;dyn_type != O_LIMIT_PARENT || !q-&gt;count) {
				UNLINK_DYN_RULE(prev, ipfw_dyn_v[i], q);
				<span class="enscript-keyword">continue</span>;
			}
<span class="enscript-reference">next</span>:
			prev=q;
			q=q-&gt;next;
		}
	}
	<span class="enscript-keyword">if</span> (pass++ &lt; max_pass)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_pass</span>;
}


<span class="enscript-comment">/**
 * lookup a dynamic rule.
 */</span>
<span class="enscript-type">static</span> ipfw_dyn_rule *
<span class="enscript-function-name">lookup_dyn_rule</span>(<span class="enscript-type">struct</span> ip_flow_id *pkt, <span class="enscript-type">int</span> *match_direction,
	<span class="enscript-type">struct</span> tcphdr *tcp)
{
	<span class="enscript-comment">/*
	 * stateful ipfw extensions.
	 * Lookup into dynamic session queue
	 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MATCH_REVERSE</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MATCH_FORWARD</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MATCH_NONE</span>	2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MATCH_UNKNOWN</span>	3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOTH_SYN</span>        (TH_SYN | (TH_SYN &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOTH_FIN</span>        (TH_FIN | (TH_FIN &lt;&lt; 8))

	<span class="enscript-type">int</span> i, dir = MATCH_NONE;
	ipfw_dyn_rule *prev, *q=NULL;
	<span class="enscript-type">struct</span> timeval timenow;

	getmicrotime(&amp;timenow);

	<span class="enscript-keyword">if</span> (ipfw_dyn_v == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;	<span class="enscript-comment">/* not found */</span>
	i = hash_packet( pkt );
	<span class="enscript-keyword">for</span> (prev=NULL, q = ipfw_dyn_v[i] ; q != NULL ; ) {
		<span class="enscript-keyword">if</span> (q-&gt;dyn_type == O_LIMIT_PARENT &amp;&amp; q-&gt;count)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		<span class="enscript-keyword">if</span> (TIME_LEQ( q-&gt;expire, timenow.tv_sec)) { <span class="enscript-comment">/* expire entry */</span>
                        <span class="enscript-type">int</span>     dounlink = 1;

			<span class="enscript-comment">/* check if entry is TCP */</span>
                        <span class="enscript-keyword">if</span> ( q-&gt;id.proto == IPPROTO_TCP )
                        {
                                <span class="enscript-comment">/* do not delete an established TCP connection which hasn't been closed by both sides */</span>
                                <span class="enscript-keyword">if</span> ( (q-&gt;state &amp; (BOTH_SYN | BOTH_FIN)) != (BOTH_SYN | BOTH_FIN) )
                                        dounlink = 0;
                        }
                        <span class="enscript-keyword">if</span> ( dounlink ){
                                UNLINK_DYN_RULE(prev, ipfw_dyn_v[i], q);
                                <span class="enscript-keyword">continue</span>;
                        }
		}
		<span class="enscript-keyword">if</span> (pkt-&gt;proto == q-&gt;id.proto &amp;&amp;
		    q-&gt;dyn_type != O_LIMIT_PARENT) {
			<span class="enscript-keyword">if</span> (pkt-&gt;src_ip == q-&gt;id.src_ip &amp;&amp;
			    pkt-&gt;dst_ip == q-&gt;id.dst_ip &amp;&amp;
			    pkt-&gt;src_port == q-&gt;id.src_port &amp;&amp;
			    pkt-&gt;dst_port == q-&gt;id.dst_port ) {
				dir = MATCH_FORWARD;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (pkt-&gt;src_ip == q-&gt;id.dst_ip &amp;&amp;
			    pkt-&gt;dst_ip == q-&gt;id.src_ip &amp;&amp;
			    pkt-&gt;src_port == q-&gt;id.dst_port &amp;&amp;
			    pkt-&gt;dst_port == q-&gt;id.src_port ) {
				dir = MATCH_REVERSE;
				<span class="enscript-keyword">break</span>;
			}
		}
<span class="enscript-reference">next</span>:
		prev = q;
		q = q-&gt;next;
	}
	<span class="enscript-keyword">if</span> (q == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; <span class="enscript-comment">/* q = NULL, not found */</span>

	<span class="enscript-keyword">if</span> ( prev != NULL) { <span class="enscript-comment">/* found and not in front */</span>
		prev-&gt;next = q-&gt;next;
		q-&gt;next = ipfw_dyn_v[i];
		ipfw_dyn_v[i] = q;
	}
	<span class="enscript-keyword">if</span> (pkt-&gt;proto == IPPROTO_TCP) { <span class="enscript-comment">/* update state according to flags */</span>
		u_char flags = pkt-&gt;flags &amp; (TH_FIN|TH_SYN|TH_RST);

		q-&gt;state |= (dir == MATCH_FORWARD ) ? flags : (flags &lt;&lt; 8);
		<span class="enscript-keyword">switch</span> (q-&gt;state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TH_SYN</span>:				<span class="enscript-comment">/* opening */</span>
			q-&gt;expire = timenow.tv_sec + dyn_syn_lifetime;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BOTH_SYN</span>:			<span class="enscript-comment">/* move to established */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BOTH_SYN</span> | TH_FIN :	<span class="enscript-comment">/* one side tries to close */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">BOTH_SYN</span> | (TH_FIN &lt;&lt; 8) :
 			<span class="enscript-keyword">if</span> (tcp) {
#<span class="enscript-reference">define</span> <span class="enscript-function-name">_SEQ_GE</span>(a,b) ((int)(a) - (int)(b) &gt;= 0)
			    u_int32_t ack = ntohl(tcp-&gt;th_ack);
			    <span class="enscript-keyword">if</span> (dir == MATCH_FORWARD) {
				<span class="enscript-keyword">if</span> (q-&gt;ack_fwd == 0 || _SEQ_GE(ack, q-&gt;ack_fwd))
				    q-&gt;ack_fwd = ack;
				<span class="enscript-keyword">else</span> { <span class="enscript-comment">/* ignore out-of-sequence */</span>
				    <span class="enscript-keyword">break</span>;
				}
			    } <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (q-&gt;ack_rev == 0 || _SEQ_GE(ack, q-&gt;ack_rev))
				    q-&gt;ack_rev = ack;
				<span class="enscript-keyword">else</span> { <span class="enscript-comment">/* ignore out-of-sequence */</span>
				    <span class="enscript-keyword">break</span>;
				}
			    }
			}
			q-&gt;expire = timenow.tv_sec + dyn_ack_lifetime;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">BOTH_SYN</span> | BOTH_FIN:	<span class="enscript-comment">/* both sides closed */</span>
			<span class="enscript-keyword">if</span> (dyn_fin_lifetime &gt;= dyn_keepalive_period)
				dyn_fin_lifetime = dyn_keepalive_period - 1;
			q-&gt;expire = timenow.tv_sec + dyn_fin_lifetime;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/*
			 * reset or some invalid combination, but can also
			 * occur if we use keep-state the wrong way.
			 */</span>
			<span class="enscript-keyword">if</span> ( (q-&gt;state &amp; ((TH_RST &lt;&lt; 8)|TH_RST)) == 0)
				printf(<span class="enscript-string">&quot;invalid state: 0x%x\n&quot;</span>, q-&gt;state);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (dyn_rst_lifetime &gt;= dyn_keepalive_period)
				dyn_rst_lifetime = dyn_keepalive_period - 1;
			q-&gt;expire = timenow.tv_sec + dyn_rst_lifetime;
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pkt-&gt;proto == IPPROTO_UDP) {
		q-&gt;expire = timenow.tv_sec + dyn_udp_lifetime;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* other protocols */</span>
		q-&gt;expire = timenow.tv_sec + dyn_short_lifetime;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (match_direction)
		*match_direction = dir;
	<span class="enscript-keyword">return</span> q;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">realloc_dynamic_table</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Try reallocation, make sure we have a power of 2 and do
	 * not allow more than 64k entries. In case of overflow,
	 * default to 1024.
	 */</span>

	<span class="enscript-keyword">if</span> (dyn_buckets &gt; 65536)
		dyn_buckets = 1024;
	<span class="enscript-keyword">if</span> ((dyn_buckets &amp; (dyn_buckets-1)) != 0) { <span class="enscript-comment">/* not a power of 2 */</span>
		dyn_buckets = curr_dyn_buckets; <span class="enscript-comment">/* reset */</span>
		<span class="enscript-keyword">return</span>;
	}
	curr_dyn_buckets = dyn_buckets;
	<span class="enscript-keyword">if</span> (ipfw_dyn_v != NULL)
		_FREE(ipfw_dyn_v, M_IPFW);
	<span class="enscript-keyword">for</span> (;;) {
		ipfw_dyn_v = _MALLOC(curr_dyn_buckets * <span class="enscript-keyword">sizeof</span>(ipfw_dyn_rule *),
		       M_IPFW, M_NOWAIT | M_ZERO);
		<span class="enscript-keyword">if</span> (ipfw_dyn_v != NULL || curr_dyn_buckets &lt;= 2)
			<span class="enscript-keyword">break</span>;
		curr_dyn_buckets /= 2;
	}
}

<span class="enscript-comment">/**
 * Install state of type 'type' for a dynamic session.
 * The hash table contains two type of rules:
 * - regular rules (O_KEEP_STATE)
 * - rules for sessions with limited number of sess per user
 *   (O_LIMIT). When they are created, the parent is
 *   increased by 1, and decreased on delete. In this case,
 *   the third parameter is the parent rule and not the chain.
 * - &quot;parent&quot; rules for the above (O_LIMIT_PARENT).
 */</span>
<span class="enscript-type">static</span> ipfw_dyn_rule *
<span class="enscript-function-name">add_dyn_rule</span>(<span class="enscript-type">struct</span> ip_flow_id *id, u_int8_t dyn_type, <span class="enscript-type">struct</span> ip_fw *rule)
{
	ipfw_dyn_rule *r;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> timeval timenow;

	getmicrotime(&amp;timenow);

	<span class="enscript-keyword">if</span> (ipfw_dyn_v == NULL ||
	    (dyn_count == 0 &amp;&amp; dyn_buckets != curr_dyn_buckets)) {
		realloc_dynamic_table();
		<span class="enscript-keyword">if</span> (ipfw_dyn_v == NULL)
			<span class="enscript-keyword">return</span> NULL; <span class="enscript-comment">/* failed ! */</span>
	}
	i = hash_packet(id);

	r = _MALLOC(<span class="enscript-keyword">sizeof</span> *r, M_IPFW, M_NOWAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (r == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW_DEBUG</span>
		printf (<span class="enscript-string">&quot;ipfw: sorry cannot allocate state\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-comment">/* increase refcount on parent, and set pointer */</span>
	<span class="enscript-keyword">if</span> (dyn_type == O_LIMIT) {
		ipfw_dyn_rule *parent = (ipfw_dyn_rule *)rule;
		<span class="enscript-keyword">if</span> ( parent-&gt;dyn_type != O_LIMIT_PARENT)
			panic(<span class="enscript-string">&quot;invalid parent&quot;</span>);
		parent-&gt;count++;
		r-&gt;parent = parent;
		rule = parent-&gt;rule;
	}

	r-&gt;id = *id;
	r-&gt;expire = timenow.tv_sec + dyn_syn_lifetime;
	r-&gt;rule = rule;
	r-&gt;dyn_type = dyn_type;
	r-&gt;pcnt = r-&gt;bcnt = 0;
	r-&gt;count = 0;

	r-&gt;bucket = i;
	r-&gt;next = ipfw_dyn_v[i];
	ipfw_dyn_v[i] = r;
	dyn_count++;
	DEB(printf(<span class="enscript-string">&quot;ipfw: add dyn entry ty %d 0x%08x %d -&gt; 0x%08x %d, total %d\n&quot;</span>,
	   dyn_type,
	   (r-&gt;id.src_ip), (r-&gt;id.src_port),
	   (r-&gt;id.dst_ip), (r-&gt;id.dst_port),
	   dyn_count ); )
	<span class="enscript-keyword">return</span> r;
}

<span class="enscript-comment">/**
 * lookup dynamic parent rule using pkt and rule as search keys.
 * If the lookup fails, then install one.
 */</span>
<span class="enscript-type">static</span> ipfw_dyn_rule *
<span class="enscript-function-name">lookup_dyn_parent</span>(<span class="enscript-type">struct</span> ip_flow_id *pkt, <span class="enscript-type">struct</span> ip_fw *rule)
{
	ipfw_dyn_rule *q;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> timeval timenow;

	getmicrotime(&amp;timenow);

	<span class="enscript-keyword">if</span> (ipfw_dyn_v) {
		i = hash_packet( pkt );
		<span class="enscript-keyword">for</span> (q = ipfw_dyn_v[i] ; q != NULL ; q=q-&gt;next)
			<span class="enscript-keyword">if</span> (q-&gt;dyn_type == O_LIMIT_PARENT &amp;&amp;
			    rule== q-&gt;rule &amp;&amp;
			    pkt-&gt;proto == q-&gt;id.proto &amp;&amp;
			    pkt-&gt;src_ip == q-&gt;id.src_ip &amp;&amp;
			    pkt-&gt;dst_ip == q-&gt;id.dst_ip &amp;&amp;
			    pkt-&gt;src_port == q-&gt;id.src_port &amp;&amp;
			    pkt-&gt;dst_port == q-&gt;id.dst_port) {
				q-&gt;expire = timenow.tv_sec + dyn_short_lifetime;
				DEB(printf(<span class="enscript-string">&quot;ipfw: lookup_dyn_parent found &quot;</span>
				    <span class="enscript-string">&quot;0x%llx\n&quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(q));)
				<span class="enscript-keyword">return</span> q;
			}
	}
	<span class="enscript-keyword">return</span> add_dyn_rule(pkt, O_LIMIT_PARENT, rule);
}

<span class="enscript-comment">/**
 * Install dynamic state for rule type cmd-&gt;o.opcode
 *
 * Returns 1 (failure) if state is not installed because of errors or because
 * session limitations are enforced.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">install_state</span>(<span class="enscript-type">struct</span> ip_fw *rule, ipfw_insn_limit *cmd,
	<span class="enscript-type">struct</span> ip_fw_args *args)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> last_log;
	<span class="enscript-type">struct</span> timeval timenow;

	ipfw_dyn_rule *q;
	getmicrotime(&amp;timenow);

	DEB(printf(<span class="enscript-string">&quot;ipfw: install state type %d 0x%08x %u -&gt; 0x%08x %u\n&quot;</span>,
	    cmd-&gt;o.opcode,
	    (args-&gt;fwa_id.src_ip), (args-&gt;fwa_id.src_port),
	    (args-&gt;fwa_id.dst_ip), (args-&gt;fwa_id.dst_port) );)

	q = lookup_dyn_rule(&amp;args-&gt;fwa_id, NULL, NULL);

	<span class="enscript-keyword">if</span> (q != NULL) { <span class="enscript-comment">/* should never occur */</span>
		<span class="enscript-keyword">if</span> (last_log != timenow.tv_sec) {
			last_log = timenow.tv_sec;
			printf(<span class="enscript-string">&quot;ipfw: install_state: entry already present, done\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (dyn_count &gt;= dyn_max)
		<span class="enscript-comment">/*
		 * Run out of slots, try to remove any expired rule.
		 */</span>
		remove_dyn_rule(NULL, (ipfw_dyn_rule *)1);

	<span class="enscript-keyword">if</span> (dyn_count &gt;= dyn_max) {
		<span class="enscript-keyword">if</span> (last_log != timenow.tv_sec) {
			last_log = timenow.tv_sec;
			printf(<span class="enscript-string">&quot;ipfw: install_state: Too many dynamic rules\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> 1; <span class="enscript-comment">/* cannot install, notify caller */</span>
	}

	<span class="enscript-keyword">switch</span> (cmd-&gt;o.opcode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>: <span class="enscript-comment">/* bidir rule */</span>
		add_dyn_rule(&amp;args-&gt;fwa_id, O_KEEP_STATE, rule);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LIMIT</span>: <span class="enscript-comment">/* limit number of sessions */</span>
	    {
		u_int16_t limit_mask = cmd-&gt;limit_mask;
		<span class="enscript-type">struct</span> ip_flow_id id;
		ipfw_dyn_rule *parent;

		DEB(printf(<span class="enscript-string">&quot;ipfw: installing dyn-limit rule %d\n&quot;</span>,
		    cmd-&gt;conn_limit);)

		id.dst_ip = id.src_ip = 0;
		id.dst_port = id.src_port = 0;
		id.proto = args-&gt;fwa_id.proto;

		<span class="enscript-keyword">if</span> (limit_mask &amp; DYN_SRC_ADDR)
			id.src_ip = args-&gt;fwa_id.src_ip;
		<span class="enscript-keyword">if</span> (limit_mask &amp; DYN_DST_ADDR)
			id.dst_ip = args-&gt;fwa_id.dst_ip;
		<span class="enscript-keyword">if</span> (limit_mask &amp; DYN_SRC_PORT)
			id.src_port = args-&gt;fwa_id.src_port;
		<span class="enscript-keyword">if</span> (limit_mask &amp; DYN_DST_PORT)
			id.dst_port = args-&gt;fwa_id.dst_port;
		parent = lookup_dyn_parent(&amp;id, rule);
		<span class="enscript-keyword">if</span> (parent == NULL) {
			printf(<span class="enscript-string">&quot;ipfw: add parent failed\n&quot;</span>);
			<span class="enscript-keyword">return</span> 1;
		}
		<span class="enscript-keyword">if</span> (parent-&gt;count &gt;= cmd-&gt;conn_limit) {
			<span class="enscript-comment">/*
			 * See if we can remove some expired rule.
			 */</span>
			remove_dyn_rule(rule, parent);
			<span class="enscript-keyword">if</span> (parent-&gt;count &gt;= cmd-&gt;conn_limit) {
				<span class="enscript-keyword">if</span> (fw_verbose &amp;&amp; last_log != timenow.tv_sec) {
					last_log = timenow.tv_sec;
					dolog((LOG_AUTHPRIV | LOG_DEBUG,
					    <span class="enscript-string">&quot;drop session, too many entries\n&quot;</span>));
				}
				<span class="enscript-keyword">return</span> 1;
			}
		}
		add_dyn_rule(&amp;args-&gt;fwa_id, O_LIMIT, (<span class="enscript-type">struct</span> ip_fw *)parent);
	    }
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;ipfw: unknown dynamic rule type %u\n&quot;</span>, cmd-&gt;o.opcode);
		<span class="enscript-keyword">return</span> 1;
	}
	lookup_dyn_rule(&amp;args-&gt;fwa_id, NULL, NULL); <span class="enscript-comment">/* XXX just set lifetime */</span>
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Generate a TCP packet, containing either a RST or a keepalive.
 * When flags &amp; TH_RST, we are sending a RST packet, because of a
 * &quot;reset&quot; action matched the packet.
 * Otherwise we are sending a keepalive, and flags &amp; TH_
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">send_pkt</span>(<span class="enscript-type">struct</span> ip_flow_id *id, u_int32_t seq, u_int32_t ack, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> tcphdr *tcp;

	MGETHDR(m, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
	<span class="enscript-keyword">if</span> (m == 0)
		<span class="enscript-keyword">return</span> NULL;
	m-&gt;m_pkthdr.rcvif = (<span class="enscript-type">struct</span> ifnet *)0;
	m-&gt;m_pkthdr.len = m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr);
	m-&gt;m_data += max_linkhdr;

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	bzero(ip, m-&gt;m_len);
	tcp = (<span class="enscript-type">struct</span> tcphdr *)(ip + 1); <span class="enscript-comment">/* no IP options */</span>
	ip-&gt;ip_p = IPPROTO_TCP;
	tcp-&gt;th_off = 5;
	<span class="enscript-comment">/*
	 * Assume we are sending a RST (or a keepalive in the reverse
	 * direction), swap src and destination addresses and ports.
	 */</span>
	ip-&gt;ip_src.s_addr = htonl(id-&gt;dst_ip);
	ip-&gt;ip_dst.s_addr = htonl(id-&gt;src_ip);
	tcp-&gt;th_sport = htons(id-&gt;dst_port);
	tcp-&gt;th_dport = htons(id-&gt;src_port);
	<span class="enscript-keyword">if</span> (flags &amp; TH_RST) {	<span class="enscript-comment">/* we are sending a RST */</span>
		<span class="enscript-keyword">if</span> (flags &amp; TH_ACK) {
			tcp-&gt;th_seq = htonl(ack);
			tcp-&gt;th_ack = htonl(0);
			tcp-&gt;th_flags = TH_RST;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (flags &amp; TH_SYN)
				seq++;
			tcp-&gt;th_seq = htonl(0);
			tcp-&gt;th_ack = htonl(seq);
			tcp-&gt;th_flags = TH_RST | TH_ACK;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We are sending a keepalive. flags &amp; TH_SYN determines
		 * the direction, forward if set, reverse if clear.
		 * NOTE: seq and ack are always assumed to be correct
		 * as set by the caller. This may be confusing...
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; TH_SYN) {
			<span class="enscript-comment">/*
			 * we have to rewrite the correct addresses!
			 */</span>
			ip-&gt;ip_dst.s_addr = htonl(id-&gt;dst_ip);
			ip-&gt;ip_src.s_addr = htonl(id-&gt;src_ip);
			tcp-&gt;th_dport = htons(id-&gt;dst_port);
			tcp-&gt;th_sport = htons(id-&gt;src_port);
		}
		tcp-&gt;th_seq = htonl(seq);
		tcp-&gt;th_ack = htonl(ack);
		tcp-&gt;th_flags = TH_ACK;
	}
	<span class="enscript-comment">/*
	 * set ip_len to the payload size so we can compute
	 * the tcp checksum on the pseudoheader
	 * XXX check this, could save a couple of words ?
	 */</span>
	ip-&gt;ip_len = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr));
	tcp-&gt;th_sum = in_cksum(m, m-&gt;m_pkthdr.len);
	<span class="enscript-comment">/*
	 * now fill fields left out earlier
	 */</span>
	ip-&gt;ip_ttl = ip_defttl;
	ip-&gt;ip_len = m-&gt;m_pkthdr.len;
	m-&gt;m_flags |= M_SKIP_FIREWALL;
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * sends a reject message, consuming the mbuf passed as an argument.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">send_reject</span>(<span class="enscript-type">struct</span> ip_fw_args *args, <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> offset, __unused <span class="enscript-type">int</span> ip_len)
{

	<span class="enscript-keyword">if</span> (code != ICMP_REJECT_RST) { <span class="enscript-comment">/* Send an ICMP unreach */</span>
		<span class="enscript-comment">/* We need the IP header in host order for icmp_error(). */</span>
		<span class="enscript-keyword">if</span> (args-&gt;fwa_eh != NULL) {
			<span class="enscript-type">struct</span> ip *ip = mtod(args-&gt;fwa_m, <span class="enscript-type">struct</span> ip *);
			ip-&gt;ip_len = ntohs(ip-&gt;ip_len);
			ip-&gt;ip_off = ntohs(ip-&gt;ip_off);
		}
		args-&gt;fwa_m-&gt;m_flags |= M_SKIP_FIREWALL;
		icmp_error(args-&gt;fwa_m, ICMP_UNREACH, code, 0L, 0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset == 0 &amp;&amp; args-&gt;fwa_id.proto == IPPROTO_TCP) {
		<span class="enscript-type">struct</span> tcphdr *<span class="enscript-type">const</span> tcp =
		    L3HDR(<span class="enscript-type">struct</span> tcphdr, mtod(args-&gt;fwa_m, <span class="enscript-type">struct</span> ip *));
		<span class="enscript-keyword">if</span> ( (tcp-&gt;th_flags &amp; TH_RST) == 0) {
			<span class="enscript-type">struct</span> mbuf *m;

			m = send_pkt(&amp;(args-&gt;fwa_id), ntohl(tcp-&gt;th_seq),
				ntohl(tcp-&gt;th_ack),
				tcp-&gt;th_flags | TH_RST);
			<span class="enscript-keyword">if</span> (m != NULL) {
				<span class="enscript-type">struct</span> route sro;	<span class="enscript-comment">/* fake route */</span>

				bzero (&amp;sro, <span class="enscript-keyword">sizeof</span> (sro));
				ip_output(m, NULL, &amp;sro, 0, NULL, NULL);
				ROUTE_RELEASE(&amp;sro);
			}
		}
		m_freem(args-&gt;fwa_m);
	} <span class="enscript-keyword">else</span>
		m_freem(args-&gt;fwa_m);
	args-&gt;fwa_m = NULL;
}

<span class="enscript-comment">/**
 *
 * Given an ip_fw *, lookup_next_rule will return a pointer
 * to the next rule, which can be either the jump
 * target (for skipto instructions) or the next one in the list (in
 * all other cases including a missing jump target).
 * The result is also written in the &quot;next_rule&quot; field of the rule.
 * Backward jumps are not allowed, so start looking from the next
 * rule...
 *
 * This never returns NULL -- in case we do not have an exact match,
 * the next rule is returned. When the ruleset is changed,
 * pointers are flushed so we are always correct.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip_fw *
<span class="enscript-function-name">lookup_next_rule</span>(<span class="enscript-type">struct</span> ip_fw *me)
{
	<span class="enscript-type">struct</span> ip_fw *rule = NULL;
	ipfw_insn *cmd;

	<span class="enscript-comment">/* look for action, in case it is a skipto */</span>
	cmd = ACTION_PTR(me);
	<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_LOG)
		cmd += F_LEN(cmd);
	<span class="enscript-keyword">if</span> ( cmd-&gt;opcode == O_SKIPTO )
		<span class="enscript-keyword">for</span> (rule = me-&gt;next; rule ; rule = rule-&gt;next)
			<span class="enscript-keyword">if</span> (rule-&gt;rulenum &gt;= cmd-&gt;arg1)
				<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> (rule == NULL)			<span class="enscript-comment">/* failure or not a skipto */</span>
		rule = me-&gt;next;
	me-&gt;next_rule = rule;
	<span class="enscript-keyword">return</span> rule;
}

<span class="enscript-comment">/*
 * The main check routine for the firewall.
 *
 * All arguments are in args so we can modify them and return them
 * back to the caller.
 *
 * Parameters:
 *
 *	args-&gt;fwa_m	(in/out) The packet; we set to NULL when/if we nuke it.
 *		Starts with the IP header.
 *	args-&gt;fwa_eh (in)	Mac header if present, or NULL for layer3 packet.
 *	args-&gt;fwa_oif	Outgoing interface, or NULL if packet is incoming.
 *		The incoming interface is in the mbuf. (in)
 *	args-&gt;fwa_divert_rule (in/out)
 *		Skip up to the first rule past this rule number;
 *		upon return, non-zero port number for divert or tee.
 *
 *	args-&gt;fwa_ipfw_rule	Pointer to the last matching rule (in/out)
 *	args-&gt;fwa_next_hop	Socket we are forwarding to (out).
 *	args-&gt;fwa_id	Addresses grabbed from the packet (out)
 *
 * Return value:
 *
 *	IP_FW_PORT_DENY_FLAG	the packet must be dropped.
 *	0	The packet is to be accepted and routed normally OR
 *      	the packet was denied/rejected and has been dropped;
 *		in the latter case, *m is equal to NULL upon return.
 *	port	Divert the packet to port, with these caveats:
 *
 *		- If IP_FW_PORT_TEE_FLAG is set, tee the packet instead
 *		  of diverting it (ie, 'ipfw tee').
 *
 *		- If IP_FW_PORT_DYNT_FLAG is set, interpret the lower
 *		  16 bits as a dummynet pipe number instead of diverting
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_chk</span>(<span class="enscript-type">struct</span> ip_fw_args *args)
{
	<span class="enscript-comment">/*
	 * Local variables hold state during the processing of a packet.
	 *
	 * IMPORTANT NOTE: to speed up the processing of rules, there
	 * are some assumption on the values of the variables, which
	 * are documented here. Should you change them, please check
	 * the implementation of the various instructions to make sure
	 * that they still work.
	 *
	 * args-&gt;fwa_eh	The MAC header. It is non-null for a layer2
	 *	packet, it is NULL for a layer-3 packet.
	 *
	 * m | args-&gt;fwa_m	Pointer to the mbuf, as received from the caller.
	 *	It may change if ipfw_chk() does an m_pullup, or if it
	 *	consumes the packet because it calls send_reject().
	 *	XXX This has to change, so that ipfw_chk() never modifies
	 *	or consumes the buffer.
	 * ip	is simply an alias of the value of m, and it is kept
	 *	in sync with it (the packet is	supposed to start with
	 *	the ip header).
	 */</span>
	<span class="enscript-type">struct</span> mbuf *m = args-&gt;fwa_m;
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	<span class="enscript-comment">/*
	 * oif | args-&gt;fwa_oif	If NULL, ipfw_chk has been called on the
	 *	inbound path (ether_input, bdg_forward, ip_input).
	 *	If non-NULL, ipfw_chk has been called on the outbound path
	 *	(ether_output, ip_output).
	 */</span>
	<span class="enscript-type">struct</span> ifnet *oif = args-&gt;fwa_oif;

	<span class="enscript-type">struct</span> ip_fw *f = NULL;		<span class="enscript-comment">/* matching rule */</span>
	<span class="enscript-type">int</span> retval = 0;

	<span class="enscript-comment">/*
	 * hlen	The length of the IPv4 header.
	 *	hlen &gt;0 means we have an IPv4 packet.
	 */</span>
	u_int hlen = 0;		<span class="enscript-comment">/* hlen &gt;0 means we have an IP pkt */</span>

	<span class="enscript-comment">/*
	 * offset	The offset of a fragment. offset != 0 means that
	 *	we have a fragment at this offset of an IPv4 packet.
	 *	offset == 0 means that (if this is an IPv4 packet)
	 *	this is the first or only fragment.
	 */</span>
	u_short offset = 0;

	<span class="enscript-comment">/*
	 * Local copies of addresses. They are only valid if we have
	 * an IP packet.
	 *
	 * proto	The protocol. Set to 0 for non-ip packets,
	 *	or to the protocol read from the packet otherwise.
	 *	proto != 0 means that we have an IPv4 packet.
	 *
	 * src_port, dst_port	port numbers, in HOST format. Only
	 *	valid for TCP and UDP packets.
	 *
	 * src_ip, dst_ip	ip addresses, in NETWORK format.
	 *	Only valid for IPv4 packets.
	 */</span>
	u_int8_t proto;
	u_int16_t src_port = 0, dst_port = 0;	<span class="enscript-comment">/* NOTE: host format	*/</span>
	<span class="enscript-type">struct</span> in_addr src_ip = { 0 } , dst_ip = { 0 };		<span class="enscript-comment">/* NOTE: network format	*/</span>
	u_int16_t ip_len=0;
	<span class="enscript-type">int</span> pktlen;
	<span class="enscript-type">int</span> dyn_dir = MATCH_UNKNOWN;
	ipfw_dyn_rule *q = NULL;
	<span class="enscript-type">struct</span> timeval timenow;

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_SKIP_FIREWALL || fw_bypass) {
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* accept */</span>
	}

	<span class="enscript-comment">/* 
	 * Clear packet chain if we find one here.
	 */</span>
	
	<span class="enscript-keyword">if</span> (m-&gt;m_nextpkt != NULL) {
		m_freem_list(m-&gt;m_nextpkt);
		m-&gt;m_nextpkt = NULL;
	}
	
	lck_mtx_lock(ipfw_mutex);

	getmicrotime(&amp;timenow);
	<span class="enscript-comment">/*
	 * dyn_dir = MATCH_UNKNOWN when rules unchecked,
	 * 	MATCH_NONE when checked and not matched (q = NULL),
	 *	MATCH_FORWARD or MATCH_REVERSE otherwise (q != NULL)
	 */</span>

	pktlen = m-&gt;m_pkthdr.len;
	<span class="enscript-keyword">if</span> (args-&gt;fwa_eh == NULL ||		<span class="enscript-comment">/* layer 3 packet */</span>
		( m-&gt;m_pkthdr.len &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &amp;&amp;
		    ntohs(args-&gt;fwa_eh-&gt;ether_type) == ETHERTYPE_IP))
			hlen = ip-&gt;ip_hl &lt;&lt; 2;

	<span class="enscript-comment">/*
	 * Collect parameters into local variables for faster matching.
	 */</span>
	<span class="enscript-keyword">if</span> (hlen == 0) {	<span class="enscript-comment">/* do not grab addresses for non-ip pkts */</span>
		proto = args-&gt;fwa_id.proto = 0;	<span class="enscript-comment">/* mark f_id invalid */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">after_ip_checks</span>;
	}

	proto = args-&gt;fwa_id.proto = ip-&gt;ip_p;
	src_ip = ip-&gt;ip_src;
	dst_ip = ip-&gt;ip_dst;
	<span class="enscript-keyword">if</span> (args-&gt;fwa_eh != NULL) { <span class="enscript-comment">/* layer 2 packets are as on the wire */</span>
		offset = ntohs(ip-&gt;ip_off) &amp; IP_OFFMASK;
		ip_len = ntohs(ip-&gt;ip_len);
	} <span class="enscript-keyword">else</span> {
		offset = ip-&gt;ip_off &amp; IP_OFFMASK;
		ip_len = ip-&gt;ip_len;
	}
	pktlen = ip_len &lt; pktlen ? ip_len : pktlen;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PULLUP_TO</span>(len)						\
		<span class="enscript-keyword">do</span> {						\
			<span class="enscript-keyword">if</span> ((m)-&gt;m_len &lt; (len)) {		\
			    args-&gt;fwa_m = m = m_pullup(m, (len));	\
			    <span class="enscript-keyword">if</span> (m == 0)				\
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">pullup_failed</span>;		\
			    ip = mtod(m, <span class="enscript-type">struct</span> ip *);		\
			}					\
		} <span class="enscript-keyword">while</span> (0)

	<span class="enscript-keyword">if</span> (offset == 0) {
		<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		    {
			<span class="enscript-type">struct</span> tcphdr *tcp;

			PULLUP_TO(hlen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr));
			tcp = L3HDR(<span class="enscript-type">struct</span> tcphdr, ip);
			dst_port = tcp-&gt;th_dport;
			src_port = tcp-&gt;th_sport;
			args-&gt;fwa_id.flags = tcp-&gt;th_flags;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		    {
			<span class="enscript-type">struct</span> udphdr *udp;

			PULLUP_TO(hlen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
			udp = L3HDR(<span class="enscript-type">struct</span> udphdr, ip);
			dst_port = udp-&gt;uh_dport;
			src_port = udp-&gt;uh_sport;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
			PULLUP_TO(hlen + 4);	<span class="enscript-comment">/* type, code and checksum. */</span>
			args-&gt;fwa_id.flags = L3HDR(<span class="enscript-type">struct</span> icmp, ip)-&gt;icmp_type;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">PULLUP_TO</span>
	}

	args-&gt;fwa_id.src_ip = ntohl(src_ip.s_addr);
	args-&gt;fwa_id.dst_ip = ntohl(dst_ip.s_addr);
	args-&gt;fwa_id.src_port = src_port = ntohs(src_port);
	args-&gt;fwa_id.dst_port = dst_port = ntohs(dst_port);

<span class="enscript-reference">after_ip_checks</span>:
	<span class="enscript-keyword">if</span> (args-&gt;fwa_ipfw_rule) {
		<span class="enscript-comment">/*
		 * Packet has already been tagged. Look for the next rule
		 * to restart processing.
		 *
		 * If fw_one_pass != 0 then just accept it.
		 * XXX should not happen here, but optimized out in
		 * the caller.
		 */</span>
		<span class="enscript-keyword">if</span> (fw_one_pass) {
			lck_mtx_unlock(ipfw_mutex);
			<span class="enscript-keyword">return</span> 0;
		}

		f = args-&gt;fwa_ipfw_rule-&gt;next_rule;
		<span class="enscript-keyword">if</span> (f == NULL)
			f = lookup_next_rule(args-&gt;fwa_ipfw_rule);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Find the starting rule. It can be either the first
		 * one, or the one after divert_rule if asked so.
		 */</span>
		<span class="enscript-type">int</span> skipto = args-&gt;fwa_divert_rule;

		f = layer3_chain;
		<span class="enscript-keyword">if</span> (args-&gt;fwa_eh == NULL &amp;&amp; skipto != 0) {
			<span class="enscript-keyword">if</span> (skipto &gt;= IPFW_DEFAULT_RULE) {
				lck_mtx_unlock(ipfw_mutex);
				<span class="enscript-keyword">return</span>(IP_FW_PORT_DENY_FLAG); <span class="enscript-comment">/* invalid */</span>
			}
			<span class="enscript-keyword">while</span> (f &amp;&amp; f-&gt;rulenum &lt;= skipto)
				f = f-&gt;next;
			<span class="enscript-keyword">if</span> (f == NULL) {	<span class="enscript-comment">/* drop packet */</span>
				lck_mtx_unlock(ipfw_mutex);
				<span class="enscript-keyword">return</span>(IP_FW_PORT_DENY_FLAG);
			}
		}
	}
	args-&gt;fwa_divert_rule = 0;	<span class="enscript-comment">/* reset to avoid confusion later */</span>

	<span class="enscript-comment">/*
	 * Now scan the rules, and parse microinstructions for each rule.
	 */</span>
	<span class="enscript-keyword">for</span> (; f; f = f-&gt;next) {
		<span class="enscript-type">int</span> l, cmdlen;
		ipfw_insn *cmd;
		<span class="enscript-type">int</span> skip_or; <span class="enscript-comment">/* skip rest of OR block */</span>

<span class="enscript-reference">again</span>:
		<span class="enscript-keyword">if</span> (f-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-keyword">if</span> (set_disable &amp; (1 &lt;&lt; f-&gt;set) )
			<span class="enscript-keyword">continue</span>;

		skip_or = 0;
		<span class="enscript-keyword">for</span> (l = f-&gt;cmd_len, cmd = f-&gt;cmd ; l &gt; 0 ;
		    l -= cmdlen, cmd += cmdlen) {
			<span class="enscript-type">int</span> match;

			<span class="enscript-comment">/*
			 * check_body is a jump target used when we find a
			 * CHECK_STATE, and need to jump to the body of
			 * the target rule.
			 */</span>

<span class="enscript-reference">check_body</span>:
			cmdlen = F_LEN(cmd);
			<span class="enscript-comment">/*
			 * An OR block (insn_1 || .. || insn_n) has the
			 * F_OR bit set in all but the last instruction.
			 * The first match will set &quot;skip_or&quot;, and cause
			 * the following instructions to be skipped until
			 * past the one with the F_OR bit clear.
			 */</span>
			<span class="enscript-keyword">if</span> (skip_or) {		<span class="enscript-comment">/* skip this instruction */</span>
				<span class="enscript-keyword">if</span> ((cmd-&gt;len &amp; F_OR) == 0)
					skip_or = 0;	<span class="enscript-comment">/* next one is good */</span>
				<span class="enscript-keyword">continue</span>;
			}
			match = 0; <span class="enscript-comment">/* set to 1 if we succeed */</span>

			<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-comment">/*
			 * The first set of opcodes compares the packet's
			 * fields with some pattern, setting 'match' if a
			 * match is found. At the end of the loop there is
			 * logic to deal with F_NOT and F_OR flags associated
			 * with the opcode.
			 */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_NOP</span>:
				match = 1;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_MAC</span>:
				printf(<span class="enscript-string">&quot;ipfw: opcode %d unimplemented\n&quot;</span>,
				    cmd-&gt;opcode);
				<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_GID</span>:
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_UID</span>:
				<span class="enscript-comment">/*
				 * We only check offset == 0 &amp;&amp; proto != 0,
				 * as this ensures that we have an IPv4
				 * packet with the ports info.
				 */</span>
				<span class="enscript-keyword">if</span> (offset!=0)
					<span class="enscript-keyword">break</span>;
					
			    {
				<span class="enscript-type">struct</span> inpcbinfo *pi;
				<span class="enscript-type">int</span> wildcard;
				<span class="enscript-type">struct</span> inpcb *pcb;

				<span class="enscript-keyword">if</span> (proto == IPPROTO_TCP) {
					wildcard = 0;
					pi = &amp;tcbinfo;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (proto == IPPROTO_UDP) {
					wildcard = 1;
					pi = &amp;udbinfo;
				} <span class="enscript-keyword">else</span>
					<span class="enscript-keyword">break</span>;

				pcb =  (oif) ?
					in_pcblookup_hash(pi,
					    dst_ip, htons(dst_port),
					    src_ip, htons(src_port),
					    wildcard, oif) :
					in_pcblookup_hash(pi,
					    src_ip, htons(src_port),
					    dst_ip, htons(dst_port),
					    wildcard, NULL);

				<span class="enscript-keyword">if</span> (pcb == NULL || pcb-&gt;inp_socket == NULL) 
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__FreeBSD_version</span> &lt; 500034
#<span class="enscript-reference">define</span> <span class="enscript-function-name">socheckuid</span>(a,b)	(kauth_cred_getuid((a)-&gt;so_cred) != (b))
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_UID) {
					match = 
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
						(kauth_cred_getuid(pcb-&gt;inp_socket-&gt;so_cred) == (uid_t)((ipfw_insn_u32 *)cmd)-&gt;d[0]);
#<span class="enscript-reference">else</span>
						!socheckuid(pcb-&gt;inp_socket,
						   (uid_t)((ipfw_insn_u32 *)cmd)-&gt;d[0]);
#<span class="enscript-reference">endif</span>
				} 
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
				<span class="enscript-keyword">else</span>  {
					match = 0;
					kauth_cred_ismember_gid(pcb-&gt;inp_socket-&gt;so_cred, 
						(gid_t)((ipfw_insn_u32 *)cmd)-&gt;d[0], &amp;match);
				}
#<span class="enscript-reference">endif</span>
				<span class="enscript-comment">/* release reference on pcb */</span>
				in_pcb_checkstate(pcb, WNT_RELEASE, 0);
				}

			<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RECV</span>:
				match = iface_match(m-&gt;m_pkthdr.rcvif,
				    (ipfw_insn_if *)cmd);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_XMIT</span>:
				match = iface_match(oif, (ipfw_insn_if *)cmd);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VIA</span>:
				match = iface_match(oif ? oif :
				    m-&gt;m_pkthdr.rcvif, (ipfw_insn_if *)cmd);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MACADDR2</span>:
				<span class="enscript-keyword">if</span> (args-&gt;fwa_eh != NULL) {	<span class="enscript-comment">/* have MAC header */</span>
					u_int32_t *want = (u_int32_t *)
						((ipfw_insn_mac *)cmd)-&gt;addr;
					u_int32_t *mask = (u_int32_t *)
						((ipfw_insn_mac *)cmd)-&gt;mask;
					u_int32_t *hdr = (u_int32_t *)args-&gt;fwa_eh;

					match =
					    ( want[0] == (hdr[0] &amp; mask[0]) &amp;&amp;
					      want[1] == (hdr[1] &amp; mask[1]) &amp;&amp;
					      want[2] == (hdr[2] &amp; mask[2]) );
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MAC_TYPE</span>:
				<span class="enscript-keyword">if</span> (args-&gt;fwa_eh != NULL) {
					u_int16_t t =
					    ntohs(args-&gt;fwa_eh-&gt;ether_type);
					u_int16_t *p =
					    ((ipfw_insn_u16 *)cmd)-&gt;ports;
					<span class="enscript-type">int</span> i;

					<span class="enscript-keyword">for</span> (i = cmdlen - 1; !match &amp;&amp; i&gt;0;
					    i--, p += 2)
						match = (t&gt;=p[0] &amp;&amp; t&lt;=p[1]);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FRAG</span>:
				match = (hlen &gt; 0 &amp;&amp; offset != 0);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IN</span>:	<span class="enscript-comment">/* &quot;out&quot; is &quot;not in&quot; */</span>
				match = (oif == NULL);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LAYER2</span>:
				match = (args-&gt;fwa_eh != NULL);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROTO</span>:
				<span class="enscript-comment">/*
				 * We do not allow an arg of 0 so the
				 * check of &quot;proto&quot; only suffices.
				 */</span>
				match = (proto == cmd-&gt;arg1);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC</span>:
				match = (hlen &gt; 0 &amp;&amp;
				    ((ipfw_insn_ip *)cmd)-&gt;addr.s_addr ==
				    src_ip.s_addr);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_MASK</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_MASK</span>:
				<span class="enscript-keyword">if</span> (hlen &gt; 0) {
				    uint32_t a =
					(cmd-&gt;opcode == O_IP_DST_MASK) ?
					    dst_ip.s_addr : src_ip.s_addr;
				    uint32_t *p = ((ipfw_insn_u32 *)cmd)-&gt;d;
				    <span class="enscript-type">int</span> i = cmdlen-1;

				    <span class="enscript-keyword">for</span> (; !match &amp;&amp; i&gt;0; i-= 2, p+= 2)
					match = (p[0] == (a &amp; p[1]));
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_ME</span>:
				<span class="enscript-keyword">if</span> (hlen &gt; 0) {
					<span class="enscript-type">struct</span> ifnet *tif;

					INADDR_TO_IFP(src_ip, tif);
					match = (tif != NULL);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_SET</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_SET</span>:
				<span class="enscript-keyword">if</span> (hlen &gt; 0) {
					u_int32_t *d = (u_int32_t *)(cmd+1);
					u_int32_t addr =
					    cmd-&gt;opcode == O_IP_DST_SET ?
						args-&gt;fwa_id.dst_ip :
						args-&gt;fwa_id.src_ip;

					    <span class="enscript-keyword">if</span> (addr &lt; d[0])
						    <span class="enscript-keyword">break</span>;
					    addr -= d[0]; <span class="enscript-comment">/* subtract base */</span>
					    match = (addr &lt; cmd-&gt;arg1) &amp;&amp;
						( d[ 1 + (addr&gt;&gt;5)] &amp;
						  (1&lt;&lt;(addr &amp; 0x1f)) );
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST</span>:
				match = (hlen &gt; 0 &amp;&amp;
				    ((ipfw_insn_ip *)cmd)-&gt;addr.s_addr ==
				    dst_ip.s_addr);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_ME</span>:
				<span class="enscript-keyword">if</span> (hlen &gt; 0) {
					<span class="enscript-type">struct</span> ifnet *tif;

					INADDR_TO_IFP(dst_ip, tif);
					match = (tif != NULL);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRCPORT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DSTPORT</span>:
				<span class="enscript-comment">/*
				 * offset == 0 &amp;&amp; proto != 0 is enough
				 * to guarantee that we have an IPv4
				 * packet with port info.
				 */</span>
				<span class="enscript-keyword">if</span> ((proto==IPPROTO_UDP || proto==IPPROTO_TCP)
				    &amp;&amp; offset == 0) {
					u_int16_t x =
					    (cmd-&gt;opcode == O_IP_SRCPORT) ?
						src_port : dst_port ;
					u_int16_t *p =
					    ((ipfw_insn_u16 *)cmd)-&gt;ports;
					<span class="enscript-type">int</span> i;

					<span class="enscript-keyword">for</span> (i = cmdlen - 1; !match &amp;&amp; i&gt;0;
					    i--, p += 2)
						match = (x&gt;=p[0] &amp;&amp; x&lt;=p[1]);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ICMPTYPE</span>:
				match = (offset == 0 &amp;&amp; proto==IPPROTO_ICMP &amp;&amp;
				    icmptype_match(ip, (ipfw_insn_u32 *)cmd) );
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPOPT</span>:
				match = (hlen &gt; 0 &amp;&amp; ipopts_match(ip, cmd) );
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPVER</span>:
				match = (hlen &gt; 0 &amp;&amp; cmd-&gt;arg1 == ip-&gt;ip_v);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPID</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPLEN</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTTL</span>:
				<span class="enscript-keyword">if</span> (hlen &gt; 0) {	<span class="enscript-comment">/* only for IP packets */</span>
				    uint16_t x;
				    uint16_t *p;
				    <span class="enscript-type">int</span> i;

				    <span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_IPLEN)
					x = ip_len;
				    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_IPTTL)
					x = ip-&gt;ip_ttl;
				    <span class="enscript-keyword">else</span> <span class="enscript-comment">/* must be IPID */</span>
					x = ntohs(ip-&gt;ip_id);
				    <span class="enscript-keyword">if</span> (cmdlen == 1) {
					match = (cmd-&gt;arg1 == x);
					<span class="enscript-keyword">break</span>;
				    }
				    <span class="enscript-comment">/* otherwise we have ranges */</span>
				    p = ((ipfw_insn_u16 *)cmd)-&gt;ports;
				    i = cmdlen - 1;
				    <span class="enscript-keyword">for</span> (; !match &amp;&amp; i&gt;0; i--, p += 2)
					match = (x &gt;= p[0] &amp;&amp; x &lt;= p[1]);
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPPRECEDENCE</span>:
				match = (hlen &gt; 0 &amp;&amp;
				    (cmd-&gt;arg1 == (ip-&gt;ip_tos &amp; 0xe0)) );
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTOS</span>:
				match = (hlen &gt; 0 &amp;&amp;
				    flags_match(cmd, ip-&gt;ip_tos));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPFLAGS</span>:
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    flags_match(cmd,
					L3HDR(<span class="enscript-type">struct</span> tcphdr,ip)-&gt;th_flags));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPOPTS</span>:
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    tcpopts_match(ip, cmd));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPSEQ</span>:
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    ((ipfw_insn_u32 *)cmd)-&gt;d[0] ==
					L3HDR(<span class="enscript-type">struct</span> tcphdr,ip)-&gt;th_seq);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPACK</span>:
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    ((ipfw_insn_u32 *)cmd)-&gt;d[0] ==
					L3HDR(<span class="enscript-type">struct</span> tcphdr,ip)-&gt;th_ack);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPWIN</span>:
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    cmd-&gt;arg1 ==
					L3HDR(<span class="enscript-type">struct</span> tcphdr,ip)-&gt;th_win);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ESTAB</span>:
				<span class="enscript-comment">/* reject packets which have SYN only */</span>
				<span class="enscript-comment">/* XXX should i also check for TH_ACK ? */</span>
				match = (proto == IPPROTO_TCP &amp;&amp; offset == 0 &amp;&amp;
				    (L3HDR(<span class="enscript-type">struct</span> tcphdr,ip)-&gt;th_flags &amp;
				     (TH_RST | TH_ACK | TH_SYN)) != TH_SYN);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
				<span class="enscript-keyword">if</span> (fw_verbose)
					ipfw_log(f, hlen, args-&gt;fwa_eh, m, oif);
				match = 1;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROB</span>:
				match = (random()&lt;((ipfw_insn_u32 *)cmd)-&gt;d[0]);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VERREVPATH</span>:
				<span class="enscript-comment">/* Outgoing packets automatically pass/match */</span>
				match = ((oif != NULL) ||
				    (m-&gt;m_pkthdr.rcvif == NULL) ||
				    verify_rev_path(src_ip, m-&gt;m_pkthdr.rcvif));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPSEC</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">FAST_IPSEC</span>
				match = (m_tag_find(m,
				    PACKET_TAG_IPSEC_IN_DONE, NULL) != NULL);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPSEC</span>
				match = (ipsec_gethist(m, NULL) != NULL);
#<span class="enscript-reference">endif</span>
				<span class="enscript-comment">/* otherwise no match */</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * The second set of opcodes represents 'actions',
			 * i.e. the terminal part of a rule once the packet
			 * matches all previous patterns.
			 * Typically there is only one action for each rule,
			 * and the opcode is stored at the end of the rule
			 * (but there are exceptions -- see below).
			 *
			 * In general, here we set retval and terminate the
			 * outer loop (would be a 'break 3' in some language,
			 * but we need to do a 'goto done').
			 *
			 * Exceptions:
			 * O_COUNT and O_SKIPTO actions:
			 *   instead of terminating, we jump to the next rule
			 *   ('goto next_rule', equivalent to a 'break 2'),
			 *   or to the SKIPTO target ('goto again' after
			 *   having set f, cmd and l), respectively.
			 *
			 * O_LIMIT and O_KEEP_STATE: these opcodes are
			 *   not real 'actions', and are stored right
			 *   before the 'action' part of the rule.
			 *   These opcodes try to install an entry in the
			 *   state tables; if successful, we continue with
			 *   the next opcode (match=1; break;), otherwise
			 *   the packet *   must be dropped
			 *   ('goto done' after setting retval);
			 *
			 * O_PROBE_STATE and O_CHECK_STATE: these opcodes
			 *   cause a lookup of the state table, and a jump
			 *   to the 'action' part of the parent rule
			 *   ('goto check_body') if an entry is found, or
			 *   (CHECK_STATE only) a jump to the next rule if
			 *   the entry is not found ('goto next_rule').
			 *   The result of the lookup is cached to make
			 *   further instances of these opcodes are
			 *   effectively NOPs.
			 */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
				<span class="enscript-keyword">if</span> (install_state(f,
				    (ipfw_insn_limit *)cmd, args)) {
					retval = IP_FW_PORT_DENY_FLAG;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; <span class="enscript-comment">/* error/limit violation */</span>
				}
				match = 1;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROBE_STATE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_CHECK_STATE</span>:
				<span class="enscript-comment">/*
				 * dynamic rules are checked at the first
				 * keep-state or check-state occurrence,
				 * with the result being stored in dyn_dir.
				 * The compiler introduces a PROBE_STATE
				 * instruction for us when we have a
				 * KEEP_STATE (because PROBE_STATE needs
				 * to be run first).
				 */</span>
				<span class="enscript-keyword">if</span> (dyn_dir == MATCH_UNKNOWN &amp;&amp;
				    (q = lookup_dyn_rule(&amp;args-&gt;fwa_id,
				     &amp;dyn_dir, proto == IPPROTO_TCP ?
					L3HDR(<span class="enscript-type">struct</span> tcphdr, ip) : NULL))
					!= NULL) {
					<span class="enscript-comment">/*
					 * Found dynamic entry, update stats
					 * and jump to the 'action' part of
					 * the parent rule.
					 */</span>
					q-&gt;pcnt++;
					q-&gt;bcnt += pktlen;
					f = q-&gt;rule;
					cmd = ACTION_PTR(f);
					l = f-&gt;cmd_len - f-&gt;act_ofs;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_body</span>;
				}
				<span class="enscript-comment">/*
				 * Dynamic entry not found. If CHECK_STATE,
				 * skip to next rule, if PROBE_STATE just
				 * ignore and continue with next opcode.
				 */</span>
				<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_CHECK_STATE)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_rule</span>;
				match = 1;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
				retval = 0;	<span class="enscript-comment">/* accept */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
				args-&gt;fwa_ipfw_rule = f; <span class="enscript-comment">/* report matching rule */</span>
				retval = cmd-&gt;arg1 | IP_FW_PORT_DYNT_FLAG;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
				<span class="enscript-keyword">if</span> (args-&gt;fwa_eh) <span class="enscript-comment">/* not on layer 2 */</span>
					<span class="enscript-keyword">break</span>;
				args-&gt;fwa_divert_rule = f-&gt;rulenum;
				retval = (cmd-&gt;opcode == O_DIVERT) ?
				    cmd-&gt;arg1 :
				    cmd-&gt;arg1 | IP_FW_PORT_TEE_FLAG;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
				f-&gt;pcnt++;	<span class="enscript-comment">/* update stats */</span>
				f-&gt;bcnt += pktlen;
				f-&gt;timestamp = timenow.tv_sec;
				<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_COUNT)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_rule</span>;
				<span class="enscript-comment">/* handle skipto */</span>
				<span class="enscript-keyword">if</span> (f-&gt;next_rule == NULL)
					lookup_next_rule(f);
				f = f-&gt;next_rule;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
				<span class="enscript-comment">/*
				 * Drop the packet and send a reject notice
				 * if the packet is not ICMP (or is an ICMP
				 * query), and it is not multicast/broadcast.
				 */</span>
				<span class="enscript-keyword">if</span> (hlen &gt; 0 &amp;&amp; offset == 0 &amp;&amp;
				    (proto != IPPROTO_ICMP ||
				     is_icmp_query(ip)) &amp;&amp;
				    !(m-&gt;m_flags &amp; (M_BCAST|M_MCAST)) &amp;&amp;
				    !IN_MULTICAST(dst_ip.s_addr)) {
					send_reject(args, cmd-&gt;arg1,
					    offset,ip_len);
					m = args-&gt;fwa_m;
				}
				<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
				retval = IP_FW_PORT_DENY_FLAG;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
				<span class="enscript-keyword">if</span> (args-&gt;fwa_eh)	<span class="enscript-comment">/* not valid on layer2 pkts */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (!q || dyn_dir == MATCH_FORWARD)
					args-&gt;fwa_next_hop =
					    &amp;((ipfw_insn_sa *)cmd)-&gt;sa;
				retval = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;-- unknown opcode %d\n&quot;</span>, cmd-&gt;opcode);
			} <span class="enscript-comment">/* end of switch() on opcodes */</span>

			<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_NOT)
				match = !match;

			<span class="enscript-keyword">if</span> (match) {
				<span class="enscript-keyword">if</span> (cmd-&gt;len &amp; F_OR)
					skip_or = 1;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!(cmd-&gt;len &amp; F_OR)) <span class="enscript-comment">/* not an OR block, */</span>
					<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* try next rule    */</span>
			}

		}	<span class="enscript-comment">/* end of inner for, scan opcodes */</span>

<span class="enscript-reference">next_rule</span>:;		<span class="enscript-comment">/* try next rule		*/</span>

	}		<span class="enscript-comment">/* end of outer for, scan rules */</span>
	printf(<span class="enscript-string">&quot;ipfw: ouch!, skip past end of rules, denying packet\n&quot;</span>);
	lck_mtx_unlock(ipfw_mutex);
	<span class="enscript-keyword">return</span>(IP_FW_PORT_DENY_FLAG);

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* Update statistics */</span>
	f-&gt;pcnt++;
	f-&gt;bcnt += pktlen;
	f-&gt;timestamp = timenow.tv_sec;
	lck_mtx_unlock(ipfw_mutex);
	<span class="enscript-keyword">return</span> retval;

<span class="enscript-reference">pullup_failed</span>:
	<span class="enscript-keyword">if</span> (fw_verbose)
		printf(<span class="enscript-string">&quot;ipfw: pullup failed\n&quot;</span>);
	lck_mtx_unlock(ipfw_mutex);
	<span class="enscript-keyword">return</span>(IP_FW_PORT_DENY_FLAG);
}

<span class="enscript-comment">/*
 * When a rule is added/deleted, clear the next_rule pointers in all rules.
 * These will be reconstructed on the fly as packets are matched.
 * Must be called at splimp().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flush_rule_ptrs</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ip_fw *rule;

	<span class="enscript-keyword">for</span> (rule = layer3_chain; rule; rule = rule-&gt;next)
		rule-&gt;next_rule = NULL;
}

<span class="enscript-comment">/*
 * When pipes/queues are deleted, clear the &quot;pipe_ptr&quot; pointer to a given
 * pipe/queue, or to all of them (match == NULL).
 * Must be called at splimp().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">flush_pipe_ptrs</span>(<span class="enscript-type">struct</span> dn_flow_set *match)
{
	<span class="enscript-type">struct</span> ip_fw *rule;

	<span class="enscript-keyword">for</span> (rule = layer3_chain; rule; rule = rule-&gt;next) {
		ipfw_insn_pipe *cmd = (ipfw_insn_pipe *)ACTION_PTR(rule);

		<span class="enscript-keyword">if</span> (cmd-&gt;o.opcode != O_PIPE &amp;&amp; cmd-&gt;o.opcode != O_QUEUE)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/*
		 * XXX Use bcmp/bzero to handle pipe_ptr to overcome
		 * possible alignment problems on 64-bit architectures.
		 * This code is seldom used so we do not worry too
		 * much about efficiency.
		 */</span>
		<span class="enscript-keyword">if</span> (match == NULL ||
		    !bcmp(&amp;cmd-&gt;pipe_ptr, &amp;match, <span class="enscript-keyword">sizeof</span>(match)) )
			bzero(&amp;cmd-&gt;pipe_ptr, <span class="enscript-keyword">sizeof</span>(cmd-&gt;pipe_ptr));
	}
}

<span class="enscript-comment">/*
 * Add a new rule to the list. Copy the rule into a malloc'ed area, then
 * possibly create a rule number and add the rule to the list.
 * Update the rule_number in the input struct so the caller knows it as well.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">add_rule</span>(<span class="enscript-type">struct</span> ip_fw **head, <span class="enscript-type">struct</span> ip_fw *input_rule)
{
	<span class="enscript-type">struct</span> ip_fw *rule, *f, *prev;
	<span class="enscript-type">int</span> l = RULESIZE(input_rule);

	<span class="enscript-keyword">if</span> (*head == NULL &amp;&amp; input_rule-&gt;rulenum != IPFW_DEFAULT_RULE)
		<span class="enscript-keyword">return</span> (EINVAL);

	rule = _MALLOC(l, M_IPFW, M_WAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (rule == NULL) {
		printf(<span class="enscript-string">&quot;ipfw2: add_rule MALLOC failed\n&quot;</span>);
		<span class="enscript-keyword">return</span> (ENOSPC);
	}
	
	bcopy(input_rule, rule, l);

	rule-&gt;next = NULL;
	rule-&gt;next_rule = NULL;

	rule-&gt;pcnt = 0;
	rule-&gt;bcnt = 0;
	rule-&gt;timestamp = 0;

	<span class="enscript-keyword">if</span> (*head == NULL) {	<span class="enscript-comment">/* default rule */</span>
		*head = rule;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }

	<span class="enscript-comment">/*
	 * If rulenum is 0, find highest numbered rule before the
	 * default rule, and add autoinc_step
	 */</span>
	<span class="enscript-keyword">if</span> (autoinc_step &lt; 1)
		autoinc_step = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (autoinc_step &gt; 1000)
		autoinc_step = 1000;
	<span class="enscript-keyword">if</span> (rule-&gt;rulenum == 0) {
		<span class="enscript-comment">/*
		 * locate the highest numbered rule before default
		 */</span>
		<span class="enscript-keyword">for</span> (f = *head; f; f = f-&gt;next) {
			<span class="enscript-keyword">if</span> (f-&gt;rulenum == IPFW_DEFAULT_RULE)
				<span class="enscript-keyword">break</span>;
			rule-&gt;rulenum = f-&gt;rulenum;
		}
		<span class="enscript-keyword">if</span> (rule-&gt;rulenum &lt; IPFW_DEFAULT_RULE - autoinc_step)
			rule-&gt;rulenum += autoinc_step;
		input_rule-&gt;rulenum = rule-&gt;rulenum;
	}

	<span class="enscript-comment">/*
	 * Now insert the new rule in the right place in the sorted list.
	 */</span>
	<span class="enscript-keyword">for</span> (prev = NULL, f = *head; f; prev = f, f = f-&gt;next) {
		<span class="enscript-keyword">if</span> (f-&gt;rulenum &gt; rule-&gt;rulenum) { <span class="enscript-comment">/* found the location */</span>
			<span class="enscript-keyword">if</span> (prev) {
				rule-&gt;next = f;
				prev-&gt;next = rule;
			} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* head insert */</span>
				rule-&gt;next = *head;
				*head = rule;
			}
			<span class="enscript-keyword">break</span>;
		}
	}
	flush_rule_ptrs();
<span class="enscript-reference">done</span>:
	static_count++;
	static_len += l;
	static_len_32 += RULESIZE32(input_rule);
	static_len_64 += RULESIZE64(input_rule);
	DEB(printf(<span class="enscript-string">&quot;ipfw: installed rule %d, static count now %d\n&quot;</span>,
		rule-&gt;rulenum, static_count);)
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/**
 * Free storage associated with a static rule (including derived
 * dynamic rules).
 * The caller is in charge of clearing rule pointers to avoid
 * dangling pointers.
 * @return a pointer to the next entry.
 * Arguments are not checked, so they better be correct.
 * Must be called at splimp().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip_fw *
<span class="enscript-function-name">delete_rule</span>(<span class="enscript-type">struct</span> ip_fw **head, <span class="enscript-type">struct</span> ip_fw *prev, <span class="enscript-type">struct</span> ip_fw *rule)
{
	<span class="enscript-type">struct</span> ip_fw *n;
	<span class="enscript-type">int</span> l = RULESIZE(rule);

	n = rule-&gt;next;
	remove_dyn_rule(rule, NULL <span class="enscript-comment">/* force removal */</span>);
	<span class="enscript-keyword">if</span> (prev == NULL)
		*head = n;
	<span class="enscript-keyword">else</span>
		prev-&gt;next = n;
	static_count--;
	static_len -= l;
	static_len_32 -= RULESIZE32(rule);
	static_len_64 -= RULESIZE64(rule);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (DUMMYNET_LOADED)
		dn_ipfw_rule_delete(rule);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	_FREE(rule, M_IPFW);
	<span class="enscript-keyword">return</span> n;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_INACTIVE_RULES</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">print_chain</span>(<span class="enscript-type">struct</span> ip_fw **chain)
{
	<span class="enscript-type">struct</span> ip_fw *rule = *chain;
	
	<span class="enscript-keyword">for</span> (; rule; rule = rule-&gt;next) {
		ipfw_insn	*cmd = ACTION_PTR(rule);
		
		printf(<span class="enscript-string">&quot;ipfw: rule-&gt;rulenum = %d\n&quot;</span>, rule-&gt;rulenum);
		
		<span class="enscript-keyword">if</span> (rule-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
			printf(<span class="enscript-string">&quot;ipfw: rule-&gt;reserved = IPFW_RULE_INACTIVE\n&quot;</span>);
		}
		
		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Deny\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
				<span class="enscript-keyword">if</span> (cmd-&gt;arg1==ICMP_REJECT_RST)
					printf(<span class="enscript-string">&quot;ipfw: ACTION: Reset\n&quot;</span>);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;arg1==ICMP_UNREACH_HOST)
					printf(<span class="enscript-string">&quot;ipfw: ACTION: Reject\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
	
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Accept\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Count\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Divert\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Tee\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: SkipTo\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Pipe\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Queue\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
				printf(<span class="enscript-string">&quot;ipfw: ACTION: Forward\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;ipfw: invalid action! %d\n&quot;</span>, cmd-&gt;opcode);
		}
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG_INACTIVE_RULES */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">flush_inactive</span>(<span class="enscript-type">void</span> *param)
{
	<span class="enscript-type">struct</span> ip_fw *inactive_rule = (<span class="enscript-type">struct</span> ip_fw *)param;
	<span class="enscript-type">struct</span> ip_fw *rule, *prev;
	
	lck_mtx_lock(ipfw_mutex);
	
	<span class="enscript-keyword">for</span> (rule = layer3_chain, prev = NULL; rule; ) {
		<span class="enscript-keyword">if</span> (rule == inactive_rule &amp;&amp; rule-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
			<span class="enscript-type">struct</span> ip_fw *n = rule;
			
			<span class="enscript-keyword">if</span> (prev == NULL) {
				layer3_chain = rule-&gt;next;
			}
			<span class="enscript-keyword">else</span> {
				prev-&gt;next = rule-&gt;next;
			}
			rule = rule-&gt;next;
			_FREE(n, M_IPFW);
		}
		<span class="enscript-keyword">else</span> {
			prev = rule;
			rule = rule-&gt;next;
		}
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_INACTIVE_RULES</span>
	print_chain(&amp;layer3_chain);
#<span class="enscript-reference">endif</span>
	lck_mtx_unlock(ipfw_mutex);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mark_inactive</span>(<span class="enscript-type">struct</span> ip_fw **prev, <span class="enscript-type">struct</span> ip_fw **rule)
{
	<span class="enscript-type">int</span> 			l = RULESIZE(*rule);

	<span class="enscript-keyword">if</span> ((*rule)-&gt;reserved_1 != IPFW_RULE_INACTIVE) {
		(*rule)-&gt;reserved_1 = IPFW_RULE_INACTIVE;
		static_count--;
		static_len -= l;
		static_len_32 -= RULESIZE32(*rule);
		static_len_64 -= RULESIZE64(*rule);
		
		timeout(flush_inactive, *rule, 30*hz); <span class="enscript-comment">/* 30 sec. */</span>
	}
	
	*prev = *rule;
	*rule = (*rule)-&gt;next;
}

<span class="enscript-comment">/*
 * Deletes all rules from a chain (except rules in set RESVD_SET
 * unless kill_default = 1).
 * Must be called at splimp().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">free_chain</span>(<span class="enscript-type">struct</span> ip_fw **chain, <span class="enscript-type">int</span> kill_default)
{
	<span class="enscript-type">struct</span> ip_fw *prev, *rule;

	flush_rule_ptrs(); <span class="enscript-comment">/* more efficient to do outside the loop */</span>
	<span class="enscript-keyword">for</span> (prev = NULL, rule = *chain; rule ; )
		<span class="enscript-keyword">if</span> (kill_default || rule-&gt;set != RESVD_SET) {
			ipfw_insn	*cmd = ACTION_PTR(rule);
			
			<span class="enscript-comment">/* skip over forwarding rules so struct isn't 
			 * deleted while pointer is still in use elsewhere
			 */</span>
			<span class="enscript-keyword">if</span> (cmd-&gt;opcode == O_FORWARD_IP) {
				mark_inactive(&amp;prev, &amp;rule);
			}
			<span class="enscript-keyword">else</span> {
				rule = delete_rule(chain, prev, rule);
			}
		}
		<span class="enscript-keyword">else</span> {
			prev = rule;
			rule = rule-&gt;next;
		}
}

<span class="enscript-comment">/**
 * Remove all rules with given number, and also do set manipulation.
 * Assumes chain != NULL &amp;&amp; *chain != NULL.
 *
 * The argument is an u_int32_t. The low 16 bit are the rule or set number,
 * the next 8 bits are the new set, the top 8 bits are the command:
 *
 *	0	delete rules with given number
 *	1	delete rules with given set number
 *	2	move rules with given number to new set
 *	3	move rules with given set number to new set
 *	4	swap sets with given numbers
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">del_entry</span>(<span class="enscript-type">struct</span> ip_fw **chain, u_int32_t arg)
{
	<span class="enscript-type">struct</span> ip_fw *prev = NULL, *rule = *chain;
	u_int16_t rulenum;	<span class="enscript-comment">/* rule or old_set */</span>
	u_int8_t cmd, new_set;

	rulenum = arg &amp; 0xffff;
	cmd = (arg &gt;&gt; 24) &amp; 0xff;
	new_set = (arg &gt;&gt; 16) &amp; 0xff;

	<span class="enscript-keyword">if</span> (cmd &gt; 4)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (new_set &gt; RESVD_SET)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (cmd == 0 || cmd == 2) {
		<span class="enscript-keyword">if</span> (rulenum &gt;= IPFW_DEFAULT_RULE)
			<span class="enscript-keyword">return</span> EINVAL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (rulenum &gt; RESVD_SET)	<span class="enscript-comment">/* old_set */</span>
			<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:	<span class="enscript-comment">/* delete rules with given number */</span>
		<span class="enscript-comment">/*
		 * locate first rule to delete
		 */</span>
		<span class="enscript-keyword">for</span> (; rule-&gt;rulenum &lt; rulenum; prev = rule, rule = rule-&gt;next)
			;
		<span class="enscript-keyword">if</span> (rule-&gt;rulenum != rulenum)
			<span class="enscript-keyword">return</span> EINVAL;

		<span class="enscript-comment">/*
		 * flush pointers outside the loop, then delete all matching
		 * rules. prev remains the same throughout the cycle.
		 */</span>
		flush_rule_ptrs();
		<span class="enscript-keyword">while</span> (rule-&gt;rulenum == rulenum) {
			ipfw_insn	*insn = ACTION_PTR(rule);
			
			<span class="enscript-comment">/* keep forwarding rules around so struct isn't 
			 * deleted while pointer is still in use elsewhere
			 */</span>
			<span class="enscript-keyword">if</span> (insn-&gt;opcode == O_FORWARD_IP) {
				mark_inactive(&amp;prev, &amp;rule);
			}
			<span class="enscript-keyword">else</span> {
				rule = delete_rule(chain, prev, rule);
			}
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:	<span class="enscript-comment">/* delete all rules with given set number */</span>
		flush_rule_ptrs();
		<span class="enscript-keyword">while</span> (rule-&gt;rulenum &lt; IPFW_DEFAULT_RULE) {
			<span class="enscript-keyword">if</span> (rule-&gt;set == rulenum) {
				ipfw_insn	*insn = ACTION_PTR(rule);
				
				<span class="enscript-comment">/* keep forwarding rules around so struct isn't 
				 * deleted while pointer is still in use elsewhere
				 */</span>
				<span class="enscript-keyword">if</span> (insn-&gt;opcode == O_FORWARD_IP) {
					mark_inactive(&amp;prev, &amp;rule);
				}
				<span class="enscript-keyword">else</span> {
					rule = delete_rule(chain, prev, rule);
				}
			}
			<span class="enscript-keyword">else</span> {
				prev = rule;
				rule = rule-&gt;next;
			}
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:	<span class="enscript-comment">/* move rules with given number to new set */</span>
		<span class="enscript-keyword">for</span> (; rule-&gt;rulenum &lt; IPFW_DEFAULT_RULE; rule = rule-&gt;next)
			<span class="enscript-keyword">if</span> (rule-&gt;rulenum == rulenum)
				rule-&gt;set = new_set;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>: <span class="enscript-comment">/* move rules with given set number to new set */</span>
		<span class="enscript-keyword">for</span> (; rule-&gt;rulenum &lt; IPFW_DEFAULT_RULE; rule = rule-&gt;next)
			<span class="enscript-keyword">if</span> (rule-&gt;set == rulenum)
				rule-&gt;set = new_set;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>: <span class="enscript-comment">/* swap two sets */</span>
		<span class="enscript-keyword">for</span> (; rule-&gt;rulenum &lt; IPFW_DEFAULT_RULE; rule = rule-&gt;next)
			<span class="enscript-keyword">if</span> (rule-&gt;set == rulenum)
				rule-&gt;set = new_set;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rule-&gt;set == new_set)
				rule-&gt;set = rulenum;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Clear counters for a specific rule.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">clear_counters</span>(<span class="enscript-type">struct</span> ip_fw *rule, <span class="enscript-type">int</span> log_only)
{
	ipfw_insn_log *l = (ipfw_insn_log *)ACTION_PTR(rule);

	<span class="enscript-keyword">if</span> (log_only == 0) {
		rule-&gt;bcnt = rule-&gt;pcnt = 0;
		rule-&gt;timestamp = 0;
	}
	<span class="enscript-keyword">if</span> (l-&gt;o.opcode == O_LOG)
		l-&gt;log_left = l-&gt;max_log;
}

<span class="enscript-comment">/**
 * Reset some or all counters on firewall rules.
 * @arg frwl is null to clear all entries, or contains a specific
 * rule number.
 * @arg log_only is 1 if we only want to reset logs, zero otherwise.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">zero_entry</span>(<span class="enscript-type">int</span> rulenum, <span class="enscript-type">int</span> log_only)
{
	<span class="enscript-type">struct</span> ip_fw *rule;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg;

	<span class="enscript-keyword">if</span> (rulenum == 0) {
		norule_counter = 0;
		<span class="enscript-keyword">for</span> (rule = layer3_chain; rule; rule = rule-&gt;next)
			clear_counters(rule, log_only);
		msg = log_only ? <span class="enscript-string">&quot;ipfw: All logging counts reset.\n&quot;</span> :
				<span class="enscript-string">&quot;ipfw: Accounting cleared.\n&quot;</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> cleared = 0;
		<span class="enscript-comment">/*
		 * We can have multiple rules with the same number, so we
		 * need to clear them all.
		 */</span>
		<span class="enscript-keyword">for</span> (rule = layer3_chain; rule; rule = rule-&gt;next)
			<span class="enscript-keyword">if</span> (rule-&gt;rulenum == rulenum) {
				<span class="enscript-keyword">while</span> (rule &amp;&amp; rule-&gt;rulenum == rulenum) {
					clear_counters(rule, log_only);
					rule = rule-&gt;next;
				}
				cleared = 1;
				<span class="enscript-keyword">break</span>;
			}
		<span class="enscript-keyword">if</span> (!cleared)	<span class="enscript-comment">/* we did not find any matching rules */</span>
			<span class="enscript-keyword">return</span> (EINVAL);
		msg = log_only ? <span class="enscript-string">&quot;ipfw: Entry %d logging count reset.\n&quot;</span> :
				<span class="enscript-string">&quot;ipfw: Entry %d cleared.\n&quot;</span>;
	}
	<span class="enscript-keyword">if</span> (fw_verbose)
	{
		dolog((LOG_AUTHPRIV | LOG_NOTICE, msg, rulenum));
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Check validity of the structure before insert.
 * Fortunately rules are simple, so this mostly need to check rule sizes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">check_ipfw_struct</span>(<span class="enscript-type">struct</span> ip_fw *rule, <span class="enscript-type">int</span> size)
{
	<span class="enscript-type">int</span> l, cmdlen = 0;
	<span class="enscript-type">int</span> have_action=0;
	ipfw_insn *cmd;

	<span class="enscript-keyword">if</span> (size &lt; <span class="enscript-keyword">sizeof</span>(*rule)) {
		printf(<span class="enscript-string">&quot;ipfw: rule too short\n&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* first, check for valid size */</span>
	l = RULESIZE(rule);
	<span class="enscript-keyword">if</span> (l != size) {
		printf(<span class="enscript-string">&quot;ipfw: size mismatch (have %d want %d)\n&quot;</span>, size, l);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/*
	 * Now go for the individual checks. Very simple ones, basically only
	 * instruction sizes.
	 */</span>
	<span class="enscript-keyword">for</span> (l = rule-&gt;cmd_len, cmd = rule-&gt;cmd ;
			l &gt; 0 ; l -= cmdlen, cmd += cmdlen) {
		cmdlen = F_LEN(cmd);
		<span class="enscript-keyword">if</span> (cmdlen &gt; l) {
			printf(<span class="enscript-string">&quot;ipfw: opcode %d size truncated\n&quot;</span>,
			    cmd-&gt;opcode);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		DEB(printf(<span class="enscript-string">&quot;ipfw: opcode %d\n&quot;</span>, cmd-&gt;opcode);)
		<span class="enscript-keyword">switch</span> (cmd-&gt;opcode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROBE_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_KEEP_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROTO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_ME</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_ME</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LAYER2</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FRAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPOPT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTOS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPPRECEDENCE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPVER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPWIN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPFLAGS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ESTAB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VERREVPATH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPSEC</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_UID</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_GID</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPSEQ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TCPACK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PROB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ICMPTYPE</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_u32))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LIMIT</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_limit))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_LOG</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_log))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
				
			<span class="enscript-comment">/* enforce logging limit */</span>
			<span class="enscript-keyword">if</span> (fw_verbose &amp;&amp;
				((ipfw_insn_log *)cmd)-&gt;max_log == 0 &amp;&amp; verbose_limit != 0) {
				((ipfw_insn_log *)cmd)-&gt;max_log = verbose_limit;
			}

			((ipfw_insn_log *)cmd)-&gt;log_left =
			    ((ipfw_insn_log *)cmd)-&gt;max_log;

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_MASK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_MASK</span>:
			<span class="enscript-comment">/* only odd command lengths */</span>
			<span class="enscript-keyword">if</span> ( !(cmdlen &amp; 1) || cmdlen &gt; 31)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRC_SET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DST_SET</span>:
			<span class="enscript-keyword">if</span> (cmd-&gt;arg1 == 0 || cmd-&gt;arg1 &gt; 256) {
				printf(<span class="enscript-string">&quot;ipfw: invalid set size %d\n&quot;</span>,
					cmd-&gt;arg1);
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_u32) +
			    (cmd-&gt;arg1+31)/32 )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MACADDR2</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_mac))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_NOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPID</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPTTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IPLEN</span>:
			<span class="enscript-keyword">if</span> (cmdlen &lt; 1 || cmdlen &gt; 31)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_MAC_TYPE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_SRCPORT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_IP_DSTPORT</span>: <span class="enscript-comment">/* XXX artificial limit, 30 port pairs */</span>
			<span class="enscript-keyword">if</span> (cmdlen &lt; 2 || cmdlen &gt; 31)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RECV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_XMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_VIA</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_if))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_PIPE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_QUEUE</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_pipe))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_action</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_IP</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn_sa))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_action</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_FORWARD_MAC</span>: <span class="enscript-comment">/* XXX not implemented yet */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_CHECK_STATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_COUNT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_ACCEPT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DENY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_REJECT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_SKIPTO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_DIVERT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">O_TEE</span>:
			<span class="enscript-keyword">if</span> (cmdlen != F_INSN_SIZE(ipfw_insn))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_size</span>;
<span class="enscript-reference">check_action</span>:
			<span class="enscript-keyword">if</span> (have_action) {
				printf(<span class="enscript-string">&quot;ipfw: opcode %d, multiple actions&quot;</span>
					<span class="enscript-string">&quot; not allowed\n&quot;</span>,
					cmd-&gt;opcode);
				<span class="enscript-keyword">return</span> EINVAL;
			}
			have_action = 1;
			<span class="enscript-keyword">if</span> (l != cmdlen) {
				printf(<span class="enscript-string">&quot;ipfw: opcode %d, action must be&quot;</span>
					<span class="enscript-string">&quot; last opcode\n&quot;</span>,
					cmd-&gt;opcode);
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;ipfw: opcode %d, unknown opcode\n&quot;</span>,
				cmd-&gt;opcode);
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}
	<span class="enscript-keyword">if</span> (have_action == 0) {
		printf(<span class="enscript-string">&quot;ipfw: missing action\n&quot;</span>);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad_size</span>:
	printf(<span class="enscript-string">&quot;ipfw: opcode %d size %d wrong\n&quot;</span>,
		cmd-&gt;opcode, cmdlen);
	<span class="enscript-keyword">return</span> EINVAL;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_kev_post_msg</span>(u_int32_t event_code)
{
	<span class="enscript-type">struct</span> kev_msg		ev_msg;

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_msg));
	
	ev_msg.vendor_code = KEV_VENDOR_APPLE;
	ev_msg.kev_class = KEV_FIREWALL_CLASS;
	ev_msg.kev_subclass = KEV_IPFW_SUBCLASS;
	ev_msg.event_code = event_code;

	kev_post_msg(&amp;ev_msg);

}

<span class="enscript-comment">/**
 * {set|get}sockopt parser.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipfw_ctl</span>(<span class="enscript-type">struct</span> sockopt *sopt)
{
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RULE_MAXSIZE</span>	(256*sizeof(u_int32_t))
	u_int32_t api_version;
	<span class="enscript-type">int</span> command;
	<span class="enscript-type">int</span> error;
	size_t size;
	size_t	rulesize = RULE_MAXSIZE;
	<span class="enscript-type">struct</span> ip_fw *bp , *buf, *rule;
	<span class="enscript-type">int</span>	is64user = 0;
	
	<span class="enscript-comment">/* copy of orig sopt to send to ipfw_get_command_and_version() */</span>
	<span class="enscript-type">struct</span> sockopt tmp_sopt = *sopt; 
	<span class="enscript-type">struct</span> timeval timenow;

	getmicrotime(&amp;timenow);
	
	<span class="enscript-comment">/*
	 * Disallow modifications in really-really secure mode, but still allow
	 * the logging counters to be reset.
	 */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_name == IP_FW_ADD ||
	    (sopt-&gt;sopt_dir == SOPT_SET &amp;&amp; sopt-&gt;sopt_name != IP_FW_RESETLOG)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__FreeBSD_version</span> &gt;= 500034
		error = securelevel_ge(sopt-&gt;sopt_td-&gt;td_ucred, 3);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* FreeBSD 4.x */</span>
		<span class="enscript-keyword">if</span> (securelevel &gt;= 3)
			<span class="enscript-keyword">return</span> (EPERM);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/* first get the command and version, then do conversion as necessary */</span>
	error = ipfw_get_command_and_version(&amp;tmp_sopt, &amp;command, &amp;api_version);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* error getting the version */</span>
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p))
		is64user = 1;

	<span class="enscript-keyword">switch</span> (command) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_GET</span>:
	{
		size_t	dynrulesize;
		<span class="enscript-comment">/*
		 * pass up a copy of the current rules. Static rules
		 * come first (the last of which has number IPFW_DEFAULT_RULE),
		 * followed by a possibly empty list of dynamic rule.
		 * The last dynamic rule has NULL in the &quot;next&quot; field.
		 */</span>
		lck_mtx_lock(ipfw_mutex);
						
		<span class="enscript-keyword">if</span> (is64user){
			size = Get64static_len();
			dynrulesize = <span class="enscript-keyword">sizeof</span>(ipfw_dyn_rule_64);
			<span class="enscript-keyword">if</span> (ipfw_dyn_v)
				size += (dyn_count * dynrulesize);
		}<span class="enscript-keyword">else</span> {
			size = Get32static_len();
			dynrulesize = <span class="enscript-keyword">sizeof</span>(ipfw_dyn_rule_32);
			<span class="enscript-keyword">if</span> (ipfw_dyn_v)
				size += (dyn_count * dynrulesize);
		}

		<span class="enscript-comment">/*
		 * XXX todo: if the user passes a short length just to know
		 * how much room is needed, do not bother filling up the
		 * buffer, just jump to the sooptcopyout.
		 */</span>
		buf = _MALLOC(size, M_TEMP, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (buf == 0) {
			lck_mtx_unlock(ipfw_mutex);
			error = ENOBUFS;
			<span class="enscript-keyword">break</span>;
		}

		bp = buf;
		<span class="enscript-keyword">for</span> (rule = layer3_chain; rule ; rule = rule-&gt;next) {
	
			<span class="enscript-keyword">if</span> (rule-&gt;reserved_1 == IPFW_RULE_INACTIVE) {
				<span class="enscript-keyword">continue</span>;
			}
			
			<span class="enscript-keyword">if</span> (is64user){
				<span class="enscript-type">int</span> rulesize_64;

				copyto64fw( rule, (<span class="enscript-type">struct</span> ip_fw_64 *)bp, size);
				bcopy(&amp;set_disable, &amp;(( (<span class="enscript-type">struct</span> ip_fw_64*)bp)-&gt;next_rule), <span class="enscript-keyword">sizeof</span>(set_disable));
				<span class="enscript-comment">/* do not use macro RULESIZE64 since we want RULESIZE for ip_fw_64 */</span>
				rulesize_64 = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) + ((<span class="enscript-type">struct</span> ip_fw_64 *)(bp))-&gt;cmd_len * 4 - 4;
				bp = (<span class="enscript-type">struct</span> ip_fw *)((<span class="enscript-type">char</span> *)bp + rulesize_64);
			}<span class="enscript-keyword">else</span>{
				<span class="enscript-type">int</span> rulesize_32;

				copyto32fw( rule, (<span class="enscript-type">struct</span> ip_fw_32*)bp, size);
				bcopy(&amp;set_disable, &amp;(( (<span class="enscript-type">struct</span> ip_fw_32*)bp)-&gt;next_rule), <span class="enscript-keyword">sizeof</span>(set_disable));
				<span class="enscript-comment">/* do not use macro RULESIZE32 since we want RULESIZE for ip_fw_32 */</span>
				rulesize_32 = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32) + ((<span class="enscript-type">struct</span> ip_fw_32 *)(bp))-&gt;cmd_len * 4 - 4;
				bp = (<span class="enscript-type">struct</span> ip_fw *)((<span class="enscript-type">char</span> *)bp + rulesize_32);
			}
		}
		<span class="enscript-keyword">if</span> (ipfw_dyn_v) {
			<span class="enscript-type">int</span> i;
			ipfw_dyn_rule *p;
			<span class="enscript-type">char</span> *dst, *last = NULL;
			
			dst = (<span class="enscript-type">char</span> *)bp;
			<span class="enscript-keyword">for</span> (i = 0 ; i &lt; curr_dyn_buckets ; i++ )
				<span class="enscript-keyword">for</span> ( p = ipfw_dyn_v[i] ; p != NULL ;
				    p = p-&gt;next, dst += dynrulesize ) {
					<span class="enscript-keyword">if</span> ( is64user ){
						ipfw_dyn_rule_64	*ipfw_dyn_dst;
						
						ipfw_dyn_dst = (ipfw_dyn_rule_64 *)dst;
						<span class="enscript-comment">/*
						 * store a non-null value in &quot;next&quot;.
						 * The userland code will interpret a
						 * NULL here as a marker
						 * for the last dynamic rule.
						 */</span>
						ipfw_dyn_dst-&gt;next = CAST_DOWN_EXPLICIT(user64_addr_t, dst);
						ipfw_dyn_dst-&gt;rule = p-&gt;rule-&gt;rulenum;
						ipfw_dyn_dst-&gt;parent = CAST_DOWN(user64_addr_t, p-&gt;parent);
						ipfw_dyn_dst-&gt;pcnt = p-&gt;pcnt;
						ipfw_dyn_dst-&gt;bcnt = p-&gt;bcnt;
						externalize_flow_id(&amp;ipfw_dyn_dst-&gt;id, &amp;p-&gt;id);
						ipfw_dyn_dst-&gt;expire =
							TIME_LEQ(p-&gt;expire, timenow.tv_sec) ?
							0 : p-&gt;expire - timenow.tv_sec;
						ipfw_dyn_dst-&gt;bucket = p-&gt;bucket;
						ipfw_dyn_dst-&gt;state = p-&gt;state;
						ipfw_dyn_dst-&gt;ack_fwd = p-&gt;ack_fwd;
						ipfw_dyn_dst-&gt;ack_rev = p-&gt;ack_rev;
						ipfw_dyn_dst-&gt;dyn_type = p-&gt;dyn_type;
						ipfw_dyn_dst-&gt;count = p-&gt;count;
						last = (<span class="enscript-type">char</span>*)ipfw_dyn_dst;
					} <span class="enscript-keyword">else</span> {
						ipfw_dyn_rule_32	*ipfw_dyn_dst;
						
						ipfw_dyn_dst = (ipfw_dyn_rule_32 *)dst;
						<span class="enscript-comment">/*
						 * store a non-null value in &quot;next&quot;.
						 * The userland code will interpret a
						 * NULL here as a marker
						 * for the last dynamic rule.
						 */</span>
						ipfw_dyn_dst-&gt;next = CAST_DOWN_EXPLICIT(user32_addr_t, dst);
						ipfw_dyn_dst-&gt;rule = p-&gt;rule-&gt;rulenum;
						ipfw_dyn_dst-&gt;parent = CAST_DOWN_EXPLICIT(user32_addr_t, p-&gt;parent);
						ipfw_dyn_dst-&gt;pcnt = p-&gt;pcnt;
						ipfw_dyn_dst-&gt;bcnt = p-&gt;bcnt;
						externalize_flow_id(&amp;ipfw_dyn_dst-&gt;id, &amp;p-&gt;id);
						ipfw_dyn_dst-&gt;expire =
							TIME_LEQ(p-&gt;expire, timenow.tv_sec) ?
							0 : p-&gt;expire - timenow.tv_sec;
						ipfw_dyn_dst-&gt;bucket = p-&gt;bucket;
						ipfw_dyn_dst-&gt;state = p-&gt;state;
						ipfw_dyn_dst-&gt;ack_fwd = p-&gt;ack_fwd;
						ipfw_dyn_dst-&gt;ack_rev = p-&gt;ack_rev;
						ipfw_dyn_dst-&gt;dyn_type = p-&gt;dyn_type;
						ipfw_dyn_dst-&gt;count = p-&gt;count;
						last = (<span class="enscript-type">char</span>*)ipfw_dyn_dst;
					}
				}
			<span class="enscript-comment">/* mark last dynamic rule */</span>
			<span class="enscript-keyword">if</span> (last != NULL) {
				<span class="enscript-keyword">if</span> (is64user)
					((ipfw_dyn_rule_64 *)last)-&gt;next = 0;
				<span class="enscript-keyword">else</span>
					((ipfw_dyn_rule_32 *)last)-&gt;next = 0;
			}
		}
		lck_mtx_unlock(ipfw_mutex);

		<span class="enscript-comment">/* convert back if necessary and copyout */</span>
		<span class="enscript-keyword">if</span> (api_version == IP_FW_VERSION_0) {
			<span class="enscript-type">int</span>	i, len = 0;
			<span class="enscript-type">struct</span> ip_old_fw	*buf2, *rule_vers0;
			
			lck_mtx_lock(ipfw_mutex);
			buf2 = _MALLOC(static_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_old_fw), M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (buf2 == 0) {
				lck_mtx_unlock(ipfw_mutex);
				error = ENOBUFS;
			}
			
			<span class="enscript-keyword">if</span> (!error) {
				bp = buf;
				rule_vers0 = buf2;
				
				<span class="enscript-keyword">for</span> (i = 0; i &lt; static_count; i++) {
					<span class="enscript-comment">/* static rules have different sizes */</span>
					<span class="enscript-type">int</span> j = RULESIZE(bp);
					ipfw_convert_from_latest(bp, rule_vers0, api_version, is64user);
					bp = (<span class="enscript-type">struct</span> ip_fw *)((<span class="enscript-type">char</span> *)bp + j);
					len += <span class="enscript-keyword">sizeof</span>(*rule_vers0);
					rule_vers0++;
				}
				lck_mtx_unlock(ipfw_mutex);
				error = sooptcopyout(sopt, buf2, len);
				_FREE(buf2, M_TEMP);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (api_version == IP_FW_VERSION_1) {
			<span class="enscript-type">int</span>	i, len = 0, buf_size;
			<span class="enscript-type">struct</span> ip_fw_compat	*buf2;
			size_t	ipfwcompsize;
			size_t	ipfwdyncompsize;
			<span class="enscript-type">char</span>	*rule_vers1;

			lck_mtx_lock(ipfw_mutex);
			<span class="enscript-keyword">if</span> ( is64user ){
				ipfwcompsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_64);
				ipfwdyncompsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_64);
			} <span class="enscript-keyword">else</span> {
				ipfwcompsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat_32);
				ipfwdyncompsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_32);
			}
				
			buf_size = static_count * ipfwcompsize + 
						dyn_count * ipfwdyncompsize;
						
			buf2 = _MALLOC(buf_size, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (buf2 == 0) {
				lck_mtx_unlock(ipfw_mutex);
				error = ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (!error) {
				bp = buf;
				rule_vers1 = (<span class="enscript-type">char</span>*)buf2;
				
				<span class="enscript-comment">/* first do static rules */</span>
				<span class="enscript-keyword">for</span> (i = 0; i &lt; static_count; i++) {
					<span class="enscript-comment">/* static rules have different sizes */</span>
					<span class="enscript-keyword">if</span> ( is64user ){
						<span class="enscript-type">int</span> rulesize_64;
						ipfw_convert_from_latest(bp, (<span class="enscript-type">void</span> *)rule_vers1, api_version, is64user);
						rulesize_64 = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_64) + ((<span class="enscript-type">struct</span> ip_fw_64 *)(bp))-&gt;cmd_len * 4 - 4;
						bp = (<span class="enscript-type">struct</span> ip_fw *)((<span class="enscript-type">char</span> *)bp + rulesize_64);
					}<span class="enscript-keyword">else</span> {
						<span class="enscript-type">int</span> rulesize_32;
						ipfw_convert_from_latest(bp, (<span class="enscript-type">void</span> *)rule_vers1, api_version, is64user);
						rulesize_32 = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_32) + ((<span class="enscript-type">struct</span> ip_fw_32 *)(bp))-&gt;cmd_len * 4 - 4;
						bp = (<span class="enscript-type">struct</span> ip_fw *)((<span class="enscript-type">char</span> *)bp + rulesize_32);
					}
					len += ipfwcompsize;
					rule_vers1 += ipfwcompsize;
				}
				<span class="enscript-comment">/* now do dynamic rules */</span>
				<span class="enscript-keyword">if</span> ( is64user )
					cp_dyn_to_comp_64( (<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_64 *)rule_vers1, &amp;len);
				<span class="enscript-keyword">else</span> 
					cp_dyn_to_comp_32( (<span class="enscript-type">struct</span> ipfw_dyn_rule_compat_32 *)rule_vers1, &amp;len);

				lck_mtx_unlock(ipfw_mutex);
				error = sooptcopyout(sopt, buf2, len);
				_FREE(buf2, M_TEMP);
			}
		} <span class="enscript-keyword">else</span> {
			error = sooptcopyout(sopt, buf, size);
		}
		
		_FREE(buf, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_FLUSH</span>:
		<span class="enscript-comment">/*
		 * Normally we cannot release the lock on each iteration.
		 * We could do it here only because we start from the head all
		 * the times so there is no risk of missing some entries.
		 * On the other hand, the risk is that we end up with
		 * a very inconsistent ruleset, so better keep the lock
		 * around the whole cycle.
		 *
		 * XXX this code can be improved by resetting the head of
		 * the list to point to the default rule, and then freeing
		 * the old list without the need for a lock.
		 */</span>

		lck_mtx_lock(ipfw_mutex);
		free_chain(&amp;layer3_chain, 0 <span class="enscript-comment">/* keep default rule */</span>);
		fw_bypass = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_INACTIVE_RULES</span>
			print_chain(&amp;layer3_chain);
#<span class="enscript-reference">endif</span>
		lck_mtx_unlock(ipfw_mutex);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ADD</span>:
	{
		size_t savedsopt_valsize=0;
		rule = _MALLOC(RULE_MAXSIZE, M_TEMP, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (rule == 0) {
			error = ENOBUFS;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (api_version != IP_FW_CURRENT_API_VERSION) {
			error = ipfw_convert_to_latest(sopt, rule, api_version, is64user);
		}
		<span class="enscript-keyword">else</span> {
			savedsopt_valsize = sopt-&gt;sopt_valsize;   <span class="enscript-comment">/* it might get modified in sooptcopyin_fw */</span>
			error = sooptcopyin_fw( sopt, rule, &amp;rulesize); 

		}
		
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> ((api_version == IP_FW_VERSION_0) || (api_version == IP_FW_VERSION_1)) {
				<span class="enscript-comment">/* the rule has already been checked so just
				 * adjust sopt_valsize to match what would be expected.
				 */</span>
				sopt-&gt;sopt_valsize = RULESIZE(rule);
				rulesize = RULESIZE(rule);
			}
			error = check_ipfw_struct(rule, rulesize);
			<span class="enscript-keyword">if</span> (!error) {
				lck_mtx_lock(ipfw_mutex);
				error = add_rule(&amp;layer3_chain, rule);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; fw_bypass)
					fw_bypass = 0;
				lck_mtx_unlock(ipfw_mutex);
				
				size = RULESIZE(rule);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; sopt-&gt;sopt_dir == SOPT_GET) {
					<span class="enscript-comment">/* convert back if necessary and copyout */</span>
					<span class="enscript-keyword">if</span> (api_version == IP_FW_VERSION_0) {
						<span class="enscript-type">struct</span> ip_old_fw	rule_vers0;
						
						ipfw_convert_from_latest(rule, &amp;rule_vers0, api_version, is64user);
						sopt-&gt;sopt_valsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_old_fw);
						
						error = sooptcopyout(sopt, &amp;rule_vers0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_old_fw));
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (api_version == IP_FW_VERSION_1) {
						<span class="enscript-type">struct</span> ip_fw_compat	rule_vers1;
						ipfw_convert_from_latest(rule, &amp;rule_vers1, api_version, is64user);
						sopt-&gt;sopt_valsize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat);
						
						error = sooptcopyout(sopt, &amp;rule_vers1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_compat));
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-type">char</span> *userrule;
						userrule = _MALLOC(savedsopt_valsize, M_TEMP, M_WAITOK);
						<span class="enscript-keyword">if</span> ( userrule == NULL )
							userrule = (<span class="enscript-type">char</span>*)rule;
						<span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p)){
							copyto64fw( rule, (<span class="enscript-type">struct</span> ip_fw_64*)userrule, savedsopt_valsize);
						}
						<span class="enscript-keyword">else</span> {
								copyto32fw( rule, (<span class="enscript-type">struct</span> ip_fw_32*)userrule, savedsopt_valsize);
						}
						error = sooptcopyout(sopt, userrule, savedsopt_valsize);
						<span class="enscript-keyword">if</span> ( userrule )
							_FREE(userrule, M_TEMP);
					}
				}
			}
		}
		
		_FREE(rule, M_TEMP);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_DEL</span>:
	{
		<span class="enscript-comment">/*
		 * IP_FW_DEL is used for deleting single rules or sets,
		 * and (ab)used to atomically manipulate sets. 
		 * rule-&gt;rulenum != 0 indicates single rule delete
		 * rule-&gt;set_masks used to manipulate sets
		 * rule-&gt;set_masks[0] contains info on sets to be 
		 *	disabled, swapped, or moved
		 * rule-&gt;set_masks[1] contains sets to be enabled.
		 */</span>
		 
		<span class="enscript-comment">/* there is only a simple rule passed in
		 * (no cmds), so use a temp struct to copy
		 */</span>
		<span class="enscript-type">struct</span> ip_fw	temp_rule;
		u_int32_t	arg;
		u_int8_t	cmd;
		
		bzero(&amp;temp_rule, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw));
		<span class="enscript-keyword">if</span> (api_version != IP_FW_CURRENT_API_VERSION) {
			error = ipfw_convert_to_latest(sopt, &amp;temp_rule, api_version, is64user);
		}
		<span class="enscript-keyword">else</span> {
			error = sooptcopyin_fw(sopt, &amp;temp_rule, 0 );
		}

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* set_masks is used to distinguish between deleting
			 * single rules or atomically manipulating sets
			 */</span>
			lck_mtx_lock(ipfw_mutex);
			
			arg = temp_rule.set_masks[0];
			cmd = (arg &gt;&gt; 24) &amp; 0xff;
			
			<span class="enscript-keyword">if</span> (temp_rule.rulenum) {
				<span class="enscript-comment">/* single rule */</span>
				error = del_entry(&amp;layer3_chain, temp_rule.rulenum);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_INACTIVE_RULES</span>
				print_chain(&amp;layer3_chain);
#<span class="enscript-reference">endif</span>
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd) {
				<span class="enscript-comment">/* set reassignment - see comment above del_entry() for details */</span>
				error = del_entry(&amp;layer3_chain, temp_rule.set_masks[0]);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_INACTIVE_RULES</span>
				print_chain(&amp;layer3_chain);
#<span class="enscript-reference">endif</span>
			}
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (temp_rule.set_masks[0] != 0 ||
				temp_rule.set_masks[1] != 0) {
				<span class="enscript-comment">/* set enable/disable */</span>
				set_disable =
					(set_disable | temp_rule.set_masks[0]) &amp; ~temp_rule.set_masks[1] &amp;
					~(1&lt;&lt;RESVD_SET); <span class="enscript-comment">/* set RESVD_SET always enabled */</span>
			}
			
			<span class="enscript-keyword">if</span> (!layer3_chain-&gt;next)
				fw_bypass = 1;
			lck_mtx_unlock(ipfw_mutex);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ZERO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_RESETLOG</span>: <span class="enscript-comment">/* using rule-&gt;rulenum */</span>
	{
		<span class="enscript-comment">/* there is only a simple rule passed in
		 * (no cmds), so use a temp struct to copy
		 */</span>
		<span class="enscript-type">struct</span> ip_fw temp_rule;
		
		bzero(&amp;temp_rule, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw));
		
		<span class="enscript-keyword">if</span> (api_version != IP_FW_CURRENT_API_VERSION) {
			error = ipfw_convert_to_latest(sopt, &amp;temp_rule, api_version, is64user);
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_val != 0) {
				error = sooptcopyin_fw( sopt, &amp;temp_rule, 0); 
			}
		}

		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(ipfw_mutex);
			error = zero_entry(temp_rule.rulenum, sopt-&gt;sopt_name == IP_FW_RESETLOG);
			lck_mtx_unlock(ipfw_mutex);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;ipfw: ipfw_ctl invalid option %d\n&quot;</span>, sopt-&gt;sopt_name);
		error = EINVAL;
	}

	<span class="enscript-keyword">if</span> (error != EINVAL) {
		<span class="enscript-keyword">switch</span> (command) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ADD</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_ADD</span>:
				ipfw_kev_post_msg(KEV_IPFW_ADD);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_DEL</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_DEL</span>:
				ipfw_kev_post_msg(KEV_IPFW_DEL);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_FLUSH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_FLUSH</span>:
				ipfw_kev_post_msg(KEV_IPFW_FLUSH);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/**
 * dummynet needs a reference to the default rule, because rules can be
 * deleted while packets hold a reference to them. When this happens,
 * dummynet changes the reference to the default rule (it could well be a
 * NULL pointer, but this way we do not need to check for the special
 * case, plus here he have info on the default behaviour).
 */</span>
<span class="enscript-type">struct</span> ip_fw *ip_fw_default_rule;

<span class="enscript-comment">/*
 * This procedure is only used to handle keepalives. It is invoked
 * every dyn_keepalive_period
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_tick</span>(__unused <span class="enscript-type">void</span> * unused)
{
	<span class="enscript-type">struct</span> mbuf *m0, *m, *mnext, **mtailp;
	<span class="enscript-type">int</span> i;
	ipfw_dyn_rule *q;
	<span class="enscript-type">struct</span> timeval timenow;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> stealth_cnt = 0;

	<span class="enscript-keyword">if</span> (ipfw_stealth_stats_needs_flush) {
	    stealth_cnt++;
	    <span class="enscript-keyword">if</span> (!(stealth_cnt % IPFW_STEALTH_TIMEOUT_FREQUENCY)) {
	        ipfw_stealth_flush_stats();
	    }
	}

	<span class="enscript-keyword">if</span> (dyn_keepalive == 0 || ipfw_dyn_v == NULL || dyn_count == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	getmicrotime(&amp;timenow);

	<span class="enscript-comment">/*
	 * We make a chain of packets to go out here -- not deferring
	 * until after we drop the ipfw lock would result
	 * in a lock order reversal with the normal packet input -&gt; ipfw
	 * call stack.
	 */</span>
	m0 = NULL;
	mtailp = &amp;m0;
	
	lck_mtx_lock(ipfw_mutex);
	<span class="enscript-keyword">for</span> (i = 0 ; i &lt; curr_dyn_buckets ; i++) {
		<span class="enscript-keyword">for</span> (q = ipfw_dyn_v[i] ; q ; q = q-&gt;next ) {
			<span class="enscript-keyword">if</span> (q-&gt;dyn_type == O_LIMIT_PARENT)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (q-&gt;id.proto != IPPROTO_TCP)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ( (q-&gt;state &amp; BOTH_SYN) != BOTH_SYN)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (TIME_LEQ( timenow.tv_sec+dyn_keepalive_interval,
			    q-&gt;expire))
				<span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* too early */</span>
			<span class="enscript-keyword">if</span> (TIME_LEQ(q-&gt;expire, timenow.tv_sec))
				<span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* too late, rule expired */</span>

			*mtailp = send_pkt(&amp;(q-&gt;id), q-&gt;ack_rev - 1, q-&gt;ack_fwd, TH_SYN);
			<span class="enscript-keyword">if</span> (*mtailp != NULL)
				mtailp = &amp;(*mtailp)-&gt;m_nextpkt;

			*mtailp = send_pkt(&amp;(q-&gt;id), q-&gt;ack_fwd - 1, q-&gt;ack_rev, 0);
			<span class="enscript-keyword">if</span> (*mtailp != NULL)
				mtailp = &amp;(*mtailp)-&gt;m_nextpkt;
		}
	}
	lck_mtx_unlock(ipfw_mutex);

	<span class="enscript-keyword">for</span> (m = mnext = m0; m != NULL; m = mnext) {
		<span class="enscript-type">struct</span> route sro;	<span class="enscript-comment">/* fake route */</span>

		mnext = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;
		bzero (&amp;sro, <span class="enscript-keyword">sizeof</span> (sro));
		ip_output(m, NULL, &amp;sro, 0, NULL, NULL);
		ROUTE_RELEASE(&amp;sro);
	}
<span class="enscript-reference">done</span>:
	timeout_with_leeway(ipfw_tick, NULL, dyn_keepalive_period*hz,
	    DYN_KEEPALIVE_LEEWAY*hz);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipfw_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ip_fw default_rule;

	<span class="enscript-comment">/* setup locks */</span>
	ipfw_mutex_grp_attr = lck_grp_attr_alloc_init();
	ipfw_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;ipfw&quot;</span>, ipfw_mutex_grp_attr);
	ipfw_mutex_attr = lck_attr_alloc_init();
	lck_mtx_init(ipfw_mutex, ipfw_mutex_grp, ipfw_mutex_attr);

	layer3_chain = NULL;

	bzero(&amp;default_rule, <span class="enscript-keyword">sizeof</span> default_rule);

	default_rule.act_ofs = 0;
	default_rule.rulenum = IPFW_DEFAULT_RULE;
	default_rule.cmd_len = 1;
	default_rule.set = RESVD_SET;

	default_rule.cmd[0].len = 1;
	default_rule.cmd[0].opcode =
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPFIREWALL_DEFAULT_TO_ACCEPT</span>
				(1) ? O_ACCEPT :
#<span class="enscript-reference">endif</span>
				O_DENY;

	<span class="enscript-keyword">if</span> (add_rule(&amp;layer3_chain, &amp;default_rule)) {
		printf(<span class="enscript-string">&quot;ipfw2: add_rule failed adding default rule\n&quot;</span>);
		printf(<span class="enscript-string">&quot;ipfw2 failed initialization!!\n&quot;</span>);
		fw_enable = 0;
	}
	<span class="enscript-keyword">else</span> {
		ip_fw_default_rule = layer3_chain;
	
	#ifdef IPFIREWALL_VERBOSE
		fw_verbose = 1;
	#endif
	#ifdef IPFIREWALL_VERBOSE_LIMIT
		verbose_limit = IPFIREWALL_VERBOSE_LIMIT;
	#endif
		<span class="enscript-keyword">if</span> (fw_verbose) {
			<span class="enscript-keyword">if</span> (!verbose_limit)
				printf(<span class="enscript-string">&quot;ipfw2 verbose logging enabled: unlimited logging by default\n&quot;</span>);
			<span class="enscript-keyword">else</span>
				printf(<span class="enscript-string">&quot;ipfw2 verbose logging enabled: limited to %d packets/entry by default\n&quot;</span>,
					verbose_limit);
		}
	}

	ip_fw_chk_ptr = ipfw_chk;
	ip_fw_ctl_ptr = ipfw_ctl;

        ipfwstringlen = strlen( ipfwstring );

	timeout(ipfw_tick, NULL, hz);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFW2 */</span>

</pre>
<hr />
</body></html>