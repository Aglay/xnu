<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_input.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_input.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_input.c	8.12 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/tcp_input.c,v 1.107.2.16 2001/08/22 00:59:12 silby Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>		<span class="enscript-comment">/* for proc0 declaration */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kasl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>	<span class="enscript-comment">/* before tcp_seq.h, for tcp_random18() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>    <span class="enscript-comment">/* for ICMP_BANDLIM		*/</span>   
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp_var.h&gt;</span>	<span class="enscript-comment">/* for ICMP_BANDLIM	*/</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/tcp6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_debug.h&gt;</span>
u_char tcp_saveipgen[40]; <span class="enscript-comment">/* the size must be of max ip header, now IPv6 */</span>
<span class="enscript-type">struct</span> tcphdr tcp_savetcp;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TCPDEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span> || <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET || CONFIG_MACF_SOCKET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/lro_ext.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_opt.h&gt;</span>	
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccaes.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETTCP, 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETTCP, 2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_TCP_INPUT</span>       NETDBG_CODE(DBG_NETTCP, (3 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_TCP_NEWCONN</span>     NETDBG_CODE(DBG_NETTCP, (7 &lt;&lt; 8))

tcp_cc	tcp_ccgen;

<span class="enscript-type">struct</span>	tcpstat tcpstat;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> log_in_vain = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, log_in_vain,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;log_in_vain, 0,
    <span class="enscript-string">&quot;Log all incoming TCP connections&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> blackhole = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, blackhole,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;blackhole, 0,
    <span class="enscript-string">&quot;Do not send RST when dropping refused connections&quot;</span>);

<span class="enscript-type">int</span> tcp_delack_enabled = 3;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, delayed_ack,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_delack_enabled, 0,
    <span class="enscript-string">&quot;Delay ACK to try and piggyback it onto a data packet&quot;</span>);

<span class="enscript-type">int</span> tcp_lq_overflow = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tcp_lq_overflow,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_lq_overflow, 0,
    <span class="enscript-string">&quot;Listen Queue Overflow&quot;</span>);

<span class="enscript-type">int</span> tcp_recv_bg = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, recvbg, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_recv_bg, 0, <span class="enscript-string">&quot;Receive background&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCP_DROP_SYNFIN</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> drop_synfin = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, drop_synfin,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;drop_synfin, 0,
    <span class="enscript-string">&quot;Drop TCP packets with SYN+FIN set&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_tcp, OID_AUTO, reass, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
    <span class="enscript-string">&quot;TCP Segment Reassembly Queue&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_reass_overflows = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp_reass, OID_AUTO, overflows,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;tcp_reass_overflows, 0,
    <span class="enscript-string">&quot;Global number of TCP Segment Reassembly Queue Overflows&quot;</span>);


__private_extern__ <span class="enscript-type">int</span> slowlink_wsize = 8192;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, slowlink_wsize,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;slowlink_wsize, 0, <span class="enscript-string">&quot;Maximum advertised window size for slowlink&quot;</span>);

<span class="enscript-type">int</span> maxseg_unacked = 8;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, maxseg_unacked,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;maxseg_unacked, 0,
    <span class="enscript-string">&quot;Maximum number of outstanding segments left unacked&quot;</span>);

<span class="enscript-type">int</span> tcp_do_rfc3465 = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rfc3465, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_do_rfc3465, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> tcp_do_rfc3465_lim2 = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rfc3465_lim2,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_do_rfc3465_lim2, 0,
    <span class="enscript-string">&quot;Appropriate bytes counting w/ L=2*SMSS&quot;</span>);

<span class="enscript-type">int</span> rtt_samples_per_slot = 20;

<span class="enscript-type">int</span> tcp_allowed_iaj = ALLOWED_IAJ;
<span class="enscript-type">int</span> tcp_acc_iaj_high_thresh = ACC_IAJ_HIGH_THRESH;
u_int32_t tcp_autorcvbuf_inc_shift = 3;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, recv_allowed_iaj,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_allowed_iaj, 0,
    <span class="enscript-string">&quot;Allowed inter-packet arrival jiter&quot;</span>);
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, acc_iaj_high_thresh,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_acc_iaj_high_thresh, 0,
    <span class="enscript-string">&quot;Used in calculating maximum accumulated IAJ&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, autorcvbufincshift,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_autorcvbuf_inc_shift, 0,
    <span class="enscript-string">&quot;Shift for increment in receive socket buffer size&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (DEVELOPMENT || DEBUG) */</span>

u_int32_t tcp_do_autorcvbuf = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, doautorcvbuf,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_do_autorcvbuf, 0,
    <span class="enscript-string">&quot;Enable automatic socket buffer tuning&quot;</span>);

u_int32_t tcp_autorcvbuf_max = 512 * 1024;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, autorcvbufmax,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_autorcvbuf_max, 0,
    <span class="enscript-string">&quot;Maximum receive socket buffer size&quot;</span>);

<span class="enscript-type">int</span> sw_lro = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, lro, CTLFLAG_RW | CTLFLAG_LOCKED,
        &amp;sw_lro, 0, <span class="enscript-string">&quot;Used to coalesce TCP packets&quot;</span>);

<span class="enscript-type">int</span> lrodebug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, lrodbg,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lrodebug, 0,
    <span class="enscript-string">&quot;Used to debug SW LRO&quot;</span>);

<span class="enscript-type">int</span> lro_start = 4;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, lro_startcnt,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lro_start, 0,
    <span class="enscript-string">&quot;Segments for starting LRO computed as power of 2&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_do_autosendbuf;

<span class="enscript-type">int</span> limited_txmt = 1;
<span class="enscript-type">int</span> early_rexmt = 1;
<span class="enscript-type">int</span> sack_ackadv = 1;
<span class="enscript-type">int</span> tcp_dsack_enable = 1;

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, limited_transmit,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;limited_txmt, 0,
    <span class="enscript-string">&quot;Enable limited transmit&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, early_rexmt,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;early_rexmt, 0,
    <span class="enscript-string">&quot;Enable Early Retransmit&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, sack_ackadv,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sack_ackadv, 0,
    <span class="enscript-string">&quot;Use SACK with cumulative ack advancement as a dupack&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, dsack_enable,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_dsack_enable, 0,
    <span class="enscript-string">&quot;use DSACK TCP option to report duplicate segments&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (DEVELOPMENT || DEBUG) */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IFEF_NOWINDOWSCALE</span>
<span class="enscript-type">int</span> tcp_obey_ifef_nowindowscale = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, obey_ifef_nowindowscale,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_obey_ifef_nowindowscale, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_TCPTV_MIN;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_acc_iaj_high;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_acc_iaj_react_limit;

<span class="enscript-type">int</span> tcprexmtthresh = 3;

u_int32_t tcp_now;
<span class="enscript-type">struct</span> timeval tcp_uptime;	<span class="enscript-comment">/* uptime when tcp_now was last updated */</span>
lck_spin_t *tcp_uptime_lock;	<span class="enscript-comment">/* Used to sychronize updates to tcp_now */</span>

<span class="enscript-type">struct</span> inpcbhead tcb;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">tcb6</span>	tcb  <span class="enscript-comment">/* for KAME src sync over BSD*'s */</span>
<span class="enscript-type">struct</span> inpcbinfo tcbinfo;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_dooptions</span>(<span class="enscript-type">struct</span> tcpcb *, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> tcphdr *,
    <span class="enscript-type">struct</span> tcpopt *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_finalize_options</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcpopt *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_pulloutofband</span>(<span class="enscript-type">struct</span> socket *,
    <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_reass</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcphdr *, <span class="enscript-type">int</span> *, <span class="enscript-type">struct</span> mbuf *,
    <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_xmit_timer</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">int</span>, u_int32_t, tcp_seq);
<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_maxmtu</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_stretch_ack_enable</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_adaptive_rwtimo_check</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">update_iaj_state</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t tlen,
    <span class="enscript-type">int</span> reset_size);
<span class="enscript-type">void</span> <span class="enscript-function-name">compute_iaj</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> nlropkts, <span class="enscript-type">int</span> lro_delay_factor);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">compute_iaj_meat</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t cur_iaj);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_maxmtu6</span>(<span class="enscript-type">struct</span> rtentry *);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_grow</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb, 
    <span class="enscript-type">struct</span> tcpopt *to, u_int32_t tlen);

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_trim</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbsnd_trim</span>(<span class="enscript-type">struct</span> sockbuf *sbsnd);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_tstmp_check</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_reserve</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb,
    u_int32_t newsize, u_int32_t idealsize);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_bad_rexmt_restore_state</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_compute_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcpopt *to, 
    <span class="enscript-type">struct</span> tcphdr *th);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_early_rexmt_check</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_bad_rexmt_check</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th,
    <span class="enscript-type">struct</span> tcpopt *to);
<span class="enscript-comment">/*
 * Constants used for resizing receive socket buffer 
 * when timestamps are not supported 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCPTV_RCVNOTS_QUANTUM</span> 100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_RCVNOTS_BYTELEVEL</span> 204800

<span class="enscript-comment">/* 
 * Constants used for limiting early retransmits 
 * to 10 per minute.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_EARLY_REXMT_WIN</span> (60 * TCP_RETRANSHZ) <span class="enscript-comment">/* 60 seconds */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_EARLY_REXMT_LIMIT</span> 10

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfwsyslog</span>( <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format,...);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_verbose;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_tcp</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>( a ) {            \
        <span class="enscript-keyword">if</span> ( (log_in_vain == 3 ) &amp;&amp; (fw_verbose == 2)) {        <span class="enscript-comment">/* Apple logging, log to ipfw.log */</span> \
                ipfwsyslog a ;  \
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( (log_in_vain == 4 ) &amp;&amp; (fw_verbose == 2)) {   \
                ipfw_stealth_stats_incr_tcp();                    \
        }                       \
        <span class="enscript-keyword">else</span> log a ;            \
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>( a ) { log a; }
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> tcp_rcvunackwin = TCPTV_UNACKWIN;
<span class="enscript-type">int</span> tcp_maxrcvidle = TCPTV_MAXRCVIDLE;
<span class="enscript-type">int</span> tcp_rcvsspktcnt = TCP_RCV_SS_PKTCOUNT;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rcvsspktcnt, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;tcp_rcvsspktcnt, 0, <span class="enscript-string">&quot;packets to be seen before receiver stretches acks&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DELAY_ACK</span>(tp, th) \
	(CC_ALGO(tp)-&gt;delay_ack != NULL &amp;&amp; CC_ALGO(tp)-&gt;delay_ack(tp, th))

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_dropdropablreq</span>(<span class="enscript-type">struct</span> socket *head);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_newreno_partial_ack</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">update_base_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t rtt);
<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_background_cc</span>(<span class="enscript-type">struct</span> socket *so);
<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_foreground_cc</span>(<span class="enscript-type">struct</span> socket *so);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_new_cc</span>(<span class="enscript-type">struct</span> socket *so, uint16_t cc_index);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_bwmeas_check</span>(<span class="enscript-type">struct</span> tcpcb *tp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">reset_acc_iaj</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	tp-&gt;acc_iaj = 0;
	tp-&gt;iaj_rwintop = 0;
	CLEAR_IAJ_STATE(tp);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">update_iaj_state</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t size, <span class="enscript-type">int</span> rst_size)
{
	<span class="enscript-keyword">if</span> (rst_size &gt; 0)
		tp-&gt;iaj_size = 0;
	<span class="enscript-keyword">if</span> (tp-&gt;iaj_size == 0 || size &gt;= tp-&gt;iaj_size) {
		tp-&gt;iaj_size = size;
		tp-&gt;iaj_rcv_ts = tcp_now;
		tp-&gt;iaj_small_pkt = 0;
	}
}

<span class="enscript-comment">/* For every 32 bit unsigned integer(v), this function will find the 
 * largest integer n such that (n*n &lt;= v). This takes at most 16 iterations 
 * irrespective of the value of v and does not involve multiplications. 
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">isqrt</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> sqrt_cache[11] = {0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100};
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> temp, g=0, b=0x8000, bshft=15;
	<span class="enscript-keyword">if</span> ( val &lt;= 100) {
		<span class="enscript-keyword">for</span> (g = 0; g &lt;= 10; ++g) {
			<span class="enscript-keyword">if</span> (sqrt_cache[g] &gt; val) {
				g--;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sqrt_cache[g] == val) {
				<span class="enscript-keyword">break</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">do</span> {
			temp = (((g &lt;&lt; 1) + b) &lt;&lt; (bshft--));
			<span class="enscript-keyword">if</span> (val &gt;= temp) {
				g += b;
				val -= temp;
			}
			b &gt;&gt;= 1;
		} <span class="enscript-keyword">while</span> ( b &gt; 0 &amp;&amp; val &gt; 0);
	}
	<span class="enscript-keyword">return</span>(g);
} 

<span class="enscript-comment">/* 
* With LRO, roughly estimate the inter arrival time between
* each sub coalesced packet as an average. Count the delay
* cur_iaj to be the delay between the last packet received
* and the first packet of the LRO stream. Due to round off errors
* cur_iaj may be the same as lro_delay_factor. Averaging has 
* round off errors too. lro_delay_factor may be close to 0
* in steady state leading to lower values fed to compute_iaj_meat.
*/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_iaj</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> nlropkts, <span class="enscript-type">int</span> lro_delay_factor)
{
	uint32_t cur_iaj = tcp_now - tp-&gt;iaj_rcv_ts;
	uint32_t timediff = 0;

	<span class="enscript-keyword">if</span> (cur_iaj &gt;= lro_delay_factor) {
		cur_iaj = cur_iaj - lro_delay_factor;
	}

	compute_iaj_meat(tp, cur_iaj);
	
	<span class="enscript-keyword">if</span> (nlropkts &lt;= 1)
		<span class="enscript-keyword">return</span>;

	nlropkts--;
	
	timediff = lro_delay_factor/nlropkts;

	<span class="enscript-keyword">while</span> (nlropkts &gt; 0) 
	{
		compute_iaj_meat(tp, timediff);	
		nlropkts--;
	}
}

<span class="enscript-type">static</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">compute_iaj_meat</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t cur_iaj)
{
	<span class="enscript-comment">/* When accumulated IAJ reaches MAX_ACC_IAJ in milliseconds, 
	 * throttle the receive window to a minimum of MIN_IAJ_WIN packets
	 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_ACC_IAJ</span> (tcp_acc_iaj_high_thresh + tcp_acc_iaj_react_limit)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IAJ_DIV_SHIFT</span> 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IAJ_ROUNDUP_CONST</span> (1 &lt;&lt; (IAJ_DIV_SHIFT - 1))

	uint32_t allowed_iaj, acc_iaj = 0;

	uint32_t mean, temp;
	int32_t cur_iaj_dev;

	cur_iaj_dev = (cur_iaj - tp-&gt;avg_iaj);	
	
	<span class="enscript-comment">/* Allow a jitter of &quot;allowed_iaj&quot; milliseconds. Some connections 
	 * may have a constant jitter more than that. We detect this by 
	 * using standard deviation.
	 */</span>
	allowed_iaj = tp-&gt;avg_iaj + tp-&gt;std_dev_iaj;
	<span class="enscript-keyword">if</span> (allowed_iaj &lt; tcp_allowed_iaj)
		allowed_iaj = tcp_allowed_iaj;

	<span class="enscript-comment">/* Initially when the connection starts, the senders congestion 
	 * window is small. During this period we avoid throttling a 
	 * connection because we do not have a good starting point for 
	 * allowed_iaj. IAJ_IGNORE_PKTCNT is used to quietly gloss over 
	 * the first few packets.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;iaj_pktcnt &gt; IAJ_IGNORE_PKTCNT) {
		<span class="enscript-keyword">if</span> ( cur_iaj &lt;= allowed_iaj ) {
			<span class="enscript-keyword">if</span> (tp-&gt;acc_iaj &gt;= 2)
				acc_iaj = tp-&gt;acc_iaj - 2;
			<span class="enscript-keyword">else</span>
				acc_iaj = 0;
				
		} <span class="enscript-keyword">else</span> {
			acc_iaj = tp-&gt;acc_iaj + (cur_iaj - allowed_iaj);
		}

		<span class="enscript-keyword">if</span> (acc_iaj &gt; MAX_ACC_IAJ)
			acc_iaj = MAX_ACC_IAJ;
		tp-&gt;acc_iaj = acc_iaj;
	}

	<span class="enscript-comment">/* Compute weighted average where the history has a weight of
	 * 15 out of 16 and the current value has a weight of 1 out of 16. 
	 * This will make the short-term measurements have more weight.
	 *
	 * The addition of 8 will help to round-up the value 
	 * instead of round-down
	 */</span>
	tp-&gt;avg_iaj = (((tp-&gt;avg_iaj &lt;&lt; IAJ_DIV_SHIFT) - tp-&gt;avg_iaj) 
		+ cur_iaj + IAJ_ROUNDUP_CONST) &gt;&gt; IAJ_DIV_SHIFT;

	<span class="enscript-comment">/* Compute Root-mean-square of deviation where mean is a weighted
	 * average as described above. 
	 */</span>
	temp = tp-&gt;std_dev_iaj * tp-&gt;std_dev_iaj;
	mean = (((temp &lt;&lt; IAJ_DIV_SHIFT) - temp) 
		+ (cur_iaj_dev * cur_iaj_dev) 
		+ IAJ_ROUNDUP_CONST) &gt;&gt; IAJ_DIV_SHIFT;
	
	tp-&gt;std_dev_iaj = isqrt(mean);

	DTRACE_TCP3(iaj, <span class="enscript-type">struct</span> tcpcb *, tp, uint32_t, cur_iaj, 
		uint32_t, allowed_iaj);

	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

<span class="enscript-comment">/* Check if enough amount of data has been acknowledged since 
 * bw measurement was started
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_bwmeas_check</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	int32_t bw_meas_bytes;
	uint32_t bw, bytes, elapsed_time;
	bw_meas_bytes = tp-&gt;snd_una - tp-&gt;t_bwmeas-&gt;bw_start;
	<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_BWMEAS_INPROGRESS) != 0 &amp;&amp;
	    bw_meas_bytes &gt;= (int32_t)(tp-&gt;t_bwmeas-&gt;bw_size)) {
		bytes = bw_meas_bytes;
		elapsed_time = tcp_now - tp-&gt;t_bwmeas-&gt;bw_ts;
		<span class="enscript-keyword">if</span> (elapsed_time &gt; 0) {
			bw = bytes / elapsed_time;
			<span class="enscript-keyword">if</span> ( bw &gt; 0) {
				<span class="enscript-keyword">if</span> (tp-&gt;t_bwmeas-&gt;bw_sndbw &gt; 0) {
					tp-&gt;t_bwmeas-&gt;bw_sndbw = 
					    (((tp-&gt;t_bwmeas-&gt;bw_sndbw &lt;&lt; 3) - tp-&gt;t_bwmeas-&gt;bw_sndbw) + bw) &gt;&gt; 3;
				} <span class="enscript-keyword">else</span> {
					tp-&gt;t_bwmeas-&gt;bw_sndbw = bw;
				}
			}
		}
		tp-&gt;t_flagsext &amp;= ~(TF_BWMEAS_INPROGRESS);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_reass</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">int</span> *tlenp, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> tseg_qent *q;
	<span class="enscript-type">struct</span> tseg_qent *p = NULL;
	<span class="enscript-type">struct</span> tseg_qent *nq;
	<span class="enscript-type">struct</span> tseg_qent *te = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> flags = 0;
	<span class="enscript-type">int</span> dowakeup = 0;
	<span class="enscript-type">struct</span> mbuf *oodata = NULL;
	<span class="enscript-type">int</span> copy_oodata = 0;
	u_int16_t qlimit;
	boolean_t cell = IFNET_IS_CELLULAR(ifp);
	boolean_t wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	boolean_t wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));
	boolean_t dsack_set = FALSE;

	<span class="enscript-comment">/*
	 * Call with th==0 after become established to
	 * force pre-ESTABLISHED data up to user socket.
	 */</span>
	<span class="enscript-keyword">if</span> (th == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">present</span>;
	
	<span class="enscript-comment">/*
	 * If the reassembly queue already has entries or if we are going 
	 * to add a new one, then the connection has reached a loss state. 
	 * Reset the stretch-ack algorithm at this point.
	 */</span>
	tcp_reset_stretch_ack(tp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
	<span class="enscript-keyword">if</span> (tp-&gt;acc_iaj &gt; 0)
		reset_acc_iaj(tp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>	

	<span class="enscript-comment">/*
	 * Limit the number of segments in the reassembly queue to prevent
	 * holding on to too many segments (and thus running out of mbufs).
	 * Make sure to let the missing segment through which caused this
	 * queue.  Always keep one global queue entry spare to be able to
	 * process the missing segment.
	 */</span>
	qlimit = min(max(100, so-&gt;so_rcv.sb_hiwat &gt;&gt; 10),
	    tcp_autorcvbuf_max &gt;&gt; 10); 
	<span class="enscript-keyword">if</span> (th-&gt;th_seq != tp-&gt;rcv_nxt &amp;&amp;
	    (tp-&gt;t_reassqlen + 1) &gt;= qlimit) {
		tcp_reass_overflows++;
		tcpstat.tcps_rcvmemdrop++;
		m_freem(m);
		*tlenp = 0;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* Allocate a new queue entry. If we can't, just drop the pkt. XXX */</span>
	te = (<span class="enscript-type">struct</span> tseg_qent *) zalloc(tcp_reass_zone);
	<span class="enscript-keyword">if</span> (te == NULL) {
		tcpstat.tcps_rcvmemdrop++;
		m_freem(m);
		<span class="enscript-keyword">return</span> (0);
	}
	tp-&gt;t_reassqlen++;

	<span class="enscript-comment">/*
	 * Find a segment which begins after this one does.
	 */</span>
	LIST_FOREACH(q, &amp;tp-&gt;t_segq, tqe_q) {
		<span class="enscript-keyword">if</span> (SEQ_GT(q-&gt;tqe_th-&gt;th_seq, th-&gt;th_seq))
			<span class="enscript-keyword">break</span>;
		p = q;
	}

	<span class="enscript-comment">/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us.
	 */</span>
	<span class="enscript-keyword">if</span> (p != NULL) {
		<span class="enscript-type">int</span> i;
		<span class="enscript-comment">/* conversion to int (in i) handles seq wraparound */</span>
		i = p-&gt;tqe_th-&gt;th_seq + p-&gt;tqe_len - th-&gt;th_seq;
		<span class="enscript-keyword">if</span> (i &gt; 0) {
			<span class="enscript-keyword">if</span> (TCP_DSACK_ENABLED(tp) &amp;&amp; i &gt; 1) {
				<span class="enscript-comment">/*
				 * Note duplicate data sequnce numbers
				 * to report in DSACK option
				 */</span>
				tp-&gt;t_dsack_lseq = th-&gt;th_seq;
				tp-&gt;t_dsack_rseq = th-&gt;th_seq +
				    min(i, *tlenp);

				<span class="enscript-comment">/*
				 * Report only the first part of partial/
				 * non-contiguous duplicate sequence space
				 */</span>
				dsack_set = TRUE;
			}
			<span class="enscript-keyword">if</span> (i &gt;= *tlenp) {
				tcpstat.tcps_rcvduppack++;
				tcpstat.tcps_rcvdupbyte += *tlenp;
				<span class="enscript-keyword">if</span> (nstat_collect) {
					nstat_route_rx(inp-&gt;inp_route.ro_rt,
					    1, *tlenp,
					    NSTAT_RX_FLAG_DUPLICATE);
					INP_ADD_STAT(inp, cell, wifi, wired,
					    rxpackets, 1);
					INP_ADD_STAT(inp, cell, wifi, wired,
					    rxbytes, *tlenp);
					tp-&gt;t_stat.rxduplicatebytes += *tlenp;
				}
				m_freem(m);
				zfree(tcp_reass_zone, te);
				te = NULL;
				tp-&gt;t_reassqlen--;
				<span class="enscript-comment">/*
				 * Try to present any queued data
				 * at the left window edge to the user.
				 * This is needed after the 3-WHS
				 * completes.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">present</span>;
			}
			m_adj(m, i);
			*tlenp -= i;
			th-&gt;th_seq += i;
		}
	}
	tcpstat.tcps_rcvoopack++;
	tcpstat.tcps_rcvoobyte += *tlenp;
	<span class="enscript-keyword">if</span> (nstat_collect) {
		nstat_route_rx(inp-&gt;inp_route.ro_rt, 1, *tlenp,
		    NSTAT_RX_FLAG_OUT_OF_ORDER);
		INP_ADD_STAT(inp, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(inp, cell, wifi, wired, rxbytes, *tlenp);
		tp-&gt;t_stat.rxoutoforderbytes += *tlenp;
	}

	<span class="enscript-comment">/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */</span>
	<span class="enscript-keyword">while</span> (q) {
		<span class="enscript-type">int</span> i = (th-&gt;th_seq + *tlenp) - q-&gt;tqe_th-&gt;th_seq;
		<span class="enscript-keyword">if</span> (i &lt;= 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Report only the first part of partial/non-contiguous
		 * duplicate segment in dsack option. The variable
		 * dsack_set will be true if a previous entry has some of
		 * the duplicate sequence space.
		 */</span>
		<span class="enscript-keyword">if</span> (TCP_DSACK_ENABLED(tp) &amp;&amp; i &gt; 1 &amp;&amp; !dsack_set) {
			<span class="enscript-keyword">if</span> (tp-&gt;t_dsack_lseq == 0) {
				tp-&gt;t_dsack_lseq = q-&gt;tqe_th-&gt;th_seq;
				tp-&gt;t_dsack_rseq =
				    tp-&gt;t_dsack_lseq + min(i, q-&gt;tqe_len);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * this segment overlaps data in multple
				 * entries in the reassembly queue, move
				 * the right sequence number further.
				 */</span>
				tp-&gt;t_dsack_rseq =
				    tp-&gt;t_dsack_rseq + min(i, q-&gt;tqe_len);
			}
		}
		<span class="enscript-keyword">if</span> (i &lt; q-&gt;tqe_len) {
			q-&gt;tqe_th-&gt;th_seq += i;
			q-&gt;tqe_len -= i;
			m_adj(q-&gt;tqe_m, i);
			<span class="enscript-keyword">break</span>;
		}

		nq = LIST_NEXT(q, tqe_q);
		LIST_REMOVE(q, tqe_q);
		m_freem(q-&gt;tqe_m);
		zfree(tcp_reass_zone, q);
		tp-&gt;t_reassqlen--;
		q = nq;
	}

	<span class="enscript-comment">/* Insert the new segment queue entry into place. */</span>
	te-&gt;tqe_m = m;
	te-&gt;tqe_th = th;
	te-&gt;tqe_len = *tlenp;

	<span class="enscript-keyword">if</span> (p == NULL) {
		LIST_INSERT_HEAD(&amp;tp-&gt;t_segq, te, tqe_q);
	} <span class="enscript-keyword">else</span> {
		LIST_INSERT_AFTER(p, te, tqe_q);
	}

	<span class="enscript-comment">/* 
	 * New out-of-order data exists, and is pointed to by
	 * queue entry te. Set copy_oodata to 1 so out-of-order data 
	 * can be copied off to sockbuf after in-order data 
	 * is copied off.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; SS_CANTRCVMORE))
		copy_oodata = 1;

<span class="enscript-reference">present</span>:
	<span class="enscript-comment">/*
	 * Present data to user, advancing rcv_nxt through
	 * completed sequence space.
	 */</span>
	<span class="enscript-keyword">if</span> (!TCPS_HAVEESTABLISHED(tp-&gt;t_state))
		<span class="enscript-keyword">return</span> (0);
	q = LIST_FIRST(&amp;tp-&gt;t_segq);
	<span class="enscript-keyword">if</span> (!q || q-&gt;tqe_th-&gt;th_seq != tp-&gt;rcv_nxt) {
		<span class="enscript-comment">/* Stop using LRO once out of order packets arrive */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_LRO_OFFLOADED) {
			tcp_lro_remove_state(inp-&gt;inp_laddr, inp-&gt;inp_faddr,
				th-&gt;th_dport, th-&gt;th_sport);
			tp-&gt;t_flagsext &amp;= ~TF_LRO_OFFLOADED;	
		}

		<span class="enscript-comment">/*
		 * continue processing if out-of-order data 
		 * can be delivered
		 */</span>
		<span class="enscript-keyword">if</span> (q &amp;&amp; (so-&gt;so_flags &amp; SOF_ENABLE_MSGS))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msg_unordered_delivery</span>;

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* lost packet was recovered, so ooo data can be returned */</span>
	tcpstat.tcps_recovered_pkts++;

	<span class="enscript-keyword">do</span> {
		tp-&gt;rcv_nxt += q-&gt;tqe_len;
		flags = q-&gt;tqe_th-&gt;th_flags &amp; TH_FIN;
		nq = LIST_NEXT(q, tqe_q);
		LIST_REMOVE(q, tqe_q);
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE) {
			m_freem(q-&gt;tqe_m);
		} <span class="enscript-keyword">else</span> {
			so_recv_data_stat(so, q-&gt;tqe_m, 0); <span class="enscript-comment">/* XXXX */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
				<span class="enscript-comment">/* 
				 * Append the inorder data as a message to the 
				 * receive socket buffer. Also check to see if 
				 * the data we are about to deliver is the same 
				 * data that we wanted to pass up to the user 
				 * out of order. If so, reset copy_oodata -- 
				 * the received data filled a gap, and
				 * is now in order!
				 */</span>
				<span class="enscript-keyword">if</span> (q == te)
					copy_oodata = 0;
			}
			<span class="enscript-keyword">if</span> (sbappendstream_rcvdemux(so, q-&gt;tqe_m, 
			    q-&gt;tqe_th-&gt;th_seq - (tp-&gt;irs + 1), 0))
				dowakeup = 1;
			<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_LRO_OFFLOADED) {	
				tcp_update_lro_seq(tp-&gt;rcv_nxt, 
				 inp-&gt;inp_laddr, inp-&gt;inp_faddr,
				 th-&gt;th_dport, th-&gt;th_sport);
			}
		}
		zfree(tcp_reass_zone, q);
		tp-&gt;t_reassqlen--;
		q = nq;
	} <span class="enscript-keyword">while</span> (q &amp;&amp; q-&gt;tqe_th-&gt;th_seq == tp-&gt;rcv_nxt);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0) {
	
		KERNEL_DEBUG(DBG_LAYER_BEG,
		     ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
		     (((inp-&gt;in6p_laddr.s6_addr16[0] &amp; 0xffff) &lt;&lt; 16) |
		      (inp-&gt;in6p_faddr.s6_addr16[0] &amp; 0xffff)),
		     0,0,0);
	}
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		KERNEL_DEBUG(DBG_LAYER_BEG,
		     ((inp-&gt;inp_fport &lt;&lt; 16) | inp-&gt;inp_lport),
		     (((inp-&gt;inp_laddr.s_addr &amp; 0xffff) &lt;&lt; 16) |
		      (inp-&gt;inp_faddr.s_addr &amp; 0xffff)),
		     0,0,0);
	}

<span class="enscript-reference">msg_unordered_delivery</span>:
	<span class="enscript-comment">/* Deliver out-of-order data as a message */</span>
	<span class="enscript-keyword">if</span> (te &amp;&amp; (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) &amp;&amp; copy_oodata &amp;&amp; te-&gt;tqe_len) {
		<span class="enscript-comment">/* 
		 * make a copy of the mbuf to be delivered up to 
		 * the user, and add it to the sockbuf
		 */</span>
		oodata = m_copym(te-&gt;tqe_m, 0, M_COPYALL, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (oodata != NULL) {
			<span class="enscript-keyword">if</span> (sbappendmsgstream_rcv(&amp;so-&gt;so_rcv, oodata, 
				te-&gt;tqe_th-&gt;th_seq - (tp-&gt;irs + 1), 1)) {
				dowakeup = 1;
				tcpstat.tcps_msg_unopkts++;
			} <span class="enscript-keyword">else</span> {
				tcpstat.tcps_msg_unoappendfail++;
			}
		}
	}

	<span class="enscript-keyword">if</span> (dowakeup)
		sorwakeup(so); <span class="enscript-comment">/* done with socket lock held */</span>
	<span class="enscript-keyword">return</span> (flags);
}

<span class="enscript-comment">/*
 * Reduce congestion window -- used when ECN is seen or when a tail loss
 * probe recovers the last packet.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_reduce_congestion_window</span>(
	<span class="enscript-type">struct</span> tcpcb	*tp)
{
	<span class="enscript-comment">/*
	 * If the current tcp cc module has
	 * defined a hook for tasks to run
	 * before entering FR, call it
	 */</span>
	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;pre_fr != NULL)
		CC_ALGO(tp)-&gt;pre_fr(tp);
	ENTER_FASTRECOVERY(tp);
	<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_SENTFIN)
		tp-&gt;snd_recover = tp-&gt;snd_max - 1;
	<span class="enscript-keyword">else</span>
		tp-&gt;snd_recover = tp-&gt;snd_max;
	tp-&gt;t_timer[TCPT_REXMT] = 0;
	tp-&gt;t_timer[TCPT_PTO] = 0;
	tp-&gt;t_rtttime = 0;
	<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_CWND_NONVALIDATED) {
		tcp_cc_adjust_nonvalidated_cwnd(tp);
	} <span class="enscript-keyword">else</span> {
		tp-&gt;snd_cwnd = tp-&gt;snd_ssthresh +
		    tp-&gt;t_maxseg * tcprexmtthresh;
	}
}

<span class="enscript-comment">/*
 * This function is called upon reception of data on a socket. It's purpose is
 * to handle the adaptive keepalive timers that monitor whether the connection
 * is making progress. First the adaptive read-timer, second the TFO probe-timer.
 *
 * The application wants to get an event if there is a stall during read.
 * Set the initial keepalive timeout to be equal to twice RTO.
 *
 * If the outgoing interface is in marginal conditions, we need to
 * enable read probes for that too.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_adaptive_rwtimo_check</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> tlen)
{
	<span class="enscript-type">struct</span> ifnet *outifp = tp-&gt;t_inpcb-&gt;inp_last_outifp;

	<span class="enscript-keyword">if</span> ((tp-&gt;t_adaptive_rtimo &gt; 0 ||
	    (outifp != NULL &amp;&amp;
	    (outifp-&gt;if_eflags &amp; IFEF_PROBE_CONNECTIVITY)))
	    &amp;&amp; tlen &gt; 0 &amp;&amp;
	    tp-&gt;t_state == TCPS_ESTABLISHED) {
		tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
			(TCP_REXMTVAL(tp) &lt;&lt; 1));
		tp-&gt;t_flagsext |= TF_DETECT_READSTALL;
		tp-&gt;t_rtimo_probes = 0;
	}
}

inline <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_keepalive_reset</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, 
		TCP_CONN_KEEPIDLE(tp));
	tp-&gt;t_flagsext &amp;= ~(TF_DETECT_READSTALL);
	tp-&gt;t_rtimo_probes = 0;
}

<span class="enscript-comment">/*
 * TCP input routine, follows pages 65-76 of the
 * protocol specification dated September, 1981 very closely.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_input</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> *offp, <span class="enscript-type">int</span> proto)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> mbuf *m = *mp;
	uint32_t ia6_flags;
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;

	IP6_EXTHDR_CHECK(m, *offp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr), <span class="enscript-keyword">return</span> IPPROTO_DONE);

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-comment">/*
	 * draft-itojun-ipv6-tcp-to-anycast
	 * better place to put this in?
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_getdstifaddr_info(m, NULL, &amp;ia6_flags) == 0) {
		<span class="enscript-keyword">if</span> (ia6_flags &amp; IN6_IFF_ANYCAST) {
			<span class="enscript-type">struct</span> ip6_hdr *ip6;

			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			icmp6_error(m, ICMP6_DST_UNREACH,
			    ICMP6_DST_UNREACH_ADDR,
			    (caddr_t)&amp;ip6-&gt;ip6_dst - (caddr_t)ip6);

			IF_TCP_STATINC(ifp, icmp6unreach);

			<span class="enscript-keyword">return</span> (IPPROTO_DONE);
		}
	}

	tcp_input(m, *offp);
	<span class="enscript-keyword">return</span> (IPPROTO_DONE);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Depending on the usage of mbuf space in the system, this function
 * will return true or false. This is used to determine if a socket 
 * buffer can take more memory from the system for auto-tuning or not.
 */</span>
u_int8_t
<span class="enscript-function-name">tcp_cansbgrow</span>(<span class="enscript-type">struct</span> sockbuf *sb)
{
	<span class="enscript-comment">/* Calculate the host level space limit in terms of MSIZE buffers.
	 * We can use a maximum of half of the available mbuf space for
	 * socket buffers. 
	 */</span>
	u_int32_t mblim = ((nmbclusters &gt;&gt; 1) &lt;&lt; (MCLSHIFT - MSIZESHIFT));

	<span class="enscript-comment">/* Calculate per sb limit in terms of bytes. We optimize this limit
	 * for upto 16 socket buffers.
	 */</span>

	u_int32_t sbspacelim = ((nmbclusters &gt;&gt; 4) &lt;&lt; MCLSHIFT);

	<span class="enscript-keyword">if</span> ((total_sbmb_cnt &lt; mblim) &amp;&amp;
		(sb-&gt;sb_hiwat &lt; sbspacelim)) {
		<span class="enscript-keyword">return</span>(1);
	} <span class="enscript-keyword">else</span> {
		OSIncrementAtomic64(&amp;sbmb_limreached);
	}
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sbrcv_reserve</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sbrcv,
	u_int32_t newsize, u_int32_t idealsize)
{

	<span class="enscript-comment">/* newsize should not exceed max */</span>
	newsize = min(newsize, tcp_autorcvbuf_max);

	<span class="enscript-comment">/* The receive window scale negotiated at the 
	 * beginning of the connection will also set a 
	 * limit on the socket buffer size
	 */</span>
	newsize = min(newsize, TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);

	<span class="enscript-comment">/* Set new socket buffer size */</span>
	<span class="enscript-keyword">if</span> (newsize &gt; sbrcv-&gt;sb_hiwat &amp;&amp;
		(sbreserve(sbrcv, newsize) == 1)) {
		sbrcv-&gt;sb_idealsize = min(max(sbrcv-&gt;sb_idealsize, 
			(idealsize != 0) ? idealsize : newsize), 
			tcp_autorcvbuf_max);

		<span class="enscript-comment">/* Again check the limit set by the advertised 
		 * window scale 
		 */</span>
		sbrcv-&gt;sb_idealsize = min(sbrcv-&gt;sb_idealsize, 
			TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);
	}
}

<span class="enscript-comment">/* 
 * This function is used to grow  a receive socket buffer. It
 * will take into account system-level memory usage and the
 * bandwidth available on the link to make a decision.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sbrcv_grow</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sbrcv, 
	<span class="enscript-type">struct</span> tcpopt *to, u_int32_t pktlen) 
{
	<span class="enscript-type">struct</span> socket *so = sbrcv-&gt;sb_so;
	
	<span class="enscript-comment">/*
	 * Do not grow the receive socket buffer if
	 * - auto resizing is disabled, globally or on this socket
	 * - the high water mark already reached the maximum
	 * - the stream is in background and receive side is being 
	 * throttled
	 * - if there are segments in reassembly queue indicating loss,
	 * do not need to increase recv window during recovery as more 
	 * data is not going to be sent. A duplicate ack sent during
	 * recovery should not change the receive window
	 */</span>
	<span class="enscript-keyword">if</span> (tcp_do_autorcvbuf == 0 ||
		(sbrcv-&gt;sb_flags &amp; SB_AUTOSIZE) == 0 ||
		tcp_cansbgrow(sbrcv) == 0 ||
		sbrcv-&gt;sb_hiwat &gt;= tcp_autorcvbuf_max ||
		(tp-&gt;t_flagsext &amp; TF_RECV_THROTTLE) ||
		(so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) ||
		!LIST_EMPTY(&amp;tp-&gt;t_segq)) {
		<span class="enscript-comment">/* Can not resize the socket buffer, just return */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (TSTMP_GT(tcp_now,
		tp-&gt;rfbuf_ts + TCPTV_RCVBUFIDLE)) {
		<span class="enscript-comment">/* If there has been an idle period in the
		 * connection, just restart the measurement
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (!TSTMP_SUPPORTED(tp)) {
		<span class="enscript-comment">/*
		 * Timestamp option is not supported on this connection.
		 * If the connection reached a state to indicate that
		 * the receive socket buffer needs to grow, increase
		 * the high water mark.
		 */</span>
		<span class="enscript-keyword">if</span> (TSTMP_GEQ(tcp_now, 
			tp-&gt;rfbuf_ts + TCPTV_RCVNOTS_QUANTUM)) {
			<span class="enscript-keyword">if</span> (tp-&gt;rfbuf_cnt &gt;= TCP_RCVNOTS_BYTELEVEL) {
				tcp_sbrcv_reserve(tp, sbrcv,
					tcp_autorcvbuf_max, 0);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			tp-&gt;rfbuf_cnt += pktlen;
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (to-&gt;to_tsecr != 0) {
		<span class="enscript-comment">/*
		 * If the timestamp shows that one RTT has
		 * completed, we can stop counting the
		 * bytes. Here we consider increasing
		 * the socket buffer if the bandwidth measured in
		 * last rtt, is more than half of sb_hiwat, this will
		 * help to scale the buffer according to the bandwidth
		 * on the link.
		 */</span>
		<span class="enscript-keyword">if</span> (TSTMP_GEQ(to-&gt;to_tsecr, tp-&gt;rfbuf_ts)) {
			<span class="enscript-keyword">if</span> (tp-&gt;rfbuf_cnt &gt; (sbrcv-&gt;sb_hiwat -
				(sbrcv-&gt;sb_hiwat &gt;&gt; 1))) {
				int32_t rcvbuf_inc, min_incr;
				<span class="enscript-comment">/*
				 * Increment the receive window by a
				 * multiple of maximum sized segments.
				 * This will prevent a connection from 
				 * sending smaller segments on wire if it
				 * is limited by the receive window.
				 *
				 * Set the ideal size based on current
				 * bandwidth measurements. We set the 
				 * ideal size on receive socket buffer to
				 * be twice the bandwidth delay product.
				 */</span>
				rcvbuf_inc = (tp-&gt;rfbuf_cnt &lt;&lt; 1)
				    - sbrcv-&gt;sb_hiwat;

				<span class="enscript-comment">/*
				 * Make the increment equal to 8 segments
				 * at least
				 */</span>
				min_incr = tp-&gt;t_maxseg &lt;&lt; tcp_autorcvbuf_inc_shift;
				<span class="enscript-keyword">if</span> (rcvbuf_inc &lt; min_incr)
				    rcvbuf_inc = min_incr;

				rcvbuf_inc = 
				    (rcvbuf_inc / tp-&gt;t_maxseg) * tp-&gt;t_maxseg;
				tcp_sbrcv_reserve(tp, sbrcv,
					sbrcv-&gt;sb_hiwat + rcvbuf_inc, 
					(tp-&gt;rfbuf_cnt * 2));
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			tp-&gt;rfbuf_cnt += pktlen;
			<span class="enscript-keyword">return</span>;
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* Restart the measurement */</span>
	tp-&gt;rfbuf_ts = 0;
	tp-&gt;rfbuf_cnt = 0;
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* This function will trim the excess space added to the socket buffer
 * to help a slow-reading app. The ideal-size of a socket buffer depends
 * on the link bandwidth or it is set by an application and we aim to 
 * reach that size.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sbrcv_trim</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sbrcv) {
	<span class="enscript-keyword">if</span> (tcp_do_autorcvbuf == 1 &amp;&amp; sbrcv-&gt;sb_idealsize &gt; 0 &amp;&amp;
		sbrcv-&gt;sb_hiwat &gt; sbrcv-&gt;sb_idealsize) {
		int32_t trim;
		<span class="enscript-comment">/* compute the difference between ideal and current sizes */</span>
		u_int32_t diff = sbrcv-&gt;sb_hiwat - sbrcv-&gt;sb_idealsize;

		<span class="enscript-comment">/* Compute the maximum advertised window for
		 * this connection.
		 */</span>
		u_int32_t advwin = tp-&gt;rcv_adv - tp-&gt;rcv_nxt;
		
		<span class="enscript-comment">/* How much can we trim the receive socket buffer?
		 * 1. it can not be trimmed beyond the max rcv win advertised
		 * 2. if possible, leave 1/16 of bandwidth*delay to 
		 * avoid closing the win completely
		 */</span>
		u_int32_t leave = max(advwin, (sbrcv-&gt;sb_idealsize &gt;&gt; 4));

		<span class="enscript-comment">/* Sometimes leave can be zero, in that case leave at least
 		 * a few segments worth of space.
		 */</span>
		<span class="enscript-keyword">if</span> (leave == 0)
			leave = tp-&gt;t_maxseg &lt;&lt; tcp_autorcvbuf_inc_shift;
		
		trim = sbrcv-&gt;sb_hiwat - (sbrcv-&gt;sb_cc + leave);
		trim = imin(trim, (int32_t)diff);

		<span class="enscript-keyword">if</span> (trim &gt; 0)
			sbreserve(sbrcv, (sbrcv-&gt;sb_hiwat - trim));
	}
}

<span class="enscript-comment">/* We may need to trim the send socket buffer size for two reasons:
 * 1. if the rtt seen on the connection is climbing up, we do not
 * want to fill the buffers any more.
 * 2. if the congestion win on the socket backed off, there is no need
 * to hold more mbufs for that connection than what the cwnd will allow.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sbsnd_trim</span>(<span class="enscript-type">struct</span> sockbuf *sbsnd) {
	<span class="enscript-keyword">if</span> (tcp_do_autosendbuf == 1 &amp;&amp; 
		((sbsnd-&gt;sb_flags &amp; (SB_AUTOSIZE | SB_TRIM)) == 
			(SB_AUTOSIZE | SB_TRIM)) &amp;&amp;
		(sbsnd-&gt;sb_idealsize &gt; 0) &amp;&amp;
		(sbsnd-&gt;sb_hiwat &gt; sbsnd-&gt;sb_idealsize)) {
		u_int32_t trim = 0;
		<span class="enscript-keyword">if</span> (sbsnd-&gt;sb_cc &lt;= sbsnd-&gt;sb_idealsize) {
			trim = sbsnd-&gt;sb_hiwat - sbsnd-&gt;sb_idealsize;
		} <span class="enscript-keyword">else</span> {
			trim = sbsnd-&gt;sb_hiwat - sbsnd-&gt;sb_cc;
		}
		sbreserve(sbsnd, (sbsnd-&gt;sb_hiwat - trim));
	}
	<span class="enscript-keyword">if</span> (sbsnd-&gt;sb_hiwat &lt;= sbsnd-&gt;sb_idealsize)
		sbsnd-&gt;sb_flags &amp;= ~(SB_TRIM);
}

<span class="enscript-comment">/* 
 * If timestamp option was not negotiated on this connection
 * and this connection is on the receiving side of a stream
 * then we can not measure the delay on the link accurately.
 * Instead of enabling automatic receive socket buffer
 * resizing, just give more space to the receive socket buffer.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> 
<span class="enscript-function-name">tcp_sbrcv_tstmp_check</span>(<span class="enscript-type">struct</span> tcpcb *tp) {
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
	u_int32_t newsize = 2 * tcp_recvspace;
	<span class="enscript-type">struct</span> sockbuf *sbrcv = &amp;so-&gt;so_rcv;

	<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; (TF_REQ_TSTMP | TF_RCVD_TSTMP)) !=
		(TF_REQ_TSTMP | TF_RCVD_TSTMP) &amp;&amp;
		(sbrcv-&gt;sb_flags &amp; SB_AUTOSIZE) != 0) {
		tcp_sbrcv_reserve(tp, sbrcv, newsize, 0);
	}
}

<span class="enscript-comment">/* A receiver will evaluate the flow of packets on a connection 
 * to see if it can reduce ack traffic. The receiver will start 
 * stretching acks if all of the following conditions are met:
 * 1. tcp_delack_enabled is set to 3
 * 2. If the bytes received in the last 100ms is greater than a threshold
 *      defined by maxseg_unacked
 * 3. If the connection has not been idle for tcp_maxrcvidle period.
 * 4. If the connection has seen enough packets to let the slow-start 
 *      finish after connection establishment or after some packet loss.
 *
 * The receiver will stop stretching acks if there is congestion/reordering
 * as indicated by packets on reassembly queue or an ECN. If the delayed-ack 
 * timer fires while stretching acks, it means that the packet flow has gone 
 * below the threshold defined by maxseg_unacked and the receiver will stop
 * stretching acks. The receiver gets no indication when slow-start is completed 
 * or when the connection reaches an idle state. That is why we use 
 * tcp_rcvsspktcnt to cover slow-start and tcp_maxrcvidle to identify idle 
 * state.
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_stretch_ack_enable</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
 	<span class="enscript-keyword">if</span> (!(tp-&gt;t_flagsext &amp; (TF_NOSTRETCHACK|TF_DISABLE_STRETCHACK)) &amp;&amp;
		tp-&gt;rcv_by_unackwin &gt;= (maxseg_unacked * tp-&gt;t_maxseg) &amp;&amp;
		TSTMP_GT(tp-&gt;rcv_unackwin + tcp_maxrcvidle, tcp_now) &amp;&amp;
		(!(tp-&gt;t_flagsext &amp; TF_RCVUNACK_WAITSS) ||
		(tp-&gt;rcv_waitforss &gt;= tcp_rcvsspktcnt))) {
		<span class="enscript-keyword">return</span>(1);
	}
		 
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Reset the state related to stretch-ack algorithm. This will make
 * the receiver generate an ack every other packet. The receiver
 * will start re-evaluating the rate at which packets come to decide 
 * if it can benefit by lowering the ack traffic.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_reset_stretch_ack</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	tp-&gt;t_flags &amp;= ~(TF_STRETCHACK);
	tp-&gt;rcv_by_unackwin = 0;
	tp-&gt;rcv_unackwin = tcp_now + tcp_rcvunackwin;

	<span class="enscript-comment">/*
	 * When there is packet loss or packet re-ordering or CWR due to
	 * ECN, the sender's congestion window is reduced. In these states,
	 * generate an ack for every other packet for some time to allow
	 * the sender's congestion window to grow. 
	 */</span>
	tp-&gt;t_flagsext |= TF_RCVUNACK_WAITSS;
	tp-&gt;rcv_waitforss = 0;
}

<span class="enscript-comment">/*
 * The last packet was a retransmission, check if this ack 
 * indicates that the retransmission was spurious.
 * 
 * If the connection supports timestamps, we could use it to
 * detect if the last retransmit was not needed. Otherwise,
 * we check if the ACK arrived within RTT/2 window, then it 
 * was a mistake to do the retransmit in the first place.
 *
 * This function will return 1 if it is a spurious retransmit, 
 * 0 otherwise. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_detect_bad_rexmt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th, 
	<span class="enscript-type">struct</span> tcpopt *to, u_int32_t rxtime)
{
	int32_t tdiff, bad_rexmt_win;
	bad_rexmt_win = (tp-&gt;t_srtt &gt;&gt; (TCP_RTT_SHIFT + 1));

	<span class="enscript-comment">/* If the ack has ECN CE bit, then cwnd has to be adjusted */</span>
	<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp) &amp;&amp; (th-&gt;th_flags &amp; TH_ECE))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (TSTMP_SUPPORTED(tp)) {
		<span class="enscript-keyword">if</span> (rxtime &gt; 0 &amp;&amp; (to-&gt;to_flags &amp; TOF_TS)
		    &amp;&amp; to-&gt;to_tsecr != 0 
		    &amp;&amp; TSTMP_LT(to-&gt;to_tsecr, rxtime))
		    <span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((tp-&gt;t_rxtshift == 1 
		    || (tp-&gt;t_flagsext &amp; TF_SENT_TLPROBE))
		    &amp;&amp; rxtime &gt; 0) {
			tdiff = (int32_t)(tcp_now - rxtime);
			<span class="enscript-keyword">if</span> (tdiff &lt; bad_rexmt_win)
				<span class="enscript-keyword">return</span>(1);
		}
	}
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * Restore congestion window state if a spurious timeout
 * was detected.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_bad_rexmt_restore_state</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-keyword">if</span> (TSTMP_SUPPORTED(tp)) {
		u_int32_t fsize, acked;
		fsize = tp-&gt;snd_max - th-&gt;th_ack;
		acked = BYTES_ACKED(th, tp);

		<span class="enscript-comment">/*
		 * Implement bad retransmit recovery as
		 * described in RFC 4015.
		 */</span>
		tp-&gt;snd_ssthresh = tp-&gt;snd_ssthresh_prev;

		<span class="enscript-comment">/* Initialize cwnd to the initial window */</span>
		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cwnd_init != NULL)
			CC_ALGO(tp)-&gt;cwnd_init(tp);

		tp-&gt;snd_cwnd = fsize + min(acked, tp-&gt;snd_cwnd);
		
	} <span class="enscript-keyword">else</span> {
		tp-&gt;snd_cwnd = tp-&gt;snd_cwnd_prev;
		tp-&gt;snd_ssthresh = tp-&gt;snd_ssthresh_prev;
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_WASFRECOVERY)
			ENTER_FASTRECOVERY(tp);

		<span class="enscript-comment">/* Do not use the loss flight size in this case */</span>
		tp-&gt;t_lossflightsize = 0;
	}
	tp-&gt;snd_cwnd = max(tp-&gt;snd_cwnd, TCP_CC_CWND_INIT_BYTES);
	tp-&gt;snd_recover = tp-&gt;snd_recover_prev;
	tp-&gt;snd_nxt = tp-&gt;snd_max;
	tp-&gt;t_rxtshift = 0;
	tp-&gt;t_rxtstart = 0;

	<span class="enscript-comment">/* Fix send socket buffer to reflect the change in cwnd */</span>
	tcp_bad_rexmt_fix_sndbuf(tp);

	<span class="enscript-comment">/*
	 * This RTT might reflect the extra delay induced 
	 * by the network. Skip using this sample for RTO
	 * calculation and mark the connection so we can
	 * recompute RTT when the next eligible sample is
	 * found.
	 */</span>
	tp-&gt;t_flagsext |= TF_RECOMPUTE_RTT;
	tp-&gt;t_badrexmt_time = tcp_now;
	tp-&gt;t_rtttime = 0;
}

<span class="enscript-comment">/*
 * If the previous packet was sent in retransmission timer, and it was
 * not needed, then restore the congestion window to the state before that
 * transmission.
 *
 * If the last packet was sent in tail loss probe timeout, check if that
 * recovered the last packet. If so, that will indicate a real loss and
 * the congestion window needs to be lowered.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_bad_rexmt_check</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">struct</span> tcpopt *to)
{
	<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &gt; 0 &amp;&amp;
	    tcp_detect_bad_rexmt(tp, th, to, tp-&gt;t_rxtstart)) {
		++tcpstat.tcps_sndrexmitbad;
		tcp_bad_rexmt_restore_state(tp, th);
		tcp_ccdbg_trace(tp, th, TCP_CC_BAD_REXMT_RECOVERY);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_SENT_TLPROBE)
	    &amp;&amp; tp-&gt;t_tlphighrxt &gt; 0
	    &amp;&amp; SEQ_GEQ(th-&gt;th_ack, tp-&gt;t_tlphighrxt)
	    &amp;&amp; !tcp_detect_bad_rexmt(tp, th, to, tp-&gt;t_tlpstart)) {
		<span class="enscript-comment">/*
		 * check DSACK information also to make sure that
		 * the TLP was indeed needed
		 */</span>
		<span class="enscript-keyword">if</span> (tcp_rxtseg_dsack_for_tlp(tp)) {
			<span class="enscript-comment">/*
			 * received a DSACK to indicate that TLP was
			 * not needed
			 */</span>
			tcp_rxtseg_clean(tp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/*
		 * The tail loss probe recovered the last packet and 
		 * we need to adjust the congestion window to take
		 * this loss into account.
		 */</span>
		++tcpstat.tcps_tlp_recoverlastpkt;
		<span class="enscript-keyword">if</span> (!IN_FASTRECOVERY(tp)) {
			tcp_reduce_congestion_window(tp);
			EXIT_FASTRECOVERY(tp);
		}
		tcp_ccdbg_trace(tp, th, TCP_CC_TLP_RECOVER_LASTPACKET);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tcp_rxtseg_detect_bad_rexmt(tp, th-&gt;th_ack)) {
		<span class="enscript-comment">/*
		 * All of the retransmitted segments were duplicated, this
		 * can be an indication of bad fast retransmit.
		 */</span>
		tcpstat.tcps_dsack_badrexmt++;
		tcp_bad_rexmt_restore_state(tp, th);
		tcp_ccdbg_trace(tp, th, TCP_CC_DSACK_BAD_REXMT);
		tcp_rxtseg_clean(tp);
	}
<span class="enscript-reference">out</span>:
	tp-&gt;t_flagsext &amp;= ~(TF_SENT_TLPROBE);
	tp-&gt;t_tlphighrxt = 0;
	tp-&gt;t_tlpstart = 0;

	<span class="enscript-comment">/*
	 * check if the latest ack was for a segment sent during PMTU
	 * blackhole detection. If the timestamp on the ack is before
	 * PMTU blackhole detection, then revert the size of the max
	 * segment to previous size.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &gt; 0 &amp;&amp; (tp-&gt;t_flags &amp; TF_BLACKHOLE) &amp;&amp;
	    tp-&gt;t_pmtud_start_ts &gt; 0 &amp;&amp; TSTMP_SUPPORTED(tp)) {
		<span class="enscript-keyword">if</span> ((to-&gt;to_flags &amp; TOF_TS) &amp;&amp; to-&gt;to_tsecr != 0 
		    &amp;&amp; TSTMP_LT(to-&gt;to_tsecr, tp-&gt;t_pmtud_start_ts)) {
			tcp_pmtud_revert_segment_size(tp);
		}
	}
	<span class="enscript-keyword">if</span> (tp-&gt;t_pmtud_start_ts &gt; 0)
		tp-&gt;t_pmtud_start_ts = 0;
}

<span class="enscript-comment">/*
 * Check if early retransmit can be attempted according to RFC 5827.
 *
 * If packet reordering is detected on a connection, fast recovery will
 * be delayed until it is clear that the packet was lost and not reordered.
 * But reordering detection is done only when SACK is enabled.
 *
 * On connections that do not support SACK, there is a limit on the number
 * of early retransmits that can be done per minute. This limit is needed
 * to make sure that too many packets are not retransmitted when there is
 * packet reordering.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_early_rexmt_check</span> (<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th)
{
	u_int32_t obytes, snd_off;
	int32_t snd_len;
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (early_rexmt &amp;&amp; (SACK_ENABLED(tp) ||
	    tp-&gt;t_early_rexmt_count &lt; TCP_EARLY_REXMT_LIMIT) &amp;&amp;
	    SEQ_GT(tp-&gt;snd_max, tp-&gt;snd_una) &amp;&amp;
	    (tp-&gt;t_dupacks == 1 || 
	    (SACK_ENABLED(tp) &amp;&amp; 
	    !TAILQ_EMPTY(&amp;tp-&gt;snd_holes)))) {
		<span class="enscript-comment">/*
		 * If there are only a few outstanding 
		 * segments on the connection, we might need
		 * to lower the retransmit threshold. This
		 * will allow us to do Early Retransmit as 
		 * described in RFC 5827.
		 */</span>
		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; 
		    !TAILQ_EMPTY(&amp;tp-&gt;snd_holes)) {
			obytes = (tp-&gt;snd_max - tp-&gt;snd_fack) +
				tp-&gt;sackhint.sack_bytes_rexmit;
		} <span class="enscript-keyword">else</span> {
			obytes = (tp-&gt;snd_max - tp-&gt;snd_una);	
		}

		<span class="enscript-comment">/*
		 * In order to lower retransmit threshold the 
		 * following two conditions must be met.
		 * 1. the amount of outstanding data is less 
		 * than 4*SMSS bytes
		 * 2. there is no unsent data ready for 
		 * transmission or the advertised window 
		 * will limit sending new segments.
		 */</span>
		snd_off = tp-&gt;snd_max - tp-&gt;snd_una;
		snd_len = min(so-&gt;so_snd.sb_cc, tp-&gt;snd_wnd) - snd_off;
		<span class="enscript-keyword">if</span> (obytes &lt; (tp-&gt;t_maxseg &lt;&lt; 2) &amp;&amp; 
		    snd_len &lt;= 0) {
			u_int32_t osegs;

			osegs = obytes / tp-&gt;t_maxseg;
			<span class="enscript-keyword">if</span> ((osegs * tp-&gt;t_maxseg) &lt; obytes)
				osegs++;

			<span class="enscript-comment">/* 
			 * Since the connection might have already 
			 * received some dupacks, we add them to
			 * to the outstanding segments count to get
			 * the correct retransmit threshold.
			 *
			 * By checking for early retransmit after 
			 * receiving some duplicate acks when SACK
			 * is supported, the connection will 
			 * enter fast recovery even if multiple 
			 * segments are lost in the same window.
			 */</span>
			osegs += tp-&gt;t_dupacks;
			<span class="enscript-keyword">if</span> (osegs &lt; 4) {
				tp-&gt;t_rexmtthresh = 
				    ((osegs - 1) &gt; 1) ? (osegs - 1) : 1;
				tp-&gt;t_rexmtthresh =
				    min(tp-&gt;t_rexmtthresh, tcprexmtthresh);
				tp-&gt;t_rexmtthresh =
				    max(tp-&gt;t_rexmtthresh, tp-&gt;t_dupacks);

				<span class="enscript-keyword">if</span> (tp-&gt;t_early_rexmt_count == 0)
					tp-&gt;t_early_rexmt_win = tcp_now;

				<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_SENT_TLPROBE) {
					tcpstat.tcps_tlp_recovery++;
					tcp_ccdbg_trace(tp, th,
					    TCP_CC_TLP_RECOVERY);
				} <span class="enscript-keyword">else</span> {
					tcpstat.tcps_early_rexmt++;
					tp-&gt;t_early_rexmt_count++;
					tcp_ccdbg_trace(tp, th,
					    TCP_CC_EARLY_RETRANSMIT);
				}
			}
		}
	}

	<span class="enscript-comment">/*
	 * If we ever sent a TLP probe, the acknowledgement will trigger
	 * early retransmit because the value of snd_fack will be close
	 * to snd_max. This will take care of adjustments to the
	 * congestion window. So we can reset TF_SENT_PROBE flag.
	 */</span>
	tp-&gt;t_flagsext &amp;= ~(TF_SENT_TLPROBE);
	tp-&gt;t_tlphighrxt = 0;
	tp-&gt;t_tlpstart = 0;
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">tcp_tfo_syn</span>(tp, to)
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> tcpopt *to;
{
	u_char out[CCAES_BLOCK_SIZE];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> len;

	<span class="enscript-keyword">if</span> (!(to-&gt;to_flags &amp; (TOF_TFO | TOF_TFOREQ)) ||
	    !(tcp_fastopen &amp; TCP_FASTOPEN_SERVER))
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> ((to-&gt;to_flags &amp; TOF_TFOREQ)) {
		tp-&gt;t_tfo_flags |= TFO_F_OFFER_COOKIE;

		tp-&gt;t_tfo_stats |= TFO_S_COOKIEREQ_RECV;
		tcpstat.tcps_tfo_cookie_req_rcv++;
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/* Ok, then it must be an offered cookie. We need to check that ... */</span>
	tcp_tfo_gen_cookie(tp-&gt;t_inpcb, out, <span class="enscript-keyword">sizeof</span>(out));

	len = *to-&gt;to_tfo - TCPOLEN_FASTOPEN_REQ;
	to-&gt;to_tfo++;
	<span class="enscript-keyword">if</span> (memcmp(out, to-&gt;to_tfo, len)) {
		<span class="enscript-comment">/* Cookies are different! Let's return and offer a new cookie */</span>
		tp-&gt;t_tfo_flags |= TFO_F_OFFER_COOKIE;

		tp-&gt;t_tfo_stats |= TFO_S_COOKIE_INVALID;
		tcpstat.tcps_tfo_cookie_invalid++;
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">if</span> (OSIncrementAtomic(&amp;tcp_tfo_halfcnt) &gt;= tcp_tfo_backlog) {
		<span class="enscript-comment">/* Need to decrement again as we just increased it... */</span>
		OSDecrementAtomic(&amp;tcp_tfo_halfcnt);
		<span class="enscript-keyword">return</span> (FALSE);
	}

	tp-&gt;t_tfo_flags |= TFO_F_COOKIE_VALID;

	tp-&gt;t_tfo_stats |= TFO_S_SYNDATA_RCV;
	tcpstat.tcps_tfo_syn_data_rcv++;

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_synack</span>(tp, to)
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> tcpopt *to;
{
	<span class="enscript-keyword">if</span> (to-&gt;to_flags &amp; TOF_TFO) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> len = *to-&gt;to_tfo - TCPOLEN_FASTOPEN_REQ;

		<span class="enscript-comment">/*
		 * If this happens, things have gone terribly wrong. len should
		 * have been check in tcp_dooptions.
		 */</span>
		VERIFY(len &lt;= TFO_COOKIE_LEN_MAX);

		to-&gt;to_tfo++;

		tcp_cache_set_cookie(tp, to-&gt;to_tfo, len);
		tcp_heuristic_tfo_success(tp);

		tp-&gt;t_tfo_stats |= TFO_S_COOKIE_RCV;
		tcpstat.tcps_tfo_cookie_rcv++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Thus, no cookie in the response, but we either asked for one
		 * or sent SYN+DATA. Now, we need to check whether we had to
		 * rexmit the SYN. If that's the case, it's better to start
		 * backing of TFO-cookie requests.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_tfo_flags &amp; TFO_F_SYN_LOSS)
			tcp_heuristic_tfo_inc_loss(tp);
		<span class="enscript-keyword">else</span>
			tcp_heuristic_tfo_reset_loss(tp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_rcv_probe</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> tlen)
{
	<span class="enscript-keyword">if</span> (tlen == 0) {
		tp-&gt;t_tfo_probe_state = TFO_PROBE_PROBING;

		<span class="enscript-comment">/*
		 * We send the probe out rather quickly (after one RTO). It does not
		 * really hurt that much, it's only one additional segment on the wire.
		 */</span>
		tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, (TCP_REXMTVAL(tp)));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* If SYN/ACK+data, don't probe. We got the data! */</span>
		tcp_heuristic_tfo_rcv_good(tp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_rcv_data</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-comment">/* Transition from PROBING to NONE as data has been received */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_tfo_probe_state &gt;= TFO_PROBE_PROBING) {
		tp-&gt;t_tfo_probe_state = TFO_PROBE_NONE;

		<span class="enscript-comment">/* Data has been received - we are good to go! */</span>
		tcp_heuristic_tfo_rcv_good(tp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_rcv_ack</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-keyword">if</span> (tp-&gt;t_tfo_probe_state == TFO_PROBE_PROBING &amp;&amp;
	    tp-&gt;t_tfo_probes &gt; 0) {
		<span class="enscript-keyword">if</span> (th-&gt;th_seq == tp-&gt;rcv_nxt) {
			<span class="enscript-comment">/* No hole, so stop probing */</span>
			tp-&gt;t_tfo_probe_state = TFO_PROBE_NONE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SEQ_GT(th-&gt;th_seq, tp-&gt;rcv_nxt)) {
			<span class="enscript-comment">/* There is a hole! Wait a bit for data... */</span>
			tp-&gt;t_tfo_probe_state = TFO_PROBE_WAIT_DATA;
			tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
			    TCP_REXMTVAL(tp));
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_input</span>(m, off0)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off0;
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcphdr *th;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> inpcb *inp;
	u_char *optp = NULL;
	<span class="enscript-type">int</span> optlen = 0;
	<span class="enscript-type">int</span> tlen, off;
	<span class="enscript-type">int</span> drop_hdrlen;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp = 0;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> thflags;
	<span class="enscript-type">struct</span> socket *so = 0;
	<span class="enscript-type">int</span> todrop, acked, ourfinisacked, needoutput = 0;
	<span class="enscript-type">struct</span> in_addr laddr;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> in6_addr laddr6;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> dropsocket = 0;
	<span class="enscript-type">int</span> iss = 0, nosock = 0; 
	u_int32_t tiwin, sack_bytes_acked = 0;
	<span class="enscript-type">struct</span> tcpopt to;		<span class="enscript-comment">/* options in this segment */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-type">short</span> ostate = 0;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-type">struct</span> sockaddr_in *next_hop = NULL;
	<span class="enscript-type">struct</span> m_tag *fwd_tag;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
	u_char ip_ecn = IPTOS_ECN_NOTECT;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;
	uint8_t isconnected, isdisconnected;
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">int</span> pktf_sw_lro_pkt = (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_PKT) ? 1 : 0;
	<span class="enscript-type">int</span> nlropkts = (pktf_sw_lro_pkt == 1) ? m-&gt;m_pkthdr.lro_npkts : 1;
	<span class="enscript-type">int</span> turnoff_lro = 0, win;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	boolean_t cell = IFNET_IS_CELLULAR(ifp);
	boolean_t wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	boolean_t wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));
	boolean_t recvd_dsack = FALSE;
	<span class="enscript-type">struct</span> tcp_respond_args tra;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCP_INC_VAR</span>(stat, npkts) do {			\
		stat += npkts;				\
} <span class="enscript-keyword">while</span> (0)

	TCP_INC_VAR(tcpstat.tcps_rcvtotal, nlropkts);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-comment">/* Grab info from PACKET_TAG_IPFORWARD tag prepended to the chain. */</span>
	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags)) {
		fwd_tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
		    KERNEL_TAG_TYPE_IPFORWARD, NULL);
	} <span class="enscript-keyword">else</span> {
		fwd_tag = NULL;
	}
	<span class="enscript-keyword">if</span> (fwd_tag != NULL) {
		<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag = 
			(<span class="enscript-type">struct</span> ip_fwd_tag *)(fwd_tag+1);

		next_hop = ipfwd_tag-&gt;next_hop;
		m_tag_delete(m, fwd_tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
	<span class="enscript-type">int</span> isipv6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">int</span> rstreason; <span class="enscript-comment">/* For badport_bandlim accounting purposes */</span>
	<span class="enscript-type">struct</span> proc *proc0=current_proc();

	KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_START,0,0,0,0,0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	isipv6 = (mtod(m, <span class="enscript-type">struct</span> ip *)-&gt;ip_v == 6) ? 1 : 0;
#<span class="enscript-reference">endif</span>
	bzero((<span class="enscript-type">char</span> *)&amp;to, <span class="enscript-keyword">sizeof</span>(to));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-comment">/* 
		 * Expect 32-bit aligned data pointer on 
		 * strict-align platforms 
		 */</span>
		MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

		<span class="enscript-comment">/* IP6_EXTHDR_CHECK() is already done at tcp6_input() */</span>
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		tlen = <span class="enscript-keyword">sizeof</span>(*ip6) + ntohs(ip6-&gt;ip6_plen) - off0;
		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip6 + off0);

		<span class="enscript-keyword">if</span> (tcp_input_checksum(AF_INET6, m, th, off0, tlen))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;

		KERNEL_DEBUG(DBG_LAYER_BEG, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		     (((ip6-&gt;ip6_src.s6_addr16[0]) &lt;&lt; 16) | (ip6-&gt;ip6_dst.s6_addr16[0])),
		     th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win);
		<span class="enscript-comment">/*
		 * Be proactive about unspecified IPv6 address in source.
		 * As we use all-zero to indicate unbounded/unconnected pcb,
		 * unspecified IPv6 address can be used to confuse us.
		 *
		 * Note that packets with unspecified IPv6 destination is
		 * already dropped in ip6_input.
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_src)) {
			<span class="enscript-comment">/* XXX stat */</span>
			IF_TCP_STATINC(ifp, unspecv6);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
		}
		DTRACE_TCP5(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
			<span class="enscript-type">struct</span> ip6_hdr *, ip6, <span class="enscript-type">struct</span> tcpcb *, NULL, 
			<span class="enscript-type">struct</span> tcphdr *, th);

		ip_ecn = (ntohl(ip6-&gt;ip6_flow) &gt;&gt; 20) &amp; IPTOS_ECN_MASK;
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
	<span class="enscript-comment">/*
	 * Get IP and TCP header together in first mbuf.
	 * Note: IP leaves IP header in first mbuf.
	 */</span>
	<span class="enscript-keyword">if</span> (off0 &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		ip_stripoptions(m, (<span class="enscript-type">struct</span> mbuf *)0);
		off0 = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr)) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr))) == 0) {
			tcpstat.tcps_rcvshort++;
			<span class="enscript-keyword">return</span>;
		}
	}

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip + off0);
	tlen = ip-&gt;ip_len;

	<span class="enscript-keyword">if</span> (tcp_input_checksum(AF_INET, m, th, off0, tlen))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-comment">/* Re-initialization for later version check */</span>
	ip-&gt;ip_v = IPVERSION;
#<span class="enscript-reference">endif</span>
	ip_ecn = (ip-&gt;ip_tos &amp; IPTOS_ECN_MASK);

	DTRACE_TCP5(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
		<span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> tcpcb *, NULL, <span class="enscript-type">struct</span> tcphdr *, th);

	KERNEL_DEBUG(DBG_LAYER_BEG, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		(((ip-&gt;ip_src.s_addr &amp; 0xffff) &lt;&lt; 16) | (ip-&gt;ip_dst.s_addr &amp; 0xffff)),
		  th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win);

	}

	<span class="enscript-comment">/*
	 * Check that TCP offset makes sense,
	 * pull out TCP options and adjust length.		XXX
	 */</span>
	off = th-&gt;th_off &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (off &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) || off &gt; tlen) {
		tcpstat.tcps_rcvbadoff++;
		IF_TCP_STATINC(ifp, badformat);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
	}
	tlen -= off;	<span class="enscript-comment">/* tlen is used instead of ti-&gt;ti_len */</span>
	<span class="enscript-keyword">if</span> (off &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			IP6_EXTHDR_CHECK(m, off0, off, <span class="enscript-keyword">return</span>);
			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip6 + off0);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + off) {
				<span class="enscript-keyword">if</span> ((m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) + off)) == 0) {
					tcpstat.tcps_rcvshort++;
					<span class="enscript-keyword">return</span>;
				}
				ip = mtod(m, <span class="enscript-type">struct</span> ip *);
				th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip + off0);
			}
		}
		optlen = off - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
		optp = (u_char *)(th + 1);
		<span class="enscript-comment">/* 
		 * Do quick retrieval of timestamp options (&quot;options
		 * prediction?&quot;).  If timestamp is the only option and it's
		 * formatted as recommended in RFC 1323 appendix A, we
		 * quickly get the values now and not bother calling
		 * tcp_dooptions(), etc.
		 */</span>
		<span class="enscript-keyword">if</span> ((optlen == TCPOLEN_TSTAMP_APPA ||
			(optlen &gt; TCPOLEN_TSTAMP_APPA &amp;&amp;
			optp[TCPOLEN_TSTAMP_APPA] == TCPOPT_EOL)) &amp;&amp;
			*(u_int32_t *)(<span class="enscript-type">void</span> *)optp == htonl(TCPOPT_TSTAMP_HDR) &amp;&amp;
			(th-&gt;th_flags &amp; TH_SYN) == 0) {
			to.to_flags |= TOF_TS;
			to.to_tsval = ntohl(*(u_int32_t *)(<span class="enscript-type">void</span> *)(optp + 4));
			to.to_tsecr = ntohl(*(u_int32_t *)(<span class="enscript-type">void</span> *)(optp + 8));
			optp = NULL;	<span class="enscript-comment">/* we've parsed the options */</span>
		}
	}
	thflags = th-&gt;th_flags;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCP_DROP_SYNFIN</span>
	<span class="enscript-comment">/*
	 * If the drop_synfin option is enabled, drop all packets with
	 * both the SYN and FIN bits set. This prevents e.g. nmap from
	 * identifying the TCP/IP stack.
	 *
	 * This is a violation of the TCP specification.
	 */</span>
	<span class="enscript-keyword">if</span> (drop_synfin &amp;&amp; (thflags &amp; (TH_SYN|TH_FIN)) == (TH_SYN|TH_FIN)) {
		IF_TCP_STATINC(ifp, synfin);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Delay dropping TCP, IP headers, IPv6 ext headers, and TCP options,
	 * until after ip6_savecontrol() is called and before other functions
	 * which don't want those proto headers.
	 * Because ip6_savecontrol() is going to parse the mbuf to
	 * search for data to be passed up to user-land, it wants mbuf
	 * parameters to be unchanged.
	 */</span>
	drop_hdrlen = off0 + off;
	
	<span class="enscript-comment">/* Since this is an entry point for input processing of tcp packets, we
	 * can update the tcp clock here.
	 */</span>
	calculate_tcp_clock();

	<span class="enscript-comment">/*
	 * Record the interface where this segment arrived on; this does not
	 * affect normal data output (for non-detached TCP) as it provides a
	 * hint about which route and interface to use for sending in the
	 * absence of a PCB, when scoped routing (and thus source interface
	 * selection) are enabled.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP) || m-&gt;m_pkthdr.rcvif == NULL)
		ifscope = IFSCOPE_NONE;
	<span class="enscript-keyword">else</span>
		ifscope = m-&gt;m_pkthdr.rcvif-&gt;if_index;

    	<span class="enscript-comment">/*
    	 * Convert TCP protocol specific fields to host format.
    	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
    	NTOHL(th-&gt;th_seq);
    	NTOHL(th-&gt;th_ack);
    	NTOHS(th-&gt;th_win);
    	NTOHS(th-&gt;th_urp);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Locate pcb for segment.
	 */</span>
<span class="enscript-reference">findpcb</span>:

	isconnected = FALSE;
	isdisconnected = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
	<span class="enscript-keyword">if</span> (next_hop != NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	    &amp;&amp; isipv6 == 0 <span class="enscript-comment">/* IPv6 support is not yet */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	    ) {
		<span class="enscript-comment">/*
		 * Diverted. Pretend to be the destination.
		 * already got one like this? 
		 */</span>
		inp = in_pcblookup_hash(&amp;tcbinfo, ip-&gt;ip_src, th-&gt;th_sport,
			ip-&gt;ip_dst, th-&gt;th_dport, 0, m-&gt;m_pkthdr.rcvif);
		<span class="enscript-keyword">if</span> (!inp) {
			<span class="enscript-comment">/* 
			 * No, then it's new. Try find the ambushing socket
			 */</span>
			<span class="enscript-keyword">if</span> (!next_hop-&gt;sin_port) {
				inp = in_pcblookup_hash(&amp;tcbinfo, ip-&gt;ip_src,
				    th-&gt;th_sport, next_hop-&gt;sin_addr,
				    th-&gt;th_dport, 1, m-&gt;m_pkthdr.rcvif);
			} <span class="enscript-keyword">else</span> {
				inp = in_pcblookup_hash(&amp;tcbinfo,
				    ip-&gt;ip_src, th-&gt;th_sport,
	    			    next_hop-&gt;sin_addr,
				    ntohs(next_hop-&gt;sin_port), 1,
				    m-&gt;m_pkthdr.rcvif);
			}
		}
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
      {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		inp = in6_pcblookup_hash(&amp;tcbinfo, &amp;ip6-&gt;ip6_src, th-&gt;th_sport,
					 &amp;ip6-&gt;ip6_dst, th-&gt;th_dport, 1,
					 m-&gt;m_pkthdr.rcvif);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	inp = in_pcblookup_hash(&amp;tcbinfo, ip-&gt;ip_src, th-&gt;th_sport,
	    ip-&gt;ip_dst, th-&gt;th_dport, 1, m-&gt;m_pkthdr.rcvif);
      }

	<span class="enscript-comment">/*
	 * Use the interface scope information from the PCB for outbound
	 * segments.  If the PCB isn't present and if scoped routing is
	 * enabled, tcp_respond will use the scope of the interface where
	 * the segment arrived on.
	 */</span>
	<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; (inp-&gt;inp_flags &amp; INP_BOUND_IF))
		ifscope = inp-&gt;inp_boundifp-&gt;if_index;

	<span class="enscript-comment">/*
	 * If the state is CLOSED (i.e., TCB does not exist) then
	 * all data in the incoming segment is discarded.
	 * If the TCB exists but is in CLOSED state, it is embryonic,
	 * but should either do a listen or a connect soon.
	 */</span>
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">if</span> (log_in_vain) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-type">char</span> dbuf[MAX_IPv6_STR_LEN], sbuf[MAX_IPv6_STR_LEN];
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-type">char</span> dbuf[MAX_IPv4_STR_LEN], sbuf[MAX_IPv4_STR_LEN];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6) {
				inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_dst, dbuf, <span class="enscript-keyword">sizeof</span>(dbuf));
				inet_ntop(AF_INET6, &amp;ip6-&gt;ip6_src, sbuf, <span class="enscript-keyword">sizeof</span>(sbuf));
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			{
				inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, dbuf, <span class="enscript-keyword">sizeof</span>(dbuf));
				inet_ntop(AF_INET, &amp;ip-&gt;ip_src, sbuf, <span class="enscript-keyword">sizeof</span>(sbuf));
			}
			<span class="enscript-keyword">switch</span> (log_in_vain) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
				<span class="enscript-keyword">if</span>(thflags &amp; TH_SYN)
					log(LOG_INFO,
						<span class="enscript-string">&quot;Connection attempt to TCP %s:%d from %s:%d\n&quot;</span>,
						dbuf, ntohs(th-&gt;th_dport),
						sbuf,
						ntohs(th-&gt;th_sport));
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
				log(LOG_INFO,
					<span class="enscript-string">&quot;Connection attempt to TCP %s:%d from %s:%d flags:0x%x\n&quot;</span>,
					dbuf, ntohs(th-&gt;th_dport), sbuf,
					ntohs(th-&gt;th_sport), thflags);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
				<span class="enscript-keyword">if</span> ((thflags &amp; TH_SYN) &amp;&amp; !(thflags &amp; TH_ACK) &amp;&amp;
					!(m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) &amp;&amp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
					((isipv6 &amp;&amp; !IN6_ARE_ADDR_EQUAL(&amp;ip6-&gt;ip6_dst, &amp;ip6-&gt;ip6_src)) ||
					 (!isipv6 &amp;&amp; ip-&gt;ip_dst.s_addr != ip-&gt;ip_src.s_addr))
#<span class="enscript-reference">else</span>
					ip-&gt;ip_dst.s_addr != ip-&gt;ip_src.s_addr
#<span class="enscript-reference">endif</span>
					 )
					log_in_vain_log((LOG_INFO,
						<span class="enscript-string">&quot;Stealth Mode connection attempt to TCP %s:%d from %s:%d\n&quot;</span>,
						dbuf, ntohs(th-&gt;th_dport),
						sbuf,
						ntohs(th-&gt;th_sport)));
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (blackhole) { 
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif &amp;&amp; m-&gt;m_pkthdr.rcvif-&gt;if_type != IFT_LOOP)
				
				<span class="enscript-keyword">switch</span> (blackhole) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
					<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
				<span class="enscript-reference">default</span>:
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
				}
		}
		rstreason = BANDLIM_RST_CLOSEDPORT;
		IF_TCP_STATINC(ifp, noconnnolist);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithresetnosock</span>;
	}
	so = inp-&gt;inp_socket;
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-comment">/* This case shouldn't happen  as the socket shouldn't be null
		 * if inp_state isn't set to INPCB_STATE_DEAD
		 * But just in case, we pretend we didn't find the socket if we hit this case
		 * as this isn't cause for a panic (the socket might be leaked however)...
		 */</span>
		inp = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TEMPDEBUG</span>
		printf(<span class="enscript-string">&quot;tcp_input: no more socket for inp=%x. This shouldn't happen\n&quot;</span>, inp);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
	}

	tcp_lock(so, 1, 0);
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
		tcp_unlock(so, 1, (<span class="enscript-type">void</span> *)2);
		inp = NULL;	<span class="enscript-comment">// pretend we didn't find it
</span>		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropnosock</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v6(inp, th-&gt;th_dport,
							    th-&gt;th_sport,
							    &amp;ip6-&gt;ip6_dst,
							    &amp;ip6-&gt;ip6_src,
							    ifp, NULL, NULL)) {
			IF_TCP_STATINC(ifp, badformatipsec);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v4(inp, th-&gt;th_dport,
							    th-&gt;th_sport,
							    &amp;ip-&gt;ip_dst,
							    &amp;ip-&gt;ip_src,
							    ifp, NULL, NULL)) {
			IF_TCP_STATINC(ifp, badformatipsec);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (tp == 0) {
		rstreason = BANDLIM_RST_CLOSEDPORT;
		IF_TCP_STATINC(ifp, noconnlist);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
	}
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_CLOSED)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-comment">/* Unscale the window into a 32-bit value. */</span>
	<span class="enscript-keyword">if</span> ((thflags &amp; TH_SYN) == 0)
		tiwin = th-&gt;th_win &lt;&lt; tp-&gt;snd_scale;
	<span class="enscript-keyword">else</span>
		tiwin = th-&gt;th_win;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">if</span> (mac_inpcb_check_deliver(inp, m, AF_INET, SOCK_STREAM))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Avoid processing packets while closing a listen socket */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_LISTEN &amp;&amp; 
		(so-&gt;so_options &amp; SO_ACCEPTCONN) == 0) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;

	<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; (SO_DEBUG|SO_ACCEPTCONN)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_DEBUG) {
			ostate = tp-&gt;t_state;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6)
				bcopy((<span class="enscript-type">char</span> *)ip6, (<span class="enscript-type">char</span> *)tcp_saveipgen,
				      <span class="enscript-keyword">sizeof</span>(*ip6));
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			bcopy((<span class="enscript-type">char</span> *)ip, (<span class="enscript-type">char</span> *)tcp_saveipgen, <span class="enscript-keyword">sizeof</span>(*ip));
			tcp_savetcp = *th;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_ACCEPTCONN) {
		    <span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp0 = tp;
			<span class="enscript-type">struct</span> socket *so2;
			<span class="enscript-type">struct</span> socket *oso;
			<span class="enscript-type">struct</span> sockaddr_storage from;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-type">struct</span> inpcb *oinp = sotoinpcb(so);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-type">struct</span> ifnet *head_ifscope;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> head_nocell, head_recvanyif,
				     head_noexpensive, head_awdl_unrestricted;

			<span class="enscript-comment">/* Get listener's bound-to-interface, if any */</span>
			head_ifscope = (inp-&gt;inp_flags &amp; INP_BOUND_IF) ?
			    inp-&gt;inp_boundifp : NULL;
			<span class="enscript-comment">/* Get listener's no-cellular information, if any */</span>
			head_nocell = INP_NO_CELLULAR(inp);
			<span class="enscript-comment">/* Get listener's recv-any-interface, if any */</span>
			head_recvanyif = (inp-&gt;inp_flags &amp; INP_RECV_ANYIF);
			<span class="enscript-comment">/* Get listener's no-expensive information, if any */</span>
			head_noexpensive = INP_NO_EXPENSIVE(inp);
			head_awdl_unrestricted = INP_AWDL_UNRESTRICTED(inp);

			<span class="enscript-comment">/*
			 * If the state is LISTEN then ignore segment if it contains an RST.
			 * If the segment contains an ACK then it is bad and send a RST.
			 * If it does not contain a SYN then it is not interesting; drop it.
			 * If it is from this socket, drop it, it must be forged.
			 */</span>
			<span class="enscript-keyword">if</span> ((thflags &amp; (TH_RST|TH_ACK|TH_SYN)) != TH_SYN) {
				IF_TCP_STATINC(ifp, listbadsyn);

				<span class="enscript-keyword">if</span> (thflags &amp; TH_RST) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				}
				<span class="enscript-keyword">if</span> (thflags &amp; TH_ACK) {
					tp = NULL;
					tcpstat.tcps_badsyn++;
					rstreason = BANDLIM_RST_OPENPORT;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
				}

				<span class="enscript-comment">/* We come here if there is no SYN set */</span>
				tcpstat.tcps_badsyn++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			KERNEL_DEBUG(DBG_FNC_TCP_NEWCONN | DBG_FUNC_START,0,0,0,0,0);
	                <span class="enscript-keyword">if</span> (th-&gt;th_dport == th-&gt;th_sport) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (isipv6) {
					<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;ip6-&gt;ip6_dst,
                                                       &amp;ip6-&gt;ip6_src))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					<span class="enscript-keyword">if</span> (ip-&gt;ip_dst.s_addr == ip-&gt;ip_src.s_addr)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			<span class="enscript-comment">/*
			 * RFC1122 4.2.3.10, p. 104: discard bcast/mcast SYN
			 * in_broadcast() should never return true on a received
			 * packet with M_BCAST not set.
			 *
			 * Packets with a multicast source address should also
			 * be discarded.
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; (M_BCAST|M_MCAST))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6) {
				<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) ||
					IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_src))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr)) ||
				IN_MULTICAST(ntohl(ip-&gt;ip_src.s_addr)) ||
				ip-&gt;ip_src.s_addr == htonl(INADDR_BROADCAST) ||
				in_broadcast(ip-&gt;ip_dst, m-&gt;m_pkthdr.rcvif))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-comment">/*
			 * If deprecated address is forbidden,
			 * we do not accept SYN to deprecated interface
			 * address to prevent any new inbound connection from
			 * getting established.
			 * When we do not accept SYN, we send a TCP RST,
			 * with deprecated source address (instead of dropping
			 * it).  We compromise it as it is much better for peer
			 * to send a RST, and RST will be the final packet
			 * for the exchange.
			 *
			 * If we do not forbid deprecated addresses, we accept
			 * the SYN packet.  RFC 4862 forbids dropping SYN in
			 * this case.
			 */</span>
			<span class="enscript-keyword">if</span> (isipv6 &amp;&amp; !ip6_use_deprecated) {
				uint32_t ia6_flags;

				<span class="enscript-keyword">if</span> (ip6_getdstifaddr_info(m, NULL,
				    &amp;ia6_flags) == 0) {
					<span class="enscript-keyword">if</span> (ia6_flags &amp; IN6_IFF_DEPRECATED) {
						tp = NULL;
						rstreason = BANDLIM_RST_OPENPORT;
						IF_TCP_STATINC(ifp, deprecate6);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
					}
				}
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_filt) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (isipv6) {
					<span class="enscript-type">struct</span> sockaddr_in6	*sin6 = (<span class="enscript-type">struct</span> sockaddr_in6*)&amp;from;
					
					sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
					sin6-&gt;sin6_family = AF_INET6;
					sin6-&gt;sin6_port = th-&gt;th_sport;
					sin6-&gt;sin6_flowinfo = 0;
					sin6-&gt;sin6_addr = ip6-&gt;ip6_src;
					sin6-&gt;sin6_scope_id = 0;
 				}
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
				{
					<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in*)&amp;from;
					
					sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
					sin-&gt;sin_family = AF_INET;
					sin-&gt;sin_port = th-&gt;th_sport;
					sin-&gt;sin_addr = ip-&gt;ip_src;
				}
				so2 = sonewconn(so, 0, (<span class="enscript-type">struct</span> sockaddr*)&amp;from);
			} <span class="enscript-keyword">else</span> {
				so2 = sonewconn(so, 0, NULL);
			}
			<span class="enscript-keyword">if</span> (so2 == 0) {
				tcpstat.tcps_listendrop++;
				<span class="enscript-keyword">if</span> (tcp_dropdropablreq(so)) {
					<span class="enscript-keyword">if</span> (so-&gt;so_filt)
						so2 = sonewconn(so, 0, (<span class="enscript-type">struct</span> sockaddr*)&amp;from);
					<span class="enscript-keyword">else</span>
						so2 = sonewconn(so, 0, NULL);
				}
				<span class="enscript-keyword">if</span> (!so2) 
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}

			<span class="enscript-comment">/* Point &quot;inp&quot; and &quot;tp&quot; in tandem to new socket */</span>
			inp = (<span class="enscript-type">struct</span> inpcb *)so2-&gt;so_pcb;
			tp = intotcpcb(inp);

			oso = so;
			tcp_unlock(so, 0, 0); <span class="enscript-comment">/* Unlock but keep a reference on listener for now */</span>

			so = so2;
			tcp_lock(so, 1, 0);
			<span class="enscript-comment">/*
			 * Mark socket as temporary until we're
			 * committed to keeping it.  The code at
			 * ``drop'' and ``dropwithreset'' check the
			 * flag dropsocket to see if the temporary
			 * socket created here should be discarded.
			 * We mark the socket as discardable until
			 * we're committed to it below in TCPS_LISTEN.
			 * There are some error conditions in which we
			 * have to drop the temporary socket.
			 */</span>
			dropsocket++;
			<span class="enscript-comment">/*
			 * Inherit INP_BOUND_IF from listener; testing if
			 * head_ifscope is non-NULL is sufficient, since it
			 * can only be set to a non-zero value earlier if
			 * the listener has such a flag set.
			 */</span>
			<span class="enscript-keyword">if</span> (head_ifscope != NULL) {
				inp-&gt;inp_flags |= INP_BOUND_IF;
				inp-&gt;inp_boundifp = head_ifscope;
			} <span class="enscript-keyword">else</span> {
				inp-&gt;inp_flags &amp;= ~INP_BOUND_IF;
			}
			<span class="enscript-comment">/*
			 * Inherit restrictions from listener.
			 */</span>
			<span class="enscript-keyword">if</span> (head_nocell)
				inp_set_nocellular(inp);
			<span class="enscript-keyword">if</span> (head_noexpensive)
				inp_set_noexpensive(inp);
			<span class="enscript-keyword">if</span> (head_awdl_unrestricted)
				inp_set_awdl_unrestricted(inp);
			<span class="enscript-comment">/*
			 * Inherit {IN,IN6}_RECV_ANYIF from listener.
			 */</span>
			<span class="enscript-keyword">if</span> (head_recvanyif)
				inp-&gt;inp_flags |= INP_RECV_ANYIF;
			<span class="enscript-keyword">else</span>
				inp-&gt;inp_flags &amp;= ~INP_RECV_ANYIF;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6)
				inp-&gt;in6p_laddr = ip6-&gt;ip6_dst;
			<span class="enscript-keyword">else</span> {
				inp-&gt;inp_vflag &amp;= ~INP_IPV6;
				inp-&gt;inp_vflag |= INP_IPV4;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				inp-&gt;inp_laddr = ip-&gt;ip_dst;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			inp-&gt;inp_lport = th-&gt;th_dport;
			<span class="enscript-keyword">if</span> (in_pcbinshash(inp, 0) != 0) {
				<span class="enscript-comment">/*
				 * Undo the assignments above if we failed to
				 * put the PCB on the hash lists.
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (isipv6)
					inp-&gt;in6p_laddr = in6addr_any;
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					inp-&gt;inp_laddr.s_addr = INADDR_ANY;
				inp-&gt;inp_lport = 0;
				tcp_lock(oso, 0, 0);	<span class="enscript-comment">/* release ref on parent */</span>
				tcp_unlock(oso, 1, 0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6) {
  				<span class="enscript-comment">/*
 				 * Inherit socket options from the listening
  				 * socket.
 				 * Note that in6p_inputopts are not (even
 				 * should not be) copied, since it stores
				 * previously received options and is used to
 				 * detect if each new option is different than
 				 * the previous one and hence should be passed
 				 * to a user.
 				 * If we copied in6p_inputopts, a user would
 				 * not be able to receive options just after
 				 * calling the accept system call.
 				 */</span>
				inp-&gt;inp_flags |=
					oinp-&gt;inp_flags &amp; INP_CONTROLOPTS;
 				<span class="enscript-keyword">if</span> (oinp-&gt;in6p_outputopts)
 					inp-&gt;in6p_outputopts =
 						ip6_copypktopts(oinp-&gt;in6p_outputopts,
 								M_NOWAIT);
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			{
				inp-&gt;inp_options = ip_srcroute();
				inp-&gt;inp_ip_tos = oinp-&gt;inp_ip_tos;
			}
			tcp_lock(oso, 0, 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-comment">/* copy old policy into new socket's */</span>
			<span class="enscript-keyword">if</span> (sotoinpcb(oso)-&gt;inp_sp)
			{
				<span class="enscript-type">int</span> error = 0;
				<span class="enscript-comment">/* Is it a security hole here to silently fail to copy the policy? */</span>
				<span class="enscript-keyword">if</span> (inp-&gt;inp_sp != NULL)
					error = ipsec_init_policy(so, &amp;inp-&gt;inp_sp);
				<span class="enscript-keyword">if</span> (error != 0 || ipsec_copy_policy(sotoinpcb(oso)-&gt;inp_sp, inp-&gt;inp_sp))
					printf(<span class="enscript-string">&quot;tcp_input: could not copy policy\n&quot;</span>);
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* inherit states from the listener */</span>
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
				<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_LISTEN);
			tp-&gt;t_state = TCPS_LISTEN;
			tp-&gt;t_flags |= tp0-&gt;t_flags &amp; (TF_NOPUSH|TF_NOOPT|TF_NODELAY);
			tp-&gt;t_flagsext |= (tp0-&gt;t_flagsext &amp; (TF_RXTFINDROP|TF_NOTIMEWAIT|TF_FASTOPEN));
			tp-&gt;t_keepinit = tp0-&gt;t_keepinit;
			tp-&gt;t_keepcnt = tp0-&gt;t_keepcnt;
			tp-&gt;t_keepintvl = tp0-&gt;t_keepintvl;
			tp-&gt;t_adaptive_wtimo = tp0-&gt;t_adaptive_wtimo;
			tp-&gt;t_adaptive_rtimo = tp0-&gt;t_adaptive_rtimo;
			tp-&gt;t_inpcb-&gt;inp_ip_ttl = tp0-&gt;t_inpcb-&gt;inp_ip_ttl;
			<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_NOTSENT_LOWAT) != 0)
				tp-&gt;t_notsent_lowat = tp0-&gt;t_notsent_lowat;

			<span class="enscript-comment">/* now drop the reference on the listener */</span>
			tcp_unlock(oso, 1, 0);

			tcp_set_max_rwinscale(tp, so);

			KERNEL_DEBUG(DBG_FNC_TCP_NEWCONN | DBG_FUNC_END,0,0,0,0,0);
		}
	}
	lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
		LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp; tlen &gt; 0) {
		<span class="enscript-comment">/* 
		 * Evaluate the rate of arrival of packets to see if the 
		 * receiver can reduce the ack traffic. The algorithm to 
		 * stretch acks will be enabled if the connection meets 
		 * certain criteria defined in tcp_stretch_ack_enable function.
		 */</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_RCVUNACK_WAITSS) != 0) {
			TCP_INC_VAR(tp-&gt;rcv_waitforss, nlropkts);
		}
		<span class="enscript-keyword">if</span> (tcp_stretch_ack_enable(tp)) {
			tp-&gt;t_flags |= TF_STRETCHACK;
			tp-&gt;t_flagsext &amp;= ~(TF_RCVUNACK_WAITSS);
			tp-&gt;rcv_waitforss = 0;
		} <span class="enscript-keyword">else</span> {
			tp-&gt;t_flags &amp;= ~(TF_STRETCHACK);
		}
		<span class="enscript-keyword">if</span> (TSTMP_GT(tp-&gt;rcv_unackwin, tcp_now)) {
			tp-&gt;rcv_by_unackwin += (tlen + off);
		} <span class="enscript-keyword">else</span> {
			tp-&gt;rcv_unackwin = tcp_now + tcp_rcvunackwin;
			tp-&gt;rcv_by_unackwin = tlen + off;
		}
	}

	<span class="enscript-comment">/* 
	 * Keep track of how many bytes were received in the LRO packet
	 */</span>
	<span class="enscript-keyword">if</span> ((pktf_sw_lro_pkt) &amp;&amp; (nlropkts &gt; 2))  {
		tp-&gt;t_lropktlen += tlen;
	}
	<span class="enscript-comment">/*
	 * Explicit Congestion Notification - Flag that we need to send ECT if
	 * 	+ The IP Congestion experienced flag was set.
	 * 	+ Socket is in established state
	 * 	+ We negotiated ECN in the TCP setup
	 * 	+ This isn't a pure ack (tlen &gt; 0)
	 * 	+ The data is in the valid window
	 *
	 * 	TE_SENDECE will be cleared when we receive a packet with TH_CWR set.
	 */</span>
	<span class="enscript-keyword">if</span> (ip_ecn == IPTOS_ECN_CE &amp;&amp; tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
	    TCP_ECN_ENABLED(tp) &amp;&amp; tlen &gt; 0 &amp;&amp;
	    SEQ_GEQ(th-&gt;th_seq, tp-&gt;last_ack_sent) &amp;&amp;
	    SEQ_LT(th-&gt;th_seq, tp-&gt;last_ack_sent + tp-&gt;rcv_wnd)) {
		tcpstat.tcps_ecn_recv_ce++;
		<span class="enscript-comment">/* Mark this connection as it received CE from network */</span>
		tp-&gt;ecn_flags |= TE_RECV_ECN_CE;
		tp-&gt;ecn_flags |= TE_SENDECE;
	}
	
	<span class="enscript-comment">/*
	 * Clear TE_SENDECE if TH_CWR is set. This is harmless, so we don't
	 * bother doing extensive checks for state and whatnot.
	 */</span>
	<span class="enscript-keyword">if</span> (thflags &amp; TH_CWR) {
		tp-&gt;ecn_flags &amp;= ~TE_SENDECE;
	}

	<span class="enscript-comment">/* 
	 * If we received an  explicit notification of congestion in 
	 * ip tos ecn bits or by the CWR bit in TCP header flags, reset
	 * the ack-strteching state. We need to handle ECN notification if
	 * an ECN setup SYN was sent even once.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED
	    &amp;&amp; (tp-&gt;ecn_flags &amp; TE_SETUPSENT)
	    &amp;&amp; (ip_ecn == IPTOS_ECN_CE || (thflags &amp; TH_CWR))) {
		tcp_reset_stretch_ack(tp);
		CLEAR_IAJ_STATE(tp);
	}

	<span class="enscript-comment">/* 
	 * Try to determine if we are receiving a packet after a long time.
	 * Use our own approximation of idletime to roughly measure remote 
	 * end's idle time. Since slowstart is used after an idle period
	 * we want to avoid doing LRO if the remote end is not up to date
	 * on initial window support and starts with 1 or 2 packets as its IW.
	 */</span>
	 <span class="enscript-keyword">if</span> (sw_lro &amp;&amp; (tp-&gt;t_flagsext &amp; TF_LRO_OFFLOADED) &amp;&amp;
	 	((tcp_now - tp-&gt;t_rcvtime) &gt;= (TCP_IDLETIMEOUT(tp)))) {
		turnoff_lro = 1;
	 }

	<span class="enscript-comment">/* Update rcvtime as a new segment was received on the connection */</span>
	tp-&gt;t_rcvtime = tcp_now;

	<span class="enscript-comment">/*
	 * Segment received on connection.
	 * Reset idle time and keep-alive timer.
	 */</span>
	<span class="enscript-keyword">if</span> (TCPS_HAVEESTABLISHED(tp-&gt;t_state))
		tcp_keepalive_reset(tp);

	<span class="enscript-comment">/*
	 * Process options if not in LISTEN state,
	 * else do it below (after getting remote address).
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_LISTEN &amp;&amp; optp) {
		tcp_dooptions(tp, optp, optlen, th, &amp;to);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">if</span> (mptcp_input_preproc(tp, m, drop_hdrlen) != 0) {
			tp-&gt;t_flags |= TF_ACKNOW;
			(<span class="enscript-type">void</span>) tcp_output(tp);
			tcp_check_timer_state(tp);
			tcp_unlock(so, 1, 0);
			KERNEL_DEBUG(DBG_FNC_TCP_INPUT |
			    DBG_FUNC_END,0,0,0,0,0);
			<span class="enscript-keyword">return</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	}
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_SENT &amp;&amp; (thflags &amp; TH_SYN)) {
		<span class="enscript-keyword">if</span> (!(thflags &amp; TH_ACK) ||
		    (SEQ_GT(th-&gt;th_ack, tp-&gt;iss) &amp;&amp;
		    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_max)))
			tcp_finalize_options(tp, &amp;to, ifscope);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
	<span class="enscript-comment">/*
	 * Compute inter-packet arrival jitter. According to RFC 3550,
	 * inter-packet arrival jitter is defined as the difference in
	 * packet spacing at the receiver compared to the sender for a
	 * pair of packets. When two packets of maximum segment size come
	 * one after the other with consecutive sequence numbers, we
	 * consider them as packets sent together at the sender and use
	 * them as a pair to compute inter-packet arrival jitter. This
	 * metric indicates the delay induced by the network components due
	 * to queuing in edge/access routers.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
	    (thflags &amp; (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK|TH_ECE|TH_PUSH)) == TH_ACK &amp;&amp;
	    ((tp-&gt;t_flags &amp; (TF_NEEDSYN|TF_NEEDFIN)) == 0) &amp;&amp;
	    ((to.to_flags &amp; TOF_TS) == 0 ||
            TSTMP_GEQ(to.to_tsval, tp-&gt;ts_recent)) &amp;&amp;
	    th-&gt;th_seq == tp-&gt;rcv_nxt &amp;&amp;
	    LIST_EMPTY(&amp;tp-&gt;t_segq)) {
		<span class="enscript-type">int</span> seg_size = tlen;
		<span class="enscript-keyword">if</span> (tp-&gt;iaj_pktcnt &lt;= IAJ_IGNORE_PKTCNT) {
			TCP_INC_VAR(tp-&gt;iaj_pktcnt, nlropkts);
		}

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_PKT) {
			seg_size = m-&gt;m_pkthdr.lro_pktlen;
		}
		<span class="enscript-keyword">if</span> ( tp-&gt;iaj_size == 0 || seg_size &gt; tp-&gt;iaj_size ||
			(seg_size == tp-&gt;iaj_size &amp;&amp; tp-&gt;iaj_rcv_ts == 0)) {
			<span class="enscript-comment">/*
			 * State related to inter-arrival jitter is
			 * uninitialized or we are trying to find a good
			 * first packet to start computing the metric
			 */</span>
			update_iaj_state(tp, seg_size, 0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (seg_size == tp-&gt;iaj_size) {
				<span class="enscript-comment">/*
				 * Compute inter-arrival jitter taking
				 * this packet as the second packet
				 */</span>
				<span class="enscript-keyword">if</span> (pktf_sw_lro_pkt)
					compute_iaj(tp, nlropkts,
					    m-&gt;m_pkthdr.lro_elapsed);
				<span class="enscript-keyword">else</span>
					compute_iaj(tp, 1, 0);
			} 
			<span class="enscript-keyword">if</span> (seg_size  &lt; tp-&gt;iaj_size) {
				<span class="enscript-comment">/*
				 * There is a smaller packet in the stream.
				 * Some times the maximum size supported
				 * on a path can change if there is a new
				 * link with smaller MTU. The receiver will
				 * not know about this change. If there
				 * are too many packets smaller than
				 * iaj_size, we try to learn the iaj_size
				 * again.
				 */</span>
				TCP_INC_VAR(tp-&gt;iaj_small_pkt, nlropkts); 
				<span class="enscript-keyword">if</span> (tp-&gt;iaj_small_pkt &gt; RESET_IAJ_SIZE_THRESH) {
					update_iaj_state(tp, seg_size, 1);
				} <span class="enscript-keyword">else</span> {
					CLEAR_IAJ_STATE(tp);
				}
			} <span class="enscript-keyword">else</span> {
				update_iaj_state(tp, seg_size, 0);
			}
		}
	} <span class="enscript-keyword">else</span> {
		CLEAR_IAJ_STATE(tp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

	<span class="enscript-comment">/*
	 * Header prediction: check for the two common cases
	 * of a uni-directional data xfer.  If the packet has
	 * no control flags, is in-sequence, the window didn't
	 * change and we're not retransmitting, it's a
	 * candidate.  If the length is zero and the ack moved
	 * forward, we're the sender side of the xfer.  Just
	 * free the data acked &amp; wake any higher level process
	 * that was blocked waiting for space.  If the length
	 * is non-zero and the ack didn't move, we're the
	 * receiver side.  If we're getting packets in-order
	 * (the reassembly queue is empty), add the data to
	 * the socket buffer and note that we need a delayed ack.
	 * Make sure that the hidden state-flags are also off.
	 * Since we check for TCPS_ESTABLISHED above, it can only
	 * be TH_NEEDSYN.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
	    (thflags &amp; (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK|TH_ECE)) == TH_ACK &amp;&amp;
	    ((tp-&gt;t_flags &amp; (TF_NEEDSYN|TF_NEEDFIN)) == 0) &amp;&amp;
	    ((to.to_flags &amp; TOF_TS) == 0 ||
	     TSTMP_GEQ(to.to_tsval, tp-&gt;ts_recent)) &amp;&amp;
	    th-&gt;th_seq == tp-&gt;rcv_nxt &amp;&amp;
	    tiwin &amp;&amp; tiwin == tp-&gt;snd_wnd &amp;&amp;
	    tp-&gt;snd_nxt == tp-&gt;snd_max) {

		<span class="enscript-comment">/*
		 * If last ACK falls within this segment's sequence numbers,
		 * record the timestamp.
		 * NOTE that the test is modified according to the latest
		 * proposal of the <a href="mailto:tcplw@cray.com">tcplw@cray.com</a> list (Braden 1993/04/26).
		 */</span>
		<span class="enscript-keyword">if</span> ((to.to_flags &amp; TOF_TS) != 0 &amp;&amp;
		   SEQ_LEQ(th-&gt;th_seq, tp-&gt;last_ack_sent)) {
			tp-&gt;ts_recent_age = tcp_now;
			tp-&gt;ts_recent = to.to_tsval;
		}

		<span class="enscript-comment">/* Force acknowledgment if we received a FIN */</span>

		<span class="enscript-keyword">if</span> (thflags &amp; TH_FIN)
			tp-&gt;t_flags |= TF_ACKNOW;

		<span class="enscript-keyword">if</span> (tlen == 0) {
			<span class="enscript-keyword">if</span> (SEQ_GT(th-&gt;th_ack, tp-&gt;snd_una) &amp;&amp;
			    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_max) &amp;&amp;
			    tp-&gt;snd_cwnd &gt;= tp-&gt;snd_ssthresh &amp;&amp;
			    (!IN_FASTRECOVERY(tp) &amp;&amp; 
			    ((!(SACK_ENABLED(tp)) &amp;&amp; 
			    tp-&gt;t_dupacks &lt; tp-&gt;t_rexmtthresh) ||
			    (SACK_ENABLED(tp) &amp;&amp; to.to_nsacks == 0 &amp;&amp;
			    TAILQ_EMPTY(&amp;tp-&gt;snd_holes))))) {
				<span class="enscript-comment">/*
				 * this is a pure ack for outstanding data.
				 */</span>
				++tcpstat.tcps_predack;

				tcp_bad_rexmt_check(tp, th, &amp;to),

				<span class="enscript-comment">/* Recalculate the RTT */</span>
				tcp_compute_rtt(tp, &amp;to, th);

				VERIFY(SEQ_GEQ(th-&gt;th_ack, tp-&gt;snd_una));
				acked = BYTES_ACKED(th, tp);
				tcpstat.tcps_rcvackpack++;
				tcpstat.tcps_rcvackbyte += acked;
				
				<span class="enscript-comment">/*
				 * Handle an ack that is in sequence during
				 * congestion avoidance phase. The
				 * calculations in this function
				 * assume that snd_una is not updated yet. 
				 */</span>
				<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;congestion_avd != NULL)
					CC_ALGO(tp)-&gt;congestion_avd(tp, th);
				tcp_ccdbg_trace(tp, th, TCP_CC_INSEQ_ACK_RCVD);
				sbdrop(&amp;so-&gt;so_snd, acked);
				<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
					VERIFY(acked &lt;= so-&gt;so_msg_state-&gt;msg_serial_bytes);
					so-&gt;so_msg_state-&gt;msg_serial_bytes -= acked;
				}
				tcp_sbsnd_trim(&amp;so-&gt;so_snd);

				<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_una, tp-&gt;snd_recover) &amp;&amp;
				    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_recover))
					tp-&gt;snd_recover = th-&gt;th_ack - 1;
				tp-&gt;snd_una = th-&gt;th_ack;

				<span class="enscript-comment">/*
				 * pull snd_wl2 up to prevent seq wrap relative
				 * to th_ack.
				 */</span>
				tp-&gt;snd_wl2 = th-&gt;th_ack;

				<span class="enscript-keyword">if</span> (tp-&gt;t_dupacks &gt; 0) {
					tp-&gt;t_dupacks = 0;
					tp-&gt;t_rexmtthresh = tcprexmtthresh;
				}

				m_freem(m);

				<span class="enscript-comment">/*
				 * If all outstanding data are acked, stop
				 * retransmit timer, otherwise restart timer
				 * using current (possibly backed-off) value.
				 * If process is waiting for space,
				 * wakeup/selwakeup/signal.  If data
				 * are ready to send, let tcp_output
				 * decide between more output or persist.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;snd_una == tp-&gt;snd_max) {
					tp-&gt;t_timer[TCPT_REXMT] = 0;
					tp-&gt;t_timer[TCPT_PTO] = 0;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_PERSIST] == 0) {
					tp-&gt;t_timer[TCPT_REXMT] =
					    OFFSET_FROM_START(tp,
					    tp-&gt;t_rxtcur);
				}
				<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments) &amp;&amp;
				    !TCP_DSACK_SEQ_IN_WINDOW(tp,
				    tp-&gt;t_dsack_lastuna, tp-&gt;snd_una))
					tcp_rxtseg_clean(tp);

				<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) != 0 &amp;&amp;
					tp-&gt;t_bwmeas != NULL)
					tcp_bwmeas_check(tp);
				sowwakeup(so); <span class="enscript-comment">/* has to be done with socket lock held */</span>
				<span class="enscript-keyword">if</span> ((so-&gt;so_snd.sb_cc) || (tp-&gt;t_flags &amp; TF_ACKNOW)) {
					(<span class="enscript-type">void</span>) tcp_output(tp);
				}

				tcp_tfo_rcv_ack(tp, th);

				tcp_check_timer_state(tp);
				tcp_unlock(so, 1, 0);
				KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
				<span class="enscript-keyword">return</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (th-&gt;th_ack == tp-&gt;snd_una &amp;&amp;
		    LIST_EMPTY(&amp;tp-&gt;t_segq) &amp;&amp;
		    tlen &lt;= tcp_sbspace(tp)) {
			<span class="enscript-comment">/*
			 * this is a pure, in-sequence data packet
			 * with nothing on the reassembly queue and
			 * we have enough buffer space to take it.
			 */</span>

			<span class="enscript-comment">/*
                 	 * If this is a connection in steady state, start
			 * coalescing packets belonging to this flow.
			 */</span>
			<span class="enscript-keyword">if</span> (turnoff_lro) {
				tcp_lro_remove_state(tp-&gt;t_inpcb-&gt;inp_laddr,
					tp-&gt;t_inpcb-&gt;inp_faddr,
					tp-&gt;t_inpcb-&gt;inp_lport, 
					tp-&gt;t_inpcb-&gt;inp_fport);
				tp-&gt;t_flagsext &amp;= ~TF_LRO_OFFLOADED;
				tp-&gt;t_idleat = tp-&gt;rcv_nxt;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sw_lro &amp;&amp; !pktf_sw_lro_pkt &amp;&amp; !isipv6 &amp;&amp;
			    (so-&gt;so_flags &amp; SOF_USELRO) &amp;&amp;	
			    !IFNET_IS_CELLULAR(m-&gt;m_pkthdr.rcvif) &amp;&amp;
  			    (m-&gt;m_pkthdr.rcvif-&gt;if_type != IFT_LOOP) &amp;&amp;
			    ((th-&gt;th_seq - tp-&gt;irs) &gt; 
			    (tp-&gt;t_maxseg &lt;&lt; lro_start)) &amp;&amp;
			    ((tp-&gt;t_idleat == 0) || ((th-&gt;th_seq - 
			     tp-&gt;t_idleat) &gt; (tp-&gt;t_maxseg &lt;&lt; lro_start)))) {
				tp-&gt;t_flagsext |= TF_LRO_OFFLOADED;
				tcp_start_coalescing(ip, th, tlen);
				tp-&gt;t_idleat = 0;
			}

			<span class="enscript-comment">/* Clean receiver SACK report if present */</span>
			<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; tp-&gt;rcv_numsacks)
				tcp_clean_sackreport(tp);
			++tcpstat.tcps_preddat;
			tp-&gt;rcv_nxt += tlen;
			<span class="enscript-comment">/*
			 * Pull snd_wl1 up to prevent seq wrap relative to
			 * th_seq.
			 */</span>
			tp-&gt;snd_wl1 = th-&gt;th_seq;
			<span class="enscript-comment">/*
			 * Pull rcv_up up to prevent seq wrap relative to
			 * rcv_nxt.
			 */</span>
			tp-&gt;rcv_up = tp-&gt;rcv_nxt;
			TCP_INC_VAR(tcpstat.tcps_rcvpack, nlropkts);
			tcpstat.tcps_rcvbyte += tlen;
			<span class="enscript-keyword">if</span> (nstat_collect) {
				<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_PKT) {
					INP_ADD_STAT(inp, cell, wifi, wired, 
					    rxpackets, m-&gt;m_pkthdr.lro_npkts);
				} <span class="enscript-keyword">else</span> {
					INP_ADD_STAT(inp, cell, wifi, wired,
					    rxpackets, 1);
				}
				INP_ADD_STAT(inp, cell, wifi, wired,rxbytes,
				    tlen);
			}

			<span class="enscript-comment">/*
			 * Calculate the RTT on the receiver only if the 
			 * connection is in streaming mode and the last 
			 * packet was not an end-of-write
			 */</span>
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_STRETCHACK) &amp;&amp;
				!(tp-&gt;t_flagsext &amp; TF_STREAMEOW))
				tcp_compute_rtt(tp, &amp;to, th);

			tcp_sbrcv_grow(tp, &amp;so-&gt;so_rcv, &amp;to, tlen);
			
			<span class="enscript-comment">/*
			 * Add data to socket buffer.
			 */</span>
			so_recv_data_stat(so, m, 0);
			m_adj(m, drop_hdrlen);	<span class="enscript-comment">/* delayed header drop */</span>
			
			<span class="enscript-comment">/*
			 * If message delivery (SOF_ENABLE_MSGS) is enabled on  
			 * this socket, deliver the packet received as an
			 * in-order message with sequence number attached to it.
			 */</span>
			<span class="enscript-keyword">if</span> (sbappendstream_rcvdemux(so, m, 
			    th-&gt;th_seq - (tp-&gt;irs + 1), 0)) {
				sorwakeup(so);
			}	    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6) {
				KERNEL_DEBUG(DBG_LAYER_END, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		     			(((ip6-&gt;ip6_src.s6_addr16[0]) &lt;&lt; 16) | (ip6-&gt;ip6_dst.s6_addr16[0])),
			     		th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win); 
			}
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> 
			{
				KERNEL_DEBUG(DBG_LAYER_END, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		     			(((ip-&gt;ip_src.s_addr &amp; 0xffff) &lt;&lt; 16) | (ip-&gt;ip_dst.s_addr &amp; 0xffff)),
			     		th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win); 
			}
			TCP_INC_VAR(tp-&gt;t_unacksegs, nlropkts);
			<span class="enscript-keyword">if</span> (DELAY_ACK(tp, th))  {
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_DELACK) == 0) {
			    		tp-&gt;t_flags |= TF_DELACK;
					tp-&gt;t_timer[TCPT_DELACK] = OFFSET_FROM_START(tp, tcp_delack);
				}
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_flags |= TF_ACKNOW;
				tcp_output(tp);
			}

			tcp_adaptive_rwtimo_check(tp, tlen);

			<span class="enscript-keyword">if</span> (tlen &gt; 0)
				tcp_tfo_rcv_data(tp);

			tcp_check_timer_state(tp);
			tcp_unlock(so, 1, 0);
			KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
			<span class="enscript-keyword">return</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Calculate amount of space in receive window,
	 * and then do TCP input processing.
	 * Receive window is amount of space in rcv queue,
	 * but not less than advertised window.
	 */</span>
	lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
	    LCK_MTX_ASSERT_OWNED);
	win = tcp_sbspace(tp);
	<span class="enscript-keyword">if</span> (win &lt; 0)
		win = 0;
	<span class="enscript-keyword">else</span> {	<span class="enscript-comment">/* clip rcv window to 4K for modems */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_SLOWLINK &amp;&amp; slowlink_wsize &gt; 0)
			win = min(win, slowlink_wsize);
	}
	tp-&gt;rcv_wnd = imax(win, (<span class="enscript-type">int</span>)(tp-&gt;rcv_adv - tp-&gt;rcv_nxt));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/*
	 * Ensure that the subflow receive window isn't greater
	 * than the connection level receive window.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) &amp;&amp;
	    (mp_tp = tptomptp(tp))) {
		MPT_LOCK(mp_tp);
		<span class="enscript-keyword">if</span> (tp-&gt;rcv_wnd &gt; mp_tp-&gt;mpt_rcvwnd) {
			tp-&gt;rcv_wnd = mp_tp-&gt;mpt_rcvwnd;
			tcpstat.tcps_mp_reducedwin++;
		}
		MPT_UNLOCK(mp_tp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

	<span class="enscript-comment">/*
	 * Initialize tp-&gt;rcv_nxt, and tp-&gt;irs, select an initial
	 * tp-&gt;iss, and send a segment:
	 *     &lt;SEQ=ISS&gt;&lt;ACK=RCV_NXT&gt;&lt;CTL=SYN,ACK&gt;
	 * Also initialize tp-&gt;snd_nxt to tp-&gt;iss+1 and tp-&gt;snd_una to tp-&gt;iss.
	 * Fill in remote peer address fields if not previously specified.
	 * Enter SYN_RECEIVED state, and process any other fields of this
	 * segment in this state.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LISTEN</span>: {
		<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sockaddr_in *sin;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sockaddr_in6 *sin6;
#<span class="enscript-reference">endif</span>

		lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
		    LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			MALLOC(sin6, <span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-keyword">sizeof</span> *sin6,
			       M_SONAME, M_NOWAIT);
			<span class="enscript-keyword">if</span> (sin6 == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			bzero(sin6, <span class="enscript-keyword">sizeof</span>(*sin6));
			sin6-&gt;sin6_family = AF_INET6;
			sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
			sin6-&gt;sin6_addr = ip6-&gt;ip6_src;
			sin6-&gt;sin6_port = th-&gt;th_sport;
			laddr6 = inp-&gt;in6p_laddr;
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr))
				inp-&gt;in6p_laddr = ip6-&gt;ip6_dst;
			<span class="enscript-keyword">if</span> (in6_pcbconnect(inp, (<span class="enscript-type">struct</span> sockaddr *)sin6,
					   proc0)) {
				inp-&gt;in6p_laddr = laddr6;
				FREE(sin6, M_SONAME);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			FREE(sin6, M_SONAME);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	    {
			lck_mtx_assert(
			    &amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
			    LCK_MTX_ASSERT_OWNED);
			MALLOC(sin, <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-keyword">sizeof</span> *sin, M_SONAME,
		       M_NOWAIT);
			<span class="enscript-keyword">if</span> (sin == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			sin-&gt;sin_family = AF_INET;
			sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
			sin-&gt;sin_addr = ip-&gt;ip_src;
			sin-&gt;sin_port = th-&gt;th_sport;
			bzero((caddr_t)sin-&gt;sin_zero, <span class="enscript-keyword">sizeof</span>(sin-&gt;sin_zero));
			laddr = inp-&gt;inp_laddr;
			<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == INADDR_ANY)
				inp-&gt;inp_laddr = ip-&gt;ip_dst;
			<span class="enscript-keyword">if</span> (in_pcbconnect(inp, (<span class="enscript-type">struct</span> sockaddr *)sin, proc0,
			    IFSCOPE_NONE, NULL)) {
				inp-&gt;inp_laddr = laddr;
				FREE(sin, M_SONAME);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			FREE(sin, M_SONAME);
		}

		tcp_dooptions(tp, optp, optlen, th, &amp;to);
		tcp_finalize_options(tp, &amp;to, ifscope);

		<span class="enscript-keyword">if</span> (tfo_enabled(tp) &amp;&amp; tcp_tfo_syn(tp, &amp;to))
			isconnected = TRUE;

		<span class="enscript-keyword">if</span> (iss)
			tp-&gt;iss = iss;
		<span class="enscript-keyword">else</span> {
			tp-&gt;iss = tcp_new_isn(tp);
 		}
		tp-&gt;irs = th-&gt;th_seq;
		tcp_sendseqinit(tp);
		tcp_rcvseqinit(tp);
		tp-&gt;snd_recover = tp-&gt;snd_una;
		<span class="enscript-comment">/*
		 * Initialization of the tcpcb for transaction;
		 *   set SND.WND = SEG.WND,
		 *   initialize CCsend and CCrecv.
		 */</span>
		tp-&gt;snd_wnd = tiwin;	<span class="enscript-comment">/* initial send-window */</span>
		tp-&gt;t_flags |= TF_ACKNOW;
		tp-&gt;t_unacksegs = 0;
		DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
			<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_SYN_RECEIVED);
		tp-&gt;t_state = TCPS_SYN_RECEIVED;
		tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, 
			TCP_CONN_KEEPINIT(tp));
		dropsocket = 0;		<span class="enscript-comment">/* committed to socket */</span>

		<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
			inp-&gt;inp_flowhash = inp_calc_flowhash(inp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-comment">/* update flowinfo - RFC 6437 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flow == 0 &amp;&amp;
		    inp-&gt;in6p_flags &amp; IN6P_AUTOFLOWLABEL) {
			inp-&gt;inp_flow &amp;= ~IPV6_FLOWLABEL_MASK;
			inp-&gt;inp_flow |=
			    (htonl(inp-&gt;inp_flowhash) &amp; IPV6_FLOWLABEL_MASK);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

		<span class="enscript-comment">/* reset the incomp processing flag */</span>
		so-&gt;so_flags &amp;= ~(SOF_INCOMP_INPROGRESS);
		tcpstat.tcps_accepts++;
		<span class="enscript-keyword">if</span> ((thflags &amp; (TH_ECE | TH_CWR)) == (TH_ECE | TH_CWR)) {
			<span class="enscript-comment">/* ECN-setup SYN */</span>
			tp-&gt;ecn_flags |= (TE_SETUPRECEIVED | TE_SENDIPECT);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IFEF_NOWINDOWSCALE</span>
		<span class="enscript-keyword">if</span> (tcp_obey_ifef_nowindowscale &amp;&amp; m-&gt;m_pkthdr.rcvif != NULL &amp;&amp;
		    (m-&gt;m_pkthdr.rcvif-&gt;if_eflags &amp; IFEF_NOWINDOWSCALE)) {
			<span class="enscript-comment">/* Window scaling is not enabled on this interface */</span>
			tp-&gt;t_flags &amp;= ~TF_REQ_SCALE;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">trimthenstep6</span>;
		}

	<span class="enscript-comment">/*
	 * If the state is SYN_RECEIVED and the seg contains an ACK,
	 * but not for our SYN/ACK, send a RST.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:
		<span class="enscript-keyword">if</span> ((thflags &amp; TH_ACK) &amp;&amp;
		    (SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_una) ||
		     SEQ_GT(th-&gt;th_ack, tp-&gt;snd_max))) {
				rstreason = BANDLIM_RST_OPENPORT;
				IF_TCP_STATINC(ifp, ooopacket);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
		}

		<span class="enscript-comment">/*
		 * In SYN_RECEIVED state, if we recv some SYNS with
		 * window scale and others without, window scaling should
		 * be disabled. Otherwise the window advertised will be
		 * lower if we assume scaling and the other end does not.
		 */</span>
		<span class="enscript-keyword">if</span> ((thflags &amp; TH_SYN) &amp;&amp;
		    (tp-&gt;irs == th-&gt;th_seq) &amp;&amp;
		    !(to.to_flags &amp; TOF_SCALE))
			tp-&gt;t_flags &amp;= ~TF_RCVD_SCALE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/*
	 * If the state is SYN_SENT:
	 *	if seg contains an ACK, but not for our SYN, drop the input.
	 *	if seg contains a RST, then drop the connection.
	 *	if seg does not contain SYN, then drop it.
	 * Otherwise this is an acceptable SYN segment
	 *	initialize tp-&gt;rcv_nxt and tp-&gt;irs
	 *	if seg contains ack then advance tp-&gt;snd_una
	 *	if SYN has been acked change to ESTABLISHED else SYN_RCVD state
	 *	arrange for segment to be acked (eventually)
	 *	continue processing rest of data/controls, beginning with URG
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_SENT</span>:
		<span class="enscript-keyword">if</span> ((thflags &amp; TH_ACK) &amp;&amp;
		    (SEQ_LEQ(th-&gt;th_ack, tp-&gt;iss) ||
		     SEQ_GT(th-&gt;th_ack, tp-&gt;snd_max))) {
			rstreason = BANDLIM_UNLIMITED;
			IF_TCP_STATINC(ifp, ooopacket);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
		}
		<span class="enscript-keyword">if</span> (thflags &amp; TH_RST) {
			<span class="enscript-keyword">if</span> ((thflags &amp; TH_ACK) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
				<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MPTCP_FASTJOIN) &amp;&amp;
					SEQ_GT(th-&gt;th_ack, tp-&gt;iss+1)) {
					so-&gt;so_flags &amp;= ~SOF_MPTCP_FASTJOIN;
					<span class="enscript-comment">/* ignore the RST and retransmit SYN */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
				soevent(so, 
				    (SO_FILT_HINT_LOCKED |
				    SO_FILT_HINT_CONNRESET));
				tp = tcp_drop(tp, ECONNREFUSED);
				postevent(so, 0, EV_RESET);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
		<span class="enscript-keyword">if</span> ((thflags &amp; TH_SYN) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		tp-&gt;snd_wnd = th-&gt;th_win;	<span class="enscript-comment">/* initial send window */</span>

		tp-&gt;irs = th-&gt;th_seq;
		tcp_rcvseqinit(tp);
		<span class="enscript-keyword">if</span> (thflags &amp; TH_ACK) {
			tcpstat.tcps_connects++;
			
			<span class="enscript-keyword">if</span> ((thflags &amp; (TH_ECE | TH_CWR)) == (TH_ECE)) {
				<span class="enscript-comment">/* ECN-setup SYN-ACK */</span>
				tp-&gt;ecn_flags |= TE_SETUPRECEIVED;
				<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp))
					tcpstat.tcps_ecn_client_success++;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_SETUPSENT &amp;&amp;
				    tp-&gt;t_rxtshift == 0)
					tcpstat.tcps_ecn_not_supported++;
				<span class="enscript-comment">/* non-ECN-setup SYN-ACK */</span>
				tp-&gt;ecn_flags &amp;= ~TE_SENDIPECT;
			}
			
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			<span class="enscript-comment">/* XXXMAC: recursive lock: SOCK_LOCK(so); */</span>
			mac_socketpeer_label_associate_mbuf(m, so);
			<span class="enscript-comment">/* XXXMAC: SOCK_UNLOCK(so); */</span>
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* Do window scaling on this connection? */</span>
			<span class="enscript-keyword">if</span> (TCP_WINDOW_SCALE_ENABLED(tp)) {
				tp-&gt;snd_scale = tp-&gt;requested_s_scale;
				tp-&gt;rcv_scale = tp-&gt;request_r_scale;
			}

			tp-&gt;rcv_adv += min(tp-&gt;rcv_wnd, TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale);
			tp-&gt;snd_una++;		<span class="enscript-comment">/* SYN is acked */</span>
			<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_una))
				tp-&gt;snd_nxt = tp-&gt;snd_una;

			<span class="enscript-comment">/*
			 * We have sent more in the SYN than what is being
			 * acked. (e.g., TFO)
			 * We should restart the sending from what the receiver
			 * has acknowledged immediately.
			 */</span>
			<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_nxt, th-&gt;th_ack))
				tp-&gt;snd_nxt = th-&gt;th_ack;

			<span class="enscript-comment">/*
			 * If there's data, delay ACK; if there's also a FIN
			 * ACKNOW will be turned on later.
			 */</span>
			TCP_INC_VAR(tp-&gt;t_unacksegs, nlropkts);
			<span class="enscript-keyword">if</span> (DELAY_ACK(tp, th) &amp;&amp; tlen != 0 ) {
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_DELACK) == 0) {
					tp-&gt;t_flags |= TF_DELACK;
					tp-&gt;t_timer[TCPT_DELACK] = OFFSET_FROM_START(tp, tcp_delack);
				}
			}
			<span class="enscript-keyword">else</span> {
				tp-&gt;t_flags |= TF_ACKNOW;
			}
			<span class="enscript-comment">/*
			 * Received &lt;SYN,ACK&gt; in SYN_SENT[*] state.
			 * Transitions:
			 *	SYN_SENT  --&gt; ESTABLISHED
			 *	SYN_SENT* --&gt; FIN_WAIT_1
			 */</span>
			tp-&gt;t_starttime = tcp_now;
			tcp_sbrcv_tstmp_check(tp);
			<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDFIN) {
				DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL,
				    <span class="enscript-type">struct</span> inpcb *, inp,
				    <span class="enscript-type">struct</span> tcpcb *, tp, int32_t,
				    TCPS_FIN_WAIT_1);
				tp-&gt;t_state = TCPS_FIN_WAIT_1;
				tp-&gt;t_flags &amp;= ~TF_NEEDFIN;
				thflags &amp;= ~TH_SYN;
			} <span class="enscript-keyword">else</span> {
				DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL,
				    <span class="enscript-type">struct</span> inpcb *, inp, <span class="enscript-type">struct</span> tcpcb *,
				    tp, int32_t, TCPS_ESTABLISHED);
				tp-&gt;t_state = TCPS_ESTABLISHED;
				tp-&gt;t_timer[TCPT_KEEP] =
				    OFFSET_FROM_START(tp,
				    TCP_CONN_KEEPIDLE(tp));
				<span class="enscript-keyword">if</span> (nstat_collect)
					nstat_route_connect_success(
					    tp-&gt;t_inpcb-&gt;inp_route.ro_rt);
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
			<span class="enscript-comment">/*
			 * Do not send the connect notification for additional
			 * subflows until ACK for 3-way handshake arrives.
			 */</span>
			<span class="enscript-keyword">if</span> ((!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)) &amp;&amp;
			    (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN)) {
				isconnected = FALSE;
				<span class="enscript-comment">/* Start data xmit if fastjoin */</span>
				<span class="enscript-keyword">if</span> (mptcp_fastjoin &amp;&amp; (so-&gt;so_flags &amp; SOF_MPTCP_FASTJOIN)) {
					soevent(so, (SO_FILT_HINT_LOCKED | 
					    SO_FILT_HINT_MPFASTJ));
				}
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
				isconnected = TRUE;

			<span class="enscript-keyword">if</span> (tp-&gt;t_tfo_flags &amp; (TFO_F_COOKIE_REQ | TFO_F_COOKIE_SENT)) {
				tcp_tfo_synack(tp, &amp;to);

				<span class="enscript-keyword">if</span> ((tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_SENT) &amp;&amp;
				    SEQ_LT(tp-&gt;snd_una, th-&gt;th_ack)) {
					tp-&gt;t_tfo_stats |= TFO_S_SYN_DATA_ACKED;
					tcpstat.tcps_tfo_syn_data_acked++;

					<span class="enscript-keyword">if</span> (!(tp-&gt;t_tfo_flags &amp; TFO_F_NO_RCVPROBING))
						tcp_tfo_rcv_probe(tp, tlen);
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 *  Received initial SYN in SYN-SENT[*] state =&gt; simul-
		  	 *  taneous open.  If segment contains CC option and there is
			 *  a cached CC, apply TAO test; if it succeeds, connection is
			 *  half-synchronized.  Otherwise, do 3-way handshake:
			 *        SYN-SENT -&gt; SYN-RECEIVED
			 *        SYN-SENT* -&gt; SYN-RECEIVED*
			 */</span>
			tp-&gt;t_flags |= TF_ACKNOW;
			tp-&gt;t_timer[TCPT_REXMT] = 0;
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
				<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_SYN_RECEIVED);
			tp-&gt;t_state = TCPS_SYN_RECEIVED;

			<span class="enscript-comment">/*
			 * During simultaneous open, TFO should not be used.
			 * So, we disable it here, to prevent that data gets
			 * sent on the SYN/ACK.
			 */</span>
			tcp_disable_tfo(tp);
		}

<span class="enscript-reference">trimthenstep6</span>:
		<span class="enscript-comment">/*
		 * Advance th-&gt;th_seq to correspond to first data byte.
		 * If data, trim to stay within window,
		 * dropping FIN if necessary.
		 */</span>
		th-&gt;th_seq++;
		<span class="enscript-keyword">if</span> (tlen &gt; tp-&gt;rcv_wnd) {
			todrop = tlen - tp-&gt;rcv_wnd;
			m_adj(m, -todrop);
			tlen = tp-&gt;rcv_wnd;
			thflags &amp;= ~TH_FIN;
			tcpstat.tcps_rcvpackafterwin++;
			tcpstat.tcps_rcvbyteafterwin += todrop;
		}
		tp-&gt;snd_wl1 = th-&gt;th_seq - 1;
		tp-&gt;rcv_up = th-&gt;th_seq;
		<span class="enscript-comment">/*
		 *  Client side of transaction: already sent SYN and data.
		 *  If the remote host used T/TCP to validate the SYN,
		 *  our data will be ACK'd; if so, enter normal data segment
		 *  processing in the middle of step 5, ack processing.
		 *  Otherwise, goto step 6.
		 */</span>
 		<span class="enscript-keyword">if</span> (thflags &amp; TH_ACK)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">process_ACK</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">step6</span>;
	<span class="enscript-comment">/*
	 * If the state is LAST_ACK or CLOSING or TIME_WAIT:
	 *      do normal processing.
	 *
	 * NB: Leftover from RFC1644 T/TCP.  Cases to be reused later.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LAST_ACK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSING</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
 		<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* continue normal processing */</span>

	<span class="enscript-comment">/* Received a SYN while connection is already established.
	 * This is a &quot;half open connection and other anomalies&quot; described
	 * in RFC793 page 34, send an ACK so the remote reset the connection
	 * or recovers by adjusting its sequence numberering 
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
		<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * States other than LISTEN or SYN_SENT.
	 * First check the RST flag and sequence number since reset segments
	 * are exempt from the timestamp and connection count tests.  This
	 * fixes a bug introduced by the Stevens, vol. 2, p. 960 bugfix
	 * below which allowed reset segments in half the sequence space
	 * to fall though and be processed (which gives forged reset
	 * segments with a random sequence number a 50 percent chance of
	 * killing a connection).
	 * Then check timestamp, if present.
	 * Then check the connection count, if present.
	 * Then check that at least some bytes of segment are within
	 * receive window.  If segment begins before rcv_nxt,
	 * drop leading data (and SYN); if nothing left, just ack.
	 *
	 *
	 * If the RST bit is set, check the sequence number to see
	 * if this is a valid reset segment.
	 * RFC 793 page 37:
	 *   In all states except SYN-SENT, all reset (RST) segments
	 *   are validated by checking their SEQ-fields.  A reset is
	 *   valid if its sequence number is in the window.
	 * Note: this does not take into account delayed ACKs, so
	 *   we should test against last_ack_sent instead of rcv_nxt.
	 *   The sequence number in the reset segment is normally an
	 *   echo of our outgoing acknowlegement numbers, but some hosts
	 *   send a reset with the sequence number at the rightmost edge
	 *   of our receive window, and we have to handle this case.
	 * Note 2: Paul Watson's paper &quot;Slipping in the Window&quot; has shown
	 *   that brute force RST attacks are possible.  To combat this,
	 *   we use a much stricter check while in the ESTABLISHED state,
	 *   only accepting RSTs where the sequence number is equal to
	 *   last_ack_sent.  In all other states (the states in which a
	 *   RST is more likely), the more permissive check is used.
	 * If we have multiple segments in flight, the intial reset
	 * segment sequence numbers will be to the left of last_ack_sent,
	 * but they will eventually catch up.
	 * In any case, it never made sense to trim reset segments to
	 * fit the receive window since RFC 1122 says:
	 *   4.2.2.12  RST Segment: RFC-793 Section 3.4
	 *
	 *    A TCP SHOULD allow a received RST segment to include data.
	 *
	 *    DISCUSSION
	 *         It has been suggested that a RST segment could contain
	 *         ASCII text that encoded and explained the cause of the
	 *         RST.  No standard has yet been established for such
	 *         data.
	 *
	 * If the reset segment passes the sequence number test examine
	 * the state:
	 *    SYN_RECEIVED STATE:
	 *	If passive open, return to LISTEN state.
	 *	If active open, inform user that connection was refused.
	 *    ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, CLOSE_WAIT STATES:
	 *	Inform user that connection was reset, and close tcb.
	 *    CLOSING, LAST_ACK STATES:
	 *	Close the tcb.
	 *    TIME_WAIT STATE:
	 *	Drop the segment - see Stevens, vol. 2, p. 964 and
	 *      RFC 1337.
	 *
	 *      Radar 4803931: Allows for the case where we ACKed the FIN but
	 *                     there is already a RST in flight from the peer.
	 *                     In that case, accept the RST for non-established
	 *                     state if it's one off from last_ack_sent.

	 */</span>
	<span class="enscript-keyword">if</span> (thflags &amp; TH_RST) {
		<span class="enscript-keyword">if</span> ((SEQ_GEQ(th-&gt;th_seq, tp-&gt;last_ack_sent) &amp;&amp;
		    SEQ_LT(th-&gt;th_seq, tp-&gt;last_ack_sent + tp-&gt;rcv_wnd)) ||
		    (tp-&gt;rcv_wnd == 0 &amp;&amp; 
		    ((tp-&gt;last_ack_sent == th-&gt;th_seq) || 
		    ((tp-&gt;last_ack_sent -1) == th-&gt;th_seq)))) {
			<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:
				IF_TCP_STATINC(ifp, rstinsynrcv);
				so-&gt;so_error = ECONNREFUSED;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">close</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
				<span class="enscript-keyword">if</span> (tp-&gt;last_ack_sent != th-&gt;th_seq) {
					tcpstat.tcps_badrst++;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_1</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSE_WAIT</span>:
				<span class="enscript-comment">/*
				  Drop through ...
				*/</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_2</span>:
				so-&gt;so_error = ECONNRESET;
			<span class="enscript-reference">close</span>:
				postevent(so, 0, EV_RESET);
				soevent(so,
				    (SO_FILT_HINT_LOCKED |
				    SO_FILT_HINT_CONNRESET));

				tcpstat.tcps_drops++;
				tp = tcp_close(tp);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSING</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LAST_ACK</span>:
				tp = tcp_close(tp);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	}

	<span class="enscript-comment">/*
	 * RFC 1323 PAWS: If we have a timestamp reply on this segment
	 * and it's less than ts_recent, drop it.
	 */</span>
	<span class="enscript-keyword">if</span> ((to.to_flags &amp; TOF_TS) != 0 &amp;&amp; tp-&gt;ts_recent &amp;&amp;
	    TSTMP_LT(to.to_tsval, tp-&gt;ts_recent)) {

		<span class="enscript-comment">/* Check to see if ts_recent is over 24 days old.  */</span>
		<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)(tcp_now - tp-&gt;ts_recent_age) &gt; TCP_PAWS_IDLE) {
			<span class="enscript-comment">/*
			 * Invalidate ts_recent.  If this segment updates
			 * ts_recent, the age will be reset later and ts_recent
			 * will get a valid value.  If it does not, setting
			 * ts_recent to zero will at least satisfy the
			 * requirement that zero be placed in the timestamp
			 * echo reply when ts_recent isn't valid.  The
			 * age isn't reset until we get a valid ts_recent
			 * because we don't want out-of-order segments to be
			 * dropped when ts_recent is old.
			 */</span>
			tp-&gt;ts_recent = 0;
		} <span class="enscript-keyword">else</span> {
			tcpstat.tcps_rcvduppack++;
			tcpstat.tcps_rcvdupbyte += tlen;
			tcpstat.tcps_pawsdrop++;
			<span class="enscript-keyword">if</span> (nstat_collect) {
				nstat_route_rx(tp-&gt;t_inpcb-&gt;inp_route.ro_rt, 
					1, tlen, NSTAT_RX_FLAG_DUPLICATE);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    rxpackets, 1);
				INP_ADD_STAT(inp, cell, wifi, wired,
				    rxbytes, tlen);
				tp-&gt;t_stat.rxduplicatebytes += tlen;
			}
			<span class="enscript-keyword">if</span> (tlen &gt; 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
	}

	<span class="enscript-comment">/*
	 * In the SYN-RECEIVED state, validate that the packet belongs to
	 * this connection before trimming the data to fit the receive
	 * window.  Check the sequence number versus IRS since we know
	 * the sequence numbers haven't wrapped.  This is a partial fix
	 * for the &quot;LAND&quot; DoS attack.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_RECEIVED &amp;&amp; SEQ_LT(th-&gt;th_seq, tp-&gt;irs)) {
		rstreason = BANDLIM_RST_OPENPORT;
		IF_TCP_STATINC(ifp, dospacket);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
	}

	todrop = tp-&gt;rcv_nxt - th-&gt;th_seq;
	<span class="enscript-keyword">if</span> (todrop &gt; 0) {
		<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN) {
			thflags &amp;= ~TH_SYN;
			th-&gt;th_seq++;
			<span class="enscript-keyword">if</span> (th-&gt;th_urp &gt; 1)
				th-&gt;th_urp--;
			<span class="enscript-keyword">else</span>
				thflags &amp;= ~TH_URG;
			todrop--;
		}
		<span class="enscript-comment">/*
		 * Following if statement from Stevens, vol. 2, p. 960.
		 */</span>
		<span class="enscript-keyword">if</span> (todrop &gt; tlen
		    || (todrop == tlen &amp;&amp; (thflags &amp; TH_FIN) == 0)) {
			<span class="enscript-comment">/*
			 * Any valid FIN must be to the left of the window.
			 * At this point the FIN must be a duplicate or out
			 * of sequence; drop it.
			 */</span>
			thflags &amp;= ~TH_FIN;

			<span class="enscript-comment">/*
			 * Send an ACK to resynchronize and drop any data.
			 * But keep on processing for RST or ACK.
			 */</span>
			tp-&gt;t_flags |= TF_ACKNOW;
			<span class="enscript-keyword">if</span> (todrop == 1) {
				<span class="enscript-comment">/* This could be a keepalive */</span>
				soevent(so, SO_FILT_HINT_LOCKED |
					SO_FILT_HINT_KEEPALIVE);
			}
			todrop = tlen;
			tcpstat.tcps_rcvduppack++;
			tcpstat.tcps_rcvdupbyte += todrop; 
		} <span class="enscript-keyword">else</span> {
			tcpstat.tcps_rcvpartduppack++;
			tcpstat.tcps_rcvpartdupbyte += todrop;
		}

		<span class="enscript-keyword">if</span> (TCP_DSACK_ENABLED(tp) &amp;&amp; todrop &gt; 1) {
			<span class="enscript-comment">/*
			 * Note the duplicate data sequence space so that
			 * it can be reported in DSACK option.
			 */</span>
			tp-&gt;t_dsack_lseq = th-&gt;th_seq;
			tp-&gt;t_dsack_rseq = th-&gt;th_seq + todrop;
			tp-&gt;t_flags |= TF_ACKNOW;
		}
		<span class="enscript-keyword">if</span> (nstat_collect) {
			nstat_route_rx(tp-&gt;t_inpcb-&gt;inp_route.ro_rt, 1, 
				todrop, NSTAT_RX_FLAG_DUPLICATE);
			INP_ADD_STAT(inp, cell, wifi, wired, rxpackets, 1);
			INP_ADD_STAT(inp, cell, wifi, wired, rxbytes, todrop);
			tp-&gt;t_stat.rxduplicatebytes += todrop;
		}
		drop_hdrlen += todrop;	<span class="enscript-comment">/* drop from the top afterwards */</span>
		th-&gt;th_seq += todrop;
		tlen -= todrop;
		<span class="enscript-keyword">if</span> (th-&gt;th_urp &gt; todrop)
			th-&gt;th_urp -= todrop;
		<span class="enscript-keyword">else</span> {
			thflags &amp;= ~TH_URG;
			th-&gt;th_urp = 0;
		}
	}

	<span class="enscript-comment">/*
	 * If new data are received on a connection after the user
	 * processes are gone, then RST the other end.
	 * Send also a RST when we received a data segment after we've
	 * sent our FIN when the socket is defunct.
	 * Note that an MPTCP subflow socket would have SS_NOFDREF set
	 * by default so check to make sure that we test for SOF_MP_SUBFLOW
	 * socket flag (which would be cleared when the socket is closed.)
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp; tlen &amp;&amp;
	    (((so-&gt;so_state &amp; SS_NOFDREF) &amp;&amp;
	    tp-&gt;t_state &gt; TCPS_CLOSE_WAIT) ||
	    ((so-&gt;so_flags &amp; SOF_DEFUNCT) &amp;&amp;
	    tp-&gt;t_state &gt; TCPS_FIN_WAIT_1))) {
		tp = tcp_close(tp);
		tcpstat.tcps_rcvafterclose++;
		rstreason = BANDLIM_UNLIMITED;
		IF_TCP_STATINC(ifp, cleanup);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
	}

	<span class="enscript-comment">/*
	 * If segment ends after window, drop trailing data
	 * (and PUSH and FIN); if nothing left, just ACK.
	 */</span>
	todrop = (th-&gt;th_seq+tlen) - (tp-&gt;rcv_nxt+tp-&gt;rcv_wnd);
	<span class="enscript-keyword">if</span> (todrop &gt; 0) {
		tcpstat.tcps_rcvpackafterwin++;
		<span class="enscript-keyword">if</span> (todrop &gt;= tlen) {
			tcpstat.tcps_rcvbyteafterwin += tlen;
			<span class="enscript-comment">/*
			 * If a new connection request is received
			 * while in TIME_WAIT, drop the old connection
			 * and start over if the sequence numbers
			 * are above the previous ones.
			 */</span>
			<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN &amp;&amp;
			    tp-&gt;t_state == TCPS_TIME_WAIT &amp;&amp;
			    SEQ_GT(th-&gt;th_seq, tp-&gt;rcv_nxt)) {
				iss = tcp_new_isn(tp);
				tp = tcp_close(tp);
				tcp_unlock(so, 1, 0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">findpcb</span>;
			}
			<span class="enscript-comment">/*
			 * If window is closed can only take segments at
			 * window edge, and have to drop data and PUSH from
			 * incoming segments.  Continue processing, but
			 * remember to ack.  Otherwise, drop segment
			 * and ack.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;rcv_wnd == 0 &amp;&amp; th-&gt;th_seq == tp-&gt;rcv_nxt) {
				tp-&gt;t_flags |= TF_ACKNOW;
				tcpstat.tcps_rcvwinprobe++;
			} <span class="enscript-keyword">else</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
		} <span class="enscript-keyword">else</span>
			tcpstat.tcps_rcvbyteafterwin += todrop;
		m_adj(m, -todrop);
		tlen -= todrop;
		thflags &amp;= ~(TH_PUSH|TH_FIN);
	}

	<span class="enscript-comment">/*
	 * If last ACK falls within this segment's sequence numbers,
	 * record its timestamp.
	 * NOTE: 
	 * 1) That the test incorporates suggestions from the latest
	 *    proposal of the <a href="mailto:tcplw@cray.com">tcplw@cray.com</a> list (Braden 1993/04/26).
	 * 2) That updating only on newer timestamps interferes with
	 *    our earlier PAWS tests, so this check should be solely
	 *    predicated on the sequence space of this segment.
	 * 3) That we modify the segment boundary check to be 
	 *        Last.ACK.Sent &lt;= SEG.SEQ + SEG.Len  
	 *    instead of RFC1323's
	 *        Last.ACK.Sent &lt; SEG.SEQ + SEG.Len,
	 *    This modified check allows us to overcome RFC1323's
	 *    limitations as described in Stevens TCP/IP Illustrated
	 *    Vol. 2 p.869. In such cases, we can still calculate the
	 *    RTT correctly when RCV.NXT == Last.ACK.Sent.
	 */</span>
	<span class="enscript-keyword">if</span> ((to.to_flags &amp; TOF_TS) != 0 &amp;&amp;
	    SEQ_LEQ(th-&gt;th_seq, tp-&gt;last_ack_sent) &amp;&amp;
	    SEQ_LEQ(tp-&gt;last_ack_sent, th-&gt;th_seq + tlen +
		((thflags &amp; (TH_SYN|TH_FIN)) != 0))) {
		tp-&gt;ts_recent_age = tcp_now;
		tp-&gt;ts_recent = to.to_tsval;
	}

	<span class="enscript-comment">/*
	 * If a SYN is in the window, then this is an
	 * error and we send an RST and drop the connection.
	 */</span>
	<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN) {
		tp = tcp_drop(tp, ECONNRESET);
		rstreason = BANDLIM_UNLIMITED;
		postevent(so, 0, EV_RESET);
		IF_TCP_STATINC(ifp, synwindow);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
	}

	<span class="enscript-comment">/*
	 * If the ACK bit is off:  if in SYN-RECEIVED state or SENDSYN
	 * flag is on (half-synchronized state), then queue data for
	 * later processing; else drop segment and return.
	 */</span>
	<span class="enscript-keyword">if</span> ((thflags &amp; TH_ACK) == 0) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_RECEIVED ||
		    (tp-&gt;t_flags &amp; TF_NEEDSYN)) {
			<span class="enscript-keyword">if</span> ((tfo_enabled(tp))) {
				<span class="enscript-comment">/*
				 * So, we received a valid segment while in
				 * SYN-RECEIVED (TF_NEEDSYN is actually never
				 * set, so this is dead code).
				 * As this cannot be an RST (see that if a bit
				 * higher), and it does not have the ACK-flag
				 * set, we want to retransmit the SYN/ACK.
				 * Thus, we have to reset snd_nxt to snd_una to
				 * trigger the going back to sending of the
				 * SYN/ACK. This is more consistent with the
				 * behavior of tcp_output(), which expects
				 * to send the segment that is pointed to by
				 * snd_nxt.
				 */</span>
				tp-&gt;snd_nxt = tp-&gt;snd_una;

				<span class="enscript-comment">/*
				 * We need to make absolutely sure that we are
				 * going to reply upon a duplicate SYN-segment.
				 */</span>
				<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN)
					needoutput = 1;
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">step6</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_ACKNOW)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	}

	<span class="enscript-comment">/*
	 * Ack processing.
	 */</span>

	<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

	<span class="enscript-comment">/*
	 * In SYN_RECEIVED state, the ack ACKs our SYN, so enter
	 * ESTABLISHED state and continue processing.
	 * The ACK was checked above.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:

		tcpstat.tcps_connects++;

		<span class="enscript-comment">/* Do window scaling? */</span>
		<span class="enscript-keyword">if</span> (TCP_WINDOW_SCALE_ENABLED(tp)) {
			tp-&gt;snd_scale = tp-&gt;requested_s_scale;
			tp-&gt;rcv_scale = tp-&gt;request_r_scale;
			tp-&gt;snd_wnd = th-&gt;th_win &lt;&lt; tp-&gt;snd_scale;
			tiwin = tp-&gt;snd_wnd;
		}
		<span class="enscript-comment">/*
		 * Make transitions:
		 *      SYN-RECEIVED  -&gt; ESTABLISHED
		 *      SYN-RECEIVED* -&gt; FIN-WAIT-1
		 */</span>
		tp-&gt;t_starttime = tcp_now;
		tcp_sbrcv_tstmp_check(tp);
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDFIN) {
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL,
			    <span class="enscript-type">struct</span> inpcb *, inp,
			    <span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_FIN_WAIT_1);
			tp-&gt;t_state = TCPS_FIN_WAIT_1;
			tp-&gt;t_flags &amp;= ~TF_NEEDFIN;
		} <span class="enscript-keyword">else</span> {
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL,
			    <span class="enscript-type">struct</span> inpcb *, inp,
			    <span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_ESTABLISHED);
			tp-&gt;t_state = TCPS_ESTABLISHED;
			tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
				TCP_CONN_KEEPIDLE(tp));
			<span class="enscript-keyword">if</span> (nstat_collect)
				nstat_route_connect_success(
				    tp-&gt;t_inpcb-&gt;inp_route.ro_rt);
		}
		<span class="enscript-comment">/*
		 * If segment contains data or ACK, will call tcp_reass()
		 * later; if not, do so now to pass queued data to user.
		 */</span>
		<span class="enscript-keyword">if</span> (tlen == 0 &amp;&amp; (thflags &amp; TH_FIN) == 0)
			(<span class="enscript-type">void</span>) tcp_reass(tp, (<span class="enscript-type">struct</span> tcphdr *)0, &amp;tlen,
			    NULL, ifp);
		tp-&gt;snd_wl1 = th-&gt;th_seq - 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-comment">/*
		 * Do not send the connect notification for additional subflows
		 * until ACK for 3-way handshake arrives.
		 */</span>
		<span class="enscript-keyword">if</span> ((!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)) &amp;&amp;
		    (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN)) {
			isconnected = FALSE;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
			isconnected = TRUE;
		<span class="enscript-keyword">if</span> ((tp-&gt;t_tfo_flags &amp; TFO_F_COOKIE_VALID)) {
			<span class="enscript-comment">/* Done this when receiving the SYN */</span>
			isconnected = FALSE;

			OSDecrementAtomic(&amp;tcp_tfo_halfcnt);

			<span class="enscript-comment">/* Panic if something has gone terribly wrong. */</span>
			VERIFY(tcp_tfo_halfcnt &gt;= 0);

			tp-&gt;t_tfo_flags &amp;= ~TFO_F_COOKIE_VALID;
		}

		<span class="enscript-comment">/*
		 * In case there is data in the send-queue (e.g., TFO is being
		 * used, or connectx+data has been done), then if we would
		 * &quot;FALLTHROUGH&quot;, we would handle this ACK as if data has been
		 * acknowledged. But, we have to prevent this. And this
		 * can be prevented by increasing snd_una by 1, so that the
		 * SYN is not considered as data (snd_una++ is actually also
		 * done in SYN_SENT-state as part of the regular TCP stack).
		 *
		 * In case there is data on this ack as well, the data will be
		 * handled by the label &quot;dodata&quot; right after step6.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_cc) {
			tp-&gt;snd_una++;	<span class="enscript-comment">/* SYN is acked */</span>
			<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_una))
				tp-&gt;snd_nxt = tp-&gt;snd_una;

			<span class="enscript-comment">/*
			 * No duplicate-ACK handling is needed. So, we
			 * directly advance to processing the ACK (aka,
			 * updating the RTT estimation,...)
			 *
			 * But, we first need to handle eventual SACKs,
			 * because TFO will start sending data with the
			 * SYN/ACK, so it might be that the client
			 * includes a SACK with its ACK.
			 */</span>
			<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp;
			    (to.to_nsacks &gt; 0 ||
			     !TAILQ_EMPTY(&amp;tp-&gt;snd_holes)))
				tcp_sack_doack(tp, &amp;to, th,
				    &amp;sack_bytes_acked);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">process_ACK</span>;
		}

		<span class="enscript-comment">/* FALLTHROUGH */</span>

	<span class="enscript-comment">/*
	 * In ESTABLISHED state: drop duplicate ACKs; ACK out of range
	 * ACKs.  If the ack is in the range
	 *	tp-&gt;snd_una &lt; th-&gt;th_ack &lt;= tp-&gt;snd_max
	 * then advance tp-&gt;snd_una to th-&gt;th_ack and drop
	 * data from the retransmission queue.  If this ACK reflects
	 * more up to date window information we update our window information.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_1</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_2</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSE_WAIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSING</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LAST_ACK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
		<span class="enscript-keyword">if</span> (SEQ_GT(th-&gt;th_ack, tp-&gt;snd_max)) {
			tcpstat.tcps_rcvacktoomuch++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
		}
		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; to.to_nsacks &gt; 0) {
			recvd_dsack = tcp_sack_process_dsack(tp, &amp;to, th);
			<span class="enscript-comment">/*
			 * If DSACK is received and this packet has no
			 * other SACK information, it can be dropped.
			 * We do not want to treat it as a duplicate ack.
			 */</span>
			<span class="enscript-keyword">if</span> (recvd_dsack &amp;&amp;
			    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_una) &amp;&amp;
			    to.to_nsacks == 0) {
				tcp_bad_rexmt_check(tp, th, &amp;to);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
		}

		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp;
		    (to.to_nsacks &gt; 0 || !TAILQ_EMPTY(&amp;tp-&gt;snd_holes)))
			tcp_sack_doack(tp, &amp;to, th, &amp;sack_bytes_acked);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_mpuna) &amp;&amp; (SEQ_GEQ(th-&gt;th_ack, tp-&gt;t_mpuna))) {
			<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) {
				<span class="enscript-comment">/* MP TCP establishment succeeded */</span>
				tp-&gt;t_mpuna = 0;
				<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW) {
					<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_SENT_JOIN) {
						tp-&gt;t_mpflags &amp;=
						    ~TMPF_PREESTABLISHED;
						tp-&gt;t_mpflags |=
						    TMPF_MPTCP_TRUE;
						so-&gt;so_flags |= SOF_MPTCP_TRUE;
						mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP &quot;</span>
						    <span class="enscript-string">&quot;Sockets: %s \n&quot;</span>,__func__),
						    MPTCP_SOCKET_DBG,
						    MPTCP_LOGLVL_LOG);

						tp-&gt;t_timer[TCPT_JACK_RXMT] = 0;
						tp-&gt;t_mprxtshift = 0;
						isconnected = TRUE;
					} <span class="enscript-keyword">else</span> {
						isconnected = FALSE;
					}
				} <span class="enscript-keyword">else</span> {
					isconnected = TRUE;
					tp-&gt;t_mpflags &amp;= ~TMPF_SENT_KEYS;
				}
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

		tcp_tfo_rcv_ack(tp, th);

		<span class="enscript-comment">/*
		 * If we have outstanding data (other than
		 * a window probe), this is a completely
		 * duplicate ack (ie, window info didn't
		 * change) and the ack is the biggest we've seen.
		 */</span> 
		<span class="enscript-keyword">if</span> (SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_una)) {
			<span class="enscript-keyword">if</span> (tlen == 0 &amp;&amp; tiwin == tp-&gt;snd_wnd) {
				<span class="enscript-comment">/*
				 * If both ends send FIN at the same time,
				 * then the ack will be a duplicate ack
				 * but we have to process the FIN. Check
				 * for this condition and process the FIN
				 * instead of the dupack
				 */</span> 
				<span class="enscript-keyword">if</span> ((thflags &amp; TH_FIN) &amp;&amp;
				    (tp-&gt;t_flags &amp; TF_SENTFIN) &amp;&amp;
				    !TCPS_HAVERCVDFIN(tp-&gt;t_state) &amp;&amp;
				    (th-&gt;th_ack + 1) == tp-&gt;snd_max)
					<span class="enscript-keyword">break</span>;
<span class="enscript-reference">process_dupack</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
				<span class="enscript-comment">/*
				 * MPTCP options that are ignored must
				 * not be treated as duplicate ACKs.
				 */</span>
				<span class="enscript-keyword">if</span> (to.to_flags &amp; TOF_MPTCP) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				}

				<span class="enscript-keyword">if</span> ((isconnected) &amp;&amp; (tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW)) {
					mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP &quot;</span>
					    <span class="enscript-string">&quot;Sockets: bypass ack recovery\n&quot;</span>),
					    MPTCP_SOCKET_DBG, 
					    MPTCP_LOGLVL_VERBOSE);
					<span class="enscript-keyword">break</span>;
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
				<span class="enscript-comment">/*
				 * If a duplicate acknowledgement was seen
				 * after ECN, it indicates packet loss in
				 * addition to ECN. Reset INRECOVERY flag
				 * so that we can process partial acks
				 * correctly
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_INRECOVERY)
					tp-&gt;ecn_flags &amp;= ~TE_INRECOVERY;

				tcpstat.tcps_rcvdupack++;
				++tp-&gt;t_dupacks;

				<span class="enscript-comment">/*
				 * Check if we need to reset the limit on
				 * early retransmit
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;t_early_rexmt_count &gt; 0 &amp;&amp;
				    TSTMP_GEQ(tcp_now,
				    (tp-&gt;t_early_rexmt_win +
				    TCP_EARLY_REXMT_WIN)))
					tp-&gt;t_early_rexmt_count = 0;

				<span class="enscript-comment">/* 
				 * Is early retransmit needed? We check for
				 * this when the connection is waiting for
				 * duplicate acks to enter fast recovery.
				 */</span>
				<span class="enscript-keyword">if</span> (!IN_FASTRECOVERY(tp))
					tcp_early_rexmt_check(tp, th);

				<span class="enscript-comment">/*
				 * If we've seen exactly rexmt threshold 
				 * of duplicate acks, assume a packet
				 * has been dropped and retransmit it.
				 * Kludge snd_nxt &amp; the congestion
				 * window so we send only this one
				 * packet.
				 *
				 * We know we're losing at the current
				 * window size so do congestion avoidance
				 * (set ssthresh to half the current window
				 * and pull our congestion window back to
				 * the new ssthresh).
				 *
				 * Dup acks mean that packets have left the
				 * network (they're now cached at the receiver)
				 * so bump cwnd by the amount in the receiver
				 * to keep a constant cwnd packets in the
				 * network.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_REXMT] == 0 ||
				    (th-&gt;th_ack != tp-&gt;snd_una
				    &amp;&amp; sack_bytes_acked == 0)) {
					tp-&gt;t_dupacks = 0;
					tp-&gt;t_rexmtthresh = tcprexmtthresh;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_dupacks &gt; tp-&gt;t_rexmtthresh ||
					IN_FASTRECOVERY(tp)) {

					<span class="enscript-comment">/*
					 * If this connection was seeing packet
					 * reordering, then recovery might be
					 * delayed to disambiguate between
					 * reordering and loss
					 */</span>
					<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp; !IN_FASTRECOVERY(tp) &amp;&amp;
					    (tp-&gt;t_flagsext &amp; 
					    (TF_PKTS_REORDERED|TF_DELAY_RECOVERY)) ==
					    (TF_PKTS_REORDERED|TF_DELAY_RECOVERY)) {
						<span class="enscript-comment">/*
						 * Since the SACK information is already
						 * updated, this ACK will be dropped
						 */</span>
						<span class="enscript-keyword">break</span>;
					}

					<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) 
					    &amp;&amp; IN_FASTRECOVERY(tp)) {
						<span class="enscript-type">int</span> awnd;
						
						<span class="enscript-comment">/*
						 * Compute the amount of data in flight first.
						 * We can inject new data into the pipe iff 
						 * we have less than 1/2 the original window's 	
						 * worth of data in flight.
						 */</span>
						awnd = (tp-&gt;snd_nxt - tp-&gt;snd_fack) +
							tp-&gt;sackhint.sack_bytes_rexmit;
						<span class="enscript-keyword">if</span> (awnd &lt; tp-&gt;snd_ssthresh) {
							tp-&gt;snd_cwnd += tp-&gt;t_maxseg;
							<span class="enscript-keyword">if</span> (tp-&gt;snd_cwnd &gt; tp-&gt;snd_ssthresh)
								tp-&gt;snd_cwnd = tp-&gt;snd_ssthresh;
						}
					} <span class="enscript-keyword">else</span>
						tp-&gt;snd_cwnd += tp-&gt;t_maxseg;

					tcp_ccdbg_trace(tp, th, TCP_CC_IN_FASTRECOVERY);

					(<span class="enscript-type">void</span>) tcp_output(tp);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_dupacks == tp-&gt;t_rexmtthresh) {
					tcp_seq onxt = tp-&gt;snd_nxt;

					<span class="enscript-comment">/*
					 * If we're doing sack, check to
					 * see if we're already in sack
					 * recovery. If we're not doing sack,
					 * check to see if we're in newreno
					 * recovery.
					 */</span>
					<span class="enscript-keyword">if</span> (SACK_ENABLED(tp)) {
						<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp)) {
							tp-&gt;t_dupacks = 0;
							<span class="enscript-keyword">break</span>;
						} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_DELAY_RECOVERY) {
							<span class="enscript-keyword">break</span>;
						}
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">if</span> (SEQ_LEQ(th-&gt;th_ack,
						    tp-&gt;snd_recover)) {
							tp-&gt;t_dupacks = 0;
							<span class="enscript-keyword">break</span>;
						}
					}
					<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_SENTFIN)
						tp-&gt;snd_recover = tp-&gt;snd_max - 1;
					<span class="enscript-keyword">else</span>
						tp-&gt;snd_recover = tp-&gt;snd_max;
					tp-&gt;t_timer[TCPT_PTO] = 0;
					tp-&gt;t_rtttime = 0;

					<span class="enscript-comment">/*
					 * If the connection has seen pkt
					 * reordering, delay recovery until
					 * it is clear that the packet
					 * was lost.
					 */</span>
					<span class="enscript-keyword">if</span> (SACK_ENABLED(tp) &amp;&amp;
					    (tp-&gt;t_flagsext &amp;
					    (TF_PKTS_REORDERED|TF_DELAY_RECOVERY))
					    == TF_PKTS_REORDERED &amp;&amp;
					    !IN_FASTRECOVERY(tp) &amp;&amp;
					    tp-&gt;t_reorderwin &gt; 0 &amp;&amp;
					    (tp-&gt;t_state == TCPS_ESTABLISHED ||
					    tp-&gt;t_state == TCPS_FIN_WAIT_1)) {
						tp-&gt;t_timer[TCPT_DELAYFR] =
						    OFFSET_FROM_START(tp,
						    tp-&gt;t_reorderwin);
						tp-&gt;t_flagsext |= TF_DELAY_RECOVERY;
						tcpstat.tcps_delay_recovery++;
						tcp_ccdbg_trace(tp, th,
						    TCP_CC_DELAY_FASTRECOVERY);
						<span class="enscript-keyword">break</span>;
					}

					tcp_rexmt_save_state(tp);
					<span class="enscript-comment">/*
					 * If the current tcp cc module has 
					 * defined a hook for tasks to run
					 * before entering FR, call it
					 */</span>
					<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;pre_fr != NULL)
						CC_ALGO(tp)-&gt;pre_fr(tp);
					ENTER_FASTRECOVERY(tp);
					tp-&gt;t_timer[TCPT_REXMT] = 0;
					<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp))
						tp-&gt;ecn_flags |= TE_SENDCWR;

					<span class="enscript-keyword">if</span> (SACK_ENABLED(tp)) {
						tcpstat.tcps_sack_recovery_episode++;
						tp-&gt;sack_newdata = tp-&gt;snd_nxt;
						tp-&gt;snd_cwnd = tp-&gt;t_maxseg;
						tp-&gt;t_flagsext &amp;=
						    ~TF_CWND_NONVALIDATED;
						tcp_ccdbg_trace(tp, th,
						    TCP_CC_ENTER_FASTRECOVERY);
						(<span class="enscript-type">void</span>) tcp_output(tp);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
					}
					tp-&gt;snd_nxt = th-&gt;th_ack;
					tp-&gt;snd_cwnd = tp-&gt;t_maxseg;
					(<span class="enscript-type">void</span>) tcp_output(tp);
					<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_CWND_NONVALIDATED) {
						tcp_cc_adjust_nonvalidated_cwnd(tp);
					} <span class="enscript-keyword">else</span> {
						tp-&gt;snd_cwnd = tp-&gt;snd_ssthresh +
						     tp-&gt;t_maxseg * tp-&gt;t_dupacks;
					}
					<span class="enscript-keyword">if</span> (SEQ_GT(onxt, tp-&gt;snd_nxt))
						tp-&gt;snd_nxt = onxt;
					tcp_ccdbg_trace(tp, th,
					    TCP_CC_ENTER_FASTRECOVERY);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (limited_txmt &amp;&amp; 
					ALLOW_LIMITED_TRANSMIT(tp) &amp;&amp;
					(!(SACK_ENABLED(tp)) || sack_bytes_acked &gt; 0) &amp;&amp; 
					(so-&gt;so_snd.sb_cc - (tp-&gt;snd_max - tp-&gt;snd_una)) &gt; 0) {
					u_int32_t incr = (tp-&gt;t_maxseg * tp-&gt;t_dupacks);

					<span class="enscript-comment">/* Use Limited Transmit algorithm on the first two
					 * duplicate acks when there is new data to transmit
					 */</span>
					tp-&gt;snd_cwnd += incr;
					tcpstat.tcps_limited_txt++;
					(<span class="enscript-type">void</span>) tcp_output(tp);

					tcp_ccdbg_trace(tp, th, TCP_CC_LIMITED_TRANSMIT);
					
					<span class="enscript-comment">/* Reset snd_cwnd back to normal */</span>
					tp-&gt;snd_cwnd -= incr;
				}
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_dupacks = 0;
				tp-&gt;t_rexmtthresh = tcprexmtthresh;
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * If the congestion window was inflated to account
		 * for the other side's cached packets, retract it.
		 */</span>
		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp)) {
			<span class="enscript-keyword">if</span> (SEQ_LT(th-&gt;th_ack, tp-&gt;snd_recover)) {
				<span class="enscript-comment">/*
				 * If we received an ECE and entered 
				 * recovery, the subsequent ACKs should
				 * not be treated as partial acks.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_INRECOVERY)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">process_ACK</span>;

				<span class="enscript-keyword">if</span> (SACK_ENABLED(tp))
					tcp_sack_partialack(tp, th);
				<span class="enscript-keyword">else</span>
					tcp_newreno_partial_ack(tp, th);			
				tcp_ccdbg_trace(tp, th, TCP_CC_PARTIAL_ACK);
			} <span class="enscript-keyword">else</span> {
				EXIT_FASTRECOVERY(tp);
				<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;post_fr != NULL)
					CC_ALGO(tp)-&gt;post_fr(tp, th);
				tp-&gt;t_pipeack = 0;
				tcp_clear_pipeack_state(tp);
				tcp_ccdbg_trace(tp, th,
				    TCP_CC_EXIT_FASTRECOVERY);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; 
			(TF_PKTS_REORDERED|TF_DELAY_RECOVERY))
			== (TF_PKTS_REORDERED|TF_DELAY_RECOVERY)) {
			<span class="enscript-comment">/*
			 * If the ack acknowledges upto snd_recover or if
			 * it acknowledges all the snd holes, exit
			 * recovery and cancel the timer. Otherwise,
			 * this is a partial ack. Wait for recovery timer
			 * to enter recovery. The snd_holes have already
			 * been updated.
			 */</span>
			<span class="enscript-keyword">if</span> (SEQ_GEQ(th-&gt;th_ack, tp-&gt;snd_recover) ||
			    TAILQ_EMPTY(&amp;tp-&gt;snd_holes)) {
				tp-&gt;t_timer[TCPT_DELAYFR] = 0;
				tp-&gt;t_flagsext &amp;= ~TF_DELAY_RECOVERY;
				EXIT_FASTRECOVERY(tp);
				tcp_ccdbg_trace(tp, th,
				    TCP_CC_EXIT_FASTRECOVERY);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We were not in fast recovery. Reset the
			 * duplicate ack counter.
			 */</span>
			tp-&gt;t_dupacks = 0;
			tp-&gt;t_rexmtthresh = tcprexmtthresh;
		}


		<span class="enscript-comment">/*
		 * If we reach this point, ACK is not a duplicate,
		 *     i.e., it ACKs something we sent.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_NEEDSYN) {
			<span class="enscript-comment">/*
			 * T/TCP: Connection was half-synchronized, and our
			 * SYN has been ACK'd (so connection is now fully
			 * synchronized).  Go to non-starred state,
			 * increment snd_una for ACK of SYN, and check if
			 * we can do window scaling.
			 */</span>
			tp-&gt;t_flags &amp;= ~TF_NEEDSYN;
			tp-&gt;snd_una++;
			<span class="enscript-comment">/* Do window scaling? */</span>
			<span class="enscript-keyword">if</span> (TCP_WINDOW_SCALE_ENABLED(tp)) {
				tp-&gt;snd_scale = tp-&gt;requested_s_scale;
				tp-&gt;rcv_scale = tp-&gt;request_r_scale;
			}
		}

<span class="enscript-reference">process_ACK</span>:
		VERIFY(SEQ_GEQ(th-&gt;th_ack, tp-&gt;snd_una));
		acked = BYTES_ACKED(th, tp);
		tcpstat.tcps_rcvackpack++;
		tcpstat.tcps_rcvackbyte += acked;

		<span class="enscript-comment">/*
		 * If the last packet was a retransmit, make sure
		 * it was not spurious.
		 *
		 * This will also take care of congestion window
		 * adjustment if a last packet was recovered due to a
		 * tail loss probe.
		 */</span>
		tcp_bad_rexmt_check(tp, th, &amp;to);

		<span class="enscript-comment">/* Recalculate the RTT */</span>
		tcp_compute_rtt(tp, &amp;to, th);

		<span class="enscript-comment">/*
		 * If all outstanding data is acked, stop retransmit
		 * timer and remember to restart (more output or persist).
		 * If there is more data to be acked, restart retransmit
		 * timer, using current (possibly backed-off) value.
		 */</span>
		<span class="enscript-keyword">if</span> (th-&gt;th_ack == tp-&gt;snd_max) {
			tp-&gt;t_timer[TCPT_REXMT] = 0;
			tp-&gt;t_timer[TCPT_PTO] = 0;
			needoutput = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_timer[TCPT_PERSIST] == 0)
			tp-&gt;t_timer[TCPT_REXMT] = OFFSET_FROM_START(tp,
			    tp-&gt;t_rxtcur);

		<span class="enscript-comment">/*
		 * If no data (only SYN) was ACK'd, skip rest of ACK
		 * processing.
		 */</span>
		<span class="enscript-keyword">if</span> (acked == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">step6</span>;

		<span class="enscript-comment">/*
		 * When outgoing data has been acked (except the SYN+data), we
		 * mark this connection as &quot;sending good&quot; for TFO.
		 */</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_SENT) &amp;&amp;
		    !(tp-&gt;t_tfo_flags &amp; TFO_F_NO_SNDPROBING) &amp;&amp;
		    !(th-&gt;th_flags &amp; TH_SYN))
			tcp_heuristic_tfo_snd_good(tp);

		<span class="enscript-comment">/*
		 * If TH_ECE is received, make sure that ECN is enabled
		 * on that connection and we have sent ECT on data packets.
		 */</span>
		<span class="enscript-keyword">if</span> ((thflags &amp; TH_ECE) != 0 &amp;&amp; TCP_ECN_ENABLED(tp) &amp;&amp;
		    (tp-&gt;ecn_flags &amp; TE_SENDIPECT)) {
			<span class="enscript-comment">/*
			 * Reduce the congestion window if we haven't
			 * done so.
			 */</span>
			<span class="enscript-keyword">if</span> (!IN_FASTRECOVERY(tp)) {
				tcp_reduce_congestion_window(tp);
				tp-&gt;ecn_flags |= (TE_INRECOVERY|TE_SENDCWR);
				<span class="enscript-comment">/*
				 * Also note that the connection received
				 * ECE atleast once
				 */</span>
				tp-&gt;ecn_flags |= TE_RECV_ECN_ECE;
				tcpstat.tcps_ecn_recv_ece++;
				tcp_ccdbg_trace(tp, th, TCP_CC_ECN_RCVD);
			}
		}

		<span class="enscript-comment">/*
		 * When new data is acked, open the congestion window.
		 * The specifics of how this is achieved are up to the
		 * congestion control algorithm in use for this connection.
		 *
		 * The calculations in this function assume that snd_una is
		 * not updated yet.
		 */</span>
		<span class="enscript-keyword">if</span> (!IN_FASTRECOVERY(tp)) {
			<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;ack_rcvd != NULL)
				CC_ALGO(tp)-&gt;ack_rcvd(tp, th);
			tcp_ccdbg_trace(tp, th, TCP_CC_ACK_RCVD);
		}
		<span class="enscript-keyword">if</span> (acked &gt; so-&gt;so_snd.sb_cc) {
			tp-&gt;snd_wnd -= so-&gt;so_snd.sb_cc;
			sbdrop(&amp;so-&gt;so_snd, (<span class="enscript-type">int</span>)so-&gt;so_snd.sb_cc);
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
				so-&gt;so_msg_state-&gt;msg_serial_bytes -= 
					(<span class="enscript-type">int</span>)so-&gt;so_snd.sb_cc;
			}
			ourfinisacked = 1;
		} <span class="enscript-keyword">else</span> {
			sbdrop(&amp;so-&gt;so_snd, acked);
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
				so-&gt;so_msg_state-&gt;msg_serial_bytes -= 
					acked;
			}
			tcp_sbsnd_trim(&amp;so-&gt;so_snd);
			tp-&gt;snd_wnd -= acked;
			ourfinisacked = 0;
		}
		<span class="enscript-comment">/* detect una wraparound */</span>
		<span class="enscript-keyword">if</span> ( !IN_FASTRECOVERY(tp) &amp;&amp;
		    SEQ_GT(tp-&gt;snd_una, tp-&gt;snd_recover) &amp;&amp;
		    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_recover))
			tp-&gt;snd_recover = th-&gt;th_ack - 1;

		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp) &amp;&amp;
		    SEQ_GEQ(th-&gt;th_ack, tp-&gt;snd_recover))
			EXIT_FASTRECOVERY(tp);

		tp-&gt;snd_una = th-&gt;th_ack;
		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp)) {
			<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;snd_una, tp-&gt;snd_recover))
				tp-&gt;snd_recover = tp-&gt;snd_una;
		}
		<span class="enscript-keyword">if</span> (SEQ_LT(tp-&gt;snd_nxt, tp-&gt;snd_una))
			tp-&gt;snd_nxt = tp-&gt;snd_una;
		<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments) &amp;&amp;
		    !TCP_DSACK_SEQ_IN_WINDOW(tp, tp-&gt;t_dsack_lastuna,
		    tp-&gt;snd_una))
			tcp_rxtseg_clean(tp);
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) != 0 &amp;&amp;
			tp-&gt;t_bwmeas != NULL)
			tcp_bwmeas_check(tp);

		<span class="enscript-comment">/*
		 * sowwakeup must happen after snd_una, et al. are updated so that
		 * the sequence numbers are in sync with so_snd
		 */</span>
		sowwakeup(so);

		<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

		<span class="enscript-comment">/*
		 * In FIN_WAIT_1 STATE in addition to the processing
		 * for the ESTABLISHED state if our FIN is now acknowledged
		 * then enter FIN_WAIT_2.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_1</span>:
			<span class="enscript-keyword">if</span> (ourfinisacked) {
				<span class="enscript-comment">/*
				 * If we can't receive any more
				 * data, then closing user can proceed.
				 * Starting the TCPT_2MSL timer is contrary to the
				 * specification, but if we don't get a FIN
				 * we'll hang forever.
				 */</span>
				<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE) {
					tp-&gt;t_timer[TCPT_2MSL] = OFFSET_FROM_START(tp,
						TCP_CONN_MAXIDLE(tp));
					isconnected = FALSE;
					isdisconnected = TRUE;
				}
				DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, 
					<span class="enscript-type">struct</span> inpcb *, inp,
					<span class="enscript-type">struct</span> tcpcb *, tp, 
					int32_t, TCPS_FIN_WAIT_2);
				tp-&gt;t_state = TCPS_FIN_WAIT_2;
				<span class="enscript-comment">/* fall through and make sure we also recognize 
				 * data ACKed with the FIN 
				 */</span>
			}
			tp-&gt;t_flags |= TF_ACKNOW;
			<span class="enscript-keyword">break</span>;

	 	<span class="enscript-comment">/*
		 * In CLOSING STATE in addition to the processing for
		 * the ESTABLISHED state if the ACK acknowledges our FIN
		 * then enter the TIME-WAIT state, otherwise ignore
		 * the segment.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSING</span>:
			<span class="enscript-keyword">if</span> (ourfinisacked) {
				DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, 
					<span class="enscript-type">struct</span> inpcb *, inp,
					<span class="enscript-type">struct</span> tcpcb *, tp, 
					int32_t, TCPS_TIME_WAIT);
				tp-&gt;t_state = TCPS_TIME_WAIT;
				tcp_canceltimers(tp);
				<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_NOTIMEWAIT) {
					tp-&gt;t_flags |= TF_CLOSING;
				} <span class="enscript-keyword">else</span> {
					add_to_time_wait(tp, 2 * tcp_msl);
				}
				isconnected = FALSE;
				isdisconnected = TRUE;
			}
			tp-&gt;t_flags |= TF_ACKNOW;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * In LAST_ACK, we may still be waiting for data to drain
		 * and/or to be acked, as well as for the ack of our FIN.
		 * If our FIN is now acknowledged, delete the TCB,
		 * enter the closed state and return.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LAST_ACK</span>:
			<span class="enscript-keyword">if</span> (ourfinisacked) {
				tp = tcp_close(tp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * In TIME_WAIT state the only thing that should arrive
		 * is a retransmission of the remote FIN.  Acknowledge
		 * it and restart the finack timer.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
			add_to_time_wait(tp, 2 * tcp_msl);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropafterack</span>;
		}

		<span class="enscript-comment">/*
		 * If there is a SACK option on the ACK and we 
		 * haven't seen any duplicate acks before, count
		 * it as a duplicate ack even if the cumulative
		 * ack is advanced. If the receiver delayed an
		 * ack and detected loss afterwards, then the ack
		 * will advance cumulative ack and will also have 
		 * a SACK option. So counting it as one duplicate
		 * ack is ok.
		 */</span> 
		<span class="enscript-keyword">if</span> (sack_ackadv == 1 &amp;&amp;
		    tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp; 
		    SACK_ENABLED(tp) &amp;&amp; sack_bytes_acked &gt; 0 &amp;&amp; 
		    to.to_nsacks &gt; 0 &amp;&amp; tp-&gt;t_dupacks == 0 &amp;&amp;
		    SEQ_LEQ(th-&gt;th_ack, tp-&gt;snd_una) &amp;&amp; tlen == 0 &amp;&amp;
		    !(tp-&gt;t_flagsext &amp; TF_PKTS_REORDERED)) {
			tcpstat.tcps_sack_ackadv++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">process_dupack</span>;
		}
	}

<span class="enscript-reference">step6</span>:
	<span class="enscript-comment">/*
	 * Update window information.
	 * Don't look at window if no ACK: TAC's send garbage on first SYN.
	 */</span>
	<span class="enscript-keyword">if</span> ((thflags &amp; TH_ACK) &amp;&amp;
	    (SEQ_LT(tp-&gt;snd_wl1, th-&gt;th_seq) ||
	    (tp-&gt;snd_wl1 == th-&gt;th_seq &amp;&amp; (SEQ_LT(tp-&gt;snd_wl2, th-&gt;th_ack) ||
	     (tp-&gt;snd_wl2 == th-&gt;th_ack &amp;&amp; tiwin &gt; tp-&gt;snd_wnd))))) {
		<span class="enscript-comment">/* keep track of pure window updates */</span>
		<span class="enscript-keyword">if</span> (tlen == 0 &amp;&amp;
		    tp-&gt;snd_wl2 == th-&gt;th_ack &amp;&amp; tiwin &gt; tp-&gt;snd_wnd)
			tcpstat.tcps_rcvwinupd++;
		tp-&gt;snd_wnd = tiwin;
		tp-&gt;snd_wl1 = th-&gt;th_seq;
		tp-&gt;snd_wl2 = th-&gt;th_ack;
		<span class="enscript-keyword">if</span> (tp-&gt;snd_wnd &gt; tp-&gt;max_sndwnd)
			tp-&gt;max_sndwnd = tp-&gt;snd_wnd;
		needoutput = 1;
	}

	<span class="enscript-comment">/*
	 * Process segments with URG.
	 */</span>
	<span class="enscript-keyword">if</span> ((thflags &amp; TH_URG) &amp;&amp; th-&gt;th_urp &amp;&amp;
	    TCPS_HAVERCVDFIN(tp-&gt;t_state) == 0) {
		<span class="enscript-comment">/*
		 * This is a kludge, but if we receive and accept
		 * random urgent pointers, we'll crash in
		 * soreceive.  It's hard to imagine someone
		 * actually wanting to send this much urgent data.
		 */</span>
		<span class="enscript-keyword">if</span> (th-&gt;th_urp + so-&gt;so_rcv.sb_cc &gt; sb_max) {
			th-&gt;th_urp = 0;			<span class="enscript-comment">/* XXX */</span>
			thflags &amp;= ~TH_URG;		<span class="enscript-comment">/* XXX */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dodata</span>;			<span class="enscript-comment">/* XXX */</span>
		}
		<span class="enscript-comment">/*
		 * If this segment advances the known urgent pointer,
		 * then mark the data stream.  This should not happen
		 * in CLOSE_WAIT, CLOSING, LAST_ACK or TIME_WAIT STATES since
		 * a FIN has been received from the remote side.
		 * In these states we ignore the URG.
		 *
		 * According to RFC961 (Assigned Protocols),
		 * the urgent pointer points to the last octet
		 * of urgent data.  We continue, however,
		 * to consider it to indicate the first octet
		 * of data past the urgent section as the original
		 * spec states (in one of two places).
		 */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(th-&gt;th_seq+th-&gt;th_urp, tp-&gt;rcv_up)) {
			tp-&gt;rcv_up = th-&gt;th_seq + th-&gt;th_urp;
			so-&gt;so_oobmark = so-&gt;so_rcv.sb_cc +
			    (tp-&gt;rcv_up - tp-&gt;rcv_nxt) - 1;
			<span class="enscript-keyword">if</span> (so-&gt;so_oobmark == 0) {
				so-&gt;so_state |= SS_RCVATMARK;
				postevent(so, 0, EV_OOB);
			}
			sohasoutofband(so);
			tp-&gt;t_oobflags &amp;= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
		}
		<span class="enscript-comment">/*
		 * Remove out of band data so doesn't get presented to user.
		 * This can happen independent of advancing the URG pointer,
		 * but if two URG's are pending at once, some out-of-band
		 * data may creep in... ick.
		 */</span>
		<span class="enscript-keyword">if</span> (th-&gt;th_urp &lt;= (u_int32_t)tlen
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SO_OOBINLINE</span>
		     &amp;&amp; (so-&gt;so_options &amp; SO_OOBINLINE) == 0
#<span class="enscript-reference">endif</span>
		     )
			tcp_pulloutofband(so, th, m,
				drop_hdrlen);	<span class="enscript-comment">/* hdr drop is delayed */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If no out of band data is expected,
		 * pull receive urgent pointer along
		 * with the receive window.
		 */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(tp-&gt;rcv_nxt, tp-&gt;rcv_up))
			tp-&gt;rcv_up = tp-&gt;rcv_nxt;
	}
<span class="enscript-reference">dodata</span>:

	<span class="enscript-comment">/* Set socket's connect or disconnect state correcly before doing data.
	 * The following might unlock the socket if there is an upcall or a socket
	 * filter.
	 */</span>
	<span class="enscript-keyword">if</span> (isconnected) {
		soisconnected(so);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (isdisconnected) {
		soisdisconnected(so);
	}

	<span class="enscript-comment">/* Let's check the state of pcb just to make sure that it did not get closed 
	 * when we unlocked above
	 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD) {
		<span class="enscript-comment">/* Just drop the packet that we are processing and return */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	}
	
	<span class="enscript-comment">/*
	 * Process the segment text, merging it into the TCP sequencing queue,
	 * and arranging for acknowledgment of receipt if necessary.
	 * This process logically involves adjusting tp-&gt;rcv_wnd as data
	 * is presented to the user (this happens in tcp_usrreq.c,
	 * case PRU_RCVD).  If a FIN has already been received on this
	 * connection then we just ignore the text.
	 *
	 * If we are in SYN-received state and got a valid TFO cookie, we want
	 * to process the data.
	 */</span>
	<span class="enscript-keyword">if</span> ((tlen || (thflags &amp; TH_FIN)) &amp;&amp;
	    TCPS_HAVERCVDFIN(tp-&gt;t_state) == 0 &amp;&amp;
	    (TCPS_HAVEESTABLISHED(tp-&gt;t_state) ||
	     (tp-&gt;t_state == TCPS_SYN_RECEIVED &amp;&amp;
	     (tp-&gt;t_tfo_flags &amp; TFO_F_COOKIE_VALID)))) {
		tcp_seq save_start = th-&gt;th_seq;
		tcp_seq save_end = th-&gt;th_seq + tlen;
		m_adj(m, drop_hdrlen);	<span class="enscript-comment">/* delayed header drop */</span>
		<span class="enscript-comment">/*
		 * Insert segment which includes th into TCP reassembly queue
		 * with control block tp.  Set thflags to whether reassembly now
		 * includes a segment with FIN.  This handles the common case
		 * inline (segment is the next to be received on an established
		 * connection, and the queue is empty), avoiding linkage into
		 * and removal from the queue and repetition of various
		 * conversions.
		 * Set DELACK for segments received in order, but ack
		 * immediately when segments are out of order (so
		 * fast retransmit can work).
		 */</span>
		<span class="enscript-keyword">if</span> (th-&gt;th_seq == tp-&gt;rcv_nxt &amp;&amp; LIST_EMPTY(&amp;tp-&gt;t_segq)) {
			TCP_INC_VAR(tp-&gt;t_unacksegs, nlropkts);
			<span class="enscript-comment">/*
			 * Calculate the RTT on the receiver only if the 
			 * connection is in streaming mode and the last 
			 * packet was not an end-of-write
			 */</span>
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_STRETCHACK) &amp;&amp;
				!(tp-&gt;t_flagsext &amp; TF_STREAMEOW))
				tcp_compute_rtt(tp, &amp;to, th);
			
			<span class="enscript-keyword">if</span> (DELAY_ACK(tp, th) &amp;&amp; 
				((tp-&gt;t_flags &amp; TF_ACKNOW) == 0) ) {
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_DELACK) == 0) {
					tp-&gt;t_flags |= TF_DELACK;
					tp-&gt;t_timer[TCPT_DELACK] = 
						OFFSET_FROM_START(tp, tcp_delack);
				}
			}         
			<span class="enscript-keyword">else</span> {
				tp-&gt;t_flags |= TF_ACKNOW;
			}
			tp-&gt;rcv_nxt += tlen;
			thflags = th-&gt;th_flags &amp; TH_FIN;
			TCP_INC_VAR(tcpstat.tcps_rcvpack, nlropkts);
			tcpstat.tcps_rcvbyte += tlen;
			<span class="enscript-keyword">if</span> (nstat_collect) {
				<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_PKT) {
					INP_ADD_STAT(inp, cell, wifi, wired, 
					    rxpackets, m-&gt;m_pkthdr.lro_npkts);
				} <span class="enscript-keyword">else</span> {
					INP_ADD_STAT(inp, cell, wifi, wired,
					    rxpackets, 1);
				}
				INP_ADD_STAT(inp, cell, wifi, wired,
				    rxbytes, tlen);
			}
			tcp_sbrcv_grow(tp, &amp;so-&gt;so_rcv, &amp;to, tlen);
			so_recv_data_stat(so, m, drop_hdrlen);
			
			<span class="enscript-keyword">if</span> (sbappendstream_rcvdemux(so, m,
			    th-&gt;th_seq - (tp-&gt;irs + 1), 0)) {
				sorwakeup(so);
			}
		} <span class="enscript-keyword">else</span> {
			thflags = tcp_reass(tp, th, &amp;tlen, m, ifp);
			tp-&gt;t_flags |= TF_ACKNOW;
		}

		<span class="enscript-keyword">if</span> (tlen &gt; 0 &amp;&amp; SACK_ENABLED(tp))
			tcp_update_sack_list(tp, save_start, save_end);

		tcp_adaptive_rwtimo_check(tp, tlen);

		<span class="enscript-keyword">if</span> (tlen &gt; 0)
			tcp_tfo_rcv_data(tp);

		<span class="enscript-keyword">if</span> (tp-&gt;t_flags &amp; TF_DELACK) 
		{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6) {
				KERNEL_DEBUG(DBG_LAYER_END, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		     			(((ip6-&gt;ip6_src.s6_addr16[0]) &lt;&lt; 16) | (ip6-&gt;ip6_dst.s6_addr16[0])),
			     		th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win); 
			}
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			{
				KERNEL_DEBUG(DBG_LAYER_END, ((th-&gt;th_dport &lt;&lt; 16) | th-&gt;th_sport),
		     			(((ip-&gt;ip_src.s_addr &amp; 0xffff) &lt;&lt; 16) | (ip-&gt;ip_dst.s_addr &amp; 0xffff)),
			     		th-&gt;th_seq, th-&gt;th_ack, th-&gt;th_win); 
			}
				
		}
	} <span class="enscript-keyword">else</span> {
		m_freem(m);
		thflags &amp;= ~TH_FIN;
	}

	<span class="enscript-comment">/*
	 * If FIN is received ACK the FIN and let the user know
	 * that the connection is closing.
	 */</span>
	<span class="enscript-keyword">if</span> (thflags &amp; TH_FIN) {
		<span class="enscript-keyword">if</span> (TCPS_HAVERCVDFIN(tp-&gt;t_state) == 0) {
			socantrcvmore(so);
			postevent(so, 0, EV_FIN);
			<span class="enscript-comment">/*
			 * If connection is half-synchronized
			 * (ie NEEDSYN flag on) then delay ACK,
			 * so it may be piggybacked when SYN is sent.
			 * Otherwise, since we received a FIN then no
			 * more input can be expected, send ACK now.
			 */</span>
			TCP_INC_VAR(tp-&gt;t_unacksegs, nlropkts);
			<span class="enscript-keyword">if</span> (DELAY_ACK(tp, th) &amp;&amp; (tp-&gt;t_flags &amp; TF_NEEDSYN)) {
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_DELACK) == 0) {
					tp-&gt;t_flags |= TF_DELACK;
					tp-&gt;t_timer[TCPT_DELACK] = OFFSET_FROM_START(tp, tcp_delack);
				}
			}
			<span class="enscript-keyword">else</span> {
				tp-&gt;t_flags |= TF_ACKNOW;
			}
			tp-&gt;rcv_nxt++;
		}
		<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

	 	<span class="enscript-comment">/*
		 * In SYN_RECEIVED and ESTABLISHED STATES
		 * enter the CLOSE_WAIT state.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:
			tp-&gt;t_starttime = tcp_now;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
				<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_CLOSE_WAIT);
			tp-&gt;t_state = TCPS_CLOSE_WAIT;
			<span class="enscript-keyword">break</span>;

	 	<span class="enscript-comment">/*
		 * If still in FIN_WAIT_1 STATE FIN has not been acked so
		 * enter the CLOSING state.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_1</span>:
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
				<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_CLOSING);
			tp-&gt;t_state = TCPS_CLOSING;
			<span class="enscript-keyword">break</span>;

	 	<span class="enscript-comment">/*
		 * In FIN_WAIT_2 state enter the TIME_WAIT state,
		 * starting the time-wait timer, turning off the other
		 * standard timers.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_2</span>:
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, 
				<span class="enscript-type">struct</span> inpcb *, inp,
				<span class="enscript-type">struct</span> tcpcb *, tp, 
				int32_t, TCPS_TIME_WAIT);
			tp-&gt;t_state = TCPS_TIME_WAIT;
			tcp_canceltimers(tp);
			tp-&gt;t_flags |= TF_ACKNOW;
			<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_NOTIMEWAIT) {
				tp-&gt;t_flags |= TF_CLOSING;
			} <span class="enscript-keyword">else</span> {
				add_to_time_wait(tp, 2 * tcp_msl);
			}
			soisdisconnected(so);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * In TIME_WAIT state restart the 2 MSL time_wait timer.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
			add_to_time_wait(tp, 2 * tcp_msl);
			<span class="enscript-keyword">break</span>;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_DEBUG)
		tcp_trace(TA_INPUT, ostate, tp, (<span class="enscript-type">void</span> *)tcp_saveipgen,
			  &amp;tcp_savetcp, 0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Return any desired output.
	 */</span>
	<span class="enscript-keyword">if</span> (needoutput || (tp-&gt;t_flags &amp; TF_ACKNOW)) {
		(<span class="enscript-type">void</span>) tcp_output(tp);
	}

	tcp_check_timer_state(tp);

	
	tcp_unlock(so, 1, 0);
	KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">dropafterack</span>:
	<span class="enscript-comment">/*
	 * Generate an ACK dropping incoming segment if it occupies
	 * sequence space, where the ACK reflects our state.
	 *
	 * We can now skip the test for the RST flag since all
	 * paths to this code happen after packets containing
	 * RST have been dropped.
	 *
	 * In the SYN-RECEIVED state, don't send an ACK unless the
	 * segment we received passes the SYN-RECEIVED ACK test.
	 * If it fails send a RST.  This breaks the loop in the
	 * &quot;LAND&quot; DoS attack, and also prevents an ACK storm
	 * between two listening ports that have been sent forged
	 * SYN segments, each with the source address of the other.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_RECEIVED &amp;&amp; (thflags &amp; TH_ACK) &amp;&amp;
	    (SEQ_GT(tp-&gt;snd_una, th-&gt;th_ack) ||
	     SEQ_GT(th-&gt;th_ack, tp-&gt;snd_max)) ) {
		rstreason = BANDLIM_RST_OPENPORT;
		IF_TCP_STATINC(ifp, dospacket);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropwithreset</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_DEBUG)
		tcp_trace(TA_DROP, ostate, tp, (<span class="enscript-type">void</span> *)tcp_saveipgen,
			  &amp;tcp_savetcp, 0);
#<span class="enscript-reference">endif</span>
	m_freem(m);
	tp-&gt;t_flags |= TF_ACKNOW;
	(<span class="enscript-type">void</span>) tcp_output(tp);

	<span class="enscript-comment">/* Don't need to check timer state as we should have done it during tcp_output */</span>
	tcp_unlock(so, 1, 0);
	KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">dropwithresetnosock</span>:
	nosock = 1;
<span class="enscript-reference">dropwithreset</span>:
	<span class="enscript-comment">/*
	 * Generate a RST, dropping incoming segment.
	 * Make ACK acceptable to originator of segment.
	 * Don't bother to respond if destination was broadcast/multicast.
	 */</span>
	<span class="enscript-keyword">if</span> ((thflags &amp; TH_RST) || m-&gt;m_flags &amp; (M_BCAST|M_MCAST))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) ||
		    IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_src))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr)) ||
	    IN_MULTICAST(ntohl(ip-&gt;ip_src.s_addr)) ||
	    ip-&gt;ip_src.s_addr == htonl(INADDR_BROADCAST) ||
	    in_broadcast(ip-&gt;ip_dst, m-&gt;m_pkthdr.rcvif))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
	<span class="enscript-comment">/* IPv6 anycast check is done at tcp6_input() */</span>

	<span class="enscript-comment">/* 
	 * Perform bandwidth limiting.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ICMP_BANDLIM</span>
	<span class="enscript-keyword">if</span> (badport_bandlim(rstreason) &lt; 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (tp == 0 || (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_DEBUG))
		tcp_trace(TA_DROP, ostate, tp, (<span class="enscript-type">void</span> *)tcp_saveipgen,
			  &amp;tcp_savetcp, 0);
#<span class="enscript-reference">endif</span>
	bzero(&amp;tra, <span class="enscript-keyword">sizeof</span>(tra));
	tra.ifscope = ifscope;
	tra.awdl_unrestricted = 1;
	<span class="enscript-keyword">if</span> (thflags &amp; TH_ACK)
		<span class="enscript-comment">/* mtod() below is safe as long as hdr dropping is delayed */</span>
		tcp_respond(tp, mtod(m, <span class="enscript-type">void</span> *), th, m, (tcp_seq)0, th-&gt;th_ack,
		    TH_RST, &amp;tra);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (thflags &amp; TH_SYN)
			tlen++;
		<span class="enscript-comment">/* mtod() below is safe as long as hdr dropping is delayed */</span>
		tcp_respond(tp, mtod(m, <span class="enscript-type">void</span> *), th, m, th-&gt;th_seq+tlen,
		    (tcp_seq)0, TH_RST|TH_ACK, &amp;tra);
	}
	<span class="enscript-comment">/* destroy temporarily created socket */</span>
	<span class="enscript-keyword">if</span> (dropsocket) {
		(<span class="enscript-type">void</span>) soabort(so); 
		tcp_unlock(so, 1, 0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((inp != NULL) &amp;&amp; (nosock == 0)) {
		tcp_unlock(so, 1, 0);
	}
	KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">dropnosock</span>:
	nosock = 1;
<span class="enscript-reference">drop</span>:
	<span class="enscript-comment">/*
	 * Drop space held by incoming segment and return.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (tp == 0 || (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_DEBUG))
		tcp_trace(TA_DROP, ostate, tp, (<span class="enscript-type">void</span> *)tcp_saveipgen,
			  &amp;tcp_savetcp, 0);
#<span class="enscript-reference">endif</span>
	m_freem(m);
	<span class="enscript-comment">/* destroy temporarily created socket */</span>
	<span class="enscript-keyword">if</span> (dropsocket) {
		(<span class="enscript-type">void</span>) soabort(so); 
		tcp_unlock(so, 1, 0);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nosock == 0) {
		tcp_unlock(so, 1, 0);
	}
	KERNEL_DEBUG(DBG_FNC_TCP_INPUT | DBG_FUNC_END,0,0,0,0,0);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Parse TCP options and place in tcpopt.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_dooptions</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cp, <span class="enscript-type">int</span> cnt, <span class="enscript-type">struct</span> tcphdr *th,
    <span class="enscript-type">struct</span> tcpopt *to)
{
	u_short mss = 0;
	<span class="enscript-type">int</span> opt, optlen;

	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, cp += optlen) {
		opt = cp[0];
		<span class="enscript-keyword">if</span> (opt == TCPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == TCPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cnt &lt; 2)
				<span class="enscript-keyword">break</span>;
			optlen = cp[1];
			<span class="enscript-keyword">if</span> (optlen &lt; 2 || optlen &gt; cnt)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">switch</span> (opt) {

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_MAXSEG</span>:
			<span class="enscript-keyword">if</span> (optlen != TCPOLEN_MAXSEG)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!(th-&gt;th_flags &amp; TH_SYN))
				<span class="enscript-keyword">continue</span>;
			bcopy((<span class="enscript-type">char</span> *) cp + 2, (<span class="enscript-type">char</span> *) &amp;mss, <span class="enscript-keyword">sizeof</span>(mss));
			NTOHS(mss);
			to-&gt;to_mss = mss;
			to-&gt;to_flags |= TOF_MSS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_WINDOW</span>:
			<span class="enscript-keyword">if</span> (optlen != TCPOLEN_WINDOW)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!(th-&gt;th_flags &amp; TH_SYN))
				<span class="enscript-keyword">continue</span>;
			to-&gt;to_flags |= TOF_SCALE;
			to-&gt;to_requested_s_scale = min(cp[2], TCP_MAX_WINSHIFT);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_TIMESTAMP</span>:
			<span class="enscript-keyword">if</span> (optlen != TCPOLEN_TIMESTAMP)
				<span class="enscript-keyword">continue</span>;
			to-&gt;to_flags |= TOF_TS;
			bcopy((<span class="enscript-type">char</span> *)cp + 2,
			    (<span class="enscript-type">char</span> *)&amp;to-&gt;to_tsval, <span class="enscript-keyword">sizeof</span>(to-&gt;to_tsval));
			NTOHL(to-&gt;to_tsval);
			bcopy((<span class="enscript-type">char</span> *)cp + 6,
			    (<span class="enscript-type">char</span> *)&amp;to-&gt;to_tsecr, <span class="enscript-keyword">sizeof</span>(to-&gt;to_tsecr));
			NTOHL(to-&gt;to_tsecr);
			<span class="enscript-comment">/* Re-enable sending Timestamps if we received them */</span>
			<span class="enscript-keyword">if</span> (!(tp-&gt;t_flags &amp; TF_REQ_TSTMP) &amp;&amp;
			    tcp_do_rfc1323 == 1)
				tp-&gt;t_flags |= TF_REQ_TSTMP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_SACK_PERMITTED</span>:
			<span class="enscript-keyword">if</span> (!tcp_do_sack ||
			    optlen != TCPOLEN_SACK_PERMITTED)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (th-&gt;th_flags &amp; TH_SYN)
				to-&gt;to_flags |= TOF_SACK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_SACK</span>:
			<span class="enscript-keyword">if</span> (optlen &lt;= 2 || (optlen - 2) % TCPOLEN_SACK != 0)
				<span class="enscript-keyword">continue</span>;
			to-&gt;to_nsacks = (optlen - 2) / TCPOLEN_SACK;
			to-&gt;to_sacks = cp + 2;
			tcpstat.tcps_sack_rcv_blocks++;

			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_FASTOPEN</span>:
			<span class="enscript-keyword">if</span> (optlen == TCPOLEN_FASTOPEN_REQ) {
				<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_LISTEN)
					<span class="enscript-keyword">continue</span>;

				to-&gt;to_flags |= TOF_TFOREQ;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (optlen &lt; TCPOLEN_FASTOPEN_REQ ||
				    (optlen - TCPOLEN_FASTOPEN_REQ) &gt; TFO_COOKIE_LEN_MAX ||
				    (optlen - TCPOLEN_FASTOPEN_REQ) &lt; TFO_COOKIE_LEN_MIN)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_LISTEN &amp;&amp;
				    tp-&gt;t_state != TCPS_SYN_SENT)
					<span class="enscript-keyword">continue</span>;

				to-&gt;to_flags |= TOF_TFO;
				to-&gt;to_tfo = cp + 1;
			}

			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPOPT_MULTIPATH</span>:
			tcp_do_mptcp_options(tp, cp, th, to, optlen);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_finalize_options</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcpopt *to, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">if</span> (to-&gt;to_flags &amp; TOF_TS) {
		tp-&gt;t_flags |= TF_RCVD_TSTMP;
		tp-&gt;ts_recent = to-&gt;to_tsval;
		tp-&gt;ts_recent_age = tcp_now;

	}
	<span class="enscript-keyword">if</span> (to-&gt;to_flags &amp; TOF_MSS)
		tcp_mss(tp, to-&gt;to_mss, ifscope);
	<span class="enscript-keyword">if</span> (SACK_ENABLED(tp)) {
		<span class="enscript-keyword">if</span> (!(to-&gt;to_flags &amp; TOF_SACK))
			tp-&gt;t_flagsext &amp;= ~(TF_SACK_ENABLE);
		<span class="enscript-keyword">else</span>
			tp-&gt;t_flags |= TF_SACK_PERMIT;
	}
	<span class="enscript-keyword">if</span> (to-&gt;to_flags &amp; TOF_SCALE) {
		tp-&gt;t_flags |= TF_RCVD_SCALE;
		tp-&gt;requested_s_scale = to-&gt;to_requested_s_scale;

		<span class="enscript-comment">/* Re-enable window scaling, if the option is received */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;request_r_scale &gt; 0)
			tp-&gt;t_flags |= TF_REQ_SCALE;
	}
}

<span class="enscript-comment">/*
 * Pull out of band byte out of a segment so
 * it doesn't appear in the user's data queue.
 * It is still reflected in the segment length for
 * sequencing purposes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_pulloutofband</span>(so, th, m, off)
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> tcphdr *th;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off;		<span class="enscript-comment">/* delayed to be droped hdrlen */</span>
{
	<span class="enscript-type">int</span> cnt = off + th-&gt;th_urp - 1;

	<span class="enscript-keyword">while</span> (cnt &gt;= 0) {
		<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; cnt) {
			<span class="enscript-type">char</span> *cp = mtod(m, caddr_t) + cnt;
			<span class="enscript-type">struct</span> tcpcb *tp = sototcpcb(so);

			tp-&gt;t_iobc = *cp;
			tp-&gt;t_oobflags |= TCPOOB_HAVEDATA;
			bcopy(cp+1, cp, (<span class="enscript-type">unsigned</span>)(m-&gt;m_len - cnt - 1));
			m-&gt;m_len--;
			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
				m-&gt;m_pkthdr.len--;
			<span class="enscript-keyword">return</span>;
		}
		cnt -= m-&gt;m_len;
		m = m-&gt;m_next;
		<span class="enscript-keyword">if</span> (m == 0)
			<span class="enscript-keyword">break</span>;
	}
	panic(<span class="enscript-string">&quot;tcp_pulloutofband&quot;</span>);
}

uint32_t
<span class="enscript-function-name">get_base_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp) 
{
	uint32_t base_rtt = 0, i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; N_RTT_BASE; ++i) {
		<span class="enscript-keyword">if</span> (tp-&gt;rtt_hist[i] != 0 &amp;&amp;
			(base_rtt == 0 || tp-&gt;rtt_hist[i] &lt; base_rtt))
			base_rtt = tp-&gt;rtt_hist[i];
	}
	<span class="enscript-keyword">return</span> base_rtt;
}

<span class="enscript-comment">/* Each value of RTT base represents the minimum RTT seen in a minute.
 * We keep upto N_RTT_BASE minutes worth of history.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">update_base_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t rtt)
{
	int32_t i, qdelay;
	u_int32_t base_rtt;

	<span class="enscript-keyword">if</span> (++tp-&gt;rtt_count &gt;= rtt_samples_per_slot) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
		<span class="enscript-comment">/*
		 * If the recv side is being throttled, check if the 
		 * current RTT is closer to the base RTT seen in 
		 * first (recent) two slots. If so, unthrottle the stream.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_RECV_THROTTLE) {
			base_rtt = min(tp-&gt;rtt_hist[0], tp-&gt;rtt_hist[1]);
			qdelay = tp-&gt;t_rttcur - base_rtt;
			<span class="enscript-keyword">if</span> (qdelay &lt; target_qdelay)
				tp-&gt;t_flagsext &amp;= ~(TF_RECV_THROTTLE);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

		<span class="enscript-keyword">for</span> (i = (N_RTT_BASE-1); i &gt; 0; --i) {
			tp-&gt;rtt_hist[i] = tp-&gt;rtt_hist[i-1];
		}
		tp-&gt;rtt_hist[0] = rtt;
		tp-&gt;rtt_count = 0;
	} <span class="enscript-keyword">else</span> {
		tp-&gt;rtt_hist[0] = min(tp-&gt;rtt_hist[0], rtt);
	}
}

<span class="enscript-comment">/*
 * If we have a timestamp reply, update smoothed RTT. If no timestamp is
 * present but transmit timer is running and timed sequence number was 
 * acked, update smoothed RTT. 
 *
 * If timestamps are supported, a receiver can update RTT even if
 * there is no outstanding data.
 *
 * Some boxes send broken timestamp replies during the SYN+ACK phase,
 * ignore timestamps of 0or we could calculate a huge RTT and blow up 
 * the retransmit timer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_compute_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcpopt *to, <span class="enscript-type">struct</span> tcphdr *th)
{
	<span class="enscript-type">int</span> rtt = 0;
	VERIFY(to != NULL &amp;&amp; th != NULL);
	<span class="enscript-keyword">if</span> (tp-&gt;t_rtttime != 0 &amp;&amp; SEQ_GT(th-&gt;th_ack, tp-&gt;t_rtseq)) {
		u_int32_t pipe_ack_val;
		rtt = tcp_now - tp-&gt;t_rtttime;
		<span class="enscript-comment">/*
		 * Compute pipe ack -- the amount of data acknowledged
		 * in the last RTT
		 */</span>
		<span class="enscript-keyword">if</span> (SEQ_GT(th-&gt;th_ack, tp-&gt;t_pipeack_lastuna)) {
			pipe_ack_val = th-&gt;th_ack - tp-&gt;t_pipeack_lastuna;
			<span class="enscript-comment">/* Update the sample */</span>
			tp-&gt;t_pipeack_sample[tp-&gt;t_pipeack_ind++] =
			    pipe_ack_val;
			tp-&gt;t_pipeack_ind %= TCP_PIPEACK_SAMPLE_COUNT;

			<span class="enscript-comment">/* Compute the max of the pipeack samples */</span>
			pipe_ack_val = tcp_get_max_pipeack(tp);
			tp-&gt;t_pipeack = (pipe_ack_val &gt;
				    TCP_CC_CWND_INIT_BYTES) ?
				    pipe_ack_val : 0;
		}
		<span class="enscript-comment">/* start another measurement */</span>
		tp-&gt;t_rtttime = 0;
	}
	<span class="enscript-keyword">if</span> (((to-&gt;to_flags &amp; TOF_TS) != 0) &amp;&amp; 
		(to-&gt;to_tsecr != 0) &amp;&amp;
		TSTMP_GEQ(tcp_now, to-&gt;to_tsecr)) {
		tcp_xmit_timer(tp, (tcp_now - to-&gt;to_tsecr),
			to-&gt;to_tsecr, th-&gt;th_ack);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rtt &gt; 0) {
		tcp_xmit_timer(tp, rtt, 0, th-&gt;th_ack);
	}
}

<span class="enscript-comment">/*
 * Collect new round-trip time estimate
 * and update averages and current timeout.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_xmit_timer</span>(<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> rtt, 
	u_int32_t tsecr, tcp_seq th_ack)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> delta;

	<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_RECOMPUTE_RTT) {
		<span class="enscript-keyword">if</span> (SEQ_GT(th_ack, tp-&gt;snd_una) &amp;&amp;
		    SEQ_LEQ(th_ack, tp-&gt;snd_max) &amp;&amp;
		    (tsecr == 0 ||
		    TSTMP_GEQ(tsecr, tp-&gt;t_badrexmt_time))) {
			<span class="enscript-comment">/*
			 * We received a new ACk after a
			 * spurious timeout. Adapt retransmission 
			 * timer as described in rfc 4015.
			 */</span>
			tp-&gt;t_flagsext &amp;= ~(TF_RECOMPUTE_RTT);
			tp-&gt;t_badrexmt_time = 0;
			tp-&gt;t_srtt = max(tp-&gt;t_srtt_prev, rtt);
			tp-&gt;t_srtt = tp-&gt;t_srtt &lt;&lt; TCP_RTT_SHIFT;
			tp-&gt;t_rttvar = max(tp-&gt;t_rttvar_prev, (rtt &gt;&gt; 1));
			tp-&gt;t_rttvar = tp-&gt;t_rttvar &lt;&lt; TCP_RTTVAR_SHIFT;

			<span class="enscript-keyword">if</span> (tp-&gt;t_rttbest &gt; (tp-&gt;t_srtt + tp-&gt;t_rttvar))
				tp-&gt;t_rttbest = tp-&gt;t_srtt + tp-&gt;t_rttvar;

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">compute_rto</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span>;
		}
	}

	tcpstat.tcps_rttupdated++;
	tp-&gt;t_rttupdated++;

	<span class="enscript-keyword">if</span> (rtt &gt; 0) {
		tp-&gt;t_rttcur = rtt;
		update_base_rtt(tp, rtt);
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_srtt != 0) {
		<span class="enscript-comment">/*
		 * srtt is stored as fixed point with 5 bits after the
		 * binary point (i.e., scaled by 32).  The following magic
		 * is equivalent to the smoothing algorithm in rfc793 with
		 * an alpha of .875 (srtt = rtt/8 + srtt*7/8 in fixed
		 * point).
		 *
		 * Freebsd adjusts rtt to origin 0 by subtracting 1 
		 * from the provided rtt value. This was required because 
		 * of the way t_rtttime was initiailised to 1 before. 
		 * Since we changed t_rtttime to be based on
		 * tcp_now, this extra adjustment is not needed.
		 */</span>
		delta = (rtt &lt;&lt; TCP_DELTA_SHIFT)
			- (tp-&gt;t_srtt &gt;&gt; (TCP_RTT_SHIFT - TCP_DELTA_SHIFT));

		<span class="enscript-keyword">if</span> ((tp-&gt;t_srtt += delta) &lt;= 0)
			tp-&gt;t_srtt = 1;

		<span class="enscript-comment">/*
		 * We accumulate a smoothed rtt variance (actually, a
		 * smoothed mean difference), then set the retransmit
		 * timer to smoothed rtt + 4 times the smoothed variance.
		 * rttvar is stored as fixed point with 4 bits after the
		 * binary point (scaled by 16).  The following is
		 * equivalent to rfc793 smoothing with an alpha of .75
		 * (rttvar = rttvar*3/4 + |delta| / 4).  This replaces
		 * rfc793's wired-in beta.
		 */</span>
		<span class="enscript-keyword">if</span> (delta &lt; 0)
			delta = -delta;
		delta -= tp-&gt;t_rttvar &gt;&gt; (TCP_RTTVAR_SHIFT - TCP_DELTA_SHIFT);
		<span class="enscript-keyword">if</span> ((tp-&gt;t_rttvar += delta) &lt;= 0)
			tp-&gt;t_rttvar = 1;
		<span class="enscript-keyword">if</span> (tp-&gt;t_rttbest == 0  || 
			tp-&gt;t_rttbest &gt; (tp-&gt;t_srtt + tp-&gt;t_rttvar))
			tp-&gt;t_rttbest = tp-&gt;t_srtt + tp-&gt;t_rttvar;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * No rtt measurement yet - use the unsmoothed rtt.
		 * Set the variance to half the rtt (so our first
		 * retransmit happens at 3*rtt).
		 */</span>
		tp-&gt;t_srtt = rtt &lt;&lt; TCP_RTT_SHIFT;
		tp-&gt;t_rttvar = rtt &lt;&lt; (TCP_RTTVAR_SHIFT - 1);
	}

<span class="enscript-reference">compute_rto</span>:
	nstat_route_rtt(tp-&gt;t_inpcb-&gt;inp_route.ro_rt, tp-&gt;t_srtt, 
		tp-&gt;t_rttvar);
	tp-&gt;t_rxtshift = 0;
	tp-&gt;t_rxtstart = 0;

	<span class="enscript-comment">/*
	 * the retransmit should happen at rtt + 4 * rttvar.
	 * Because of the way we do the smoothing, srtt and rttvar
	 * will each average +1/2 tick of bias.  When we compute
	 * the retransmit timer, we want 1/2 tick of rounding and
	 * 1 extra tick because of +-1/2 tick uncertainty in the
	 * firing of the timer.  The bias will give us exactly the
	 * 1.5 tick we need.  But, because the bias is
	 * statistical, we have to test that we don't drop below
	 * the minimum feasible timer (which is 2 ticks).
	 */</span>
	TCPT_RANGESET(tp-&gt;t_rxtcur, TCP_REXMTVAL(tp),
		max(tp-&gt;t_rttmin, rtt + 2), TCPTV_REXMTMAX, 
		TCP_ADD_REXMTSLOP(tp));

	<span class="enscript-comment">/*
	 * We received an ack for a packet that wasn't retransmitted;
	 * it is probably safe to discard any error indications we've
	 * received recently.  This isn't quite right, but close enough
	 * for now (a route might have failed after we sent a segment,
	 * and the return path might not be symmetrical).
	 */</span>
	tp-&gt;t_softerror = 0;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_maxmtu</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> maxmtu;

	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_mtu == 0)
		maxmtu = rt-&gt;rt_ifp-&gt;if_mtu;
	<span class="enscript-keyword">else</span>
		maxmtu = MIN(rt-&gt;rt_rmx.rmx_mtu, rt-&gt;rt_ifp-&gt;if_mtu);

	<span class="enscript-keyword">return</span> (maxmtu);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_maxmtu6</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> maxmtu;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-keyword">if</span> ((ndi = ND_IFINFO(rt-&gt;rt_ifp)) != NULL &amp;&amp; !ndi-&gt;initialized)
		ndi = NULL;
	<span class="enscript-keyword">if</span> (ndi != NULL)
		lck_mtx_lock(&amp;ndi-&gt;lock);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_mtu == 0)
		maxmtu = IN6_LINKMTU(rt-&gt;rt_ifp);
	<span class="enscript-keyword">else</span>
		maxmtu = MIN(rt-&gt;rt_rmx.rmx_mtu, IN6_LINKMTU(rt-&gt;rt_ifp));
	<span class="enscript-keyword">if</span> (ndi != NULL)
		lck_mtx_unlock(&amp;ndi-&gt;lock);

	<span class="enscript-keyword">return</span> (maxmtu);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Determine a reasonable value for maxseg size.
 * If the route is known, check route for mtu.
 * If none, use an mss that can be handled on the outgoing
 * interface without forcing IP to fragment; if bigger than
 * an mbuf cluster (MCLBYTES), round down to nearest multiple of MCLBYTES
 * to utilize large mbufs.  If no route is found, route has no mtu,
 * or the destination isn't local, use a default, hopefully conservative
 * size (usually 512 or the default IP max size, but no more than the mtu
 * of the interface), as we can't discover anything about intervening
 * gateways or networks.  We also initialize the congestion/slow start
 * window. While looking at the routing entry, we also initialize 
 * other path-dependent parameters from pre-set or cached values 
 * in the routing entry.
 *
 * Also take into account the space needed for options that we
 * send regularly.  Make maxseg shorter by that amount to assure
 * that we can send maxseg amount of data even when the options
 * are present.  Store the upper limit of the length of options plus
 * data in maxopd.
 *
 * NOTE that this routine is only called when we process an incoming
 * segment, for outgoing segments only tcp_mssopt is called.
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_mss</span>(tp, offer, input_ifscope)
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">int</span> offer;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> input_ifscope;
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> rtt, mss;
	u_int32_t bufsize;
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> rmxp_tao *taop;
	<span class="enscript-type">int</span> origoffer = offer;
	u_int32_t sb_max_corrected;
	<span class="enscript-type">int</span> isnetlocal = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6;
	<span class="enscript-type">int</span> min_protoh;
#<span class="enscript-reference">endif</span>

	inp = tp-&gt;t_inpcb;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	isipv6 = ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0) ? 1 : 0;
	min_protoh = isipv6 ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr)
			    : <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">min_protoh</span>  (sizeof (struct tcpiphdr))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		rt = tcp_rtlookup6(inp, input_ifscope);
	}
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		rt = tcp_rtlookup(inp, input_ifscope);
	}
	isnetlocal = (tp-&gt;t_flags &amp; TF_LOCAL);

	<span class="enscript-keyword">if</span> (rt == NULL) {
		tp-&gt;t_maxopd = tp-&gt;t_maxseg =
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		tcp_mssdflt;
		<span class="enscript-keyword">return</span>;
	}
	ifp = rt-&gt;rt_ifp;
	<span class="enscript-comment">/*
	 * Slower link window correction:
	 * If a value is specificied for slowlink_wsize use it for
	 * PPP links believed to be on a serial modem (speed &lt;128Kbps).
	 * Excludes 9600bps as it is the default value adversized
	 * by pseudo-devices over ppp.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_type == IFT_PPP &amp;&amp; slowlink_wsize &gt; 0 &amp;&amp; 
	    ifp-&gt;if_baudrate &gt; 9600 &amp;&amp; ifp-&gt;if_baudrate &lt;= 128000) {
		tp-&gt;t_flags |= TF_SLOWLINK;
	}
	so = inp-&gt;inp_socket;

	taop = rmx_taop(rt-&gt;rt_rmx);
	<span class="enscript-comment">/*
	 * Offer == -1 means that we didn't receive SYN yet,
	 * use cached value in that case;
	 */</span>
	<span class="enscript-keyword">if</span> (offer == -1)
		offer = taop-&gt;tao_mssopt;
	<span class="enscript-comment">/*
	 * Offer == 0 means that there was no MSS on the SYN segment,
	 * in this case we use tcp_mssdflt.
	 */</span>
	<span class="enscript-keyword">if</span> (offer == 0)
		offer =
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			tcp_mssdflt;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Prevent DoS attack with too small MSS. Round up
		 * to at least minmss.
		 */</span>
		offer = max(offer, tcp_minmss);
		<span class="enscript-comment">/*
		 * Sanity check: make sure that maxopd will be large
		 * enough to allow some data on segments even is the
		 * all the option space is used (40bytes).  Otherwise
		 * funny things may happen in tcp_output.
		 */</span>
		offer = max(offer, 64);
	}
	taop-&gt;tao_mssopt = offer;

	<span class="enscript-comment">/*
	 * While we're here, check if there's an initial rtt
	 * or rttvar.  Convert from the route-table units
	 * to scaled multiples of the slow timeout timer.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_srtt == 0 &amp;&amp; (rtt = rt-&gt;rt_rmx.rmx_rtt) != 0) {
		tcp_getrt_rtt(tp, rt);
	} <span class="enscript-keyword">else</span> {
		tp-&gt;t_rttmin = isnetlocal ? tcp_TCPTV_MIN : TCPTV_REXMTMIN;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	mss = (isipv6 ? tcp_maxmtu6(rt) : tcp_maxmtu(rt));
#<span class="enscript-reference">else</span>
	mss = tcp_maxmtu(rt);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">// At this point, the mss is just the MTU. Adjust if necessary.
</span>	mss = necp_socket_get_effective_mtu(inp, mss);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	mss -= min_protoh;

	<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_mtu == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			<span class="enscript-keyword">if</span> (!isnetlocal)
				mss = min(mss, tcp_v6mssdflt);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (!isnetlocal)
			mss = min(mss, tcp_mssdflt);
	}

	mss = min(mss, offer);
	<span class="enscript-comment">/*
	 * maxopd stores the maximum length of data AND options
	 * in a segment; maxseg is the amount of data in a normal
	 * segment.  We need to store this value (maxopd) apart
	 * from maxseg, because now every segment carries options
	 * and thus we normally have somewhat less data in segments.
	 */</span>
	tp-&gt;t_maxopd = mss;

	<span class="enscript-comment">/*
	 * origoffer==-1 indicates, that no segments were received yet.
	 * In this case we just guess.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &amp;&amp;
	    (origoffer == -1 ||
	     (tp-&gt;t_flags &amp; TF_RCVD_TSTMP) == TF_RCVD_TSTMP))
		mss -= TCPOLEN_TSTAMP_APPA;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	mss -= mptcp_adj_mss(tp, FALSE);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	tp-&gt;t_maxseg = mss;
	
	<span class="enscript-comment">/*
	 * Calculate corrected value for sb_max; ensure to upgrade the
	 * numerator for large sb_max values else it will overflow.
	 */</span>
	sb_max_corrected = (sb_max * (u_int64_t)MCLBYTES) / (MSIZE + MCLBYTES);

	<span class="enscript-comment">/*
	 * If there's a pipesize (ie loopback), change the socket
	 * buffer to that size only if it's bigger than the current
	 * sockbuf size.  Make the socket buffers an integral
	 * number of mss units; if the mss is larger than
	 * the socket buffer, decrease the mss.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RTV_SPIPE</span>
	bufsize = rt-&gt;rt_rmx.rmx_sendpipe;
	<span class="enscript-keyword">if</span> (bufsize &lt; so-&gt;so_snd.sb_hiwat)
#<span class="enscript-reference">endif</span>
		bufsize = so-&gt;so_snd.sb_hiwat;
	<span class="enscript-keyword">if</span> (bufsize &lt; mss)
		mss = bufsize;
	<span class="enscript-keyword">else</span> {
		bufsize = (((bufsize + (u_int64_t)mss - 1) / (u_int64_t)mss) * (u_int64_t)mss);
		<span class="enscript-keyword">if</span> (bufsize &gt; sb_max_corrected)
			bufsize = sb_max_corrected;
		(<span class="enscript-type">void</span>)sbreserve(&amp;so-&gt;so_snd, bufsize);
	}
	tp-&gt;t_maxseg = mss;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RTV_RPIPE</span>
	bufsize = rt-&gt;rt_rmx.rmx_recvpipe;
	<span class="enscript-keyword">if</span> (bufsize &lt; so-&gt;so_rcv.sb_hiwat)
#<span class="enscript-reference">endif</span>
		bufsize = so-&gt;so_rcv.sb_hiwat;
	<span class="enscript-keyword">if</span> (bufsize &gt; mss) {
		bufsize = (((bufsize + (u_int64_t)mss - 1) / (u_int64_t)mss) * (u_int64_t)mss);
		<span class="enscript-keyword">if</span> (bufsize &gt; sb_max_corrected)
			bufsize = sb_max_corrected;
		(<span class="enscript-type">void</span>)sbreserve(&amp;so-&gt;so_rcv, bufsize);
	}

	set_tcp_stream_priority(so);

	<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_ssthresh) {
		<span class="enscript-comment">/*
		 * There's some sort of gateway or interface
		 * buffer limit on the path.  Use this to set
		 * slow-start threshold, but set the threshold to
		 * no less than 2*mss.
		 */</span>
		tp-&gt;snd_ssthresh = max(2 * mss, rt-&gt;rt_rmx.rmx_ssthresh);
		tcpstat.tcps_usedssthresh++;
	} <span class="enscript-keyword">else</span> {
		tp-&gt;snd_ssthresh = TCP_MAXWIN &lt;&lt; TCP_MAX_WINSHIFT;
	}

	<span class="enscript-comment">/*
	 * Set the slow-start flight size depending on whether this
	 * is a local network or not.
	 */</span>
	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cwnd_init != NULL)
		CC_ALGO(tp)-&gt;cwnd_init(tp);

	tcp_ccdbg_trace(tp, NULL, TCP_CC_CWND_INIT);

	<span class="enscript-comment">/* Route locked during lookup above */</span>
	RT_UNLOCK(rt);
}

<span class="enscript-comment">/*
 * Determine the MSS option to send on an outgoing SYN.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_mssopt</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> mss;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6;
	<span class="enscript-type">int</span> min_protoh;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	isipv6 = ((tp-&gt;t_inpcb-&gt;inp_vflag &amp; INP_IPV6) != 0) ? 1 : 0;
	min_protoh = isipv6 ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr)
			    : <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">min_protoh</span>  (sizeof (struct tcpiphdr))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		rt = tcp_rtlookup6(tp-&gt;t_inpcb, IFSCOPE_NONE);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	rt = tcp_rtlookup(tp-&gt;t_inpcb, IFSCOPE_NONE);
	<span class="enscript-keyword">if</span> (rt == NULL) {
		<span class="enscript-keyword">return</span> (
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			tcp_mssdflt);
	}
	<span class="enscript-comment">/*
	 * Slower link window correction:
	 * If a value is specificied for slowlink_wsize use it for PPP links
	 * believed to be on a serial modem (speed &lt;128Kbps). Excludes 9600bps as
	 * it is the default value adversized by pseudo-devices over ppp.
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp-&gt;if_type == IFT_PPP &amp;&amp; slowlink_wsize &gt; 0 &amp;&amp; 
	    rt-&gt;rt_ifp-&gt;if_baudrate &gt; 9600 &amp;&amp; rt-&gt;rt_ifp-&gt;if_baudrate &lt;= 128000) {
		tp-&gt;t_flags |= TF_SLOWLINK;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	mss = (isipv6 ? tcp_maxmtu6(rt) : tcp_maxmtu(rt));
#<span class="enscript-reference">else</span>
	mss = tcp_maxmtu(rt);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Route locked during lookup above */</span>
	RT_UNLOCK(rt);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">// At this point, the mss is just the MTU. Adjust if necessary.
</span>	mss = necp_socket_get_effective_mtu(tp-&gt;t_inpcb, mss);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-keyword">return</span> (mss - min_protoh);
}

<span class="enscript-comment">/*
 * On a partial ack arrives, force the retransmission of the
 * next unacknowledged segment.  Do not clear tp-&gt;t_dupacks.
 * By setting snd_nxt to th_ack, this forces retransmission timer to
 * be started again.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_newreno_partial_ack</span>(tp, th)
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> tcphdr *th;
{
		tcp_seq onxt = tp-&gt;snd_nxt;
		u_int32_t  ocwnd = tp-&gt;snd_cwnd;
		tp-&gt;t_timer[TCPT_REXMT] = 0;
		tp-&gt;t_timer[TCPT_PTO] = 0;
		tp-&gt;t_rtttime = 0;
		tp-&gt;snd_nxt = th-&gt;th_ack;
		<span class="enscript-comment">/*
		 * Set snd_cwnd to one segment beyond acknowledged offset
		 * (tp-&gt;snd_una has not yet been updated when this function 
		 *  is called)
		 */</span>
		tp-&gt;snd_cwnd = tp-&gt;t_maxseg + BYTES_ACKED(th, tp);
		tp-&gt;t_flags |= TF_ACKNOW;
		(<span class="enscript-type">void</span>) tcp_output(tp);
		tp-&gt;snd_cwnd = ocwnd;
		<span class="enscript-keyword">if</span> (SEQ_GT(onxt, tp-&gt;snd_nxt))
			tp-&gt;snd_nxt = onxt;
		<span class="enscript-comment">/*
		 * Partial window deflation.  Relies on fact that tp-&gt;snd_una
		 * not updated yet.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;snd_cwnd &gt; BYTES_ACKED(th, tp))
			tp-&gt;snd_cwnd -= BYTES_ACKED(th, tp);
		<span class="enscript-keyword">else</span>
			tp-&gt;snd_cwnd = 0;
		tp-&gt;snd_cwnd += tp-&gt;t_maxseg;

}

<span class="enscript-comment">/*
 * Drop a random TCP connection that hasn't been serviced yet and
 * is eligible for discard.  There is a one in qlen chance that
 * we will return a null, saying that there are no dropable
 * requests.  In this case, the protocol specific code should drop
 * the new request.  This insures fairness.
 *
 * The listening TCP socket &quot;head&quot; must be locked
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_dropdropablreq</span>(<span class="enscript-type">struct</span> socket *head)
{
	<span class="enscript-type">struct</span> socket *so, *sonext;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, j, qlen;
	<span class="enscript-type">static</span> u_int32_t rnd = 0;
	<span class="enscript-type">static</span> u_int64_t old_runtime;
	<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cur_cnt, old_cnt;
	u_int64_t now_sec;
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
	<span class="enscript-type">struct</span> tcpcb *tp;

	<span class="enscript-keyword">if</span> ((head-&gt;so_options &amp; SO_ACCEPTCONN) == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;head-&gt;so_incomp))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* 
	 * Check if there is any socket in the incomp queue
	 * that is closed because of a reset from the peer and is
	 * waiting to be garbage collected. If so, pick that as
	 * the victim
	 */</span>
	TAILQ_FOREACH_SAFE(so, &amp;head-&gt;so_incomp, so_list, sonext) {
		inp = sotoinpcb(so);
		tp = intotcpcb(inp);
		<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; tp-&gt;t_state == TCPS_CLOSED &amp;&amp;
		    so-&gt;so_head != NULL &amp;&amp;
		    (so-&gt;so_state &amp; (SS_INCOMP|SS_CANTSENDMORE|SS_CANTRCVMORE)) ==
		    (SS_INCOMP|SS_CANTSENDMORE|SS_CANTRCVMORE)) {
			<span class="enscript-comment">/* 
			 * The listen socket is already locked but we 
			 * can lock this socket here without lock ordering
			 * issues because it is in the incomp queue and
			 * is not visible to others.
			 */</span>
			<span class="enscript-keyword">if</span> (lck_mtx_try_lock(&amp;inp-&gt;inpcb_mtx)) {
				so-&gt;so_usecount++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">found_victim</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">continue</span>;
			}
		}
	}

	so = TAILQ_FIRST(&amp;head-&gt;so_incomp);

	now_sec = net_uptime();
	<span class="enscript-keyword">if</span> ((i = (now_sec - old_runtime)) != 0) {
		old_runtime = now_sec;
		old_cnt = cur_cnt / i;
		cur_cnt = 0;
	}
	
	
	qlen = head-&gt;so_incqlen;
	<span class="enscript-keyword">if</span> (rnd == 0)
		rnd = RandomULong();

	<span class="enscript-keyword">if</span> (++cur_cnt &gt; qlen || old_cnt &gt; qlen) {
		rnd = (314159 * rnd + 66329) &amp; 0xffff;
		j = ((qlen + 1) * rnd) &gt;&gt; 16;

		<span class="enscript-keyword">while</span> (j-- &amp;&amp; so)
			so = TAILQ_NEXT(so, so_list);
	}
	<span class="enscript-comment">/* Find a connection that is not already closing (or being served) */</span>
	<span class="enscript-keyword">while</span> (so) {
		inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
		
		sonext = TAILQ_NEXT(so, so_list);

		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) 
			!= WNT_STOPUSING) {
			<span class="enscript-comment">/* 
			 * Avoid the issue of a socket being accepted
			 * by one input thread and being dropped by 
			 * another input thread. If we can't get a hold 
			 * on this mutex, then grab the next socket in 
			 * line.
			 */</span>
			<span class="enscript-keyword">if</span> (lck_mtx_try_lock(&amp;inp-&gt;inpcb_mtx)) {
				so-&gt;so_usecount++;
				<span class="enscript-keyword">if</span> ((so-&gt;so_usecount == 2) &amp;&amp; 
				    (so-&gt;so_state &amp; SS_INCOMP) &amp;&amp;
				    !(so-&gt;so_flags &amp; SOF_INCOMP_INPROGRESS))  {
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* 
					 * don't use if being accepted or 
					 * used in any other way
					 */</span>
					in_pcb_checkstate(inp, WNT_RELEASE, 1);
					tcp_unlock(so, 1, 0);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * do not try to lock the inp in 
				 * in_pcb_checkstate because the lock 
				 * is already held in some other thread.
				 * Only drop the inp_wntcnt reference.
				 */</span>
				in_pcb_checkstate(inp, WNT_RELEASE, 1);
			}
		}
		so = sonext;
		
	}
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* Makes sure socket is still in the right state to be discarded */</span>

	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
		tcp_unlock(so, 1, 0);
		<span class="enscript-keyword">return</span> (0);
	}

<span class="enscript-reference">found_victim</span>:
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount != 2 || !(so-&gt;so_state &amp; SS_INCOMP)) {
		<span class="enscript-comment">/* do not discard: that socket is being accepted */</span>
		tcp_unlock(so, 1, 0);
		<span class="enscript-keyword">return</span> (0);
	}

	TAILQ_REMOVE(&amp;head-&gt;so_incomp, so, so_list);
	tcp_unlock(head, 0, 0);

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);
	tp = sototcpcb(so);
	so-&gt;so_flags |= SOF_OVERFLOW;
	so-&gt;so_head = NULL;

	tcp_close(tp);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt &gt; 0 &amp;&amp; inp-&gt;inp_wantcnt != WNT_STOPUSING) {
		<span class="enscript-comment">/* 
		 * Some one has a wantcnt on this pcb. Since WNT_ACQUIRE
		 * doesn't require a lock, it could have happened while
		 * we are holding the lock. This pcb will have to
		 * be garbage collected later.
		 * Release the reference held for so_incomp queue
		 */</span>
		so-&gt;so_usecount--;
		tcp_unlock(so, 1, 0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * Unlock this socket and leave the reference on. 
		 * We need to acquire the pcbinfo lock in order to 
		 * fully dispose it off 
		 */</span>
		tcp_unlock(so, 0, 0);

		lck_rw_lock_exclusive(tcbinfo.ipi_lock);

		tcp_lock(so, 0, 0);
		<span class="enscript-comment">/* Release the reference held for so_incomp queue */</span>
		so-&gt;so_usecount--;

		<span class="enscript-keyword">if</span> (so-&gt;so_usecount != 1 || 
		    (inp-&gt;inp_wantcnt &gt; 0 &amp;&amp; 
		    inp-&gt;inp_wantcnt != WNT_STOPUSING)) {
			<span class="enscript-comment">/* 
			 * There is an extra wantcount or usecount 
			 * that must have been added when the socket 
			 * was unlocked. This socket will have to be 
			 * garbage collected later
			 */</span>
			tcp_unlock(so, 1, 0);
		} <span class="enscript-keyword">else</span> {

			<span class="enscript-comment">/* Drop the reference held for this function */</span>
			so-&gt;so_usecount--;

			in_pcbdispose(inp);
		}
		lck_rw_done(tcbinfo.ipi_lock);
	}
	tcpstat.tcps_drops++;

	tcp_lock(head, 0, 0);
	head-&gt;so_incqlen--;
	head-&gt;so_qlen--;
	<span class="enscript-keyword">return</span>(1);
}

<span class="enscript-comment">/* Set background congestion control on a socket */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_background_cc</span>(<span class="enscript-type">struct</span> socket *so)
{
	tcp_set_new_cc(so, TCP_CC_ALGO_BACKGROUND_INDEX);
}

<span class="enscript-comment">/* Set foreground congestion control on a socket */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_foreground_cc</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (tcp_use_newreno)
		tcp_set_new_cc(so, TCP_CC_ALGO_NEWRENO_INDEX);
	<span class="enscript-keyword">else</span>
		tcp_set_new_cc(so, TCP_CC_ALGO_CUBIC_INDEX);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_new_cc</span>(<span class="enscript-type">struct</span> socket *so, uint16_t cc_index)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(inp);
	u_char old_cc_index = 0;
	<span class="enscript-keyword">if</span> (tp-&gt;tcp_cc_index != cc_index) {

		old_cc_index = tp-&gt;tcp_cc_index;

		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cleanup != NULL)
			CC_ALGO(tp)-&gt;cleanup(tp);
		tp-&gt;tcp_cc_index = cc_index;

		tcp_cc_allocate_state(tp);

		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;switch_to != NULL)
			CC_ALGO(tp)-&gt;switch_to(tp, old_cc_index);

		tcp_ccdbg_trace(tp, NULL, TCP_CC_CHANGE_ALGO);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_recv_bg</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (!IS_TCP_RECV_BG(so))
		so-&gt;so_traffic_mgt_flags |= TRAFFIC_MGT_TCP_RECVBG;

	<span class="enscript-comment">/* Unset Large Receive Offload on background sockets */</span>
	so_set_lro(so, SO_TC_BK);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_clear_recv_bg</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (IS_TCP_RECV_BG(so))
		so-&gt;so_traffic_mgt_flags &amp;= ~(TRAFFIC_MGT_TCP_RECVBG);

	<span class="enscript-comment">/* 
	 * Set/unset use of Large Receive Offload depending on 
	 * the traffic class
	 */</span>
	so_set_lro(so, so-&gt;so_traffic_class);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_fc_unthrottle_tcp</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> tcpcb *tp = inp-&gt;inp_ppcb;
	<span class="enscript-comment">/*
	 * Back off the slow-start threshold and enter
	 * congestion avoidance phase
	 */</span>
	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;pre_fr != NULL)
		CC_ALGO(tp)-&gt;pre_fr(tp);

	tp-&gt;snd_cwnd = tp-&gt;snd_ssthresh;
	tp-&gt;t_flagsext &amp;= ~TF_CWND_NONVALIDATED;
	<span class="enscript-comment">/*
	 * Restart counting for ABC as we changed the
	 * congestion window just now.
	 */</span>
	tp-&gt;t_bytes_acked = 0;

	<span class="enscript-comment">/* Reset retransmit shift as we know that the reason
	 * for delay in sending a packet is due to flow 
	 * control on the outgoing interface. There is no need
	 * to backoff retransmit timer.
	 */</span>
	tp-&gt;t_rxtshift = 0;
	tp-&gt;t_rtttime = 0;

	<span class="enscript-comment">/*
	 * Start the output stream again. Since we are
	 * not retransmitting data, do not reset the
	 * retransmit timer or rtt calculation.
	 */</span>
	tcp_output(tp);
}
    
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
tcp_getstat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">int</span> error;

	proc_t caller = PROC_NULL;
	proc_t caller_parent = PROC_NULL;
	<span class="enscript-type">char</span> command_name[MAXCOMLEN + 1] = <span class="enscript-string">&quot;&quot;</span>;
	<span class="enscript-type">char</span> parent_name[MAXCOMLEN + 1] = <span class="enscript-string">&quot;&quot;</span>;

	<span class="enscript-keyword">if</span> ((caller = proc_self()) != PROC_NULL) {
		<span class="enscript-comment">/* get process name */</span>
		strlcpy(command_name, caller-&gt;p_comm, <span class="enscript-keyword">sizeof</span>(command_name));

		<span class="enscript-comment">/* get parent process name if possible */</span>
		<span class="enscript-keyword">if</span> ((caller_parent = proc_find(caller-&gt;p_ppid)) != PROC_NULL) {
			strlcpy(parent_name, caller_parent-&gt;p_comm,
			    <span class="enscript-keyword">sizeof</span>(parent_name));
			proc_rele(caller_parent);
		}

		<span class="enscript-keyword">if</span> ((escape_str(command_name, strlen(command_name),
		    <span class="enscript-keyword">sizeof</span>(command_name)) == 0) &amp;&amp;
		    (escape_str(parent_name, strlen(parent_name),
		    <span class="enscript-keyword">sizeof</span>(parent_name)) == 0)) {
			kern_asl_msg(LOG_DEBUG, <span class="enscript-string">&quot;messagetracer&quot;</span>,
			    5,
			    <span class="enscript-string">&quot;com.apple.message.domain&quot;</span>,
			    <span class="enscript-string">&quot;com.apple.kernel.tcpstat&quot;</span>, <span class="enscript-comment">/* 1 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature&quot;</span>,
			    <span class="enscript-string">&quot;tcpstat&quot;</span>, <span class="enscript-comment">/* 2 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature2&quot;</span>, command_name, <span class="enscript-comment">/* 3 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature3&quot;</span>, parent_name, <span class="enscript-comment">/* 4 */</span>
			    <span class="enscript-string">&quot;com.apple.message.summarize&quot;</span>, <span class="enscript-string">&quot;YES&quot;</span>, <span class="enscript-comment">/* 5 */</span>
			    NULL);
		}
	}
	<span class="enscript-keyword">if</span> (caller != PROC_NULL)
		proc_rele(caller);

	<span class="enscript-keyword">if</span> (req-&gt;oldptr == 0) {
		req-&gt;oldlen= (size_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcpstat);
	}

	error = SYSCTL_OUT(req, &amp;tcpstat, MIN(<span class="enscript-keyword">sizeof</span> (tcpstat), req-&gt;oldlen));

        <span class="enscript-keyword">return</span> (error);

}

<span class="enscript-comment">/*
 * Checksum extended TCP header and data.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_input_checksum</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> tlen)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;

	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>: {
		<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-type">struct</span> ipovly *ipov = (<span class="enscript-type">struct</span> ipovly *)ip;

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_DID_CSUM)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> ((hwcksum_rx || (ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
		    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID)) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_PSEUDO_HDR) {
				th-&gt;th_sum = m-&gt;m_pkthdr.csum_rx_val;
			} <span class="enscript-keyword">else</span> {
				uint16_t sum = m-&gt;m_pkthdr.csum_rx_val;
				uint16_t start = m-&gt;m_pkthdr.csum_rx_start;

				<span class="enscript-comment">/*
				 * Perform 1's complement adjustment of octets
				 * that got included/excluded in the hardware-
				 * calculated checksum value.  Ignore cases
				 * where the value includes or excludes the IP
				 * header span, as the sum for those octets
				 * would already be 0xffff and thus no-op.
				 */</span>
				<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_PARTIAL) &amp;&amp;
				    start != 0 &amp;&amp; (off - start) != off) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
					<span class="enscript-keyword">if</span> (start &lt; off) {
						HTONS(ip-&gt;ip_len);
						HTONS(ip-&gt;ip_off);
					}
#<span class="enscript-reference">endif</span>
					<span class="enscript-comment">/* callee folds in sum */</span>
					sum = m_adj_sum16(m, start, off, sum);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
					<span class="enscript-keyword">if</span> (start &lt; off) {
						NTOHS(ip-&gt;ip_off);
						NTOHS(ip-&gt;ip_len);
					}
#<span class="enscript-reference">endif</span>
				}

				<span class="enscript-comment">/* callee folds in sum */</span>
				th-&gt;th_sum = in_pseudo(ip-&gt;ip_src.s_addr,
				    ip-&gt;ip_dst.s_addr,
				    sum + htonl(tlen + IPPROTO_TCP));
			}
			th-&gt;th_sum ^= 0xffff;
		} <span class="enscript-keyword">else</span> {
			uint16_t ip_sum;
			<span class="enscript-type">int</span> len;
			<span class="enscript-type">char</span> b[9];

			bcopy(ipov-&gt;ih_x1, b, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
			bzero(ipov-&gt;ih_x1, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
			ip_sum = ipov-&gt;ih_len;
			ipov-&gt;ih_len = (u_short)tlen;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			HTONS(ipov-&gt;ih_len);
#<span class="enscript-reference">endif</span>
			len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) + tlen;
			th-&gt;th_sum = in_cksum(m, len);
			bcopy(b, ipov-&gt;ih_x1, <span class="enscript-keyword">sizeof</span> (ipov-&gt;ih_x1));
			ipov-&gt;ih_len = ip_sum;

			tcp_in_cksum_stats(len);
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_SW_LRO_DID_CSUM)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> ((hwcksum_rx || (ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
		    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID)) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_PSEUDO_HDR) {
				th-&gt;th_sum = m-&gt;m_pkthdr.csum_rx_val;
			} <span class="enscript-keyword">else</span> {
				uint16_t sum = m-&gt;m_pkthdr.csum_rx_val;
				uint16_t start = m-&gt;m_pkthdr.csum_rx_start;

				<span class="enscript-comment">/*
				 * Perform 1's complement adjustment of octets
				 * that got included/excluded in the hardware-
				 * calculated checksum value.
				 */</span>
				<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_PARTIAL) &amp;&amp;
				    start != off) {
					uint16_t s, d;

					<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src)) {
						s = ip6-&gt;ip6_src.s6_addr16[1];
						ip6-&gt;ip6_src.s6_addr16[1] = 0 ;
					}
					<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst)) {
						d = ip6-&gt;ip6_dst.s6_addr16[1];
						ip6-&gt;ip6_dst.s6_addr16[1] = 0;
					}

					<span class="enscript-comment">/* callee folds in sum */</span>
					sum = m_adj_sum16(m, start, off, sum);

					<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src))
						ip6-&gt;ip6_src.s6_addr16[1] = s;
					<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))
						ip6-&gt;ip6_dst.s6_addr16[1] = d;
				}

				th-&gt;th_sum = in6_pseudo(
				    &amp;ip6-&gt;ip6_src, &amp;ip6-&gt;ip6_dst,
				    sum + htonl(tlen + IPPROTO_TCP));
			}
			th-&gt;th_sum ^= 0xffff;
		} <span class="enscript-keyword">else</span> {
			tcp_in6_cksum_stats(tlen);
			th-&gt;th_sum = in6_cksum(m, IPPROTO_TCP, off, tlen);
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (th-&gt;th_sum != 0) {
		tcpstat.tcps_rcvbadsum++;
		IF_TCP_STATINC(ifp, badformat);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_STATS, stats,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, tcp_getstat,
    <span class="enscript-string">&quot;S,tcpstat&quot;</span>, <span class="enscript-string">&quot;TCP statistics (struct tcpstat, netinet/tcp_var.h)&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_rexmtthresh SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">int</span> error, val = tcprexmtthresh;

	error = sysctl_handle_int(oidp, &amp;val, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
                <span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Constrain the number of duplicate ACKs
	 * to consider for TCP fast retransmit 
	 * to either 2 or 3
	 */</span>

        <span class="enscript-keyword">if</span> (val &lt; 2 || val &gt; 3)
		<span class="enscript-keyword">return</span> (EINVAL);

	 tcprexmtthresh = val;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, rexmt_thresh, CTLTYPE_INT | CTLFLAG_RW |
	CTLFLAG_LOCKED, &amp;tcprexmtthresh, 0, &amp;sysctl_rexmtthresh, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;Duplicate ACK Threshold for Fast Retransmit&quot;</span>);

</pre>
<hr />
</body></html>