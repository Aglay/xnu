<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_timer.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_timer.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_timer.c	8.2 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/tcp_timer.c,v 1.34.2.11 2001/08/22 00:59:12 silby Exp $
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>	<span class="enscript-comment">/* before tcp_seq.h, for tcp_random18() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/tcp6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_debug.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIMERENTRY_TO_TP</span>(te) ((struct tcpcb *)((uintptr_t)te - offsetof(struct tcpcb, tentry.le.le_next))) 

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VERIFY_NEXT_LINK</span>(elm,field) do {	\
	<span class="enscript-keyword">if</span> (LIST_NEXT((elm),field) != NULL &amp;&amp; 	\
	    LIST_NEXT((elm),field)-&gt;field.le_prev !=	\
		&amp;((elm)-&gt;field.le_next))	\
		panic(<span class="enscript-string">&quot;Bad link elm %p next-&gt;prev != elm&quot;</span>, (elm));	\
} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VERIFY_PREV_LINK</span>(elm,field) do {	\
	<span class="enscript-keyword">if</span> (*(elm)-&gt;field.le_prev != (elm))	\
		panic(<span class="enscript-string">&quot;Bad link elm %p prev-&gt;next != elm&quot;</span>, (elm));	\
} <span class="enscript-keyword">while</span>(0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TCP_SET_TIMER_MODE</span>(mode, i) do { \
	<span class="enscript-keyword">if</span> (IS_TIMER_HZ_10MS(i)) \
		(mode) |= TCP_TIMERLIST_10MS_MODE; \
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IS_TIMER_HZ_100MS(i)) \
		(mode) |= TCP_TIMERLIST_100MS_MODE; \
	<span class="enscript-keyword">else</span> \
		(mode) |= TCP_TIMERLIST_500MS_MODE; \
} <span class="enscript-keyword">while</span>(0)

<span class="enscript-comment">/* Max number of times a stretch ack can be delayed on a connection */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_STRETCHACK_DELAY_THRESHOLD</span>	5

<span class="enscript-comment">/*
 * If the host processor has been sleeping for too long, this is the threshold
 * used to avoid sending stale retransmissions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_SLEEP_TOO_LONG</span>	(10 * 60 * 1000) <span class="enscript-comment">/* 10 minutes in ms */</span>

<span class="enscript-comment">/* tcp timer list */</span>
<span class="enscript-type">struct</span> tcptimerlist tcp_timer_list;

<span class="enscript-comment">/* List of pcbs in timewait state, protected by tcbinfo's ipi_lock */</span>
<span class="enscript-type">struct</span> tcptailq tcp_tw_tailq;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_msec_to_ticks SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, s, tt;

	tt = *(<span class="enscript-type">int</span> *)oidp-&gt;oid_arg1;
	s = tt * 1000 / TCP_RETRANSHZ;;

	error = sysctl_handle_int(oidp, &amp;s, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	tt = s * TCP_RETRANSHZ / 1000;
	<span class="enscript-keyword">if</span> (tt &lt; 1)
		<span class="enscript-keyword">return</span> (EINVAL);

	*(<span class="enscript-type">int</span> *)oidp-&gt;oid_arg1 = tt;
        <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>	tcp_keepinit;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_KEEPINIT, keepinit,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_keepinit, 0, sysctl_msec_to_ticks, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span>	tcp_keepidle;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_KEEPIDLE, keepidle,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_keepidle, 0, sysctl_msec_to_ticks, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span>	tcp_keepintvl;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_KEEPINTVL, keepintvl,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_keepintvl, 0, sysctl_msec_to_ticks, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span>	tcp_keepcnt;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, keepcnt,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_keepcnt, 0, <span class="enscript-string">&quot;number of times to repeat keepalive&quot;</span>);

<span class="enscript-type">int</span>	tcp_msl;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, msl,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_msl, 0, sysctl_msec_to_ticks, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Maximum segment lifetime&quot;</span>);

<span class="enscript-comment">/* 
 * Avoid DoS via TCP Robustness in Persist Condition
 * (see <a href="http://www.ietf.org/id/draft-ananth-tcpm-persist-02.txt">http://www.ietf.org/id/draft-ananth-tcpm-persist-02.txt</a>)
 * by allowing a system wide maximum persistence timeout value when in
 * Zero Window Probe mode.
 *
 * Expressed in milliseconds to be consistent without timeout related
 * values, the TCP socket option is in seconds.
 */</span>
u_int32_t tcp_max_persist_timeout = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, max_persist_timeout,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_max_persist_timeout, 0, sysctl_msec_to_ticks, <span class="enscript-string">&quot;I&quot;</span>, 
    <span class="enscript-string">&quot;Maximum persistence timeout for ZWP&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	always_keepalive = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, always_keepalive,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;always_keepalive , 0, <span class="enscript-string">&quot;Assume SO_KEEPALIVE on all TCP connections&quot;</span>);

<span class="enscript-comment">/*
 * This parameter determines how long the timer list will stay in fast or
 * quick mode even though all connections are idle. In this state, the 
 * timer will run more frequently anticipating new data.
 */</span>
<span class="enscript-type">int</span> timer_fastmode_idlemax = TCP_FASTMODE_IDLERUN_MAX;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, timer_fastmode_idlemax,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;timer_fastmode_idlemax, 0, <span class="enscript-string">&quot;Maximum idle generations in fast mode&quot;</span>);

<span class="enscript-comment">/*
 * See tcp_syn_backoff[] for interval values between SYN retransmits;
 * the value set below defines the number of retransmits, before we
 * disable the timestamp and window scaling options during subsequent
 * SYN retransmits.  Setting it to 0 disables the dropping off of those
 * two options.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_broken_peer_syn_rxmit_thres = 10;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, broken_peer_syn_rexmit_thres,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_broken_peer_syn_rxmit_thres, 0,
    <span class="enscript-string">&quot;Number of retransmitted SYNs before disabling RFC 1323 &quot;</span>
    <span class="enscript-string">&quot;options on local connections&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_timer_advanced = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tcp_timer_advanced,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;tcp_timer_advanced, 0,
    <span class="enscript-string">&quot;Number of times one of the timers was advanced&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_resched_timerlist = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tcp_resched_timerlist,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;tcp_resched_timerlist, 0, 
    <span class="enscript-string">&quot;Number of times timer list was rescheduled as part of processing a packet&quot;</span>);

<span class="enscript-type">int</span>	tcp_pmtud_black_hole_detect = 1 ;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, pmtud_blackhole_detection,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_pmtud_black_hole_detect, 0,
    <span class="enscript-string">&quot;Path MTU Discovery Black Hole Detection&quot;</span>);

<span class="enscript-type">int</span>	tcp_pmtud_black_hole_mss = 1200 ;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, pmtud_blackhole_mss,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_pmtud_black_hole_mss, 0,
    <span class="enscript-string">&quot;Path MTU Discovery Black Hole Detection lowered MSS&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_REPORT_STATS_INTERVAL</span>	43200 <span class="enscript-comment">/* 12 hours, in seconds */</span>
<span class="enscript-type">int</span> tcp_report_stats_interval = TCP_REPORT_STATS_INTERVAL;
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, report_stats_interval,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_report_stats_interval, 0,
    <span class="enscript-string">&quot;Report stats interval&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (DEVELOPMENT || DEBUG) */</span>

<span class="enscript-comment">/* performed garbage collection of &quot;used&quot; sockets */</span>
<span class="enscript-type">static</span> boolean_t tcp_gc_done = FALSE;

<span class="enscript-comment">/* max idle probes */</span>
<span class="enscript-type">int</span>	tcp_maxpersistidle;

<span class="enscript-comment">/*
 * TCP delack timer is set to 100 ms. Since the processing of timer list
 * in fast mode will happen no faster than 100 ms, the delayed ack timer
 * will fire some where between 100 and 200 ms.
 */</span>
<span class="enscript-type">int</span>	tcp_delack = TCP_RETRANSHZ / 10;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
<span class="enscript-comment">/*
 * MP_JOIN retransmission of 3rd ACK will be every 500 msecs without backoff
 */</span>
<span class="enscript-type">int</span>	tcp_jack_rxmt = TCP_RETRANSHZ / 2;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

<span class="enscript-type">static</span> boolean_t tcp_itimer_done = FALSE;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_remove_timer</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sched_timerlist</span>(uint32_t offset);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">tcp_run_conn_timer</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_int16_t *mode,
    u_int16_t probe_if_index);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sched_timers</span>(<span class="enscript-type">struct</span> tcpcb *tp);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_set_lotimer_index</span>(<span class="enscript-type">struct</span> tcpcb *);
__private_extern__ <span class="enscript-type">void</span> tcp_remove_from_time_wait(<span class="enscript-type">struct</span> inpcb *inp);
__private_extern__ <span class="enscript-type">void</span> tcp_report_stats(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Macro to compare two timers. If there is a reset of the sign bit,
 * it is safe to assume that the timer has wrapped around. By doing
 * signed comparision, we take care of wrap around such that the value
 * with the sign bit reset is actually ahead of the other.
 */</span>
inline int32_t
<span class="enscript-function-name">timer_diff</span>(uint32_t t1, uint32_t toff1, uint32_t t2, uint32_t toff2) {
	<span class="enscript-keyword">return</span> (int32_t)((t1 + toff1) - (t2 + toff2));
};

<span class="enscript-type">static</span>	u_int64_t tcp_last_report_time;

<span class="enscript-comment">/*
 * Structure to store previously reported stats so that we can send
 * incremental changes in each report interval.
 */</span>
<span class="enscript-type">struct</span> tcp_last_report_stats {
	u_int32_t	tcps_connattempt;
	u_int32_t	tcps_accepts;
	u_int32_t	tcps_ecn_client_setup;
	u_int32_t	tcps_ecn_server_setup;
	u_int32_t	tcps_ecn_client_success;
	u_int32_t	tcps_ecn_server_success;
	u_int32_t	tcps_ecn_not_supported;
	u_int32_t	tcps_ecn_lost_syn;
	u_int32_t	tcps_ecn_lost_synack;
	u_int32_t	tcps_ecn_recv_ce;
	u_int32_t	tcps_ecn_recv_ece;
	u_int32_t	tcps_ecn_sent_ece;
	u_int32_t	tcps_ecn_conn_recv_ce;
	u_int32_t	tcps_ecn_conn_recv_ece;
	u_int32_t	tcps_ecn_conn_plnoce;
	u_int32_t	tcps_ecn_conn_pl_ce;
	u_int32_t	tcps_ecn_conn_nopl_ce;

	<span class="enscript-comment">/* TFO-related statistics */</span>
	u_int32_t	tcps_tfo_syn_data_rcv;
	u_int32_t	tcps_tfo_cookie_req_rcv;
	u_int32_t	tcps_tfo_cookie_sent;
	u_int32_t	tcps_tfo_cookie_invalid;
	u_int32_t	tcps_tfo_cookie_req;
	u_int32_t	tcps_tfo_cookie_rcv;
	u_int32_t	tcps_tfo_syn_data_sent;
	u_int32_t	tcps_tfo_syn_data_acked;
	u_int32_t	tcps_tfo_syn_loss;
	u_int32_t	tcps_tfo_blackhole;
};


<span class="enscript-comment">/* Returns true if the timer is on the timer list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIMER_IS_ON_LIST</span>(tp) ((tp)-&gt;t_flags &amp; TF_TIMER_ONLIST)

<span class="enscript-comment">/* Run the TCP timerlist atleast once every hour */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_TIMERLIST_MAX_OFFSET</span> (60 * 60 * TCP_RETRANSHZ)


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">add_to_time_wait_locked</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t delay);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">tcp_garbage_collect</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 * Add to tcp timewait list, delay is given in milliseconds.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">add_to_time_wait_locked</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t delay)
{
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = &amp;tcbinfo;
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	uint32_t timer;

	<span class="enscript-comment">/* pcb list should be locked when we get here */</span>
	lck_rw_assert(pcbinfo-&gt;ipi_lock, LCK_RW_ASSERT_EXCLUSIVE);

	<span class="enscript-comment">/* We may get here multiple times, so check */</span>
	<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags2 &amp; INP2_TIMEWAIT)) {
		pcbinfo-&gt;ipi_twcount++;
		inp-&gt;inp_flags2 |= INP2_TIMEWAIT;
		
		<span class="enscript-comment">/* Remove from global inp list */</span>
		LIST_REMOVE(inp, inp_list);
	} <span class="enscript-keyword">else</span> {
		TAILQ_REMOVE(&amp;tcp_tw_tailq, tp, t_twentry);
	}

	<span class="enscript-comment">/* Compute the time at which this socket can be closed */</span>
	timer = tcp_now + delay;
	
	<span class="enscript-comment">/* We will use the TCPT_2MSL timer for tracking this delay */</span>

	<span class="enscript-keyword">if</span> (TIMER_IS_ON_LIST(tp))
		tcp_remove_timer(tp);
	tp-&gt;t_timer[TCPT_2MSL] = timer;

	TAILQ_INSERT_TAIL(&amp;tcp_tw_tailq, tp, t_twentry);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">add_to_time_wait</span>(<span class="enscript-type">struct</span> tcpcb *tp, uint32_t delay)
{
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = &amp;tcbinfo;
	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_NOWAKEFROMSLEEP)
		socket_post_kev_msg_closed(tp-&gt;t_inpcb-&gt;inp_socket);

	<span class="enscript-comment">/* 19182803: Notify nstat that connection is closing before waiting. */</span>
	nstat_pcb_detach(tp-&gt;t_inpcb);

	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(pcbinfo-&gt;ipi_lock)) {
		tcp_unlock(tp-&gt;t_inpcb-&gt;inp_socket, 0, 0);
		lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);
		tcp_lock(tp-&gt;t_inpcb-&gt;inp_socket, 0, 0);
	}
	add_to_time_wait_locked(tp, delay);
	lck_rw_done(pcbinfo-&gt;ipi_lock);

	inpcb_gc_sched(pcbinfo, INPCB_TIMER_LAZY);
}

<span class="enscript-comment">/* If this is on time wait queue, remove it. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_remove_from_time_wait</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_TIMEWAIT)
		TAILQ_REMOVE(&amp;tcp_tw_tailq, tp, t_twentry);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">tcp_garbage_collect</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> istimewait)
{
	boolean_t active = FALSE;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> tcpcb *tp;

	so = inp-&gt;inp_socket;
	tp = intotcpcb(inp);

	<span class="enscript-comment">/*
	 * Skip if still in use or busy; it would have been more efficient
	 * if we were to test so_usecount against 0, but this isn't possible
	 * due to the current implementation of tcp_dropdropablreq() where
	 * overflow sockets that are eligible for garbage collection have
	 * their usecounts set to 1.
	 */</span>
	<span class="enscript-keyword">if</span> (!lck_mtx_try_lock_spin(&amp;inp-&gt;inpcb_mtx))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-comment">/* Check again under the lock */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &gt; 1) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt == WNT_STOPUSING)
			active = TRUE;
		lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
		<span class="enscript-keyword">return</span> (active);
	}

	<span class="enscript-keyword">if</span> (istimewait &amp;&amp;
		TSTMP_GEQ(tcp_now, tp-&gt;t_timer[TCPT_2MSL]) &amp;&amp;
		tp-&gt;t_state != TCPS_CLOSED) {
		<span class="enscript-comment">/* Become a regular mutex */</span>
		lck_mtx_convert_spin(&amp;inp-&gt;inpcb_mtx);
		tcp_close(tp);
	}

	<span class="enscript-comment">/*
	 * Overflowed socket dropped from the listening queue?  Do this
	 * only if we are called to clean up the time wait slots, since
	 * tcp_dropdropablreq() considers a socket to have been fully
	 * dropped after add_to_time_wait() is finished.
	 * Also handle the case of connections getting closed by the peer
	 * while in the queue as seen with rdar://6422317
	 *
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 1 &amp;&amp;
	    ((istimewait &amp;&amp; (so-&gt;so_flags &amp; SOF_OVERFLOW)) ||
	    ((tp != NULL) &amp;&amp; (tp-&gt;t_state == TCPS_CLOSED) &amp;&amp;
	    (so-&gt;so_head != NULL) &amp;&amp;
	    ((so-&gt;so_state &amp; (SS_INCOMP|SS_CANTSENDMORE|SS_CANTRCVMORE)) ==
	    (SS_INCOMP|SS_CANTSENDMORE|SS_CANTRCVMORE))))) {

		<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD) {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			lck_mtx_convert_spin(&amp;inp-&gt;inpcb_mtx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
				in6_pcbdetach(inp);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				in_pcbdetach(inp);
		}
		so-&gt;so_usecount--;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt == WNT_STOPUSING)
			active = TRUE;
		lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
		<span class="enscript-keyword">return</span> (active);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt != WNT_STOPUSING) {
		lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-comment">/*
	 * We get here because the PCB is no longer searchable 
	 * (WNT_STOPUSING); detach (if needed) and dispose if it is dead 
	 * (usecount is 0).  This covers all cases, including overflow 
	 * sockets and those that are considered as &quot;embryonic&quot;, 
	 * i.e. created by sonewconn() in TCP input path, and have 
	 * not yet been committed.  For the former, we reduce the usecount
	 *  to 0 as done by the code above.  For the latter, the usecount 
	 * would have reduced to 0 as part calling soabort() when the
	 * socket is dropped at the end of tcp_input().
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
		DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
			<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_CLOSED);
		<span class="enscript-comment">/* Become a regular mutex */</span>
		lck_mtx_convert_spin(&amp;inp-&gt;inpcb_mtx);

		<span class="enscript-comment">/*
		 * If this tp still happens to be on the timer list, 
		 * take it out
		 */</span>
		<span class="enscript-keyword">if</span> (TIMER_IS_ON_LIST(tp)) {
			tcp_remove_timer(tp);
		}

		<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
				in6_pcbdetach(inp);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				in_pcbdetach(inp);
		}
		in_pcbdispose(inp);
		<span class="enscript-keyword">return</span> (FALSE);
	}

	lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 * TCP garbage collector callback (inpcb_timer_func_t).
 *
 * Returns the number of pcbs that will need to be gc-ed soon,
 * returnining &gt; 0 will keep timer active.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_gc</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi)
{
	<span class="enscript-type">struct</span> inpcb *inp, *nxt;
	<span class="enscript-type">struct</span> tcpcb *tw_tp, *tw_ntp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-type">int</span> ostate;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">KDEBUG</span>
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> tws_checked = 0;
#<span class="enscript-reference">endif</span>

	KERNEL_DEBUG(DBG_FNC_TCP_SLOW | DBG_FUNC_START, 0, 0, 0, 0, 0);

	<span class="enscript-comment">/*
	 * Update tcp_now here as it may get used while
	 * processing the slow timer.
	 */</span>
	calculate_tcp_clock();

	<span class="enscript-comment">/*
	 * Garbage collect socket/tcpcb: We need to acquire the list lock
	 * exclusively to do this
	 */</span>

	<span class="enscript-keyword">if</span> (lck_rw_try_lock_exclusive(ipi-&gt;ipi_lock) == FALSE) {
		<span class="enscript-comment">/* don't sweat it this time; cleanup was done last time */</span>
		<span class="enscript-keyword">if</span> (tcp_gc_done == TRUE) {
			tcp_gc_done = FALSE;
			KERNEL_DEBUG(DBG_FNC_TCP_SLOW | DBG_FUNC_END,
			    tws_checked, cur_tw_slot, 0, 0, 0);
			<span class="enscript-comment">/* Lock upgrade failed, give up this round */</span>
			atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/* Upgrade failed, lost lock now take it again exclusive */</span>
		lck_rw_lock_exclusive(ipi-&gt;ipi_lock);
	}
	tcp_gc_done = TRUE;

	LIST_FOREACH_SAFE(inp, &amp;tcb, inp_list, nxt) {
		<span class="enscript-keyword">if</span> (tcp_garbage_collect(inp, 0))
			atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
	}

	<span class="enscript-comment">/* Now cleanup the time wait ones */</span>
	TAILQ_FOREACH_SAFE(tw_tp, &amp;tcp_tw_tailq, t_twentry, tw_ntp) {
		<span class="enscript-comment">/*
		 * We check the timestamp here without holding the 
		 * socket lock for better performance. If there are
		 * any pcbs in time-wait, the timer will get rescheduled.
		 * Hence some error in this check can be tolerated.
		 *
		 * Sometimes a socket on time-wait queue can be closed if
		 * 2MSL timer expired but the application still has a
		 * usecount on it. 
		 */</span>
		<span class="enscript-keyword">if</span> (tw_tp-&gt;t_state == TCPS_CLOSED ||  
		    TSTMP_GEQ(tcp_now, tw_tp-&gt;t_timer[TCPT_2MSL])) {
			<span class="enscript-keyword">if</span> (tcp_garbage_collect(tw_tp-&gt;t_inpcb, 1))
				atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_lazy, 1);
		}
	}

	<span class="enscript-comment">/* take into account pcbs that are still in time_wait_slots */</span>
	atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_lazy, ipi-&gt;ipi_twcount);

	lck_rw_done(ipi-&gt;ipi_lock);

	<span class="enscript-comment">/* Clean up the socache while we are here */</span>
	<span class="enscript-keyword">if</span> (so_cache_timer())
		atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_lazy, 1);

	KERNEL_DEBUG(DBG_FNC_TCP_SLOW | DBG_FUNC_END, tws_checked,
	    cur_tw_slot, 0, 0, 0);

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Cancel all timers for TCP tp.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_canceltimers</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;

	tcp_remove_timer(tp);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; TCPT_NTIMERS; i++)
		tp-&gt;t_timer[i] = 0;
	tp-&gt;tentry.timer_start = tcp_now;
	tp-&gt;tentry.index = TCPT_NONE;
}

<span class="enscript-type">int</span>	tcp_syn_backoff[TCP_MAXRXTSHIFT + 1] =
    { 1, 1, 1, 1, 1, 2, 4, 8, 16, 32, 64, 64, 64 };

<span class="enscript-type">int</span>	tcp_backoff[TCP_MAXRXTSHIFT + 1] =
    { 1, 2, 4, 8, 16, 32, 64, 64, 64, 64, 64, 64, 64 };

<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_totbackoff = 511;	<span class="enscript-comment">/* sum of tcp_backoff[] */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_rexmt_save_state</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	u_int32_t fsize;
	<span class="enscript-keyword">if</span> (TSTMP_SUPPORTED(tp)) {
		<span class="enscript-comment">/*
		 * Since timestamps are supported on the connection, 
		 * we can do recovery as described in rfc 4015.
		 */</span>
		fsize = tp-&gt;snd_max - tp-&gt;snd_una;
		tp-&gt;snd_ssthresh_prev = max(fsize, tp-&gt;snd_ssthresh);
		tp-&gt;snd_recover_prev = tp-&gt;snd_recover;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Timestamp option is not supported on this connection.
		 * Record ssthresh and cwnd so they can
		 * be recovered if this turns out to be a &quot;bad&quot; retransmit.
		 * A retransmit is considered &quot;bad&quot; if an ACK for this 
		 * segment is received within RTT/2 interval; the assumption
		 * here is that the ACK was already in flight.  See 
		 * &quot;On Estimating End-to-End Network Path Properties&quot; by
		 * Allman and Paxson for more details.
		 */</span>
		tp-&gt;snd_cwnd_prev = tp-&gt;snd_cwnd;
		tp-&gt;snd_ssthresh_prev = tp-&gt;snd_ssthresh;
		tp-&gt;snd_recover_prev = tp-&gt;snd_recover;
		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp))
			tp-&gt;t_flags |= TF_WASFRECOVERY;
		<span class="enscript-keyword">else</span>
			tp-&gt;t_flags &amp;= ~TF_WASFRECOVERY;
	}
	tp-&gt;t_srtt_prev = (tp-&gt;t_srtt &gt;&gt; TCP_RTT_SHIFT) + 2;
	tp-&gt;t_rttvar_prev = (tp-&gt;t_rttvar &gt;&gt; TCP_RTTVAR_SHIFT);
	tp-&gt;t_flagsext &amp;= ~(TF_RECOMPUTE_RTT);
}

<span class="enscript-comment">/*
 * Revert to the older segment size if there is an indication that PMTU
 * blackhole detection was not needed.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_pmtud_revert_segment_size</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	int32_t optlen;

	VERIFY(tp-&gt;t_pmtud_saved_maxopd &gt; 0);
	tp-&gt;t_flags |= TF_PMTUD; 
	tp-&gt;t_flags &amp;= ~TF_BLACKHOLE; 
	optlen = tp-&gt;t_maxopd - tp-&gt;t_maxseg;
	tp-&gt;t_maxopd = tp-&gt;t_pmtud_saved_maxopd;
	tp-&gt;t_maxseg = tp-&gt;t_maxopd - optlen;
	<span class="enscript-comment">/*
	 * Reset the slow-start flight size as it 
	 * may depend on the new MSS
	 */</span>
	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cwnd_init != NULL)
		CC_ALGO(tp)-&gt;cwnd_init(tp);
	tp-&gt;t_pmtud_start_ts = 0;
	tcpstat.tcps_pmtudbh_reverted++;
}

<span class="enscript-comment">/*
 * TCP timer processing.
 */</span>
<span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_timers</span>(tp, timer)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">int</span> timer;
{
	int32_t rexmt, optlen = 0, idle_time = 0;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> tcptemp *t_template;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-type">int</span> ostate;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = (tp-&gt;t_inpcb-&gt;inp_vflag &amp; INP_IPV4) == 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	u_int64_t accsleep_ms;
	u_int32_t last_sleep_ms = 0;

	so = tp-&gt;t_inpcb-&gt;inp_socket;
	idle_time = tcp_now - tp-&gt;t_rcvtime;

	<span class="enscript-keyword">switch</span> (timer) {

	<span class="enscript-comment">/*
	 * 2 MSL timeout in shutdown went off.  If we're closed but
	 * still waiting for peer to close and connection has been idle
	 * too long, or if 2MSL time is up from TIME_WAIT or FIN_WAIT_2,
	 * delete connection control block.
	 * Otherwise, (this case shouldn't happen) check again in a bit
	 * we keep the socket in the main list in that case.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_2MSL</span>:
		tcp_free_sackholes(tp);
		<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_TIME_WAIT &amp;&amp;
		    tp-&gt;t_state != TCPS_FIN_WAIT_2 &amp;&amp;
		    ((idle_time &gt; 0) &amp;&amp; (idle_time &lt; TCP_CONN_MAXIDLE(tp)))) {
			tp-&gt;t_timer[TCPT_2MSL] = OFFSET_FROM_START(tp, 
				(u_int32_t)TCP_CONN_KEEPINTVL(tp));
		} <span class="enscript-keyword">else</span> {
			tp = tcp_close(tp);
			<span class="enscript-keyword">return</span>(tp);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/*
	 * Retransmission timer went off.  Message has not
	 * been acked within retransmit interval.  Back off
	 * to a longer retransmit interval and retransmit one segment.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_REXMT</span>:
		accsleep_ms = mach_absolutetime_asleep / 1000000UL;
		<span class="enscript-keyword">if</span> (accsleep_ms &gt; tp-&gt;t_accsleep_ms)
			last_sleep_ms = accsleep_ms - tp-&gt;t_accsleep_ms;
		<span class="enscript-comment">/*
		 * Drop a connection in the retransmit timer
		 * 1. If we have retransmitted more than TCP_MAXRXTSHIFT
		 * times
		 * 2. If the time spent in this retransmission episode is
		 * more than the time limit set with TCP_RXT_CONNDROPTIME
		 * socket option
		 * 3. If TCP_RXT_FINDROP socket option was set and
		 * we have already retransmitted the FIN 3 times without
		 * receiving an ack
		 */</span>
		<span class="enscript-keyword">if</span> (++tp-&gt;t_rxtshift &gt; TCP_MAXRXTSHIFT ||
		    (tp-&gt;t_rxt_conndroptime &gt; 0 &amp;&amp; tp-&gt;t_rxtstart &gt; 0 &amp;&amp;
		    (tcp_now - tp-&gt;t_rxtstart) &gt;= tp-&gt;t_rxt_conndroptime) ||
		    ((tp-&gt;t_flagsext &amp; TF_RXTFINDROP) != 0 &amp;&amp;
		    (tp-&gt;t_flags &amp; TF_SENTFIN) != 0 &amp;&amp; tp-&gt;t_rxtshift &gt;= 4) ||
		    (tp-&gt;t_rxtshift &gt; 4 &amp;&amp; last_sleep_ms &gt;= TCP_SLEEP_TOO_LONG)) {
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_RXTFINDROP) != 0) {
				tcpstat.tcps_rxtfindrop++;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (last_sleep_ms &gt;= TCP_SLEEP_TOO_LONG) {
				tcpstat.tcps_drop_after_sleep++;
			} <span class="enscript-keyword">else</span> {
				tcpstat.tcps_timeoutdrop++;
			}
			tp-&gt;t_rxtshift = TCP_MAXRXTSHIFT;
			postevent(so, 0, EV_TIMEOUT);			
			soevent(so, 
			    (SO_FILT_HINT_LOCKED|SO_FILT_HINT_TIMEOUT));
			tp = tcp_drop(tp, tp-&gt;t_softerror ?
			    tp-&gt;t_softerror : ETIMEDOUT);

			<span class="enscript-keyword">break</span>;
		}

		tcpstat.tcps_rexmttimeo++;
		tp-&gt;t_accsleep_ms = accsleep_ms;

		<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift == 1 &amp;&amp; 
			tp-&gt;t_state == TCPS_ESTABLISHED) {
			<span class="enscript-comment">/* Set the time at which retransmission started. */</span>
			tp-&gt;t_rxtstart = tcp_now;

			<span class="enscript-comment">/* 
			 * if this is the first retransmit timeout, save
			 * the state so that we can recover if the timeout
			 * is spurious.
			 */</span> 
			tcp_rexmt_save_state(tp);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_rxtshift &gt;= mptcp_fail_thresh) &amp;&amp;
		    (tp-&gt;t_state == TCPS_ESTABLISHED) &amp;&amp;
		    (tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE)) {
			mptcp_act_on_txfail(so);

		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

		<span class="enscript-keyword">if</span> (tp-&gt;t_adaptive_wtimo &gt; 0 &amp;&amp;
			tp-&gt;t_rxtshift &gt; tp-&gt;t_adaptive_wtimo &amp;&amp;
			TCPS_HAVEESTABLISHED(tp-&gt;t_state)) {
			<span class="enscript-comment">/* Send an event to the application */</span>
			soevent(so,
				(SO_FILT_HINT_LOCKED|
				SO_FILT_HINT_ADAPTIVE_WTIMO));
		}

		<span class="enscript-comment">/*
		 * If this is a retransmit timeout after PTO, the PTO
		 * was not effective
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_SENT_TLPROBE) {
			tp-&gt;t_flagsext &amp;= ~(TF_SENT_TLPROBE);
			tcpstat.tcps_rto_after_pto++;
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_DELAY_RECOVERY) {
			<span class="enscript-comment">/*
			 * Retransmit timer fired before entering recovery
			 * on a connection with packet re-ordering. This
			 * suggests that the reordering metrics computed
			 * are not accurate.
			 */</span>
			tp-&gt;t_reorderwin = 0;
			tp-&gt;t_timer[TCPT_DELAYFR] = 0;
			tp-&gt;t_flagsext &amp;= ~(TF_DELAY_RECOVERY);
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_RECEIVED)
			tcp_disable_tfo(tp);

		<span class="enscript-keyword">if</span> ((tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_SENT) &amp;&amp;
		    !(tp-&gt;t_tfo_flags &amp; TFO_F_NO_SNDPROBING) &amp;&amp;
		    ((tp-&gt;t_state != TCPS_SYN_SENT &amp;&amp; tp-&gt;t_rxtshift &gt; 1) ||
		     tp-&gt;t_rxtshift &gt; 2)) {
			<span class="enscript-comment">/*
			 * For regular retransmissions, a first one is being
			 * done for tail-loss probe.
			 * Thus, if rxtshift &gt; 1, this means we have sent the segment
			 * a total of 3 times.
			 *
			 * If we are in SYN-SENT state, then there is no tail-loss
			 * probe thus we have to let rxtshift go up to 3.
			 */</span>
			tcp_heuristic_tfo_middlebox(tp);

			so-&gt;so_error = ENODATA;
			sorwakeup(so);
			sowwakeup(so);
		}

		<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_SENT) {
			rexmt = TCP_REXMTVAL(tp) * tcp_syn_backoff[tp-&gt;t_rxtshift];
			tp-&gt;t_stat.synrxtshift = tp-&gt;t_rxtshift;

			<span class="enscript-comment">/* When retransmitting, disable TFO */</span>
			<span class="enscript-keyword">if</span> (tfo_enabled(tp)) {
				tp-&gt;t_flagsext &amp;= ~TF_FASTOPEN;
				tp-&gt;t_tfo_flags |= TFO_F_SYN_LOSS;

				tp-&gt;t_tfo_stats |= TFO_S_SYN_LOSS;
				tcpstat.tcps_tfo_syn_loss++;
			}
		} <span class="enscript-keyword">else</span> {
			rexmt = TCP_REXMTVAL(tp) * tcp_backoff[tp-&gt;t_rxtshift];
		}

		TCPT_RANGESET(tp-&gt;t_rxtcur, rexmt,
			tp-&gt;t_rttmin, TCPTV_REXMTMAX, 
			TCP_ADD_REXMTSLOP(tp));
		tp-&gt;t_timer[TCPT_REXMT] = OFFSET_FROM_START(tp, tp-&gt;t_rxtcur);

		<span class="enscript-keyword">if</span> (INP_WAIT_FOR_IF_FEEDBACK(tp-&gt;t_inpcb))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fc_output</span>;

		tcp_free_sackholes(tp);
		<span class="enscript-comment">/*
		 * Check for potential Path MTU Discovery Black Hole
		 */</span>
		<span class="enscript-keyword">if</span> (tcp_pmtud_black_hole_detect &amp;&amp;
			!(tp-&gt;t_flagsext &amp; TF_NOBLACKHOLE_DETECTION) &amp;&amp;
			(tp-&gt;t_state == TCPS_ESTABLISHED)) {
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_PMTUD) &amp;&amp;
			    ((tp-&gt;t_flags &amp; TF_MAXSEGSNT)
			    || tp-&gt;t_pmtud_lastseg_size &gt; tcp_pmtud_black_hole_mss) &amp;&amp;
			    tp-&gt;t_rxtshift == 2) {
				<span class="enscript-comment">/* 
				 * Enter Path MTU Black-hole Detection mechanism:
				 * - Disable Path MTU Discovery (IP &quot;DF&quot; bit).
				 * - Reduce MTU to lower value than what we
				 * negotiated with the peer.
				 */</span>
				<span class="enscript-comment">/* Disable Path MTU Discovery for now */</span>
				tp-&gt;t_flags &amp;= ~TF_PMTUD;
				<span class="enscript-comment">/* Record that we may have found a black hole */</span>
				tp-&gt;t_flags |= TF_BLACKHOLE;
				optlen = tp-&gt;t_maxopd - tp-&gt;t_maxseg;
				<span class="enscript-comment">/* Keep track of previous MSS */</span>
				tp-&gt;t_pmtud_saved_maxopd = tp-&gt;t_maxopd;
				tp-&gt;t_pmtud_start_ts = tcp_now;
				<span class="enscript-keyword">if</span> (tp-&gt;t_pmtud_start_ts == 0)
					tp-&gt;t_pmtud_start_ts++;
				<span class="enscript-comment">/* Reduce the MSS to intermediary value */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;t_maxopd &gt; tcp_pmtud_black_hole_mss) {
					tp-&gt;t_maxopd = tcp_pmtud_black_hole_mss;
				} <span class="enscript-keyword">else</span> {
					tp-&gt;t_maxopd = 	<span class="enscript-comment">/* use the default MSS */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
						isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
							tcp_mssdflt;
				}
				tp-&gt;t_maxseg = tp-&gt;t_maxopd - optlen;

				<span class="enscript-comment">/*
	 			 * Reset the slow-start flight size 
				 * as it may depend on the new MSS
	 			 */</span>
				<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cwnd_init != NULL)
					CC_ALGO(tp)-&gt;cwnd_init(tp);
			}
			<span class="enscript-comment">/*
			 * If further retransmissions are still
			 * unsuccessful with a lowered MTU, maybe this
			 * isn't a Black Hole and we restore the previous
			 * MSS and blackhole detection flags.
			 */</span>
			<span class="enscript-keyword">else</span> {
	
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_BLACKHOLE) &amp;&amp;
				    (tp-&gt;t_rxtshift &gt; 4)) {
					tcp_pmtud_revert_segment_size(tp);
				}
			}
		}


		<span class="enscript-comment">/*
		 * Disable rfc1323 and rfc1644 if we haven't got any
		 * response to our SYN (after we reach the threshold)
		 * to work-around some broken terminal servers (most of
		 * which have hopefully been retired) that have bad VJ
		 * header compression code which trashes TCP segments
		 * containing unknown-to-them TCP options.
		 * Do this only on non-local connections.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_SENT &amp;&amp;
		    tp-&gt;t_rxtshift == tcp_broken_peer_syn_rxmit_thres)
			tp-&gt;t_flags &amp;= ~(TF_REQ_SCALE|TF_REQ_TSTMP|TF_REQ_CC);

		<span class="enscript-comment">/*
		 * If losing, let the lower level know and try for
		 * a better route.  Also, if we backed off this far,
		 * our srtt estimate is probably bogus.  Clobber it
		 * so we'll take the next rtt measurement as our srtt;
		 * move the current srtt into rttvar to keep the current
		 * retransmit times until then.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &gt; TCP_MAXRXTSHIFT / 4) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6)
				in6_losing(tp-&gt;t_inpcb);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			in_losing(tp-&gt;t_inpcb);
			tp-&gt;t_rttvar += (tp-&gt;t_srtt &gt;&gt; TCP_RTT_SHIFT);
			tp-&gt;t_srtt = 0;
		}
		tp-&gt;snd_nxt = tp-&gt;snd_una;
		<span class="enscript-comment">/*
		 * Note:  We overload snd_recover to function also as the
		 * snd_last variable described in RFC 2582
		 */</span>
		tp-&gt;snd_recover = tp-&gt;snd_max;
		<span class="enscript-comment">/*
		 * Force a segment to be sent.
		 */</span>
		tp-&gt;t_flags |= TF_ACKNOW;

		<span class="enscript-comment">/* If timing a segment in this window, stop the timer */</span>
		tp-&gt;t_rtttime = 0;

		<span class="enscript-keyword">if</span> (!IN_FASTRECOVERY(tp) &amp;&amp; tp-&gt;t_rxtshift == 1)
			tcpstat.tcps_tailloss_rto++;


		<span class="enscript-comment">/*
		 * RFC 5681 says: when a TCP sender detects segment loss
		 * using retransmit timer and the given segment has already
		 * been retransmitted by way of the retransmission timer at
		 * least once, the value of ssthresh is held constant
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift == 1 &amp;&amp; 
		    CC_ALGO(tp)-&gt;after_timeout != NULL) {
			CC_ALGO(tp)-&gt;after_timeout(tp);
			<span class="enscript-comment">/*
			 * CWR notifications are to be sent on new data
			 * right after Fast Retransmits and ECE
			 * notification receipts.
			 */</span>
			<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp))
				tp-&gt;ecn_flags |= TE_SENDCWR;
		}

		EXIT_FASTRECOVERY(tp);

		<span class="enscript-comment">/* Exit cwnd non validated phase */</span>
		tp-&gt;t_flagsext &amp;= ~TF_CWND_NONVALIDATED;


<span class="enscript-reference">fc_output</span>:
		tcp_ccdbg_trace(tp, NULL, TCP_CC_REXMT_TIMEOUT);

		(<span class="enscript-type">void</span>) tcp_output(tp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/*
	 * Persistance timer into zero window.
	 * Force a byte to be output, if possible.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_PERSIST</span>:
		tcpstat.tcps_persisttimeo++;
		<span class="enscript-comment">/*
		 * Hack: if the peer is dead/unreachable, we do not
		 * time out if the window is closed.  After a full
		 * backoff, drop the connection if the idle time
		 * (no responses to probes) reaches the maximum
		 * backoff that we would use if retransmitting.
		 * 
		 * Drop the connection if we reached the maximum allowed time for 
		 * Zero Window Probes without a non-zero update from the peer. 
		 * See rdar://5805356
		 */</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_rxtshift == TCP_MAXRXTSHIFT &amp;&amp;
		    (idle_time &gt;= tcp_maxpersistidle ||
		    idle_time &gt;= TCP_REXMTVAL(tp) * tcp_totbackoff)) || 
		    ((tp-&gt;t_persist_stop != 0) &amp;&amp; 
			TSTMP_LEQ(tp-&gt;t_persist_stop, tcp_now))) {
			tcpstat.tcps_persistdrop++;
			postevent(so, 0, EV_TIMEOUT);
			soevent(so,
			    (SO_FILT_HINT_LOCKED|SO_FILT_HINT_TIMEOUT));
			tp = tcp_drop(tp, ETIMEDOUT);
			<span class="enscript-keyword">break</span>;
		}
		tcp_setpersist(tp);
		tp-&gt;t_flagsext |= TF_FORCE;
		(<span class="enscript-type">void</span>) tcp_output(tp);
		tp-&gt;t_flagsext &amp;= ~TF_FORCE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/*
	 * Keep-alive timer went off; send something
	 * or drop connection if idle for too long.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_KEEP</span>:
		tcpstat.tcps_keeptimeo++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-comment">/*
		 * Regular TCP connections do not send keepalives after closing
		 * MPTCP must not also, after sending Data FINs.
		 */</span>
		<span class="enscript-type">struct</span> mptcb *mp_tp = tp-&gt;t_mptcb;
		<span class="enscript-keyword">if</span> ((tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) &amp;&amp;
		    (tp-&gt;t_state &gt; TCPS_ESTABLISHED)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp_tp != NULL) {
			<span class="enscript-keyword">if</span> ((mptcp_ok_to_keepalive(mp_tp) == 0))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_state &lt; TCPS_ESTABLISHED)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
		<span class="enscript-keyword">if</span> ((always_keepalive ||
		    (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_KEEPALIVE) ||
		    (tp-&gt;t_flagsext &amp; TF_DETECT_READSTALL) ||
		    (tp-&gt;t_tfo_probe_state == TFO_PROBE_PROBING)) &amp;&amp;
		    (tp-&gt;t_state &lt;= TCPS_CLOSING || tp-&gt;t_state == TCPS_FIN_WAIT_2)) {
		    	<span class="enscript-keyword">if</span> (idle_time &gt;= TCP_CONN_KEEPIDLE(tp) + TCP_CONN_MAXIDLE(tp))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
			<span class="enscript-comment">/*
			 * Send a packet designed to force a response
			 * if the peer is up and reachable:
			 * either an ACK if the connection is still alive,
			 * or an RST if the peer has closed the connection
			 * due to timeout or reboot.
			 * Using sequence number tp-&gt;snd_una-1
			 * causes the transmitted zero-length segment
			 * to lie outside the receive window;
			 * by the protocol spec, this requires the
			 * correspondent TCP to respond.
			 */</span>
			tcpstat.tcps_keepprobe++;
			t_template = tcp_maketemplate(tp);
			<span class="enscript-keyword">if</span> (t_template) {
				<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
				<span class="enscript-type">struct</span> tcp_respond_args tra;

				bzero(&amp;tra, <span class="enscript-keyword">sizeof</span>(tra));
				tra.nocell = INP_NO_CELLULAR(inp);
				tra.noexpensive = INP_NO_EXPENSIVE(inp);
				tra.awdl_unrestricted = INP_AWDL_UNRESTRICTED(inp);
				<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_flags &amp; INP_BOUND_IF)
					tra.ifscope = tp-&gt;t_inpcb-&gt;inp_boundifp-&gt;if_index;
				<span class="enscript-keyword">else</span>
					tra.ifscope = IFSCOPE_NONE;
				tcp_respond(tp, t_template-&gt;tt_ipgen,
				    &amp;t_template-&gt;tt_t, (<span class="enscript-type">struct</span> mbuf *)NULL,
				    tp-&gt;rcv_nxt, tp-&gt;snd_una - 1, 0, &amp;tra);
				(<span class="enscript-type">void</span>) m_free(dtom(t_template));
				<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_DETECT_READSTALL)
					tp-&gt;t_rtimo_probes++;
			}
			tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
			    TCP_CONN_KEEPINTVL(tp));
		} <span class="enscript-keyword">else</span> {
			tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
			    TCP_CONN_KEEPIDLE(tp));
		}
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_DETECT_READSTALL) {
			<span class="enscript-type">struct</span> ifnet *outifp = tp-&gt;t_inpcb-&gt;inp_last_outifp;
			bool reenable_probe = false;
			<span class="enscript-comment">/* 
			 * The keep alive packets sent to detect a read
			 * stall did not get a response from the 
			 * peer. Generate more keep-alives to confirm this.
			 * If the number of probes sent reaches the limit,
			 * generate an event.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;t_adaptive_rtimo &gt; 0) {
				<span class="enscript-keyword">if</span> (tp-&gt;t_rtimo_probes &gt; tp-&gt;t_adaptive_rtimo) {
					<span class="enscript-comment">/* Generate an event */</span>
					soevent(so,
					    (SO_FILT_HINT_LOCKED |
					    SO_FILT_HINT_ADAPTIVE_RTIMO));
					tcp_keepalive_reset(tp);
				} <span class="enscript-keyword">else</span> {
					reenable_probe = true;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (outifp != NULL &amp;&amp;
			    (outifp-&gt;if_eflags &amp; IFEF_PROBE_CONNECTIVITY) &amp;&amp;
			    tp-&gt;t_rtimo_probes &lt;= TCP_CONNECTIVITY_PROBES_MAX) {
				reenable_probe = true;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_flagsext &amp;= ~TF_DETECT_READSTALL;
			}
			<span class="enscript-keyword">if</span> (reenable_probe) {
				<span class="enscript-type">int</span> ind = min(tp-&gt;t_rtimo_probes,
				    TCP_MAXRXTSHIFT);
				tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(
				    tp, tcp_backoff[ind] * TCP_REXMTVAL(tp));
			}
		}
		<span class="enscript-keyword">if</span> (tp-&gt;t_tfo_probe_state == TFO_PROBE_PROBING) {
			<span class="enscript-type">int</span> ind;

			tp-&gt;t_tfo_probes++;
			ind = min(tp-&gt;t_tfo_probes, TCP_MAXRXTSHIFT);

			<span class="enscript-comment">/*
			 * We take the minimum among the time set by true
			 * keepalive (see above) and the backoff'd RTO. That
			 * way we backoff in case of packet-loss but will never
			 * timeout slower than regular keepalive due to the
			 * backing off.
			 */</span>
			tp-&gt;t_timer[TCPT_KEEP] = min(OFFSET_FROM_START(
			    tp, tcp_backoff[ind] * TCP_REXMTVAL(tp)),
			    tp-&gt;t_timer[TCPT_KEEP]);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_tfo_probe_state == TFO_PROBE_WAIT_DATA) {
			<span class="enscript-comment">/* Still no data! Let's assume a TFO-error and err out... */</span>
			tcp_heuristic_tfo_middlebox(tp);

			so-&gt;so_error = ENODATA;
			sorwakeup(so);
			tcpstat.tcps_tfo_blackhole++;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_DELACK</span>:
		<span class="enscript-keyword">if</span> (tcp_delack_enabled &amp;&amp; (tp-&gt;t_flags &amp; TF_DELACK)) {
			tp-&gt;t_flags &amp;= ~TF_DELACK;
			tp-&gt;t_timer[TCPT_DELACK] = 0;
			tp-&gt;t_flags |= TF_ACKNOW;

			<span class="enscript-comment">/*
			 * If delayed ack timer fired while stretching
			 * acks, count the number of times the streaming
			 * detection was not correct. If this exceeds a 
			 * threshold, disable strech ack on this
			 * connection
			 *
			 * Also, go back to acking every other packet.
			 */</span>
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_STRETCHACK)) {
				<span class="enscript-keyword">if</span> (tp-&gt;t_unacksegs &gt; 1 &amp;&amp;
				    tp-&gt;t_unacksegs &lt; maxseg_unacked)
					tp-&gt;t_stretchack_delayed++;

				<span class="enscript-keyword">if</span> (tp-&gt;t_stretchack_delayed &gt;
					TCP_STRETCHACK_DELAY_THRESHOLD) {
					tp-&gt;t_flagsext |= TF_DISABLE_STRETCHACK;
					<span class="enscript-comment">/*
					 * Note the time at which stretch
					 * ack was disabled automatically
					 */</span>
					tp-&gt;rcv_nostrack_ts = tcp_now;
					tcpstat.tcps_nostretchack++;
					tp-&gt;t_stretchack_delayed = 0;
				}
				tcp_reset_stretch_ack(tp);
			}

			<span class="enscript-comment">/*
			 * If we are measuring inter packet arrival jitter
			 * for throttling a connection, this delayed ack
			 * might be the reason for accumulating some
			 * jitter. So let's restart the measurement.
			 */</span>
			CLEAR_IAJ_STATE(tp);

			tcpstat.tcps_delack++;
			(<span class="enscript-type">void</span>) tcp_output(tp);
		}
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_JACK_RXMT</span>:
		<span class="enscript-keyword">if</span> ((tp-&gt;t_state == TCPS_ESTABLISHED) &amp;&amp;
		    (tp-&gt;t_mpflags &amp; TMPF_PREESTABLISHED) &amp;&amp;
		    (tp-&gt;t_mpflags &amp; TMPF_JOINED_FLOW)) {
			<span class="enscript-keyword">if</span> (++tp-&gt;t_mprxtshift &gt; TCP_MAXRXTSHIFT) {
				tcpstat.tcps_timeoutdrop++;
				postevent(so, 0, EV_TIMEOUT);
				soevent(so, 
			    	    (SO_FILT_HINT_LOCKED|
				    SO_FILT_HINT_TIMEOUT));
				tp = tcp_drop(tp, tp-&gt;t_softerror ?
			    	    tp-&gt;t_softerror : ETIMEDOUT);
				<span class="enscript-keyword">break</span>;
			}
			tcpstat.tcps_join_rxmts++;
			tp-&gt;t_flags |= TF_ACKNOW;

			<span class="enscript-comment">/*
			 * No backoff is implemented for simplicity for this 
			 * corner case.
			 */</span>
			(<span class="enscript-type">void</span>) tcp_output(tp);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_PTO</span>:
	{
		int32_t snd_len;
		tp-&gt;t_flagsext &amp;= ~(TF_SENT_TLPROBE);

		<span class="enscript-comment">/*
		 * Check if the connection is in the right state to
		 * send a probe
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_ESTABLISHED ||
		    (tp-&gt;t_rxtshift &gt; 0 &amp;&amp; !(tp-&gt;t_flagsext &amp; TF_PROBING))
		    || tp-&gt;snd_max == tp-&gt;snd_una ||
		    !SACK_ENABLED(tp) || !TAILQ_EMPTY(&amp;tp-&gt;snd_holes) ||
		    IN_FASTRECOVERY(tp))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * If there is no new data to send or if the
		 * connection is limited by receive window then
		 * retransmit the last segment, otherwise send
		 * new data.
		 */</span>
		snd_len = min(so-&gt;so_snd.sb_cc, tp-&gt;snd_wnd)
		    - (tp-&gt;snd_max - tp-&gt;snd_una);
		<span class="enscript-keyword">if</span> (snd_len &gt; 0) {
			tp-&gt;snd_nxt = tp-&gt;snd_max;
		} <span class="enscript-keyword">else</span> {
			snd_len = min((tp-&gt;snd_max - tp-&gt;snd_una),
			    tp-&gt;t_maxseg);
			tp-&gt;snd_nxt = tp-&gt;snd_max - snd_len;
		}

		tcpstat.tcps_pto++;
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_PROBING)
			tcpstat.tcps_probe_if++;

		<span class="enscript-comment">/* If timing a segment in this window, stop the timer */</span>
		tp-&gt;t_rtttime = 0;
		<span class="enscript-comment">/* Note that tail loss probe is being sent */</span>
		tp-&gt;t_flagsext |= TF_SENT_TLPROBE;
		tp-&gt;t_tlpstart = tcp_now;

		tp-&gt;snd_cwnd += tp-&gt;t_maxseg;
		(<span class="enscript-type">void</span> )tcp_output(tp);
		tp-&gt;snd_cwnd -= tp-&gt;t_maxseg;

		tp-&gt;t_tlphighrxt = tp-&gt;snd_nxt;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPT_DELAYFR</span>:
		tp-&gt;t_flagsext &amp;= ~TF_DELAY_RECOVERY;

		<span class="enscript-comment">/*
		 * Don't do anything if one of the following is true:
		 * - the connection is already in recovery
		 * - sequence until snd_recover has been acknowledged.
		 * - retransmit timeout has fired
		 */</span>
		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp) ||
		    SEQ_GEQ(tp-&gt;snd_una, tp-&gt;snd_recover) ||
		    tp-&gt;t_rxtshift &gt; 0)
			<span class="enscript-keyword">break</span>;

		VERIFY(SACK_ENABLED(tp));
		tcp_rexmt_save_state(tp);
		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;pre_fr != NULL) {
			CC_ALGO(tp)-&gt;pre_fr(tp);
			<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp))
				tp-&gt;ecn_flags |= TE_SENDCWR;
		}
		ENTER_FASTRECOVERY(tp);

		tp-&gt;t_timer[TCPT_REXMT] = 0;
		tcpstat.tcps_sack_recovery_episode++;
		tp-&gt;sack_newdata = tp-&gt;snd_nxt;
		tp-&gt;snd_cwnd = tp-&gt;t_maxseg;
		tcp_ccdbg_trace(tp, NULL, TCP_CC_ENTER_FASTRECOVERY);
		(<span class="enscript-type">void</span>) tcp_output(tp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">dropit</span>:
		tcpstat.tcps_keepdrops++;
		postevent(so, 0, EV_TIMEOUT);
		soevent(so,
		    (SO_FILT_HINT_LOCKED|SO_FILT_HINT_TIMEOUT));
		tp = tcp_drop(tp, ETIMEDOUT);
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_DEBUG)
		tcp_trace(TA_USER, ostate, tp, (<span class="enscript-type">void</span> *)0, (<span class="enscript-type">struct</span> tcphdr *)0,
			  PRU_SLOWTIMO);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (tp);
}

<span class="enscript-comment">/* Remove a timer entry from timer list */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_remove_timer</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;

	lck_mtx_assert(&amp;tp-&gt;t_inpcb-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (!(TIMER_IS_ON_LIST(tp))) {
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_lock(listp-&gt;mtx);
	
	<span class="enscript-comment">/* Check if pcb is on timer list again after acquiring the lock */</span>
	<span class="enscript-keyword">if</span> (!(TIMER_IS_ON_LIST(tp))) {
		lck_mtx_unlock(listp-&gt;mtx);
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (listp-&gt;next_te != NULL &amp;&amp; listp-&gt;next_te == &amp;tp-&gt;tentry)
		listp-&gt;next_te = LIST_NEXT(&amp;tp-&gt;tentry, le);

	LIST_REMOVE(&amp;tp-&gt;tentry, le);
	tp-&gt;t_flags &amp;= ~(TF_TIMER_ONLIST);

	listp-&gt;entries--;

	tp-&gt;tentry.le.le_next = NULL;
	tp-&gt;tentry.le.le_prev = NULL;
	lck_mtx_unlock(listp-&gt;mtx);
}

<span class="enscript-comment">/*
 * Function to check if the timerlist needs to be rescheduled to run
 * the timer entry correctly. Basically, this is to check if we can avoid
 * taking the list lock.
 */</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">need_to_resched_timerlist</span>(u_int32_t runtime, u_int16_t mode)
{
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;
	int32_t diff;

	<span class="enscript-comment">/*
	 * If the list is being processed then the state of the list is
	 * in flux. In this case always acquire the lock and set the state
	 * correctly.
	 */</span>
	<span class="enscript-keyword">if</span> (listp-&gt;running)
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (!listp-&gt;scheduled)
		<span class="enscript-keyword">return</span> (TRUE);

	diff = timer_diff(listp-&gt;runtime, 0, runtime, 0);
	<span class="enscript-keyword">if</span> (diff &lt;= 0) {
		<span class="enscript-comment">/* The list is going to run before this timer */</span>
		<span class="enscript-keyword">return</span> (FALSE);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (mode &amp; TCP_TIMERLIST_10MS_MODE) {
			<span class="enscript-keyword">if</span> (diff &lt;= TCP_TIMER_10MS_QUANTUM)
				<span class="enscript-keyword">return</span> (FALSE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mode &amp; TCP_TIMERLIST_100MS_MODE) {
			<span class="enscript-keyword">if</span> (diff &lt;= TCP_TIMER_100MS_QUANTUM)
				<span class="enscript-keyword">return</span> (FALSE);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (diff &lt;= TCP_TIMER_500MS_QUANTUM)
				<span class="enscript-keyword">return</span> (FALSE);
		}
	}
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sched_timerlist</span>(uint32_t offset) 
{
	uint64_t deadline = 0;
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;

	lck_mtx_assert(listp-&gt;mtx, LCK_MTX_ASSERT_OWNED);

	offset = min(offset, TCP_TIMERLIST_MAX_OFFSET);
	listp-&gt;runtime = tcp_now + offset;
	<span class="enscript-keyword">if</span> (listp-&gt;runtime == 0) {
		listp-&gt;runtime++;
		offset++;
	}

	clock_interval_to_deadline(offset, USEC_PER_SEC, &amp;deadline);

	thread_call_enter_delayed(listp-&gt;call, deadline);
	listp-&gt;scheduled = TRUE;
}

<span class="enscript-comment">/*
 * Function to run the timers for a connection.
 *
 * Returns the offset of next timer to be run for this connection which 
 * can be used to reschedule the timerlist.
 *
 * te_mode is an out parameter that indicates the modes of active
 * timers for this connection.
 */</span>
u_int32_t
<span class="enscript-function-name">tcp_run_conn_timer</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_int16_t *te_mode,
	u_int16_t probe_if_index)
{
	<span class="enscript-type">struct</span> socket *so;
	u_int16_t i = 0, index = TCPT_NONE, lo_index = TCPT_NONE;
	u_int32_t timer_val, offset = 0, lo_timer = 0;
	int32_t diff;
	boolean_t needtorun[TCPT_NTIMERS];
	<span class="enscript-type">int</span> count = 0;

	VERIFY(tp != NULL);
	bzero(needtorun, <span class="enscript-keyword">sizeof</span>(needtorun));
	*te_mode = 0;

	tcp_lock(tp-&gt;t_inpcb-&gt;inp_socket, 1, 0);

	so = tp-&gt;t_inpcb-&gt;inp_socket;
	<span class="enscript-comment">/* Release the want count on inp */</span> 
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(tp-&gt;t_inpcb, WNT_RELEASE, 1)
		== WNT_STOPUSING) {
		<span class="enscript-keyword">if</span> (TIMER_IS_ON_LIST(tp)) {
			tcp_remove_timer(tp);
		}

		<span class="enscript-comment">/* Looks like the TCP connection got closed while we 
		 * were waiting for the lock.. Done
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If this connection is over an interface that needs to
	 * be probed, send probe packets to reinitiate communication.
	 */</span>
	<span class="enscript-keyword">if</span> (probe_if_index &gt; 0 &amp;&amp; tp-&gt;t_inpcb-&gt;inp_last_outifp != NULL &amp;&amp;
	    tp-&gt;t_inpcb-&gt;inp_last_outifp-&gt;if_index == probe_if_index) {
		tp-&gt;t_flagsext |= TF_PROBING;
		tcp_timers(tp, TCPT_PTO);
		tp-&gt;t_timer[TCPT_PTO] = 0;
		tp-&gt;t_flagsext &amp;= TF_PROBING;
	}

	<span class="enscript-comment">/*
	 * Since the timer thread needs to wait for tcp lock, it may race
	 * with another thread that can cancel or reschedule the timer
	 * that is about to run. Check if we need to run anything.
	 */</span>
	<span class="enscript-keyword">if</span> ((index = tp-&gt;tentry.index) == TCPT_NONE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	
	timer_val = tp-&gt;t_timer[index];

	diff = timer_diff(tp-&gt;tentry.runtime, 0, tcp_now, 0);
	<span class="enscript-keyword">if</span> (diff &gt; 0) {
		<span class="enscript-keyword">if</span> (tp-&gt;tentry.index != TCPT_NONE) {
			offset = diff;
			*(te_mode) = tp-&gt;tentry.mode;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	tp-&gt;t_timer[index] = 0;
	<span class="enscript-keyword">if</span> (timer_val &gt; 0) {
		tp = tcp_timers(tp, index);
		<span class="enscript-keyword">if</span> (tp == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	<span class="enscript-comment">/*
	 * Check if there are any other timers that need to be run.
	 * While doing it, adjust the timer values wrt tcp_now.
	 */</span>
	tp-&gt;tentry.mode = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; TCPT_NTIMERS; ++i) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_timer[i] != 0) {
			diff = timer_diff(tp-&gt;tentry.timer_start,
				tp-&gt;t_timer[i], tcp_now, 0);
			<span class="enscript-keyword">if</span> (diff &lt;= 0) {
				needtorun[i] = TRUE;
				count++;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_timer[i] = diff;
				needtorun[i] = FALSE;
				<span class="enscript-keyword">if</span> (lo_timer == 0 || diff &lt; lo_timer) {
					lo_timer = diff;
					lo_index = i;
				}
				TCP_SET_TIMER_MODE(tp-&gt;tentry.mode, i);
			}
		}
	}
	
	tp-&gt;tentry.timer_start = tcp_now;
	tp-&gt;tentry.index = lo_index;
	VERIFY(tp-&gt;tentry.index == TCPT_NONE || tp-&gt;tentry.mode &gt; 0);

	<span class="enscript-keyword">if</span> (tp-&gt;tentry.index != TCPT_NONE) {
		tp-&gt;tentry.runtime = tp-&gt;tentry.timer_start +
			tp-&gt;t_timer[tp-&gt;tentry.index];
		<span class="enscript-keyword">if</span> (tp-&gt;tentry.runtime == 0)
			tp-&gt;tentry.runtime++;
	}

	<span class="enscript-keyword">if</span> (count &gt; 0) {
		<span class="enscript-comment">/* run any other timers outstanding at this time. */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; TCPT_NTIMERS; ++i) {
			<span class="enscript-keyword">if</span> (needtorun[i]) {
				tp-&gt;t_timer[i] = 0;
				tp = tcp_timers(tp, i);
				<span class="enscript-keyword">if</span> (tp == NULL) {
					offset = 0;
					*(te_mode) = 0;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
			}
		}
		tcp_set_lotimer_index(tp);
	}

	<span class="enscript-keyword">if</span> (tp-&gt;tentry.index &lt; TCPT_NONE) {
		offset = tp-&gt;t_timer[tp-&gt;tentry.index];
		*(te_mode) = tp-&gt;tentry.mode;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; tp-&gt;tentry.index == TCPT_NONE) {
		tcp_remove_timer(tp);
		offset = 0;
	}

	tcp_unlock(so, 1, 0);
	<span class="enscript-keyword">return</span>(offset);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_run_timerlist</span>(<span class="enscript-type">void</span> * arg1, <span class="enscript-type">void</span> * arg2) {
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">struct</span> tcptimerentry *te, *next_te;
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;
	<span class="enscript-type">struct</span> tcpcb *tp;
	uint32_t next_timer = 0; <span class="enscript-comment">/* offset of the next timer on the list */</span>
	u_int16_t te_mode = 0;	<span class="enscript-comment">/* modes of all active timers in a tcpcb */</span>
	u_int16_t list_mode = 0; <span class="enscript-comment">/* cumulative of modes of all tcpcbs */</span>
	uint32_t active_count = 0;

	calculate_tcp_clock();

	lck_mtx_lock(listp-&gt;mtx);

	listp-&gt;running = TRUE;
	
	LIST_FOREACH_SAFE(te, &amp;listp-&gt;lhead, le, next_te) {
		uint32_t offset = 0;
		uint32_t runtime = te-&gt;runtime;
		<span class="enscript-keyword">if</span> (te-&gt;index &lt; TCPT_NONE &amp;&amp; TSTMP_GT(runtime, tcp_now)) {
			offset = timer_diff(runtime, 0, tcp_now, 0);
			<span class="enscript-keyword">if</span> (next_timer == 0 || offset &lt; next_timer) {
				next_timer = offset;
			}
			list_mode |= te-&gt;mode;
			<span class="enscript-keyword">continue</span>;
		}

		tp = TIMERENTRY_TO_TP(te);

		<span class="enscript-comment">/*
		 * Acquire an inp wantcnt on the inpcb so that the socket
		 * won't get detached even if tcp_close is called
		 */</span>
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(tp-&gt;t_inpcb, WNT_ACQUIRE, 0)
		    == WNT_STOPUSING) {
			<span class="enscript-comment">/*
			 * Some how this pcb went into dead state while
			 * on the timer list, just take it off the list.
			 * Since the timer list entry pointers are
			 * protected by the timer list lock, we can 
			 * do it here without the socket lock.
			 */</span>
			<span class="enscript-keyword">if</span> (TIMER_IS_ON_LIST(tp)) {
				tp-&gt;t_flags &amp;= ~(TF_TIMER_ONLIST);
				LIST_REMOVE(&amp;tp-&gt;tentry, le);
				listp-&gt;entries--;

				tp-&gt;tentry.le.le_next = NULL;
				tp-&gt;tentry.le.le_prev = NULL;
			}
			<span class="enscript-keyword">continue</span>;
		}
		active_count++;

		<span class="enscript-comment">/*
		 * Store the next timerentry pointer before releasing the
		 * list lock. If that entry has to be removed when we
		 * release the lock, this pointer will be updated to the
		 * element after that.
		 */</span>
		listp-&gt;next_te = next_te; 

		VERIFY_NEXT_LINK(&amp;tp-&gt;tentry, le);
		VERIFY_PREV_LINK(&amp;tp-&gt;tentry, le);

		lck_mtx_unlock(listp-&gt;mtx);

		offset = tcp_run_conn_timer(tp, &amp;te_mode,
		    listp-&gt;probe_if_index);
		
		lck_mtx_lock(listp-&gt;mtx);

		next_te = listp-&gt;next_te;
		listp-&gt;next_te = NULL;

		<span class="enscript-keyword">if</span> (offset &gt; 0 &amp;&amp; te_mode != 0) {
			list_mode |= te_mode;

			<span class="enscript-keyword">if</span> (next_timer == 0 || offset &lt; next_timer)
				next_timer = offset;
		}
	}

	<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;listp-&gt;lhead)) {
		u_int16_t next_mode = 0;
		<span class="enscript-keyword">if</span> ((list_mode &amp; TCP_TIMERLIST_10MS_MODE) ||
			(listp-&gt;pref_mode &amp; TCP_TIMERLIST_10MS_MODE))
			next_mode = TCP_TIMERLIST_10MS_MODE;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((list_mode &amp; TCP_TIMERLIST_100MS_MODE) ||
			(listp-&gt;pref_mode &amp; TCP_TIMERLIST_100MS_MODE))
			next_mode = TCP_TIMERLIST_100MS_MODE;
		<span class="enscript-keyword">else</span>
			next_mode = TCP_TIMERLIST_500MS_MODE;

		<span class="enscript-keyword">if</span> (next_mode != TCP_TIMERLIST_500MS_MODE) {
			listp-&gt;idleruns = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * the next required mode is slow mode, but if
			 * the last one was a faster mode and we did not
			 * have enough idle runs, repeat the last mode.
			 *
			 * We try to keep the timer list in fast mode for
			 * some idle time in expectation of new data.
			 */</span>
			<span class="enscript-keyword">if</span> (listp-&gt;mode != next_mode &amp;&amp;
			    listp-&gt;idleruns &lt; timer_fastmode_idlemax) {
				listp-&gt;idleruns++;
				next_mode = listp-&gt;mode;
				next_timer = TCP_TIMER_100MS_QUANTUM;
			} <span class="enscript-keyword">else</span> {
				listp-&gt;idleruns = 0;
			}
		}
		listp-&gt;mode = next_mode;
		<span class="enscript-keyword">if</span> (listp-&gt;pref_offset != 0)
			next_timer = min(listp-&gt;pref_offset, next_timer);

		<span class="enscript-keyword">if</span> (listp-&gt;mode == TCP_TIMERLIST_500MS_MODE)
			next_timer = max(next_timer,
				TCP_TIMER_500MS_QUANTUM);

		tcp_sched_timerlist(next_timer);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * No need to reschedule this timer, but always run
		 * periodically at a much higher granularity.
		 */</span>
		tcp_sched_timerlist(TCP_TIMERLIST_MAX_OFFSET);
	}

	listp-&gt;running = FALSE;
	listp-&gt;pref_mode = 0;
	listp-&gt;pref_offset = 0;
	listp-&gt;probe_if_index = 0;

	lck_mtx_unlock(listp-&gt;mtx);
}

<span class="enscript-comment">/*
 * Function to check if the timerlist needs to be rescheduled to run this
 * connection's timers correctly.
 */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">tcp_sched_timers</span>(<span class="enscript-type">struct</span> tcpcb *tp) 
{
	<span class="enscript-type">struct</span> tcptimerentry *te = &amp;tp-&gt;tentry;
	u_int16_t index = te-&gt;index;
	u_int16_t mode = te-&gt;mode;
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;
	int32_t offset = 0;
	boolean_t list_locked = FALSE;

	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_state == INPCB_STATE_DEAD) {
		<span class="enscript-comment">/* Just return without adding the dead pcb to the list */</span>
		<span class="enscript-keyword">if</span> (TIMER_IS_ON_LIST(tp)) {
			tcp_remove_timer(tp);
		}
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (index == TCPT_NONE) {
		<span class="enscript-comment">/* Nothing to run */</span>
		tcp_remove_timer(tp);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * compute the offset at which the next timer for this connection
	 * has to run.
	 */</span>
	offset = timer_diff(te-&gt;runtime, 0, tcp_now, 0);
	<span class="enscript-keyword">if</span> (offset &lt;= 0) {
		offset = 1;
		tcp_timer_advanced++;
	}

	<span class="enscript-keyword">if</span> (!TIMER_IS_ON_LIST(tp)) {
		<span class="enscript-keyword">if</span> (!list_locked) {
			lck_mtx_lock(listp-&gt;mtx);
			list_locked = TRUE;
		}

		LIST_INSERT_HEAD(&amp;listp-&gt;lhead, te, le);
		tp-&gt;t_flags |= TF_TIMER_ONLIST;

		listp-&gt;entries++;
		<span class="enscript-keyword">if</span> (listp-&gt;entries &gt; listp-&gt;maxentries)
			listp-&gt;maxentries = listp-&gt;entries;

		<span class="enscript-comment">/* if the list is not scheduled, just schedule it */</span>
		<span class="enscript-keyword">if</span> (!listp-&gt;scheduled)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">schedule</span>;
	}


	<span class="enscript-comment">/*
	 * Timer entry is currently on the list, check if the list needs
	 * to be rescheduled.
	 */</span>
	<span class="enscript-keyword">if</span> (need_to_resched_timerlist(te-&gt;runtime, mode)) {
		tcp_resched_timerlist++;
	
		<span class="enscript-keyword">if</span> (!list_locked) {
			lck_mtx_lock(listp-&gt;mtx);
			list_locked = TRUE;
		}

		VERIFY_NEXT_LINK(te, le);
		VERIFY_PREV_LINK(te, le);

		<span class="enscript-keyword">if</span> (listp-&gt;running) {
			listp-&gt;pref_mode |= mode;
			<span class="enscript-keyword">if</span> (listp-&gt;pref_offset == 0 ||
				offset &lt; listp-&gt;pref_offset) {
				listp-&gt;pref_offset = offset;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * The list could have got rescheduled while
			 * this thread was waiting for the lock
			 */</span>
			<span class="enscript-keyword">if</span> (listp-&gt;scheduled) {
				int32_t diff;
				diff = timer_diff(listp-&gt;runtime, 0,
				    tcp_now, offset);
				<span class="enscript-keyword">if</span> (diff &lt;= 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">schedule</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">schedule</span>;
			}
		}
	}
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">schedule</span>:
	<span class="enscript-comment">/*
	 * Since a connection with timers is getting scheduled, the timer
	 * list moves from idle to active state and that is why idlegen is
	 * reset
	 */</span>
	<span class="enscript-keyword">if</span> (mode &amp; TCP_TIMERLIST_10MS_MODE) {
		listp-&gt;mode = TCP_TIMERLIST_10MS_MODE;
		listp-&gt;idleruns = 0;
		offset = min(offset, TCP_TIMER_10MS_QUANTUM);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mode &amp; TCP_TIMERLIST_100MS_MODE) {
		<span class="enscript-keyword">if</span> (listp-&gt;mode &gt; TCP_TIMERLIST_100MS_MODE)
			listp-&gt;mode = TCP_TIMERLIST_100MS_MODE;
		listp-&gt;idleruns = 0;
		offset = min(offset, TCP_TIMER_100MS_QUANTUM);
	}
	tcp_sched_timerlist(offset);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (list_locked)
		lck_mtx_unlock(listp-&gt;mtx);

	<span class="enscript-keyword">return</span>;
}
		
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_lotimer_index</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	uint16_t i, lo_index = TCPT_NONE, mode = 0;
	uint32_t lo_timer = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; TCPT_NTIMERS; ++i) {
		<span class="enscript-keyword">if</span> (tp-&gt;t_timer[i] != 0) {
			TCP_SET_TIMER_MODE(mode, i);
			<span class="enscript-keyword">if</span> (lo_timer == 0 || tp-&gt;t_timer[i] &lt; lo_timer) {
				lo_timer = tp-&gt;t_timer[i];
				lo_index = i;
			}
		}
	}
	tp-&gt;tentry.index = lo_index;
	tp-&gt;tentry.mode = mode;
	VERIFY(tp-&gt;tentry.index == TCPT_NONE || tp-&gt;tentry.mode &gt; 0);

	<span class="enscript-keyword">if</span> (tp-&gt;tentry.index != TCPT_NONE) {
		tp-&gt;tentry.runtime = tp-&gt;tentry.timer_start 
		    + tp-&gt;t_timer[tp-&gt;tentry.index];
		<span class="enscript-keyword">if</span> (tp-&gt;tentry.runtime == 0)
			tp-&gt;tentry.runtime++;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_check_timer_state</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	lck_mtx_assert(&amp;tp-&gt;t_inpcb-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb-&gt;inp_flags2 &amp; INP2_TIMEWAIT)
		<span class="enscript-keyword">return</span>;

	tcp_set_lotimer_index(tp);

	tcp_sched_timers(tp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_cumulative_stat</span>(u_int32_t cur, u_int32_t *prev, u_int32_t *dest)
{
	<span class="enscript-comment">/* handle wrap around */</span>
	int32_t diff = (int32_t) (cur - *prev);
	<span class="enscript-keyword">if</span> (diff &gt; 0)
		*dest = diff;
	<span class="enscript-keyword">else</span>
		*dest = 0;
	*prev = cur;
	<span class="enscript-keyword">return</span>;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_report_stats</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nstat_sysinfo_data data;
	<span class="enscript-type">struct</span> sockaddr_in dst;
	<span class="enscript-type">struct</span> sockaddr_in6 dst6;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcp_last_report_stats prev;
	u_int64_t var, uptime;	

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">stat</span>	data.u.tcp_stats
	<span class="enscript-keyword">if</span> (((uptime = net_uptime()) - tcp_last_report_time) &lt;
		tcp_report_stats_interval)
		<span class="enscript-keyword">return</span>;

	tcp_last_report_time = uptime;

	bzero(&amp;data, <span class="enscript-keyword">sizeof</span>(data));
	data.flags = NSTAT_SYSINFO_TCP_STATS;

	bzero(&amp;dst, <span class="enscript-keyword">sizeof</span>(dst));
	dst.sin_len = <span class="enscript-keyword">sizeof</span>(dst);
	dst.sin_family = AF_INET;

	<span class="enscript-comment">/* ipv4 avg rtt */</span>
	lck_mtx_lock(rnh_lock);
	rt =  rt_lookup(TRUE, (<span class="enscript-type">struct</span> sockaddr *)&amp;dst, NULL,
		rt_tables[AF_INET], IFSCOPE_NONE);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt_primary_default(rt, rt_key(rt)) &amp;&amp;
			rt-&gt;rt_stats != NULL) {
			stat.ipv4_avgrtt = rt-&gt;rt_stats-&gt;nstat_avg_rtt;
		}
		RT_UNLOCK(rt);
		rtfree(rt);
		rt = NULL;
	}

	<span class="enscript-comment">/* ipv6 avg rtt */</span>
	bzero(&amp;dst6, <span class="enscript-keyword">sizeof</span>(dst6));
	dst6.sin6_len = <span class="enscript-keyword">sizeof</span>(dst6);
	dst6.sin6_family = AF_INET6;

	lck_mtx_lock(rnh_lock);
	rt = rt_lookup(TRUE,(<span class="enscript-type">struct</span> sockaddr *)&amp;dst6, NULL,
		rt_tables[AF_INET6], IFSCOPE_NONE);
	lck_mtx_unlock(rnh_lock);
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt_primary_default(rt, rt_key(rt)) &amp;&amp;
			rt-&gt;rt_stats != NULL) {
			stat.ipv6_avgrtt = rt-&gt;rt_stats-&gt;nstat_avg_rtt;
		}
		RT_UNLOCK(rt);
		rtfree(rt);
		rt = NULL;
	}

	<span class="enscript-comment">/* send packet loss rate, shift by 10 for precision */</span>
	<span class="enscript-keyword">if</span> (tcpstat.tcps_sndpack &gt; 0 &amp;&amp; tcpstat.tcps_sndrexmitpack &gt; 0) {
		var = tcpstat.tcps_sndrexmitpack &lt;&lt; 10;
		stat.send_plr = (var * 100) / tcpstat.tcps_sndpack;
	}

	<span class="enscript-comment">/* recv packet loss rate, shift by 10 for precision */</span>
	<span class="enscript-keyword">if</span> (tcpstat.tcps_rcvpack &gt; 0 &amp;&amp; tcpstat.tcps_recovered_pkts &gt; 0) {
		var = tcpstat.tcps_recovered_pkts &lt;&lt; 10;
		stat.recv_plr = (var * 100) / tcpstat.tcps_rcvpack;
	}

	<span class="enscript-comment">/* RTO after tail loss, shift by 10 for precision */</span>
	<span class="enscript-keyword">if</span> (tcpstat.tcps_sndrexmitpack &gt; 0 
	    &amp;&amp; tcpstat.tcps_tailloss_rto &gt; 0) {
		var = tcpstat.tcps_tailloss_rto &lt;&lt; 10;
		stat.send_tlrto_rate =
			(var * 100) / tcpstat.tcps_sndrexmitpack;
	}
	
	<span class="enscript-comment">/* packet reordering */</span>
	<span class="enscript-keyword">if</span> (tcpstat.tcps_sndpack &gt; 0 &amp;&amp; tcpstat.tcps_reordered_pkts &gt; 0) {
		var = tcpstat.tcps_reordered_pkts &lt;&lt; 10;
		stat.send_reorder_rate =
			(var * 100) / tcpstat.tcps_sndpack;
	}

	<span class="enscript-keyword">if</span> (tcp_ecn_outbound == 1)
		stat.ecn_client_enabled = 1;
	<span class="enscript-keyword">if</span> (tcp_ecn_inbound == 1)
		stat.ecn_server_enabled = 1;
	tcp_cumulative_stat(tcpstat.tcps_connattempt,
	    &amp;prev.tcps_connattempt, &amp;stat.connection_attempts);
	tcp_cumulative_stat(tcpstat.tcps_accepts,
	    &amp;prev.tcps_accepts, &amp;stat.connection_accepts);
	tcp_cumulative_stat(tcpstat.tcps_ecn_client_setup,
	    &amp;prev.tcps_ecn_client_setup, &amp;stat.ecn_client_setup);
	tcp_cumulative_stat(tcpstat.tcps_ecn_server_setup,
	    &amp;prev.tcps_ecn_server_setup, &amp;stat.ecn_server_setup);
	tcp_cumulative_stat(tcpstat.tcps_ecn_client_success,
	    &amp;prev.tcps_ecn_client_success, &amp;stat.ecn_client_success);
	tcp_cumulative_stat(tcpstat.tcps_ecn_server_success,
	    &amp;prev.tcps_ecn_server_success, &amp;stat.ecn_server_success);
	tcp_cumulative_stat(tcpstat.tcps_ecn_not_supported,
	    &amp;prev.tcps_ecn_not_supported, &amp;stat.ecn_not_supported);
	tcp_cumulative_stat(tcpstat.tcps_ecn_lost_syn,
	    &amp;prev.tcps_ecn_lost_syn, &amp;stat.ecn_lost_syn);
	tcp_cumulative_stat(tcpstat.tcps_ecn_lost_synack,
	    &amp;prev.tcps_ecn_lost_synack, &amp;stat.ecn_lost_synack);
	tcp_cumulative_stat(tcpstat.tcps_ecn_recv_ce,
	    &amp;prev.tcps_ecn_recv_ce, &amp;stat.ecn_recv_ce);
	tcp_cumulative_stat(tcpstat.tcps_ecn_recv_ece,
	    &amp;prev.tcps_ecn_recv_ece, &amp;stat.ecn_recv_ece);
	tcp_cumulative_stat(tcpstat.tcps_ecn_recv_ece,
	    &amp;prev.tcps_ecn_recv_ece, &amp;stat.ecn_recv_ece);
	tcp_cumulative_stat(tcpstat.tcps_ecn_sent_ece,
	    &amp;prev.tcps_ecn_sent_ece, &amp;stat.ecn_sent_ece);
	tcp_cumulative_stat(tcpstat.tcps_ecn_sent_ece,
	    &amp;prev.tcps_ecn_sent_ece, &amp;stat.ecn_sent_ece);
	tcp_cumulative_stat(tcpstat.tcps_ecn_conn_recv_ce,
	    &amp;prev.tcps_ecn_conn_recv_ce, &amp;stat.ecn_conn_recv_ce);
	tcp_cumulative_stat(tcpstat.tcps_ecn_conn_recv_ece,
	    &amp;prev.tcps_ecn_conn_recv_ece, &amp;stat.ecn_conn_recv_ece);
	tcp_cumulative_stat(tcpstat.tcps_ecn_conn_plnoce,
	    &amp;prev.tcps_ecn_conn_plnoce, &amp;stat.ecn_conn_plnoce);
	tcp_cumulative_stat(tcpstat.tcps_ecn_conn_pl_ce,
	    &amp;prev.tcps_ecn_conn_pl_ce, &amp;stat.ecn_conn_pl_ce);
	tcp_cumulative_stat(tcpstat.tcps_ecn_conn_nopl_ce,
	    &amp;prev.tcps_ecn_conn_nopl_ce, &amp;stat.ecn_conn_nopl_ce);
	tcp_cumulative_stat(tcpstat.tcps_tfo_syn_data_rcv,
	    &amp;prev.tcps_tfo_syn_data_rcv, &amp;stat.tfo_syn_data_rcv);
	tcp_cumulative_stat(tcpstat.tcps_tfo_cookie_req_rcv,
	    &amp;prev.tcps_tfo_cookie_req_rcv, &amp;stat.tfo_cookie_req_rcv);
	tcp_cumulative_stat(tcpstat.tcps_tfo_cookie_sent,
	    &amp;prev.tcps_tfo_cookie_sent, &amp;stat.tfo_cookie_sent);
	tcp_cumulative_stat(tcpstat.tcps_tfo_cookie_invalid,
	    &amp;prev.tcps_tfo_cookie_invalid, &amp;stat.tfo_cookie_invalid);
	tcp_cumulative_stat(tcpstat.tcps_tfo_cookie_req,
	    &amp;prev.tcps_tfo_cookie_req, &amp;stat.tfo_cookie_req);
	tcp_cumulative_stat(tcpstat.tcps_tfo_cookie_rcv,
	    &amp;prev.tcps_tfo_cookie_rcv, &amp;stat.tfo_cookie_rcv);
	tcp_cumulative_stat(tcpstat.tcps_tfo_syn_data_sent,
	    &amp;prev.tcps_tfo_syn_data_sent, &amp;stat.tfo_syn_data_sent);
	tcp_cumulative_stat(tcpstat.tcps_tfo_syn_data_acked,
	    &amp;prev.tcps_tfo_syn_data_acked, &amp;stat.tfo_syn_data_acked);
	tcp_cumulative_stat(tcpstat.tcps_tfo_syn_loss,
	    &amp;prev.tcps_tfo_syn_loss, &amp;stat.tfo_syn_loss);
	tcp_cumulative_stat(tcpstat.tcps_tfo_blackhole,
	    &amp;prev.tcps_tfo_blackhole, &amp;stat.tfo_blackhole);

	nstat_sysinfo_send_data(&amp;data);

#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">stat</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_interface_send_probe</span>(u_int16_t probe_if_index)
{
	int32_t offset = 0;
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;

	<span class="enscript-comment">/* Make sure TCP clock is up to date */</span>
	calculate_tcp_clock();

	lck_mtx_lock(listp-&gt;mtx);
	<span class="enscript-keyword">if</span> (listp-&gt;probe_if_index &gt; 0) {
		tcpstat.tcps_probe_if_conflict++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	listp-&gt;probe_if_index = probe_if_index;
	<span class="enscript-keyword">if</span> (listp-&gt;running)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/*
	 * Reschedule the timerlist to run within the next 10ms, which is
	 * the fastest that we can do.
	 */</span>
	offset = TCP_TIMER_10MS_QUANTUM;
	<span class="enscript-keyword">if</span> (listp-&gt;scheduled) {
		int32_t diff;
		diff = timer_diff(listp-&gt;runtime, 0, tcp_now, offset);
		<span class="enscript-keyword">if</span> (diff &lt;= 0) {
			<span class="enscript-comment">/* The timer will fire sooner than what's needed */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	listp-&gt;mode = TCP_TIMERLIST_10MS_MODE;
	listp-&gt;idleruns = 0;

	tcp_sched_timerlist(offset);

<span class="enscript-reference">done</span>:
	lck_mtx_unlock(listp-&gt;mtx);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Enable read probes on this connection, if:
 * - it is in established state
 * - doesn't have any data outstanding
 * - the outgoing ifp matches
 * - we have not already sent any read probes
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_enable_read_probe</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
	    tp-&gt;snd_max == tp-&gt;snd_una &amp;&amp;
	    tp-&gt;t_inpcb-&gt;inp_last_outifp == ifp &amp;&amp;
	    !(tp-&gt;t_flagsext &amp; TF_DETECT_READSTALL) &amp;&amp;
	    tp-&gt;t_rtimo_probes == 0) {
		tp-&gt;t_flagsext |= TF_DETECT_READSTALL;
		tp-&gt;t_rtimo_probes = 0;
		tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
		    TCP_TIMER_10MS_QUANTUM);
		<span class="enscript-keyword">if</span> (tp-&gt;tentry.index == TCPT_NONE) {
			tp-&gt;tentry.index = TCPT_KEEP;
			tp-&gt;tentry.runtime = tcp_now +
			    TCP_TIMER_10MS_QUANTUM;
		} <span class="enscript-keyword">else</span> {
			int32_t diff = 0;

			<span class="enscript-comment">/* Reset runtime to be in next 10ms */</span>
			diff = timer_diff(tp-&gt;tentry.runtime, 0,
			    tcp_now, TCP_TIMER_10MS_QUANTUM);
			<span class="enscript-keyword">if</span> (diff &gt; 0) {
				tp-&gt;tentry.index = TCPT_KEEP;
				tp-&gt;tentry.runtime = tcp_now +
				    TCP_TIMER_10MS_QUANTUM;
				<span class="enscript-keyword">if</span> (tp-&gt;tentry.runtime == 0)
					tp-&gt;tentry.runtime++;
			}
		}
	}
}

<span class="enscript-comment">/*
 * Disable read probe and reset the keep alive timer
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_disable_read_probe</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-keyword">if</span> (tp-&gt;t_adaptive_rtimo == 0 &amp;&amp;
	    ((tp-&gt;t_flagsext &amp; TF_DETECT_READSTALL) ||
	    tp-&gt;t_rtimo_probes &gt; 0)) {
		tcp_keepalive_reset(tp);
	}
}

<span class="enscript-comment">/*
 * Reschedule the tcp timerlist in the next 10ms to re-enable read/write
 * probes on connections going over a particular interface.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_probe_connectivity</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t enable)
{
	int32_t offset;
	<span class="enscript-type">struct</span> tcptimerlist *listp = &amp;tcp_timer_list;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = &amp;tcbinfo;
	<span class="enscript-type">struct</span> inpcb *inp, *nxt;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* update clock */</span>
	calculate_tcp_clock();

	<span class="enscript-comment">/*
	 * Enable keep alive timer on all connections that are
	 * active/established on this interface.
	 */</span>
	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	LIST_FOREACH_SAFE(inp, pcbinfo-&gt;ipi_listhead, inp_list, nxt) {
		<span class="enscript-type">struct</span> tcpcb *tp = NULL;
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) ==
		    WNT_STOPUSING)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Acquire lock to look at the state of the connection */</span>
		tcp_lock(inp-&gt;inp_socket, 1, 0);

		<span class="enscript-comment">/* Release the want count */</span>
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
			tcp_unlock(inp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}

		tp = intotcpcb(inp);
		<span class="enscript-keyword">if</span> (enable)
			tcp_enable_read_probe(tp, ifp);
		<span class="enscript-keyword">else</span>
			tcp_disable_read_probe(tp);

		tcp_unlock(inp-&gt;inp_socket, 1, 0);
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);

	lck_mtx_lock(listp-&gt;mtx);
	<span class="enscript-keyword">if</span> (listp-&gt;running) {
		listp-&gt;pref_mode |= TCP_TIMERLIST_10MS_MODE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Reschedule within the next 10ms */</span>
	offset = TCP_TIMER_10MS_QUANTUM;
	<span class="enscript-keyword">if</span> (listp-&gt;scheduled) {
		int32_t diff;
		diff = timer_diff(listp-&gt;runtime, 0, tcp_now, offset);
		<span class="enscript-keyword">if</span> (diff &lt;= 0) {
			<span class="enscript-comment">/* The timer will fire sooner than what's needed */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	listp-&gt;mode = TCP_TIMERLIST_10MS_MODE;
	listp-&gt;idleruns = 0;

	tcp_sched_timerlist(offset);
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(listp-&gt;mtx);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_itimer</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi)
{
	<span class="enscript-type">struct</span> inpcb *inp, *nxt;

	<span class="enscript-keyword">if</span> (lck_rw_try_lock_exclusive(ipi-&gt;ipi_lock) == FALSE) {
		<span class="enscript-keyword">if</span> (tcp_itimer_done == TRUE) {
			tcp_itimer_done = FALSE;
			atomic_add_32(&amp;ipi-&gt;ipi_timer_req.intimer_fast, 1);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/* Upgrade failed, lost lock now take it again exclusive */</span>
		lck_rw_lock_exclusive(ipi-&gt;ipi_lock);
	}
	tcp_itimer_done = TRUE;

	LIST_FOREACH_SAFE(inp, &amp;tcb, inp_list, nxt) {
		<span class="enscript-type">struct</span> socket *so;

		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) == WNT_STOPUSING)
			<span class="enscript-keyword">continue</span>;
		so = inp-&gt;inp_socket;
		tcp_lock(so, 1, 0);
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
			tcp_unlock(so, 1, 0);
			<span class="enscript-keyword">continue</span>;
		}
		so_check_extended_bk_idle_time(so);
		tcp_unlock(so, 1, 0);
	}

	lck_rw_done(ipi-&gt;ipi_lock);
}

</pre>
<hr />
</body></html>