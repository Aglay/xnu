<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>raw_ip.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">raw_ip.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)raw_ip.c	8.7 (Berkeley) 5/15/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">load_ipfw</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_detach</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_abort</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_bind</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_connect</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">int</span> <span class="enscript-function-name">rip_shutdown</span>(<span class="enscript-type">struct</span> socket *);

<span class="enscript-type">struct</span>	inpcbhead ripcb;
<span class="enscript-type">struct</span>	inpcbinfo ripcbinfo;

<span class="enscript-comment">/* control hooks for ipfw and dummynet */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
ip_fw_ctl_t *ip_fw_ctl_ptr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
ip_dn_ctl_t *ip_dn_ctl_ptr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-comment">/*
 * Nominal space allocated to a raw ip socket.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RIPSNDQ</span>		8192
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RIPRCVQ</span>		8192

<span class="enscript-comment">/*
 * Raw interface to IP protocol.
 */</span>

<span class="enscript-comment">/*
 * Initialize raw connection block q.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rip_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> rip_initialized = 0;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo;

	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-keyword">if</span> (rip_initialized)
		<span class="enscript-keyword">return</span>;
	rip_initialized = 1;

	LIST_INIT(&amp;ripcb);
	ripcbinfo.ipi_listhead = &amp;ripcb;
	<span class="enscript-comment">/*
	 * XXX We don't use the hash list for raw IP, but it's easier
	 * to allocate a one entry hash list than it is to check all
	 * over the place for ipi_hashbase == NULL.
	 */</span>
	ripcbinfo.ipi_hashbase = hashinit(1, M_PCB, &amp;ripcbinfo.ipi_hashmask);
	ripcbinfo.ipi_porthashbase = hashinit(1, M_PCB, &amp;ripcbinfo.ipi_porthashmask);

	ripcbinfo.ipi_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> inpcb),
	    (4096 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> inpcb)), 4096, <span class="enscript-string">&quot;ripzone&quot;</span>);

	pcbinfo = &amp;ripcbinfo;
        <span class="enscript-comment">/*
	 * allocate lock group attribute and group for udp pcb mutexes
	 */</span>
	pcbinfo-&gt;ipi_lock_grp_attr = lck_grp_attr_alloc_init();
	pcbinfo-&gt;ipi_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;ripcb&quot;</span>, pcbinfo-&gt;ipi_lock_grp_attr);

	<span class="enscript-comment">/*
	 * allocate the lock attribute for udp pcb mutexes
	 */</span>
	pcbinfo-&gt;ipi_lock_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> ((pcbinfo-&gt;ipi_lock = lck_rw_alloc_init(pcbinfo-&gt;ipi_lock_grp,
	    pcbinfo-&gt;ipi_lock_attr)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate PCB lock\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	in_pcbinfo_attach(&amp;ripcbinfo);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span>	sockaddr_in ripsrc = { <span class="enscript-keyword">sizeof</span>(ripsrc), AF_INET , 0, {0}, {0,0,0,0,0,0,0,0,} };
<span class="enscript-comment">/*
 * Setup generic address and protocol structures
 * for raw_input routine, then pass them along with
 * mbuf chain.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rip_input</span>(m, iphlen)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> iphlen;
{
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> inpcb *last = 0;
	<span class="enscript-type">struct</span> mbuf *opts = 0;
	<span class="enscript-type">int</span> skipit = 0, ret = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	ripsrc.sin_addr = ip-&gt;ip_src;
	lck_rw_lock_shared(ripcbinfo.ipi_lock);
	LIST_FOREACH(inp, &amp;ripcb, inp_list) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV4) == 0)
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_ip_p &amp;&amp; (inp-&gt;inp_ip_p != ip-&gt;ip_p))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr &amp;&amp;
                  inp-&gt;inp_laddr.s_addr != ip-&gt;ip_dst.s_addr)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr &amp;&amp;
                  inp-&gt;inp_faddr.s_addr != ip-&gt;ip_src.s_addr)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (last) {
			<span class="enscript-type">struct</span> mbuf *n = m_copy(m, 0, (<span class="enscript-type">int</span>)M_COPYALL);

			skipit = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
			<span class="enscript-keyword">if</span> (n &amp;&amp; !necp_socket_is_allowed_to_send_recv_v4(last, 0, 0,
				&amp;ip-&gt;ip_dst, &amp;ip-&gt;ip_src, ifp, NULL, NULL)) {
				m_freem(n);
				<span class="enscript-comment">/* do not inject data to pcb */</span>
				skipit = 1;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
			<span class="enscript-keyword">if</span> (n &amp;&amp; skipit == 0) {
				<span class="enscript-keyword">if</span> (mac_inpcb_check_deliver(last, n, AF_INET,
				    SOCK_RAW) != 0) {
					m_freem(n);
					skipit = 1;
				}
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (n &amp;&amp; skipit == 0) {
				<span class="enscript-type">int</span> error = 0;
				<span class="enscript-keyword">if</span> ((last-&gt;inp_flags &amp; INP_CONTROLOPTS) != 0 ||
				    (last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
				    (last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
					ret = ip_savecontrol(last, &amp;opts, ip, n);
					<span class="enscript-keyword">if</span> (ret != 0) {
						m_freem(n);
						m_freem(opts);
						last = inp;
						<span class="enscript-keyword">continue</span>;
					}
				}
				<span class="enscript-keyword">if</span> (last-&gt;inp_flags &amp; INP_STRIPHDR) {
					n-&gt;m_len -= iphlen;
					n-&gt;m_pkthdr.len -= iphlen;
					n-&gt;m_data += iphlen;
				}
				so_recv_data_stat(last-&gt;inp_socket, m, 0);
				<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;inp_socket-&gt;so_rcv,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;ripsrc, n,
				    opts, &amp;error) != 0) {
					sorwakeup(last-&gt;inp_socket);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-comment">/* should notify about lost packet */</span>
						kprintf(<span class="enscript-string">&quot;rip_input can't append to socket\n&quot;</span>);
					}
				}
				opts = 0;
			}
		}
		last = inp;
	}

	skipit = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">if</span> (last &amp;&amp; !necp_socket_is_allowed_to_send_recv_v4(last, 0, 0,
		&amp;ip-&gt;ip_dst, &amp;ip-&gt;ip_src, ifp, NULL, NULL)) {
		m_freem(m);
		OSAddAtomic(1, &amp;ipstat.ips_delivered);
		<span class="enscript-comment">/* do not inject data to pcb */</span>
		skipit = 1;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">if</span> (last &amp;&amp; skipit == 0) {
		<span class="enscript-keyword">if</span> (mac_inpcb_check_deliver(last, m, AF_INET, SOCK_RAW) != 0) {
			skipit = 1;
			m_freem(m);
		}
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (skipit == 0) {
		<span class="enscript-keyword">if</span> (last) {
			<span class="enscript-keyword">if</span> ((last-&gt;inp_flags &amp; INP_CONTROLOPTS) != 0 ||
				(last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
				(last-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
				ret = ip_savecontrol(last, &amp;opts, ip, m);
				<span class="enscript-keyword">if</span> (ret != 0) {
					m_freem(m);
					m_freem(opts);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock</span>;		
				}
			}
			<span class="enscript-keyword">if</span> (last-&gt;inp_flags &amp; INP_STRIPHDR) {
				m-&gt;m_len -= iphlen;
				m-&gt;m_pkthdr.len -= iphlen;
				m-&gt;m_data += iphlen;
			}
			so_recv_data_stat(last-&gt;inp_socket, m, 0);
			<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;inp_socket-&gt;so_rcv,
				(<span class="enscript-type">struct</span> sockaddr *)&amp;ripsrc, m, opts, NULL) != 0) {
				sorwakeup(last-&gt;inp_socket);
			} <span class="enscript-keyword">else</span> {
				kprintf(<span class="enscript-string">&quot;rip_input(2) can't append to socket\n&quot;</span>);
			}
		} <span class="enscript-keyword">else</span> {
			m_freem(m);
			OSAddAtomic(1, &amp;ipstat.ips_noproto);
			OSAddAtomic(-1, &amp;ipstat.ips_delivered);
		}
	}
<span class="enscript-reference">unlock</span>:
	<span class="enscript-comment">/*
	 * Keep the list locked because socket filter may force the socket lock 
	 * to be released when calling sbappendaddr() -- see rdar://7627704
	 */</span>
	lck_rw_done(ripcbinfo.ipi_lock);
}

<span class="enscript-comment">/*
 * Generate IP header and pass packet to ip_output.
 * Tack on options user may have setup with control call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rip_output</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">struct</span> socket *so,
	u_int32_t dst,
	<span class="enscript-type">struct</span> mbuf *control)
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span> flags = (so-&gt;so_options &amp; SO_DONTROUTE) | IP_ALLOWBROADCAST;
	<span class="enscript-type">struct</span> ip_out_args ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF, 0 };
	<span class="enscript-type">struct</span> ip_moptions *imo;
	<span class="enscript-type">int</span> error = 0;
	mbuf_svc_class_t msc = MBUF_SC_UNSPEC;

	<span class="enscript-keyword">if</span> (control != NULL) {
		msc = mbuf_service_class_from_control(control);

		m_freem(control);
		control = NULL;
	}

	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		VERIFY(control == NULL);
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);
	}

	flags |= IP_OUTARGS;
	<span class="enscript-comment">/* If socket was bound to an ifindex, tell ip_output about it */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_BOUND_IF) {
		ipoa.ipoa_boundif = inp-&gt;inp_boundifp-&gt;if_index;
		ipoa.ipoa_flags |= IPOAF_BOUND_IF;
	}
	<span class="enscript-keyword">if</span> (INP_NO_CELLULAR(inp))
		ipoa.ipoa_flags |=  IPOAF_NO_CELLULAR;
	<span class="enscript-keyword">if</span> (INP_NO_EXPENSIVE(inp))
		ipoa.ipoa_flags |=  IPOAF_NO_EXPENSIVE;
	<span class="enscript-keyword">if</span> (INP_AWDL_UNRESTRICTED(inp))
		ipoa.ipoa_flags |=  IPOAF_AWDL_UNRESTRICTED;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
		inp-&gt;inp_flowhash = inp_calc_flowhash(inp);

	<span class="enscript-comment">/*
	 * If the user handed us a complete IP packet, use it.
	 * Otherwise, allocate an mbuf for a header and fill it in.
	 */</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; INP_HDRINCL) == 0) {
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt; IP_MAXPACKET) {
			m_freem(m);
			<span class="enscript-keyword">return</span>(EMSGSIZE);
		}
		M_PREPEND(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip), M_WAIT, 1);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> ENOBUFS;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		ip-&gt;ip_tos = inp-&gt;inp_ip_tos;
		ip-&gt;ip_off = 0;
		ip-&gt;ip_p = inp-&gt;inp_ip_p;
		ip-&gt;ip_len = m-&gt;m_pkthdr.len;
		ip-&gt;ip_src = inp-&gt;inp_laddr;
		ip-&gt;ip_dst.s_addr = dst;
		ip-&gt;ip_ttl = inp-&gt;inp_ip_ttl;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; IP_MAXPACKET) {
			m_freem(m);
			<span class="enscript-keyword">return</span>(EMSGSIZE);
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-comment">/* don't allow both user specified and setsockopt options,
		   and don't allow packet length sizes that will crash */</span>
		<span class="enscript-keyword">if</span> (((IP_VHL_HL(ip-&gt;ip_vhl) != (<span class="enscript-keyword">sizeof</span> (*ip) &gt;&gt; 2))
		     &amp;&amp; inp-&gt;inp_options)
		    || (ip-&gt;ip_len &gt; m-&gt;m_pkthdr.len)
		    || (ip-&gt;ip_len &lt; (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2))) {
			m_freem(m);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (ip-&gt;ip_id == 0)
			ip-&gt;ip_id = ip_randomid();
		<span class="enscript-comment">/* XXX prevent ip_output from overwriting header fields */</span>
		flags |= IP_RAWOUTPUT;
		OSAddAtomic(1, &amp;ipstat.ips_rawout);
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY)
		ipoa.ipoa_flags |= IPOAF_BOUND_SRCADDR;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	{
		necp_kernel_policy_id policy_id;
		u_int32_t route_rule_id;
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v4(inp, 0, 0,
			&amp;ip-&gt;ip_src, &amp;ip-&gt;ip_dst, NULL, &amp;policy_id, &amp;route_rule_id)) {
			m_freem(m);
			<span class="enscript-keyword">return</span>(EHOSTUNREACH);
		}

		necp_mark_packet_from_socket(m, inp, policy_id, route_rule_id);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp != NULL &amp;&amp; ipsec_setsocket(m, so) != 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;inp-&gt;inp_route))
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);

	set_packet_service_class(m, so, msc, 0);
	m-&gt;m_pkthdr.pkt_flowsrc = FLOWSRC_INPCB;
	m-&gt;m_pkthdr.pkt_flowid = inp-&gt;inp_flowhash;
	m-&gt;m_pkthdr.pkt_flags |= (PKTF_FLOW_ID | PKTF_FLOW_LOCALSRC |
	    PKTF_FLOW_RAWSOCK);
	m-&gt;m_pkthdr.pkt_proto = inp-&gt;inp_ip_p;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_mbuf_label_associate_inpcb(inp, m);
#<span class="enscript-reference">endif</span>

	imo = inp-&gt;inp_moptions;
	<span class="enscript-keyword">if</span> (imo != NULL)
		IMO_ADDREF(imo);
	<span class="enscript-comment">/*
	 * The domain lock is held across ip_output, so it is okay
	 * to pass the PCB cached route pointer directly to IP and
	 * the modules beneath it.
	 */</span>
	<span class="enscript-comment">// TODO: PASS DOWN ROUTE RULE ID
</span>	error = ip_output(m, inp-&gt;inp_options, &amp;inp-&gt;inp_route, flags,
	    imo, &amp;ipoa);

	<span class="enscript-keyword">if</span> (imo != NULL)
		IMO_REMREF(imo);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_route.ro_rt != NULL) {
		<span class="enscript-type">struct</span> rtentry *rt = inp-&gt;inp_route.ro_rt;
		<span class="enscript-type">struct</span> ifnet *outif;

		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_MULTICAST|RTF_BROADCAST)) ||
		    inp-&gt;inp_socket == NULL ||
		    !(inp-&gt;inp_socket-&gt;so_state &amp; SS_ISCONNECTED)) {
			rt = NULL;	<span class="enscript-comment">/* unusable */</span>
		}
		<span class="enscript-comment">/*
		 * Always discard the cached route for unconnected
		 * socket or if it is a multicast route.
		 */</span>
		<span class="enscript-keyword">if</span> (rt == NULL)
			ROUTE_RELEASE(&amp;inp-&gt;inp_route);

		<span class="enscript-comment">/*
		 * If this is a connected socket and the destination
		 * route is unicast, update outif with that of the
		 * route interface used by IP.
		 */</span>
		<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; (outif = rt-&gt;rt_ifp) != inp-&gt;inp_last_outifp)
			inp-&gt;inp_last_outifp = outif;
	} <span class="enscript-keyword">else</span> {
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
	}

	<span class="enscript-comment">/*
	 * If output interface was cellular/expensive, and this socket is
	 * denied access to it, generate an event.
	 */</span>
	<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; (ipoa.ipoa_retflags &amp; IPOARF_IFDENIED) &amp;&amp;
	    (INP_NO_CELLULAR(inp) || INP_NO_EXPENSIVE(inp)))
		soevent(so, (SO_FILT_HINT_LOCKED|SO_FILT_HINT_IFDENIED));

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">load_ipfw</span>(<span class="enscript-type">void</span>)
{
	kern_return_t	err;
	
	ipfw_init();
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (!DUMMYNET_LOADED)
		ip_dn_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	err = 0;
	
	<span class="enscript-keyword">return</span> err == 0 &amp;&amp; ip_fw_ctl_ptr == NULL ? -1 : err;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

<span class="enscript-comment">/*
 * Raw IP socket option processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rip_ctloutput</span>(so, sopt)
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> sockopt *sopt;
{
	<span class="enscript-type">struct</span>	inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span>	error, optval;

	<span class="enscript-comment">/* Allow &lt;SOL_SOCKET,SO_FLUSH&gt; at this level */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_IP &amp;&amp;
	    !(sopt-&gt;sopt_level == SOL_SOCKET &amp;&amp; sopt-&gt;sopt_name == SO_FLUSH))
		<span class="enscript-keyword">return</span> (EINVAL);

	error = 0;

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_HDRINCL</span>:
			optval = inp-&gt;inp_flags &amp; INP_HDRINCL;
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_STRIPHDR</span>:
			optval = inp-&gt;inp_flags &amp; INP_STRIPHDR;
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_GET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_GET</span>:
			<span class="enscript-keyword">if</span> (ip_fw_ctl_ptr == 0)
				error = load_ipfw();
			<span class="enscript-keyword">if</span> (ip_fw_ctl_ptr &amp;&amp; error == 0)
				error = ip_fw_ctl_ptr(sopt);
			<span class="enscript-keyword">else</span>
				error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DUMMYNET_GET</span>:
			<span class="enscript-keyword">if</span> (!DUMMYNET_LOADED)
				ip_dn_init();
			<span class="enscript-keyword">if</span> (DUMMYNET_LOADED)
				error = ip_dn_ctl_ptr(sopt);
			<span class="enscript-keyword">else</span>
				error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span> ;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

		<span class="enscript-reference">default</span>:
			error = ip_ctloutput(so, sopt);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_HDRINCL</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
					    <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval)
				inp-&gt;inp_flags |= INP_HDRINCL;
			<span class="enscript-keyword">else</span>
				inp-&gt;inp_flags &amp;= ~INP_HDRINCL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_STRIPHDR</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
			    <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval)
				inp-&gt;inp_flags |= INP_STRIPHDR;
			<span class="enscript-keyword">else</span>
				inp-&gt;inp_flags &amp;= ~INP_STRIPHDR;
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_DEL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_FLUSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_ZERO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FW_RESETLOG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_DEL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_FLUSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_ZERO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OLD_FW_RESETLOG</span>:
			<span class="enscript-keyword">if</span> (ip_fw_ctl_ptr == 0)
				error = load_ipfw();
			<span class="enscript-keyword">if</span> (ip_fw_ctl_ptr &amp;&amp; error == 0)
				error = ip_fw_ctl_ptr(sopt);
			<span class="enscript-keyword">else</span>
				error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DUMMYNET_CONFIGURE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DUMMYNET_DEL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DUMMYNET_FLUSH</span>:
			<span class="enscript-keyword">if</span> (!DUMMYNET_LOADED)
				ip_dn_init();
			<span class="enscript-keyword">if</span> (DUMMYNET_LOADED)
				error = ip_dn_ctl_ptr(sopt);
			<span class="enscript-keyword">else</span>
				error = ENOPROTOOPT ;
			<span class="enscript-keyword">break</span> ;
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			error = inp_flush(inp, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ip_ctloutput(so, sopt);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This function exists solely to receive the PRC_IFDOWN messages which
 * are sent by if_down().  It looks for an ifaddr whose ifa_addr is sa,
 * and calls in_ifadown() to remove all routes corresponding to that address.
 * It also receives the PRC_IFUP messages from if_up() and reinstalls the
 * interface routes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rip_ctlinput</span>(
	<span class="enscript-type">int</span> cmd,
	<span class="enscript-type">struct</span> sockaddr *sa,
	__unused <span class="enscript-type">void</span> *vip)
{
	<span class="enscript-type">struct</span> in_ifaddr *ia;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> err;
	<span class="enscript-type">int</span> flags, done = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRC_IFDOWN</span>:
		lck_rw_lock_shared(in_ifaddr_rwlock);
		<span class="enscript-keyword">for</span> (ia = in_ifaddrhead.tqh_first; ia;
		     ia = ia-&gt;ia_link.tqe_next) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (ia-&gt;ia_ifa.ifa_addr == sa &amp;&amp;
			    (ia-&gt;ia_flags &amp; IFA_ROUTE)) {
				done = 1;
				IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				lck_rw_done(in_ifaddr_rwlock);
				lck_mtx_lock(rnh_lock);
				<span class="enscript-comment">/*
				 * in_ifscrub kills the interface route.
				 */</span>
				in_ifscrub(ia-&gt;ia_ifp, ia, 1);
				<span class="enscript-comment">/*
				 * in_ifadown gets rid of all the rest of
				 * the routes.  This is not quite the right
				 * thing to do, but at least if we are running
				 * a routing process they will come back.
				 */</span>
				in_ifadown(&amp;ia-&gt;ia_ifa, 1);
				lck_mtx_unlock(rnh_lock);
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		<span class="enscript-keyword">if</span> (!done)
			lck_rw_done(in_ifaddr_rwlock);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRC_IFUP</span>:
		lck_rw_lock_shared(in_ifaddr_rwlock);
		<span class="enscript-keyword">for</span> (ia = in_ifaddrhead.tqh_first; ia;
		     ia = ia-&gt;ia_link.tqe_next) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (ia-&gt;ia_ifa.ifa_addr == sa) {
				<span class="enscript-comment">/* keep it locked */</span>
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		<span class="enscript-keyword">if</span> (ia == NULL || (ia-&gt;ia_flags &amp; IFA_ROUTE) ||
		    (ia-&gt;ia_ifa.ifa_debug &amp; IFD_NOTREADY)) {
			<span class="enscript-keyword">if</span> (ia != NULL)
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">return</span>;
		}
		IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		lck_rw_done(in_ifaddr_rwlock);

		flags = RTF_UP;
		ifp = ia-&gt;ia_ifa.ifa_ifp;

		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK)
		    || (ifp-&gt;if_flags &amp; IFF_POINTOPOINT))
			flags |= RTF_HOST;

		err = rtinit(&amp;ia-&gt;ia_ifa, RTM_ADD, flags);
		<span class="enscript-keyword">if</span> (err == 0) {
			IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
			ia-&gt;ia_flags |= IFA_ROUTE;
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">break</span>;
	}
}

u_int32_t	rip_sendspace = RIPSNDQ;
u_int32_t	rip_recvspace = RIPRCVQ;

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_raw, OID_AUTO, maxdgram, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;rip_sendspace, 0, <span class="enscript-string">&quot;Maximum outgoing raw IP datagram size&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_raw, OID_AUTO, recvspace, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;rip_recvspace, 0, <span class="enscript-string">&quot;Maximum incoming raw IP datagram size&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_raw, OID_AUTO, pcbcount, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;ripcbinfo.ipi_count, 0, <span class="enscript-string">&quot;Number of active PCBs&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp)
		panic(<span class="enscript-string">&quot;rip_attach&quot;</span>);
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_PRIV) == 0)
		<span class="enscript-keyword">return</span> (EPERM);

	error = soreserve(so, rip_sendspace, rip_recvspace);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	error = in_pcballoc(so, &amp;ripcbinfo, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
	inp-&gt;inp_vflag |= INP_IPV4;
	inp-&gt;inp_ip_p = proto;
	inp-&gt;inp_ip_ttl = ip_defttl;
	<span class="enscript-keyword">return</span> 0;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == 0)
		panic(<span class="enscript-string">&quot;rip_detach&quot;</span>);
	in_pcbdetach(inp);
	<span class="enscript-keyword">return</span> 0;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_abort</span>(<span class="enscript-type">struct</span> socket *so)
{
	soisdisconnected(so);
	<span class="enscript-keyword">return</span> rip_detach(so);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISCONNECTED) == 0)
		<span class="enscript-keyword">return</span> ENOTCONN;
	<span class="enscript-keyword">return</span> rip_abort(so);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> sockaddr_in sin;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;

	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);

	<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Sanitized local copy for interface address searches */</span>
	bzero(&amp;sin, <span class="enscript-keyword">sizeof</span> (sin));
	sin.sin_family = AF_INET;
	sin.sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
	sin.sin_addr.s_addr = SIN(nam)-&gt;sin_addr.s_addr;

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;ifnet_head) ||
	    (sin.sin_family != AF_INET &amp;&amp; sin.sin_family != AF_IMPLINK) ||
	    (sin.sin_addr.s_addr &amp;&amp; (ifa = ifa_ifwithaddr(SA(&amp;sin))) == 0)) {
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa) {
		<span class="enscript-comment">/*
		 * Opportunistically determine the outbound
		 * interface that may be used; this may not
		 * hold true if we end up using a route
		 * going over a different interface, e.g.
		 * when sending to a local address.  This
		 * will get updated again after sending.
		 */</span>
		IFA_LOCK(ifa);
		outif = ifa-&gt;ifa_ifp;
		IFA_UNLOCK(ifa);
		IFA_REMREF(ifa);
	}
	inp-&gt;inp_laddr = sin.sin_addr;
	inp-&gt;inp_last_outifp = outif;
	<span class="enscript-keyword">return</span> (0);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, __unused  <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> sockaddr_in *addr = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;

	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);
	<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(*addr))
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;ifnet_head))
		<span class="enscript-keyword">return</span> EADDRNOTAVAIL;
	<span class="enscript-keyword">if</span> ((addr-&gt;sin_family != AF_INET) &amp;&amp;
	    (addr-&gt;sin_family != AF_IMPLINK))
		<span class="enscript-keyword">return</span> EAFNOSUPPORT;
	inp-&gt;inp_faddr = addr-&gt;sin_addr;
	soisconnected(so);

	<span class="enscript-keyword">return</span> 0;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_shutdown</span>(<span class="enscript-type">struct</span> socket *so)
{
	socantsendmore(so);
	<span class="enscript-keyword">return</span> 0;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">rip_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> sockaddr *nam,
    <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	u_int32_t dst;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp) &amp;&amp; (error = EPROTOTYPE))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		<span class="enscript-keyword">if</span> (inp == NULL)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = EPROTOTYPE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED) {
		<span class="enscript-keyword">if</span> (nam != NULL) {
			error = EISCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		dst = inp-&gt;inp_faddr.s_addr;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (nam == NULL) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		dst = ((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam)-&gt;sin_addr.s_addr;
	}
	<span class="enscript-keyword">return</span> (rip_output(m, so, dst, control));

<span class="enscript-reference">bad</span>:
	VERIFY(error != 0);

	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* note: rip_unlock is called from different protos  instead of the generic socket_unlock,
 * it will handle the socket dealloc on last reference 
 * */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">rip_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *debug)
{
	<span class="enscript-type">void</span> *lr_saved;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

	<span class="enscript-keyword">if</span> (debug == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = debug;

	<span class="enscript-keyword">if</span> (refcount) {
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 0) {
			panic(<span class="enscript-string">&quot;rip_unlock: bad refoucnt so=%p val=%x lrh= %s\n&quot;</span>,
			    so, so-&gt;so_usecount, solockhistory_nr(so));
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		so-&gt;so_usecount--;
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0 &amp;&amp; (inp-&gt;inp_wantcnt == WNT_STOPUSING)) {
			<span class="enscript-comment">/* cleanup after last reference */</span>
			lck_mtx_unlock(so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx);
			lck_rw_lock_exclusive(ripcbinfo.ipi_lock);
			<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
					in6_pcbdetach(inp);
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				in_pcbdetach(inp);
			}
			in_pcbdispose(inp);
			lck_rw_done(ripcbinfo.ipi_lock);
			<span class="enscript-keyword">return</span>(0);
		}
	}
	so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
	so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;
	lck_mtx_unlock(so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
rip_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i, n;
	<span class="enscript-type">struct</span> inpcb *inp, **inp_list;
	inp_gen_t gencnt;
	<span class="enscript-type">struct</span> xinpgen xig;

	<span class="enscript-comment">/*
	 * The process of preparing the TCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */</span>
	lck_rw_lock_exclusive(ripcbinfo.ipi_lock);
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		n = ripcbinfo.ipi_count;
		req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> xig)
			+ (n + n/8) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xinpcb);
		lck_rw_done(ripcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		lck_rw_done(ripcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">/*
	 * OK, now we're committed to doing something.
	 */</span>
	gencnt = ripcbinfo.ipi_gencnt;
	n = ripcbinfo.ipi_count;
	
	bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
	xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(ripcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> error;
	}
    <span class="enscript-comment">/*
     * We are done if there is no pcb
     */</span>
    <span class="enscript-keyword">if</span> (n == 0) {
	lck_rw_done(ripcbinfo.ipi_lock);
        <span class="enscript-keyword">return</span> 0; 
    }

	inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> *inp_list, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (inp_list == 0) {
		lck_rw_done(ripcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	
	<span class="enscript-keyword">for</span> (inp = ripcbinfo.ipi_listhead-&gt;lh_first, i = 0; inp &amp;&amp; i &lt; n;
	     inp = inp-&gt;inp_list.le_next) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
	}
	n = i;

	error = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
		inp = inp_list[i];
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; inp-&gt;inp_state != INPCB_STATE_DEAD) {
			<span class="enscript-type">struct</span> xinpcb xi;

			bzero(&amp;xi, <span class="enscript-keyword">sizeof</span>(xi));
			xi.xi_len = <span class="enscript-keyword">sizeof</span> xi;
			<span class="enscript-comment">/* XXX should avoid extra copy */</span>
			inpcb_to_compat(inp, &amp;xi.xi_inp);
			<span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
				sotoxsocket(inp-&gt;inp_socket, &amp;xi.xi_socket);
			error = SYSCTL_OUT(req, &amp;xi, <span class="enscript-keyword">sizeof</span> xi);
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
		xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
		xig.xig_gen = ripcbinfo.ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = ripcbinfo.ipi_count;
		error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
	}
	FREE(inp_list, M_TEMP);
	lck_rw_done(ripcbinfo.ipi_lock);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_raw, OID_AUTO<span class="enscript-comment">/*XXX*/</span>, pcblist,
	    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	    rip_pcblist, <span class="enscript-string">&quot;S,xinpcb&quot;</span>, <span class="enscript-string">&quot;List of active raw IP sockets&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
rip_pcblist64 SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
        <span class="enscript-type">int</span> error, i, n;
        <span class="enscript-type">struct</span> inpcb *inp, **inp_list;
        inp_gen_t gencnt;
        <span class="enscript-type">struct</span> xinpgen xig;

        <span class="enscript-comment">/*
         * The process of preparing the TCB list is too time-consuming and
         * resource-intensive to repeat twice on every request.
         */</span>
        lck_rw_lock_exclusive(ripcbinfo.ipi_lock);
        <span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
                n = ripcbinfo.ipi_count;
                req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> xig)
                        + (n + n/8) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xinpcb64);
                lck_rw_done(ripcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> 0;
        }

        <span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
                lck_rw_done(ripcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> EPERM;
        }

        <span class="enscript-comment">/*
         * OK, now we're committed to doing something.
         */</span>
        gencnt = ripcbinfo.ipi_gencnt;
        n = ripcbinfo.ipi_count;

        bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
        xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
        xig.xig_count = n;
        xig.xig_gen = gencnt;
        xig.xig_sogen = so_gencnt;
        error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
        <span class="enscript-keyword">if</span> (error) {
                lck_rw_done(ripcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> error;
        }
    <span class="enscript-comment">/*
     * We are done if there is no pcb
     */</span>
    <span class="enscript-keyword">if</span> (n == 0) {
        lck_rw_done(ripcbinfo.ipi_lock);
        <span class="enscript-keyword">return</span> 0;
    }

        inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> *inp_list, M_TEMP, M_WAITOK);
        <span class="enscript-keyword">if</span> (inp_list == 0) {
                lck_rw_done(ripcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> ENOMEM;
        }

        <span class="enscript-keyword">for</span> (inp = ripcbinfo.ipi_listhead-&gt;lh_first, i = 0; inp &amp;&amp; i &lt; n;
             inp = inp-&gt;inp_list.le_next) {
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; inp-&gt;inp_state != INPCB_STATE_DEAD)
                        inp_list[i++] = inp;
        }
        n = i;

        error = 0;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
                inp = inp_list[i];
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; inp-&gt;inp_state != INPCB_STATE_DEAD) {
                        <span class="enscript-type">struct</span> xinpcb64 xi;

                        bzero(&amp;xi, <span class="enscript-keyword">sizeof</span>(xi));
                        xi.xi_len = <span class="enscript-keyword">sizeof</span> xi;
                        inpcb_to_xinpcb64(inp, &amp;xi);
                        <span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
                                sotoxsocket64(inp-&gt;inp_socket, &amp;xi.xi_socket);
                        error = SYSCTL_OUT(req, &amp;xi, <span class="enscript-keyword">sizeof</span> xi);
                }
        }
        <span class="enscript-keyword">if</span> (!error) {
                <span class="enscript-comment">/*
                 * Give the user an updated idea of our state.
                 * If the generation differs from what we told
                 * her before, she knows that something happened
                 * while we were processing this request, and it
                 * might be necessary to retry.
                 */</span>
                bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
                xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
                xig.xig_gen = ripcbinfo.ipi_gencnt;
                xig.xig_sogen = so_gencnt;
                xig.xig_count = ripcbinfo.ipi_count;
                error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
        }
        FREE(inp_list, M_TEMP);
        lck_rw_done(ripcbinfo.ipi_lock);
        <span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_raw, OID_AUTO, pcblist64,
            CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
            rip_pcblist64, <span class="enscript-string">&quot;S,xinpcb64&quot;</span>, <span class="enscript-string">&quot;List of active raw IP sockets&quot;</span>);



<span class="enscript-type">static</span> <span class="enscript-type">int</span>
rip_pcblist_n SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;

	error = get_pcblist_n(IPPROTO_IP, req, &amp;ripcbinfo);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_raw, OID_AUTO, pcblist_n,
            CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
            rip_pcblist_n, <span class="enscript-string">&quot;S,xinpcb_n&quot;</span>, <span class="enscript-string">&quot;List of active raw IP sockets&quot;</span>);

<span class="enscript-type">struct</span> pr_usrreqs rip_usrreqs = {
	.pru_abort =		rip_abort,
	.pru_attach =		rip_attach,
	.pru_bind =		rip_bind,
	.pru_connect =		rip_connect,
	.pru_control =		in_control,
	.pru_detach =		rip_detach,
	.pru_disconnect =	rip_disconnect,
	.pru_peeraddr =		in_getpeeraddr,
	.pru_send =		rip_send,
	.pru_shutdown =		rip_shutdown,
	.pru_sockaddr =		in_getsockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
};
<span class="enscript-comment">/* DSEP Review Done pl-20051213-v02 @3253 */</span>
</pre>
<hr />
</body></html>