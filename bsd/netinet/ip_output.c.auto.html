<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip_output.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip_output.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip_output.c	8.3 (Berkeley) 1/21/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_IP_VHL</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_perf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETIP, 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETIP, 3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_IP_OUTPUT</span>	NETDBG_CODE(DBG_NETIP, (1 &lt;&lt; 8) | 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_IPSEC4_OUTPUT</span>	NETDBG_CODE(DBG_NETIP, (2 &lt;&lt; 8) | 1)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key_debug.h&gt;</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KEYDEBUG</span>(lev, arg)
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_divert.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span> &amp;&amp; <span class="enscript-variable-name">IPFIREWALL_FORWARD_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">print_ip</span>(a)	\
	printf(<span class="enscript-string">&quot;%ld.%ld.%ld.%ld&quot;</span>, (ntohl(a.s_addr) &gt;&gt; 24) &amp; 0xFF,	\
	    (ntohl(a.s_addr) &gt;&gt; 16) &amp; 0xFF,				\
	    (ntohl(a.s_addr) &gt;&gt; 8) &amp; 0xFF,				\
	    (ntohl(a.s_addr)) &amp; 0xFF);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD &amp;&amp; IPFIREWALL_FORWARD_DEBUG */</span>

u_short ip_id;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_reset_ip_output_stats SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip_output_measure_bins SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip_output_getperf SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_out_cksum_stats</span>(<span class="enscript-type">int</span>, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ip_insertoptions</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip_optcopy</span>(<span class="enscript-type">struct</span> ip *, <span class="enscript-type">struct</span> ip *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip_pcbopts</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">imo_trace</span>(<span class="enscript-type">struct</span> ip_moptions *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_mloopback</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
    <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *<span class="enscript-function-name">in_selectsrcif</span>(<span class="enscript-type">struct</span> ip *, <span class="enscript-type">struct</span> route *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ip_linklocal_stat ip_linklocal_stat;

<span class="enscript-comment">/* temporary: for testing */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_maxchainsent = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, maxchainsent,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_maxchainsent, 0,
	<span class="enscript-string">&quot;use dlil_output_list&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> forge_ce = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, forge_ce,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;forge_ce, 0,
	<span class="enscript-string">&quot;Forge ECN CE&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_select_srcif_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, select_srcif_debug,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_select_srcif_debug, 0,
	<span class="enscript-string">&quot;log source interface selection debug info&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_output_measure = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, output_perf,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_output_measure, 0, sysctl_reset_ip_output_stats, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;Do time measurement&quot;</span>);

<span class="enscript-type">static</span> uint64_t ip_output_measure_bins = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, output_perf_bins,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_output_measure_bins, 0,
	sysctl_ip_output_measure_bins, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;bins for chaining performance data histogram&quot;</span>);

<span class="enscript-type">static</span> net_perf_t net_perf;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, output_perf_data,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
	0, 0, sysctl_ip_output_getperf, <span class="enscript-string">&quot;S,net_perf&quot;</span>,
	<span class="enscript-string">&quot;IP output performance data (struct net_perf, net/net_perf.h)&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IMO_TRACE_HIST_SIZE</span>	32	<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> imo_trace_hist_size = IMO_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> ip_moptions_dbg {
	<span class="enscript-type">struct</span> ip_moptions	imo;			<span class="enscript-comment">/* ip_moptions */</span>
	u_int16_t		imo_refhold_cnt;	<span class="enscript-comment">/* # of IMO_ADDREF */</span>
	u_int16_t		imo_refrele_cnt;	<span class="enscript-comment">/* # of IMO_REMREF */</span>
	<span class="enscript-comment">/*
	 * Alloc and free callers.
	 */</span>
	ctrace_t		imo_alloc;
	ctrace_t		imo_free;
	<span class="enscript-comment">/*
	 * Circular lists of IMO_ADDREF and IMO_REMREF callers.
	 */</span>
	ctrace_t		imo_refhold[IMO_TRACE_HIST_SIZE];
	ctrace_t		imo_refrele[IMO_TRACE_HIST_SIZE];
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> imo_debug = 1;	<span class="enscript-comment">/* debugging (enabled) */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> imo_debug;		<span class="enscript-comment">/* debugging (disabled) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> imo_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *imo_zone;		<span class="enscript-comment">/* zone for ip_moptions */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IMO_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IMO_ZONE_NAME</span>		<span class="enscript-string">&quot;ip_moptions&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-comment">/*
 * IP output.  The packet in mbuf chain m contains a skeletal IP
 * header (with len, off, ttl, proto, tos, src, dst).
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_output</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">struct</span> mbuf *opt, <span class="enscript-type">struct</span> route *ro, <span class="enscript-type">int</span> flags,
    <span class="enscript-type">struct</span> ip_moptions *imo, <span class="enscript-type">struct</span> ip_out_args *ipoa)
{
	<span class="enscript-keyword">return</span> (ip_output_list(m0, 0, opt, ro, flags, imo, ipoa));
}

<span class="enscript-comment">/*
 * IP output.  The packet in mbuf chain m contains a skeletal IP
 * header (with len, off, ttl, proto, tos, src, dst).
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 *
 * Route ro MUST be non-NULL; if ro-&gt;ro_rt is valid, route lookup would be
 * skipped and ro-&gt;ro_rt would be used.  Otherwise the result of route
 * lookup is stored in ro-&gt;ro_rt.
 *
 * In the IP forwarding case, the packet will arrive with options already
 * inserted, so must have a NULL opt pointer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_output_list</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> packetchain, <span class="enscript-type">struct</span> mbuf *opt,
    <span class="enscript-type">struct</span> route *ro, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> ip_moptions *imo,
    <span class="enscript-type">struct</span> ip_out_args *ipoa)
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;		<span class="enscript-comment">/* not refcnt'd */</span>
	<span class="enscript-type">struct</span> mbuf *m = m0, *prevnxt = NULL, **mppn = &amp;prevnxt;
	<span class="enscript-type">int</span> hlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	<span class="enscript-type">int</span> len = 0, error = 0;
	<span class="enscript-type">struct</span> sockaddr_in *dst = NULL;
	<span class="enscript-type">struct</span> in_ifaddr *ia = NULL, *src_ia = NULL;
	<span class="enscript-type">struct</span> in_addr pkt_dst;
	<span class="enscript-type">struct</span> ipf_pktopts *ippo = NULL;
	ipfilter_t inject_filter_ref = NULL;
	<span class="enscript-type">struct</span> mbuf *packetlist;
	uint32_t sw_csum, pktcnt = 0, scnt = 0, bytecnt = 0;
	uint32_t packets_processed = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = IFSCOPE_NONE;
	<span class="enscript-type">struct</span> flowadv *adv = NULL;
	<span class="enscript-type">struct</span> timeval start_tv;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-type">struct</span> socket *so = NULL;
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	necp_kernel_policy_result necp_result = 0;
	necp_kernel_policy_result_parameter necp_result_parameter;
	necp_kernel_policy_id necp_matched_policy_id = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-type">int</span> ipfwoff;
	<span class="enscript-type">struct</span> sockaddr_in *next_hop_from_ipfwd_tag = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> m_tag *tag;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL || DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> ip_out_args saved_ipoa;
	<span class="enscript-type">struct</span> sockaddr_in dst_buf;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	<span class="enscript-type">struct</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-type">struct</span> ipsec_output_state ipsec_state;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-type">struct</span> route necp_route;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-type">struct</span> ip_fw_args args;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL || DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-type">struct</span> route sro_fwd;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-type">struct</span> route saved_route;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-type">struct</span> ipf_pktopts ipf_pktopts;
	} ipobz;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ipsec_state</span>	ipobz.ipsec_state
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">necp_route</span>	ipobz.necp_route
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">args</span>		ipobz.args
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">sro_fwd</span>		ipobz.sro_fwd
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">saved_route</span>	ipobz.saved_route
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ipf_pktopts</span>	ipobz.ipf_pktopts
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			boolean_t select_srcif : 1;	<span class="enscript-comment">/* set once */</span>
			boolean_t srcbound : 1;		<span class="enscript-comment">/* set once */</span>
			boolean_t nocell : 1;		<span class="enscript-comment">/* set once */</span>
			boolean_t isbroadcast : 1;
			boolean_t didfilter : 1;
			boolean_t noexpensive : 1;	<span class="enscript-comment">/* set once */</span>
			boolean_t awdl_unrestricted : 1;	<span class="enscript-comment">/* set once */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
			boolean_t fwd_rewrite_src : 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
		};
		uint32_t raw;
	} ipobf = { .raw = 0 };

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IP_CHECK_RESTRICTIONS</span>(_ifp, _ipobf) 				\
	(((_ipobf).nocell &amp;&amp; IFNET_IS_CELLULAR(_ifp)) ||		\
	 ((_ipobf).noexpensive &amp;&amp; IFNET_IS_EXPENSIVE(_ifp)) ||		\
	 (!(_ipobf).awdl_unrestricted &amp;&amp; IFNET_IS_AWDL_RESTRICTED(_ifp)))

	<span class="enscript-keyword">if</span> (ip_output_measure)
		net_perf_start_time(&amp;net_perf, &amp;start_tv);
	KERNEL_DEBUG(DBG_FNC_IP_OUTPUT | DBG_FUNC_START, 0, 0, 0, 0, 0);

	VERIFY(m0-&gt;m_flags &amp; M_PKTHDR);
	packetlist = m0;

	<span class="enscript-comment">/* zero out {ipsec_state, args, sro_fwd, saved_route, ipf_pktops} */</span>
	bzero(&amp;ipobz, <span class="enscript-keyword">sizeof</span> (ipobz));
	ippo = &amp;ipf_pktopts;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;m0-&gt;m_pkthdr.tags))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ipfw_tags_done</span>;

	<span class="enscript-comment">/* Grab info from mtags prepended to the chain */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m0, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DUMMYNET, NULL)) != NULL) {
		<span class="enscript-type">struct</span> dn_pkt_tag	*dn_tag;

		dn_tag = (<span class="enscript-type">struct</span> dn_pkt_tag *)(tag+1);
		args.fwa_ipfw_rule = dn_tag-&gt;dn_ipfw_rule;
		args.fwa_pf_rule = dn_tag-&gt;dn_pf_rule;
		opt = NULL;
		saved_route = dn_tag-&gt;dn_ro;
		ro = &amp;saved_route;

		imo = NULL;
		bcopy(&amp;dn_tag-&gt;dn_dst, &amp;dst_buf, <span class="enscript-keyword">sizeof</span> (dst_buf));
		dst = &amp;dst_buf;
		ifp = dn_tag-&gt;dn_ifp;
		flags = dn_tag-&gt;dn_flags;
		<span class="enscript-keyword">if</span> ((dn_tag-&gt;dn_flags &amp; IP_OUTARGS)) {
			saved_ipoa = dn_tag-&gt;dn_ipoa;
			ipoa = &amp;saved_ipoa;
		}

		m_tag_delete(m0, tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m0, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DIVERT, NULL)) != NULL) {
		<span class="enscript-type">struct</span> divert_tag	*div_tag;

		div_tag = (<span class="enscript-type">struct</span> divert_tag *)(tag+1);
		args.fwa_divert_rule = div_tag-&gt;cookie;

		m_tag_delete(m0, tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m0, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_IPFORWARD, NULL)) != NULL) {
		<span class="enscript-type">struct</span> ip_fwd_tag	*ipfwd_tag;

		ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(tag+1);
		next_hop_from_ipfwd_tag = ipfwd_tag-&gt;next_hop;

		m_tag_delete(m0, tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

<span class="enscript-reference">ipfw_tags_done</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL || DUMMYNET */</span>

	m = m0;
	m-&gt;m_pkthdr.pkt_flags &amp;= ~(PKTF_LOOP|PKTF_IFAINFO);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; !(flags &amp; IP_NOIPSEC)) {
		<span class="enscript-comment">/* If packet is bound to an interface, check bound policies */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; IP_OUTARGS) &amp;&amp; (ipoa != NULL) &amp;&amp;
			(ipoa-&gt;ipoa_flags &amp; IPOAF_BOUND_IF) &amp;&amp;
			ipoa-&gt;ipoa_boundif != IFSCOPE_NONE) {
			<span class="enscript-keyword">if</span> (ipsec4_getpolicybyinterface(m, IPSEC_DIR_OUTBOUND,
				&amp;flags, ipoa, &amp;sp) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	
	VERIFY(ro != NULL);

	<span class="enscript-keyword">if</span> (ip_doscopedroute &amp;&amp; (flags &amp; IP_OUTARGS)) {
		<span class="enscript-comment">/*
		 * In the forwarding case, only the ifscope value is used,
		 * as source interface selection doesn't take place.
		 */</span>
		<span class="enscript-keyword">if</span> ((ipobf.select_srcif = (!(flags &amp; IP_FORWARDING) &amp;&amp;
		    (ipoa-&gt;ipoa_flags &amp; IPOAF_SELECT_SRCIF)))) {
			ipf_pktopts.ippo_flags |= IPPOF_SELECT_SRCIF;
		}

		<span class="enscript-keyword">if</span> ((ipoa-&gt;ipoa_flags &amp; IPOAF_BOUND_IF) &amp;&amp;
		    ipoa-&gt;ipoa_boundif != IFSCOPE_NONE) {
			ifscope = ipoa-&gt;ipoa_boundif;
			ipf_pktopts.ippo_flags |=
			    (IPPOF_BOUND_IF | (ifscope &lt;&lt; IPPOF_SHIFT_IFSCOPE));
		}

		<span class="enscript-comment">/* double negation needed for bool bit field */</span>
		ipobf.srcbound = !!(ipoa-&gt;ipoa_flags &amp; IPOAF_BOUND_SRCADDR);
		<span class="enscript-keyword">if</span> (ipobf.srcbound)
			ipf_pktopts.ippo_flags |= IPPOF_BOUND_SRCADDR;
	} <span class="enscript-keyword">else</span> {
		ipobf.select_srcif = FALSE;
		ipobf.srcbound = FALSE;
		ifscope = IFSCOPE_NONE;
		<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS) {
			ipoa-&gt;ipoa_boundif = IFSCOPE_NONE;
			ipoa-&gt;ipoa_flags &amp;= ~(IPOAF_SELECT_SRCIF |
			    IPOAF_BOUND_IF | IPOAF_BOUND_SRCADDR);
		}
	}

	<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS) {
		<span class="enscript-keyword">if</span> (ipoa-&gt;ipoa_flags &amp; IPOAF_NO_CELLULAR) {
			ipobf.nocell = TRUE;
			ipf_pktopts.ippo_flags |= IPPOF_NO_IFT_CELLULAR;
		}
		<span class="enscript-keyword">if</span> (ipoa-&gt;ipoa_flags &amp; IPOAF_NO_EXPENSIVE) {
			ipobf.noexpensive = TRUE;
			ipf_pktopts.ippo_flags |= IPPOF_NO_IFF_EXPENSIVE;
		}
		<span class="enscript-keyword">if</span> (ipoa-&gt;ipoa_flags &amp; IPOAF_AWDL_UNRESTRICTED)
			ipobf.awdl_unrestricted = TRUE;
		adv = &amp;ipoa-&gt;ipoa_flowadv;
		adv-&gt;code = FADV_SUCCESS;
		ipoa-&gt;ipoa_retflags = 0;
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; !(flags &amp; IP_NOIPSEC)) {
		so = ipsec_getsocket(m);
		<span class="enscript-keyword">if</span> (so != NULL) {
			(<span class="enscript-type">void</span>) ipsec_setsocket(m, NULL);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (args.fwa_ipfw_rule != NULL || args.fwa_pf_rule != NULL) {
		<span class="enscript-comment">/* dummynet already saw us */</span>
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
		pkt_dst = ip-&gt;ip_dst;
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
			RT_LOCK_SPIN(ro-&gt;ro_rt);
			ia = (<span class="enscript-type">struct</span> in_ifaddr *)ro-&gt;ro_rt-&gt;rt_ifa;
			<span class="enscript-keyword">if</span> (ia) {
				<span class="enscript-comment">/* Become a regular mutex */</span>
				RT_CONVERT_LOCK(ro-&gt;ro_rt);
				IFA_ADDREF(&amp;ia-&gt;ia_ifa);
			}
			RT_UNLOCK(ro-&gt;ro_rt);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		<span class="enscript-keyword">if</span> (args.fwa_ipfw_rule != NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL  */</span>
		<span class="enscript-keyword">if</span> (args.fwa_pf_rule != NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendit</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-reference">loopit</span>:
	packets_processed++;
	ipobf.isbroadcast = FALSE;
	ipobf.didfilter = FALSE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
	ipobf.fwd_rewrite_src = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
	<span class="enscript-comment">/*
	 * No need to proccess packet twice if we've already seen it.
	 */</span>
	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		inject_filter_ref = ipf_get_inject_filter(m);
	<span class="enscript-keyword">else</span>
		inject_filter_ref = NULL;

	<span class="enscript-keyword">if</span> (opt) {
		m = ip_insertoptions(m, opt, &amp;len);
		hlen = len;
		<span class="enscript-comment">/* Update the chain */</span>
		<span class="enscript-keyword">if</span> (m != m0) {
			<span class="enscript-keyword">if</span> (m0 == packetlist)
				packetlist = m;
			m0 = m;
		}
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-comment">/*
	 * rdar://8542331
	 *
	 * When dealing with a packet chain, we need to reset &quot;next_hop&quot;
	 * because &quot;dst&quot; may have been changed to the gateway address below
	 * for the previous packet of the chain. This could cause the route
	 * to be inavertandly changed to the route to the gateway address
	 * (instead of the route to the destination).
	 */</span>
	args.fwa_next_hop = next_hop_from_ipfwd_tag;
	pkt_dst = args.fwa_next_hop ? args.fwa_next_hop-&gt;sin_addr : ip-&gt;ip_dst;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	pkt_dst = ip-&gt;ip_dst;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

	<span class="enscript-comment">/*
	 * We must not send if the packet is destined to network zero.
	 * RFC1122 3.2.1.3 (a) and (b).
	 */</span>
	<span class="enscript-keyword">if</span> (IN_ZERONET(ntohl(pkt_dst.s_addr))) {
		error = EHOSTUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Fill in IP header.
	 */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; (IP_FORWARDING|IP_RAWOUTPUT))) {
		ip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, hlen &gt;&gt; 2);
		ip-&gt;ip_off &amp;= IP_DF;
		ip-&gt;ip_id = ip_randomid();
		OSAddAtomic(1, &amp;ipstat.ips_localout);
	} <span class="enscript-keyword">else</span> {
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* For debugging, we let the stack forge congestion */</span>
	<span class="enscript-keyword">if</span> (forge_ce != 0 &amp;&amp;
	    ((ip-&gt;ip_tos &amp; IPTOS_ECN_MASK) == IPTOS_ECN_ECT1 ||
	    (ip-&gt;ip_tos &amp; IPTOS_ECN_MASK) == IPTOS_ECN_ECT0)) {
		ip-&gt;ip_tos = (ip-&gt;ip_tos &amp; ~IPTOS_ECN_MASK) | IPTOS_ECN_CE;
		forge_ce--;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	KERNEL_DEBUG(DBG_LAYER_BEG, ip-&gt;ip_dst.s_addr, ip-&gt;ip_src.s_addr,
	    ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

	dst = SIN(&amp;ro-&gt;ro_dst);

	<span class="enscript-comment">/*
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up.  If not, free it and try again.
	 * The address family should also be checked in case of sharing the
	 * cache with IPv6.
	 */</span>

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) &amp;&amp; ip-&gt;ip_src.s_addr != INADDR_ANY &amp;&amp;
		    !(flags &amp; (IP_ROUTETOIF | IP_FORWARDING))) {
			src_ia = ifa_foraddr(ip-&gt;ip_src.s_addr);
			<span class="enscript-keyword">if</span> (src_ia == NULL) {
				error = EADDRNOTAVAIL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			IFA_REMREF(&amp;src_ia-&gt;ia_ifa);
			src_ia = NULL;
		}
		<span class="enscript-comment">/*
		 * Test rt_flags without holding rt_lock for performance
		 * reasons; if the route is down it will hopefully be
		 * caught by the layer below (since it uses this route
		 * as a hint) or during the next transmit.
		 */</span>
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) || dst-&gt;sin_family != AF_INET ||
		    dst-&gt;sin_addr.s_addr != pkt_dst.s_addr)
			ROUTE_RELEASE(ro);

		<span class="enscript-comment">/*
		 * If we're doing source interface selection, we may not
		 * want to use this route; only synch up the generation
		 * count otherwise.
		 */</span>
		<span class="enscript-keyword">if</span> (!ipobf.select_srcif &amp;&amp; ro-&gt;ro_rt != NULL &amp;&amp;
		    RT_GENID_OUTOFSYNC(ro-&gt;ro_rt))
			RT_GENID_SYNC(ro-&gt;ro_rt);
	}
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
		bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
		dst-&gt;sin_family = AF_INET;
		dst-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*dst);
		dst-&gt;sin_addr = pkt_dst;
	}
	<span class="enscript-comment">/*
	 * If routing to interface only,
	 * short circuit routing lookup.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; IP_ROUTETOIF) {
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((ia = ifatoia(ifa_ifwithdstaddr(sintosa(dst)))) == NULL) {
			ia = ifatoia(ifa_ifwithnet(sintosa(dst)));
			<span class="enscript-keyword">if</span> (ia == NULL) {
				OSAddAtomic(1, &amp;ipstat.ips_noroute);
				error = ENETUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
		ifp = ia-&gt;ia_ifp;
		ip-&gt;ip_ttl = 1;
		ipobf.isbroadcast = in_broadcast(dst-&gt;sin_addr, ifp);
		<span class="enscript-comment">/*
		 * For consistency with other cases below.  Loopback
		 * multicast case is handled separately by ip_mloopback().
		 */</span>
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !IN_MULTICAST(ntohl(pkt_dst.s_addr))) {
			m-&gt;m_pkthdr.rcvif = ifp;
			ip_setsrcifaddr_info(m, ifp-&gt;if_index, NULL);
			ip_setdstifaddr_info(m, ifp-&gt;if_index, NULL);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(pkt_dst.s_addr)) &amp;&amp;
	    imo != NULL &amp;&amp; (ifp = imo-&gt;imo_multicast_ifp) != NULL) {
		<span class="enscript-comment">/*
		 * Bypass the normal routing lookup for multicast
		 * packets if the interface is specified.
		 */</span>
		ipobf.isbroadcast = FALSE;
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);

		<span class="enscript-comment">/* Macro takes reference on ia */</span>
		IFP_TO_IA(ifp, ia);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ifaddr *ia0 = NULL;
		boolean_t cloneok = FALSE;
		<span class="enscript-comment">/*
		 * Perform source interface selection; the source IP address
		 * must belong to one of the addresses of the interface used
		 * by the route.  For performance reasons, do this only if
		 * there is no route, or if the routing table has changed,
		 * or if we haven't done source interface selection on this
		 * route (for this PCB instance) before.
		 */</span>
		<span class="enscript-keyword">if</span> (ipobf.select_srcif &amp;&amp;
		    ip-&gt;ip_src.s_addr != INADDR_ANY &amp;&amp; (ROUTE_UNUSABLE(ro) ||
		    !(ro-&gt;ro_flags &amp; ROF_SRCIF_SELECTED))) {
			<span class="enscript-comment">/* Find the source interface */</span>
			ia0 = in_selectsrcif(ip, ro, ifscope);

			<span class="enscript-comment">/*
			 * If the source address belongs to a restricted
			 * interface and the caller forbids our using 
			 * interfaces of such type, pretend that there is no
			 * route.
			 */</span>
			<span class="enscript-keyword">if</span> (ia0 != NULL &amp;&amp; 
			    IP_CHECK_RESTRICTIONS(ia0-&gt;ifa_ifp, ipobf)) {
				IFA_REMREF(ia0);
				ia0 = NULL;
				error = EHOSTUNREACH;
				<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS)
					ipoa-&gt;ipoa_retflags |= IPOARF_IFDENIED;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			<span class="enscript-comment">/*
			 * If the source address is spoofed (in the case of
			 * IP_RAWOUTPUT on an unbounded socket), or if this
			 * is destined for local/loopback, just let it go out
			 * using the interface of the route.  Otherwise,
			 * there's no interface having such an address,
			 * so bail out.
			 */</span>
			<span class="enscript-keyword">if</span> (ia0 == NULL &amp;&amp; (!(flags &amp; IP_RAWOUTPUT) ||
			    ipobf.srcbound) &amp;&amp; ifscope != lo_ifp-&gt;if_index) {
				error = EADDRNOTAVAIL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			<span class="enscript-comment">/*
			 * If the caller didn't explicitly specify the scope,
			 * pick it up from the source interface.  If the cached
			 * route was wrong and was blown away as part of source
			 * interface selection, don't mask out RTF_PRCLONING
			 * since that route may have been allocated by the ULP,
			 * unless the IP header was created by the caller or
			 * the destination is IPv4 LLA.  The check for the
			 * latter is needed because IPv4 LLAs are never scoped
			 * in the current implementation, and we don't want to
			 * replace the resolved IPv4 LLA route with one whose
			 * gateway points to that of the default gateway on
			 * the primary interface of the system.
			 */</span>
			<span class="enscript-keyword">if</span> (ia0 != NULL) {
				<span class="enscript-keyword">if</span> (ifscope == IFSCOPE_NONE)
					ifscope = ia0-&gt;ifa_ifp-&gt;if_index;
				cloneok = (!(flags &amp; IP_RAWOUTPUT) &amp;&amp;
				    !(IN_LINKLOCAL(ntohl(ip-&gt;ip_dst.s_addr))));
			}
		}

		<span class="enscript-comment">/*
		 * If this is the case, we probably don't want to allocate
		 * a protocol-cloned route since we didn't get one from the
		 * ULP.  This lets TCP do its thing, while not burdening
		 * forwarding or ICMP with the overhead of cloning a route.
		 * Of course, we still want to do any cloning requested by
		 * the link layer, as this is probably required in all cases
		 * for correct operation (as it is for ARP).
		 */</span>
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ign = RTF_PRCLONING;
			<span class="enscript-comment">/*
			 * We make an exception here: if the destination
			 * address is INADDR_BROADCAST, allocate a protocol-
			 * cloned host route so that we end up with a route
			 * marked with the RTF_BROADCAST flag.  Otherwise,
			 * we would end up referring to the default route,
			 * instead of creating a cloned host route entry.
			 * That would introduce inconsistencies between ULPs
			 * that allocate a route and those that don't.  The
			 * RTF_BROADCAST route is important since we'd want
			 * to send out undirected IP broadcast packets using
			 * link-level broadcast address. Another exception
			 * is for ULP-created routes that got blown away by
			 * source interface selection (see above).
			 *
			 * These exceptions will no longer be necessary when
			 * the RTF_PRCLONING scheme is no longer present.
			 */</span>
			<span class="enscript-keyword">if</span> (cloneok || dst-&gt;sin_addr.s_addr == INADDR_BROADCAST)
				ign &amp;= ~RTF_PRCLONING;

			<span class="enscript-comment">/*
			 * Loosen the route lookup criteria if the ifscope
			 * corresponds to the loopback interface; this is
			 * needed to support Application Layer Gateways
			 * listening on loopback, in conjunction with packet
			 * filter redirection rules.  The final source IP
			 * address will be rewritten by the packet filter
			 * prior to the RFC1122 loopback check below.
			 */</span>
			<span class="enscript-keyword">if</span> (ifscope == lo_ifp-&gt;if_index)
				rtalloc_ign(ro, ign);
			<span class="enscript-keyword">else</span>
				rtalloc_scoped_ign(ro, ign, ifscope);

			<span class="enscript-comment">/*
			 * If the route points to a cellular/expensive interface 
			 * and the caller forbids our using interfaces of such type,
			 * pretend that there is no route.
			 */</span>
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
				RT_LOCK_SPIN(ro-&gt;ro_rt);
				<span class="enscript-keyword">if</span> (IP_CHECK_RESTRICTIONS(ro-&gt;ro_rt-&gt;rt_ifp,
				    ipobf)) {
					RT_UNLOCK(ro-&gt;ro_rt);
					ROUTE_RELEASE(ro);
					<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS) {
						ipoa-&gt;ipoa_retflags |=
						    IPOARF_IFDENIED;
					}
				} <span class="enscript-keyword">else</span> {
					RT_UNLOCK(ro-&gt;ro_rt);
				}
			}
		}

		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
			OSAddAtomic(1, &amp;ipstat.ips_noroute);
			error = EHOSTUNREACH;
			<span class="enscript-keyword">if</span> (ia0 != NULL) {
				IFA_REMREF(ia0);
				ia0 = NULL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		RT_LOCK_SPIN(ro-&gt;ro_rt);
		ia = ifatoia(ro-&gt;ro_rt-&gt;rt_ifa);
		<span class="enscript-keyword">if</span> (ia != NULL) {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(ro-&gt;ro_rt);
			IFA_ADDREF(&amp;ia-&gt;ia_ifa);
		}
		<span class="enscript-comment">/*
		 * Note: ia_ifp may not be the same as rt_ifp; the latter
		 * is what we use for determining outbound i/f, mtu, etc.
		 */</span>
		ifp = ro-&gt;ro_rt-&gt;rt_ifp;
		ro-&gt;ro_rt-&gt;rt_use++;
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY) {
			dst = SIN(ro-&gt;ro_rt-&gt;rt_gateway);
		}
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_HOST) {
			<span class="enscript-comment">/* double negation needed for bool bit field */</span>
			ipobf.isbroadcast =
			    !!(ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_BROADCAST);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(ro-&gt;ro_rt);
			ipobf.isbroadcast = in_broadcast(dst-&gt;sin_addr, ifp);
		}
		<span class="enscript-comment">/*
		 * For consistency with IPv6, as well as to ensure that
		 * IP_RECVIF is set correctly for packets that are sent
		 * to one of the local addresses.  ia (rt_ifa) would have
		 * been fixed up by rt_setif for local routes.  This
		 * would make it appear as if the packet arrives on the
		 * interface which owns the local address.  Loopback
		 * multicast case is handled separately by ip_mloopback().
		 */</span>
		<span class="enscript-keyword">if</span> (ia != NULL &amp;&amp; (ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !IN_MULTICAST(ntohl(pkt_dst.s_addr))) {
			uint32_t srcidx;

			m-&gt;m_pkthdr.rcvif = ia-&gt;ia_ifa.ifa_ifp;

			<span class="enscript-keyword">if</span> (ia0 != NULL)
				srcidx = ia0-&gt;ifa_ifp-&gt;if_index;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ro-&gt;ro_flags &amp; ROF_SRCIF_SELECTED) &amp;&amp;
			    ro-&gt;ro_srcia != NULL)
				srcidx = ro-&gt;ro_srcia-&gt;ifa_ifp-&gt;if_index;
			<span class="enscript-keyword">else</span>
				srcidx = 0;

			ip_setsrcifaddr_info(m, srcidx, NULL);
			ip_setdstifaddr_info(m, 0, ia);
		}
		RT_UNLOCK(ro-&gt;ro_rt);
		<span class="enscript-keyword">if</span> (ia0 != NULL) {
			IFA_REMREF(ia0);
			ia0 = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(pkt_dst.s_addr))) {
		<span class="enscript-type">struct</span> ifnet *srcifp = NULL;
		<span class="enscript-type">struct</span> in_multi *inm;
		u_int32_t vif;
		u_int8_t ttl = IP_DEFAULT_MULTICAST_TTL;
		u_int8_t loop = IP_DEFAULT_MULTICAST_LOOP;

		m-&gt;m_flags |= M_MCAST;
		<span class="enscript-comment">/*
		 * IP destination address is multicast.  Make sure &quot;dst&quot;
		 * still points to the address in &quot;ro&quot;.  (It may have been
		 * changed to point to a gateway address, above.)
		 */</span>
		dst = SIN(&amp;ro-&gt;ro_dst);
		<span class="enscript-comment">/*
		 * See if the caller provided any multicast options
		 */</span>
		<span class="enscript-keyword">if</span> (imo != NULL) {
			IMO_LOCK(imo);
			vif = imo-&gt;imo_multicast_vif;
			ttl = imo-&gt;imo_multicast_ttl;
			loop = imo-&gt;imo_multicast_loop;
			<span class="enscript-keyword">if</span> (!(flags &amp; IP_RAWOUTPUT))
				ip-&gt;ip_ttl = ttl;
			<span class="enscript-keyword">if</span> (imo-&gt;imo_multicast_ifp != NULL)
				ifp = imo-&gt;imo_multicast_ifp;
			IMO_UNLOCK(imo);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(flags &amp; IP_RAWOUTPUT)) {
			vif = -1;
			ip-&gt;ip_ttl = ttl;
		}
		<span class="enscript-comment">/*
		 * Confirm that the outgoing interface supports multicast.
		 */</span>
		<span class="enscript-keyword">if</span> (imo == NULL || vif == -1) {
			<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_MULTICAST)) {
				OSAddAtomic(1, &amp;ipstat.ips_noroute);
				error = ENETUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
		<span class="enscript-comment">/*
		 * If source address not specified yet, use address
		 * of outgoing interface.
		 */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_src.s_addr == INADDR_ANY) {
			<span class="enscript-type">struct</span> in_ifaddr *ia1;
			lck_rw_lock_shared(in_ifaddr_rwlock);
			TAILQ_FOREACH(ia1, &amp;in_ifaddrhead, ia_link) {
				IFA_LOCK_SPIN(&amp;ia1-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> (ia1-&gt;ia_ifp == ifp) {
					ip-&gt;ip_src = IA_SIN(ia1)-&gt;sin_addr;
					srcifp = ifp;
					IFA_UNLOCK(&amp;ia1-&gt;ia_ifa);
					<span class="enscript-keyword">break</span>;
				}
				IFA_UNLOCK(&amp;ia1-&gt;ia_ifa);
			}
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">if</span> (ip-&gt;ip_src.s_addr == INADDR_ANY) {
				error = ENETUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}

		in_multihead_lock_shared();
		IN_LOOKUP_MULTI(&amp;pkt_dst, ifp, inm);
		in_multihead_lock_done();
		<span class="enscript-keyword">if</span> (inm != NULL &amp;&amp; (imo == NULL || loop)) {
			<span class="enscript-comment">/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */</span>
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ipv4_filters)) {
				<span class="enscript-type">struct</span> ipfilter	*filter;
				<span class="enscript-type">int</span> seen = (inject_filter_ref == NULL);

				<span class="enscript-keyword">if</span> (imo != NULL) {
					ipf_pktopts.ippo_flags |=
					    IPPOF_MCAST_OPTS;
					ipf_pktopts.ippo_mcast_ifnet = ifp;
					ipf_pktopts.ippo_mcast_ttl = ttl;
					ipf_pktopts.ippo_mcast_loop = loop;
				}

				ipf_ref();

				<span class="enscript-comment">/*
				 * 4135317 - always pass network byte
				 * order to filter
				 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
				HTONS(ip-&gt;ip_len);
				HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
				TAILQ_FOREACH(filter, &amp;ipv4_filters, ipf_link) {
					<span class="enscript-keyword">if</span> (seen == 0) {
						<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> ipfilter *)
						    inject_filter_ref == filter)
							seen = 1;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.
					    ipf_output != NULL) {
						errno_t result;
						result = filter-&gt;ipf_filter.
						    ipf_output(filter-&gt;
						    ipf_filter.cookie,
						    (mbuf_t *)&amp;m, ippo);
						<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
							ipf_unref();
							INM_REMREF(inm);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
						}
						<span class="enscript-keyword">if</span> (result != 0) {
							ipf_unref();
							INM_REMREF(inm);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
						}
					}
				}

				<span class="enscript-comment">/* set back to host byte order */</span>
				ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
				NTOHS(ip-&gt;ip_len);
				NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
				ipf_unref();
				ipobf.didfilter = TRUE;
			}
			ip_mloopback(srcifp, ifp, m, dst, hlen);
		}
		<span class="enscript-keyword">if</span> (inm != NULL)
			INM_REMREF(inm);
		<span class="enscript-comment">/*
		 * Multicasts with a time-to-live of zero may be looped-
		 * back, above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_ttl == 0 || ifp-&gt;if_flags &amp; IFF_LOOPBACK) {
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendit</span>;
	}
	<span class="enscript-comment">/*
	 * If source address not specified yet, use address
	 * of outgoing interface.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_src.s_addr == INADDR_ANY) {
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		ip-&gt;ip_src = IA_SIN(ia)-&gt;sin_addr;
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-comment">/*
		 * Keep note that we did this - if the firewall changes
		 * the next-hop, our interface may change, changing the
		 * default source IP. It's a shame so much effort happens
		 * twice. Oh well.
		 */</span>
		ipobf.fwd_rewrite_src = TRUE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
	}

	<span class="enscript-comment">/*
	 * Look for broadcast address and
	 * and verify user is allowed to send
	 * such a packet.
	 */</span>
	<span class="enscript-keyword">if</span> (ipobf.isbroadcast) {
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_BROADCAST)) {
			error = EADDRNOTAVAIL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (!(flags &amp; IP_ALLOWBROADCAST)) {
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-comment">/* don't allow broadcast messages to be fragmented */</span>
		<span class="enscript-keyword">if</span> ((u_short)ip-&gt;ip_len &gt; ifp-&gt;if_mtu) {
			error = EMSGSIZE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		m-&gt;m_flags |= M_BCAST;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_flags &amp;= ~M_BCAST;
	}

<span class="enscript-reference">sendit</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Invoke outbound packet filter */</span>
	<span class="enscript-keyword">if</span> (PF_IS_ENABLED) {
		<span class="enscript-type">int</span> rc;

		m0 = m; <span class="enscript-comment">/* Save for later */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		args.fwa_m = m;
		args.fwa_next_hop = dst;
		args.fwa_oif = ifp;
		args.fwa_ro = ro;
		args.fwa_dst = dst;
		args.fwa_oflags = flags;
		<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS)
			args.fwa_ipoa = ipoa;
		rc = pf_af_hook(ifp, mppn, &amp;m, AF_INET, FALSE, &amp;args);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DUMMYNET */</span>
		rc = pf_af_hook(ifp, mppn, &amp;m, AF_INET, FALSE, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-keyword">if</span> (rc != 0 || m == NULL) {
			<span class="enscript-comment">/* Move to the next packet */</span>
			m = *mppn;

			<span class="enscript-comment">/* Skip ahead if first packet in list got dropped */</span>
			<span class="enscript-keyword">if</span> (packetlist == m0)
				packetlist = m;

			<span class="enscript-keyword">if</span> (m != NULL) {
				m0 = m;
				<span class="enscript-comment">/* Next packet in the chain */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopit</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (packetlist != NULL) {
				<span class="enscript-comment">/* No more packet; send down the chain */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendchain</span>;
			}
			<span class="enscript-comment">/* Nothing left; we're done */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		m0 = m;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		pkt_dst = ip-&gt;ip_dst;
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>
	<span class="enscript-comment">/*
	 * Force IP TTL to 255 following draft-ietf-zeroconf-ipv4-linklocal.txt
	 */</span>
	<span class="enscript-keyword">if</span> (IN_LINKLOCAL(ntohl(ip-&gt;ip_src.s_addr)) ||
	    IN_LINKLOCAL(ntohl(ip-&gt;ip_dst.s_addr))) {
		ip_linklocal_stat.iplls_out_total++;
		<span class="enscript-keyword">if</span> (ip-&gt;ip_ttl != MAXTTL) {
			ip_linklocal_stat.iplls_out_badttl++;
			ip-&gt;ip_ttl = MAXTTL;
		}
	}

	<span class="enscript-keyword">if</span> (!ipobf.didfilter &amp;&amp; !TAILQ_EMPTY(&amp;ipv4_filters)) {
		<span class="enscript-type">struct</span> ipfilter	*filter;
		<span class="enscript-type">int</span> seen = (inject_filter_ref == NULL);
		ipf_pktopts.ippo_flags &amp;= ~IPPOF_MCAST_OPTS;

		<span class="enscript-comment">/*
		 * Check that a TSO frame isn't passed to a filter.
		 * This could happen if a filter is inserted while
		 * TCP is sending the TSO packet.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4) {
			error = EMSGSIZE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		ipf_ref();

		<span class="enscript-comment">/* 4135317 - always pass network byte order to filter */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
		HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		TAILQ_FOREACH(filter, &amp;ipv4_filters, ipf_link) {
			<span class="enscript-keyword">if</span> (seen == 0) {
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> ipfilter *)inject_filter_ref ==
				    filter)
					seen = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.ipf_output) {
				errno_t result;
				result = filter-&gt;ipf_filter.
				    ipf_output(filter-&gt;ipf_filter.cookie,
				    (mbuf_t *)&amp;m, ippo);
				<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
					ipf_unref();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				<span class="enscript-keyword">if</span> (result != 0) {
					ipf_unref();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
			}
		}
		<span class="enscript-comment">/* set back to host byte order */</span>
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		NTOHS(ip-&gt;ip_len);
		NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		ipf_unref();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">/* Process Network Extension Policy. Will Pass, Drop, or Rebind packet. */</span>
	necp_matched_policy_id = necp_ip_output_find_policy_match (m,
		flags, (flags &amp; IP_OUTARGS) ? ipoa : NULL, &amp;necp_result, &amp;necp_result_parameter);
	<span class="enscript-keyword">if</span> (necp_matched_policy_id) {
		necp_mark_packet_from_ip(m, necp_matched_policy_id);
		<span class="enscript-keyword">switch</span> (necp_result) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_PASS</span>:
				<span class="enscript-comment">/* Check if the interface is allowed */</span>
				<span class="enscript-keyword">if</span> (!necp_packet_is_allowed_over_interface(m, ifp)) {
					error = EHOSTUNREACH;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_DROP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT</span>:
				<span class="enscript-comment">/* Flow divert packets should be blocked at the IP layer */</span>
				error = EHOSTUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_IP_TUNNEL</span>: {
				<span class="enscript-comment">/* Verify that the packet is being routed to the tunnel */</span>
				<span class="enscript-type">struct</span> ifnet *policy_ifp = necp_get_ifnet_from_result_parameter(&amp;necp_result_parameter);
				<span class="enscript-keyword">if</span> (policy_ifp == ifp) {
					<span class="enscript-comment">/* Check if the interface is allowed */</span>
					<span class="enscript-keyword">if</span> (!necp_packet_is_allowed_over_interface(m, ifp)) {
						error = EHOSTUNREACH;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (necp_packet_can_rebind_to_ifnet(m, policy_ifp, &amp;necp_route, AF_INET)) {
						<span class="enscript-comment">/* Check if the interface is allowed */</span>
						<span class="enscript-keyword">if</span> (!necp_packet_is_allowed_over_interface(m, policy_ifp)) {
							error = EHOSTUNREACH;
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
						}

						<span class="enscript-comment">/* Set ifp to the tunnel interface, since it is compatible with the packet */</span>
						ifp = policy_ifp;
						ro = &amp;necp_route;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
					} <span class="enscript-keyword">else</span> {
						error = ENETUNREACH;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-comment">/* Catch-all to check if the interface is allowed */</span>
	<span class="enscript-keyword">if</span> (!necp_packet_is_allowed_over_interface(m, ifp)) {
		error = EHOSTUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0 || (flags &amp; IP_NOIPSEC))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;

	KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_START, 0, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> (sp == NULL) {
		<span class="enscript-comment">/* get SP for this packet */</span>
		<span class="enscript-keyword">if</span> (so != NULL) {
			sp = ipsec4_getpolicybysock(m, IPSEC_DIR_OUTBOUND,
				so, &amp;error);
		} <span class="enscript-keyword">else</span> {
			sp = ipsec4_getpolicybyaddr(m, IPSEC_DIR_OUTBOUND,
				flags, &amp;error);
		}
		<span class="enscript-keyword">if</span> (sp == NULL) {
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
						 0, 0, 0, 0, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	error = 0;

	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (sp-&gt;policy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
		<span class="enscript-comment">/*
		 * This packet is just discarded.
		 */</span>
		IPSEC_STAT_INCREMENT(ipsecstat.out_polvio);
		KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
		    1, 0, 0, 0, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-comment">/* no need to do IPsec. */</span>
		KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
		    2, 0, 0, 0, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
		<span class="enscript-keyword">if</span> (sp-&gt;req == NULL) {
			<span class="enscript-comment">/* acquire a policy */</span>
			error = key_spdacquire(sp);
			KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
			    3, 0, 0, 0, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (sp-&gt;ipsec_if) {
			<span class="enscript-comment">/* Verify the redirect to ipsec interface */</span>
			<span class="enscript-keyword">if</span> (sp-&gt;ipsec_if == ifp) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;ip_output: Invalid policy found. %d\n&quot;</span>, sp-&gt;policy);
	}
	{
	ipsec_state.m = m;
	<span class="enscript-keyword">if</span> (flags &amp; IP_ROUTETOIF) {
		bzero(&amp;ipsec_state.ro, <span class="enscript-keyword">sizeof</span> (ipsec_state.ro));
	} <span class="enscript-keyword">else</span> {
		route_copyout(&amp;ipsec_state.ro, ro, <span class="enscript-keyword">sizeof</span> (ipsec_state.ro));
	}
	ipsec_state.dst = SA(dst);

	ip-&gt;ip_sum = 0;

	<span class="enscript-comment">/*
	 * XXX
	 * delayed checksums are not currently compatible with IPsec
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_DATA)
		in_delayed_cksum(m);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	HTONS(ip-&gt;ip_len);
	HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

	DTRACE_IP6(send, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, ifp,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

	error = ipsec4_output(&amp;ipsec_state, sp, flags);

	m0 = m = ipsec_state.m;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-comment">/*
	 * If we're about to use the route in ipsec_state
	 * and this came from dummynet, cleaup now.
	 */</span>
	<span class="enscript-keyword">if</span> (ro == &amp;saved_route &amp;&amp;
	    (!(flags &amp; IP_ROUTETOIF) || ipsec_state.tunneled))
		ROUTE_RELEASE(ro);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	<span class="enscript-keyword">if</span> (flags &amp; IP_ROUTETOIF) {
		<span class="enscript-comment">/*
		 * if we have tunnel mode SA, we may need to ignore
		 * IP_ROUTETOIF.
		 */</span>
		<span class="enscript-keyword">if</span> (ipsec_state.tunneled) {
			flags &amp;= ~IP_ROUTETOIF;
			ro = &amp;ipsec_state.ro;
		}
	} <span class="enscript-keyword">else</span> {
		ro = &amp;ipsec_state.ro;
	}
	dst = SIN(ipsec_state.dst);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* mbuf is already reclaimed in ipsec4_output. */</span>
		m0 = NULL;
		<span class="enscript-keyword">switch</span> (error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOMEM</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;ip4_output (ipsec): error code %d\n&quot;</span>, error);
			<span class="enscript-comment">/* FALLTHRU */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
			<span class="enscript-comment">/* don't show these error codes to the user */</span>
			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
		    4, 0, 0, 0, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	}

	<span class="enscript-comment">/* be sure to update variables that are affected by ipsec4_output() */</span>
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !_IP_VHL */</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IP_VHL */</span>
	<span class="enscript-comment">/* Check that there wasn't a route change and src is still valid */</span>
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro)) {
		ROUTE_RELEASE(ro);
		VERIFY(src_ia == NULL);
		<span class="enscript-keyword">if</span> (ip-&gt;ip_src.s_addr != INADDR_ANY &amp;&amp;
		    !(flags &amp; (IP_ROUTETOIF | IP_FORWARDING)) &amp;&amp;
		    (src_ia = ifa_foraddr(ip-&gt;ip_src.s_addr)) == NULL) {
			error = EADDRNOTAVAIL;
			KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
			    5, 0, 0, 0, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (src_ia != NULL) {
			IFA_REMREF(&amp;src_ia-&gt;ia_ifa);
			src_ia = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
		<span class="enscript-keyword">if</span> (!(flags &amp; IP_ROUTETOIF)) {
			printf(<span class="enscript-string">&quot;%s: can't update route after &quot;</span>
			    <span class="enscript-string">&quot;IPsec processing\n&quot;</span>, __func__);
			error = EHOSTUNREACH;	<span class="enscript-comment">/* XXX */</span>
			KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
			    6, 0, 0, 0, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		RT_LOCK_SPIN(ro-&gt;ro_rt);
		ia = ifatoia(ro-&gt;ro_rt-&gt;rt_ifa);
		<span class="enscript-keyword">if</span> (ia != NULL) {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(ro-&gt;ro_rt);
			IFA_ADDREF(&amp;ia-&gt;ia_ifa);
		}
		ifp = ro-&gt;ro_rt-&gt;rt_ifp;
		RT_UNLOCK(ro-&gt;ro_rt);
	}

	<span class="enscript-comment">/* make it flipped, again. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_len);
	NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
	KERNEL_DEBUG(DBG_FNC_IPSEC4_OUTPUT | DBG_FUNC_END,
	    7, 0xff, 0xff, 0xff, 0xff);

	<span class="enscript-comment">/* Pass to filters again */</span>
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ipv4_filters)) {
		<span class="enscript-type">struct</span> ipfilter	*filter;

		ipf_pktopts.ippo_flags &amp;= ~IPPOF_MCAST_OPTS;

		<span class="enscript-comment">/*
		 * Check that a TSO frame isn't passed to a filter.
		 * This could happen if a filter is inserted while
		 * TCP is sending the TSO packet.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4) {
			error = EMSGSIZE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		ipf_ref();

		<span class="enscript-comment">/* 4135317 - always pass network byte order to filter */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
		HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		TAILQ_FOREACH(filter, &amp;ipv4_filters, ipf_link) {
			<span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.ipf_output) {
				errno_t result;
				result = filter-&gt;ipf_filter.
				    ipf_output(filter-&gt;ipf_filter.cookie,
				    (mbuf_t *)&amp;m, ippo);
				<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
					ipf_unref();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				<span class="enscript-keyword">if</span> (result != 0) {
					ipf_unref();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
			}
		}
		<span class="enscript-comment">/* set back to host byte order */</span>
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		NTOHS(ip-&gt;ip_len);
		NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		ipf_unref();
	}
<span class="enscript-reference">skip_ipsec</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-comment">/*
	 * Check with the firewall...
	 * but not if we are already being fwd'd from a firewall.
	 */</span>
	<span class="enscript-keyword">if</span> (fw_enable &amp;&amp; IPFW_LOADED &amp;&amp; !args.fwa_next_hop) {
		<span class="enscript-type">struct</span> sockaddr_in *old = dst;

		args.fwa_m = m;
		args.fwa_next_hop = dst;
		args.fwa_oif = ifp;
		ipfwoff = ip_fw_chk_ptr(&amp;args);
		m = args.fwa_m;
		dst = args.fwa_next_hop;

		<span class="enscript-comment">/*
		 * On return we must do the following:
		 *   IP_FW_PORT_DENY_FLAG	  -&gt; drop the pkt (XXX new)
		 *   1&lt;=off&lt;= 0xffff		  -&gt; DIVERT
		 *   (off &amp; IP_FW_PORT_DYNT_FLAG) -&gt; send to a DUMMYNET pipe
		 *   (off &amp; IP_FW_PORT_TEE_FLAG)  -&gt; TEE the packet
		 *   dst != old			  -&gt; IPFIREWALL_FORWARD
		 *   off==0, dst==old		  -&gt; accept
		 * If some of the above modules is not compiled in, then
		 * we should't have to check the corresponding condition
		 * (because the ipfw control socket should not accept
		 * unsupported rules), but better play safe and drop
		 * packets in case of doubt.
		 */</span>
		m0 = m;
		<span class="enscript-keyword">if</span> ((ipfwoff &amp; IP_FW_PORT_DENY_FLAG) || m == NULL) {
			<span class="enscript-keyword">if</span> (m)
				m_freem(m);
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);

		<span class="enscript-keyword">if</span> (ipfwoff == 0 &amp;&amp; dst == old) {	<span class="enscript-comment">/* common case */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-keyword">if</span> (DUMMYNET_LOADED &amp;&amp; (ipfwoff &amp; IP_FW_PORT_DYNT_FLAG) != 0) {
			<span class="enscript-comment">/*
			 * pass the pkt to dummynet. Need to include
			 * pipe number, m, ifp, ro, dst because these are
			 * not recomputed in the next pass.
			 * All other parameters have been already used and
			 * so they are not needed anymore.
			 * XXX note: if the ifp or ro entry are deleted
			 * while a pkt is in dummynet, we are in trouble!
			 */</span>
			args.fwa_ro = ro;
			args.fwa_dst = dst;
			args.fwa_oflags = flags;
			<span class="enscript-keyword">if</span> (flags &amp; IP_OUTARGS)
				args.fwa_ipoa = ipoa;

			error = ip_dn_io_ptr(m, ipfwoff &amp; 0xffff, DN_TO_IP_OUT,
			    &amp;args, DN_CLIENT_IPFW);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-keyword">if</span> (ipfwoff != 0 &amp;&amp; (ipfwoff &amp; IP_FW_PORT_DYNT_FLAG) == 0) {
			<span class="enscript-type">struct</span> mbuf *clone = NULL;

			<span class="enscript-comment">/* Clone packet if we're doing a 'tee' */</span>
			<span class="enscript-keyword">if</span> ((ipfwoff &amp; IP_FW_PORT_TEE_FLAG) != 0)
				clone = m_dup(m, M_DONTWAIT);
			<span class="enscript-comment">/*
			 * XXX
			 * delayed checksums are not currently compatible
			 * with divert sockets.
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_DATA)
				in_delayed_cksum(m);

			<span class="enscript-comment">/* Restore packet header fields to original values */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			HTONS(ip-&gt;ip_len);
			HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

			<span class="enscript-comment">/* Deliver packet to divert input routine */</span>
			divert_packet(m, 0, ipfwoff &amp; 0xffff,
			    args.fwa_divert_rule);

			<span class="enscript-comment">/* If 'tee', continue with original packet */</span>
			<span class="enscript-keyword">if</span> (clone != NULL) {
				m0 = m = clone;
				ip = mtod(m, <span class="enscript-type">struct</span> ip *);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-comment">/*
		 * Here we check dst to make sure it's directly reachable on
		 * the interface we previously thought it was.
		 * If it isn't (which may be likely in some situations) we have
		 * to re-route it (ie, find a route for the next-hop and the
		 * associated interface) and set them here. This is nested
		 * forwarding which in most cases is undesirable, except where
		 * such control is nigh impossible. So we do it here.
		 * And I'm babbling.
		 */</span>
		<span class="enscript-keyword">if</span> (ipfwoff == 0 &amp;&amp; old != dst) {
			<span class="enscript-type">struct</span> in_ifaddr *ia_fw;
			<span class="enscript-type">struct</span> route *ro_fwd = &amp;sro_fwd;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD_DEBUG</span>
			printf(<span class="enscript-string">&quot;IPFIREWALL_FORWARD: New dst ip: &quot;</span>);
			print_ip(dst-&gt;sin_addr);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD_DEBUG */</span>
			<span class="enscript-comment">/*
			 * We need to figure out if we have been forwarded
			 * to a local socket. If so then we should somehow
			 * &quot;loop back&quot; to ip_input, and get directed to the
			 * PCB as if we had received this packet. This is
			 * because it may be dificult to identify the packets
			 * you want to forward until they are being output
			 * and have selected an interface. (e.g. locally
			 * initiated packets) If we used the loopback inteface,
			 * we would not be able to control what happens
			 * as the packet runs through ip_input() as
			 * it is done through a ISR.
			 */</span>
			lck_rw_lock_shared(in_ifaddr_rwlock);
			TAILQ_FOREACH(ia_fw, &amp;in_ifaddrhead, ia_link) {
				<span class="enscript-comment">/*
				 * If the addr to forward to is one
				 * of ours, we pretend to
				 * be the destination for this packet.
				 */</span>
				IFA_LOCK_SPIN(&amp;ia_fw-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> (IA_SIN(ia_fw)-&gt;sin_addr.s_addr ==
				    dst-&gt;sin_addr.s_addr) {
					IFA_UNLOCK(&amp;ia_fw-&gt;ia_ifa);
					<span class="enscript-keyword">break</span>;
				}
				IFA_UNLOCK(&amp;ia_fw-&gt;ia_ifa);
			}
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">if</span> (ia_fw) {
				<span class="enscript-comment">/* tell ip_input &quot;dont filter&quot; */</span>
				<span class="enscript-type">struct</span> m_tag		*fwd_tag;
				<span class="enscript-type">struct</span> ip_fwd_tag	*ipfwd_tag;

				fwd_tag = m_tag_create(KERNEL_MODULE_TAG_ID,
				    KERNEL_TAG_TYPE_IPFORWARD,
				    <span class="enscript-keyword">sizeof</span> (*ipfwd_tag), M_NOWAIT, m);
				<span class="enscript-keyword">if</span> (fwd_tag == NULL) {
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}

				ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(fwd_tag+1);
				ipfwd_tag-&gt;next_hop = args.fwa_next_hop;

				m_tag_prepend(m, fwd_tag);

				<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif == NULL)
					m-&gt;m_pkthdr.rcvif = lo_ifp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
				HTONS(ip-&gt;ip_len);
				HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
				mbuf_outbound_finalize(m, PF_INET, 0);

				<span class="enscript-comment">/*
				 * we need to call dlil_output to run filters
				 * and resync to avoid recursion loops.
				 */</span>
				<span class="enscript-keyword">if</span> (lo_ifp) {
					dlil_output(lo_ifp, PF_INET, m, NULL,
					    SA(dst), 0, adv);
				} <span class="enscript-keyword">else</span> {
					printf(<span class="enscript-string">&quot;%s: no loopback ifp for &quot;</span>
					    <span class="enscript-string">&quot;forwarding!!!\n&quot;</span>, __func__);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-comment">/*
			 * Some of the logic for this was nicked from above.
			 *
			 * This rewrites the cached route in a local PCB.
			 * Is this what we want to do?
			 */</span>
			ROUTE_RELEASE(ro_fwd);
			bcopy(dst, &amp;ro_fwd-&gt;ro_dst, <span class="enscript-keyword">sizeof</span> (*dst));

			rtalloc_ign(ro_fwd, RTF_PRCLONING);

			<span class="enscript-keyword">if</span> (ro_fwd-&gt;ro_rt == NULL) {
				OSAddAtomic(1, &amp;ipstat.ips_noroute);
				error = EHOSTUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			RT_LOCK_SPIN(ro_fwd-&gt;ro_rt);
			ia_fw = ifatoia(ro_fwd-&gt;ro_rt-&gt;rt_ifa);
			<span class="enscript-keyword">if</span> (ia_fw != NULL) {
				<span class="enscript-comment">/* Become a regular mutex */</span>
				RT_CONVERT_LOCK(ro_fwd-&gt;ro_rt);
				IFA_ADDREF(&amp;ia_fw-&gt;ia_ifa);
			}
			ifp = ro_fwd-&gt;ro_rt-&gt;rt_ifp;
			ro_fwd-&gt;ro_rt-&gt;rt_use++;
			<span class="enscript-keyword">if</span> (ro_fwd-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY)
				dst = SIN(ro_fwd-&gt;ro_rt-&gt;rt_gateway);
			<span class="enscript-keyword">if</span> (ro_fwd-&gt;ro_rt-&gt;rt_flags &amp; RTF_HOST) {
				<span class="enscript-comment">/* double negation needed for bool bit field */</span>
				ipobf.isbroadcast =
				    !!(ro_fwd-&gt;ro_rt-&gt;rt_flags &amp; RTF_BROADCAST);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Become a regular mutex */</span>
				RT_CONVERT_LOCK(ro_fwd-&gt;ro_rt);
				ipobf.isbroadcast =
				    in_broadcast(dst-&gt;sin_addr, ifp);
			}
			RT_UNLOCK(ro_fwd-&gt;ro_rt);
			ROUTE_RELEASE(ro);
			ro-&gt;ro_rt = ro_fwd-&gt;ro_rt;
			ro_fwd-&gt;ro_rt = NULL;
			dst = SIN(&amp;ro_fwd-&gt;ro_dst);

			<span class="enscript-comment">/*
			 * If we added a default src ip earlier,
			 * which would have been gotten from the-then
			 * interface, do it again, from the new one.
			 */</span>
			<span class="enscript-keyword">if</span> (ia_fw != NULL) {
				<span class="enscript-keyword">if</span> (ipobf.fwd_rewrite_src) {
					IFA_LOCK_SPIN(&amp;ia_fw-&gt;ia_ifa);
					ip-&gt;ip_src = IA_SIN(ia_fw)-&gt;sin_addr;
					IFA_UNLOCK(&amp;ia_fw-&gt;ia_ifa);
				}
				IFA_REMREF(&amp;ia_fw-&gt;ia_ifa);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
		<span class="enscript-comment">/*
		 * if we get here, none of the above matches, and
		 * we have to drop the pkt
		 */</span>
		m_freem(m);
		error = EACCES; <span class="enscript-comment">/* not sure this is the right error msg */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

<span class="enscript-reference">pass</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

	<span class="enscript-comment">/* 127/8 must not appear on wire - RFC1122 */</span>
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    ((ntohl(ip-&gt;ip_src.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
	    (ntohl(ip-&gt;ip_dst.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET)) {
		OSAddAtomic(1, &amp;ipstat.ips_badaddr);
		error = EADDRNOTAVAIL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	ip_output_checksum(ifp, m, (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2),
	    ip-&gt;ip_len, &amp;sw_csum);

	<span class="enscript-comment">/*
	 * If small enough for interface, or the interface will take
	 * care of the fragmentation for us, can just send directly.
	 */</span>
	<span class="enscript-keyword">if</span> ((u_short)ip-&gt;ip_len &lt;= ifp-&gt;if_mtu || TSO_IPV4_OK(ifp, m) ||
	    (!(ip-&gt;ip_off &amp; IP_DF) &amp;&amp; (ifp-&gt;if_hwassist &amp; CSUM_FRAGMENT))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
		HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

		ip-&gt;ip_sum = 0;
		<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IP) {
			ip-&gt;ip_sum = ip_cksum_hdr_out(m, hlen);
			sw_csum &amp;= ~CSUM_DELAY_IP;
			m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DELAY_IP;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-comment">/* clean ipsec history once it goes out of the node */</span>
		<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; !(flags &amp; IP_NOIPSEC))
			ipsec_delaux(m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4) &amp;&amp;
		    (m-&gt;m_pkthdr.tso_segsz &gt; 0))
			scnt += m-&gt;m_pkthdr.len / m-&gt;m_pkthdr.tso_segsz;
		<span class="enscript-keyword">else</span>
			scnt++;

		<span class="enscript-keyword">if</span> (packetchain == 0) {
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL &amp;&amp; nstat_collect)
				nstat_route_tx(ro-&gt;ro_rt, scnt,
				    m-&gt;m_pkthdr.len, 0);

			error = dlil_output(ifp, PF_INET, m, ro-&gt;ro_rt,
			    SA(dst), 0, adv);
			<span class="enscript-keyword">if</span> (dlil_verbose &amp;&amp; error) {
				printf(<span class="enscript-string">&quot;dlil_output error on interface %s: %d\n&quot;</span>,
					ifp-&gt;if_xname, error);
			}
			scnt = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * packet chaining allows us to reuse the
			 * route for all packets
			 */</span>
			bytecnt += m-&gt;m_pkthdr.len;
			mppn = &amp;m-&gt;m_nextpkt;
			m = m-&gt;m_nextpkt;
			<span class="enscript-keyword">if</span> (m == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
<span class="enscript-reference">sendchain</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>
				<span class="enscript-keyword">if</span> (pktcnt &gt; ip_maxchainsent)
					ip_maxchainsent = pktcnt;
				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL &amp;&amp; nstat_collect)
					nstat_route_tx(ro-&gt;ro_rt, scnt,
					    bytecnt, 0);

				error = dlil_output(ifp, PF_INET, packetlist,
				    ro-&gt;ro_rt, SA(dst), 0, adv);
				<span class="enscript-keyword">if</span> (dlil_verbose &amp;&amp; error) {
					printf(<span class="enscript-string">&quot;dlil_output error on interface %s: %d\n&quot;</span>,
					ifp-&gt;if_xname, error);
				}
				pktcnt = 0;
				scnt = 0;
				bytecnt = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

			}
			m0 = m;
			pktcnt++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopit</span>;
		}
	}
	<span class="enscript-comment">/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 * Balk when DF bit is set or the interface didn't support TSO.
	 */</span>
	<span class="enscript-keyword">if</span> ((ip-&gt;ip_off &amp; IP_DF) || pktcnt &gt; 0 ||
	    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV4)) {
		error = EMSGSIZE;
		<span class="enscript-comment">/*
		 * This case can happen if the user changed the MTU
		 * of an interface after enabling IP on it.  Because
		 * most netifs don't keep track of routes pointing to
		 * them, there is no way for one to update all its
		 * routes when the MTU is changed.
		 */</span>
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt) {
			RT_LOCK_SPIN(ro-&gt;ro_rt);
			<span class="enscript-keyword">if</span> ((ro-&gt;ro_rt-&gt;rt_flags &amp; (RTF_UP | RTF_HOST)) &amp;&amp;
			    !(ro-&gt;ro_rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU) &amp;&amp;
			    (ro-&gt;ro_rt-&gt;rt_rmx.rmx_mtu &gt; ifp-&gt;if_mtu)) {
				ro-&gt;ro_rt-&gt;rt_rmx.rmx_mtu = ifp-&gt;if_mtu;
			}
			RT_UNLOCK(ro-&gt;ro_rt);
		}
		<span class="enscript-keyword">if</span> (pktcnt &gt; 0) {
			m0 = packetlist;
		}
		OSAddAtomic(1, &amp;ipstat.ips_cantfrag);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	error = ip_fragment(m, ifp, ifp-&gt;if_mtu, sw_csum);
	<span class="enscript-keyword">if</span> (error != 0) {
		m0 = m = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	KERNEL_DEBUG(DBG_LAYER_END, ip-&gt;ip_dst.s_addr,
	    ip-&gt;ip_src.s_addr, ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

	<span class="enscript-keyword">for</span> (m = m0; m; m = m0) {
		m0 = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-comment">/* clean ipsec history once it goes out of the node */</span>
		<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; !(flags &amp; IP_NOIPSEC))
			ipsec_delaux(m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> ((packetchain != 0) &amp;&amp; (pktcnt &gt; 0)) {
				panic(<span class="enscript-string">&quot;%s: mix of packet in packetlist is &quot;</span>
				    <span class="enscript-string">&quot;wrong=%p&quot;</span>, __func__, packetlist);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL &amp;&amp; nstat_collect) {
				nstat_route_tx(ro-&gt;ro_rt, 1,
				    m-&gt;m_pkthdr.len, 0);
			}
			error = dlil_output(ifp, PF_INET, m, ro-&gt;ro_rt,
			    SA(dst), 0, adv);
			<span class="enscript-keyword">if</span> (dlil_verbose &amp;&amp; error) {
				printf(<span class="enscript-string">&quot;dlil_output error on interface %s: %d\n&quot;</span>,
					   ifp-&gt;if_xname, error);
			}
		} <span class="enscript-keyword">else</span> {
			m_freem(m);
		}
	}

	<span class="enscript-keyword">if</span> (error == 0)
		OSAddAtomic(1, &amp;ipstat.ips_fragmented);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ia != NULL) {
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
		ia = NULL;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	ROUTE_RELEASE(&amp;ipsec_state.ro);
	<span class="enscript-keyword">if</span> (sp != NULL) {
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
		    printf(<span class="enscript-string">&quot;DP ip_output call free SP:%x\n&quot;</span>, sp));
		key_freesp(sp, KEY_SADB_UNLOCKED);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	ROUTE_RELEASE(&amp;necp_route);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	ROUTE_RELEASE(&amp;saved_route);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
	ROUTE_RELEASE(&amp;sro_fwd);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>

	KERNEL_DEBUG(DBG_FNC_IP_OUTPUT | DBG_FUNC_END, error, 0, 0, 0, 0);
	<span class="enscript-keyword">if</span> (ip_output_measure) {
		net_perf_measure_time(&amp;net_perf, &amp;start_tv, packets_processed);
		net_perf_histogram(&amp;net_perf, packets_processed);
	}
	<span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (pktcnt &gt; 0)
		m0 = packetlist;
	m_freem_list(m0);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ipsec_state</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">args</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">sro_fwd</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">saved_route</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ipf_pktopts</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IP_CHECK_RESTRICTIONS</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_fragment</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> mtu, <span class="enscript-type">int</span> sw_csum)
{
	<span class="enscript-type">struct</span> ip *ip, *mhip;
	<span class="enscript-type">int</span> len, hlen, mhlen, firstlen, off, error = 0;
	<span class="enscript-type">struct</span> mbuf **mnext = &amp;m-&gt;m_nextpkt, *m0;
	<span class="enscript-type">int</span> nfrags = 1;

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !_IP_VHL */</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !_IP_VHL */</span>

	firstlen = len = (mtu - hlen) &amp;~ 7;
	<span class="enscript-keyword">if</span> (len &lt; 8) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}

	<span class="enscript-comment">/*
	 * if the interface will not calculate checksums on
	 * fragmented packets, then do it here.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_DATA) &amp;&amp;
	    !(ifp-&gt;if_hwassist &amp; CSUM_IP_FRAGS))
		in_delayed_cksum(m);

	<span class="enscript-comment">/*
	 * Loop through length of segment after first fragment,
	 * make new header and copy data of each part and link onto chain.
	 */</span>
	m0 = m;
	mhlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	<span class="enscript-keyword">for</span> (off = hlen + len; off &lt; (u_short)ip-&gt;ip_len; off += len) {
		MGETHDR(m, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (m == NULL) {
			error = ENOBUFS;
			OSAddAtomic(1, &amp;ipstat.ips_odropped);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendorfree</span>;
		}
		m-&gt;m_flags |= (m0-&gt;m_flags &amp; M_MCAST) | M_FRAG;
		m-&gt;m_data += max_linkhdr;
		mhip = mtod(m, <span class="enscript-type">struct</span> ip *);
		*mhip = *ip;
		<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
			mhlen = ip_optcopy(ip, mhip) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
			mhip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, mhlen &gt;&gt; 2);
		}
		m-&gt;m_len = mhlen;
		mhip-&gt;ip_off = ((off - hlen) &gt;&gt; 3) + (ip-&gt;ip_off &amp; ~IP_MF);
		<span class="enscript-keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)
			mhip-&gt;ip_off |= IP_MF;
		<span class="enscript-keyword">if</span> (off + len &gt;= (u_short)ip-&gt;ip_len)
			len = (u_short)ip-&gt;ip_len - off;
		<span class="enscript-keyword">else</span>
			mhip-&gt;ip_off |= IP_MF;
		mhip-&gt;ip_len = htons((u_short)(len + mhlen));
		m-&gt;m_next = m_copy(m0, off, len);
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
			(<span class="enscript-type">void</span>) m_free(m);
			error = ENOBUFS;	<span class="enscript-comment">/* ??? */</span>
			OSAddAtomic(1, &amp;ipstat.ips_odropped);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendorfree</span>;
		}
		m-&gt;m_pkthdr.len = mhlen + len;
		m-&gt;m_pkthdr.rcvif = NULL;
		m-&gt;m_pkthdr.csum_flags = m0-&gt;m_pkthdr.csum_flags;

		M_COPY_CLASSIFIER(m, m0);
		M_COPY_PFTAG(m, m0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		mac_netinet_fragment(m0, m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(mhip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

		mhip-&gt;ip_sum = 0;
		<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IP) {
			mhip-&gt;ip_sum = ip_cksum_hdr_out(m, mhlen);
			m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DELAY_IP;
		}
		*mnext = m;
		mnext = &amp;m-&gt;m_nextpkt;
		nfrags++;
	}
	OSAddAtomic(nfrags, &amp;ipstat.ips_ofragments);

	<span class="enscript-comment">/* set first/last markers for fragment chain */</span>
	m-&gt;m_flags |= M_LASTFRAG;
	m0-&gt;m_flags |= M_FIRSTFRAG | M_FRAG;
	m0-&gt;m_pkthdr.csum_data = nfrags;

	<span class="enscript-comment">/*
	 * Update first fragment by trimming what's been copied out
	 * and updating header, then send each fragment (in order).
	 */</span>
	m = m0;
	m_adj(m, hlen + firstlen - (u_short)ip-&gt;ip_len);
	m-&gt;m_pkthdr.len = hlen + firstlen;
	ip-&gt;ip_len = htons((u_short)m-&gt;m_pkthdr.len);
	ip-&gt;ip_off |= IP_MF;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

	ip-&gt;ip_sum = 0;
	<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IP) {
		ip-&gt;ip_sum = ip_cksum_hdr_out(m, hlen);
		m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DELAY_IP;
	}
<span class="enscript-reference">sendorfree</span>:
	<span class="enscript-keyword">if</span> (error)
		m_freem_list(m0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_out_cksum_stats</span>(<span class="enscript-type">int</span> proto, u_int32_t len)
{
	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		tcp_out_cksum_stats(len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		udp_out_cksum_stats(len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* keep only TCP or UDP stats for now */</span>
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Process a delayed payload checksum calculation (outbound path.)
 *
 * hoff is the number of bytes beyond the mbuf data pointer which
 * points to the IP header.
 *
 * Returns a bitmask representing all the work done in software.
 */</span>
uint32_t
<span class="enscript-function-name">in_finalize_cksum</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t hoff, uint32_t csum_flags)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[15 &lt;&lt; 2] __attribute__((aligned(8)));
	<span class="enscript-type">struct</span> ip *ip;
	uint32_t offset, _hlen, mlen, hlen, len, sw_csum;
	uint16_t csum, ip_len;

	_CASSERT(<span class="enscript-keyword">sizeof</span> (csum) == <span class="enscript-keyword">sizeof</span> (uint16_t));
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	sw_csum = (csum_flags &amp; m-&gt;m_pkthdr.csum_flags);

	<span class="enscript-keyword">if</span> ((sw_csum &amp;= (CSUM_DELAY_IP | CSUM_DELAY_DATA)) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	mlen = m-&gt;m_pkthdr.len;				<span class="enscript-comment">/* total mbuf len */</span>

	<span class="enscript-comment">/* sanity check (need at least simple IP header) */</span>
	<span class="enscript-keyword">if</span> (mlen &lt; (hoff + <span class="enscript-keyword">sizeof</span> (*ip))) {
		panic(<span class="enscript-string">&quot;%s: mbuf %p pkt len (%u) &lt; hoff+ip_hdr &quot;</span>
		    <span class="enscript-string">&quot;(%u+%u)\n&quot;</span>, __func__, m, mlen, hoff,
		    (uint32_t)<span class="enscript-keyword">sizeof</span> (*ip));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * In case the IP header is not contiguous, or not 32-bit aligned,
	 * or if we're computing the IP header checksum, copy it to a local
	 * buffer.  Copy only the simple IP header here (IP options case
	 * is handled below.)
	 */</span>
	<span class="enscript-keyword">if</span> ((sw_csum &amp; CSUM_DELAY_IP) || (hoff + <span class="enscript-keyword">sizeof</span> (*ip)) &gt; m-&gt;m_len ||
	    !IP_HDR_ALIGNED_P(mtod(m, caddr_t) + hoff)) {
		m_copydata(m, hoff, <span class="enscript-keyword">sizeof</span> (*ip), (caddr_t)buf);
		ip = (<span class="enscript-type">struct</span> ip *)(<span class="enscript-type">void</span> *)buf;
		_hlen = <span class="enscript-keyword">sizeof</span> (*ip);
	} <span class="enscript-keyword">else</span> {
		ip = (<span class="enscript-type">struct</span> ip *)(<span class="enscript-type">void</span> *)(m-&gt;m_data + hoff);
		_hlen = 0;
	}

	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;		<span class="enscript-comment">/* IP header len */</span>

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (mlen &lt; (hoff + hlen)) {
		panic(<span class="enscript-string">&quot;%s: mbuf %p pkt too short (%d) for IP header (%u), &quot;</span>
		    <span class="enscript-string">&quot;hoff %u&quot;</span>, __func__, m, mlen, hlen, hoff);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * We could be in the context of an IP or interface filter; in the
	 * former case, ip_len would be in host (correct) order while for
	 * the latter it would be in network order.  Because of this, we
	 * attempt to interpret the length field by comparing it against
	 * the actual packet length.  If the comparison fails, byte swap
	 * the length and check again.  If it still fails, use the actual
	 * packet length.  This also covers the trailing bytes case.
	 */</span>
	ip_len = ip-&gt;ip_len;
	<span class="enscript-keyword">if</span> (ip_len != (mlen - hoff)) {
		ip_len = OSSwapInt16(ip_len);
		<span class="enscript-keyword">if</span> (ip_len != (mlen - hoff)) {
			printf(<span class="enscript-string">&quot;%s: mbuf 0x%llx proto %d IP len %d (%x) &quot;</span>
			    <span class="enscript-string">&quot;[swapped %d (%x)] doesn't match actual packet &quot;</span>
			    <span class="enscript-string">&quot;length; %d is used instead\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m), ip-&gt;ip_p,
			    ip-&gt;ip_len, ip-&gt;ip_len, ip_len, ip_len,
			    (mlen - hoff));
			ip_len = mlen - hoff;
		}
	}

	len = ip_len - hlen;				<span class="enscript-comment">/* csum span */</span>

	<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_DATA) {
		uint16_t ulpoff;

		<span class="enscript-comment">/*
		 * offset is added to the lower 16-bit value of csum_data,
		 * which is expected to contain the ULP offset; therefore
		 * CSUM_PARTIAL offset adjustment must be undone.
		 */</span>
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; (CSUM_PARTIAL|CSUM_DATA_VALID)) ==
		    (CSUM_PARTIAL|CSUM_DATA_VALID)) {
			<span class="enscript-comment">/*
			 * Get back the original ULP offset (this will
			 * undo the CSUM_PARTIAL logic in ip_output.)
			 */</span>
			m-&gt;m_pkthdr.csum_data = (m-&gt;m_pkthdr.csum_tx_stuff -
			    m-&gt;m_pkthdr.csum_tx_start);
		}

		ulpoff = (m-&gt;m_pkthdr.csum_data &amp; 0xffff); <span class="enscript-comment">/* ULP csum offset */</span>
		offset = hoff + hlen;			<span class="enscript-comment">/* ULP header */</span>

		<span class="enscript-keyword">if</span> (mlen &lt; (ulpoff + <span class="enscript-keyword">sizeof</span> (csum))) {
			panic(<span class="enscript-string">&quot;%s: mbuf %p pkt len (%u) proto %d invalid ULP &quot;</span>
			    <span class="enscript-string">&quot;cksum offset (%u) cksum flags 0x%x\n&quot;</span>, __func__,
			    m, mlen, ip-&gt;ip_p, ulpoff, m-&gt;m_pkthdr.csum_flags);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		csum = inet_cksum(m, 0, offset, len);

		<span class="enscript-comment">/* Update stats */</span>
		ip_out_cksum_stats(ip-&gt;ip_p, len);

		<span class="enscript-comment">/* RFC1122 4.1.3.4 */</span>
		<span class="enscript-keyword">if</span> (csum == 0 &amp;&amp; (m-&gt;m_pkthdr.csum_flags &amp; CSUM_UDP))
			csum = 0xffff;

		<span class="enscript-comment">/* Insert the checksum in the ULP csum field */</span>
		offset += ulpoff;
		<span class="enscript-keyword">if</span> (offset + <span class="enscript-keyword">sizeof</span> (csum) &gt; m-&gt;m_len) {
			m_copyback(m, offset, <span class="enscript-keyword">sizeof</span> (csum), &amp;csum);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IP_HDR_ALIGNED_P(mtod(m, <span class="enscript-type">char</span> *) + hoff)) {
			*(uint16_t *)(<span class="enscript-type">void</span> *)(mtod(m, <span class="enscript-type">char</span> *) + offset) = csum;
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;csum, (mtod(m, <span class="enscript-type">char</span> *) + offset), <span class="enscript-keyword">sizeof</span> (csum));
		}
		m-&gt;m_pkthdr.csum_flags &amp;=
		    ~(CSUM_DELAY_DATA | CSUM_DATA_VALID | CSUM_PARTIAL);
	}

	<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IP) {
		<span class="enscript-comment">/* IP header must be in the local buffer */</span>
		VERIFY(_hlen == <span class="enscript-keyword">sizeof</span> (*ip));
		<span class="enscript-keyword">if</span> (_hlen != hlen) {
			VERIFY(hlen &lt;= <span class="enscript-keyword">sizeof</span> (buf));
			m_copydata(m, hoff, hlen, (caddr_t)buf);
			ip = (<span class="enscript-type">struct</span> ip *)(<span class="enscript-type">void</span> *)buf;
			_hlen = hlen;
		}

		<span class="enscript-comment">/*
		 * Compute the IP header checksum as if the IP length
		 * is the length which we believe is &quot;correct&quot;; see
		 * how ip_len gets calculated above.  Note that this
		 * is done on the local copy and not on the real one.
		 */</span>
		ip-&gt;ip_len = htons(ip_len);
		ip-&gt;ip_sum = 0;
		csum = in_cksum_hdr_opt(ip);

		<span class="enscript-comment">/* Update stats */</span>
		ipstat.ips_snd_swcsum++;
		ipstat.ips_snd_swcsum_bytes += hlen;

		<span class="enscript-comment">/*
		 * Insert only the checksum in the existing IP header
		 * csum field; all other fields are left unchanged.
		 */</span>
		offset = hoff + offsetof(<span class="enscript-type">struct</span> ip, ip_sum);
		<span class="enscript-keyword">if</span> (offset + <span class="enscript-keyword">sizeof</span> (csum) &gt; m-&gt;m_len) {
			m_copyback(m, offset, <span class="enscript-keyword">sizeof</span> (csum), &amp;csum);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IP_HDR_ALIGNED_P(mtod(m, <span class="enscript-type">char</span> *) + hoff)) {
			*(uint16_t *)(<span class="enscript-type">void</span> *)(mtod(m, <span class="enscript-type">char</span> *) + offset) = csum;
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;csum, (mtod(m, <span class="enscript-type">char</span> *) + offset), <span class="enscript-keyword">sizeof</span> (csum));
		}
		m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DELAY_IP;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (sw_csum);
}

<span class="enscript-comment">/*
 * Insert IP options into preformed packet.
 * Adjust IP destination as required for IP source routing,
 * as indicated by a non-zero in_addr at the start of the options.
 *
 * XXX This routine assumes that the packet has no options in place.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ip_insertoptions</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf *opt, <span class="enscript-type">int</span> *phlen)
{
	<span class="enscript-type">struct</span> ipoption *p = mtod(opt, <span class="enscript-type">struct</span> ipoption *);
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-type">unsigned</span> optlen;

	optlen = opt-&gt;m_len - <span class="enscript-keyword">sizeof</span> (p-&gt;ipopt_dst);
	<span class="enscript-keyword">if</span> (optlen + (u_short)ip-&gt;ip_len &gt; IP_MAXPACKET)
		<span class="enscript-keyword">return</span> (m);		<span class="enscript-comment">/* XXX should fail */</span>
	<span class="enscript-keyword">if</span> (p-&gt;ipopt_dst.s_addr)
		ip-&gt;ip_dst = p-&gt;ipopt_dst;
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT || m-&gt;m_data - optlen &lt; m-&gt;m_pktdat) {
		MGETHDR(n, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">return</span> (m);
		n-&gt;m_pkthdr.rcvif = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		mac_mbuf_label_copy(m, n);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
		n-&gt;m_pkthdr.len = m-&gt;m_pkthdr.len + optlen;
		m-&gt;m_len -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
		m-&gt;m_data += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
		n-&gt;m_next = m;
		m = n;
		m-&gt;m_len = optlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
		m-&gt;m_data += max_linkhdr;
		(<span class="enscript-type">void</span>) memcpy(mtod(m, <span class="enscript-type">void</span> *), ip, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip));
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_data -= optlen;
		m-&gt;m_len += optlen;
		m-&gt;m_pkthdr.len += optlen;
		ovbcopy((caddr_t)ip, mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip));
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	bcopy(p-&gt;ipopt_list, ip + 1, optlen);
	*phlen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) + optlen;
	ip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, *phlen &gt;&gt; 2);
	ip-&gt;ip_len += optlen;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Copy options from ip to jp,
 * omitting those not copied during fragmentation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip_optcopy</span>(<span class="enscript-type">struct</span> ip *ip, <span class="enscript-type">struct</span> ip *jp)
{
	u_char *cp, *dp;
	<span class="enscript-type">int</span> opt, optlen, cnt;

	cp = (u_char *)(ip + 1);
	dp = (u_char *)(jp + 1);
	cnt = (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, cp += optlen) {
		opt = cp[0];
		<span class="enscript-keyword">if</span> (opt == IPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == IPOPT_NOP) {
			<span class="enscript-comment">/* Preserve for IP mcast tunnel's LSRR alignment. */</span>
			*dp++ = IPOPT_NOP;
			optlen = 1;
			<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (cnt &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp)) {
			panic(<span class="enscript-string">&quot;malformed IPv4 option passed to ip_optcopy&quot;</span>);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
#<span class="enscript-reference">endif</span>
		optlen = cp[IPOPT_OLEN];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp) || optlen &gt; cnt) {
			panic(<span class="enscript-string">&quot;malformed IPv4 option passed to ip_optcopy&quot;</span>);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* bogus lengths should have been caught by ip_dooptions */</span>
		<span class="enscript-keyword">if</span> (optlen &gt; cnt)
			optlen = cnt;
		<span class="enscript-keyword">if</span> (IPOPT_COPIED(opt)) {
			bcopy(cp, dp, optlen);
			dp += optlen;
		}
	}
	<span class="enscript-keyword">for</span> (optlen = dp - (u_char *)(jp+1); optlen &amp; 0x3; optlen++)
		*dp++ = IPOPT_EOL;
	<span class="enscript-keyword">return</span> (optlen);
}

<span class="enscript-comment">/*
 * IP socket option processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">struct</span>	inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span>	error, optval;

	error = optval = 0;
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_IP)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RETOPTS</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OPTIONS</span>: {
			<span class="enscript-type">struct</span> mbuf *m;

			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize &gt; MLEN) {
				error = EMSGSIZE;
				<span class="enscript-keyword">break</span>;
			}
			MGET(m, sopt-&gt;sopt_p != kernproc ? M_WAIT : M_DONTWAIT,
			    MT_HEADER);
			<span class="enscript-keyword">if</span> (m == NULL) {
				error = ENOBUFS;
				<span class="enscript-keyword">break</span>;
			}
			m-&gt;m_len = sopt-&gt;sopt_valsize;
			error = sooptcopyin(sopt, mtod(m, <span class="enscript-type">char</span> *),
			    m-&gt;m_len, m-&gt;m_len);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">return</span> (ip_pcbopts(sopt-&gt;sopt_name,
			    &amp;inp-&gt;inp_options, m));
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TOS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVRETOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVDSTADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVTTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVPKTINFO</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TOS</span>:
				inp-&gt;inp_ip_tos = optval;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TTL</span>:
				inp-&gt;inp_ip_ttl = optval;
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OPTSET</span>(bit) \
	<span class="enscript-keyword">if</span> (optval) \
		inp-&gt;inp_flags |= bit; \
	<span class="enscript-keyword">else</span> \
		inp-&gt;inp_flags &amp;= ~bit;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVOPTS</span>:
				OPTSET(INP_RECVOPTS);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVRETOPTS</span>:
				OPTSET(INP_RECVRETOPTS);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVDSTADDR</span>:
				OPTSET(INP_RECVDSTADDR);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVIF</span>:
				OPTSET(INP_RECVIF);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVTTL</span>:
				OPTSET(INP_RECVTTL);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVPKTINFO</span>:
				OPTSET(INP_PKTINFO);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">OPTSET</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FORCE_OUT_IFP</span>
		<span class="enscript-comment">/*
		 * Apple private interface, similar to IP_BOUND_IF, except
		 * that the parameter is a NULL-terminated string containing
		 * the name of the network interface; an emptry string means
		 * unbind.  Applications are encouraged to use IP_BOUND_IF
		 * instead, as that is the current &quot;official&quot; API.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_FORCE_OUT_IFP</span>: {
			<span class="enscript-type">char</span> ifname[IFNAMSIZ];
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

			<span class="enscript-comment">/* This option is settable only for IPv4 */</span>
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Verify interface name parameter is sane */</span>
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize &gt; <span class="enscript-keyword">sizeof</span> (ifname)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Copy the interface name */</span>
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize != 0) {
				error = sooptcopyin(sopt, ifname,
				    <span class="enscript-keyword">sizeof</span> (ifname), sopt-&gt;sopt_valsize);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize == 0 || ifname[0] == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-comment">/* Unbind this socket from any interface */</span>
				ifscope = IFSCOPE_NONE;
			} <span class="enscript-keyword">else</span> {
				ifnet_t	ifp;

				<span class="enscript-comment">/* Verify name is NULL terminated */</span>
				<span class="enscript-keyword">if</span> (ifname[sopt-&gt;sopt_valsize - 1] != <span class="enscript-string">'\0'</span>) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/* Bail out if given bogus interface name */</span>
				<span class="enscript-keyword">if</span> (ifnet_find_by_name(ifname, &amp;ifp) != 0) {
					error = ENXIO;
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/* Bind this socket to this interface */</span>
				ifscope = ifp-&gt;if_index;

				<span class="enscript-comment">/*
				 * Won't actually free; since we don't release
				 * this later, we should do it now.
				 */</span>
				ifnet_release(ifp);
			}
			error = inp_bindif(inp, ifscope, NULL);
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FORCE_OUT_IFP */</span>
		<span class="enscript-comment">/*
		 * Multicast socket options are processed by the in_mcast
		 * module.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_IF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_IFINDEX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_VIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_TTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_LOOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_ADD_MEMBERSHIP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DROP_MEMBERSHIP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_ADD_SOURCE_MEMBERSHIP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_DROP_SOURCE_MEMBERSHIP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_BLOCK_SOURCE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_UNBLOCK_SOURCE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MSFILTER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_JOIN_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_LEAVE_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_JOIN_SOURCE_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_LEAVE_SOURCE_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_BLOCK_SOURCE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_UNBLOCK_SOURCE</span>:
			error = inp_setmoptions(inp, sopt);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">switch</span> (optval) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE_DEFAULT</span>:
				inp-&gt;inp_flags &amp;= ~(INP_LOWPORT);
				inp-&gt;inp_flags &amp;= ~(INP_HIGHPORT);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE_HIGH</span>:
				inp-&gt;inp_flags &amp;= ~(INP_LOWPORT);
				inp-&gt;inp_flags |= INP_HIGHPORT;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE_LOW</span>:
				inp-&gt;inp_flags &amp;= ~(INP_HIGHPORT);
				inp-&gt;inp_flags |= INP_LOWPORT;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_IPSEC_POLICY</span>: {
			caddr_t req = NULL;
			size_t len = 0;
			<span class="enscript-type">int</span> priv;
			<span class="enscript-type">struct</span> mbuf *m;
			<span class="enscript-type">int</span> optname;
			
			<span class="enscript-keyword">if</span> ((error = soopt_getm(sopt, &amp;m)) != 0) <span class="enscript-comment">/* XXX */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> ((error = soopt_mcopyin(sopt, m)) != 0) <span class="enscript-comment">/* XXX */</span>
				<span class="enscript-keyword">break</span>;
			priv = (proc_suser(sopt-&gt;sopt_p) == 0);
			<span class="enscript-keyword">if</span> (m) {
				req = mtod(m, caddr_t);
				len = m-&gt;m_len;
			}
			optname = sopt-&gt;sopt_name;
			error = ipsec4_set_policy(inp, optname, req, len, priv);
			m_freem(m);
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TRAFFIC_MGT_BACKGROUND</span>: {
			<span class="enscript-type">unsigned</span> background = 0;

			error = sooptcopyin(sopt, &amp;background,
			    <span class="enscript-keyword">sizeof</span> (background), <span class="enscript-keyword">sizeof</span> (background));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (background) {
				socket_set_traffic_mgt_flags_locked(so,
				    TRAFFIC_MGT_SO_BACKGROUND);
			} <span class="enscript-keyword">else</span> {
				socket_clear_traffic_mgt_flags_locked(so,
				    TRAFFIC_MGT_SO_BACKGROUND);
			}

			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

		<span class="enscript-comment">/*
		 * On a multihomed system, scoped routing can be used to
		 * restrict the source interface used for sending packets.
		 * The socket option IP_BOUND_IF binds a particular AF_INET
		 * socket to an interface such that data sent on the socket
		 * is restricted to that interface.  This is unlike the
		 * SO_DONTROUTE option where the routing table is bypassed;
		 * therefore it allows for a greater flexibility and control
		 * over the system behavior, and does not place any restriction
		 * on the destination address type (e.g.  unicast, multicast,
		 * or broadcast if applicable) or whether or not the host is
		 * directly reachable.  Note that in the multicast transmit
		 * case, IP_MULTICAST_{IF,IFINDEX} takes precedence over
		 * IP_BOUND_IF, since the former practically bypasses the
		 * routing table; in this case, IP_BOUND_IF sets the default
		 * interface used for sending multicast packets in the absence
		 * of an explicit multicast transmit interface.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_BOUND_IF</span>:
			<span class="enscript-comment">/* This option is settable only for IPv4 */</span>
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			error = inp_bindif(inp, optval, NULL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_NO_IFT_CELLULAR</span>:
			<span class="enscript-comment">/* This option is settable only for IPv4 */</span>
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* once set, it cannot be unset */</span>
			<span class="enscript-keyword">if</span> (!optval &amp;&amp; INP_NO_CELLULAR(inp)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			error = so_set_restrictions(so,
			    SO_RESTRICT_DENY_CELLULAR);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OUT_IF</span>:
			<span class="enscript-comment">/* This option is not settable */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OPTIONS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RETOPTS</span>:
			<span class="enscript-keyword">if</span> (inp-&gt;inp_options) {
				error = sooptcopyout(sopt,
				    mtod(inp-&gt;inp_options, <span class="enscript-type">char</span> *),
				    inp-&gt;inp_options-&gt;m_len);
			} <span class="enscript-keyword">else</span> {
				sopt-&gt;sopt_valsize = 0;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TOS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVRETOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVDSTADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVTTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVPKTINFO</span>:
			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TOS</span>:
				optval = inp-&gt;inp_ip_tos;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TTL</span>:
				optval = inp-&gt;inp_ip_ttl;
				<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OPTBIT</span>(bit)	(inp-&gt;inp_flags &amp; bit ? 1 : 0)

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVOPTS</span>:
				optval = OPTBIT(INP_RECVOPTS);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVRETOPTS</span>:
				optval = OPTBIT(INP_RECVRETOPTS);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVDSTADDR</span>:
				optval = OPTBIT(INP_RECVDSTADDR);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVIF</span>:
				optval = OPTBIT(INP_RECVIF);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVTTL</span>:
				optval = OPTBIT(INP_RECVTTL);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_PORTRANGE</span>:
				<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_HIGHPORT)
					optval = IP_PORTRANGE_HIGH;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_LOWPORT)
					optval = IP_PORTRANGE_LOW;
				<span class="enscript-keyword">else</span>
					optval = 0;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_RECVPKTINFO</span>:
				optval = OPTBIT(INP_PKTINFO);
				<span class="enscript-keyword">break</span>;
			}
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_IF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_IFINDEX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_VIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_TTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MULTICAST_LOOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_MSFILTER</span>:
			error = inp_getmoptions(inp, sopt);
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_IPSEC_POLICY</span>: {
			error = 0; <span class="enscript-comment">/* This option is no longer supported */</span>
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TRAFFIC_MGT</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_TRAFFIC_MGT_BACKGROUND</span>: {
			<span class="enscript-type">unsigned</span> background = (so-&gt;so_traffic_mgt_flags &amp;
			    TRAFFIC_MGT_SO_BACKGROUND) ? 1 : 0;
			<span class="enscript-keyword">return</span> (sooptcopyout(sopt, &amp;background,
			    <span class="enscript-keyword">sizeof</span> (background)));
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TRAFFIC_MGT */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_BOUND_IF</span>:
			<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_BOUND_IF)
				optval = inp-&gt;inp_boundifp-&gt;if_index;
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_NO_IFT_CELLULAR</span>:
			optval = INP_NO_CELLULAR(inp) ? 1 : 0;
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP_OUT_IF</span>:
			optval = (inp-&gt;inp_last_outifp != NULL) ?
			    inp-&gt;inp_last_outifp-&gt;if_index : 0;
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set up IP options in pcb for insertion in output packets.
 * Store in mbuf with pointer in pcbopt, adding pseudo-option
 * with destination address if source routed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip_pcbopts</span>(<span class="enscript-type">int</span> optname, <span class="enscript-type">struct</span> mbuf **pcbopt, <span class="enscript-type">struct</span> mbuf *m)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">optname</span>)
	<span class="enscript-type">int</span> cnt, optlen;
	u_char *cp;
	u_char opt;

	<span class="enscript-comment">/* turn off any old options */</span>
	<span class="enscript-keyword">if</span> (*pcbopt)
		(<span class="enscript-type">void</span>) m_free(*pcbopt);
	*pcbopt = 0;
	<span class="enscript-keyword">if</span> (m == (<span class="enscript-type">struct</span> mbuf *)0 || m-&gt;m_len == 0) {
		<span class="enscript-comment">/*
		 * Only turning off any previous options.
		 */</span>
		<span class="enscript-keyword">if</span> (m)
			(<span class="enscript-type">void</span>) m_free(m);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_len % <span class="enscript-keyword">sizeof</span> (int32_t))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * IP first-hop destination address will be stored before
	 * actual options; move other options back
	 * and clear it when none present.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_data + m-&gt;m_len + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) &gt;= &amp;m-&gt;m_dat[MLEN])
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	cnt = m-&gt;m_len;
	m-&gt;m_len += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
	cp = mtod(m, u_char *) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
	ovbcopy(mtod(m, caddr_t), (caddr_t)cp, (<span class="enscript-type">unsigned</span>)cnt);
	bzero(mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));

	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		<span class="enscript-keyword">if</span> (opt == IPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == IPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cnt &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			optlen = cp[IPOPT_OLEN];
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp) || optlen &gt; cnt)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">switch</span> (opt) {

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_LSRR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_SSRR</span>:
			<span class="enscript-comment">/*
			 * user process specifies route as:
			 *	-&gt;A-&gt;B-&gt;C-&gt;D
			 * D must be our final destination (but we can't
			 * check that since we may not have connected yet).
			 * A is first hop destination, which doesn't appear in
			 * actual IP option, but is stored before the options.
			 */</span>
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_MINOFF - 1 + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			m-&gt;m_len -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
			cnt -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
			optlen -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
			cp[IPOPT_OLEN] = optlen;
			<span class="enscript-comment">/*
			 * Move first hop before start of options.
			 */</span>
			bcopy((caddr_t)&amp;cp[IPOPT_OFFSET+1], mtod(m, caddr_t),
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
			<span class="enscript-comment">/*
			 * Then copy rest of options back
			 * to close up the deleted entry.
			 */</span>
			ovbcopy((caddr_t)(&amp;cp[IPOPT_OFFSET+1] +
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr)),
			    (caddr_t)&amp;cp[IPOPT_OFFSET+1],
			    (<span class="enscript-type">unsigned</span>)cnt + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; MAX_IPOPTLEN + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	*pcbopt = m;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	(<span class="enscript-type">void</span>) m_free(m);
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_moptions_init</span>(<span class="enscript-type">void</span>)
{
	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;imo_debug, <span class="enscript-keyword">sizeof</span> (imo_debug));

	imo_size = (imo_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip_moptions) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip_moptions_dbg);

	imo_zone = zinit(imo_size, IMO_ZONE_MAX * imo_size, 0,
	    IMO_ZONE_NAME);
	<span class="enscript-keyword">if</span> (imo_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, IMO_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(imo_zone, Z_EXPAND, TRUE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">imo_addref</span>(<span class="enscript-type">struct</span> ip_moptions *imo, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IMO_LOCK(imo);
	<span class="enscript-keyword">else</span>
		IMO_LOCK_ASSERT_HELD(imo);

	<span class="enscript-keyword">if</span> (++imo-&gt;imo_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: imo %p wraparound refcnt\n&quot;</span>, __func__, imo);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (imo-&gt;imo_trace != NULL) {
		(*imo-&gt;imo_trace)(imo, TRUE);
	}

	<span class="enscript-keyword">if</span> (!locked)
		IMO_UNLOCK(imo);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">imo_remref</span>(<span class="enscript-type">struct</span> ip_moptions *imo)
{
	<span class="enscript-type">int</span> i;

	IMO_LOCK(imo);
	<span class="enscript-keyword">if</span> (imo-&gt;imo_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: imo %p negative refcnt&quot;</span>, __func__, imo);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (imo-&gt;imo_trace != NULL) {
		(*imo-&gt;imo_trace)(imo, FALSE);
	}

	--imo-&gt;imo_refcnt;
	<span class="enscript-keyword">if</span> (imo-&gt;imo_refcnt &gt; 0) {
		IMO_UNLOCK(imo);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; imo-&gt;imo_num_memberships; ++i) {
		<span class="enscript-type">struct</span> in_mfilter *imf;

		imf = imo-&gt;imo_mfilters ? &amp;imo-&gt;imo_mfilters[i] : NULL;
		<span class="enscript-keyword">if</span> (imf != NULL)
			imf_leave(imf);

		(<span class="enscript-type">void</span>) in_leavegroup(imo-&gt;imo_membership[i], imf);

		<span class="enscript-keyword">if</span> (imf != NULL)
			imf_purge(imf);

		INM_REMREF(imo-&gt;imo_membership[i]);
		imo-&gt;imo_membership[i] = NULL;
	}
	imo-&gt;imo_num_memberships = 0;
	<span class="enscript-keyword">if</span> (imo-&gt;imo_mfilters != NULL) {
		FREE(imo-&gt;imo_mfilters, M_INMFILTER);
		imo-&gt;imo_mfilters = NULL;
	}
	<span class="enscript-keyword">if</span> (imo-&gt;imo_membership != NULL) {
		FREE(imo-&gt;imo_membership, M_IPMOPTS);
		imo-&gt;imo_membership = NULL;
	}
	IMO_UNLOCK(imo);

	lck_mtx_destroy(&amp;imo-&gt;imo_lock, ifa_mtx_grp);

	<span class="enscript-keyword">if</span> (!(imo-&gt;imo_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: imo %p cannot be freed&quot;</span>, __func__, imo);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zfree(imo_zone, imo);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">imo_trace</span>(<span class="enscript-type">struct</span> ip_moptions *imo, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> ip_moptions_dbg *imo_dbg = (<span class="enscript-type">struct</span> ip_moptions_dbg *)imo;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(imo-&gt;imo_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: imo %p has no debug structure&quot;</span>, __func__, imo);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;imo_dbg-&gt;imo_refhold_cnt;
		tr = imo_dbg-&gt;imo_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;imo_dbg-&gt;imo_refrele_cnt;
		tr = imo_dbg-&gt;imo_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % IMO_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">struct</span> ip_moptions *
<span class="enscript-function-name">ip_allocmoptions</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> ip_moptions *imo;

	imo = (how == M_WAITOK) ? zalloc(imo_zone) : zalloc_noblock(imo_zone);
	<span class="enscript-keyword">if</span> (imo != NULL) {
		bzero(imo, imo_size);
		lck_mtx_init(&amp;imo-&gt;imo_lock, ifa_mtx_grp, ifa_mtx_attr);
		imo-&gt;imo_debug |= IFD_ALLOC;
		<span class="enscript-keyword">if</span> (imo_debug != 0) {
			imo-&gt;imo_debug |= IFD_DEBUG;
			imo-&gt;imo_trace = imo_trace;
		}
		IMO_ADDREF(imo);
	}

	<span class="enscript-keyword">return</span> (imo);
}

<span class="enscript-comment">/*
 * Routine called from ip_output() to loop back a copy of an IP multicast
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback &quot;driver&quot;, but with an interface
 * pointer that might NOT be a loopback interface -- evil, but easier than
 * replicating that code here.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_mloopback</span>(<span class="enscript-type">struct</span> ifnet *srcifp, <span class="enscript-type">struct</span> ifnet *origifp, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr_in *dst, <span class="enscript-type">int</span> hlen)
{
	<span class="enscript-type">struct</span> mbuf *copym;
	<span class="enscript-type">struct</span> ip *ip;

	<span class="enscript-keyword">if</span> (lo_ifp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Copy the packet header as it's needed for the checksum
	 * Make sure to deep-copy IP header portion in case the data
	 * is in an mbuf cluster, so that we can safely override the IP
	 * header portion later.
	 */</span>
	copym = m_copym_mode(m, 0, M_COPYALL, M_DONTWAIT, M_COPYM_COPY_HDR);
	<span class="enscript-keyword">if</span> (copym != NULL &amp;&amp; ((copym-&gt;m_flags &amp; M_EXT) || copym-&gt;m_len &lt; hlen))
		copym = m_pullup(copym, hlen);

	<span class="enscript-keyword">if</span> (copym == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * We don't bother to fragment if the IP length is greater
	 * than the interface's MTU.  Can this possibly matter?
	 */</span>
	ip = mtod(copym, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	HTONS(ip-&gt;ip_len);
	HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
	ip-&gt;ip_sum = 0;
	ip-&gt;ip_sum = ip_cksum_hdr_out(copym, hlen);

	<span class="enscript-comment">/*
	 * Mark checksum as valid unless receive checksum offload is
	 * disabled; if so, compute checksum in software.  If the
	 * interface itself is lo0, this will be overridden by if_loop.
	 */</span>
	<span class="enscript-keyword">if</span> (hwcksum_rx) {
		copym-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_PARTIAL;
		copym-&gt;m_pkthdr.csum_flags |=
		    CSUM_DATA_VALID | CSUM_PSEUDO_HDR;
		copym-&gt;m_pkthdr.csum_data = 0xffff;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (copym-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_DATA) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>
		in_delayed_cksum(copym);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/*
	 * Stuff the 'real' ifp into the pkthdr, to be used in matching
	 * in ip_input(); we need the loopback ifp/dl_tag passed as args
	 * to make the loopback driver compliant with the data link
	 * requirements.
	 */</span>
	copym-&gt;m_pkthdr.rcvif = origifp;

	<span class="enscript-comment">/*
	 * Also record the source interface (which owns the source address).
	 * This is basically a stripped down version of ifa_foraddr().
	 */</span>
	<span class="enscript-keyword">if</span> (srcifp == NULL) {
		<span class="enscript-type">struct</span> in_ifaddr *ia;

		lck_rw_lock_shared(in_ifaddr_rwlock);
		TAILQ_FOREACH(ia, INADDR_HASH(ip-&gt;ip_src.s_addr), ia_hash) {
			IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (IA_SIN(ia)-&gt;sin_addr.s_addr == ip-&gt;ip_src.s_addr) {
				srcifp = ia-&gt;ia_ifp;
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		lck_rw_done(in_ifaddr_rwlock);
	}
	<span class="enscript-keyword">if</span> (srcifp != NULL)
		ip_setsrcifaddr_info(copym, srcifp-&gt;if_index, NULL);
	ip_setdstifaddr_info(copym, origifp-&gt;if_index, NULL);

	dlil_output(lo_ifp, PF_INET, copym, NULL, SA(dst), 0, NULL);
}

<span class="enscript-comment">/*
 * Given a source IP address (and route, if available), determine the best
 * interface to send the packet from.  Checking for (and updating) the
 * ROF_SRCIF_SELECTED flag in the pcb-supplied route placeholder is done
 * without any locks based on the assumption that ip_output() is single-
 * threaded per-pcb, i.e. for any given pcb there can only be one thread
 * performing output at the IP layer.
 *
 * This routine is analogous to in6_selectroute() for IPv6.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifaddr *
<span class="enscript-function-name">in_selectsrcif</span>(<span class="enscript-type">struct</span> ip *ip, <span class="enscript-type">struct</span> route *ro, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> in_addr src = ip-&gt;ip_src;
	<span class="enscript-type">struct</span> in_addr dst = ip-&gt;ip_dst;
	<span class="enscript-type">struct</span> ifnet *rt_ifp;
	<span class="enscript-type">char</span> s_src[MAX_IPv4_STR_LEN], s_dst[MAX_IPv4_STR_LEN];

	VERIFY(src.s_addr != INADDR_ANY);

	<span class="enscript-keyword">if</span> (ip_select_srcif_debug) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET, &amp;src.s_addr, s_src, <span class="enscript-keyword">sizeof</span> (s_src));
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET, &amp;dst.s_addr, s_dst, <span class="enscript-keyword">sizeof</span> (s_dst));
	}

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_LOCK(ro-&gt;ro_rt);

	rt_ifp = (ro-&gt;ro_rt != NULL) ? ro-&gt;ro_rt-&gt;rt_ifp : NULL;

	<span class="enscript-comment">/*
	 * Given the source IP address, find a suitable source interface
	 * to use for transmission; if the caller has specified a scope,
	 * optimize the search by looking at the addresses only for that
	 * interface.  This is still suboptimal, however, as we need to
	 * traverse the per-interface list.
	 */</span>
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE || ro-&gt;ro_rt != NULL) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scope = ifscope;

		<span class="enscript-comment">/*
		 * If no scope is specified and the route is stale (pointing
		 * to a defunct interface) use the current primary interface;
		 * this happens when switching between interfaces configured
		 * with the same IP address.  Otherwise pick up the scope
		 * information from the route; the ULP may have looked up a
		 * correct route and we just need to verify it here and mark
		 * it with the ROF_SRCIF_SELECTED flag below.
		 */</span>
		<span class="enscript-keyword">if</span> (scope == IFSCOPE_NONE) {
			scope = rt_ifp-&gt;if_index;
			<span class="enscript-keyword">if</span> (scope != get_primary_ifscope(AF_INET) &amp;&amp;
			    ROUTE_UNUSABLE(ro))
				scope = get_primary_ifscope(AF_INET);
		}

		ifa = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr_scoped(src.s_addr, scope);

		<span class="enscript-keyword">if</span> (ifa == NULL &amp;&amp; ip-&gt;ip_p != IPPROTO_UDP &amp;&amp;
		    ip-&gt;ip_p != IPPROTO_TCP &amp;&amp; ipforwarding) {
			<span class="enscript-comment">/*
			 * If forwarding is enabled, and if the packet isn't
			 * TCP or UDP, check if the source address belongs
			 * to one of our own interfaces; if so, demote the
			 * interface scope and do a route lookup right below.
			 */</span>
			ifa = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr(src.s_addr);
			<span class="enscript-keyword">if</span> (ifa != NULL) {
				IFA_REMREF(ifa);
				ifa = NULL;
				ifscope = IFSCOPE_NONE;
			}
		}

		<span class="enscript-keyword">if</span> (ip_select_srcif_debug &amp;&amp; ifa != NULL) {
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
				printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d-&gt;%d ifa_if %s &quot;</span>
				    <span class="enscript-string">&quot;ro_if %s\n&quot;</span>, s_src, s_dst, ifscope,
				    scope, if_name(ifa-&gt;ifa_ifp),
				    if_name(rt_ifp));
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d-&gt;%d ifa_if %s\n&quot;</span>,
				    s_src, s_dst, ifscope, scope,
				    if_name(ifa-&gt;ifa_ifp));
			}
		}
	}

	<span class="enscript-comment">/*
	 * Slow path; search for an interface having the corresponding source
	 * IP address if the scope was not specified by the caller, and:
	 *
	 *   1) There currently isn't any route, or,
	 *   2) The interface used by the route does not own that source
	 *	IP address; in this case, the route will get blown away
	 *	and we'll do a more specific scoped search using the newly
	 *	found interface.
	 */</span>
	<span class="enscript-keyword">if</span> (ifa == NULL &amp;&amp; ifscope == IFSCOPE_NONE) {
		ifa = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr(src.s_addr);

		<span class="enscript-comment">/*
		 * If we have the IP address, but not the route, we don't
		 * really know whether or not it belongs to the correct
		 * interface (it could be shared across multiple interfaces.)
		 * The only way to find out is to do a route lookup.
		 */</span>
		<span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; ro-&gt;ro_rt == NULL) {
			<span class="enscript-type">struct</span> rtentry *rt;
			<span class="enscript-type">struct</span> sockaddr_in sin;
			<span class="enscript-type">struct</span> ifaddr *oifa = NULL;

			bzero(&amp;sin, <span class="enscript-keyword">sizeof</span> (sin));
			sin.sin_family = AF_INET;
			sin.sin_len = <span class="enscript-keyword">sizeof</span> (sin);
			sin.sin_addr = dst;

			lck_mtx_lock(rnh_lock);
			<span class="enscript-keyword">if</span> ((rt = rt_lookup(TRUE, SA(&amp;sin), NULL,
			    rt_tables[AF_INET], IFSCOPE_NONE)) != NULL) {
				RT_LOCK(rt);
				<span class="enscript-comment">/*
				 * If the route uses a different interface,
				 * use that one instead.  The IP address of
				 * the ifaddr that we pick up here is not
				 * relevant.
				 */</span>
				<span class="enscript-keyword">if</span> (ifa-&gt;ifa_ifp != rt-&gt;rt_ifp) {
					oifa = ifa;
					ifa = rt-&gt;rt_ifa;
					IFA_ADDREF(ifa);
					RT_UNLOCK(rt);
				} <span class="enscript-keyword">else</span> {
					RT_UNLOCK(rt);
				}
				rtfree_locked(rt);
			}
			lck_mtx_unlock(rnh_lock);

			<span class="enscript-keyword">if</span> (oifa != NULL) {
				<span class="enscript-type">struct</span> ifaddr *iifa;

				<span class="enscript-comment">/*
				 * See if the interface pointed to by the
				 * route is configured with the source IP
				 * address of the packet.
				 */</span>
				iifa = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr_scoped(
				    src.s_addr, ifa-&gt;ifa_ifp-&gt;if_index);

				<span class="enscript-keyword">if</span> (iifa != NULL) {
					<span class="enscript-comment">/*
					 * Found it; drop the original one
					 * as well as the route interface
					 * address, and use this instead.
					 */</span>
					IFA_REMREF(oifa);
					IFA_REMREF(ifa);
					ifa = iifa;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ipforwarding ||
				    (rt-&gt;rt_flags &amp; RTF_GATEWAY)) {
					<span class="enscript-comment">/*
					 * This interface doesn't have that
					 * source IP address; drop the route
					 * interface address and just use the
					 * original one, and let the caller
					 * do a scoped route lookup.
					 */</span>
					IFA_REMREF(ifa);
					ifa = oifa;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * Forwarding is enabled and the source
					 * address belongs to one of our own
					 * interfaces which isn't the outgoing
					 * interface, and we have a route, and
					 * the destination is on a network that
					 * is directly attached (onlink); drop
					 * the original one and use the route
					 * interface address instead.
					 */</span>
					IFA_REMREF(oifa);
				}
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; ro-&gt;ro_rt != NULL &amp;&amp;
		    !(ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY) &amp;&amp;
		    ifa-&gt;ifa_ifp != ro-&gt;ro_rt-&gt;rt_ifp &amp;&amp; ipforwarding) {
			<span class="enscript-comment">/*
			 * Forwarding is enabled and the source address belongs
			 * to one of our own interfaces which isn't the same
			 * as the interface used by the known route; drop the
			 * original one and use the route interface address.
			 */</span>
			IFA_REMREF(ifa);
			ifa = ro-&gt;ro_rt-&gt;rt_ifa;
			IFA_ADDREF(ifa);
		}

		<span class="enscript-keyword">if</span> (ip_select_srcif_debug &amp;&amp; ifa != NULL) {
			printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d ifa_if %s\n&quot;</span>,
			    s_src, s_dst, ifscope, if_name(ifa-&gt;ifa_ifp));
		}
	}

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_LOCK_ASSERT_HELD(ro-&gt;ro_rt);
	<span class="enscript-comment">/*
	 * If there is a non-loopback route with the wrong interface, or if
	 * there is no interface configured with such an address, blow it
	 * away.  Except for local/loopback, we look for one with a matching
	 * interface scope/index.
	 */</span>
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL &amp;&amp;
	    (ifa == NULL || (ifa-&gt;ifa_ifp != rt_ifp &amp;&amp; rt_ifp != lo_ifp) ||
	    !(ro-&gt;ro_rt-&gt;rt_flags &amp; RTF_UP))) {
		<span class="enscript-keyword">if</span> (ip_select_srcif_debug) {
			<span class="enscript-keyword">if</span> (ifa != NULL) {
				printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d ro_if %s != &quot;</span>
				    <span class="enscript-string">&quot;ifa_if %s (cached route cleared)\n&quot;</span>,
				    s_src, s_dst, ifscope, if_name(rt_ifp),
				    if_name(ifa-&gt;ifa_ifp));
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d ro_if %s &quot;</span>
				    <span class="enscript-string">&quot;(no ifa_if found)\n&quot;</span>,
				    s_src, s_dst, ifscope, if_name(rt_ifp));
			}
		}

		RT_UNLOCK(ro-&gt;ro_rt);
		ROUTE_RELEASE(ro);

		<span class="enscript-comment">/*
		 * If the destination is IPv4 LLA and the route's interface
		 * doesn't match the source interface, then the source IP
		 * address is wrong; it most likely belongs to the primary
		 * interface associated with the IPv4 LL subnet.  Drop the
		 * packet rather than letting it go out and return an error
		 * to the ULP.  This actually applies not only to IPv4 LL
		 * but other shared subnets; for now we explicitly test only
		 * for the former case and save the latter for future.
		 */</span>
		<span class="enscript-keyword">if</span> (IN_LINKLOCAL(ntohl(dst.s_addr)) &amp;&amp;
		    !IN_LINKLOCAL(ntohl(src.s_addr)) &amp;&amp; ifa != NULL) {
			IFA_REMREF(ifa);
			ifa = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (ip_select_srcif_debug &amp;&amp; ifa == NULL) {
		printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d (neither ro_if/ifa_if found)\n&quot;</span>,
		    s_src, s_dst, ifscope);
	}

	<span class="enscript-comment">/*
	 * If there is a route, mark it accordingly.  If there isn't one,
	 * we'll get here again during the next transmit (possibly with a
	 * route) and the flag will get set at that point.  For IPv4 LLA
	 * destination, mark it only if the route has been fully resolved;
	 * otherwise we want to come back here again when the route points
	 * to the interface over which the ARP reply arrives on.
	 */</span>
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL &amp;&amp; (!IN_LINKLOCAL(ntohl(dst.s_addr)) ||
	    (ro-&gt;ro_rt-&gt;rt_gateway-&gt;sa_family == AF_LINK &amp;&amp;
	    SDL(ro-&gt;ro_rt-&gt;rt_gateway)-&gt;sdl_alen != 0))) {
		<span class="enscript-keyword">if</span> (ifa != NULL)
			IFA_ADDREF(ifa);	<span class="enscript-comment">/* for route */</span>
		<span class="enscript-keyword">if</span> (ro-&gt;ro_srcia != NULL)
			IFA_REMREF(ro-&gt;ro_srcia);
		ro-&gt;ro_srcia = ifa;
		ro-&gt;ro_flags |= ROF_SRCIF_SELECTED;
		RT_GENID_SYNC(ro-&gt;ro_rt);
	}

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_UNLOCK(ro-&gt;ro_rt);

	<span class="enscript-keyword">return</span> (ifa);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_output_checksum</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hlen, <span class="enscript-type">int</span> ip_len,
    uint32_t *sw_csum)
{
	<span class="enscript-type">int</span> tso = TSO_IPV4_OK(ifp, m);
	uint32_t hwcap = ifp-&gt;if_hwassist;

	m-&gt;m_pkthdr.csum_flags |= CSUM_IP;

	<span class="enscript-keyword">if</span> (!hwcksum_tx) {
		<span class="enscript-comment">/* do all in software; hardware checksum offload is disabled */</span>
		*sw_csum = (CSUM_DELAY_DATA | CSUM_DELAY_IP) &amp;
		    m-&gt;m_pkthdr.csum_flags;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* do in software what the hardware cannot */</span>
		*sw_csum = m-&gt;m_pkthdr.csum_flags &amp;
		    ~IF_HWASSIST_CSUM_FLAGS(hwcap);
	}

	<span class="enscript-keyword">if</span> (hlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		*sw_csum |= ((CSUM_DELAY_DATA | CSUM_DELAY_IP) &amp;
		    m-&gt;m_pkthdr.csum_flags);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(*sw_csum &amp; CSUM_DELAY_DATA) &amp;&amp; (hwcap &amp; CSUM_PARTIAL)) {
		<span class="enscript-comment">/*
		 * Partial checksum offload, if non-IP fragment, and TCP only
		 * (no UDP support, as the hardware may not be able to convert
		 * +0 to -0 (0xffff) per RFC1122 4.1.3.4.)
		 */</span>
		<span class="enscript-keyword">if</span> (hwcksum_tx &amp;&amp; !tso &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCP) &amp;&amp;
		    ip_len &lt;= ifp-&gt;if_mtu) {
			uint16_t start = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
			uint16_t ulpoff = m-&gt;m_pkthdr.csum_data &amp; 0xffff;
			m-&gt;m_pkthdr.csum_flags |=
			    (CSUM_DATA_VALID | CSUM_PARTIAL);
			m-&gt;m_pkthdr.csum_tx_stuff = (ulpoff + start);
			m-&gt;m_pkthdr.csum_tx_start = start;
			<span class="enscript-comment">/* do IP hdr chksum in software */</span>
			*sw_csum = CSUM_DELAY_IP;
		} <span class="enscript-keyword">else</span> {
			*sw_csum |= (CSUM_DELAY_DATA &amp; m-&gt;m_pkthdr.csum_flags);
		}
	}

	<span class="enscript-keyword">if</span> (*sw_csum &amp; CSUM_DELAY_DATA) {
		in_delayed_cksum(m);
		*sw_csum &amp;= ~CSUM_DELAY_DATA;
	}

	<span class="enscript-keyword">if</span> (hwcksum_tx) {
		<span class="enscript-comment">/*
		 * Drop off bits that aren't supported by hardware;
		 * also make sure to preserve non-checksum related bits.
		 */</span>
		m-&gt;m_pkthdr.csum_flags =
		    ((m-&gt;m_pkthdr.csum_flags &amp;
		    (IF_HWASSIST_CSUM_FLAGS(hwcap) | CSUM_DATA_VALID)) |
		    (m-&gt;m_pkthdr.csum_flags &amp; ~IF_HWASSIST_CSUM_MASK));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* drop all bits; hardware checksum offload is disabled */</span>
		m-&gt;m_pkthdr.csum_flags = 0;
	}
}

<span class="enscript-comment">/*
 * GRE protocol output for PPP/PPTP
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_gre_output</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> route ro;
	<span class="enscript-type">int</span> error;

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));

	error = ip_output(m, NULL, &amp;ro, 0, NULL, NULL);

	ROUTE_RELEASE(&amp;ro);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_reset_ip_output_stats SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	i = ip_output_measure;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* impose bounds */</span>
	<span class="enscript-keyword">if</span> (i &lt; 0 || i &gt; 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (ip_output_measure != i &amp;&amp; i == 1) {
		net_perf_initialize(&amp;net_perf, ip_output_measure_bins);
	}
	ip_output_measure = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip_output_measure_bins SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	uint64_t i;

	i = ip_output_measure_bins;
	error = sysctl_handle_quad(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* validate data */</span>
	<span class="enscript-keyword">if</span> (!net_perf_validate_bins(i)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	ip_output_measure_bins = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip_output_getperf SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;net_perf, MIN(<span class="enscript-keyword">sizeof</span> (net_perf), req-&gt;oldlen)));
}

</pre>
<hr />
</body></html>