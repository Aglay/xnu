<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in_var.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in_var.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1985, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_var.h	8.2 (Berkeley) 1/9/95
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NETINET_IN_VAR_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_NETINET_IN_VAR_H_</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

<span class="enscript-comment">/*
 * Interface address, Internet version.  One of these structures
 * is allocated for each Internet address on an interface.
 * The ifaddr structure contains the protocol-independent part
 * of the structure and is assumed to be first.
 */</span>
<span class="enscript-type">struct</span> in_ifaddr {
	<span class="enscript-type">struct</span> ifaddr ia_ifa;		<span class="enscript-comment">/* protocol-independent info */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ia_ifp</span>		ia_ifa.ifa_ifp
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ia_flags</span>	ia_ifa.ifa_flags
					<span class="enscript-comment">/* ia_{,sub}net{,mask} in host order */</span>
	u_int32_t ia_net;		<span class="enscript-comment">/* network number of interface */</span>
	u_int32_t ia_netmask;		<span class="enscript-comment">/* mask of net part */</span>
	u_int32_t ia_subnet;		<span class="enscript-comment">/* subnet number, including net */</span>
	u_int32_t ia_subnetmask;	<span class="enscript-comment">/* mask of subnet part */</span>
	<span class="enscript-type">struct</span> in_addr ia_netbroadcast;	<span class="enscript-comment">/* to recognize net broadcasts */</span>
	TAILQ_ENTRY(in_ifaddr) ia_link;	<span class="enscript-comment">/* tailq macro glue */</span>
	<span class="enscript-type">struct</span> sockaddr_in ia_addr;	<span class="enscript-comment">/* reserve space for interface name */</span>
	<span class="enscript-type">struct</span> sockaddr_in ia_dstaddr;	<span class="enscript-comment">/* reserve space for broadcast addr */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ia_broadaddr</span>	ia_dstaddr
	<span class="enscript-type">struct</span> sockaddr_in ia_sockmask;	<span class="enscript-comment">/* reserve space for general netmask */</span>
	TAILQ_ENTRY(in_ifaddr) ia_hash;	<span class="enscript-comment">/* hash bucket entry */</span>
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ifatoia</span>(ifa)	((struct in_ifaddr *)(void *)(ifa))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>

<span class="enscript-type">struct</span> in_aliasreq {
	<span class="enscript-type">char</span> ifra_name[IFNAMSIZ];	<span class="enscript-comment">/* if name, e.g. &quot;en0&quot; */</span>
	<span class="enscript-type">struct</span> sockaddr_in ifra_addr;
	<span class="enscript-type">struct</span> sockaddr_in ifra_broadaddr;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ifra_dstaddr</span>	ifra_broadaddr
	<span class="enscript-type">struct</span> sockaddr_in ifra_mask;
};

<span class="enscript-comment">/*
 * Event data, inet style.
 */</span>
<span class="enscript-type">struct</span> kev_in_data {
	<span class="enscript-type">struct</span> net_event_data link_data;
	<span class="enscript-type">struct</span> in_addr ia_addr;		<span class="enscript-comment">/* interface address */</span>
	u_int32_t ia_net;		<span class="enscript-comment">/* network number of interface */</span>
	u_int32_t ia_netmask;		<span class="enscript-comment">/* mask of net part */</span>
	u_int32_t ia_subnet;		<span class="enscript-comment">/* subnet number, including net */</span>
	u_int32_t ia_subnetmask;	<span class="enscript-comment">/* mask of subnet part */</span>
	<span class="enscript-type">struct</span> in_addr ia_netbroadcast;	<span class="enscript-comment">/* to recognize net broadcasts */</span>
	<span class="enscript-type">struct</span> in_addr ia_dstaddr;
};

<span class="enscript-type">struct</span> kev_in_collision {
	<span class="enscript-type">struct</span> net_event_data link_data; <span class="enscript-comment">/* link where ARP was received on */</span>
	<span class="enscript-type">struct</span> in_addr ia_ipaddr;	<span class="enscript-comment">/* conflicting IP address */</span>
	u_char hw_len;			<span class="enscript-comment">/* length of hardware address */</span>
	u_char hw_addr[0];		<span class="enscript-comment">/* variable length hardware address */</span>
};

<span class="enscript-type">struct</span> kev_in_arpfailure {
	<span class="enscript-type">struct</span> net_event_data link_data; <span class="enscript-comment">/* link where ARP is being sent */</span>
};

<span class="enscript-type">struct</span> kev_in_arpalive {
	<span class="enscript-type">struct</span> net_event_data link_data; <span class="enscript-comment">/* link where ARP was received */</span>
};


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
<span class="enscript-type">struct</span> kev_in_portinuse {
	u_int16_t port;		<span class="enscript-comment">/* conflicting port number in host order */</span>
	u_int32_t req_pid;	<span class="enscript-comment">/* PID port requestor */</span>
	u_int32_t reserved[2];
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>

<span class="enscript-comment">/*
 * Define inet event subclass and specific inet events.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_SUBCLASS</span>		1 <span class="enscript-comment">/* inet subclass identifier */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_NEW_ADDR</span>		1 <span class="enscript-comment">/* Userland configured IP address */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_CHANGED_ADDR</span>		2 <span class="enscript-comment">/* Address changed event */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_ADDR_DELETED</span>		3 <span class="enscript-comment">/* IPv6 address was deleted */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_SIFDSTADDR</span>		4 <span class="enscript-comment">/* Dest. address was set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_SIFBRDADDR</span>		5 <span class="enscript-comment">/* Broadcast address was set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_SIFNETMASK</span>		6 <span class="enscript-comment">/* Netmask was set */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_ARPCOLLISION</span>		7 <span class="enscript-comment">/* ARP collision detected */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_PORTINUSE</span>		8 <span class="enscript-comment">/* use ken_in_portinuse */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_ARPRTRFAILURE</span>		9 <span class="enscript-comment">/* ARP resolution failed for router */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KEV_INET_ARPRTRALIVE</span>		10 <span class="enscript-comment">/* ARP resolution succeeded for 
					      router */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tree.h&gt;</span>
<span class="enscript-comment">/*
 * Given a pointer to an in_ifaddr (ifaddr),
 * return a pointer to the addr as a sockaddr_in.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IA_SIN</span>(ia)    (&amp;(((struct in_ifaddr *)(ia))-&gt;ia_addr))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IA_DSTSIN</span>(ia) (&amp;(((struct in_ifaddr *)(ia))-&gt;ia_dstaddr))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN_LNAOF</span>(in, ifa) \
	((ntohl((in).s_addr) &amp; ~((<span class="enscript-type">struct</span> in_ifaddr *)(ifa)-&gt;ia_subnetmask))

<span class="enscript-comment">/*
 * Hash table for IPv4 addresses.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">TAILQ_HEAD</span>(in_ifaddrhead, in_ifaddr) in_ifaddrhead;
<span class="enscript-type">extern</span> <span class="enscript-function-name">TAILQ_HEAD</span>(in_ifaddrhashhead, in_ifaddr) *in_ifaddrhashtbl;
<span class="enscript-type">extern</span> lck_rw_t *in_ifaddr_rwlock;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INADDR_HASH</span>(x)	(&amp;in_ifaddrhashtbl[inaddr_hashval(x)])

<span class="enscript-type">extern</span>	u_char	inetctlerrmap[];

<span class="enscript-comment">/*
 * Macro for finding the interface (ifnet structure) corresponding to one
 * of our IP addresses.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INADDR_TO_IFP</span>(addr, ifp)					\
	<span class="enscript-comment">/* struct in_addr addr; */</span>					\
	<span class="enscript-comment">/* struct ifnet *ifp; */</span>					\
{									\
	<span class="enscript-type">struct</span> in_ifaddr *ia;						\
									\
	lck_rw_lock_shared(in_ifaddr_rwlock);				\
	TAILQ_FOREACH(ia, INADDR_HASH((addr).s_addr), ia_hash) {	\
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);				\
		<span class="enscript-keyword">if</span> (IA_SIN(ia)-&gt;sin_addr.s_addr == (addr).s_addr) {	\
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);			\
			<span class="enscript-keyword">break</span>;						\
		}							\
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);				\
	}								\
	(ifp) = (ia == NULL) ? NULL : ia-&gt;ia_ifp;			\
	lck_rw_done(in_ifaddr_rwlock);					\
}

<span class="enscript-comment">/*
 * Macro for finding the internet address structure (in_ifaddr) corresponding
 * to a given interface (ifnet structure).  Caller is responsible for freeing
 * the reference.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IFP_TO_IA</span>(ifp, ia)						\
	<span class="enscript-comment">/* struct ifnet *ifp; */</span>					\
	<span class="enscript-comment">/* struct in_ifaddr *ia; */</span>					\
{									\
	lck_rw_lock_shared(in_ifaddr_rwlock);				\
	<span class="enscript-keyword">for</span> ((ia) = TAILQ_FIRST(&amp;in_ifaddrhead);			\
	    (ia) != NULL &amp;&amp; (ia)-&gt;ia_ifp != (ifp);			\
	    (ia) = TAILQ_NEXT((ia), ia_link))				\
		<span class="enscript-keyword">continue</span>;						\
	<span class="enscript-keyword">if</span> ((ia) != NULL)						\
		IFA_ADDREF(&amp;(ia)-&gt;ia_ifa);				\
	lck_rw_done(in_ifaddr_rwlock);					\
}

<span class="enscript-comment">/*
 * This information should be part of the ifnet structure but we don't wish
 * to change that - as it might break a number of things
 */</span>

<span class="enscript-comment">/*
 * Legacy IPv4 IGMP per-link structure.
 */</span>
<span class="enscript-type">struct</span> router_info {
	<span class="enscript-type">struct</span> ifnet *rti_ifp;
	<span class="enscript-type">int</span>    rti_type; <span class="enscript-comment">/* type of router which is querier on this interface */</span>
	<span class="enscript-type">int</span>    rti_time; <span class="enscript-comment">/* # of slow timeouts since last old query */</span>
	SLIST_ENTRY(router_info) rti_list;
};

<span class="enscript-comment">/*
 * IPv4 multicast IGMP-layer source entry.
 */</span>
<span class="enscript-type">struct</span> ip_msource {
	RB_ENTRY(ip_msource)	ims_link;	<span class="enscript-comment">/* RB tree links */</span>
	in_addr_t		ims_haddr;	<span class="enscript-comment">/* host byte order */</span>
	<span class="enscript-type">struct</span> ims_st {
		uint16_t	ex;		<span class="enscript-comment">/* # of exclusive members */</span>
		uint16_t	in;		<span class="enscript-comment">/* # of inclusive members */</span>
	}			ims_st[2];	<span class="enscript-comment">/* state at t0, t1 */</span>
	uint8_t			ims_stp;	<span class="enscript-comment">/* pending query */</span>
};

<span class="enscript-comment">/*
 * IPv4 multicast PCB-layer source entry.
 */</span>
<span class="enscript-type">struct</span> in_msource {
	RB_ENTRY(ip_msource)	ims_link;	<span class="enscript-comment">/* RB tree links */</span>
	in_addr_t		ims_haddr;	<span class="enscript-comment">/* host byte order */</span>
	uint8_t			imsl_st[2];	<span class="enscript-comment">/* state before/at commit */</span>
};

<span class="enscript-function-name">RB_HEAD</span>(ip_msource_tree, ip_msource);	<span class="enscript-comment">/* define struct ip_msource_tree */</span>

<span class="enscript-function-name">RB_PROTOTYPE_SC_PREV</span>(__private_extern__, ip_msource_tree, ip_msource,
    ims_link, ip_msource_cmp);

<span class="enscript-comment">/*
 * IPv4 multicast PCB-layer group filter descriptor.
 */</span>
<span class="enscript-type">struct</span> in_mfilter {
	<span class="enscript-type">struct</span> ip_msource_tree	imf_sources; <span class="enscript-comment">/* source list for (S,G) */</span>
	u_long			imf_nsrc;    <span class="enscript-comment">/* # of source entries */</span>
	uint8_t			imf_st[2];   <span class="enscript-comment">/* state before/at commit */</span>
};

<span class="enscript-type">struct</span> igmp_ifinfo;

<span class="enscript-comment">/*
 * IPv4 group descriptor.
 *
 * For every entry on an ifnet's if_multiaddrs list which represents
 * an IP multicast group, there is one of these structures.
 *
 * If any source filters are present, then a node will exist in the RB-tree
 * to permit fast lookup by source whenever an operation takes place.
 * This permits pre-order traversal when we issue reports.
 * Source filter trees are kept separately from the socket layer to
 * greatly simplify locking.
 *
 * When IGMPv3 is active, inm_timer is the response to group query timer.
 * The state-change timer inm_sctimer is separate; whenever state changes
 * for the group the state change record is generated and transmitted,
 * and kept if retransmissions are necessary.
 *
 * The request count here is a count of requests for this address, not a
 * count of pointers to this structure.
 *
 * FUTURE: inm_link is now only used when groups are being purged
 * on a detaching ifnet.  It could be demoted to a SLIST_ENTRY.
 */</span>
<span class="enscript-type">struct</span> in_multi {
	decl_lck_mtx_data(, inm_lock);
	u_int32_t inm_refcount;		<span class="enscript-comment">/* reference count */</span>
	u_int32_t inm_reqcnt;		<span class="enscript-comment">/* request count for this address */</span>
	u_int32_t inm_debug;		<span class="enscript-comment">/* see ifa_debug flags */</span>
	LIST_ENTRY(in_multi) inm_link;	<span class="enscript-comment">/* queue macro glue */</span>
	<span class="enscript-type">struct</span>	in_addr inm_addr;	<span class="enscript-comment">/* IP multicast address, convenience */</span>
	<span class="enscript-type">struct</span>	ifnet *inm_ifp;		<span class="enscript-comment">/* back pointer to ifnet */</span>
	<span class="enscript-type">struct</span>	ifmultiaddr *inm_ifma;	<span class="enscript-comment">/* back pointer to ifmultiaddr */</span>
	u_int	inm_timer;		<span class="enscript-comment">/* IGMPv1/v2 group / v3 query timer  */</span>
	u_int	inm_state;		<span class="enscript-comment">/*  state of the membership */</span>
	<span class="enscript-type">void</span> *inm_rti;			<span class="enscript-comment">/* unused, legacy field */</span>

	<span class="enscript-comment">/* New fields for IGMPv3 follow. */</span>
	<span class="enscript-type">struct</span> igmp_ifinfo	*inm_igi;	<span class="enscript-comment">/* IGMP info */</span>
	SLIST_ENTRY(in_multi)	 inm_dtle;	<span class="enscript-comment">/* detached waiting for rele */</span>
	SLIST_ENTRY(in_multi)	 inm_nrele;	<span class="enscript-comment">/* to-be-released by IGMP */</span>
	u_int32_t		 inm_nrelecnt;	<span class="enscript-comment">/* deferred release count */</span>
	<span class="enscript-type">struct</span> ip_msource_tree	 inm_srcs;	<span class="enscript-comment">/* tree of sources */</span>
	u_long			 inm_nsrc;	<span class="enscript-comment">/* # of tree entries */</span>

	<span class="enscript-type">struct</span> ifqueue		 inm_scq;	<span class="enscript-comment">/* queue of pending
						 * state-change packets */</span>
	<span class="enscript-type">struct</span> timeval		 inm_lastgsrtv;	<span class="enscript-comment">/* Time of last G-S-R query */</span>
	uint16_t		 inm_sctimer;	<span class="enscript-comment">/* state-change timer */</span>
	uint16_t		 inm_scrv;	<span class="enscript-comment">/* state-change rexmit count */</span>

	<span class="enscript-comment">/*
	 * SSM state counters which track state at T0 (the time the last
	 * state-change report's RV timer went to zero) and T1
	 * (time of pending report, i.e. now).
	 * Used for computing IGMPv3 state-change reports. Several refcounts
	 * are maintained here to optimize for common use-cases.
	 */</span>
	<span class="enscript-type">struct</span> inm_st {
		uint16_t	iss_fmode;	<span class="enscript-comment">/* IGMP filter mode */</span>
		uint16_t	iss_asm;	<span class="enscript-comment">/* # of ASM listeners */</span>
		uint16_t	iss_ex;		<span class="enscript-comment">/* # of exclusive members */</span>
		uint16_t	iss_in;		<span class="enscript-comment">/* # of inclusive members */</span>
		uint16_t	iss_rec;	<span class="enscript-comment">/* # of recorded sources */</span>
	}			inm_st[2];	<span class="enscript-comment">/* state at t0, t1 */</span>

	<span class="enscript-type">void</span> (*inm_trace)		<span class="enscript-comment">/* callback fn for tracing refs */</span>
	    (<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">int</span>);
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_LOCK_ASSERT_HELD</span>(_inm)					\
	lck_mtx_assert(&amp;(_inm)-&gt;inm_lock, LCK_MTX_ASSERT_OWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_LOCK_ASSERT_NOTHELD</span>(_inm)					\
	lck_mtx_assert(&amp;(_inm)-&gt;inm_lock, LCK_MTX_ASSERT_NOTOWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_LOCK</span>(_inm)							\
	lck_mtx_lock(&amp;(_inm)-&gt;inm_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_LOCK_SPIN</span>(_inm)						\
	lck_mtx_lock_spin(&amp;(_inm)-&gt;inm_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_CONVERT_LOCK</span>(_inm) do {					\
	INM_LOCK_ASSERT_HELD(_inm);					\
	lck_mtx_convert_spin(&amp;(_inm)-&gt;inm_lock);			\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_UNLOCK</span>(_inm)						\
	lck_mtx_unlock(&amp;(_inm)-&gt;inm_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_ADDREF</span>(_inm)						\
	inm_addref(_inm, 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_ADDREF_LOCKED</span>(_inm)						\
	inm_addref(_inm, 1)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_REMREF</span>(_inm)						\
	inm_remref(_inm, 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INM_REMREF_LOCKED</span>(_inm)						\
	inm_remref(_inm, 1)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SYSCTL_DECL</span>
<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet_ip);
<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet_raw);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(in_multihead, in_multi) in_multihead;

<span class="enscript-comment">/*
 * Structure used by macros below to remember position when stepping through
 * all of the in_multi records.
 */</span>
<span class="enscript-type">struct</span> in_multistep {
	<span class="enscript-type">struct</span> in_multi *i_inm;
};

<span class="enscript-comment">/*
 * Macro for looking up the in_multi record for a given IP multicast address
 * on a given interface.  If no matching record is found, &quot;inm&quot; is set null.
 *
 * We do this differently compared other BSD implementations; instead of
 * walking the if_multiaddrs list at the interface and returning the
 * ifma_protospec value of a matching entry, we search the global list
 * of in_multi records and find it that way.  Otherwise either the two
 * structures (in_multi, ifmultiaddr) need to be ref counted both ways,
 * which will make things too complicated, or they need to reside in the
 * same protected domain, which they aren't.
 *
 * Must be called with in_multihead_lock held.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN_LOOKUP_MULTI</span>(addr, ifp, inm)					\
	<span class="enscript-comment">/* struct in_addr *addr; */</span>					\
	<span class="enscript-comment">/* struct ifnet *ifp; */</span>					\
	<span class="enscript-comment">/* struct in_multi *inm; */</span>					\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-type">struct</span> in_multistep _step;					\
	IN_FIRST_MULTI(_step, inm);					\
	<span class="enscript-keyword">while</span> ((inm) != NULL) {						\
		INM_LOCK_SPIN(inm);					\
		<span class="enscript-keyword">if</span> ((inm)-&gt;inm_ifp == (ifp) &amp;&amp;				\
		    (inm)-&gt;inm_addr.s_addr == (addr)-&gt;s_addr) {		\
			INM_ADDREF_LOCKED(inm);				\
			INM_UNLOCK(inm);				\
			<span class="enscript-keyword">break</span>;						\
		}							\
		INM_UNLOCK(inm);					\
		IN_NEXT_MULTI(_step, inm);				\
	}								\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Macro to step through all of the in_multi records, one at a time.
 * The current position is remembered in &quot;step&quot;, which the caller must
 * provide.  IN_FIRST_MULTI(), below, must be called to initialize &quot;step&quot;
 * and get the first record.  Both macros return a NULL &quot;inm&quot; when there
 * are no remaining records.
 *
 * Must be called with in_multihead_lock held.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN_NEXT_MULTI</span>(step, inm)					\
	<span class="enscript-comment">/* struct in_multistep  step; */</span>				\
	<span class="enscript-comment">/* struct in_multi *inm; */</span>					\
<span class="enscript-keyword">do</span> {									\
	in_multihead_lock_assert(LCK_RW_ASSERT_HELD);			\
	<span class="enscript-keyword">if</span> (((inm) = (step).i_inm) != NULL)				\
		(step).i_inm = LIST_NEXT((step).i_inm, inm_link);	\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN_FIRST_MULTI</span>(step, inm)					\
	<span class="enscript-comment">/* struct in_multistep step; */</span>					\
	<span class="enscript-comment">/* struct in_multi *inm; */</span>					\
<span class="enscript-keyword">do</span> {									\
	in_multihead_lock_assert(LCK_RW_ASSERT_HELD);			\
	(step).i_inm = LIST_FIRST(&amp;in_multihead);			\
	IN_NEXT_MULTI((step), (inm));					\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">extern</span> lck_mtx_t *inet_domain_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain *inetdomain;

<span class="enscript-type">struct</span> ip_moptions;
<span class="enscript-type">struct</span> inpcb;

<span class="enscript-comment">/*
 * Return values for imo_multi_filter().
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCAST_PASS</span>		0	<span class="enscript-comment">/* Pass */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCAST_NOTGMEMBER</span>	1	<span class="enscript-comment">/* This host not a member of group */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCAST_NOTSMEMBER</span>	2	<span class="enscript-comment">/* This host excluded source */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCAST_MUTED</span>		3	<span class="enscript-comment">/* [deprecated] */</span>

<span class="enscript-comment">/*
 * Per-interface IPv4 structures.
 */</span>
<span class="enscript-type">struct</span> in_ifextra {
	uint32_t		netsig_len;
	u_int8_t		netsig[IFNET_SIGNATURELEN];
};
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN_IFEXTRA</span>(_ifp)	((struct in_ifextra *)(_ifp-&gt;if_inetdata))

<span class="enscript-type">extern</span> u_int32_t ipv4_ll_arp_aware;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_ifaddr_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">imo_multi_filter</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip_moptions *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">imo_clone</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> inpcb *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_commit</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_clear_recorded</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_print</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">inm_record_source</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">const</span> in_addr_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_release</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_multi_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> in_multi *<span class="enscript-function-name">in_addmulti</span>(<span class="enscript-type">struct</span> in_addr *, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_delmulti</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_leavegroup</span>(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">struct</span> in_mfilter *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_multi_detach</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_addref</span>(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_remref</span>(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inm_purge</span>(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">extern</span> uint8_t <span class="enscript-function-name">ims_get_mode</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_multi *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip_msource *, uint8_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_control</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_inithead</span>(<span class="enscript-type">void</span> **, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_rtqdrain</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> radix_node *<span class="enscript-function-name">in_validate</span>(<span class="enscript-type">struct</span> radix_node *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_input</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_input_process_list</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_ifadown</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_ifscrub</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in_ifaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">inaddr_hashval</span>(u_int32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_purgeaddrs</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in_selectaddrs</span>(<span class="enscript-type">int</span> af, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_entry **, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_entry **);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">gre_input</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">imf_leave</span>(<span class="enscript-type">struct</span> in_mfilter *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">imf_purge</span>(<span class="enscript-type">struct</span> in_mfilter *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">inp_join_group</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">inp_leave_group</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_multihead_lock_exclusive</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_multihead_lock_shared</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_multihead_lock_assert</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_multihead_lock_done</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* BSD_KERNEL_PRIVATE */</span>
<span class="enscript-comment">/* INET6 stuff */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NETINET_IN_VAR_H_ */</span>
</pre>
<hr />
</body></html>