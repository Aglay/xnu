<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_cache.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_cache.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/* TCP-cache to store and retrieve TCP-related information */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

<span class="enscript-type">struct</span> tcp_heuristic_key {
	<span class="enscript-type">union</span> {
		uint8_t thk_net_signature[IFNET_SIGNATURELEN];
		<span class="enscript-type">union</span> {
			<span class="enscript-type">struct</span> in_addr addr;
			<span class="enscript-type">struct</span> in6_addr addr6;
		} thk_ip;
	};
	sa_family_t	thk_family;
};

<span class="enscript-type">struct</span> tcp_heuristic {
	SLIST_ENTRY(tcp_heuristic) list;

	u_int32_t	th_last_access;

	<span class="enscript-type">struct</span> tcp_heuristic_key	th_key;

	<span class="enscript-comment">/*
	 * If tfo_cookie_loss is changed to a smaller type, it might be worth
	 * checking for integer-overflow in tcp_cache_tfo_inc_loss
	 */</span>
	u_int32_t	th_tfo_cookie_loss; <span class="enscript-comment">/* The number of times a SYN+cookie has been lost */</span>
	u_int32_t	th_tfo_fallback_trials; <span class="enscript-comment">/* Number of times we did not try out TFO due to SYN-loss */</span>
	u_int32_t	th_tfo_cookie_backoff; <span class="enscript-comment">/* Time until when we should not try out TFO */</span>

	u_int8_t	th_tfo_in_backoff:1, <span class="enscript-comment">/* Are we doing TFO due to the backoff timer? */</span>
			<span class="enscript-reference">th_tfo_aggressive_fallback</span>:1, <span class="enscript-comment">/* Agressive fallback due to nasty middlebox */</span>
			<span class="enscript-reference">th_tfo_snd_middlebox_supp</span>:1, <span class="enscript-comment">/* We are sure that the network supports TFO in upstream direction */</span>
			<span class="enscript-reference">th_tfo_rcv_middlebox_supp</span>:1; <span class="enscript-comment">/* We are sure that the network supports TFO in downstream direction*/</span>
};

<span class="enscript-type">struct</span> tcp_heuristics_head {
	SLIST_HEAD(tcp_heur_bucket, tcp_heuristic) tcp_heuristics;

	<span class="enscript-comment">/* Per-hashbucket lock to avoid lock-contention */</span>
	lck_mtx_t	thh_mtx;
};

<span class="enscript-type">struct</span> tcp_cache_key {
	sa_family_t	tck_family;

	<span class="enscript-type">struct</span> tcp_heuristic_key tck_src;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> in_addr addr;
		<span class="enscript-type">struct</span> in6_addr addr6;
	} tck_dst;
};

<span class="enscript-type">struct</span> tcp_cache {
	SLIST_ENTRY(tcp_cache) list;

	u_int32_t	tc_last_access;

	<span class="enscript-type">struct</span> tcp_cache_key tc_key;

	u_int8_t	tc_tfo_cookie[TFO_COOKIE_LEN_MAX];
	u_int8_t	tc_tfo_cookie_len;
};

<span class="enscript-type">struct</span> tcp_cache_head {
	SLIST_HEAD(tcp_cache_bucket, tcp_cache) tcp_caches;

	<span class="enscript-comment">/* Per-hashbucket lock to avoid lock-contention */</span>
	lck_mtx_t	tch_mtx;
};

<span class="enscript-type">static</span> u_int32_t tcp_cache_hash_seed;

size_t tcp_cache_size;

<span class="enscript-comment">/*
 * The maximum depth of the hash-bucket. This way we limit the tcp_cache to
 * TCP_CACHE_BUCKET_SIZE * tcp_cache_size and have &quot;natural&quot; garbage collection
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCP_CACHE_BUCKET_SIZE</span> 5

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcp_cache_head *tcp_cache;

<span class="enscript-function-name">decl_lck_mtx_data</span>(, tcp_cache_mtx);

<span class="enscript-type">static</span> lck_attr_t	*tcp_cache_mtx_attr;
<span class="enscript-type">static</span> lck_grp_t	*tcp_cache_mtx_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*tcp_cache_mtx_grp_attr;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcp_heuristics_head *tcp_heuristics;

<span class="enscript-function-name">decl_lck_mtx_data</span>(, tcp_heuristics_mtx);

<span class="enscript-type">static</span> lck_attr_t	*tcp_heuristic_mtx_attr;
<span class="enscript-type">static</span> lck_grp_t	*tcp_heuristic_mtx_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*tcp_heuristic_mtx_grp_attr;

<span class="enscript-comment">/* Number of SYN-losses we accept */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TFO_MAX_COOKIE_LOSS</span>	2

<span class="enscript-comment">/*
 * Round up to next higher power-of 2.  See &quot;Bit Twiddling Hacks&quot;.
 *
 * Might be worth moving this to a library so that others
 * (e.g., scale_to_powerof2()) can use this as well instead of a while-loop.
 */</span>
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">tcp_cache_roundup2</span>(u_int32_t a)
{
	a--;
	a |= a &gt;&gt; 1;
	a |= a &gt;&gt; 2;
	a |= a &gt;&gt; 4;
	a |= a &gt;&gt; 8;
	a |= a &gt;&gt; 16;
	a++;

	<span class="enscript-keyword">return</span> a;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_cache_hash_src</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> tcp_heuristic_key *key)
{
	<span class="enscript-type">struct</span> ifnet *ifn = inp-&gt;inp_last_outifp;
	uint8_t len = <span class="enscript-keyword">sizeof</span>(key-&gt;thk_net_signature);
	uint16_t flags;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		<span class="enscript-type">int</span> ret;

		key-&gt;thk_family = AF_INET6;
		ret = ifnet_get_netsignature(ifn, AF_INET6, &amp;len, &amp;flags,
		    key-&gt;thk_net_signature);

		<span class="enscript-comment">/*
		 * ifnet_get_netsignature only returns EINVAL if ifn is NULL
		 * (we made sure that in the other cases it does not). So,
		 * in this case we should take the connection's address.
		 */</span>
		<span class="enscript-keyword">if</span> (ret == ENOENT || ret == EINVAL)
			memcpy(&amp;key-&gt;thk_ip.addr6, &amp;inp-&gt;in6p_laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> ret;

		key-&gt;thk_family = AF_INET;
		ret = ifnet_get_netsignature(ifn, AF_INET, &amp;len, &amp;flags,
		    key-&gt;thk_net_signature);

		<span class="enscript-comment">/*
		 * ifnet_get_netsignature only returns EINVAL if ifn is NULL
		 * (we made sure that in the other cases it does not). So,
		 * in this case we should take the connection's address.
		 */</span>
		<span class="enscript-keyword">if</span> (ret == ENOENT || ret == EINVAL)
			memcpy(&amp;key-&gt;thk_ip.addr, &amp;inp-&gt;inp_laddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
	}
}

<span class="enscript-type">static</span> u_int16_t <span class="enscript-function-name">tcp_cache_hash</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> tcp_cache_key *key)
{
	u_int32_t hash;

	bzero(key, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_cache_key));

	tcp_cache_hash_src(inp, &amp;key-&gt;tck_src);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		key-&gt;tck_family = AF_INET6;
		memcpy(&amp;key-&gt;tck_dst.addr6, &amp;inp-&gt;in6p_faddr,
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
	} <span class="enscript-keyword">else</span> {
		key-&gt;tck_family = AF_INET;
		memcpy(&amp;key-&gt;tck_dst.addr, &amp;inp-&gt;inp_faddr,
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
	}

	hash = net_flowhash(key, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_cache_key),
	    tcp_cache_hash_seed);

	<span class="enscript-keyword">return</span> (hash &amp; (tcp_cache_size - 1));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_cache_unlock</span>(<span class="enscript-type">struct</span> tcp_cache_head *head)
{
	lck_mtx_unlock(&amp;head-&gt;tch_mtx);
}

<span class="enscript-comment">/*
 * Make sure that everything that happens after tcp_getcache_with_lock()
 * is short enough to justify that you hold the per-bucket lock!!!
 *
 * Otherwise, better build another lookup-function that does not hold the
 * lock and you copy out the bits and bytes.
 *
 * That's why we provide the head as a &quot;return&quot;-pointer so that the caller
 * can give it back to use for tcp_cache_unlock().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcp_cache *<span class="enscript-function-name">tcp_getcache_with_lock</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">int</span> create,
    <span class="enscript-type">struct</span> tcp_cache_head **headarg)
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> tcp_cache *tpcache = NULL;
	<span class="enscript-type">struct</span> tcp_cache_head *head;
	<span class="enscript-type">struct</span> tcp_cache_key key;
	u_int16_t hash;
	<span class="enscript-type">int</span> i = 0;

	hash = tcp_cache_hash(inp, &amp;key);
	head = &amp;tcp_cache[hash];

	lck_mtx_lock(&amp;head-&gt;tch_mtx);

	<span class="enscript-comment">/*** First step: Look for the tcp_cache in our bucket ***/</span>
	SLIST_FOREACH(tpcache, &amp;head-&gt;tcp_caches, list) {
		<span class="enscript-keyword">if</span> (memcmp(&amp;tpcache-&gt;tc_key, &amp;key, <span class="enscript-keyword">sizeof</span>(key)) == 0)
			<span class="enscript-keyword">break</span>;

		i++;
	}

	<span class="enscript-comment">/*** Second step: If it's not there, create/recycle it ***/</span>
	<span class="enscript-keyword">if</span> ((tpcache == NULL) &amp;&amp; create) {
		<span class="enscript-keyword">if</span> (i &gt;= TCP_CACHE_BUCKET_SIZE) {
			<span class="enscript-type">struct</span> tcp_cache *oldest_cache = NULL;
			u_int32_t max_age = 0;

			<span class="enscript-comment">/* Look for the oldest tcp_cache in the bucket */</span>
			SLIST_FOREACH(tpcache, &amp;head-&gt;tcp_caches, list) {
				u_int32_t age = tcp_now - tpcache-&gt;tc_last_access;
				<span class="enscript-keyword">if</span> (age &gt; max_age) {
					max_age = age;
					oldest_cache = tpcache;
				}
			}
			VERIFY(oldest_cache != NULL);

			tpcache = oldest_cache;

			<span class="enscript-comment">/* We recycle, thus let's indicate that there is no cookie */</span>
			tpcache-&gt;tc_tfo_cookie_len = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Create a new cache and add it to the list */</span>
			tpcache = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_cache), M_TEMP,
			    M_NOWAIT | M_ZERO);
			<span class="enscript-keyword">if</span> (tpcache == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_null</span>;

			SLIST_INSERT_HEAD(&amp;head-&gt;tcp_caches, tpcache, list);
		}

		memcpy(&amp;tpcache-&gt;tc_key, &amp;key, <span class="enscript-keyword">sizeof</span>(key));
	}

	<span class="enscript-keyword">if</span> (tpcache == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_null</span>;

	<span class="enscript-comment">/* Update timestamp for garbage collection purposes */</span>
	tpcache-&gt;tc_last_access = tcp_now;
	*headarg = head;

	<span class="enscript-keyword">return</span> (tpcache);

<span class="enscript-reference">out_null</span>:
	tcp_cache_unlock(head);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_cache_set_cookie</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cookie, u_int8_t len)
{
	<span class="enscript-type">struct</span> tcp_cache_head *head;
	<span class="enscript-type">struct</span> tcp_cache *tpcache;

	<span class="enscript-comment">/* Call lookup/create function */</span>
	tpcache = tcp_getcache_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpcache == NULL)
		<span class="enscript-keyword">return</span>;

	tpcache-&gt;tc_tfo_cookie_len = len;
	memcpy(tpcache-&gt;tc_tfo_cookie, cookie, len);

	tcp_cache_unlock(head);
}

<span class="enscript-comment">/*
 * Get the cookie related to 'tp', and copy it into 'cookie', provided that len
 * is big enough (len designates the available memory.
 * Upon return, 'len' is set to the cookie's length.
 *
 * Returns 0 if we should request a cookie.
 * Returns 1 if the cookie has been found and written.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">tcp_cache_get_cookie</span>(<span class="enscript-type">struct</span> tcpcb *tp, u_char *cookie, u_int8_t *len)
{
	<span class="enscript-type">struct</span> tcp_cache_head *head;
	<span class="enscript-type">struct</span> tcp_cache *tpcache;

	<span class="enscript-comment">/* Call lookup/create function */</span>
	tpcache = tcp_getcache_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpcache == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (tpcache-&gt;tc_tfo_cookie_len == 0) {
		tcp_cache_unlock(head);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Not enough space - this should never happen as it has been checked
	 * in tcp_tfo_check. So, fail here!
	 */</span>
	VERIFY(tpcache-&gt;tc_tfo_cookie_len &lt;= *len);

	memcpy(cookie, tpcache-&gt;tc_tfo_cookie, tpcache-&gt;tc_tfo_cookie_len);
	*len = tpcache-&gt;tc_tfo_cookie_len;

	tcp_cache_unlock(head);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tcp_cache_get_cookie_len</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_cache_head *head;
	<span class="enscript-type">struct</span> tcp_cache *tpcache;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> cookie_len;

	<span class="enscript-comment">/* Call lookup/create function */</span>
	tpcache = tcp_getcache_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpcache == NULL)
		<span class="enscript-keyword">return</span> (0);

	cookie_len = tpcache-&gt;tc_tfo_cookie_len;

	tcp_cache_unlock(head);

	<span class="enscript-keyword">return</span> cookie_len;
}

<span class="enscript-type">static</span> u_int16_t <span class="enscript-function-name">tcp_heuristics_hash</span>(<span class="enscript-type">struct</span> inpcb *inp,
				     <span class="enscript-type">struct</span> tcp_heuristic_key *key)
{
	u_int32_t hash;

	bzero(key, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_heuristic_key));

	tcp_cache_hash_src(inp, key);

	hash = net_flowhash(key, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_heuristic_key),
	    tcp_cache_hash_seed);

	<span class="enscript-keyword">return</span> (hash &amp; (tcp_cache_size - 1));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_unlock</span>(<span class="enscript-type">struct</span> tcp_heuristics_head *head)
{
	lck_mtx_unlock(&amp;head-&gt;thh_mtx);
}

<span class="enscript-comment">/*
 * Make sure that everything that happens after tcp_getheuristic_with_lock()
 * is short enough to justify that you hold the per-bucket lock!!!
 *
 * Otherwise, better build another lookup-function that does not hold the
 * lock and you copy out the bits and bytes.
 *
 * That's why we provide the head as a &quot;return&quot;-pointer so that the caller
 * can give it back to use for tcp_heur_unlock().
 *
 *
 * ToDo - way too much code-duplication. We should create an interface to handle
 * bucketized hashtables with recycling of the oldest element.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcp_heuristic *<span class="enscript-function-name">tcp_getheuristic_with_lock</span>(<span class="enscript-type">struct</span> tcpcb *tp,
    <span class="enscript-type">int</span> create, <span class="enscript-type">struct</span> tcp_heuristics_head **headarg)
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> tcp_heuristic *tpheur = NULL;
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;
	<span class="enscript-type">struct</span> tcp_heuristic_key key;
	u_int16_t hash;
	<span class="enscript-type">int</span> i = 0;

	hash = tcp_heuristics_hash(inp, &amp;key);
	head = &amp;tcp_heuristics[hash];

	lck_mtx_lock(&amp;head-&gt;thh_mtx);

	<span class="enscript-comment">/*** First step: Look for the tcp_heur in our bucket ***/</span>
	SLIST_FOREACH(tpheur, &amp;head-&gt;tcp_heuristics, list) {
		<span class="enscript-keyword">if</span> (memcmp(&amp;tpheur-&gt;th_key, &amp;key, <span class="enscript-keyword">sizeof</span>(key)) == 0)
			<span class="enscript-keyword">break</span>;

		i++;
	}

	<span class="enscript-comment">/*** Second step: If it's not there, create/recycle it ***/</span>
	<span class="enscript-keyword">if</span> ((tpheur == NULL) &amp;&amp; create) {
		<span class="enscript-keyword">if</span> (i &gt;= TCP_CACHE_BUCKET_SIZE) {
			<span class="enscript-type">struct</span> tcp_heuristic *oldest_heur = NULL;
			u_int32_t max_age = 0;

			<span class="enscript-comment">/* Look for the oldest tcp_heur in the bucket */</span>
			SLIST_FOREACH(tpheur, &amp;head-&gt;tcp_heuristics, list) {
				u_int32_t age = tcp_now - tpheur-&gt;th_last_access;
				<span class="enscript-keyword">if</span> (age &gt; max_age) {
					max_age = age;
					oldest_heur = tpheur;
				}
			}
			VERIFY(oldest_heur != NULL);

			tpheur = oldest_heur;

			<span class="enscript-comment">/* We recycle - set everything to 0 */</span>
			tpheur-&gt;th_tfo_cookie_loss = 0;
			tpheur-&gt;th_tfo_fallback_trials = 0;
			tpheur-&gt;th_tfo_cookie_backoff = 0;
			tpheur-&gt;th_tfo_in_backoff = 0;
			tpheur-&gt;th_tfo_aggressive_fallback = 0;
			tpheur-&gt;th_tfo_snd_middlebox_supp = 0;
			tpheur-&gt;th_tfo_rcv_middlebox_supp = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Create a new heuristic and add it to the list */</span>
			tpheur = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_heuristic), M_TEMP,
			    M_NOWAIT | M_ZERO);
			<span class="enscript-keyword">if</span> (tpheur == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_null</span>;

			SLIST_INSERT_HEAD(&amp;head-&gt;tcp_heuristics, tpheur, list);
		}

		memcpy(&amp;tpheur-&gt;th_key, &amp;key, <span class="enscript-keyword">sizeof</span>(key));
	}

	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_null</span>;

	<span class="enscript-comment">/* Update timestamp for garbage collection purposes */</span>
	tpheur-&gt;th_last_access = tcp_now;
	*headarg = head;

	<span class="enscript-keyword">return</span> (tpheur);

<span class="enscript-reference">out_null</span>:
	tcp_heuristic_unlock(head);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_success</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;

	<span class="enscript-type">struct</span> tcp_heuristic *tpheur = tcp_getheuristic_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	tpheur-&gt;th_tfo_cookie_loss = 0;

	tcp_heuristic_unlock(head);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_rcv_good</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;

	<span class="enscript-type">struct</span> tcp_heuristic *tpheur = tcp_getheuristic_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	tpheur-&gt;th_tfo_rcv_middlebox_supp = 1;

	tcp_heuristic_unlock(head);

	tp-&gt;t_tfo_flags |= TFO_F_NO_RCVPROBING;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_snd_good</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;

	<span class="enscript-type">struct</span> tcp_heuristic *tpheur = tcp_getheuristic_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	tpheur-&gt;th_tfo_snd_middlebox_supp = 1;

	tcp_heuristic_unlock(head);

	tp-&gt;t_tfo_flags |= TFO_F_NO_SNDPROBING;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_inc_loss</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;
	<span class="enscript-type">struct</span> tcp_heuristic *tpheur;

	tpheur = tcp_getheuristic_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Potential integer overflow, but tfo_cookie_loss is 32-bits */</span>
	tpheur-&gt;th_tfo_cookie_loss++;

	tcp_heuristic_unlock(head);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_middlebox</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;
	<span class="enscript-type">struct</span> tcp_heuristic *tpheur;

	tpheur = tcp_getheuristic_with_lock(tp, 1, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	tpheur-&gt;th_tfo_aggressive_fallback = 1;

	tcp_heuristic_unlock(head);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_heuristic_tfo_reset_loss</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;
	<span class="enscript-type">struct</span> tcp_heuristic *tpheur;

	<span class="enscript-comment">/*
	 * Don't attempt to create it! Keep the heuristics clean if the
	 * server does not support TFO. This reduces the lookup-cost on
	 * our side.
	 */</span>
	tpheur = tcp_getheuristic_with_lock(tp, 0, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span>;

	tpheur-&gt;th_tfo_cookie_loss = 0;
	tpheur-&gt;th_tfo_aggressive_fallback = 0;

	tcp_heuristic_unlock(head);
}

boolean_t <span class="enscript-function-name">tcp_heuristic_do_tfo</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_heuristics_head *head;
	<span class="enscript-type">struct</span> tcp_heuristic *tpheur;

	<span class="enscript-comment">/* Get the tcp-heuristic. */</span>
	tpheur = tcp_getheuristic_with_lock(tp, 0, &amp;head);
	<span class="enscript-keyword">if</span> (tpheur == NULL)
		<span class="enscript-keyword">return</span> (true);

	<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_aggressive_fallback) {
		<span class="enscript-comment">/* Aggressive fallback - don't do TFO anymore... :'( */</span>
		tcp_heuristic_unlock(head);
		<span class="enscript-keyword">return</span> (false);
	}

	<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_cookie_loss &gt;= TFO_MAX_COOKIE_LOSS &amp;&amp;
	    (tpheur-&gt;th_tfo_fallback_trials &lt; tcp_tfo_fallback_min ||
	     TSTMP_GT(tpheur-&gt;th_tfo_cookie_backoff, tcp_now))) {
		<span class="enscript-comment">/*
		 * So, when we are in SYN-loss mode we try to stop using TFO
		 * for the next 'tcp_tfo_fallback_min' connections. That way,
		 * we are sure that never more than 1 out of tcp_tfo_fallback_min
		 * connections will suffer from our nice little middelbox.
		 *
		 * After that we first wait for 2 minutes. If we fail again,
		 * we wait for yet another 60 minutes.
		 */</span>
		tpheur-&gt;th_tfo_fallback_trials++;
		<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_fallback_trials &gt;= tcp_tfo_fallback_min &amp;&amp;
		    !tpheur-&gt;th_tfo_in_backoff) {
			<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_cookie_loss == TFO_MAX_COOKIE_LOSS)
				<span class="enscript-comment">/* Backoff for 2 minutes */</span>
				tpheur-&gt;th_tfo_cookie_backoff = tcp_now + (60 * 2 * TCP_RETRANSHZ);
			<span class="enscript-keyword">else</span>
				<span class="enscript-comment">/* Backoff for 60 minutes */</span>
				tpheur-&gt;th_tfo_cookie_backoff = tcp_now + (60 * 60 * TCP_RETRANSHZ);

			tpheur-&gt;th_tfo_in_backoff = 1;
		}

		tcp_heuristic_unlock(head);
		<span class="enscript-keyword">return</span> (false);
	}

	<span class="enscript-comment">/*
	 * We give it a new shot, set trials back to 0. This allows to
	 * start counting again from zero in case we get yet another SYN-loss
	 */</span>
	tpheur-&gt;th_tfo_fallback_trials = 0;
	tpheur-&gt;th_tfo_in_backoff = 0;

	<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_rcv_middlebox_supp)
		tp-&gt;t_tfo_flags |= TFO_F_NO_RCVPROBING;
	<span class="enscript-keyword">if</span> (tpheur-&gt;th_tfo_snd_middlebox_supp)
		tp-&gt;t_tfo_flags |= TFO_F_NO_SNDPROBING;

	tcp_heuristic_unlock(head);

	<span class="enscript-keyword">return</span> (true);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sysctl_cleartfocache</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; tcp_cache_size; i++) {
		<span class="enscript-type">struct</span> tcp_cache_head *head = &amp;tcp_cache[i];
		<span class="enscript-type">struct</span> tcp_cache *tpcache, *tmp;
		<span class="enscript-type">struct</span> tcp_heuristics_head *hhead = &amp;tcp_heuristics[i];
		<span class="enscript-type">struct</span> tcp_heuristic *tpheur, *htmp;

		lck_mtx_lock(&amp;head-&gt;tch_mtx);
		SLIST_FOREACH_SAFE(tpcache, &amp;head-&gt;tcp_caches, list, tmp) {
			SLIST_REMOVE(&amp;head-&gt;tcp_caches, tpcache, tcp_cache, list);
			_FREE(tpcache, M_TEMP);
		}
		lck_mtx_unlock(&amp;head-&gt;tch_mtx);

		lck_mtx_lock(&amp;hhead-&gt;thh_mtx);
		SLIST_FOREACH_SAFE(tpheur, &amp;hhead-&gt;tcp_heuristics, list, htmp) {
			SLIST_REMOVE(&amp;hhead-&gt;tcp_heuristics, tpheur, tcp_heuristic, list);
			_FREE(tpheur, M_TEMP);
		}
		lck_mtx_unlock(&amp;hhead-&gt;thh_mtx);
	}
}

<span class="enscript-comment">/* This sysctl is useful for testing purposes only */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcpcleartfo = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_cleartfo SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0, val, oldval = tcpcleartfo;

	val = oldval;
	error = sysctl_handle_int(oidp, &amp;val, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * The actual value does not matter. If the value is set, it triggers
	 * the clearing of the TFO cache. If a future implementation does not
	 * use the route entry to hold the TFO cache, replace the route sysctl.
	 */</span>

	<span class="enscript-keyword">if</span> (val != oldval)
		sysctl_cleartfocache();

	tcpcleartfo = val;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, clear_tfocache, CTLTYPE_INT | CTLFLAG_RW |
	CTLFLAG_LOCKED, &amp;tcpcleartfo, 0, &amp;sysctl_cleartfo, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;Toggle to clear the TFO destination based heuristic cache&quot;</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">tcp_cache_init</span>(<span class="enscript-type">void</span>)
{
	uint64_t sane_size_meg = sane_size / 1024 / 1024;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * On machines with &lt;100MB of memory this will result in a (full) cache-size
	 * of 32 entries, thus 32 * 5 * 64bytes = 10KB. (about 0.01 %)
	 * On machines with &gt; 4GB of memory, we have a cache-size of 1024 entries,
	 * thus about 327KB.
	 *
	 * Side-note: we convert to u_int32_t. If sane_size is more than
	 * 16000 TB, we loose precision. But, who cares? :)
	 */</span>
	tcp_cache_size = tcp_cache_roundup2((u_int32_t)(sane_size_meg &gt;&gt; 2));
	<span class="enscript-keyword">if</span> (tcp_cache_size &lt; 32)
		tcp_cache_size = 32;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tcp_cache_size &gt; 1024)
		tcp_cache_size = 1024;

	tcp_cache = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_cache_head) * tcp_cache_size,
	    M_TEMP, M_ZERO);
	<span class="enscript-keyword">if</span> (tcp_cache == NULL)
		panic(<span class="enscript-string">&quot;Allocating tcp_cache failed at boot-time!&quot;</span>);

	tcp_cache_mtx_grp_attr = lck_grp_attr_alloc_init();
	tcp_cache_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tcpcache&quot;</span>, tcp_cache_mtx_grp_attr);
	tcp_cache_mtx_attr = lck_attr_alloc_init();

	tcp_heuristics = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_heuristics_head) * tcp_cache_size,
	    M_TEMP, M_ZERO);
	<span class="enscript-keyword">if</span> (tcp_heuristics == NULL)
		panic(<span class="enscript-string">&quot;Allocating tcp_heuristic failed at boot-time!&quot;</span>);

	tcp_heuristic_mtx_grp_attr = lck_grp_attr_alloc_init();
	tcp_heuristic_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tcpheuristic&quot;</span>, tcp_heuristic_mtx_grp_attr);
	tcp_heuristic_mtx_attr = lck_attr_alloc_init();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; tcp_cache_size; i++) {
		lck_mtx_init(&amp;tcp_cache[i].tch_mtx, tcp_cache_mtx_grp,
		    tcp_cache_mtx_attr);
		SLIST_INIT(&amp;tcp_cache[i].tcp_caches);

		lck_mtx_init(&amp;tcp_heuristics[i].thh_mtx, tcp_heuristic_mtx_grp,
		    tcp_heuristic_mtx_attr);
		SLIST_INIT(&amp;tcp_heuristics[i].tcp_heuristics);
	}

	tcp_cache_hash_seed = RandomULong();
}
</pre>
<hr />
</body></html>