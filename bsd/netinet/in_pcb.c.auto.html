<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in_pcb.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in_pcb.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1991, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_pcb.c	8.4 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/in_pcb.c,v 1.59.2.17 2001/08/13 16:26:17 ume Exp $
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_uuid_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowhash.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/flowadv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> lck_grp_t	*inpcb_lock_grp;
<span class="enscript-type">static</span> lck_attr_t	*inpcb_lock_attr;
<span class="enscript-type">static</span> lck_grp_attr_t	*inpcb_lock_grp_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, inpcb_lock);		<span class="enscript-comment">/* global INPCB lock */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, inpcb_timeout_lock);

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, inpcbinfo) inpcb_head = TAILQ_HEAD_INITIALIZER(inpcb_head);

<span class="enscript-type">static</span> u_int16_t inpcb_timeout_run = 0;	<span class="enscript-comment">/* INPCB timer is scheduled to run */</span>
<span class="enscript-type">static</span> boolean_t inpcb_garbage_collecting = FALSE; <span class="enscript-comment">/* gc timer is scheduled */</span>
<span class="enscript-type">static</span> boolean_t inpcb_ticking = FALSE;		<span class="enscript-comment">/* &quot;slow&quot; timer is scheduled */</span>
<span class="enscript-type">static</span> boolean_t inpcb_fast_timer_on = FALSE;

<span class="enscript-comment">/*
 * If the total number of gc reqs is above a threshold, schedule
 * garbage collect timer sooner
 */</span>
<span class="enscript-type">static</span> boolean_t inpcb_toomany_gcreq = FALSE;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INPCB_GCREQ_THRESHOLD</span>	50000
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INPCB_TOOMANY_GCREQ_TIMER</span>	(hz/10) <span class="enscript-comment">/* 10 times a second */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inpcb_sched_timeout</span>(<span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inpcb_timeout</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> inpcb_timeout_lazy = 10;	<span class="enscript-comment">/* 10 seconds leeway for lazy timers */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tvtohz</span>(<span class="enscript-type">struct</span> timeval *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROC_UUID_POLICY</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inp_update_cellular_policy</span>(<span class="enscript-type">struct</span> inpcb *, boolean_t);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inp_update_necp_want_app_policy</span>(<span class="enscript-type">struct</span> inpcb *, boolean_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_PROC_UUID_POLICY */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_PCB_LOOKUP</span>	NETDBG_CODE(DBG_NETTCP, (6 &lt;&lt; 8))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_PCB_HLOOKUP</span>	NETDBG_CODE(DBG_NETTCP, ((6 &lt;&lt; 8) | 1))

<span class="enscript-comment">/*
 * These configure the range of local port addresses assigned to
 * &quot;unspecified&quot; outgoing connections/packets/whatever.
 */</span>
<span class="enscript-type">int</span>	ipport_lowfirstauto  = IPPORT_RESERVED - 1;	<span class="enscript-comment">/* 1023 */</span>
<span class="enscript-type">int</span>	ipport_lowlastauto = IPPORT_RESERVEDSTART;	<span class="enscript-comment">/* 600 */</span>
<span class="enscript-type">int</span>	ipport_firstauto = IPPORT_HIFIRSTAUTO;		<span class="enscript-comment">/* 49152 */</span>
<span class="enscript-type">int</span>	ipport_lastauto  = IPPORT_HILASTAUTO;		<span class="enscript-comment">/* 65535 */</span>
<span class="enscript-type">int</span>	ipport_hifirstauto = IPPORT_HIFIRSTAUTO;	<span class="enscript-comment">/* 49152 */</span>
<span class="enscript-type">int</span>	ipport_hilastauto  = IPPORT_HILASTAUTO;		<span class="enscript-comment">/* 65535 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RANGECHK</span>(var, min, max) \
	<span class="enscript-keyword">if</span> ((var) &lt; (min)) { (var) = (min); } \
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((var) &gt; (max)) { (var) = (max); }

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_net_ipport_check SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;

	error = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);
	<span class="enscript-keyword">if</span> (!error) {
		RANGECHK(ipport_lowfirstauto, 1, IPPORT_RESERVED - 1);
		RANGECHK(ipport_lowlastauto, 1, IPPORT_RESERVED - 1);
		RANGECHK(ipport_firstauto, IPPORT_RESERVED, USHRT_MAX);
		RANGECHK(ipport_lastauto, IPPORT_RESERVED, USHRT_MAX);
		RANGECHK(ipport_hifirstauto, IPPORT_RESERVED, USHRT_MAX);
		RANGECHK(ipport_hilastauto, IPPORT_RESERVED, USHRT_MAX);
	}
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">RANGECHK</span>

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_ip, IPPROTO_IP, portrange,
	CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;IP Ports&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, lowfirst,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_lowfirstauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, lowlast,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_lowlastauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, first,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_firstauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, last,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_lastauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, hifirst,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_hifirstauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip_portrange, OID_AUTO, hilast,
	CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipport_hilastauto, 0, &amp;sysctl_net_ipport_check, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	udp_use_randomport;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	tcp_use_randomport;

<span class="enscript-comment">/* Structs used for flowhash computation */</span>
<span class="enscript-type">struct</span> inp_flowhash_key_addr {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> in_addr	v4;
		<span class="enscript-type">struct</span> in6_addr v6;
		u_int8_t	addr8[16];
		u_int16_t	addr16[8];
		u_int32_t	addr32[4];
	} infha;
};

<span class="enscript-type">struct</span> inp_flowhash_key {
	<span class="enscript-type">struct</span> inp_flowhash_key_addr	infh_laddr;
	<span class="enscript-type">struct</span> inp_flowhash_key_addr	infh_faddr;
	u_int32_t			infh_lport;
	u_int32_t			infh_fport;
	u_int32_t			infh_af;
	u_int32_t			infh_proto;
	u_int32_t			infh_rand1;
	u_int32_t			infh_rand2;
};

<span class="enscript-type">static</span> u_int32_t inp_hash_seed = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">infc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *);

<span class="enscript-comment">/* Flags used by inp_fc_getinp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INPFC_SOLOCKED</span>	0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INPFC_REMOVE</span>	0x2
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> inpcb *<span class="enscript-function-name">inp_fc_getinp</span>(u_int32_t, u_int32_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inp_fc_feedback</span>(<span class="enscript-type">struct</span> inpcb *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_remove_from_time_wait</span>(<span class="enscript-type">struct</span> inpcb *inp);

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, inp_fc_lck);

<span class="enscript-function-name">RB_HEAD</span>(inp_fc_tree, inpcb) inp_fc_tree;
<span class="enscript-function-name">RB_PROTOTYPE</span>(inp_fc_tree, inpcb, infc_link, infc_cmp);
<span class="enscript-function-name">RB_GENERATE</span>(inp_fc_tree, inpcb, infc_link, infc_cmp);

<span class="enscript-comment">/*
 * Use this inp as a key to find an inp in the flowhash tree.
 * Accesses to it are protected by inp_fc_lck.
 */</span>
<span class="enscript-type">struct</span> inpcb key_inp;

<span class="enscript-comment">/*
 * in_pcb.c: manage the Protocol Control Blocks.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> inpcb_initialized = 0;

	VERIFY(!inpcb_initialized);
	inpcb_initialized = 1;

	inpcb_lock_grp_attr = lck_grp_attr_alloc_init();
	inpcb_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;inpcb&quot;</span>, inpcb_lock_grp_attr);
	inpcb_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;inpcb_lock, inpcb_lock_grp, inpcb_lock_attr);
	lck_mtx_init(&amp;inpcb_timeout_lock, inpcb_lock_grp, inpcb_lock_attr);

	<span class="enscript-comment">/*
	 * Initialize data structures required to deliver
	 * flow advisories.
	 */</span>
	lck_mtx_init(&amp;inp_fc_lck, inpcb_lock_grp, inpcb_lock_attr);
	lck_mtx_lock(&amp;inp_fc_lck);
	RB_INIT(&amp;inp_fc_tree);
	bzero(&amp;key_inp, <span class="enscript-keyword">sizeof</span>(key_inp));
	lck_mtx_unlock(&amp;inp_fc_lck);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">INPCB_HAVE_TIMER_REQ</span>(req)	(((req).intimer_lazy &gt; 0) || \
	((req).intimer_fast &gt; 0) || ((req).intimer_nodelay &gt; 0))
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_timeout</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> inpcbinfo *ipi;
	boolean_t t, gc;
	<span class="enscript-type">struct</span> intimercount gccnt, tmcnt;
	<span class="enscript-type">struct</span> timeval leeway;
	boolean_t toomany_gc = FALSE;

	<span class="enscript-keyword">if</span> (arg != NULL) {
		VERIFY(arg == &amp;inpcb_toomany_gcreq);
		toomany_gc = *(boolean_t *)arg;
	}

	<span class="enscript-comment">/*
	 * Update coarse-grained networking timestamp (in sec.); the idea
	 * is to piggy-back on the timeout callout to update the counter
	 * returnable via net_uptime().
	 */</span>
	net_update_uptime();

	bzero(&amp;gccnt, <span class="enscript-keyword">sizeof</span>(gccnt));
	bzero(&amp;tmcnt, <span class="enscript-keyword">sizeof</span>(tmcnt));

	lck_mtx_lock_spin(&amp;inpcb_timeout_lock);
	gc = inpcb_garbage_collecting;
	inpcb_garbage_collecting = FALSE;

	t = inpcb_ticking;
	inpcb_ticking = FALSE;

	<span class="enscript-keyword">if</span> (gc || t) {
		lck_mtx_unlock(&amp;inpcb_timeout_lock);

		lck_mtx_lock(&amp;inpcb_lock);
		TAILQ_FOREACH(ipi, &amp;inpcb_head, ipi_entry) {
			<span class="enscript-keyword">if</span> (INPCB_HAVE_TIMER_REQ(ipi-&gt;ipi_gc_req)) {
				bzero(&amp;ipi-&gt;ipi_gc_req,
					<span class="enscript-keyword">sizeof</span>(ipi-&gt;ipi_gc_req));
				<span class="enscript-keyword">if</span> (gc &amp;&amp; ipi-&gt;ipi_gc != NULL) {
					ipi-&gt;ipi_gc(ipi);
					gccnt.intimer_lazy +=
					    ipi-&gt;ipi_gc_req.intimer_lazy;
					gccnt.intimer_fast +=
					    ipi-&gt;ipi_gc_req.intimer_fast;
					gccnt.intimer_nodelay +=
					    ipi-&gt;ipi_gc_req.intimer_nodelay;
				}
			}
			<span class="enscript-keyword">if</span> (INPCB_HAVE_TIMER_REQ(ipi-&gt;ipi_timer_req)) {
				bzero(&amp;ipi-&gt;ipi_timer_req,
					<span class="enscript-keyword">sizeof</span>(ipi-&gt;ipi_timer_req));
				<span class="enscript-keyword">if</span> (t &amp;&amp; ipi-&gt;ipi_timer != NULL) {
					ipi-&gt;ipi_timer(ipi);
					tmcnt.intimer_lazy +=
					    ipi-&gt;ipi_timer_req.intimer_lazy;
					tmcnt.intimer_lazy +=
					    ipi-&gt;ipi_timer_req.intimer_fast;
					tmcnt.intimer_nodelay +=
					    ipi-&gt;ipi_timer_req.intimer_nodelay;
				}
			}
		}
		lck_mtx_unlock(&amp;inpcb_lock);
		lck_mtx_lock_spin(&amp;inpcb_timeout_lock);
	}

	<span class="enscript-comment">/* lock was dropped above, so check first before overriding */</span>
	<span class="enscript-keyword">if</span> (!inpcb_garbage_collecting)
		inpcb_garbage_collecting = INPCB_HAVE_TIMER_REQ(gccnt);
	<span class="enscript-keyword">if</span> (!inpcb_ticking)
		inpcb_ticking = INPCB_HAVE_TIMER_REQ(tmcnt);

	<span class="enscript-comment">/* re-arm the timer if there's work to do */</span>
	<span class="enscript-keyword">if</span> (toomany_gc) {
		inpcb_toomany_gcreq = FALSE;
	} <span class="enscript-keyword">else</span> {
		inpcb_timeout_run--;
		VERIFY(inpcb_timeout_run &gt;= 0 &amp;&amp; inpcb_timeout_run &lt; 2);
	}

	bzero(&amp;leeway, <span class="enscript-keyword">sizeof</span>(leeway));
	leeway.tv_sec = inpcb_timeout_lazy;
	<span class="enscript-keyword">if</span> (gccnt.intimer_nodelay &gt; 0 || tmcnt.intimer_nodelay &gt; 0)
		inpcb_sched_timeout(NULL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((gccnt.intimer_fast + tmcnt.intimer_fast) &lt;= 5)
		<span class="enscript-comment">/* be lazy when idle with little activity */</span>
		inpcb_sched_timeout(&amp;leeway);
	<span class="enscript-keyword">else</span>
		inpcb_sched_timeout(NULL);

	lck_mtx_unlock(&amp;inpcb_timeout_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_sched_timeout</span>(<span class="enscript-type">struct</span> timeval *leeway)
{
	lck_mtx_assert(&amp;inpcb_timeout_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (inpcb_timeout_run == 0 &amp;&amp;
		(inpcb_garbage_collecting || inpcb_ticking)) {
		lck_mtx_convert_spin(&amp;inpcb_timeout_lock);
		inpcb_timeout_run++;
		<span class="enscript-keyword">if</span> (leeway == NULL) {
			inpcb_fast_timer_on = TRUE;
			timeout(inpcb_timeout, NULL, hz);
		} <span class="enscript-keyword">else</span> {
			inpcb_fast_timer_on = FALSE;
			timeout_with_leeway(inpcb_timeout, NULL, hz,
				tvtohz(leeway));
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inpcb_timeout_run == 1 &amp;&amp;
		leeway == NULL &amp;&amp; !inpcb_fast_timer_on) {
		<span class="enscript-comment">/*
		 * Since the request was for a fast timer but the
		 * scheduled timer is a lazy timer, try to schedule
		 * another instance of fast timer also
		 */</span>
		lck_mtx_convert_spin(&amp;inpcb_timeout_lock);
		inpcb_timeout_run++;
		inpcb_fast_timer_on = TRUE;
		timeout(inpcb_timeout, NULL, hz);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_gc_sched</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi, u_int32_t type)
{
	<span class="enscript-type">struct</span> timeval leeway;
	u_int32_t gccnt;
	lck_mtx_lock_spin(&amp;inpcb_timeout_lock);
	inpcb_garbage_collecting = TRUE;

	gccnt = ipi-&gt;ipi_gc_req.intimer_nodelay +
		ipi-&gt;ipi_gc_req.intimer_fast;

	<span class="enscript-keyword">if</span> (gccnt &gt; INPCB_GCREQ_THRESHOLD &amp;&amp; !inpcb_toomany_gcreq) {
		inpcb_toomany_gcreq = TRUE;

		<span class="enscript-comment">/*
		 * There are toomany pcbs waiting to be garbage collected,
		 * schedule a much faster timeout in addition to
		 * the caller's request
		 */</span>
		lck_mtx_convert_spin(&amp;inpcb_timeout_lock);
		timeout(inpcb_timeout, (<span class="enscript-type">void</span> *)&amp;inpcb_toomany_gcreq,
		    INPCB_TOOMANY_GCREQ_TIMER);
	}

	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">INPCB_TIMER_NODELAY</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_nodelay, 1);
		inpcb_sched_timeout(NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">INPCB_TIMER_FAST</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_fast, 1);
		inpcb_sched_timeout(NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_gc_req.intimer_lazy, 1);
		leeway.tv_sec = inpcb_timeout_lazy;
		leeway.tv_usec = 0;
		inpcb_sched_timeout(&amp;leeway);
		<span class="enscript-keyword">break</span>;
	}
	lck_mtx_unlock(&amp;inpcb_timeout_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_timer_sched</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi, u_int32_t type)
{
	<span class="enscript-type">struct</span> timeval leeway;
	lck_mtx_lock_spin(&amp;inpcb_timeout_lock);
	inpcb_ticking = TRUE;
	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">INPCB_TIMER_NODELAY</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_timer_req.intimer_nodelay, 1);
		inpcb_sched_timeout(NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">INPCB_TIMER_FAST</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_timer_req.intimer_fast, 1);
		inpcb_sched_timeout(NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		atomic_add_32(&amp;ipi-&gt;ipi_timer_req.intimer_lazy, 1);
		leeway.tv_sec = inpcb_timeout_lazy;
		leeway.tv_usec = 0;
		inpcb_sched_timeout(&amp;leeway);
		<span class="enscript-keyword">break</span>;
	}
	lck_mtx_unlock(&amp;inpcb_timeout_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbinfo_attach</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi)
{
	<span class="enscript-type">struct</span> inpcbinfo *ipi0;

	lck_mtx_lock(&amp;inpcb_lock);
	TAILQ_FOREACH(ipi0, &amp;inpcb_head, ipi_entry) {
		<span class="enscript-keyword">if</span> (ipi0 == ipi) {
			panic(<span class="enscript-string">&quot;%s: ipi %p already in the list\n&quot;</span>,
			    __func__, ipi);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}
	TAILQ_INSERT_TAIL(&amp;inpcb_head, ipi, ipi_entry);
	lck_mtx_unlock(&amp;inpcb_lock);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcbinfo_detach</span>(<span class="enscript-type">struct</span> inpcbinfo *ipi)
{
	<span class="enscript-type">struct</span> inpcbinfo *ipi0;
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_lock(&amp;inpcb_lock);
	TAILQ_FOREACH(ipi0, &amp;inpcb_head, ipi_entry) {
		<span class="enscript-keyword">if</span> (ipi0 == ipi)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (ipi0 != NULL)
		TAILQ_REMOVE(&amp;inpcb_head, ipi0, ipi_entry);
	<span class="enscript-keyword">else</span>
		error = ENXIO;
	lck_mtx_unlock(&amp;inpcb_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Allocate a PCB and associate it with the socket.
 *
 * Returns:	0			Success
 *		ENOBUFS
 *		ENOMEM
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcballoc</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> inpcb *inp;
	caddr_t	temp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-type">int</span> mac_error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER) == 0) {
		inp = (<span class="enscript-type">struct</span> inpcb *)zalloc(pcbinfo-&gt;ipi_zone);
		<span class="enscript-keyword">if</span> (inp == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		bzero((caddr_t)inp, <span class="enscript-keyword">sizeof</span> (*inp));
	} <span class="enscript-keyword">else</span> {
		inp = (<span class="enscript-type">struct</span> inpcb *)(<span class="enscript-type">void</span> *)so-&gt;so_saved_pcb;
		temp = inp-&gt;inp_saved_ppcb;
		bzero((caddr_t)inp, <span class="enscript-keyword">sizeof</span> (*inp));
		inp-&gt;inp_saved_ppcb = temp;
	}

	inp-&gt;inp_gencnt = ++pcbinfo-&gt;ipi_gencnt;
	inp-&gt;inp_pcbinfo = pcbinfo;
	inp-&gt;inp_socket = so;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_error = mac_inpcb_label_init(inp, M_WAITOK);
	<span class="enscript-keyword">if</span> (mac_error != 0) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER) == 0)
			zfree(pcbinfo-&gt;ipi_zone, inp);
		<span class="enscript-keyword">return</span> (mac_error);
	}
	mac_inpcb_label_associate(so, inp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
	<span class="enscript-comment">/* make sure inp_stat is always 64-bit aligned */</span>
	inp-&gt;inp_stat = (<span class="enscript-type">struct</span> inp_stat *)P2ROUNDUP(inp-&gt;inp_stat_store,
	    <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">if</span> (((uintptr_t)inp-&gt;inp_stat - (uintptr_t)inp-&gt;inp_stat_store) +
	    <span class="enscript-keyword">sizeof</span> (*inp-&gt;inp_stat) &gt; <span class="enscript-keyword">sizeof</span> (inp-&gt;inp_stat_store)) {
		panic(<span class="enscript-string">&quot;%s: insufficient space to align inp_stat&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* make sure inp_cstat is always 64-bit aligned */</span>
	inp-&gt;inp_cstat = (<span class="enscript-type">struct</span> inp_stat *)P2ROUNDUP(inp-&gt;inp_cstat_store,
	    <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">if</span> (((uintptr_t)inp-&gt;inp_cstat - (uintptr_t)inp-&gt;inp_cstat_store) +
	    <span class="enscript-keyword">sizeof</span> (*inp-&gt;inp_cstat) &gt; <span class="enscript-keyword">sizeof</span> (inp-&gt;inp_cstat_store)) {
		panic(<span class="enscript-string">&quot;%s: insufficient space to align inp_cstat&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* make sure inp_wstat is always 64-bit aligned */</span>
	inp-&gt;inp_wstat = (<span class="enscript-type">struct</span> inp_stat *)P2ROUNDUP(inp-&gt;inp_wstat_store,
	    <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">if</span> (((uintptr_t)inp-&gt;inp_wstat - (uintptr_t)inp-&gt;inp_wstat_store) +
	    <span class="enscript-keyword">sizeof</span> (*inp-&gt;inp_wstat) &gt; <span class="enscript-keyword">sizeof</span> (inp-&gt;inp_wstat_store)) {
		panic(<span class="enscript-string">&quot;%s: insufficient space to align inp_wstat&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* make sure inp_Wstat is always 64-bit aligned */</span>
	inp-&gt;inp_Wstat = (<span class="enscript-type">struct</span> inp_stat *)P2ROUNDUP(inp-&gt;inp_Wstat_store,
	    <span class="enscript-keyword">sizeof</span> (u_int64_t));
	<span class="enscript-keyword">if</span> (((uintptr_t)inp-&gt;inp_Wstat - (uintptr_t)inp-&gt;inp_Wstat_store) +
	    <span class="enscript-keyword">sizeof</span> (*inp-&gt;inp_Wstat) &gt; <span class="enscript-keyword">sizeof</span> (inp-&gt;inp_Wstat_store)) {
		panic(<span class="enscript-string">&quot;%s: insufficient space to align inp_Wstat&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	
	so-&gt;so_pcb = (caddr_t)inp;

	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_flags &amp; PR_PCBLOCK) {
		lck_mtx_init(&amp;inp-&gt;inpcb_mtx, pcbinfo-&gt;ipi_lock_grp,
		    pcbinfo-&gt;ipi_lock_attr);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET6 &amp;&amp; !ip6_mapped_addr_on)
		inp-&gt;inp_flags |= IN6P_IPV6_V6ONLY;

	<span class="enscript-keyword">if</span> (ip6_auto_flowlabel)
		inp-&gt;inp_flags |= IN6P_AUTOFLOWLABEL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	(<span class="enscript-type">void</span>) inp_update_policy(inp);

	lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);
	inp-&gt;inp_gencnt = ++pcbinfo-&gt;ipi_gencnt;
	LIST_INSERT_HEAD(pcbinfo-&gt;ipi_listhead, inp, inp_list);
	pcbinfo-&gt;ipi_count++;
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * in_pcblookup_local_and_cleanup does everything
 * in_pcblookup_local does but it checks for a socket
 * that's going away. Since we know that the lock is
 * held read+write when this funciton is called, we
 * can safely dispose of this socket like the slow
 * timer would usually do and return NULL. This is
 * great for bind.
 */</span>
<span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in_pcblookup_local_and_cleanup</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in_addr laddr,
    u_int lport_arg, <span class="enscript-type">int</span> wild_okay)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	<span class="enscript-comment">/* Perform normal lookup */</span>
	inp = in_pcblookup_local(pcbinfo, laddr, lport_arg, wild_okay);

	<span class="enscript-comment">/* Check if we found a match but it's waiting to be disposed */</span>
	<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; inp-&gt;inp_wantcnt == WNT_STOPUSING) {
		<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

		lck_mtx_lock(&amp;inp-&gt;inpcb_mtx);

		<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD)
				in_pcbdetach(inp);
			in_pcbdispose(inp);	<span class="enscript-comment">/* will unlock &amp; destroy */</span>
			inp = NULL;
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
		}
	}

	<span class="enscript-keyword">return</span> (inp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcb_conflict_post_msg</span>(u_int16_t port)
{
	<span class="enscript-comment">/*
	 * Radar 5523020 send a kernel event notification if a
	 * non-participating socket tries to bind the port a socket
	 * who has set SOF_NOTIFYCONFLICT owns.
	 */</span>
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> kev_in_portinuse	in_portinuse;

	bzero(&amp;in_portinuse, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_in_portinuse));
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));
	in_portinuse.port = ntohs(port);	<span class="enscript-comment">/* port in host order */</span>
	in_portinuse.req_pid = proc_selfpid();
	ev_msg.vendor_code = KEV_VENDOR_APPLE;
	ev_msg.kev_class = KEV_NETWORK_CLASS;
	ev_msg.kev_subclass = KEV_INET_SUBCLASS;
	ev_msg.event_code = KEV_INET_PORTINUSE;
	ev_msg.dv[0].data_ptr = &amp;in_portinuse;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_in_portinuse);
	ev_msg.dv[1].data_length = 0;
	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-comment">/*
 * Bind an INPCB to an address and/or port.  This routine should not alter
 * the caller-supplied local address &quot;nam&quot;.
 *
 * Returns:	0			Success
 *		EADDRNOTAVAIL		Address not available.
 *		EINVAL			Invalid argument
 *		EAFNOSUPPORT		Address family not supported [notdef]
 *		EACCES			Permission denied
 *		EADDRINUSE		Address in use
 *		EAGAIN			Resource unavailable, try again
 *		priv_check_cred:EPERM	Operation not permitted
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcbbind</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> *lastport;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = inp-&gt;inp_pcbinfo;
	u_short lport = 0, rand_port = 0;
	<span class="enscript-type">int</span> wild = 0, reuseport = (so-&gt;so_options &amp; SO_REUSEPORT);
	<span class="enscript-type">int</span> error, randomport, conflict = 0;
	boolean_t anonport = FALSE;
	kauth_cred_t cred;
	<span class="enscript-type">struct</span> in_addr laddr;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;in_ifaddrhead)) <span class="enscript-comment">/* XXX broken! */</span>
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport != 0 || inp-&gt;inp_laddr.s_addr != INADDR_ANY)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (!(so-&gt;so_options &amp; (SO_REUSEADDR|SO_REUSEPORT)))
		wild = 1;
	socket_unlock(so, 0); <span class="enscript-comment">/* keep reference on socket */</span>
	lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);

	bzero(&amp;laddr, <span class="enscript-keyword">sizeof</span>(laddr));

	<span class="enscript-keyword">if</span> (nam != NULL) {

		<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in)) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
#<span class="enscript-reference">if</span> 0
		<span class="enscript-comment">/*
		 * We should check the family, but old programs
		 * incorrectly fail to initialize it.
		 */</span>
		<span class="enscript-keyword">if</span> (nam-&gt;sa_family != AF_INET) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
			<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
		lport = SIN(nam)-&gt;sin_port;

		<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(SIN(nam)-&gt;sin_addr.s_addr))) {
			<span class="enscript-comment">/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow complete duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_REUSEADDR)
				reuseport = SO_REUSEADDR|SO_REUSEPORT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_addr.s_addr != INADDR_ANY) {
			<span class="enscript-type">struct</span> sockaddr_in sin;
			<span class="enscript-type">struct</span> ifaddr *ifa;

			<span class="enscript-comment">/* Sanitized for interface address searches */</span>
			bzero(&amp;sin, <span class="enscript-keyword">sizeof</span> (sin));
			sin.sin_family = AF_INET;
			sin.sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
			sin.sin_addr.s_addr = SIN(nam)-&gt;sin_addr.s_addr;

			ifa = ifa_ifwithaddr(SA(&amp;sin));
			<span class="enscript-keyword">if</span> (ifa == NULL) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				socket_lock(so, 0);
				<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Opportunistically determine the outbound
				 * interface that may be used; this may not
				 * hold true if we end up using a route
				 * going over a different interface, e.g.
				 * when sending to a local address.  This
				 * will get updated again after sending.
				 */</span>
				IFA_LOCK(ifa);
				outif = ifa-&gt;ifa_ifp;
				IFA_UNLOCK(ifa);
				IFA_REMREF(ifa);
			}
		}
		<span class="enscript-keyword">if</span> (lport != 0) {
			<span class="enscript-type">struct</span> inpcb *t;
			uid_t u;

			<span class="enscript-keyword">if</span> (ntohs(lport) &lt; IPPORT_RESERVED) {
				cred = kauth_cred_proc_ref(p);
				error = priv_check_cred(cred,
				    PRIV_NETINET_RESERVEDPORT, 0);
				kauth_cred_unref(&amp;cred);
				<span class="enscript-keyword">if</span> (error != 0) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EACCES);
				}
			}
			<span class="enscript-keyword">if</span> (!IN_MULTICAST(ntohl(SIN(nam)-&gt;sin_addr.s_addr)) &amp;&amp;
			    (u = kauth_cred_getuid(so-&gt;so_cred)) != 0 &amp;&amp;
			    (t = in_pcblookup_local_and_cleanup(
			    inp-&gt;inp_pcbinfo, SIN(nam)-&gt;sin_addr, lport,
			    INPLOOKUP_WILDCARD)) != NULL &amp;&amp;
			    (SIN(nam)-&gt;sin_addr.s_addr != INADDR_ANY ||
			    t-&gt;inp_laddr.s_addr != INADDR_ANY ||
			    !(t-&gt;inp_socket-&gt;so_options &amp; SO_REUSEPORT)) &amp;&amp;
			    (u != kauth_cred_getuid(t-&gt;inp_socket-&gt;so_cred)) &amp;&amp;
			    !(t-&gt;inp_socket-&gt;so_flags &amp; SOF_REUSESHAREUID) &amp;&amp;
			    (SIN(nam)-&gt;sin_addr.s_addr != INADDR_ANY ||
			    t-&gt;inp_laddr.s_addr != INADDR_ANY)) {
				<span class="enscript-keyword">if</span> ((t-&gt;inp_socket-&gt;so_flags &amp;
				    SOF_NOTIFYCONFLICT) &amp;&amp;
				    !(so-&gt;so_flags &amp; SOF_NOTIFYCONFLICT))
					conflict = 1;

				lck_rw_done(pcbinfo-&gt;ipi_lock);

				<span class="enscript-keyword">if</span> (conflict)
					in_pcb_conflict_post_msg(lport);

				socket_lock(so, 0);
				<span class="enscript-keyword">return</span> (EADDRINUSE);
			}
			t = in_pcblookup_local_and_cleanup(pcbinfo,
			    SIN(nam)-&gt;sin_addr, lport, wild);
			<span class="enscript-keyword">if</span> (t != NULL &amp;&amp;
			    (reuseport &amp; t-&gt;inp_socket-&gt;so_options) == 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_addr.s_addr != INADDR_ANY ||
				    t-&gt;inp_laddr.s_addr != INADDR_ANY ||
				    SOCK_DOM(so) != PF_INET6 ||
				    SOCK_DOM(t-&gt;inp_socket) != PF_INET6)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				{

					<span class="enscript-keyword">if</span> ((t-&gt;inp_socket-&gt;so_flags &amp;
					    SOF_NOTIFYCONFLICT) &amp;&amp;
					    !(so-&gt;so_flags &amp; SOF_NOTIFYCONFLICT))
						conflict = 1;

					lck_rw_done(pcbinfo-&gt;ipi_lock);

					<span class="enscript-keyword">if</span> (conflict)
						in_pcb_conflict_post_msg(lport);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRINUSE);
				}
			}
		}
		laddr = SIN(nam)-&gt;sin_addr;
	}
	<span class="enscript-keyword">if</span> (lport == 0) {
		u_short first, last;
		<span class="enscript-type">int</span> count;

		randomport = (so-&gt;so_flags &amp; SOF_BINDRANDOMPORT) ||
		    (so-&gt;so_type == SOCK_STREAM ? tcp_use_randomport :
		    udp_use_randomport);

		<span class="enscript-comment">/*
		 * Even though this looks similar to the code in
		 * in6_pcbsetport, the v6 vs v4 checks are different.
		 */</span>
		anonport = TRUE;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_HIGHPORT) {
			first = ipport_hifirstauto;	<span class="enscript-comment">/* sysctl */</span>
			last  = ipport_hilastauto;
			lastport = &amp;pcbinfo-&gt;ipi_lasthi;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_LOWPORT) {
			cred = kauth_cred_proc_ref(p);
			error = priv_check_cred(cred,
			    PRIV_NETINET_RESERVEDPORT, 0);
			kauth_cred_unref(&amp;cred);
			<span class="enscript-keyword">if</span> (error != 0) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				socket_lock(so, 0);
				<span class="enscript-keyword">return</span> (error);
			}
			first = ipport_lowfirstauto;	<span class="enscript-comment">/* 1023 */</span>
			last  = ipport_lowlastauto;	<span class="enscript-comment">/* 600 */</span>
			lastport = &amp;pcbinfo-&gt;ipi_lastlow;
		} <span class="enscript-keyword">else</span> {
			first = ipport_firstauto;	<span class="enscript-comment">/* sysctl */</span>
			last  = ipport_lastauto;
			lastport = &amp;pcbinfo-&gt;ipi_lastport;
		}
		<span class="enscript-comment">/* No point in randomizing if only one port is available */</span>

		<span class="enscript-keyword">if</span> (first == last)
			randomport = 0;
		<span class="enscript-comment">/*
		 * Simple check to ensure all ports are not used up causing
		 * a deadlock here.
		 *
		 * We split the two cases (up and down) so that the direction
		 * is not being tested on each round of the loop.
		 */</span>
		<span class="enscript-keyword">if</span> (first &gt; last) {
			<span class="enscript-comment">/*
			 * counting down
			 */</span>
			<span class="enscript-keyword">if</span> (randomport) {
				read_random(&amp;rand_port, <span class="enscript-keyword">sizeof</span> (rand_port));
				*lastport =
				    first - (rand_port % (first - last));
			}
			count = first - last;

			<span class="enscript-keyword">do</span> {
				<span class="enscript-keyword">if</span> (count-- &lt; 0) {	<span class="enscript-comment">/* completely used? */</span>
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
				}
				--*lastport;
				<span class="enscript-keyword">if</span> (*lastport &gt; first || *lastport &lt; last)
					*lastport = first;
				lport = htons(*lastport);
			} <span class="enscript-keyword">while</span> (in_pcblookup_local_and_cleanup(pcbinfo,
			    ((laddr.s_addr != INADDR_ANY) ? laddr : 
			    inp-&gt;inp_laddr), lport, wild));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * counting up
			 */</span>
			<span class="enscript-keyword">if</span> (randomport) {
				read_random(&amp;rand_port, <span class="enscript-keyword">sizeof</span> (rand_port));
				*lastport =
				    first + (rand_port % (first - last));
			}
			count = last - first;

			<span class="enscript-keyword">do</span> {
				<span class="enscript-keyword">if</span> (count-- &lt; 0) {	<span class="enscript-comment">/* completely used? */</span>
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
				}
				++*lastport;
				<span class="enscript-keyword">if</span> (*lastport &lt; first || *lastport &gt; last)
					*lastport = first;
				lport = htons(*lastport);
			} <span class="enscript-keyword">while</span> (in_pcblookup_local_and_cleanup(pcbinfo,
			    ((laddr.s_addr != INADDR_ANY) ? laddr :
			    inp-&gt;inp_laddr), lport, wild));
		}
	}
	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport != 0 || inp-&gt;inp_laddr.s_addr != INADDR_ANY) {
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (laddr.s_addr != INADDR_ANY) {
		inp-&gt;inp_laddr = laddr;
		inp-&gt;inp_last_outifp = outif;
	}
	inp-&gt;inp_lport = lport;
	<span class="enscript-keyword">if</span> (anonport)
		inp-&gt;inp_flags |= INP_ANONPORT;

	<span class="enscript-keyword">if</span> (in_pcbinshash(inp, 1) != 0) {
		inp-&gt;inp_laddr.s_addr = INADDR_ANY;
		inp-&gt;inp_last_outifp = NULL;

		inp-&gt;inp_lport = 0;
		<span class="enscript-keyword">if</span> (anonport)
			inp-&gt;inp_flags &amp;= ~INP_ANONPORT;
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	sflt_notify(so, sock_evt_bound, NULL);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Transform old in_pcbconnect() into an inner subroutine for new
 * in_pcbconnect(); do some validity-checking on the remote address
 * (in &quot;nam&quot;) and then determine local host address (i.e., which
 * interface) to use to access that remote host.
 *
 * This routine may alter the caller-supplied remote address &quot;nam&quot;.
 *
 * The caller may override the bound-to-interface setting of the socket
 * by specifying the ifscope parameter (e.g. from IP_PKTINFO.)
 *
 * This routine might return an ifp with a reference held if the caller
 * provides a non-NULL outif, even in the error case.  The caller is
 * responsible for releasing its reference.
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *		EAFNOSUPPORT		Address family not supported
 *		EADDRNOTAVAIL		Address not available
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcbladdr</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> in_addr *laddr,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope, <span class="enscript-type">struct</span> ifnet **outif)
{
	<span class="enscript-type">struct</span> route *ro = &amp;inp-&gt;inp_route;
	<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;
	<span class="enscript-type">struct</span> sockaddr_in sin;
	<span class="enscript-type">int</span> error = 0;
	boolean_t restricted = FALSE;

	<span class="enscript-keyword">if</span> (outif != NULL)
		*outif = NULL;
	<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_family != AF_INET)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
	<span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_port == 0)
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);

	<span class="enscript-comment">/*
	 * If the destination address is INADDR_ANY,
	 * use the primary local address.
	 * If the supplied address is INADDR_BROADCAST,
	 * and the primary interface supports broadcast,
	 * choose the broadcast address for that interface.
	 */</span>
	<span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_addr.s_addr == INADDR_ANY ||
	    SIN(nam)-&gt;sin_addr.s_addr == (u_int32_t)INADDR_BROADCAST) {
		lck_rw_lock_shared(in_ifaddr_rwlock);
		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;in_ifaddrhead)) {
			ia = TAILQ_FIRST(&amp;in_ifaddrhead);
			IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (SIN(nam)-&gt;sin_addr.s_addr == INADDR_ANY) {
				SIN(nam)-&gt;sin_addr = IA_SIN(ia)-&gt;sin_addr;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ia-&gt;ia_ifp-&gt;if_flags &amp; IFF_BROADCAST) {
				SIN(nam)-&gt;sin_addr =
				    SIN(&amp;ia-&gt;ia_broadaddr)-&gt;sin_addr;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			ia = NULL;
		}
		lck_rw_done(in_ifaddr_rwlock);
	}
	<span class="enscript-comment">/*
	 * Otherwise, if the socket has already bound the source, just use it.
	 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY) {
		VERIFY(ia == NULL);
		*laddr = inp-&gt;inp_laddr;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * If the ifscope is specified by the caller (e.g. IP_PKTINFO)
	 * then it overrides the sticky ifscope set for the socket.
	 */</span>
	<span class="enscript-keyword">if</span> (ifscope == IFSCOPE_NONE &amp;&amp; (inp-&gt;inp_flags &amp; INP_BOUND_IF))
		ifscope = inp-&gt;inp_boundifp-&gt;if_index;

	<span class="enscript-comment">/*
	 * If route is known or can be allocated now,
	 * our src addr is taken from the i/f, else punt.
	 * Note that we should check the address family of the cached
	 * destination, in case of sharing the cache with IPv6.
	 */</span>
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_LOCK_SPIN(ro-&gt;ro_rt);
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) || ro-&gt;ro_dst.sa_family != AF_INET ||
	    SIN(&amp;ro-&gt;ro_dst)-&gt;sin_addr.s_addr != SIN(nam)-&gt;sin_addr.s_addr ||
	    (inp-&gt;inp_socket-&gt;so_options &amp; SO_DONTROUTE)) {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);
		ROUTE_RELEASE(ro);
	}
	<span class="enscript-keyword">if</span> (!(inp-&gt;inp_socket-&gt;so_options &amp; SO_DONTROUTE) &amp;&amp;
	    (ro-&gt;ro_rt == NULL || ro-&gt;ro_rt-&gt;rt_ifp == NULL)) {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);
		ROUTE_RELEASE(ro);
		<span class="enscript-comment">/* No route yet, so try to acquire one */</span>
		bzero(&amp;ro-&gt;ro_dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in));
		ro-&gt;ro_dst.sa_family = AF_INET;
		ro-&gt;ro_dst.sa_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
		SIN(&amp;ro-&gt;ro_dst)-&gt;sin_addr = SIN(nam)-&gt;sin_addr;
		rtalloc_scoped(ro, ifscope);
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_LOCK_SPIN(ro-&gt;ro_rt);
	}
	<span class="enscript-comment">/* Sanitized local copy for interface address searches */</span>
	bzero(&amp;sin, <span class="enscript-keyword">sizeof</span> (sin));
	sin.sin_family = AF_INET;
	sin.sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
	sin.sin_addr.s_addr = SIN(nam)-&gt;sin_addr.s_addr;
	<span class="enscript-comment">/*
	 * If we did not find (or use) a route, assume dest is reachable
	 * on a directly connected network and try to find a corresponding
	 * interface to take the source address from.
	 */</span>
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
		VERIFY(ia == NULL);
		ia = ifatoia(ifa_ifwithdstaddr(SA(&amp;sin)));
		<span class="enscript-keyword">if</span> (ia == NULL)
			ia = ifatoia(ifa_ifwithnet_scoped(SA(&amp;sin), ifscope));
		error = ((ia == NULL) ? ENETUNREACH : 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	RT_LOCK_ASSERT_HELD(ro-&gt;ro_rt);
	<span class="enscript-comment">/*
	 * If the outgoing interface on the route found is not
	 * a loopback interface, use the address from that interface.
	 */</span>
	<span class="enscript-keyword">if</span> (!(ro-&gt;ro_rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
		VERIFY(ia == NULL);
		<span class="enscript-comment">/*
		 * If the route points to a cellular interface and the
		 * caller forbids our using interfaces of such type,
		 * pretend that there is no route.
		 * Apply the same logic for expensive interfaces.
		 */</span>
		<span class="enscript-keyword">if</span> (inp_restricted_send(inp, ro-&gt;ro_rt-&gt;rt_ifp)) {
			RT_UNLOCK(ro-&gt;ro_rt);
			ROUTE_RELEASE(ro);
			error = EHOSTUNREACH;
			restricted = TRUE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(ro-&gt;ro_rt);
			ia = ifatoia(ro-&gt;ro_rt-&gt;rt_ifa);
			IFA_ADDREF(&amp;ia-&gt;ia_ifa);
			RT_UNLOCK(ro-&gt;ro_rt);
			error = 0;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	VERIFY(ro-&gt;ro_rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK);
	RT_UNLOCK(ro-&gt;ro_rt);
	<span class="enscript-comment">/*
	 * The outgoing interface is marked with 'loopback net', so a route
	 * to ourselves is here.
	 * Try to find the interface of the destination address and then
	 * take the address from there. That interface is not necessarily
	 * a loopback interface.
	 */</span>
	VERIFY(ia == NULL);
	ia = ifatoia(ifa_ifwithdstaddr(SA(&amp;sin)));
	<span class="enscript-keyword">if</span> (ia == NULL)
		ia = ifatoia(ifa_ifwithaddr_scoped(SA(&amp;sin), ifscope));
	<span class="enscript-keyword">if</span> (ia == NULL)
		ia = ifatoia(ifa_ifwithnet_scoped(SA(&amp;sin), ifscope));
	<span class="enscript-keyword">if</span> (ia == NULL) {
		RT_LOCK(ro-&gt;ro_rt);
		ia = ifatoia(ro-&gt;ro_rt-&gt;rt_ifa);
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_ADDREF(&amp;ia-&gt;ia_ifa);
		RT_UNLOCK(ro-&gt;ro_rt);
	}
	error = ((ia == NULL) ? ENETUNREACH : 0);

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * If the destination address is multicast and an outgoing
	 * interface has been set as a multicast option, use the
	 * address of that interface as our source address.
	 */</span>
	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(SIN(nam)-&gt;sin_addr.s_addr)) &amp;&amp;
	    inp-&gt;inp_moptions != NULL) {
		<span class="enscript-type">struct</span> ip_moptions *imo;
		<span class="enscript-type">struct</span> ifnet *ifp;

		imo = inp-&gt;inp_moptions;
		IMO_LOCK(imo);
		<span class="enscript-keyword">if</span> (imo-&gt;imo_multicast_ifp != NULL &amp;&amp; (ia == NULL ||
		    ia-&gt;ia_ifp != imo-&gt;imo_multicast_ifp)) {
			ifp = imo-&gt;imo_multicast_ifp;
			<span class="enscript-keyword">if</span> (ia != NULL)
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
			lck_rw_lock_shared(in_ifaddr_rwlock);
			TAILQ_FOREACH(ia, &amp;in_ifaddrhead, ia_link) {
				<span class="enscript-keyword">if</span> (ia-&gt;ia_ifp == ifp)
					<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (ia != NULL)
				IFA_ADDREF(&amp;ia-&gt;ia_ifa);
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">if</span> (ia == NULL)
				error = EADDRNOTAVAIL;
			<span class="enscript-keyword">else</span>
				error = 0;
		}
		IMO_UNLOCK(imo);
	}
	<span class="enscript-comment">/*
	 * Don't do pcblookup call here; return interface in laddr
	 * and exit to caller, that will do the lookup.
	 */</span>
	<span class="enscript-keyword">if</span> (ia != NULL) {
		<span class="enscript-comment">/*
		 * If the source address belongs to a cellular interface
		 * and the socket forbids our using interfaces of such
		 * type, pretend that there is no source address.
		 * Apply the same logic for expensive interfaces.
		 */</span>
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (inp_restricted_send(inp, ia-&gt;ia_ifa.ifa_ifp)) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			error = EHOSTUNREACH;
			restricted = TRUE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0) {
			*laddr = ia-&gt;ia_addr.sin_addr;
			<span class="enscript-keyword">if</span> (outif != NULL) {
				<span class="enscript-type">struct</span> ifnet *ifp;

				<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
					ifp = ro-&gt;ro_rt-&gt;rt_ifp;
				<span class="enscript-keyword">else</span>
					ifp = ia-&gt;ia_ifp;

				VERIFY(ifp != NULL);
				IFA_CONVERT_LOCK(&amp;ia-&gt;ia_ifa);
				ifnet_reference(ifp);	<span class="enscript-comment">/* for caller */</span>
				<span class="enscript-keyword">if</span> (*outif != NULL)
					ifnet_release(*outif);
				*outif = ifp;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
		ia = NULL;
	}

	<span class="enscript-keyword">if</span> (restricted &amp;&amp; error == EHOSTUNREACH) {
		soevent(inp-&gt;inp_socket, (SO_FILT_HINT_LOCKED |
		    SO_FILT_HINT_IFDENIED));
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Outer subroutine:
 * Connect from a socket to a specified address.
 * Both address and port must be specified in argument sin.
 * If don't have a local address for this socket yet,
 * then pick one.
 *
 * The caller may override the bound-to-interface setting of the socket
 * by specifying the ifscope parameter (e.g. from IP_PKTINFO.)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcbconnect</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope, <span class="enscript-type">struct</span> ifnet **outif)
{
	<span class="enscript-type">struct</span> in_addr laddr;
	<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-type">struct</span> inpcb *pcb;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-comment">/*
	 *   Call inner routine, to assign local interface address.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = in_pcbladdr(inp, nam, &amp;laddr, ifscope, outif)) != 0)
		<span class="enscript-keyword">return</span> (error);

	socket_unlock(so, 0);
	pcb = in_pcblookup_hash(inp-&gt;inp_pcbinfo, sin-&gt;sin_addr, sin-&gt;sin_port,
	    inp-&gt;inp_laddr.s_addr ? inp-&gt;inp_laddr : laddr,
	    inp-&gt;inp_lport, 0, NULL);
	socket_lock(so, 0);

	<span class="enscript-comment">/*
	 * Check if the socket is still in a valid state. When we unlock this
	 * embryonic socket, it can get aborted if another thread is closing
	 * the listener (radar 7947600).
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_ABORTED) != 0)
		<span class="enscript-keyword">return</span> (ECONNREFUSED);

	<span class="enscript-keyword">if</span> (pcb != NULL) {
		in_pcb_checkstate(pcb, WNT_RELEASE, pcb == inp ? 1 : 0);
		<span class="enscript-keyword">return</span> (EADDRINUSE);
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == INADDR_ANY) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0) {
			error = in_pcbbind(inp, NULL, p);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
			<span class="enscript-comment">/*
			 * Lock inversion issue, mostly with udp
			 * multicast packets.
			 */</span>
			socket_unlock(so, 0);
			lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
		}
		inp-&gt;inp_laddr = laddr;
		<span class="enscript-comment">/* no reference needed */</span>
		inp-&gt;inp_last_outifp = (outif != NULL) ? *outif : NULL;
		inp-&gt;inp_flags |= INP_INADDR_ANY;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Usage of IP_PKTINFO, without local port already
		 * speficified will cause kernel to panic,
		 * see rdar://problem/18508185.
		 * For now returning error to avoid a kernel panic
		 * This routines can be refactored and handle this better
		 * in future.
		 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
			<span class="enscript-comment">/*
			 * Lock inversion issue, mostly with udp
			 * multicast packets.
			 */</span>
			socket_unlock(so, 0);
			lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
		}
	}
	inp-&gt;inp_faddr = sin-&gt;sin_addr;
	inp-&gt;inp_fport = sin-&gt;sin_port;
	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp; SOCK_PROTO(so) == IPPROTO_UDP)
		nstat_pcb_invalidate_cache(inp);
	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbdisconnect</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp; SOCK_PROTO(so) == IPPROTO_UDP)
		nstat_pcb_cache(inp);

	inp-&gt;inp_faddr.s_addr = INADDR_ANY;
	inp-&gt;inp_fport = 0;

	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
		<span class="enscript-comment">/* lock inversion issue, mostly with udp multicast packets */</span>
		socket_unlock(so, 0);
		lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
		socket_lock(so, 0);
	}

	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
	<span class="enscript-comment">/*
	 * A multipath subflow socket would have its SS_NOFDREF set by default,
	 * so check for SOF_MP_SUBFLOW socket flag before detaching the PCB;
	 * when the socket is closed for real, SOF_MP_SUBFLOW would be cleared.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp; (so-&gt;so_state &amp; SS_NOFDREF))
		in_pcbdetach(inp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbdetach</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		<span class="enscript-comment">/* PCB has been disposed */</span>
		panic(<span class="enscript-string">&quot;%s: inp=%p so=%p proto=%d so_pcb is null!\n&quot;</span>, __func__,
		    inp, so, SOCK_PROTO(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp != NULL) {
		(<span class="enscript-type">void</span>) ipsec4_delete_pcbpolicy(inp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	
	<span class="enscript-comment">/*
	 * Let NetworkStatistics know this PCB is going away
	 * before we detach it.
	 */</span>
	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp; 
	    (SOCK_PROTO(so) == IPPROTO_TCP || SOCK_PROTO(so) == IPPROTO_UDP))
		nstat_pcb_detach(inp);

	<span class="enscript-comment">/* Free memory buffer held for generating keep alives */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_keepalive_data != NULL) {
		FREE(inp-&gt;inp_keepalive_data, M_TEMP);
		inp-&gt;inp_keepalive_data = NULL;
	}

	<span class="enscript-comment">/* mark socket state as dead */</span>
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_STOPUSING, 1) != WNT_STOPUSING) {
		panic(<span class="enscript-string">&quot;%s: so=%p proto=%d couldn't set to STOPUSING\n&quot;</span>,
		    __func__, so, SOCK_PROTO(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) {
		<span class="enscript-type">struct</span> ip_moptions *imo;

		inp-&gt;inp_vflag = 0;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_options != NULL) {
			(<span class="enscript-type">void</span>) m_free(inp-&gt;inp_options);
			inp-&gt;inp_options = NULL;
		}
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
		imo = inp-&gt;inp_moptions;
		inp-&gt;inp_moptions = NULL;
		<span class="enscript-keyword">if</span> (imo != NULL)
			IMO_REMREF(imo);
		sofreelastref(so, 0);
		inp-&gt;inp_state = INPCB_STATE_DEAD;
		<span class="enscript-comment">/* makes sure we're not called twice from so_close */</span>
		so-&gt;so_flags |= SOF_PCBCLEARING;

		inpcb_gc_sched(inp-&gt;inp_pcbinfo, INPCB_TIMER_FAST);
	}
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbdispose</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">struct</span> inpcbinfo *ipi = inp-&gt;inp_pcbinfo;

	<span class="enscript-keyword">if</span> (so != NULL &amp;&amp; so-&gt;so_usecount != 0) {
		panic(<span class="enscript-string">&quot;%s: so %p [%d,%d] usecount %d lockhistory %s\n&quot;</span>,
		    __func__, so, SOCK_DOM(so), SOCK_TYPE(so), so-&gt;so_usecount,
		    solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_wantcnt != WNT_STOPUSING) {
		<span class="enscript-keyword">if</span> (so != NULL) {
			panic_plain(<span class="enscript-string">&quot;%s: inp %p invalid wantcnt %d, so %p &quot;</span>
			    <span class="enscript-string">&quot;[%d,%d] usecount %d retaincnt %d state 0x%x &quot;</span>
			    <span class="enscript-string">&quot;flags 0x%x lockhistory %s\n&quot;</span>, __func__, inp,
			    inp-&gt;inp_wantcnt, so, SOCK_DOM(so), SOCK_TYPE(so),
			    so-&gt;so_usecount, so-&gt;so_retaincnt, so-&gt;so_state,
			    so-&gt;so_flags, solockhistory_nr(so));
			<span class="enscript-comment">/* NOTREACHED */</span>
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;%s: inp %p invalid wantcnt %d no socket\n&quot;</span>,
			    __func__, inp, inp-&gt;inp_wantcnt);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}

	lck_rw_assert(ipi-&gt;ipi_lock, LCK_RW_ASSERT_EXCLUSIVE);

	inp-&gt;inp_gencnt = ++ipi-&gt;ipi_gencnt;
	<span class="enscript-comment">/* access ipi in in_pcbremlists */</span>
	in_pcbremlists(inp);

	<span class="enscript-keyword">if</span> (so != NULL) {
		<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_flags &amp; PR_PCBLOCK) {
			sofreelastref(so, 0);
			<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_cc &gt; 0 || so-&gt;so_snd.sb_cc &gt; 0) {
				<span class="enscript-comment">/*
				 * selthreadclear() already called
				 * during sofreelastref() above.
				 */</span>
				sbrelease(&amp;so-&gt;so_rcv);
				sbrelease(&amp;so-&gt;so_snd);
			}
			<span class="enscript-keyword">if</span> (so-&gt;so_head != NULL) {
				panic(<span class="enscript-string">&quot;%s: so=%p head still exist\n&quot;</span>,
				    __func__, so);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
			lck_mtx_destroy(&amp;inp-&gt;inpcb_mtx, ipi-&gt;ipi_lock_grp);
		}
		<span class="enscript-comment">/* makes sure we're not called twice from so_close */</span>
		so-&gt;so_flags |= SOF_PCBCLEARING;
		so-&gt;so_saved_pcb = (caddr_t)inp;
		so-&gt;so_pcb = NULL;
		inp-&gt;inp_socket = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		mac_inpcb_label_destroy(inp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
		<span class="enscript-comment">/*
		 * In case there a route cached after a detach (possible
		 * in the tcp case), make sure that it is freed before
		 * we deallocate the structure.
		 */</span>
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
		<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER) == 0) {
			zfree(ipi-&gt;ipi_zone, inp);
		}
		sodealloc(so);
	}
}

<span class="enscript-comment">/*
 * The calling convention of in_getsockaddr() and in_getpeeraddr() was
 * modified to match the pru_sockaddr() and pru_peeraddr() entry points
 * in struct pr_usrreqs, so that protocols can just reference then directly
 * without the need for a wrapper function.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_getsockaddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> sockaddr_in *sin;

	<span class="enscript-comment">/*
	 * Do the malloc first in case it blocks.
	 */</span>
	MALLOC(sin, <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-keyword">sizeof</span> (*sin), M_SONAME, M_WAITOK);
	<span class="enscript-keyword">if</span> (sin == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	bzero(sin, <span class="enscript-keyword">sizeof</span> (*sin));
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL) {
		FREE(sin, M_SONAME);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	sin-&gt;sin_port = inp-&gt;inp_lport;
	sin-&gt;sin_addr = inp-&gt;inp_laddr;

	*nam = (<span class="enscript-type">struct</span> sockaddr *)sin;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in_getsockaddr_s</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_storage *ss)
{
	<span class="enscript-type">struct</span> sockaddr_in *sin = SIN(ss);
	<span class="enscript-type">struct</span> inpcb *inp;

	VERIFY(ss != NULL);
	bzero(ss, <span class="enscript-keyword">sizeof</span> (*ss));

	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);

	sin-&gt;sin_port = inp-&gt;inp_lport;
	sin-&gt;sin_addr = inp-&gt;inp_laddr;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in_getpeeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> sockaddr_in *sin;

	<span class="enscript-comment">/*
	 * Do the malloc first in case it blocks.
	 */</span>
	MALLOC(sin, <span class="enscript-type">struct</span> sockaddr_in *, <span class="enscript-keyword">sizeof</span> (*sin), M_SONAME, M_WAITOK);
	<span class="enscript-keyword">if</span> (sin == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	bzero((caddr_t)sin, <span class="enscript-keyword">sizeof</span> (*sin));
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL) {
		FREE(sin, M_SONAME);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	sin-&gt;sin_port = inp-&gt;inp_fport;
	sin-&gt;sin_addr = inp-&gt;inp_faddr;

	*nam = (<span class="enscript-type">struct</span> sockaddr *)sin;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in_getpeeraddr_s</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_storage *ss)
{
	<span class="enscript-type">struct</span> sockaddr_in *sin = SIN(ss);
	<span class="enscript-type">struct</span> inpcb *inp;

	VERIFY(ss != NULL);
	bzero(ss, <span class="enscript-keyword">sizeof</span> (*ss));

	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);
	}

	sin-&gt;sin_port = inp-&gt;inp_fport;
	sin-&gt;sin_addr = inp-&gt;inp_faddr;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbnotifyall</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in_addr faddr,
    <span class="enscript-type">int</span> errno, <span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>))
{
	<span class="enscript-type">struct</span> inpcb *inp;

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	LIST_FOREACH(inp, pcbinfo-&gt;ipi_listhead, inp_list) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != faddr.s_addr ||
		    inp-&gt;inp_socket == NULL)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) == WNT_STOPUSING)
			<span class="enscript-keyword">continue</span>;
		socket_lock(inp-&gt;inp_socket, 1);
		(*notify)(inp, errno);
		(<span class="enscript-type">void</span>) in_pcb_checkstate(inp, WNT_RELEASE, 1);
		socket_unlock(inp-&gt;inp_socket, 1);
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
}

<span class="enscript-comment">/*
 * Check for alternatives when higher level complains
 * about service problems.  For now, invalidate cached
 * routing information.  If the route was created dynamically
 * (by a redirect), time to try a default gateway again.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in_losing</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	boolean_t release = FALSE;
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-keyword">if</span> ((rt = inp-&gt;inp_route.ro_rt) != NULL) {
		<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;

		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_DYNAMIC) {
			<span class="enscript-comment">/*
			 * Prevent another thread from modifying rt_key,
			 * rt_gateway via rt_setgate() after rt_lock is
			 * dropped by marking the route as defunct.
			 */</span>
			rt-&gt;rt_flags |= RTF_CONDEMNED;
			RT_UNLOCK(rt);
			(<span class="enscript-type">void</span>) rtrequest(RTM_DELETE, rt_key(rt),
			    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}
		<span class="enscript-comment">/* if the address is gone keep the old route in the pcb */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY &amp;&amp;
		    (ia = ifa_foraddr(inp-&gt;inp_laddr.s_addr)) != NULL) {
			<span class="enscript-comment">/*
			 * Address is around; ditch the route.  A new route
			 * can be allocated the next time output is attempted.
			 */</span>
			release = TRUE;
		}
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
	}
	<span class="enscript-keyword">if</span> (rt == NULL || release)
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

<span class="enscript-comment">/*
 * After a routing change, flush old routing
 * and allocate a (hopefully) better one.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in_rtchange</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> errno)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">errno</span>)
	boolean_t release = FALSE;
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-keyword">if</span> ((rt = inp-&gt;inp_route.ro_rt) != NULL) {
		<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;

		<span class="enscript-comment">/* if address is gone, keep the old route */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY &amp;&amp;
		    (ia = ifa_foraddr(inp-&gt;inp_laddr.s_addr)) != NULL) {
			<span class="enscript-comment">/*
			 * Address is around; ditch the route.  A new route
			 * can be allocated the next time output is attempted.
			 */</span>
			release = TRUE;
		}
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
	}
	<span class="enscript-keyword">if</span> (rt == NULL || release)
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

<span class="enscript-comment">/*
 * Lookup a PCB based on the local address and port.
 */</span>
<span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in_pcblookup_local</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in_addr laddr,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> lport_arg, <span class="enscript-type">int</span> wild_okay)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> matchwild = 3, wildcard;
	u_short lport = lport_arg;

	KERNEL_DEBUG(DBG_FNC_PCB_LOOKUP | DBG_FUNC_START, 0, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> (!wild_okay) {
		<span class="enscript-type">struct</span> inpcbhead *head;
		<span class="enscript-comment">/*
		 * Look for an unconnected (wildcard foreign addr) PCB that
		 * matches the local address and port we're looking for.
		 */</span>
		head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
		    pcbinfo-&gt;ipi_hashmask)];
		LIST_FOREACH(inp, head, inp_hash) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
				<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == INADDR_ANY &amp;&amp;
			    inp-&gt;inp_laddr.s_addr == laddr.s_addr &amp;&amp;
			    inp-&gt;inp_lport == lport) {
				<span class="enscript-comment">/*
				 * Found.
				 */</span>
				<span class="enscript-keyword">return</span> (inp);
			}
		}
		<span class="enscript-comment">/*
		 * Not found.
		 */</span>
		KERNEL_DEBUG(DBG_FNC_PCB_LOOKUP | DBG_FUNC_END, 0, 0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> inpcbporthead *porthash;
		<span class="enscript-type">struct</span> inpcbport *phd;
		<span class="enscript-type">struct</span> inpcb *match = NULL;
		<span class="enscript-comment">/*
		 * Best fit PCB lookup.
		 *
		 * First see if this local port is in use by looking on the
		 * port hash list.
		 */</span>
		porthash = &amp;pcbinfo-&gt;ipi_porthashbase[INP_PCBPORTHASH(lport,
		    pcbinfo-&gt;ipi_porthashmask)];
		LIST_FOREACH(phd, porthash, phd_hash) {
			<span class="enscript-keyword">if</span> (phd-&gt;phd_port == lport)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (phd != NULL) {
			<span class="enscript-comment">/*
			 * Port is in use by one or more PCBs. Look for best
			 * fit.
			 */</span>
			LIST_FOREACH(inp, &amp;phd-&gt;phd_pcblist, inp_portlist) {
				wildcard = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
					<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != INADDR_ANY)
					wildcard++;
				<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr != INADDR_ANY) {
					<span class="enscript-keyword">if</span> (laddr.s_addr == INADDR_ANY)
						wildcard++;
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr !=
					    laddr.s_addr)
						<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (laddr.s_addr != INADDR_ANY)
						wildcard++;
				}
				<span class="enscript-keyword">if</span> (wildcard &lt; matchwild) {
					match = inp;
					matchwild = wildcard;
					<span class="enscript-keyword">if</span> (matchwild == 0) {
						<span class="enscript-keyword">break</span>;
					}
				}
			}
		}
		KERNEL_DEBUG(DBG_FNC_PCB_LOOKUP | DBG_FUNC_END, match,
		    0, 0, 0, 0);
		<span class="enscript-keyword">return</span> (match);
	}
}

<span class="enscript-comment">/*
 * Check if PCB exists in hash list.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcblookup_hash_exists</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in_addr faddr,
    u_int fport_arg, <span class="enscript-type">struct</span> in_addr laddr, u_int lport_arg, <span class="enscript-type">int</span> wildcard,
    uid_t *uid, gid_t *gid, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> inpcbhead *head;
	<span class="enscript-type">struct</span> inpcb *inp;
	u_short fport = fport_arg, lport = lport_arg;
	<span class="enscript-type">int</span> found = 0;
	<span class="enscript-type">struct</span> inpcb *local_wild = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> inpcb *local_wild_mapped = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	*uid = UID_MAX;
	*gid = GID_MAX;

	<span class="enscript-comment">/*
	 * We may have found the pcb in the last lookup - check this first.
	 */</span>

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	<span class="enscript-comment">/*
	 * First look for an exact match.
	 */</span>
	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(faddr.s_addr, lport, fport,
	    pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == faddr.s_addr &amp;&amp;
		    inp-&gt;inp_laddr.s_addr == laddr.s_addr &amp;&amp;
		    inp-&gt;inp_fport == fport &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-keyword">if</span> ((found = (inp-&gt;inp_socket != NULL))) {
				<span class="enscript-comment">/*
				 * Found.
				 */</span>
				*uid = kauth_cred_getuid(
				    inp-&gt;inp_socket-&gt;so_cred);
				*gid = kauth_cred_getgid(
				    inp-&gt;inp_socket-&gt;so_cred);
			}
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (found);
		}
	}

	<span class="enscript-keyword">if</span> (!wildcard) {
		<span class="enscript-comment">/*
		 * Not found.
		 */</span>
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
	    pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == INADDR_ANY &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == laddr.s_addr) {
				<span class="enscript-keyword">if</span> ((found = (inp-&gt;inp_socket != NULL))) {
					*uid = kauth_cred_getuid(
					    inp-&gt;inp_socket-&gt;so_cred);
					*gid = kauth_cred_getgid(
					    inp-&gt;inp_socket-&gt;so_cred);
				}
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (found);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == INADDR_ANY) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (inp-&gt;inp_socket &amp;&amp;
				    SOCK_CHECK_DOM(inp-&gt;inp_socket, PF_INET6))
					local_wild_mapped = inp;
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					local_wild = inp;
			}
		}
	}
	<span class="enscript-keyword">if</span> (local_wild == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (local_wild_mapped != NULL) {
			<span class="enscript-keyword">if</span> ((found = (local_wild_mapped-&gt;inp_socket != NULL))) {
				*uid = kauth_cred_getuid(
				    local_wild_mapped-&gt;inp_socket-&gt;so_cred);
				*gid = kauth_cred_getgid(
				    local_wild_mapped-&gt;inp_socket-&gt;so_cred);
			}
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (found);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> ((found = (local_wild-&gt;inp_socket != NULL))) {
		*uid = kauth_cred_getuid(
		    local_wild-&gt;inp_socket-&gt;so_cred);
		*gid = kauth_cred_getgid(
		    local_wild-&gt;inp_socket-&gt;so_cred);
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (found);
}

<span class="enscript-comment">/*
 * Lookup PCB in hash list.
 */</span>
<span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in_pcblookup_hash</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in_addr faddr,
    u_int fport_arg, <span class="enscript-type">struct</span> in_addr laddr, u_int lport_arg, <span class="enscript-type">int</span> wildcard,
    <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> inpcbhead *head;
	<span class="enscript-type">struct</span> inpcb *inp;
	u_short fport = fport_arg, lport = lport_arg;
	<span class="enscript-type">struct</span> inpcb *local_wild = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> inpcb *local_wild_mapped = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-comment">/*
	 * We may have found the pcb in the last lookup - check this first.
	 */</span>

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	<span class="enscript-comment">/*
	 * First look for an exact match.
	 */</span>
	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(faddr.s_addr, lport, fport,
	    pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == faddr.s_addr &amp;&amp;
		    inp-&gt;inp_laddr.s_addr == laddr.s_addr &amp;&amp;
		    inp-&gt;inp_fport == fport &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-comment">/*
			 * Found.
			 */</span>
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) !=
			    WNT_STOPUSING) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (inp);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* it's there but dead, say it isn't found */</span>
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (NULL);
			}
		}
	}

	<span class="enscript-keyword">if</span> (!wildcard) {
		<span class="enscript-comment">/*
		 * Not found.
		 */</span>
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (NULL);
	}

	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
	    pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV4))
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr == INADDR_ANY &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == laddr.s_addr) {
				<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) !=
				    WNT_STOPUSING) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					<span class="enscript-keyword">return</span> (inp);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* it's dead; say it isn't found */</span>
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					<span class="enscript-keyword">return</span> (NULL);
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == INADDR_ANY) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(inp-&gt;inp_socket, PF_INET6))
					local_wild_mapped = inp;
				<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
					local_wild = inp;
			}
		}
	}
	<span class="enscript-keyword">if</span> (local_wild == NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (local_wild_mapped != NULL) {
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(local_wild_mapped,
			    WNT_ACQUIRE, 0) != WNT_STOPUSING) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (local_wild_mapped);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* it's dead; say it isn't found */</span>
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (NULL);
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(local_wild, WNT_ACQUIRE, 0) != WNT_STOPUSING) {
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (local_wild);
	}
	<span class="enscript-comment">/*
	 * It's either not found or is already dead.
	 */</span>
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Insert PCB onto various hash lists.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcbinshash</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> inpcbhead *pcbhash;
	<span class="enscript-type">struct</span> inpcbporthead *pcbporthash;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = inp-&gt;inp_pcbinfo;
	<span class="enscript-type">struct</span> inpcbport *phd;
	u_int32_t hashkey_faddr;

	<span class="enscript-keyword">if</span> (!locked) {
		<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(pcbinfo-&gt;ipi_lock)) {
			<span class="enscript-comment">/*
			 * Lock inversion issue, mostly with udp
			 * multicast packets
			 */</span>
			socket_unlock(inp-&gt;inp_socket, 0);
			lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);
			socket_lock(inp-&gt;inp_socket, 0);
			<span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD) {
				<span class="enscript-comment">/*
				 * The socket got dropped when
				 * it was unlocked
				 */</span>
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (ECONNABORTED);
			}
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6)
		hashkey_faddr = inp-&gt;in6p_faddr.s6_addr32[3] <span class="enscript-comment">/* XXX */</span>;
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		hashkey_faddr = inp-&gt;inp_faddr.s_addr;

	inp-&gt;inp_hash_element = INP_PCBHASH(hashkey_faddr, inp-&gt;inp_lport,
	    inp-&gt;inp_fport, pcbinfo-&gt;ipi_hashmask);

	pcbhash = &amp;pcbinfo-&gt;ipi_hashbase[inp-&gt;inp_hash_element];

	pcbporthash = &amp;pcbinfo-&gt;ipi_porthashbase[INP_PCBPORTHASH(inp-&gt;inp_lport,
	    pcbinfo-&gt;ipi_porthashmask)];

	<span class="enscript-comment">/*
	 * Go through port list and look for a head for this lport.
	 */</span>
	LIST_FOREACH(phd, pcbporthash, phd_hash) {
		<span class="enscript-keyword">if</span> (phd-&gt;phd_port == inp-&gt;inp_lport)
			<span class="enscript-keyword">break</span>;
	}

	VERIFY(inp-&gt;inp_state != INPCB_STATE_DEAD);

	<span class="enscript-comment">/*
	 * If none exists, malloc one and tack it on.
	 */</span>
	<span class="enscript-keyword">if</span> (phd == NULL) {
		MALLOC(phd, <span class="enscript-type">struct</span> inpcbport *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> inpcbport),
		    M_PCB, M_WAITOK);
		<span class="enscript-keyword">if</span> (phd == NULL) {
			<span class="enscript-keyword">if</span> (!locked)
				lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (ENOBUFS); <span class="enscript-comment">/* XXX */</span>
		}
		phd-&gt;phd_port = inp-&gt;inp_lport;
		LIST_INIT(&amp;phd-&gt;phd_pcblist);
		LIST_INSERT_HEAD(pcbporthash, phd, phd_hash);
	}

	VERIFY(!(inp-&gt;inp_flags2 &amp; INP2_INHASHLIST));
	inp-&gt;inp_phd = phd;
	LIST_INSERT_HEAD(&amp;phd-&gt;phd_pcblist, inp, inp_portlist);
	LIST_INSERT_HEAD(pcbhash, inp, inp_hash);
	inp-&gt;inp_flags2 |= INP2_INHASHLIST;

	<span class="enscript-keyword">if</span> (!locked)
		lck_rw_done(pcbinfo-&gt;ipi_lock);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">// This call catches the original setting of the local address
</span>	inp_update_necp_policy(inp, NULL, NULL, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Move PCB to the proper hash bucket when { faddr, fport } have  been
 * changed. NOTE: This does not handle the case of the lport changing (the
 * hashed port list would have to be updated as well), so the lport must
 * not change after in_pcbinshash() has been called.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbrehash</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> inpcbhead *head;
	u_int32_t hashkey_faddr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6)
		hashkey_faddr = inp-&gt;in6p_faddr.s6_addr32[3] <span class="enscript-comment">/* XXX */</span>;
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		hashkey_faddr = inp-&gt;inp_faddr.s_addr;

	inp-&gt;inp_hash_element = INP_PCBHASH(hashkey_faddr, inp-&gt;inp_lport,
	    inp-&gt;inp_fport, inp-&gt;inp_pcbinfo-&gt;ipi_hashmask);
	head = &amp;inp-&gt;inp_pcbinfo-&gt;ipi_hashbase[inp-&gt;inp_hash_element];

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_INHASHLIST) {
		LIST_REMOVE(inp, inp_hash);
		inp-&gt;inp_flags2 &amp;= ~INP2_INHASHLIST;
	}

	VERIFY(!(inp-&gt;inp_flags2 &amp; INP2_INHASHLIST));
	LIST_INSERT_HEAD(head, inp, inp_hash);
	inp-&gt;inp_flags2 |= INP2_INHASHLIST;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">// This call catches updates to the remote addresses
</span>	inp_update_necp_policy(inp, NULL, NULL, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
}

<span class="enscript-comment">/*
 * Remove PCB from various lists.
 * Must be called pcbinfo lock is held in exclusive mode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in_pcbremlists</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_gencnt = ++inp-&gt;inp_pcbinfo-&gt;ipi_gencnt;

	<span class="enscript-comment">/*
	 * Check if it's in hashlist -- an inp is placed in hashlist when
	 * it's local port gets assigned. So it should also be present 
	 * in the port list.
	 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_INHASHLIST) {
		<span class="enscript-type">struct</span> inpcbport *phd = inp-&gt;inp_phd;

		VERIFY(phd != NULL &amp;&amp; inp-&gt;inp_lport &gt; 0);

		LIST_REMOVE(inp, inp_hash);
		inp-&gt;inp_hash.le_next = NULL;
		inp-&gt;inp_hash.le_prev = NULL;

		LIST_REMOVE(inp, inp_portlist);
		inp-&gt;inp_portlist.le_next = NULL;
		inp-&gt;inp_portlist.le_prev = NULL;
		<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;phd-&gt;phd_pcblist)) {
			LIST_REMOVE(phd, phd_hash);
			FREE(phd, M_PCB);
		}
		inp-&gt;inp_phd = NULL;
		inp-&gt;inp_flags2 &amp;= ~INP2_INHASHLIST;
	}
	VERIFY(!(inp-&gt;inp_flags2 &amp; INP2_INHASHLIST));

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_TIMEWAIT) {
		<span class="enscript-comment">/* Remove from time-wait queue */</span>
		tcp_remove_from_time_wait(inp);
		inp-&gt;inp_flags2 &amp;= ~INP2_TIMEWAIT;
		VERIFY(inp-&gt;inp_pcbinfo-&gt;ipi_twcount != 0);
		inp-&gt;inp_pcbinfo-&gt;ipi_twcount--;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Remove from global inp list if it is not time-wait */</span>
		LIST_REMOVE(inp, inp_list);
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags2 &amp; INP2_IN_FCTREE) {
		inp_fc_getinp(inp-&gt;inp_flowhash, (INPFC_SOLOCKED|INPFC_REMOVE));
		VERIFY(!(inp-&gt;inp_flags2 &amp; INP2_IN_FCTREE));
	}

	inp-&gt;inp_pcbinfo-&gt;ipi_count--;
}

<span class="enscript-comment">/*
 * Mechanism used to defer the memory release of PCBs
 * The pcb list will contain the pcb until the reaper can clean it up if
 * the following conditions are met:
 *	1) state &quot;DEAD&quot;,
 *	2) wantcnt is STOPUSING
 *	3) usecount is 0
 * This function will be called to either mark the pcb as
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in_pcb_checkstate</span>(<span class="enscript-type">struct</span> inpcb *pcb, <span class="enscript-type">int</span> mode, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">volatile</span> UInt32 *wantcnt = (<span class="enscript-type">volatile</span> UInt32 *)&amp;pcb-&gt;inp_wantcnt;
	UInt32 origwant;
	UInt32 newwant;

	<span class="enscript-keyword">switch</span> (mode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">WNT_STOPUSING</span>:
		<span class="enscript-comment">/*
		 * Try to mark the pcb as ready for recycling.  CAS with
		 * STOPUSING, if success we're good, if it's in use, will
		 * be marked later
		 */</span>
		<span class="enscript-keyword">if</span> (locked == 0)
			socket_lock(pcb-&gt;inp_socket, 1);
		pcb-&gt;inp_state = INPCB_STATE_DEAD;

<span class="enscript-reference">stopusing</span>:
		<span class="enscript-keyword">if</span> (pcb-&gt;inp_socket-&gt;so_usecount &lt; 0) {
			panic(<span class="enscript-string">&quot;%s: pcb=%p so=%p usecount is negative\n&quot;</span>,
			    __func__, pcb, pcb-&gt;inp_socket);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-keyword">if</span> (locked == 0)
			socket_unlock(pcb-&gt;inp_socket, 1);

		inpcb_gc_sched(pcb-&gt;inp_pcbinfo, INPCB_TIMER_FAST);

		origwant = *wantcnt;
		<span class="enscript-keyword">if</span> ((UInt16) origwant == 0xffff) <span class="enscript-comment">/* should stop using */</span>
			<span class="enscript-keyword">return</span> (WNT_STOPUSING);
		newwant = 0xffff;
		<span class="enscript-keyword">if</span> ((UInt16) origwant == 0) {
			<span class="enscript-comment">/* try to mark it as unsuable now */</span>
			OSCompareAndSwap(origwant, newwant, wantcnt);
		}
		<span class="enscript-keyword">return</span> (WNT_STOPUSING);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">WNT_ACQUIRE</span>:
		<span class="enscript-comment">/*
		 * Try to increase reference to pcb.  If WNT_STOPUSING
		 * should bail out.  If socket state DEAD, try to set count
		 * to STOPUSING, return failed otherwise increase cnt.
		 */</span>
		<span class="enscript-keyword">do</span> {
			origwant = *wantcnt;
			<span class="enscript-keyword">if</span> ((UInt16) origwant == 0xffff) {
				<span class="enscript-comment">/* should stop using */</span>
				<span class="enscript-keyword">return</span> (WNT_STOPUSING);
			}
			newwant = origwant + 1;
		} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(origwant, newwant, wantcnt));
		<span class="enscript-keyword">return</span> (WNT_ACQUIRE);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">WNT_RELEASE</span>:
		<span class="enscript-comment">/*
		 * Release reference.  If result is null and pcb state
		 * is DEAD, set wanted bit to STOPUSING
		 */</span>
		<span class="enscript-keyword">if</span> (locked == 0)
			socket_lock(pcb-&gt;inp_socket, 1);

		<span class="enscript-keyword">do</span> {
			origwant = *wantcnt;
			<span class="enscript-keyword">if</span> ((UInt16) origwant == 0x0) {
				panic(<span class="enscript-string">&quot;%s: pcb=%p release with zero count&quot;</span>,
				    __func__, pcb);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-keyword">if</span> ((UInt16) origwant == 0xffff) {
				<span class="enscript-comment">/* should stop using */</span>
				<span class="enscript-keyword">if</span> (locked == 0)
					socket_unlock(pcb-&gt;inp_socket, 1);
				<span class="enscript-keyword">return</span> (WNT_STOPUSING);
			}
			newwant = origwant - 1;
		} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(origwant, newwant, wantcnt));

		<span class="enscript-keyword">if</span> (pcb-&gt;inp_state == INPCB_STATE_DEAD)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">stopusing</span>;
		<span class="enscript-keyword">if</span> (pcb-&gt;inp_socket-&gt;so_usecount &lt; 0) {
			panic(<span class="enscript-string">&quot;%s: RELEASE pcb=%p so=%p usecount is negative\n&quot;</span>,
			    __func__, pcb, pcb-&gt;inp_socket);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		<span class="enscript-keyword">if</span> (locked == 0)
			socket_unlock(pcb-&gt;inp_socket, 1);
		<span class="enscript-keyword">return</span> (WNT_RELEASE);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: so=%p not a valid state =%x\n&quot;</span>, __func__,
		    pcb-&gt;inp_socket, mode);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* NOTREACHED */</span>
	<span class="enscript-keyword">return</span> (mode);
}

<span class="enscript-comment">/*
 * inpcb_to_compat copies specific bits of an inpcb to a inpcb_compat.
 * The inpcb_compat data structure is passed to user space and must
 * not change. We intentionally avoid copying pointers.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_to_compat</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> inpcb_compat *inp_compat)
{
	bzero(inp_compat, <span class="enscript-keyword">sizeof</span> (*inp_compat));
	inp_compat-&gt;inp_fport = inp-&gt;inp_fport;
	inp_compat-&gt;inp_lport = inp-&gt;inp_lport;
	inp_compat-&gt;nat_owner = 0;
	inp_compat-&gt;nat_cookie = 0;
	inp_compat-&gt;inp_gencnt = inp-&gt;inp_gencnt;
	inp_compat-&gt;inp_flags = inp-&gt;inp_flags;
	inp_compat-&gt;inp_flow = inp-&gt;inp_flow;
	inp_compat-&gt;inp_vflag = inp-&gt;inp_vflag;
	inp_compat-&gt;inp_ip_ttl = inp-&gt;inp_ip_ttl;
	inp_compat-&gt;inp_ip_p = inp-&gt;inp_ip_p;
	inp_compat-&gt;inp_dependfaddr.inp6_foreign =
	    inp-&gt;inp_dependfaddr.inp6_foreign;
	inp_compat-&gt;inp_dependladdr.inp6_local =
	    inp-&gt;inp_dependladdr.inp6_local;
	inp_compat-&gt;inp_depend4.inp4_ip_tos = inp-&gt;inp_depend4.inp4_ip_tos;
	inp_compat-&gt;inp_depend6.inp6_hlim = 0;
	inp_compat-&gt;inp_depend6.inp6_cksum = inp-&gt;inp_depend6.inp6_cksum;
	inp_compat-&gt;inp_depend6.inp6_ifindex = 0;
	inp_compat-&gt;inp_depend6.inp6_hops = inp-&gt;inp_depend6.inp6_hops;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_to_xinpcb64</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> xinpcb64 *xinp)
{
	xinp-&gt;inp_fport = inp-&gt;inp_fport;
	xinp-&gt;inp_lport = inp-&gt;inp_lport;
	xinp-&gt;inp_gencnt = inp-&gt;inp_gencnt;
	xinp-&gt;inp_flags = inp-&gt;inp_flags;
	xinp-&gt;inp_flow = inp-&gt;inp_flow;
	xinp-&gt;inp_vflag = inp-&gt;inp_vflag;
	xinp-&gt;inp_ip_ttl = inp-&gt;inp_ip_ttl;
	xinp-&gt;inp_ip_p = inp-&gt;inp_ip_p;
	xinp-&gt;inp_dependfaddr.inp6_foreign = inp-&gt;inp_dependfaddr.inp6_foreign;
	xinp-&gt;inp_dependladdr.inp6_local = inp-&gt;inp_dependladdr.inp6_local;
	xinp-&gt;inp_depend4.inp4_ip_tos = inp-&gt;inp_depend4.inp4_ip_tos;
	xinp-&gt;inp_depend6.inp6_hlim = 0;
	xinp-&gt;inp_depend6.inp6_cksum = inp-&gt;inp_depend6.inp6_cksum;
	xinp-&gt;inp_depend6.inp6_ifindex = 0;
	xinp-&gt;inp_depend6.inp6_hops = inp-&gt;inp_depend6.inp6_hops;
}

<span class="enscript-comment">/*
 * The following routines implement this scheme:
 *
 * Callers of ip_output() that intend to cache the route in the inpcb pass
 * a local copy of the struct route to ip_output().  Using a local copy of
 * the cached route significantly simplifies things as IP no longer has to
 * worry about having exclusive access to the passed in struct route, since
 * it's defined in the caller's stack; in essence, this allows for a lock-
 * less operation when updating the struct route at the IP level and below,
 * whenever necessary. The scheme works as follows:
 *
 * Prior to dropping the socket's lock and calling ip_output(), the caller
 * copies the struct route from the inpcb into its stack, and adds a reference
 * to the cached route entry, if there was any.  The socket's lock is then
 * dropped and ip_output() is called with a pointer to the copy of struct
 * route defined on the stack (not to the one in the inpcb.)
 *
 * Upon returning from ip_output(), the caller then acquires the socket's
 * lock and synchronizes the cache; if there is no route cached in the inpcb,
 * it copies the local copy of struct route (which may or may not contain any
 * route) back into the cache; otherwise, if the inpcb has a route cached in
 * it, the one in the local copy will be freed, if there's any.  Trashing the
 * cached route in the inpcb can be avoided because ip_output() is single-
 * threaded per-PCB (i.e. multiple transmits on a PCB are always serialized
 * by the socket/transport layer.)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_route_copyout</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> route *dst)
{
	<span class="enscript-type">struct</span> route *src = &amp;inp-&gt;inp_route;

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * If the route in the PCB is stale or not for IPv4, blow it away;
	 * this is possible in the case of IPv4-mapped address case.
	 */</span>
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(src) || rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET)
		ROUTE_RELEASE(src);

	route_copyout(dst, src, <span class="enscript-keyword">sizeof</span> (*dst));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_route_copyin</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> route *src)
{
	<span class="enscript-type">struct</span> route *dst = &amp;inp-&gt;inp_route;

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Minor sanity check */</span>
	<span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL &amp;&amp; rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET)
		panic(<span class="enscript-string">&quot;%s: wrong or corrupted route: %p&quot;</span>, __func__, src);

	route_copyin(src, dst, <span class="enscript-keyword">sizeof</span> (*src));
}

<span class="enscript-comment">/*
 * Handler for setting IP_FORCE_OUT_IFP/IP_BOUND_IF/IPV6_BOUND_IF socket option.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">inp_bindif</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope, <span class="enscript-type">struct</span> ifnet **pifp)
{
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> ((ifscope &gt; (<span class="enscript-type">unsigned</span>)if_index) || (ifscope != IFSCOPE_NONE &amp;&amp;
	    (ifp = ifindex2ifnet[ifscope]) == NULL)) {
		ifnet_head_done();
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	ifnet_head_done();

	VERIFY(ifp != NULL || ifscope == IFSCOPE_NONE);

	<span class="enscript-comment">/*
	 * A zero interface scope value indicates an &quot;unbind&quot;.
	 * Otherwise, take in whatever value the app desires;
	 * the app may already know the scope (or force itself
	 * to such a scope) ahead of time before the interface
	 * gets attached.  It doesn't matter either way; any
	 * route lookup from this point on will require an
	 * exact match for the embedded interface scope.
	 */</span>
	inp-&gt;inp_boundifp = ifp;
	<span class="enscript-keyword">if</span> (inp-&gt;inp_boundifp == NULL)
		inp-&gt;inp_flags &amp;= ~INP_BOUND_IF;
	<span class="enscript-keyword">else</span>
		inp-&gt;inp_flags |= INP_BOUND_IF;

	<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
	ROUTE_RELEASE(&amp;inp-&gt;inp_route);

	<span class="enscript-keyword">if</span> (pifp != NULL)
		*pifp = ifp;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Handler for setting IP_NO_IFT_CELLULAR/IPV6_NO_IFT_CELLULAR socket option,
 * as well as for setting PROC_UUID_NO_CELLULAR policy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_set_nocellular</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags |= INP_NO_IFT_CELLULAR;

	<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
	ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

<span class="enscript-comment">/*
 * Handler for clearing IP_NO_IFT_CELLULAR/IPV6_NO_IFT_CELLULAR socket option,
 * as well as for clearing PROC_UUID_NO_CELLULAR policy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_clear_nocellular</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-comment">/*
	 * SO_RESTRICT_DENY_CELLULAR socket restriction issued on the socket
	 * has a higher precendence than INP_NO_IFT_CELLULAR.  Clear the flag
	 * if and only if the socket is unrestricted.
	 */</span>
	<span class="enscript-keyword">if</span> (so != NULL &amp;&amp; !(so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_CELLULAR)) {
		inp-&gt;inp_flags &amp;= ~INP_NO_IFT_CELLULAR;

		<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
		ROUTE_RELEASE(&amp;inp-&gt;inp_route);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_set_noexpensive</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags2 |= INP2_NO_IFF_EXPENSIVE;

	<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
	ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_set_awdl_unrestricted</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags2 |= INP2_AWDL_UNRESTRICTED;

	<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
	ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

boolean_t
<span class="enscript-function-name">inp_get_awdl_unrestricted</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-keyword">return</span> (inp-&gt;inp_flags2 &amp; INP2_AWDL_UNRESTRICTED) ? TRUE : FALSE;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_clear_awdl_unrestricted</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags2 &amp;= ~INP2_AWDL_UNRESTRICTED;

	<span class="enscript-comment">/* Blow away any cached route in the PCB */</span>
	ROUTE_RELEASE(&amp;inp-&gt;inp_route);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
<span class="enscript-comment">/*
 * Called when PROC_UUID_NECP_APP_POLICY is set.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_set_want_app_policy</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags2 |= INP2_WANT_APP_POLICY;
}

<span class="enscript-comment">/*
 * Called when PROC_UUID_NECP_APP_POLICY is cleared.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_clear_want_app_policy</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	inp-&gt;inp_flags2 &amp;= ~INP2_WANT_APP_POLICY;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

<span class="enscript-comment">/*
 * Calculate flow hash for an inp, used by an interface to identify a
 * flow. When an interface provides flow control advisory, this flow
 * hash is used as an identifier.
 */</span>
u_int32_t
<span class="enscript-function-name">inp_calc_flowhash</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> inp_flowhash_key fh __attribute__((aligned(8)));
	u_int32_t flowhash = 0;
	<span class="enscript-type">struct</span> inpcb *tmp_inp = NULL;

	<span class="enscript-keyword">if</span> (inp_hash_seed == 0)
		inp_hash_seed = RandomULong();

	bzero(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh));

	bcopy(&amp;inp-&gt;inp_dependladdr, &amp;fh.infh_laddr, <span class="enscript-keyword">sizeof</span> (fh.infh_laddr));
	bcopy(&amp;inp-&gt;inp_dependfaddr, &amp;fh.infh_faddr, <span class="enscript-keyword">sizeof</span> (fh.infh_faddr));

	fh.infh_lport = inp-&gt;inp_lport;
	fh.infh_fport = inp-&gt;inp_fport;
	fh.infh_af = (inp-&gt;inp_vflag &amp; INP_IPV6) ? AF_INET6 : AF_INET;
	fh.infh_proto = inp-&gt;inp_ip_p;
	fh.infh_rand1 = RandomULong();
	fh.infh_rand2 = RandomULong();

<span class="enscript-reference">try_again</span>:
	flowhash = net_flowhash(&amp;fh, <span class="enscript-keyword">sizeof</span> (fh), inp_hash_seed);
	<span class="enscript-keyword">if</span> (flowhash == 0) {
		<span class="enscript-comment">/* try to get a non-zero flowhash */</span>
		inp_hash_seed = RandomULong();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	}

	inp-&gt;inp_flowhash = flowhash;

	<span class="enscript-comment">/* Insert the inp into inp_fc_tree */</span>
	lck_mtx_lock_spin(&amp;inp_fc_lck);
	tmp_inp = RB_FIND(inp_fc_tree, &amp;inp_fc_tree, inp);
	<span class="enscript-keyword">if</span> (tmp_inp != NULL) {
		<span class="enscript-comment">/*
		 * There is a different inp with the same flowhash.
		 * There can be a collision on flow hash but the
		 * probability is low.  Let's recompute the
		 * flowhash.
		 */</span>
		lck_mtx_unlock(&amp;inp_fc_lck);
		<span class="enscript-comment">/* recompute hash seed */</span>
		inp_hash_seed = RandomULong();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_again</span>;
	}

	RB_INSERT(inp_fc_tree, &amp;inp_fc_tree, inp);
	inp-&gt;inp_flags2 |= INP2_IN_FCTREE;
	lck_mtx_unlock(&amp;inp_fc_lck);

	<span class="enscript-keyword">return</span> (flowhash);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_flowadv</span>(uint32_t flowhash)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = inp_fc_getinp(flowhash, 0);

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span>;
	inp_fc_feedback(inp);
}

<span class="enscript-comment">/*
 * Function to compare inp_fc_entries in inp flow control tree
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">infc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp1, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> inpcb *inp2)
{
	<span class="enscript-keyword">return</span> (memcmp(&amp;(inp1-&gt;inp_flowhash), &amp;(inp2-&gt;inp_flowhash),
	    <span class="enscript-keyword">sizeof</span>(inp1-&gt;inp_flowhash)));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">inp_fc_getinp</span>(u_int32_t flowhash, u_int32_t flags)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
	<span class="enscript-type">int</span> locked = (flags &amp; INPFC_SOLOCKED) ? 1 : 0;

	lck_mtx_lock_spin(&amp;inp_fc_lck);
	key_inp.inp_flowhash = flowhash;
	inp = RB_FIND(inp_fc_tree, &amp;inp_fc_tree, &amp;key_inp);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-comment">/* inp is not present, return */</span>
		lck_mtx_unlock(&amp;inp_fc_lck);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (flags &amp; INPFC_REMOVE) {
		RB_REMOVE(inp_fc_tree, &amp;inp_fc_tree, inp);
		lck_mtx_unlock(&amp;inp_fc_lck);

		bzero(&amp;(inp-&gt;infc_link), <span class="enscript-keyword">sizeof</span> (inp-&gt;infc_link));
		inp-&gt;inp_flags2 &amp;= ~INP2_IN_FCTREE;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, locked) == WNT_STOPUSING)
		inp = NULL;
	lck_mtx_unlock(&amp;inp_fc_lck);

	<span class="enscript-keyword">return</span> (inp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inp_fc_feedback</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-comment">/* we already hold a want_cnt on this inp, socket can't be null */</span>
	VERIFY(so != NULL);
	socket_lock(so, 1);

	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (inp-&gt;inp_sndinprog_cnt &gt; 0)
		inp-&gt;inp_flags |= INP_FC_FEEDBACK;

	<span class="enscript-comment">/*
	 * Return if the connection is not in flow-controlled state.
	 * This can happen if the connection experienced
	 * loss while it was in flow controlled state
	 */</span>
	<span class="enscript-keyword">if</span> (!INP_WAIT_FOR_IF_FEEDBACK(inp)) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span>;
	}
	inp_reset_fc_state(inp);

	<span class="enscript-keyword">if</span> (SOCK_TYPE(so) == SOCK_STREAM)
		inp_fc_unthrottle_tcp(inp);

	socket_unlock(so, 1);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_reset_fc_state</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> suspended = (INP_IS_FLOW_SUSPENDED(inp)) ? 1 : 0;
	<span class="enscript-type">int</span> needwakeup = (INP_WAIT_FOR_IF_FEEDBACK(inp)) ? 1 : 0;

	inp-&gt;inp_flags &amp;= ~(INP_FLOW_CONTROLLED | INP_FLOW_SUSPENDED);

	<span class="enscript-keyword">if</span> (suspended) {
		so-&gt;so_flags &amp;= ~(SOF_SUSPENDED);
		soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_RESUME));
	}

	<span class="enscript-comment">/* Give a write wakeup to unblock the socket */</span>
	<span class="enscript-keyword">if</span> (needwakeup)
		sowwakeup(so);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">inp_set_fc_state</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> advcode)
{
	<span class="enscript-type">struct</span> inpcb *tmp_inp = NULL;
	<span class="enscript-comment">/*
	 * If there was a feedback from the interface when
	 * send operation was in progress, we should ignore
	 * this flow advisory to avoid a race between setting
	 * flow controlled state and receiving feedback from
	 * the interface
	 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_FC_FEEDBACK)
		<span class="enscript-keyword">return</span> (0);

	inp-&gt;inp_flags &amp;= ~(INP_FLOW_CONTROLLED | INP_FLOW_SUSPENDED);
	<span class="enscript-keyword">if</span> ((tmp_inp = inp_fc_getinp(inp-&gt;inp_flowhash,
	    INPFC_SOLOCKED)) != NULL) {
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(tmp_inp, WNT_RELEASE, 1) == WNT_STOPUSING)
			<span class="enscript-keyword">return</span> (0);
		VERIFY(tmp_inp == inp);
		<span class="enscript-keyword">switch</span> (advcode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FADV_FLOW_CONTROLLED</span>:
			inp-&gt;inp_flags |= INP_FLOW_CONTROLLED;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FADV_SUSPENDED</span>:
			inp-&gt;inp_flags |= INP_FLOW_SUSPENDED;
			soevent(inp-&gt;inp_socket,
			    (SO_FILT_HINT_LOCKED | SO_FILT_HINT_SUSPEND));

			<span class="enscript-comment">/* Record the fact that suspend event was sent */</span>
			inp-&gt;inp_socket-&gt;so_flags |= SOF_SUSPENDED;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Handler for SO_FLUSH socket option.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">inp_flush</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> optval)
{
	u_int32_t flowhash = inp-&gt;inp_flowhash;
	<span class="enscript-type">struct</span> ifnet *rtifp, *oifp;

	<span class="enscript-comment">/* Either all classes or one of the valid ones */</span>
	<span class="enscript-keyword">if</span> (optval != SO_TC_ALL &amp;&amp; !SO_VALID_TC(optval))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* We need a flow hash for identification */</span>
	<span class="enscript-keyword">if</span> (flowhash == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* Grab the interfaces from the route and pcb */</span>
	rtifp = ((inp-&gt;inp_route.ro_rt != NULL) ?
	    inp-&gt;inp_route.ro_rt-&gt;rt_ifp : NULL);
	oifp = inp-&gt;inp_last_outifp;

	<span class="enscript-keyword">if</span> (rtifp != NULL)
		if_qflush_sc(rtifp, so_tc2msc(optval), flowhash, NULL, NULL, 0);
	<span class="enscript-keyword">if</span> (oifp != NULL &amp;&amp; oifp != rtifp)
		if_qflush_sc(oifp, so_tc2msc(optval), flowhash, NULL, NULL, 0);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Clear the INP_INADDR_ANY flag (special case for PPP only)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_clear_INP_INADDR_ANY</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;

	socket_lock(so, 1);
	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp) {
		inp-&gt;inp_flags &amp;= ~INP_INADDR_ANY;
	}
	socket_unlock(so, 1);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_get_soprocinfo</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> so_procinfo *soprocinfo)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	soprocinfo-&gt;spi_pid = so-&gt;last_pid;
	<span class="enscript-keyword">if</span> (so-&gt;last_pid != 0)
		uuid_copy(soprocinfo-&gt;spi_uuid, so-&gt;last_uuid);
	<span class="enscript-comment">/*
	 * When not delegated, the effective pid is the same as the real pid
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
		soprocinfo-&gt;spi_delegated = 1;
		soprocinfo-&gt;spi_epid = so-&gt;e_pid;
		uuid_copy(soprocinfo-&gt;spi_euuid, so-&gt;e_uuid);
	} <span class="enscript-keyword">else</span> {
		soprocinfo-&gt;spi_delegated = 0;
		soprocinfo-&gt;spi_epid = so-&gt;last_pid;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">inp_findinpcb_procinfo</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, uint32_t flowhash,
    <span class="enscript-type">struct</span> so_procinfo *soprocinfo)
{
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
	<span class="enscript-type">int</span> found = 0;

	bzero(soprocinfo, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_procinfo));

	<span class="enscript-keyword">if</span> (!flowhash)
		<span class="enscript-keyword">return</span> (-1);

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
	LIST_FOREACH(inp, pcbinfo-&gt;ipi_listhead, inp_list) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD &amp;&amp;
		    inp-&gt;inp_socket != NULL &amp;&amp;
		    inp-&gt;inp_flowhash == flowhash) {
			found = 1;
			inp_get_soprocinfo(inp, soprocinfo);
			<span class="enscript-keyword">break</span>;
		}
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);

	<span class="enscript-keyword">return</span> (found);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROC_UUID_POLICY</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inp_update_cellular_policy</span>(<span class="enscript-type">struct</span> inpcb *inp, boolean_t set)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> before, after;

	VERIFY(so != NULL);
	VERIFY(inp-&gt;inp_state != INPCB_STATE_DEAD);

	before = INP_NO_CELLULAR(inp);
	<span class="enscript-keyword">if</span> (set) {
		inp_set_nocellular(inp);
	} <span class="enscript-keyword">else</span> {
		inp_clear_nocellular(inp);
	}
	after = INP_NO_CELLULAR(inp);
	<span class="enscript-keyword">if</span> (net_io_policy_log &amp;&amp; (before != after)) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ok = <span class="enscript-string">&quot;OK&quot;</span>;
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *nok = <span class="enscript-string">&quot;NOACCESS&quot;</span>;
		uuid_string_t euuid_buf;
		pid_t epid;

		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
			uuid_unparse(so-&gt;e_uuid, euuid_buf);
			epid = so-&gt;e_pid;
		} <span class="enscript-keyword">else</span> {
			uuid_unparse(so-&gt;last_uuid, euuid_buf);
			epid = so-&gt;last_pid;
		}

		<span class="enscript-comment">/* allow this socket to generate another notification event */</span>
		so-&gt;so_ifdenied_notifies = 0;

		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: so 0x%llx [%d,%d] epid %d &quot;</span>
		    <span class="enscript-string">&quot;euuid %s%s %s-&gt;%s\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(so), SOCK_DOM(so),
		    SOCK_TYPE(so), epid, euuid_buf,
		    (so-&gt;so_flags &amp; SOF_DELEGATED) ?
		    <span class="enscript-string">&quot; [delegated]&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    ((before &lt; after) ? ok : nok),
		    ((before &lt; after) ? nok : ok));
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inp_update_necp_want_app_policy</span>(<span class="enscript-type">struct</span> inpcb *inp, boolean_t set)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> before, after;

	VERIFY(so != NULL);
	VERIFY(inp-&gt;inp_state != INPCB_STATE_DEAD);

	before = (inp-&gt;inp_flags2 &amp; INP2_WANT_APP_POLICY);
	<span class="enscript-keyword">if</span> (set) {
		inp_set_want_app_policy(inp);
	} <span class="enscript-keyword">else</span> {
		inp_clear_want_app_policy(inp);
	}
	after = (inp-&gt;inp_flags2 &amp; INP2_WANT_APP_POLICY);
	<span class="enscript-keyword">if</span> (net_io_policy_log &amp;&amp; (before != after)) {
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *wanted = <span class="enscript-string">&quot;WANTED&quot;</span>;
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *unwanted = <span class="enscript-string">&quot;UNWANTED&quot;</span>;
		uuid_string_t euuid_buf;
		pid_t epid;

		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
			uuid_unparse(so-&gt;e_uuid, euuid_buf);
			epid = so-&gt;e_pid;
		} <span class="enscript-keyword">else</span> {
			uuid_unparse(so-&gt;last_uuid, euuid_buf);
			epid = so-&gt;last_pid;
		}

		log(LOG_DEBUG, <span class="enscript-string">&quot;%s: so 0x%llx [%d,%d] epid %d &quot;</span>
		    <span class="enscript-string">&quot;euuid %s%s %s-&gt;%s\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(so), SOCK_DOM(so),
		    SOCK_TYPE(so), epid, euuid_buf,
		    (so-&gt;so_flags &amp; SOF_DELEGATED) ?
		    <span class="enscript-string">&quot; [delegated]&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    ((before &lt; after) ? unwanted : wanted),
		    ((before &lt; after) ? wanted : unwanted));
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_PROC_UUID_POLICY */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inp_update_necp_policy</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *override_local_addr, <span class="enscript-type">struct</span> sockaddr *override_remote_addr, u_int override_bound_interface)
{
	necp_socket_find_policy_match(inp, override_local_addr, override_remote_addr, override_bound_interface);
	<span class="enscript-keyword">if</span> (necp_socket_should_rescope(inp) &amp;&amp;
		inp-&gt;inp_lport == 0 &amp;&amp;
		inp-&gt;inp_laddr.s_addr == INADDR_ANY &amp;&amp;
		IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
		<span class="enscript-comment">// If we should rescope, and the socket is not yet bound
</span>		inp_bindif(inp, necp_socket_get_rescope_if_index(inp), NULL);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">inp_update_policy</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROC_UUID_POLICY</span>
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	uint32_t pflags = 0;
	int32_t ogencnt;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (!net_io_policy_uuid ||
	    so == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Kernel-created sockets that aren't delegating other sockets
	 * are currently exempted from UUID policy checks.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;last_pid == 0 &amp;&amp; !(so-&gt;so_flags &amp; SOF_DELEGATED))
		<span class="enscript-keyword">return</span> (0);

	ogencnt = so-&gt;so_policy_gencnt;
	err = proc_uuid_policy_lookup(((so-&gt;so_flags &amp; SOF_DELEGATED) ?
	    so-&gt;e_uuid : so-&gt;last_uuid), &amp;pflags, &amp;so-&gt;so_policy_gencnt);

	<span class="enscript-comment">/*
	 * Discard cached generation count if the entry is gone (ENOENT),
	 * so that we go thru the checks below.
	 */</span>
	<span class="enscript-keyword">if</span> (err == ENOENT &amp;&amp; ogencnt != 0)
		so-&gt;so_policy_gencnt = 0;

	<span class="enscript-comment">/*
	 * If the generation count has changed, inspect the policy flags
	 * and act accordingly.  If a policy flag was previously set and
	 * the UUID is no longer present in the table (ENOENT), treat it
	 * as if the flag has been cleared.
	 */</span>
	<span class="enscript-keyword">if</span> ((err == 0 || err == ENOENT) &amp;&amp; ogencnt != so-&gt;so_policy_gencnt) {
		<span class="enscript-comment">/* update cellular policy for this socket */</span>
		<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; (pflags &amp; PROC_UUID_NO_CELLULAR)) {
			inp_update_cellular_policy(inp, TRUE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(pflags &amp; PROC_UUID_NO_CELLULAR)) {
			inp_update_cellular_policy(inp, FALSE);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-comment">/* update necp want app policy for this socket */</span>
		<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; (pflags &amp; PROC_UUID_NECP_APP_POLICY)) {
			inp_update_necp_want_app_policy(inp, TRUE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(pflags &amp; PROC_UUID_NECP_APP_POLICY)) {
			inp_update_necp_want_app_policy(inp, FALSE);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	}

	<span class="enscript-keyword">return</span> ((err == ENOENT) ? 0 : err);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !CONFIG_PROC_UUID_POLICY */</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">inp</span>)
	<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_PROC_UUID_POLICY */</span>
}
<span class="enscript-comment">/*
 * Called when we need to enforce policy restrictions in the input path.
 *
 * Returns TRUE if we're not allowed to receive data, otherwise FALSE.
 */</span>
boolean_t
<span class="enscript-function-name">inp_restricted_recv</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> ifnet *ifp)
{
	VERIFY(inp != NULL);

	<span class="enscript-comment">/*
	 * Inbound restrictions.
	 */</span>
	<span class="enscript-keyword">if</span> (!sorestrictrecv)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (IFNET_IS_CELLULAR(ifp) &amp;&amp; INP_NO_CELLULAR(inp))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (IFNET_IS_EXPENSIVE(ifp) &amp;&amp; INP_NO_EXPENSIVE(inp))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (IFNET_IS_AWDL_RESTRICTED(ifp) &amp;&amp; !INP_AWDL_UNRESTRICTED(inp))
		<span class="enscript-keyword">return</span> (TRUE);
	
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; IFEF_RESTRICTED_RECV))
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECV_ANYIF)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; INP_BOUND_IF) &amp;&amp; inp-&gt;inp_boundifp == ifp)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 * Called when we need to enforce policy restrictions in the output path.
 *
 * Returns TRUE if we're not allowed to send data out, otherwise FALSE.
 */</span>
boolean_t
<span class="enscript-function-name">inp_restricted_send</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> ifnet *ifp)
{
	VERIFY(inp != NULL);

	<span class="enscript-comment">/*
	 * Outbound restrictions.
	 */</span>
	<span class="enscript-keyword">if</span> (!sorestrictsend)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">if</span> (IFNET_IS_CELLULAR(ifp) &amp;&amp; INP_NO_CELLULAR(inp))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (IFNET_IS_EXPENSIVE(ifp) &amp;&amp; INP_NO_EXPENSIVE(inp))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (IFNET_IS_AWDL_RESTRICTED(ifp) &amp;&amp; !INP_AWDL_UNRESTRICTED(inp))
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">return</span> (FALSE);
}
</pre>
<hr />
</body></html>