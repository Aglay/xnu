<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in_pcblist.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in_pcblist.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2010-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ROUNDUP64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROUNDUP64</span>(x) P2ROUNDUP((x), sizeof (u_int64_t))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ADVANCE64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADVANCE64</span>(p, n) (void*)((char *)(p) + ROUNDUP64(n))
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">inpcb_to_xinpcb_n</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> xinpcb_n *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcpcb_to_xtcpcb_n</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> xtcpcb_n *);

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sotoxsocket_n</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> xsocket_n *xso)
{
	xso-&gt;xso_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsocket_n);
	xso-&gt;xso_kind = XSO_SOCKET;

	<span class="enscript-keyword">if</span> (so != NULL) {
		xso-&gt;xso_so = (uint64_t)VM_KERNEL_ADDRPERM(so);
		xso-&gt;so_type = so-&gt;so_type;
		xso-&gt;so_options = so-&gt;so_options;
		xso-&gt;so_linger = so-&gt;so_linger;
		xso-&gt;so_state = so-&gt;so_state;
		xso-&gt;so_pcb = (uint64_t)VM_KERNEL_ADDRPERM(so-&gt;so_pcb);
		<span class="enscript-keyword">if</span> (so-&gt;so_proto) {
			xso-&gt;xso_protocol = SOCK_PROTO(so);
			xso-&gt;xso_family = SOCK_DOM(so);
		} <span class="enscript-keyword">else</span> {
			xso-&gt;xso_protocol = xso-&gt;xso_family = 0;
		}
		xso-&gt;so_qlen = so-&gt;so_qlen;
		xso-&gt;so_incqlen = so-&gt;so_incqlen;
		xso-&gt;so_qlimit = so-&gt;so_qlimit;
		xso-&gt;so_timeo = so-&gt;so_timeo;
		xso-&gt;so_error = so-&gt;so_error;
		xso-&gt;so_pgid = so-&gt;so_pgid;
		xso-&gt;so_oobmark = so-&gt;so_oobmark;
		xso-&gt;so_uid = kauth_cred_getuid(so-&gt;so_cred);
		xso-&gt;so_last_pid = so-&gt;last_pid;
		xso-&gt;so_e_pid = so-&gt;e_pid;
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sbtoxsockbuf_n</span>(<span class="enscript-type">struct</span> sockbuf *sb, <span class="enscript-type">struct</span> xsockbuf_n *xsb)
{
	xsb-&gt;xsb_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockbuf_n);
	xsb-&gt;xsb_kind = (sb-&gt;sb_flags &amp; SB_RECV) ? XSO_RCVBUF : XSO_SNDBUF;

	<span class="enscript-keyword">if</span> (sb != NULL) {
		xsb-&gt;sb_cc = sb-&gt;sb_cc;
		xsb-&gt;sb_hiwat = sb-&gt;sb_hiwat;
		xsb-&gt;sb_mbcnt = sb-&gt;sb_mbcnt;
		xsb-&gt;sb_mbmax = sb-&gt;sb_mbmax;
		xsb-&gt;sb_lowat = sb-&gt;sb_lowat;
		xsb-&gt;sb_flags = sb-&gt;sb_flags;
		xsb-&gt;sb_timeo = (<span class="enscript-type">short</span>)(sb-&gt;sb_timeo.tv_sec * hz) +
		    sb-&gt;sb_timeo.tv_usec / tick;
		<span class="enscript-keyword">if</span> (xsb-&gt;sb_timeo == 0 &amp;&amp; sb-&gt;sb_timeo.tv_usec != 0)
			xsb-&gt;sb_timeo = 1;
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sbtoxsockstat_n</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> xsockstat_n *xst)
{
	<span class="enscript-type">int</span> i;

	xst-&gt;xst_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockstat_n);
	xst-&gt;xst_kind = XSO_STATS;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; SO_TC_STATS_MAX; i++) {
		xst-&gt;xst_tc_stats[i].rxpackets = so-&gt;so_tc_stats[i].rxpackets;
		xst-&gt;xst_tc_stats[i].rxbytes = so-&gt;so_tc_stats[i].rxbytes;
		xst-&gt;xst_tc_stats[i].txpackets = so-&gt;so_tc_stats[i].txpackets;
		xst-&gt;xst_tc_stats[i].txbytes = so-&gt;so_tc_stats[i].txbytes;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_to_xinpcb_n</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> xinpcb_n *xinp)
{
	xinp-&gt;xi_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xinpcb_n);
	xinp-&gt;xi_kind = XSO_INPCB;
	xinp-&gt;xi_inpp = (uint64_t)VM_KERNEL_ADDRPERM(inp);
	xinp-&gt;inp_fport = inp-&gt;inp_fport;
	xinp-&gt;inp_lport = inp-&gt;inp_lport;
	xinp-&gt;inp_ppcb = (uint64_t)VM_KERNEL_ADDRPERM(inp-&gt;inp_ppcb);
	xinp-&gt;inp_gencnt = inp-&gt;inp_gencnt;
	xinp-&gt;inp_flags = inp-&gt;inp_flags;
	xinp-&gt;inp_flow = inp-&gt;inp_flow;
	xinp-&gt;inp_vflag = inp-&gt;inp_vflag;
	xinp-&gt;inp_ip_ttl = inp-&gt;inp_ip_ttl;
	xinp-&gt;inp_ip_p = inp-&gt;inp_ip_p;
	xinp-&gt;inp_dependfaddr.inp6_foreign = inp-&gt;inp_dependfaddr.inp6_foreign;
	xinp-&gt;inp_dependladdr.inp6_local = inp-&gt;inp_dependladdr.inp6_local;
	xinp-&gt;inp_depend4.inp4_ip_tos = inp-&gt;inp_depend4.inp4_ip_tos;
	xinp-&gt;inp_depend6.inp6_hlim = 0;
	xinp-&gt;inp_depend6.inp6_cksum = inp-&gt;inp_depend6.inp6_cksum;
	xinp-&gt;inp_depend6.inp6_ifindex = 0;
	xinp-&gt;inp_depend6.inp6_hops = inp-&gt;inp_depend6.inp6_hops;
	xinp-&gt;inp_flowhash = inp-&gt;inp_flowhash;
	xinp-&gt;inp_flags2 = inp-&gt;inp_flags2;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">tcpcb_to_xtcpcb_n</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> xtcpcb_n *xt)
{
	xt-&gt;xt_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xtcpcb_n);
	xt-&gt;xt_kind = XSO_TCPCB;

	xt-&gt;t_segq = (uint32_t)VM_KERNEL_ADDRPERM(tp-&gt;t_segq.lh_first);
	xt-&gt;t_dupacks = tp-&gt;t_dupacks;
	xt-&gt;t_timer[TCPT_REXMT_EXT] = tp-&gt;t_timer[TCPT_REXMT];
	xt-&gt;t_timer[TCPT_PERSIST_EXT] = tp-&gt;t_timer[TCPT_PERSIST];
	xt-&gt;t_timer[TCPT_KEEP_EXT] = tp-&gt;t_timer[TCPT_KEEP];
	xt-&gt;t_timer[TCPT_2MSL_EXT] = tp-&gt;t_timer[TCPT_2MSL];
	xt-&gt;t_state = tp-&gt;t_state;
	xt-&gt;t_flags = tp-&gt;t_flags;
	xt-&gt;t_force = (tp-&gt;t_flagsext &amp; TF_FORCE) ? 1 : 0;
	xt-&gt;snd_una = tp-&gt;snd_una;
	xt-&gt;snd_max = tp-&gt;snd_max;
	xt-&gt;snd_nxt = tp-&gt;snd_nxt;
	xt-&gt;snd_up = tp-&gt;snd_up;
	xt-&gt;snd_wl1 = tp-&gt;snd_wl1;
	xt-&gt;snd_wl2 = tp-&gt;snd_wl2;
	xt-&gt;iss = tp-&gt;iss;
	xt-&gt;irs = tp-&gt;irs;
	xt-&gt;rcv_nxt = tp-&gt;rcv_nxt;
	xt-&gt;rcv_adv = tp-&gt;rcv_adv;
	xt-&gt;rcv_wnd = tp-&gt;rcv_wnd;
	xt-&gt;rcv_up = tp-&gt;rcv_up;
	xt-&gt;snd_wnd = tp-&gt;snd_wnd;
	xt-&gt;snd_cwnd = tp-&gt;snd_cwnd;
	xt-&gt;snd_ssthresh = tp-&gt;snd_ssthresh;
	xt-&gt;t_maxopd = tp-&gt;t_maxopd;
	xt-&gt;t_rcvtime = tp-&gt;t_rcvtime;
	xt-&gt;t_starttime = tp-&gt;t_starttime;
	xt-&gt;t_rtttime = tp-&gt;t_rtttime;
	xt-&gt;t_rtseq = tp-&gt;t_rtseq;
	xt-&gt;t_rxtcur = tp-&gt;t_rxtcur;
	xt-&gt;t_maxseg = tp-&gt;t_maxseg;
	xt-&gt;t_srtt = tp-&gt;t_srtt;
	xt-&gt;t_rttvar = tp-&gt;t_rttvar;
	xt-&gt;t_rxtshift = tp-&gt;t_rxtshift;
	xt-&gt;t_rttmin = tp-&gt;t_rttmin;
	xt-&gt;t_rttupdated = tp-&gt;t_rttupdated;
	xt-&gt;max_sndwnd = tp-&gt;max_sndwnd;
	xt-&gt;t_softerror = tp-&gt;t_softerror;
	xt-&gt;t_oobflags = tp-&gt;t_oobflags;
	xt-&gt;t_iobc = tp-&gt;t_iobc;
	xt-&gt;snd_scale = tp-&gt;snd_scale;
	xt-&gt;rcv_scale = tp-&gt;rcv_scale;
	xt-&gt;request_r_scale = tp-&gt;request_r_scale;
	xt-&gt;requested_s_scale = tp-&gt;requested_s_scale;
	xt-&gt;ts_recent = tp-&gt;ts_recent;
	xt-&gt;ts_recent_age = tp-&gt;ts_recent_age;
	xt-&gt;last_ack_sent = tp-&gt;last_ack_sent;
	xt-&gt;cc_send = tp-&gt;cc_send;
	xt-&gt;cc_recv = tp-&gt;cc_recv;
	xt-&gt;snd_recover = tp-&gt;snd_recover;
	xt-&gt;snd_cwnd_prev = tp-&gt;snd_cwnd_prev;
	xt-&gt;snd_ssthresh_prev = tp-&gt;snd_ssthresh_prev;
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">get_pcblist_n</span>(<span class="enscript-type">short</span> proto, <span class="enscript-type">struct</span> sysctl_req *req, <span class="enscript-type">struct</span> inpcbinfo *pcbinfo)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> i, n;
	<span class="enscript-type">struct</span> inpcb *inp, **inp_list = NULL;
	inp_gen_t gencnt;
	<span class="enscript-type">struct</span> xinpgen xig;
	<span class="enscript-type">void</span> *buf = NULL;
	size_t item_size = ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xinpcb_n)) +
	    ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsocket_n)) +
	    2 * ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockbuf_n)) +
	    ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockstat_n));

	<span class="enscript-keyword">if</span> (proto == IPPROTO_TCP)
		item_size += ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xtcpcb_n));

	<span class="enscript-comment">/*
	 * The process of preparing the PCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */</span>
	lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		n = pcbinfo-&gt;ipi_count;
		req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> (xig)) + (n + n/8) * item_size;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * OK, now we're committed to doing something.
	 */</span>
	gencnt = pcbinfo-&gt;ipi_gencnt;
	n = pcbinfo-&gt;ipi_count;

	bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	buf = _MALLOC(item_size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (buf == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> (*inp_list), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (inp_list == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">for</span> (inp = pcbinfo-&gt;ipi_listhead-&gt;lh_first, i = 0; inp &amp;&amp; i &lt; n;
	    inp = inp-&gt;inp_list.le_next) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
	}
	n = i;

	error = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
		inp = inp_list[i];
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD) {
			<span class="enscript-type">struct</span> xinpcb_n *xi = (<span class="enscript-type">struct</span> xinpcb_n *)buf;
			<span class="enscript-type">struct</span> xsocket_n *xso = (<span class="enscript-type">struct</span> xsocket_n *)
			    ADVANCE64(xi, <span class="enscript-keyword">sizeof</span> (*xi));
			<span class="enscript-type">struct</span> xsockbuf_n *xsbrcv = (<span class="enscript-type">struct</span> xsockbuf_n *)
			    ADVANCE64(xso, <span class="enscript-keyword">sizeof</span> (*xso));
			<span class="enscript-type">struct</span> xsockbuf_n *xsbsnd = (<span class="enscript-type">struct</span> xsockbuf_n *)
			    ADVANCE64(xsbrcv, <span class="enscript-keyword">sizeof</span> (*xsbrcv));
			<span class="enscript-type">struct</span> xsockstat_n *xsostats = (<span class="enscript-type">struct</span> xsockstat_n *)
			    ADVANCE64(xsbsnd, <span class="enscript-keyword">sizeof</span> (*xsbsnd));

			bzero(buf, item_size);

			inpcb_to_xinpcb_n(inp, xi);
			sotoxsocket_n(inp-&gt;inp_socket, xso);
			sbtoxsockbuf_n(inp-&gt;inp_socket ?
			    &amp;inp-&gt;inp_socket-&gt;so_rcv : NULL, xsbrcv);
			sbtoxsockbuf_n(inp-&gt;inp_socket ?
			    &amp;inp-&gt;inp_socket-&gt;so_snd : NULL, xsbsnd);
			sbtoxsockstat_n(inp-&gt;inp_socket, xsostats);
			<span class="enscript-keyword">if</span> (proto == IPPROTO_TCP) {
				<span class="enscript-type">struct</span>  xtcpcb_n *xt = (<span class="enscript-type">struct</span> xtcpcb_n *)
				    ADVANCE64(xsostats, <span class="enscript-keyword">sizeof</span> (*xsostats));

				<span class="enscript-comment">/*
				 * inp-&gt;inp_ppcb, can only be NULL on
				 * an initialization race window.
				 * No need to lock.
				 */</span>
				<span class="enscript-keyword">if</span> (inp-&gt;inp_ppcb == NULL)
					<span class="enscript-keyword">continue</span>;

				tcpcb_to_xtcpcb_n((<span class="enscript-type">struct</span> tcpcb *)
				    inp-&gt;inp_ppcb, xt);
			}
			error = SYSCTL_OUT(req, buf, item_size);
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
		xig.xig_len = <span class="enscript-keyword">sizeof</span> (xig);
		xig.xig_gen = pcbinfo-&gt;ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = pcbinfo-&gt;ipi_count;
		error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> (xig));
	}
<span class="enscript-reference">done</span>:
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">if</span> (inp_list != NULL)
		FREE(inp_list, M_TEMP);
	<span class="enscript-keyword">if</span> (buf != NULL)
		FREE(buf, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">inpcb_get_ports_used</span>(uint32_t ifindex, <span class="enscript-type">int</span> protocol, uint32_t flags,
    bitstr_t *bitfield, <span class="enscript-type">struct</span> inpcbinfo *pcbinfo)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> socket *so;
	inp_gen_t gencnt;
	bool iswildcard, wildcardok, nowakeok;
	bool recvanyifonly, extbgidleok;
	bool activeonly;

	wildcardok = ((flags &amp; INPCB_GET_PORTS_USED_WILDCARDOK) != 0);
	nowakeok = ((flags &amp; INPCB_GET_PORTS_USED_NOWAKEUPOK) != 0);
	recvanyifonly = ((flags &amp; INPCB_GET_PORTS_USED_RECVANYIFONLY) != 0);
	extbgidleok = ((flags &amp; INPCB_GET_PORTS_USED_EXTBGIDLEONLY) != 0);
	activeonly = ((flags &amp; INPCB_GET_PORTS_USED_ACTIVEONLY) != 0);

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
	gencnt = pcbinfo-&gt;ipi_gencnt;

	<span class="enscript-keyword">for</span> (inp = LIST_FIRST(pcbinfo-&gt;ipi_listhead); inp;
	    inp = LIST_NEXT(inp, inp_list)) {
		uint16_t port;

		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &gt; gencnt ||
		    inp-&gt;inp_state == INPCB_STATE_DEAD ||
		    inp-&gt;inp_wantcnt == WNT_STOPUSING)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((so = inp-&gt;inp_socket) == NULL ||
		    (so-&gt;so_state &amp; SS_DEFUNCT) ||
		    (so-&gt;so_state &amp; SS_ISDISCONNECTED))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!(protocol == PF_UNSPEC ||
		    (protocol == PF_INET &amp;&amp; (inp-&gt;inp_vflag &amp; INP_IPV4)) ||
		    (protocol == PF_INET6 &amp;&amp; (inp-&gt;inp_vflag &amp; INP_IPV6))))
			<span class="enscript-keyword">continue</span>;

		iswildcard = (((inp-&gt;inp_vflag &amp; INP_IPV4) &amp;&amp;
		    inp-&gt;inp_laddr.s_addr == INADDR_ANY) ||
		    ((inp-&gt;inp_vflag &amp; INP_IPV6) &amp;&amp;
		    IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)));

		<span class="enscript-keyword">if</span> (!wildcardok &amp;&amp; iswildcard)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_NOWAKEFROMSLEEP) &amp;&amp;
			!nowakeok)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; INP_RECV_ANYIF) &amp;&amp;
			recvanyifonly)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!(so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) &amp;&amp;
			extbgidleok)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!iswildcard &amp;&amp;
		    !(ifindex == 0 || inp-&gt;inp_last_outifp == NULL ||
		    ifindex == inp-&gt;inp_last_outifp-&gt;if_index))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (SOCK_PROTO(inp-&gt;inp_socket) == IPPROTO_UDP &amp;&amp;
		    so-&gt;so_state &amp; SS_CANTRCVMORE)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (SOCK_PROTO(inp-&gt;inp_socket) == IPPROTO_TCP) {
			<span class="enscript-type">struct</span>  tcpcb *tp = sototcpcb(inp-&gt;inp_socket);

			<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSED</span>:
					<span class="enscript-keyword">continue</span>;
					<span class="enscript-comment">/* NOT REACHED */</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LISTEN</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_SENT</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_1</span>:
					<span class="enscript-comment">/*
					 * Note: FIN_WAIT_1 is an active state
					 * because we need our FIN to be
					 * acknowledged
					 */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSE_WAIT</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSING</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LAST_ACK</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_FIN_WAIT_2</span>:
					<span class="enscript-comment">/*
					 * In the closing states, the connection
					 * is not idle when there is outgoing
					 * data having to be acknowledged
					 */</span>
					<span class="enscript-keyword">if</span> (activeonly &amp;&amp; so-&gt;so_snd.sb_cc == 0)
						<span class="enscript-keyword">continue</span>;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_TIME_WAIT</span>:
					<span class="enscript-keyword">continue</span>;
					<span class="enscript-comment">/* NOT REACHED */</span>
			}
		}
		<span class="enscript-comment">/*
		 * Final safeguard to exclude unspecified local port
		 */</span>
		port = ntohs(inp-&gt;inp_lport);
		<span class="enscript-keyword">if</span> (port == 0)
			<span class="enscript-keyword">continue</span>;
		bit_set(bitfield, port);
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
}

__private_extern__ uint32_t
<span class="enscript-function-name">inpcb_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, <span class="enscript-type">struct</span> inpcbinfo *pcbinfo,
    u_int32_t flags)
{
	uint32_t opportunistic = 0;
	<span class="enscript-type">struct</span> inpcb *inp;
	inp_gen_t gencnt;

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
	gencnt = pcbinfo-&gt;ipi_gencnt;
	<span class="enscript-keyword">for</span> (inp = LIST_FIRST(pcbinfo-&gt;ipi_listhead);
	    inp != NULL; inp = LIST_NEXT(inp, inp_list)) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD &amp;&amp;
		    inp-&gt;inp_socket != NULL &amp;&amp;
		    so_get_opportunistic(inp-&gt;inp_socket) &amp;&amp;
		    inp-&gt;inp_last_outifp != NULL &amp;&amp;
		    ifindex == inp-&gt;inp_last_outifp-&gt;if_index) {
			opportunistic++;
			<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
			<span class="enscript-keyword">if</span> ((flags &amp; INPCB_OPPORTUNISTIC_SETCMD) &amp;&amp;
			    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
				socket_lock(so, 1);
				<span class="enscript-keyword">if</span> (flags &amp; INPCB_OPPORTUNISTIC_THROTTLEON) {
					so-&gt;so_flags |= SOF_SUSPENDED;
					soevent(so,
					    (SO_FILT_HINT_LOCKED |
					    SO_FILT_HINT_SUSPEND));
				} <span class="enscript-keyword">else</span> {
					so-&gt;so_flags &amp;= ~(SOF_SUSPENDED);
					soevent(so,
					    (SO_FILT_HINT_LOCKED |
					    SO_FILT_HINT_RESUME));
				}
				SOTHROTTLELOG((<span class="enscript-string">&quot;throttle[%d]: so 0x%llx &quot;</span>
				    <span class="enscript-string">&quot;[%d,%d] %s\n&quot;</span>, so-&gt;last_pid,
				    (uint64_t)VM_KERNEL_ADDRPERM(so),
				    SOCK_DOM(so), SOCK_TYPE(so),
				    (so-&gt;so_flags &amp; SOF_SUSPENDED) ?
				    <span class="enscript-string">&quot;SUSPENDED&quot;</span> : <span class="enscript-string">&quot;RESUMED&quot;</span>));
				socket_unlock(so, 1);
			}
		}
	}

	lck_rw_done(pcbinfo-&gt;ipi_lock);

	<span class="enscript-keyword">return</span> (opportunistic);
}

__private_extern__ uint32_t
<span class="enscript-function-name">inpcb_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">struct</span> inpcbinfo *pcbinfo)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	inp_gen_t gencnt = pcbinfo-&gt;ipi_gencnt;
	<span class="enscript-type">struct</span> socket *so = NULL;
	<span class="enscript-type">int</span> af;

	<span class="enscript-keyword">if</span> ((ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) &amp;&amp;
	    (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6)) {
		<span class="enscript-keyword">return</span> (0);
	}

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">for</span> (inp = LIST_FIRST(pcbinfo-&gt;ipi_listhead);
	    inp != NULL; inp = LIST_NEXT(inp, inp_list)) {

		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp;
		    inp-&gt;inp_state != INPCB_STATE_DEAD &amp;&amp;
		    inp-&gt;inp_socket != NULL) {
			so = inp-&gt;inp_socket;
			af = SOCK_DOM(so);
			<span class="enscript-keyword">if</span> (af != ifa-&gt;ifa_addr-&gt;sa_family)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (inp-&gt;inp_last_outifp != ifa-&gt;ifa_ifp)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (af == AF_INET) {
				<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr ==
				    (satosin(ifa-&gt;ifa_addr))-&gt;sin_addr.s_addr) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					<span class="enscript-keyword">return</span> (1);
				}
			}
			<span class="enscript-keyword">if</span> (af == AF_INET6) {
				<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa),
				    &amp;inp-&gt;in6p_laddr)) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					<span class="enscript-keyword">return</span> (1);
				}
			}
		}
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>