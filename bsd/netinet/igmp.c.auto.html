<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>igmp.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">igmp.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 2007-2009 Bruce Simpson.
 * Copyright (c) 1988 Stephen Deering.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)igmp.c	8.1 (Berkeley) 7/19/93
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * Internet Group Management Protocol (IGMP) routines.
 * [RFC1112, RFC2236, RFC3376]
 *
 * Written by Steve Deering, Stanford, May 1988.
 * Modified by Rosen Sharma, Stanford, Aug 1994.
 * Modified by Bill Fenner, Xerox PARC, Feb 1995.
 * Modified to fully comply to IGMPv2 by Bill Fenner, Oct 1995.
 * Significantly rewritten for IGMPv3, VIMAGE, and SMP by Bruce Simpson.
 *
 * MULTICAST Revision: 3.5.1.4
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/igmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/igmp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter_var.h&gt;</span>

<span class="enscript-function-name">SLIST_HEAD</span>(igmp_inm_relhead, in_multi);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igi_initvar(<span class="enscript-type">struct</span> igmp_ifinfo *, <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> igmp_ifinfo *<span class="enscript-function-name">igi_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igi_free(<span class="enscript-type">struct</span> igmp_ifinfo *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igi_delete(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> igmp_inm_relhead *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_dispatch_queue(<span class="enscript-type">struct</span> igmp_ifinfo *, <span class="enscript-type">struct</span> ifqueue *,
    <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_final_leave(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">struct</span> igmp_ifinfo *,
		    <span class="enscript-type">struct</span> igmp_tparams *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_handle_state_change(<span class="enscript-type">struct</span> in_multi *,
		    <span class="enscript-type">struct</span> igmp_ifinfo *, <span class="enscript-type">struct</span> igmp_tparams *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_initial_join(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">struct</span> igmp_ifinfo *,
		    <span class="enscript-type">struct</span> igmp_tparams *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v1_query(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *,
		    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> igmp *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v2_query(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *,
		    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> igmp *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v3_query(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *,
		    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmpv3 *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v3_group_query(<span class="enscript-type">struct</span> in_multi *,
		     <span class="enscript-type">int</span>, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmpv3 *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v1_report(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
		    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> ip *, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmp *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_input_v2_report(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *,
		    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> ip *, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmp *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_sendpkt(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>	igmp_isgroupreported(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">igmp_ra_alloc</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">igmp_rec_type_to_str</span>(<span class="enscript-type">const</span> <span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> uint32_t	igmp_set_version(<span class="enscript-type">struct</span> igmp_ifinfo *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_flush_relq(<span class="enscript-type">struct</span> igmp_ifinfo *,
    <span class="enscript-type">struct</span> igmp_inm_relhead *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_v1v2_queue_report(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_v1v2_process_group_timer(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_v1v2_process_querier_timers(<span class="enscript-type">struct</span> igmp_ifinfo *);
<span class="enscript-type">static</span> uint32_t	igmp_v2_update_group(<span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_v3_cancel_link_timers(<span class="enscript-type">struct</span> igmp_ifinfo *);
<span class="enscript-type">static</span> uint32_t	igmp_v3_dispatch_general_query(<span class="enscript-type">struct</span> igmp_ifinfo *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
		igmp_v3_encap_report(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_v3_enqueue_group_record(<span class="enscript-type">struct</span> ifqueue *,
		    <span class="enscript-type">struct</span> in_multi *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_v3_enqueue_filter_change(<span class="enscript-type">struct</span> ifqueue *,
		    <span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_v3_process_group_timers(<span class="enscript-type">struct</span> igmp_ifinfo *,
		    <span class="enscript-type">struct</span> ifqueue *, <span class="enscript-type">struct</span> ifqueue *, <span class="enscript-type">struct</span> in_multi *,
		    <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	igmp_v3_merge_state_changes(<span class="enscript-type">struct</span> in_multi *,
		    <span class="enscript-type">struct</span> ifqueue *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	igmp_v3_suppress_group_record(<span class="enscript-type">struct</span> in_multi *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	sysctl_igmp_ifinfo SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	sysctl_igmp_gsr SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	sysctl_igmp_default_version SYSCTL_HANDLER_ARGS;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_timeout_run;		<span class="enscript-comment">/* IGMP timer is scheduled to run */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">igmp_timeout</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">igmp_sched_timeout</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *m_raopt;		<span class="enscript-comment">/* Router Alert option */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> querier_present_timers_running;	<span class="enscript-comment">/* IGMPv1/v2 older version
						 * querier present */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> interface_timers_running;		<span class="enscript-comment">/* IGMPv3 general
						 * query response */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> state_change_timers_running;		<span class="enscript-comment">/* IGMPv3 state-change
						 * retransmit */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> current_state_timers_running;	<span class="enscript-comment">/* IGMPv1/v2 host
						 * report; IGMPv3 g/sg
						 * query response */</span>

<span class="enscript-comment">/*
 * Subsystem lock macros.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_LOCK</span>()			\
	lck_mtx_lock(&amp;igmp_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_LOCK_ASSERT_HELD</span>()		\
	lck_mtx_assert(&amp;igmp_mtx, LCK_MTX_ASSERT_OWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_LOCK_ASSERT_NOTHELD</span>()	\
	lck_mtx_assert(&amp;igmp_mtx, LCK_MTX_ASSERT_NOTOWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_UNLOCK</span>()			\
	lck_mtx_unlock(&amp;igmp_mtx)

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(, igmp_ifinfo) igi_head;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> igmpstat_v3 igmpstat_v3 = {
	.igps_version = IGPS_VERSION_3,
	.igps_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmpstat_v3),
};
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> igmpstat igmpstat; <span class="enscript-comment">/* old IGMPv2 stats structure */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval igmp_gsrdelay = {10, 0};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_recvifkludge = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_sendra = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_sendlocal = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_v1enable = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_v2enable = 1;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_legacysupp = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_default_version = IGMP_VERSION_3;

<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_inet_igmp, IGMPCTL_STATS, stats, CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;igmpstat, igmpstat, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_inet_igmp, OID_AUTO, v3stats,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;igmpstat_v3, igmpstat_v3, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, recvifkludge, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_recvifkludge, 0,
    <span class="enscript-string">&quot;Rewrite IGMPv1/v2 reports from 0.0.0.0 to contain subnet address&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, sendra, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_sendra, 0,
    <span class="enscript-string">&quot;Send IP Router Alert option in IGMPv2/v3 messages&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, sendlocal, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_sendlocal, 0,
    <span class="enscript-string">&quot;Send IGMP membership reports for 224.0.0.0/24 groups&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, v1enable, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_v1enable, 0,
    <span class="enscript-string">&quot;Enable backwards compatibility with IGMPv1&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, v2enable, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_v2enable, 0,
    <span class="enscript-string">&quot;Enable backwards compatibility with IGMPv2&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO, legacysupp, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;igmp_legacysupp, 0,
    <span class="enscript-string">&quot;Allow v1/v2 reports to suppress v3 group responses&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_igmp, OID_AUTO, default_version,
  CTLTYPE_INT | CTLFLAG_RW,
  &amp;igmp_default_version, 0, sysctl_igmp_default_version, <span class="enscript-string">&quot;I&quot;</span>,
    <span class="enscript-string">&quot;Default version of IGMP to run on each interface&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_igmp, OID_AUTO, gsrdelay,
    CTLTYPE_INT | CTLFLAG_RW,
    &amp;igmp_gsrdelay.tv_sec, 0, sysctl_igmp_gsr, <span class="enscript-string">&quot;I&quot;</span>,
    <span class="enscript-string">&quot;Rate limit for IGMPv3 Group-and-Source queries in seconds&quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
<span class="enscript-type">int</span> igmp_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_igmp, OID_AUTO,
	debug, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;igmp_debug, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_igmp, OID_AUTO, ifinfo, CTLFLAG_RD | CTLFLAG_LOCKED,
    sysctl_igmp_ifinfo, <span class="enscript-string">&quot;Per-interface IGMPv3 state&quot;</span>);

<span class="enscript-comment">/* Lock group and attribute for igmp_mtx */</span>
<span class="enscript-type">static</span> lck_attr_t	*igmp_mtx_attr;
<span class="enscript-type">static</span> lck_grp_t	*igmp_mtx_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*igmp_mtx_grp_attr;

<span class="enscript-comment">/*
 * Locking and reference counting:
 *
 * igmp_mtx mainly protects igi_head.  In cases where both igmp_mtx and
 * in_multihead_lock must be held, the former must be acquired first in order
 * to maintain lock ordering.  It is not a requirement that igmp_mtx be
 * acquired first before in_multihead_lock, but in case both must be acquired
 * in succession, the correct lock ordering must be followed.
 *
 * Instead of walking the if_multiaddrs list at the interface and returning
 * the ifma_protospec value of a matching entry, we search the global list
 * of in_multi records and find it that way; this is done with in_multihead
 * lock held.  Doing so avoids the race condition issues that many other BSDs
 * suffer from (therefore in our implementation, ifma_protospec will never be
 * NULL for as long as the in_multi is valid.)
 *
 * The above creates a requirement for the in_multi to stay in in_multihead
 * list even after the final IGMP leave (in IGMPv3 mode) until no longer needs
 * be retransmitted (this is not required for IGMPv1/v2.)  In order to handle
 * this, the request and reference counts of the in_multi are bumped up when
 * the state changes to IGMP_LEAVING_MEMBER, and later dropped in the timeout
 * handler.  Each in_multi holds a reference to the underlying igmp_ifinfo.
 *
 * Thus, the permitted lock oder is:
 *
 *	igmp_mtx, in_multihead_lock, inm_lock, igi_lock
 *
 * Any may be taken independently, but if any are held at the same time,
 * the above lock order must be followed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">decl_lck_mtx_data</span>(, igmp_mtx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_timers_are_running;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_ADD_DETACHED_INM</span>(_head, _inm) {				\
	SLIST_INSERT_HEAD(_head, _inm, inm_dtle);			\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IGMP_REMOVE_DETACHED_INM</span>(_head) {				\
	<span class="enscript-type">struct</span> in_multi *_inm, *_inm_tmp;				\
	SLIST_FOREACH_SAFE(_inm, _head, inm_dtle, _inm_tmp) {		\
		SLIST_REMOVE(_head, _inm, in_multi, inm_dtle);		\
		INM_REMREF(_inm);					\
	}								\
	VERIFY(SLIST_EMPTY(_head));					\
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IGI_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IGI_ZONE_NAME</span>		<span class="enscript-string">&quot;igmp_ifinfo&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> igi_size;			<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *igi_zone;			<span class="enscript-comment">/* zone for igmp_ifinfo */</span>

<span class="enscript-comment">/* Store IGMPv3 record count in the module private scratch space */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">vt_nrecs</span>	pkt_mpriv.__mpriv_u.__mpriv32[0].__mpriv32_u.__val16[0]

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_save_context</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *ifp)
{
        m-&gt;m_pkthdr.rcvif = ifp;
}

<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_scrub_context</span>(<span class="enscript-type">struct</span> mbuf *m)
{
        m-&gt;m_pkthdr.rcvif = NULL;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">inet_ntop_haddr</span>(in_addr_t haddr, <span class="enscript-type">char</span> *buf, socklen_t size)
{
	<span class="enscript-type">struct</span> in_addr ia;

	ia.s_addr = htonl(haddr);
	<span class="enscript-keyword">return</span> (inet_ntop(AF_INET, &amp;ia, buf, size));
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Restore context from a queued IGMP output chain.
 * Return saved ifp.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">igmp_restore_context</span>(<span class="enscript-type">struct</span> mbuf *m)
{
        <span class="enscript-keyword">return</span> (m-&gt;m_pkthdr.rcvif);
}

<span class="enscript-comment">/*
 * Retrieve or set default IGMP version.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_igmp_default_version SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span>	 error;
	<span class="enscript-type">int</span>	 new;

	IGMP_LOCK();

	error = SYSCTL_OUT(req, arg1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;

	new = igmp_default_version;

	error = SYSCTL_IN(req, &amp;new, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;

	<span class="enscript-keyword">if</span> (new &lt; IGMP_VERSION_1 || new &gt; IGMP_VERSION_3) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;
	}

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: change igmp_default_version from %d to %d\n&quot;</span>,
	    __func__, igmp_default_version, new));

	igmp_default_version = new;

<span class="enscript-reference">out_locked</span>:
	IGMP_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Retrieve or set threshold between group-source queries in seconds.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_igmp_gsr SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> i;

	IGMP_LOCK();

	i = igmp_gsrdelay.tv_sec;

	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;

	<span class="enscript-keyword">if</span> (i &lt; -1 || i &gt;= 60) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;
	}

	igmp_gsrdelay.tv_sec = i;

<span class="enscript-reference">out_locked</span>:
	IGMP_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Expose struct igmp_ifinfo to userland, keyed by ifindex.
 * For use by ifmcstat(8).
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_igmp_ifinfo SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>)
	<span class="enscript-type">int</span>			*name;
	<span class="enscript-type">int</span>			 error;
	u_int			 namelen;
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> igmp_ifinfo	*igi;
	<span class="enscript-type">struct</span> igmp_ifinfo_u	igi_u;

	name = (<span class="enscript-type">int</span> *)arg1;
	namelen = arg2;

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> (namelen != 1)
		<span class="enscript-keyword">return</span> (EINVAL);

	IGMP_LOCK();

	<span class="enscript-keyword">if</span> (name[0] &lt;= 0 || name[0] &gt; (u_int)if_index) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;
	}

	error = ENOENT;

	ifnet_head_lock_shared();
	ifp = ifindex2ifnet[name[0]];
	ifnet_head_done();
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;

	bzero(&amp;igi_u, <span class="enscript-keyword">sizeof</span> (igi_u));

	LIST_FOREACH(igi, &amp;igi_head, igi_link) {
		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (ifp != igi-&gt;igi_ifp) {
			IGI_UNLOCK(igi);
			<span class="enscript-keyword">continue</span>;
		}
		igi_u.igi_ifindex = igi-&gt;igi_ifp-&gt;if_index;
		igi_u.igi_version = igi-&gt;igi_version;
		igi_u.igi_v1_timer = igi-&gt;igi_v1_timer;
		igi_u.igi_v2_timer = igi-&gt;igi_v2_timer;
		igi_u.igi_v3_timer = igi-&gt;igi_v3_timer;
		igi_u.igi_flags = igi-&gt;igi_flags;
		igi_u.igi_rv = igi-&gt;igi_rv;
		igi_u.igi_qi = igi-&gt;igi_qi;
		igi_u.igi_qri = igi-&gt;igi_qri;
		igi_u.igi_uri = igi-&gt;igi_uri;
		IGI_UNLOCK(igi);

		error = SYSCTL_OUT(req, &amp;igi_u, <span class="enscript-keyword">sizeof</span> (igi_u));
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out_locked</span>:
	IGMP_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Dispatch an entire queue of pending packet chains
 *
 * Must not be called with inm_lock held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_dispatch_queue</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi, <span class="enscript-type">struct</span> ifqueue *ifq, <span class="enscript-type">int</span> limit,
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> loop)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip *ip;

	<span class="enscript-keyword">if</span> (igi != NULL)
		IGI_LOCK_ASSERT_HELD(igi);

	<span class="enscript-keyword">for</span> (;;) {
		IF_DEQUEUE(ifq, m);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">break</span>;
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: dispatch 0x%llx from 0x%llx\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifq),
		    (uint64_t)VM_KERNEL_ADDRPERM(m)));
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-keyword">if</span> (loop)
			m-&gt;m_flags |= M_IGMP_LOOP;
		<span class="enscript-keyword">if</span> (igi != NULL)
			IGI_UNLOCK(igi);
		igmp_sendpkt(m);
		<span class="enscript-keyword">if</span> (igi != NULL)
			IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (--limit == 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (igi != NULL)
		IGI_LOCK_ASSERT_HELD(igi);
}

<span class="enscript-comment">/*
 * Filter outgoing IGMP report state by group.
 *
 * Reports are ALWAYS suppressed for ALL-HOSTS (224.0.0.1).
 * If the net.inet.igmp.sendlocal sysctl is 0, then IGMP reports are
 * disabled for all groups in the 224.0.0.0/24 link-local scope. However,
 * this may break certain IGMP snooping switches which rely on the old
 * report behaviour.
 *
 * Return zero if the given group is one for which IGMP reports
 * should be suppressed, or non-zero if reports should be issued.
 */</span>

<span class="enscript-type">static</span> __inline__
<span class="enscript-type">int</span> <span class="enscript-function-name">igmp_isgroupreported</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr addr)
{

	<span class="enscript-keyword">if</span> (in_allhosts(addr) ||
	    ((!igmp_sendlocal &amp;&amp; IN_LOCAL_GROUP(ntohl(addr.s_addr)))))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Construct a Router Alert option to use in outgoing packets.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">igmp_ra_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> mbuf	*m;
	<span class="enscript-type">struct</span> ipoption	*p;

	MGET(m, M_WAITOK, MT_DATA);
	p = mtod(m, <span class="enscript-type">struct</span> ipoption *);
	p-&gt;ipopt_dst.s_addr = INADDR_ANY;
	p-&gt;ipopt_list[0] = IPOPT_RA;	<span class="enscript-comment">/* Router Alert Option */</span>
	p-&gt;ipopt_list[1] = 0x04;	<span class="enscript-comment">/* 4 bytes long */</span>
	p-&gt;ipopt_list[2] = IPOPT_EOL;	<span class="enscript-comment">/* End of IP option list */</span>
	p-&gt;ipopt_list[3] = 0x00;	<span class="enscript-comment">/* pad byte */</span>
	m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(p-&gt;ipopt_dst) + p-&gt;ipopt_list[1];

	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Attach IGMP when PF_INET is attached to an interface.
 */</span>
<span class="enscript-type">struct</span> igmp_ifinfo *
<span class="enscript-function-name">igmp_domifattach</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> igmp_ifinfo *igi;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: called for ifp 0x%llx(%s)\n&quot;</span>,
	    __func__, (uint64_t)VM_KERNEL_ADDRPERM(ifp), ifp-&gt;if_name));

	igi = igi_alloc(how);
	<span class="enscript-keyword">if</span> (igi == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	IGMP_LOCK();

	IGI_LOCK(igi);
	igi_initvar(igi, ifp, 0);
	igi-&gt;igi_debug |= IFD_ATTACHED;
	IGI_ADDREF_LOCKED(igi); <span class="enscript-comment">/* hold a reference for igi_head */</span>
	IGI_ADDREF_LOCKED(igi); <span class="enscript-comment">/* hold a reference for caller */</span>
	IGI_UNLOCK(igi);
	ifnet_lock_shared(ifp);
	igmp_initsilent(ifp, igi);
	ifnet_lock_done(ifp);

	LIST_INSERT_HEAD(&amp;igi_head, igi, igi_link);

	IGMP_UNLOCK();

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: allocate igmp_ifinfo for ifp 0x%llx(%s)\n&quot;</span>, __func__,
	     (uint64_t)VM_KERNEL_ADDRPERM(ifp), ifp-&gt;if_name));

	<span class="enscript-keyword">return</span> (igi);
}

<span class="enscript-comment">/*
 * Attach IGMP when PF_INET is reattached to an interface.  Caller is
 * expected to have an outstanding reference to the igi.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_domifreattach</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	<span class="enscript-type">struct</span> ifnet *ifp;

	IGMP_LOCK();

	IGI_LOCK(igi);
	VERIFY(!(igi-&gt;igi_debug &amp; IFD_ATTACHED));
	ifp = igi-&gt;igi_ifp;
	VERIFY(ifp != NULL);
	igi_initvar(igi, ifp, 1);
	igi-&gt;igi_debug |= IFD_ATTACHED;
	IGI_ADDREF_LOCKED(igi); <span class="enscript-comment">/* hold a reference for igi_head */</span>
	IGI_UNLOCK(igi);
	ifnet_lock_shared(ifp);
	igmp_initsilent(ifp, igi);
	ifnet_lock_done(ifp);

	LIST_INSERT_HEAD(&amp;igi_head, igi, igi_link);

	IGMP_UNLOCK();

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: reattached igmp_ifinfo for ifp 0x%llx(%s)\n&quot;</span>,
	    __func__, (uint64_t)VM_KERNEL_ADDRPERM(ifp), ifp-&gt;if_name));
}

<span class="enscript-comment">/*
 * Hook for domifdetach.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_domifdetach</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	SLIST_HEAD(, in_multi) inm_dthead;

	SLIST_INIT(&amp;inm_dthead);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: called for ifp 0x%llx(%s%d)\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(ifp), ifp-&gt;if_name, ifp-&gt;if_unit));

	IGMP_LOCK();
	igi_delete(ifp, (<span class="enscript-type">struct</span> igmp_inm_relhead *)&amp;inm_dthead);
	IGMP_UNLOCK();

	<span class="enscript-comment">/* Now that we're dropped all locks, release detached records */</span>
	IGMP_REMOVE_DETACHED_INM(&amp;inm_dthead);
}

<span class="enscript-comment">/*
 * Called at interface detach time.  Note that we only flush all deferred
 * responses and record releases; all remaining inm records and their source
 * entries related to this interface are left intact, in order to handle
 * the reattach case.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igi_delete</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> igmp_inm_relhead *inm_dthead)
{
	<span class="enscript-type">struct</span> igmp_ifinfo *igi, *tigi;

	IGMP_LOCK_ASSERT_HELD();

	LIST_FOREACH_SAFE(igi, &amp;igi_head, igi_link, tigi) {
		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (igi-&gt;igi_ifp == ifp) {
			<span class="enscript-comment">/*
			 * Free deferred General Query responses.
			 */</span>
			IF_DRAIN(&amp;igi-&gt;igi_gq);
			IF_DRAIN(&amp;igi-&gt;igi_v2q);
			igmp_flush_relq(igi, inm_dthead);
			VERIFY(SLIST_EMPTY(&amp;igi-&gt;igi_relinmhead));
			igi-&gt;igi_debug &amp;= ~IFD_ATTACHED;
			IGI_UNLOCK(igi);

			LIST_REMOVE(igi, igi_link);
			IGI_REMREF(igi); <span class="enscript-comment">/* release igi_head reference */</span>
			<span class="enscript-keyword">return</span>;
		}
		IGI_UNLOCK(igi);
	}
	panic(<span class="enscript-string">&quot;%s: igmp_ifinfo not found for ifp %p(%s)\n&quot;</span>, __func__,
	    ifp, ifp-&gt;if_xname);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_initsilent</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	ifnet_lock_assert(ifp, IFNET_LCK_ASSERT_OWNED);

	IGI_LOCK_ASSERT_NOTHELD(igi);
	IGI_LOCK(igi);
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_MULTICAST))
		igi-&gt;igi_flags |= IGIF_SILENT;
	<span class="enscript-keyword">else</span>
		igi-&gt;igi_flags &amp;= ~IGIF_SILENT;
	IGI_UNLOCK(igi);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igi_initvar</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> reattach)
{
	IGI_LOCK_ASSERT_HELD(igi);

	igi-&gt;igi_ifp = ifp;
	igi-&gt;igi_version = igmp_default_version;
	igi-&gt;igi_flags = 0;
	igi-&gt;igi_rv = IGMP_RV_INIT;
	igi-&gt;igi_qi = IGMP_QI_INIT;
	igi-&gt;igi_qri = IGMP_QRI_INIT;
	igi-&gt;igi_uri = IGMP_URI_INIT;

	<span class="enscript-keyword">if</span> (!reattach)
		SLIST_INIT(&amp;igi-&gt;igi_relinmhead);

	<span class="enscript-comment">/*
	 * Responses to general queries are subject to bounds.
	 */</span>
	igi-&gt;igi_gq.ifq_maxlen =  IGMP_MAX_RESPONSE_PACKETS;
	igi-&gt;igi_v2q.ifq_maxlen = IGMP_MAX_RESPONSE_PACKETS;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> igmp_ifinfo *
<span class="enscript-function-name">igi_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> igmp_ifinfo *igi;

	igi = (how == M_WAITOK) ? zalloc(igi_zone) : zalloc_noblock(igi_zone);
	<span class="enscript-keyword">if</span> (igi != NULL) {
		bzero(igi, igi_size);
		lck_mtx_init(&amp;igi-&gt;igi_lock, igmp_mtx_grp, igmp_mtx_attr);
		igi-&gt;igi_debug |= IFD_ALLOC;
	}
	<span class="enscript-keyword">return</span> (igi);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igi_free</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	IGI_LOCK(igi);
	<span class="enscript-keyword">if</span> (igi-&gt;igi_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: attached igi=%p is being freed&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_ifp != NULL) {
		panic(<span class="enscript-string">&quot;%s: ifp not NULL for igi=%p&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(igi-&gt;igi_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: igi %p cannot be freed&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_refcnt != 0) {
		panic(<span class="enscript-string">&quot;%s: non-zero refcnt igi=%p&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	igi-&gt;igi_debug &amp;= ~IFD_ALLOC;
	IGI_UNLOCK(igi);

	lck_mtx_destroy(&amp;igi-&gt;igi_lock, igmp_mtx_grp);
	zfree(igi_zone, igi);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">igi_addref</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IGI_LOCK_SPIN(igi);
	<span class="enscript-keyword">else</span>
		IGI_LOCK_ASSERT_HELD(igi);

	<span class="enscript-keyword">if</span> (++igi-&gt;igi_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: igi=%p wraparound refcnt&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (!locked)
		IGI_UNLOCK(igi);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">igi_remref</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	SLIST_HEAD(, in_multi) inm_dthead;
	<span class="enscript-type">struct</span> ifnet *ifp;

	IGI_LOCK_SPIN(igi);

	<span class="enscript-keyword">if</span> (igi-&gt;igi_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: igi=%p negative refcnt&quot;</span>, __func__, igi);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	--igi-&gt;igi_refcnt;
	<span class="enscript-keyword">if</span> (igi-&gt;igi_refcnt &gt; 0) {
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">return</span>;
	}

	ifp = igi-&gt;igi_ifp;
	igi-&gt;igi_ifp = NULL;
	IF_DRAIN(&amp;igi-&gt;igi_gq);
	IF_DRAIN(&amp;igi-&gt;igi_v2q);
	SLIST_INIT(&amp;inm_dthead);
	igmp_flush_relq(igi, (<span class="enscript-type">struct</span> igmp_inm_relhead *)&amp;inm_dthead);
	VERIFY(SLIST_EMPTY(&amp;igi-&gt;igi_relinmhead));
	IGI_UNLOCK(igi);

	<span class="enscript-comment">/* Now that we're dropped all locks, release detached records */</span>
	IGMP_REMOVE_DETACHED_INM(&amp;inm_dthead);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: freeing igmp_ifinfo for ifp 0x%llx(%s)\n&quot;</span>,
	    __func__, (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));

	igi_free(igi);
}

<span class="enscript-comment">/*
 * Process a received IGMPv1 query.
 * Return non-zero if the message should be dropped.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v1_query</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> igmp *igmp)
{
	<span class="enscript-type">struct</span> igmp_ifinfo	*igi;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">struct</span> in_multistep	step;
	<span class="enscript-type">struct</span> igmp_tparams	itp = { 0, 0, 0, 0 };

	IGMP_LOCK_ASSERT_NOTHELD();

	<span class="enscript-comment">/*
	 * IGMPv1 Host Membership Queries SHOULD always be addressed to
	 * 224.0.0.1. They are always treated as General Queries.
	 * igmp_group is always ignored. Do not drop it as a userland
	 * daemon may wish to see it.
	 */</span>
	<span class="enscript-keyword">if</span> (!in_allhosts(ip-&gt;ip_dst) || !in_nullhost(igmp-&gt;igmp_group)) {
		IGMPSTAT_INC(igps_rcv_badqueries);
		OIGMPSTAT_INC(igps_rcv_badqueries);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	IGMPSTAT_INC(igps_rcv_gen_queries);

	igi = IGMP_IFINFO(ifp);
	VERIFY(igi != NULL);

	IGI_LOCK(igi);
	<span class="enscript-keyword">if</span> (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: ignore v1 query on IGIF_LOOPBACK &quot;</span>
		    <span class="enscript-string">&quot;ifp 0x%llx(%s)\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * Switch to IGMPv1 host compatibility mode.
	 */</span>
	itp.qpt = igmp_set_version(igi, IGMP_VERSION_1);
	IGI_UNLOCK(igi);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: process v1 query on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));

	<span class="enscript-comment">/*
	 * Start the timers in all of our group records
	 * for the interface on which the query arrived,
	 * except those which are already running.
	 */</span>
	in_multihead_lock_shared();
	IN_FIRST_MULTI(step, inm);
	<span class="enscript-keyword">while</span> (inm != NULL) {
		INM_LOCK(inm);
		<span class="enscript-keyword">if</span> (inm-&gt;inm_ifp != ifp || inm-&gt;inm_timer != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

		<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
			inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
			inm-&gt;inm_timer = IGMP_RANDOM_DELAY(IGMP_V1V2_MAX_RI);
			itp.cst = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		}
<span class="enscript-reference">next</span>:
		INM_UNLOCK(inm);
		IN_NEXT_MULTI(step, inm);
	}
	in_multihead_lock_done();
<span class="enscript-reference">done</span>:
	igmp_set_timeout(&amp;itp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Process a received IGMPv2 general or group-specific query.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v2_query</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> igmp *igmp)
{
	<span class="enscript-type">struct</span> igmp_ifinfo	*igi;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">int</span>			 is_general_query;
	uint16_t		 timer;
	<span class="enscript-type">struct</span> igmp_tparams	 itp = { 0, 0, 0, 0 };

	IGMP_LOCK_ASSERT_NOTHELD();

	is_general_query = 0;

	<span class="enscript-comment">/*
	 * Validate address fields upfront.
	 */</span>
	<span class="enscript-keyword">if</span> (in_nullhost(igmp-&gt;igmp_group)) {
		<span class="enscript-comment">/*
		 * IGMPv2 General Query.
		 * If this was not sent to the all-hosts group, ignore it.
		 */</span>
		<span class="enscript-keyword">if</span> (!in_allhosts(ip-&gt;ip_dst))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		IGMPSTAT_INC(igps_rcv_gen_queries);
		is_general_query = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* IGMPv2 Group-Specific Query. */</span>
		IGMPSTAT_INC(igps_rcv_group_queries);
	}

	igi = IGMP_IFINFO(ifp);
	VERIFY(igi != NULL);

	IGI_LOCK(igi);
	<span class="enscript-keyword">if</span> (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: ignore v2 query on IGIF_LOOPBACK &quot;</span>
		    <span class="enscript-string">&quot;ifp 0x%llx(%s)\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * Ignore v2 query if in v1 Compatibility Mode.
	 */</span>
	<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_1) {
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	itp.qpt = igmp_set_version(igi, IGMP_VERSION_2);
	IGI_UNLOCK(igi);

	timer = igmp-&gt;igmp_code / IGMP_TIMER_SCALE;
	<span class="enscript-keyword">if</span> (timer == 0)
		timer = 1;

	<span class="enscript-keyword">if</span> (is_general_query) {
		<span class="enscript-type">struct</span> in_multistep step;

		IGMP_PRINTF((<span class="enscript-string">&quot;%s: process v2 general query on ifp 0x%llx(%s)\n&quot;</span>,
		    __func__, (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		<span class="enscript-comment">/*
		 * For each reporting group joined on this
		 * interface, kick the report timer.
		 */</span>
		in_multihead_lock_shared();
		IN_FIRST_MULTI(step, inm);
		<span class="enscript-keyword">while</span> (inm != NULL) {
			INM_LOCK(inm);
			<span class="enscript-keyword">if</span> (inm-&gt;inm_ifp == ifp)
				itp.cst += igmp_v2_update_group(inm, timer);
			INM_UNLOCK(inm);
			IN_NEXT_MULTI(step, inm);
		}
		in_multihead_lock_done();
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Group-specific IGMPv2 query, we need only
		 * look up the single group to process it.
		 */</span>
		in_multihead_lock_shared();
		IN_LOOKUP_MULTI(&amp;igmp-&gt;igmp_group, ifp, inm);
		in_multihead_lock_done();
		<span class="enscript-keyword">if</span> (inm != NULL) {
			INM_LOCK(inm);
			IGMP_INET_PRINTF(igmp-&gt;igmp_group,
			    (<span class="enscript-string">&quot;process v2 query %s on ifp 0x%llx(%s)\n&quot;</span>,
			    _igmp_inet_buf,
			    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
			itp.cst = igmp_v2_update_group(inm, timer);
			INM_UNLOCK(inm);
			INM_REMREF(inm); <span class="enscript-comment">/* from IN_LOOKUP_MULTI */</span>
		}
	}
<span class="enscript-reference">done</span>:
	igmp_set_timeout(&amp;itp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Update the report timer on a group in response to an IGMPv2 query.
 *
 * If we are becoming the reporting member for this group, start the timer.
 * If we already are the reporting member for this group, and timer is
 * below the threshold, reset it.
 *
 * We may be updating the group for the first time since we switched
 * to IGMPv3. If we are, then we must clear any recorded source lists,
 * and transition to REPORTING state; the group timer is overloaded
 * for group and group-source query responses. 
 *
 * Unlike IGMPv3, the delay per group should be jittered
 * to avoid bursts of IGMPv2 reports.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">igmp_v2_update_group</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">const</span> <span class="enscript-type">int</span> timer)
{

	IGMP_INET_PRINTF(inm-&gt;inm_addr, (<span class="enscript-string">&quot;%s: %s/%s timer=%d\n&quot;</span>,
	    __func__, _igmp_inet_buf, if_name(inm-&gt;inm_ifp),
	    timer));

	INM_LOCK_ASSERT_HELD(inm);

	<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
		<span class="enscript-keyword">if</span> (inm-&gt;inm_timer != 0 &amp;&amp;
		    inm-&gt;inm_timer &lt;= timer) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: REPORTING and timer running, &quot;</span>
			    <span class="enscript-string">&quot;skipping.\n&quot;</span>, __func__));
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: -&gt;REPORTING\n&quot;</span>, __func__));
		inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
		inm-&gt;inm_timer = IGMP_RANDOM_DELAY(timer);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: -&gt;AWAKENING\n&quot;</span>, __func__));
		inm-&gt;inm_state = IGMP_AWAKENING_MEMBER;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (inm-&gt;inm_timer);
}

<span class="enscript-comment">/*
 * Process a received IGMPv3 general, group-specific or
 * group-and-source-specific query.
 * Assumes m has already been pulled up to the full IGMP message length.
 * Return 0 if successful, otherwise an appropriate error code is returned.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v3_query</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmpv3 *igmpv3)
{
	<span class="enscript-type">struct</span> igmp_ifinfo	*igi;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">int</span>			 is_general_query;
	uint32_t		 maxresp, nsrc, qqi;
	uint16_t		 timer;
	uint8_t			 qrv;
	<span class="enscript-type">struct</span> igmp_tparams	 itp = { 0, 0, 0, 0 };

	IGMP_LOCK_ASSERT_NOTHELD();

	is_general_query = 0;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: process v3 query on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));

	maxresp = igmpv3-&gt;igmp_code;	<span class="enscript-comment">/* in 1/10ths of a second */</span>
	<span class="enscript-keyword">if</span> (maxresp &gt;= 128) {
		maxresp = IGMP_MANT(igmpv3-&gt;igmp_code) &lt;&lt;
			  (IGMP_EXP(igmpv3-&gt;igmp_code) + 3);
	}

	<span class="enscript-comment">/*
	 * Robustness must never be less than 2 for on-wire IGMPv3.
	 * FUTURE: Check if ifp has IGIF_LOOPBACK set, as we will make
	 * an exception for interfaces whose IGMPv3 state changes
	 * are redirected to loopback (e.g. MANET).
	 */</span>
	qrv = IGMP_QRV(igmpv3-&gt;igmp_misc);
	<span class="enscript-keyword">if</span> (qrv &lt; 2) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: clamping qrv %d to %d\n&quot;</span>, __func__,
		    qrv, IGMP_RV_INIT));
		qrv = IGMP_RV_INIT;
	}

	qqi = igmpv3-&gt;igmp_qqi;
	<span class="enscript-keyword">if</span> (qqi &gt;= 128) {
		qqi = IGMP_MANT(igmpv3-&gt;igmp_qqi) &lt;&lt;
		     (IGMP_EXP(igmpv3-&gt;igmp_qqi) + 3);
	}

	timer = maxresp / IGMP_TIMER_SCALE;
	<span class="enscript-keyword">if</span> (timer == 0)
		timer = 1;

	nsrc = ntohs(igmpv3-&gt;igmp_numsrc);

	<span class="enscript-comment">/*
	 * Validate address fields and versions upfront before
	 * accepting v3 query.
	 */</span>
	<span class="enscript-keyword">if</span> (in_nullhost(igmpv3-&gt;igmp_group)) {
		<span class="enscript-comment">/*
		 * IGMPv3 General Query.
		 *
		 * General Queries SHOULD be directed to 224.0.0.1.
		 * A general query with a source list has undefined
		 * behaviour; discard it.
		 */</span>
		IGMPSTAT_INC(igps_rcv_gen_queries);
		<span class="enscript-keyword">if</span> (!in_allhosts(ip-&gt;ip_dst) || nsrc &gt; 0) {
			IGMPSTAT_INC(igps_rcv_badqueries);
			OIGMPSTAT_INC(igps_rcv_badqueries);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		is_general_query = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Group or group-source specific query. */</span>
		<span class="enscript-keyword">if</span> (nsrc == 0)
			IGMPSTAT_INC(igps_rcv_group_queries);
		<span class="enscript-keyword">else</span>
			IGMPSTAT_INC(igps_rcv_gsr_queries);
	}

	igi = IGMP_IFINFO(ifp);
	VERIFY(igi != NULL);

	IGI_LOCK(igi);
	<span class="enscript-keyword">if</span> (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: ignore v3 query on IGIF_LOOPBACK &quot;</span>
		    <span class="enscript-string">&quot;ifp 0x%llx(%s)\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Discard the v3 query if we're in Compatibility Mode.
	 * The RFC is not obviously worded that hosts need to stay in
	 * compatibility mode until the Old Version Querier Present
	 * timer expires.
	 */</span>
	<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_3) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: ignore v3 query in v%d mode on &quot;</span>
		    <span class="enscript-string">&quot;ifp 0x%llx(%s)\n&quot;</span>, __func__, igi-&gt;igi_version,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	itp.qpt = igmp_set_version(igi, IGMP_VERSION_3);
	igi-&gt;igi_rv = qrv;
	igi-&gt;igi_qi = qqi;
	igi-&gt;igi_qri = MAX(timer, IGMP_QRI_MIN);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: qrv %d qi %d qri %d\n&quot;</span>, __func__, igi-&gt;igi_rv,
	    igi-&gt;igi_qi, igi-&gt;igi_qri));

	<span class="enscript-keyword">if</span> (is_general_query) {
		<span class="enscript-comment">/*
		 * Schedule a current-state report on this ifp for
		 * all groups, possibly containing source lists.
		 * If there is a pending General Query response
		 * scheduled earlier than the selected delay, do
		 * not schedule any other reports.
		 * Otherwise, reset the interface timer.
		 */</span>
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: process v3 general query on ifp 0x%llx(%s)\n&quot;</span>,
		    __func__, (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		<span class="enscript-keyword">if</span> (igi-&gt;igi_v3_timer == 0 || igi-&gt;igi_v3_timer &gt;= timer) {
			itp.it = igi-&gt;igi_v3_timer = IGMP_RANDOM_DELAY(timer);
		}
		IGI_UNLOCK(igi);
	} <span class="enscript-keyword">else</span> {
		IGI_UNLOCK(igi);
		<span class="enscript-comment">/*
		 * Group-source-specific queries are throttled on
		 * a per-group basis to defeat denial-of-service attempts.
		 * Queries for groups we are not a member of on this
		 * link are simply ignored.
		 */</span>
		in_multihead_lock_shared();
		IN_LOOKUP_MULTI(&amp;igmpv3-&gt;igmp_group, ifp, inm);
		in_multihead_lock_done();
		<span class="enscript-keyword">if</span> (inm == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

		INM_LOCK(inm);
		<span class="enscript-keyword">if</span> (nsrc &gt; 0) {
			<span class="enscript-keyword">if</span> (!ratecheck(&amp;inm-&gt;inm_lastgsrtv,
			    &amp;igmp_gsrdelay)) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: GS query throttled.\n&quot;</span>,
				    __func__));
				IGMPSTAT_INC(igps_drop_gsr_queries);
				INM_UNLOCK(inm);
				INM_REMREF(inm); <span class="enscript-comment">/* from IN_LOOKUP_MULTI */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
		IGMP_INET_PRINTF(igmpv3-&gt;igmp_group,
		    (<span class="enscript-string">&quot;process v3 %s query on ifp 0x%llx(%s)\n&quot;</span>, _igmp_inet_buf,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		<span class="enscript-comment">/*
		 * If there is a pending General Query response
		 * scheduled sooner than the selected delay, no
		 * further report need be scheduled.
		 * Otherwise, prepare to respond to the
		 * group-specific or group-and-source query.
		 */</span>
		IGI_LOCK(igi);
		itp.it = igi-&gt;igi_v3_timer;
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">if</span> (itp.it == 0 || itp.it &gt;= timer) {
			(<span class="enscript-type">void</span>) igmp_input_v3_group_query(inm, timer, igmpv3);
			itp.cst = inm-&gt;inm_timer;
		}
		INM_UNLOCK(inm);
		INM_REMREF(inm); <span class="enscript-comment">/* from IN_LOOKUP_MULTI */</span>
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (itp.it &gt; 0) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: v3 general query response scheduled in &quot;</span>
		    <span class="enscript-string">&quot;T+%d seconds on ifp 0x%llx(%s)\n&quot;</span>, __func__, itp.it,
		    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
	}
	igmp_set_timeout(&amp;itp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Process a recieved IGMPv3 group-specific or group-and-source-specific
 * query.
 * Return &lt;0 if any error occured. Currently this is ignored.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v3_group_query</span>(<span class="enscript-type">struct</span> in_multi *inm,
    <span class="enscript-type">int</span> timer, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmpv3 *igmpv3)
{
	<span class="enscript-type">int</span>			 retval;
	uint16_t		 nsrc;

	INM_LOCK_ASSERT_HELD(inm);

	retval = 0;

	<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
		<span class="enscript-keyword">return</span> (retval);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	}

	nsrc = ntohs(igmpv3-&gt;igmp_numsrc);

	<span class="enscript-comment">/*
	 * Deal with group-specific queries upfront.
	 * If any group query is already pending, purge any recorded
	 * source-list state if it exists, and schedule a query response
	 * for this group-specific query.
	 */</span>
	<span class="enscript-keyword">if</span> (nsrc == 0) {
		<span class="enscript-keyword">if</span> (inm-&gt;inm_state == IGMP_G_QUERY_PENDING_MEMBER ||
		    inm-&gt;inm_state == IGMP_SG_QUERY_PENDING_MEMBER) {
			inm_clear_recorded(inm);
			timer = min(inm-&gt;inm_timer, timer);
		}
		inm-&gt;inm_state = IGMP_G_QUERY_PENDING_MEMBER;
		inm-&gt;inm_timer = IGMP_RANDOM_DELAY(timer);
		<span class="enscript-keyword">return</span> (retval);
	}

	<span class="enscript-comment">/*
	 * Deal with the case where a group-and-source-specific query has
	 * been received but a group-specific query is already pending.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_state == IGMP_G_QUERY_PENDING_MEMBER) {
		timer = min(inm-&gt;inm_timer, timer);
		inm-&gt;inm_timer = IGMP_RANDOM_DELAY(timer);
		<span class="enscript-keyword">return</span> (retval);
	}

	<span class="enscript-comment">/*
	 * Finally, deal with the case where a group-and-source-specific
	 * query has been received, where a response to a previous g-s-r
	 * query exists, or none exists.
	 * In this case, we need to parse the source-list which the Querier
	 * has provided us with and check if we have any source list filter
	 * entries at T1 for these sources. If we do not, there is no need
	 * schedule a report and the query may be dropped.
	 * If we do, we must record them and schedule a current-state
	 * report for those sources.
	 * FIXME: Handling source lists larger than 1 mbuf requires that
	 * we pass the mbuf chain pointer down to this function, and use
	 * m_getptr() to walk the chain.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_nsrc &gt; 0) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr	*ap;
		<span class="enscript-type">int</span>			 i, nrecorded;

		ap = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *)(igmpv3 + 1);
		nrecorded = 0;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; nsrc; i++, ap++) {
			retval = inm_record_source(inm, ap-&gt;s_addr);
			<span class="enscript-keyword">if</span> (retval &lt; 0)
				<span class="enscript-keyword">break</span>;
			nrecorded += retval;
		}
		<span class="enscript-keyword">if</span> (nrecorded &gt; 0) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: schedule response to SG query\n&quot;</span>,
			    __func__));
			inm-&gt;inm_state = IGMP_SG_QUERY_PENDING_MEMBER;
			inm-&gt;inm_timer = IGMP_RANDOM_DELAY(timer);
		}
	}

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Process a received IGMPv1 host membership report.
 *
 * NOTE: 0.0.0.0 workaround breaks const correctness.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v1_report</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmp *igmp)
{
	<span class="enscript-type">struct</span> in_ifaddr *ia;
	<span class="enscript-type">struct</span> in_multi *inm;

	IGMPSTAT_INC(igps_rcv_reports);
	OIGMPSTAT_INC(igps_rcv_reports);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (!IN_MULTICAST(ntohl(igmp-&gt;igmp_group.s_addr) ||
	    !in_hosteq(igmp-&gt;igmp_group, ip-&gt;ip_dst))) {
		IGMPSTAT_INC(igps_rcv_badreports);
		OIGMPSTAT_INC(igps_rcv_badreports);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * RFC 3376, Section 4.2.13, 9.2, 9.3:
	 * Booting clients may use the source address 0.0.0.0. Some
	 * IGMP daemons may not know how to use IP_RECVIF to determine
	 * the interface upon which this message was received.
	 * Replace 0.0.0.0 with the subnet address if told to do so.
	 */</span>
	<span class="enscript-keyword">if</span> (igmp_recvifkludge &amp;&amp; in_nullhost(ip-&gt;ip_src)) {
		IFP_TO_IA(ifp, ia);
		<span class="enscript-keyword">if</span> (ia != NULL) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			ip-&gt;ip_src.s_addr = htonl(ia-&gt;ia_subnet);
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		}
	}

	IGMP_INET_PRINTF(igmp-&gt;igmp_group,
	    (<span class="enscript-string">&quot;process v1 report %s on ifp 0x%llx(%s)\n&quot;</span>, _igmp_inet_buf,
	    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));

	<span class="enscript-comment">/*
	 * IGMPv1 report suppression.
	 * If we are a member of this group, and our membership should be
	 * reported, stop our group timer and transition to the 'lazy' state.
	 */</span>
	in_multihead_lock_shared();
	IN_LOOKUP_MULTI(&amp;igmp-&gt;igmp_group, ifp, inm);
	in_multihead_lock_done();
	<span class="enscript-keyword">if</span> (inm != NULL) {
		<span class="enscript-type">struct</span> igmp_ifinfo *igi;

		INM_LOCK(inm);

		igi = inm-&gt;inm_igi;
		VERIFY(igi != NULL);

		IGMPSTAT_INC(igps_rcv_ourreports);
		OIGMPSTAT_INC(igps_rcv_ourreports);

		<span class="enscript-comment">/*
		 * If we are in IGMPv3 host mode, do not allow the
		 * other host's IGMPv1 report to suppress our reports
		 * unless explicitly configured to do so.
		 */</span>
		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_3) {
			<span class="enscript-keyword">if</span> (igmp_legacysupp)
				igmp_v3_suppress_group_record(inm);
			IGI_UNLOCK(igi);
			INM_UNLOCK(inm);
			INM_REMREF(inm); <span class="enscript-comment">/* from IN_LOOKUP_MULTI */</span>
			<span class="enscript-keyword">return</span> (0);
		}

		INM_LOCK_ASSERT_HELD(inm);
		inm-&gt;inm_timer = 0;

		<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
			IGMP_INET_PRINTF(igmp-&gt;igmp_group,
			    (<span class="enscript-string">&quot;report suppressed for %s on ifp 0x%llx(%s)\n&quot;</span>,
			    _igmp_inet_buf,
			    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
			inm-&gt;inm_state = IGMP_SLEEPING_MEMBER;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
			IGMP_INET_PRINTF(igmp-&gt;igmp_group,
			    (<span class="enscript-string">&quot;report suppressed for %s on ifp 0x%llx(%s)\n&quot;</span>,
			    _igmp_inet_buf,
			    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));
			<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_1)
				inm-&gt;inm_state = IGMP_LAZY_MEMBER;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_2)
				inm-&gt;inm_state = IGMP_SLEEPING_MEMBER;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		}
		IGI_UNLOCK(igi);
		INM_UNLOCK(inm);
		INM_REMREF(inm); <span class="enscript-comment">/* from IN_LOOKUP_MULTI */</span>
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Process a received IGMPv2 host membership report.
 *
 * NOTE: 0.0.0.0 workaround breaks const correctness.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_input_v2_report</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-comment">/*const*/</span> <span class="enscript-type">struct</span> igmp *igmp)
{
	<span class="enscript-type">struct</span> in_ifaddr *ia;
	<span class="enscript-type">struct</span> in_multi *inm;

	<span class="enscript-comment">/*
	 * Make sure we don't hear our own membership report.  Fast
	 * leave requires knowing that we are the only member of a
	 * group.
	 */</span>
	IFP_TO_IA(ifp, ia);
	<span class="enscript-keyword">if</span> (ia != NULL) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (in_hosteq(ip-&gt;ip_src, IA_SIN(ia)-&gt;sin_addr)) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">return</span> (0);
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}

	IGMPSTAT_INC(igps_rcv_reports);
	OIGMPSTAT_INC(igps_rcv_reports);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (!IN_MULTICAST(ntohl(igmp-&gt;igmp_group.s_addr)) ||
	    !in_hosteq(igmp-&gt;igmp_group, ip-&gt;ip_dst)) {
		<span class="enscript-keyword">if</span> (ia != NULL)
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		IGMPSTAT_INC(igps_rcv_badreports);
		OIGMPSTAT_INC(igps_rcv_badreports);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * RFC 3376, Section 4.2.13, 9.2, 9.3:
	 * Booting clients may use the source address 0.0.0.0. Some
	 * IGMP daemons may not know how to use IP_RECVIF to determine
	 * the interface upon which this message was received.
	 * Replace 0.0.0.0 with the subnet address if told to do so.
	 */</span>
	<span class="enscript-keyword">if</span> (igmp_recvifkludge &amp;&amp; in_nullhost(ip-&gt;ip_src)) {
		<span class="enscript-keyword">if</span> (ia != NULL) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			ip-&gt;ip_src.s_addr = htonl(ia-&gt;ia_subnet);
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
	}
	<span class="enscript-keyword">if</span> (ia != NULL)
		IFA_REMREF(&amp;ia-&gt;ia_ifa);

	IGMP_INET_PRINTF(igmp-&gt;igmp_group,
	    (<span class="enscript-string">&quot;process v2 report %s on ifp 0x%llx(%s)\n&quot;</span>, _igmp_inet_buf,
	    (uint64_t)VM_KERNEL_ADDRPERM(ifp), if_name(ifp)));

	<span class="enscript-comment">/*
	 * IGMPv2 report suppression.
	 * If we are a member of this group, and our membership should be
	 * reported, and our group timer is pending or about to be reset,
	 * stop our group timer by transitioning to the 'lazy' state.
	 */</span>
	in_multihead_lock_shared();
	IN_LOOKUP_MULTI(&amp;igmp-&gt;igmp_group, ifp, inm);
	in_multihead_lock_done();
	<span class="enscript-keyword">if</span> (inm != NULL) {
		<span class="enscript-type">struct</span> igmp_ifinfo *igi;

		INM_LOCK(inm);
		igi = inm-&gt;inm_igi;
		VERIFY(igi != NULL);

		IGMPSTAT_INC(igps_rcv_ourreports);
		OIGMPSTAT_INC(igps_rcv_ourreports);

		<span class="enscript-comment">/*
		 * If we are in IGMPv3 host mode, do not allow the
		 * other host's IGMPv1 report to suppress our reports
		 * unless explicitly configured to do so.
		 */</span>
		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_3) {
			<span class="enscript-keyword">if</span> (igmp_legacysupp)
				igmp_v3_suppress_group_record(inm);
			IGI_UNLOCK(igi);
			INM_UNLOCK(inm);
			INM_REMREF(inm);
			<span class="enscript-keyword">return</span> (0);
		}

		inm-&gt;inm_timer = 0;

		<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
			IGMP_INET_PRINTF(igmp-&gt;igmp_group,
			    (<span class="enscript-string">&quot;report suppressed for %s on ifp 0x%llx(%s)\n&quot;</span>,
			    _igmp_inet_buf, (uint64_t)VM_KERNEL_ADDRPERM(ifp),
			    if_name(ifp)));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
			inm-&gt;inm_state = IGMP_LAZY_MEMBER;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		}
		IGI_UNLOCK(igi);
		INM_UNLOCK(inm);
		INM_REMREF(inm);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off)
{
	<span class="enscript-type">int</span> iphlen;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> igmp *igmp;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">int</span> igmplen;
	<span class="enscript-type">int</span> minlen;
	<span class="enscript-type">int</span> queryver;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: called w/mbuf (0x%llx,%d)\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(m), off));

	ifp = m-&gt;m_pkthdr.rcvif;

	IGMPSTAT_INC(igps_rcv_total);
	OIGMPSTAT_INC(igps_rcv_total);

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	iphlen = off;

	<span class="enscript-comment">/* By now, ip_len no longer contains the length of IP header */</span>
	igmplen = ip-&gt;ip_len;

	<span class="enscript-comment">/*
	 * Validate lengths.
	 */</span>
	<span class="enscript-keyword">if</span> (igmplen &lt; IGMP_MINLEN) {
		IGMPSTAT_INC(igps_rcv_tooshort);
		OIGMPSTAT_INC(igps_rcv_tooshort);
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Always pullup to the minimum size for v1/v2 or v3
	 * to amortize calls to m_pulldown().
	 */</span>
	<span class="enscript-keyword">if</span> (igmplen &gt;= IGMP_V3_QUERY_MINLEN)
		minlen = IGMP_V3_QUERY_MINLEN;
	<span class="enscript-keyword">else</span>
		minlen = IGMP_MINLEN;

	<span class="enscript-comment">/* A bit more expensive than M_STRUCT_GET, but ensures alignment */</span>
	M_STRUCT_GET0(igmp, <span class="enscript-type">struct</span> igmp *, m, off, minlen);
	<span class="enscript-keyword">if</span> (igmp == NULL) {
		IGMPSTAT_INC(igps_rcv_tooshort);
		OIGMPSTAT_INC(igps_rcv_tooshort);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* N.B.: we assume the packet was correctly aligned in ip_input. */</span>

	<span class="enscript-comment">/*
	 * Validate checksum.
	 */</span>
	m-&gt;m_data += iphlen;
	m-&gt;m_len -= iphlen;
	<span class="enscript-keyword">if</span> (in_cksum(m, igmplen)) {
		IGMPSTAT_INC(igps_rcv_badsum);
		OIGMPSTAT_INC(igps_rcv_badsum);
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}
	m-&gt;m_data -= iphlen;
	m-&gt;m_len += iphlen;

	<span class="enscript-comment">/*
	 * IGMP control traffic is link-scope, and must have a TTL of 1.
	 * DVMRP traffic (e.g. mrinfo, mtrace) is an exception;
	 * probe packets may come from beyond the LAN.
	 */</span>
	<span class="enscript-keyword">if</span> (igmp-&gt;igmp_type != IGMP_DVMRP &amp;&amp; ip-&gt;ip_ttl != 1) {
		IGMPSTAT_INC(igps_rcv_badttl);
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">switch</span> (igmp-&gt;igmp_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_HOST_MEMBERSHIP_QUERY</span>:
		<span class="enscript-keyword">if</span> (igmplen == IGMP_MINLEN) {
			<span class="enscript-keyword">if</span> (igmp-&gt;igmp_code == 0)
				queryver = IGMP_VERSION_1;
			<span class="enscript-keyword">else</span>
				queryver = IGMP_VERSION_2;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igmplen &gt;= IGMP_V3_QUERY_MINLEN) {
			queryver = IGMP_VERSION_3;
		} <span class="enscript-keyword">else</span> {
			IGMPSTAT_INC(igps_rcv_tooshort);
			OIGMPSTAT_INC(igps_rcv_tooshort);
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}

		OIGMPSTAT_INC(igps_rcv_queries);

		<span class="enscript-keyword">switch</span> (queryver) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_1</span>:
			IGMPSTAT_INC(igps_rcv_v1v2_queries);
			<span class="enscript-keyword">if</span> (!igmp_v1enable)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (igmp_input_v1_query(ifp, ip, igmp) != 0) {
				m_freem(m);
				<span class="enscript-keyword">return</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_2</span>:
			IGMPSTAT_INC(igps_rcv_v1v2_queries);
			<span class="enscript-keyword">if</span> (!igmp_v2enable)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (igmp_input_v2_query(ifp, ip, igmp) != 0) {
				m_freem(m);
				<span class="enscript-keyword">return</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_3</span>: {
				<span class="enscript-type">struct</span> igmpv3 *igmpv3;
				uint16_t igmpv3len;
				uint16_t srclen;
				<span class="enscript-type">int</span> nsrc;

				IGMPSTAT_INC(igps_rcv_v3_queries);
				igmpv3 = (<span class="enscript-type">struct</span> igmpv3 *)igmp;
				<span class="enscript-comment">/*
				 * Validate length based on source count.
				 */</span>
				nsrc = ntohs(igmpv3-&gt;igmp_numsrc);
				srclen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) * nsrc;
				<span class="enscript-keyword">if</span> (igmplen &lt; (IGMP_V3_QUERY_MINLEN + srclen)) {
					IGMPSTAT_INC(igps_rcv_tooshort);
					OIGMPSTAT_INC(igps_rcv_tooshort);
					m_freem(m);
					<span class="enscript-keyword">return</span>;
				}
				igmpv3len = IGMP_V3_QUERY_MINLEN + srclen;
				<span class="enscript-comment">/*
				 * A bit more expensive than M_STRUCT_GET,
				 * but ensures alignment.
				 */</span>
				M_STRUCT_GET0(igmpv3, <span class="enscript-type">struct</span> igmpv3 *, m,
				    off, igmpv3len);
				<span class="enscript-keyword">if</span> (igmpv3 == NULL) {
					IGMPSTAT_INC(igps_rcv_tooshort);
					OIGMPSTAT_INC(igps_rcv_tooshort);
					<span class="enscript-keyword">return</span>;
				}
				<span class="enscript-comment">/* 
				 * N.B.: we assume the packet was correctly
				 * aligned in ip_input.
				 */</span>
				<span class="enscript-keyword">if</span> (igmp_input_v3_query(ifp, ip, igmpv3) != 0) {
					m_freem(m);
					<span class="enscript-keyword">return</span>;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_v1_HOST_MEMBERSHIP_REPORT</span>:
		<span class="enscript-keyword">if</span> (!igmp_v1enable)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (igmp_input_v1_report(ifp, m, ip, igmp) != 0) {
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_v2_HOST_MEMBERSHIP_REPORT</span>:
		<span class="enscript-keyword">if</span> (!igmp_v2enable)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!ip_checkrouteralert(m))
			IGMPSTAT_INC(igps_rcv_nora);
		<span class="enscript-keyword">if</span> (igmp_input_v2_report(ifp, m, ip, igmp) != 0) {
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_v3_HOST_MEMBERSHIP_REPORT</span>:
		<span class="enscript-comment">/*
		 * Hosts do not need to process IGMPv3 membership reports,
		 * as report suppression is no longer required.
		 */</span>
		<span class="enscript-keyword">if</span> (!ip_checkrouteralert(m))
			IGMPSTAT_INC(igps_rcv_nora);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	IGMP_LOCK_ASSERT_NOTHELD();
	<span class="enscript-comment">/*
	 * Pass all valid IGMP packets up to any process(es) listening on a
	 * raw IGMP socket.
	 */</span>
	rip_input(m, off);
}

<span class="enscript-comment">/*
 * Schedule IGMP timer based on various parameters; caller must ensure that
 * lock ordering is maintained as this routine acquires IGMP global lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_set_timeout</span>(<span class="enscript-type">struct</span> igmp_tparams *itp)
{
	IGMP_LOCK_ASSERT_NOTHELD();
	VERIFY(itp != NULL);

	<span class="enscript-keyword">if</span> (itp-&gt;qpt != 0 || itp-&gt;it != 0 || itp-&gt;cst != 0 || itp-&gt;sct != 0) {
		IGMP_LOCK();
		<span class="enscript-keyword">if</span> (itp-&gt;qpt != 0)
			querier_present_timers_running = 1;
		<span class="enscript-keyword">if</span> (itp-&gt;it != 0)
			interface_timers_running = 1;
		<span class="enscript-keyword">if</span> (itp-&gt;cst != 0)
			current_state_timers_running = 1;
		<span class="enscript-keyword">if</span> (itp-&gt;sct != 0)
			state_change_timers_running = 1;
		igmp_sched_timeout();
		IGMP_UNLOCK();
	}
}

<span class="enscript-comment">/*
 * IGMP timer handler (per 1 second).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_timeout</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> ifqueue		 scq;	<span class="enscript-comment">/* State-change packets */</span>
	<span class="enscript-type">struct</span> ifqueue		 qrq;	<span class="enscript-comment">/* Query response packets */</span>
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> igmp_ifinfo	*igi;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">int</span>			 loop = 0, uri_sec = 0;
	SLIST_HEAD(, in_multi)	inm_dthead;

	SLIST_INIT(&amp;inm_dthead);

	<span class="enscript-comment">/*
	 * Update coarse-grained networking timestamp (in sec.); the idea
	 * is to piggy-back on the timeout callout to update the counter
	 * returnable via net_uptime().
	 */</span>
	net_update_uptime();

	IGMP_LOCK();

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: qpt %d, it %d, cst %d, sct %d\n&quot;</span>, __func__,
	    querier_present_timers_running, interface_timers_running,
	    current_state_timers_running, state_change_timers_running));

	<span class="enscript-comment">/*
	 * IGMPv1/v2 querier present timer processing.
	 */</span>
	<span class="enscript-keyword">if</span> (querier_present_timers_running) {
		querier_present_timers_running = 0;
		LIST_FOREACH(igi, &amp;igi_head, igi_link) {
			IGI_LOCK(igi);
			igmp_v1v2_process_querier_timers(igi);
			<span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer &gt; 0 || igi-&gt;igi_v2_timer &gt; 0)
				querier_present_timers_running = 1;
			IGI_UNLOCK(igi);
		}
	}

	<span class="enscript-comment">/*
	 * IGMPv3 General Query response timer processing.
	 */</span>
	<span class="enscript-keyword">if</span> (interface_timers_running) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: interface timers running\n&quot;</span>, __func__));
		interface_timers_running = 0;
		LIST_FOREACH(igi, &amp;igi_head, igi_link) {
			IGI_LOCK(igi);
			<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_3) {
				IGI_UNLOCK(igi);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (igi-&gt;igi_v3_timer == 0) {
				<span class="enscript-comment">/* Do nothing. */</span>
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--igi-&gt;igi_v3_timer == 0) {
				<span class="enscript-keyword">if</span> (igmp_v3_dispatch_general_query(igi) &gt; 0)
					interface_timers_running = 1;
			} <span class="enscript-keyword">else</span> {
				interface_timers_running = 1;
			}
			IGI_UNLOCK(igi);
		}
	}

	<span class="enscript-keyword">if</span> (!current_state_timers_running &amp;&amp;
	    !state_change_timers_running)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_locked</span>;

	current_state_timers_running = 0;
	state_change_timers_running = 0;

	memset(&amp;qrq, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ifqueue));
	qrq.ifq_maxlen = IGMP_MAX_G_GS_PACKETS;

	memset(&amp;scq, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ifqueue));
	scq.ifq_maxlen =  IGMP_MAX_STATE_CHANGE_PACKETS;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: state change timers running\n&quot;</span>, __func__));

	<span class="enscript-comment">/*
	 * IGMPv1/v2/v3 host report and state-change timer processing.
	 * Note: Processing a v3 group timer may remove a node.
	 */</span>
	LIST_FOREACH(igi, &amp;igi_head, igi_link) {
		<span class="enscript-type">struct</span> in_multistep step;

		IGI_LOCK(igi);
		ifp = igi-&gt;igi_ifp;
		loop = (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) ? 1 : 0;
		uri_sec = IGMP_RANDOM_DELAY(igi-&gt;igi_uri);
		IGI_UNLOCK(igi);

		in_multihead_lock_shared();
		IN_FIRST_MULTI(step, inm);
		<span class="enscript-keyword">while</span> (inm != NULL) {
			INM_LOCK(inm);
			<span class="enscript-keyword">if</span> (inm-&gt;inm_ifp != ifp)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

			IGI_LOCK(igi);
			<span class="enscript-keyword">switch</span> (igi-&gt;igi_version) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_1</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_2</span>:
					igmp_v1v2_process_group_timer(inm,
					    igi-&gt;igi_version);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_3</span>:
					igmp_v3_process_group_timers(igi, &amp;qrq,
					    &amp;scq, inm, uri_sec);
					<span class="enscript-keyword">break</span>;
			}
			IGI_UNLOCK(igi);
<span class="enscript-reference">next</span>:
			INM_UNLOCK(inm);
			IN_NEXT_MULTI(step, inm);
		}
		in_multihead_lock_done();

		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_1 ||
		    igi-&gt;igi_version == IGMP_VERSION_2) {
			igmp_dispatch_queue(igi, &amp;igi-&gt;igi_v2q, 0, loop);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_3) {
			IGI_UNLOCK(igi);
			igmp_dispatch_queue(NULL, &amp;qrq, 0, loop);
			igmp_dispatch_queue(NULL, &amp;scq, 0, loop);
			VERIFY(qrq.ifq_len == 0);
			VERIFY(scq.ifq_len == 0);
			IGI_LOCK(igi);
		}
		<span class="enscript-comment">/*
		 * In case there are still any pending membership reports
		 * which didn't get drained at version change time.
		 */</span>
		IF_DRAIN(&amp;igi-&gt;igi_v2q);
		<span class="enscript-comment">/*
		 * Release all deferred inm records, and drain any locally
		 * enqueued packets; do it even if the current IGMP version
		 * for the link is no longer IGMPv3, in order to handle the
		 * version change case.
		 */</span>
		igmp_flush_relq(igi, (<span class="enscript-type">struct</span> igmp_inm_relhead *)&amp;inm_dthead);
		VERIFY(SLIST_EMPTY(&amp;igi-&gt;igi_relinmhead));
		IGI_UNLOCK(igi);

		IF_DRAIN(&amp;qrq);
		IF_DRAIN(&amp;scq);
	}

<span class="enscript-reference">out_locked</span>:
	<span class="enscript-comment">/* re-arm the timer if there's work to do */</span>
	igmp_timeout_run = 0;
	igmp_sched_timeout();
	IGMP_UNLOCK();

	<span class="enscript-comment">/* Now that we're dropped all locks, release detached records */</span>
	IGMP_REMOVE_DETACHED_INM(&amp;inm_dthead);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_sched_timeout</span>(<span class="enscript-type">void</span>)
{
	IGMP_LOCK_ASSERT_HELD();

	<span class="enscript-keyword">if</span> (!igmp_timeout_run &amp;&amp;
	    (querier_present_timers_running || current_state_timers_running ||
	    interface_timers_running || state_change_timers_running)) {
		igmp_timeout_run = 1;
		timeout(igmp_timeout, NULL, hz);
	}
}

<span class="enscript-comment">/*
 * Free the in_multi reference(s) for this IGMP lifecycle.
 *
 * Caller must be holding igi_lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_flush_relq</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi, <span class="enscript-type">struct</span> igmp_inm_relhead *inm_dthead)
{
	<span class="enscript-type">struct</span> in_multi *inm;

<span class="enscript-reference">again</span>:
	IGI_LOCK_ASSERT_HELD(igi);
	inm = SLIST_FIRST(&amp;igi-&gt;igi_relinmhead);
	<span class="enscript-keyword">if</span> (inm != NULL) {
		<span class="enscript-type">int</span> lastref;

		SLIST_REMOVE_HEAD(&amp;igi-&gt;igi_relinmhead, inm_nrele);
		IGI_UNLOCK(igi);

		in_multihead_lock_exclusive();
		INM_LOCK(inm);
		VERIFY(inm-&gt;inm_nrelecnt != 0);
		inm-&gt;inm_nrelecnt--;
		lastref = in_multi_detach(inm);
		VERIFY(!lastref || (!(inm-&gt;inm_debug &amp; IFD_ATTACHED) &amp;&amp;
		    inm-&gt;inm_reqcnt == 0));
		INM_UNLOCK(inm);
		in_multihead_lock_done();
		<span class="enscript-comment">/* from igi_relinmhead */</span>
		INM_REMREF(inm);
		<span class="enscript-comment">/* from in_multihead list */</span>
		<span class="enscript-keyword">if</span> (lastref) {
			<span class="enscript-comment">/*
			 * Defer releasing our final reference, as we
			 * are holding the IGMP lock at this point, and
			 * we could end up with locking issues later on
			 * (while issuing SIOCDELMULTI) when this is the
			 * final reference count.  Let the caller do it
			 * when it is safe.
			 */</span>
			IGMP_ADD_DETACHED_INM(inm_dthead, inm);
		}
		IGI_LOCK(igi);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
}

<span class="enscript-comment">/*
 * Update host report group timer for IGMPv1/v2.
 * Will update the global pending timer flags.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_v1v2_process_group_timer</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">const</span> <span class="enscript-type">int</span> igmp_version)
{
	<span class="enscript-type">int</span> report_timer_expired;

	IGMP_LOCK_ASSERT_HELD();
	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_HELD(inm-&gt;inm_igi);

	<span class="enscript-keyword">if</span> (inm-&gt;inm_timer == 0) {
		report_timer_expired = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--inm-&gt;inm_timer == 0) {
		report_timer_expired = 1;
	} <span class="enscript-keyword">else</span> {
		current_state_timers_running = 1;
		<span class="enscript-comment">/* caller will schedule timer */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
		<span class="enscript-keyword">if</span> (report_timer_expired) {
			inm-&gt;inm_state = IGMP_IDLE_MEMBER;
			(<span class="enscript-type">void</span>) igmp_v1v2_queue_report(inm,
			    (igmp_version == IGMP_VERSION_2) ?
			     IGMP_v2_HOST_MEMBERSHIP_REPORT :
			     IGMP_v1_HOST_MEMBERSHIP_REPORT);
			INM_LOCK_ASSERT_HELD(inm);
			IGI_LOCK_ASSERT_HELD(inm-&gt;inm_igi);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Update a group's timers for IGMPv3.
 * Will update the global pending timer flags.
 * Note: Unlocked read from igi.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_v3_process_group_timers</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi,
    <span class="enscript-type">struct</span> ifqueue *qrq, <span class="enscript-type">struct</span> ifqueue *scq,
    <span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">const</span> <span class="enscript-type">int</span> uri_sec)
{
	<span class="enscript-type">int</span> query_response_timer_expired;
	<span class="enscript-type">int</span> state_change_retransmit_timer_expired;

	IGMP_LOCK_ASSERT_HELD();
	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_HELD(igi);
	VERIFY(igi == inm-&gt;inm_igi);

	query_response_timer_expired = 0;
	state_change_retransmit_timer_expired = 0;

	<span class="enscript-comment">/*
	 * During a transition from v1/v2 compatibility mode back to v3,
	 * a group record in REPORTING state may still have its group
	 * timer active. This is a no-op in this function; it is easier
	 * to deal with it here than to complicate the timeout path.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_timer == 0) {
		query_response_timer_expired = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--inm-&gt;inm_timer == 0) {
		query_response_timer_expired = 1;
	} <span class="enscript-keyword">else</span> {
		current_state_timers_running = 1;
		<span class="enscript-comment">/* caller will schedule timer */</span>
	}

	<span class="enscript-keyword">if</span> (inm-&gt;inm_sctimer == 0) {
		state_change_retransmit_timer_expired = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--inm-&gt;inm_sctimer == 0) {
		state_change_retransmit_timer_expired = 1;
	} <span class="enscript-keyword">else</span> {
		state_change_timers_running = 1;
		<span class="enscript-comment">/* caller will schedule timer */</span>
	}

	<span class="enscript-comment">/* We are in timer callback, so be quick about it. */</span>
	<span class="enscript-keyword">if</span> (!state_change_retransmit_timer_expired &amp;&amp;
	    !query_response_timer_expired)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-comment">/*
		 * Respond to a previously pending Group-Specific
		 * or Group-and-Source-Specific query by enqueueing
		 * the appropriate Current-State report for
		 * immediate transmission.
		 */</span>
		<span class="enscript-keyword">if</span> (query_response_timer_expired) {
			<span class="enscript-type">int</span> retval;

			retval = igmp_v3_enqueue_group_record(qrq, inm, 0, 1,
			    (inm-&gt;inm_state == IGMP_SG_QUERY_PENDING_MEMBER));
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueue record = %d\n&quot;</span>,
			    __func__, retval));
			inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
			<span class="enscript-comment">/* XXX Clear recorded sources for next time. */</span>
			inm_clear_recorded(inm);
		}
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
		<span class="enscript-keyword">if</span> (state_change_retransmit_timer_expired) {
			<span class="enscript-comment">/*
			 * State-change retransmission timer fired.
			 * If there are any further pending retransmissions,
			 * set the global pending state-change flag, and
			 * reset the timer.
			 */</span>
			<span class="enscript-keyword">if</span> (--inm-&gt;inm_scrv &gt; 0) {
				inm-&gt;inm_sctimer = uri_sec;
				state_change_timers_running = 1;
				<span class="enscript-comment">/* caller will schedule timer */</span>
			}
			<span class="enscript-comment">/*
			 * Retransmit the previously computed state-change
			 * report. If there are no further pending
			 * retransmissions, the mbuf queue will be consumed.
			 * Update T0 state to T1 as we have now sent
			 * a state-change.
			 */</span>
			(<span class="enscript-type">void</span>) igmp_v3_merge_state_changes(inm, scq);

			inm_commit(inm);
			IGMP_INET_PRINTF(inm-&gt;inm_addr,
			    (<span class="enscript-string">&quot;%s: T1 -&gt; T0 for %s/%s\n&quot;</span>, __func__,
			    _igmp_inet_buf, if_name(inm-&gt;inm_ifp)));

			<span class="enscript-comment">/*
			 * If we are leaving the group for good, make sure
			 * we release IGMP's reference to it.
			 * This release must be deferred using a SLIST,
			 * as we are called from a loop which traverses
			 * the in_multihead list.
			 */</span>
			<span class="enscript-keyword">if</span> (inm-&gt;inm_state == IGMP_LEAVING_MEMBER &amp;&amp;
			    inm-&gt;inm_scrv == 0) {
				inm-&gt;inm_state = IGMP_NOT_MEMBER;
				<span class="enscript-comment">/*
				 * A reference has already been held in
				 * igmp_final_leave() for this inm, so
				 * no need to hold another one.  We also
				 * bumped up its request count then, so
				 * that it stays in in_multihead.  Both
				 * of them will be released when it is
				 * dequeued later on.
				 */</span>
				VERIFY(inm-&gt;inm_nrelecnt != 0);
				SLIST_INSERT_HEAD(&amp;igi-&gt;igi_relinmhead,
				    inm, inm_nrele);
			}
		}
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Suppress a group's pending response to a group or source/group query.
 *
 * Do NOT suppress state changes. This leads to IGMPv3 inconsistency.
 * Do NOT update ST1/ST0 as this operation merely suppresses
 * the currently pending group record.
 * Do NOT suppress the response to a general query. It is possible but
 * it would require adding another state or flag.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_v3_suppress_group_record</span>(<span class="enscript-type">struct</span> in_multi *inm)
{

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_HELD(inm-&gt;inm_igi);

	VERIFY(inm-&gt;inm_igi-&gt;igi_version == IGMP_VERSION_3);

	<span class="enscript-keyword">if</span> (inm-&gt;inm_state != IGMP_G_QUERY_PENDING_MEMBER ||
	    inm-&gt;inm_state != IGMP_SG_QUERY_PENDING_MEMBER)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (inm-&gt;inm_state == IGMP_SG_QUERY_PENDING_MEMBER)
		inm_clear_recorded(inm);

	inm-&gt;inm_timer = 0;
	inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
}

<span class="enscript-comment">/*
 * Switch to a different IGMP version on the given interface,
 * as per Section 7.2.1.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">igmp_set_version</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi, <span class="enscript-type">const</span> <span class="enscript-type">int</span> igmp_version)
{
	<span class="enscript-type">int</span> old_version_timer;

	IGI_LOCK_ASSERT_HELD(igi);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: switching to v%d on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    igmp_version, (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
	    if_name(igi-&gt;igi_ifp)));

	<span class="enscript-keyword">if</span> (igmp_version == IGMP_VERSION_1 || igmp_version == IGMP_VERSION_2) {
		<span class="enscript-comment">/*
		 * Compute the &quot;Older Version Querier Present&quot; timer as per
		 * Section 8.12, in seconds.
		 */</span>
		old_version_timer = igi-&gt;igi_rv * igi-&gt;igi_qi + igi-&gt;igi_qri;

		<span class="enscript-keyword">if</span> (igmp_version == IGMP_VERSION_1) {
			igi-&gt;igi_v1_timer = old_version_timer;
			igi-&gt;igi_v2_timer = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igmp_version == IGMP_VERSION_2) {
			igi-&gt;igi_v1_timer = 0;
			igi-&gt;igi_v2_timer = old_version_timer;
		}
	}

	<span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer == 0 &amp;&amp; igi-&gt;igi_v2_timer &gt; 0) {
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_2) {
			igi-&gt;igi_version = IGMP_VERSION_2;
			igmp_v3_cancel_link_timers(igi);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer &gt; 0) {
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_1) {
			igi-&gt;igi_version = IGMP_VERSION_1;
			igmp_v3_cancel_link_timers(igi);
		}
	}

	IGI_LOCK_ASSERT_HELD(igi);

	<span class="enscript-keyword">return</span> (MAX(igi-&gt;igi_v1_timer, igi-&gt;igi_v2_timer));
}

<span class="enscript-comment">/*
 * Cancel pending IGMPv3 timers for the given link and all groups
 * joined on it; state-change, general-query, and group-query timers.
 *
 * Only ever called on a transition from v3 to Compatibility mode. Kill
 * the timers stone dead (this may be expensive for large N groups), they
 * will be restarted if Compatibility Mode deems that they must be due to
 * query processing.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_v3_cancel_link_timers</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">struct</span> in_multistep	step;

	IGI_LOCK_ASSERT_HELD(igi);

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: cancel v3 timers on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp), if_name(igi-&gt;igi_ifp)));

	<span class="enscript-comment">/*
	 * Stop the v3 General Query Response on this link stone dead.
	 * If timer is woken up due to interface_timers_running,
	 * the flag will be cleared if there are no pending link timers.
	 */</span>
	igi-&gt;igi_v3_timer = 0;

	<span class="enscript-comment">/*
	 * Now clear the current-state and state-change report timers
	 * for all memberships scoped to this link.
	 */</span>
	ifp = igi-&gt;igi_ifp;
	IGI_UNLOCK(igi);

	in_multihead_lock_shared();
	IN_FIRST_MULTI(step, inm);
	<span class="enscript-keyword">while</span> (inm != NULL) {
		INM_LOCK(inm);
		<span class="enscript-keyword">if</span> (inm-&gt;inm_ifp != ifp)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

		<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
			<span class="enscript-comment">/*
			 * These states are either not relevant in v3 mode,
			 * or are unreported. Do nothing.
			 */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
			<span class="enscript-comment">/*
			 * If we are leaving the group and switching to
			 * compatibility mode, we need to release the final
			 * reference held for issuing the INCLUDE {}, and
			 * transition to REPORTING to ensure the host leave
			 * message is sent upstream to the old querier --
			 * transition to NOT would lose the leave and race.
			 * During igmp_final_leave(), we bumped up both the
			 * request and reference counts.  Since we cannot
			 * call in_multi_detach() here, defer this task to
			 * the timer routine.
			 */</span>
			VERIFY(inm-&gt;inm_nrelecnt != 0);
			IGI_LOCK(igi);
			SLIST_INSERT_HEAD(&amp;igi-&gt;igi_relinmhead, inm, inm_nrele);
			IGI_UNLOCK(igi);
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
			inm_clear_recorded(inm);
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
			inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Always clear state-change and group report timers.
		 * Free any pending IGMPv3 state-change records.
		 */</span>
		inm-&gt;inm_sctimer = 0;
		inm-&gt;inm_timer = 0;
		IF_DRAIN(&amp;inm-&gt;inm_scq);
<span class="enscript-reference">next</span>:
		INM_UNLOCK(inm);
		IN_NEXT_MULTI(step, inm);
	}
	in_multihead_lock_done();

	IGI_LOCK(igi);
}

<span class="enscript-comment">/*
 * Update the Older Version Querier Present timers for a link.
 * See Section 7.2.1 of RFC 3376.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_v1v2_process_querier_timers</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	IGI_LOCK_ASSERT_HELD(igi);

	<span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer == 0 &amp;&amp; igi-&gt;igi_v2_timer == 0) {
		<span class="enscript-comment">/*
		 * IGMPv1 and IGMPv2 Querier Present timers expired.
		 *
		 * Revert to IGMPv3.
		 */</span>
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_3) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: transition from v%d -&gt; v%d &quot;</span>
			    <span class="enscript-string">&quot;on 0x%llx(%s)\n&quot;</span>, __func__,
			    igi-&gt;igi_version, IGMP_VERSION_3,
			    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
			    if_name(igi-&gt;igi_ifp)));
			igi-&gt;igi_version = IGMP_VERSION_3;
			IF_DRAIN(&amp;igi-&gt;igi_v2q);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer == 0 &amp;&amp; igi-&gt;igi_v2_timer &gt; 0) {
		<span class="enscript-comment">/*
		 * IGMPv1 Querier Present timer expired,
		 * IGMPv2 Querier Present timer running.
		 * If IGMPv2 was disabled since last timeout,
		 * revert to IGMPv3.
		 * If IGMPv2 is enabled, revert to IGMPv2.
		 */</span>
		<span class="enscript-keyword">if</span> (!igmp_v2enable) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: transition from v%d -&gt; v%d &quot;</span>
			    <span class="enscript-string">&quot;on 0x%llx(%s%d)\n&quot;</span>, __func__,
			    igi-&gt;igi_version, IGMP_VERSION_3,
			    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
			    igi-&gt;igi_ifp-&gt;if_name, igi-&gt;igi_ifp-&gt;if_unit));
			igi-&gt;igi_v2_timer = 0;
			igi-&gt;igi_version = IGMP_VERSION_3;
			IF_DRAIN(&amp;igi-&gt;igi_v2q);
		} <span class="enscript-keyword">else</span> {
			--igi-&gt;igi_v2_timer;
			<span class="enscript-keyword">if</span> (igi-&gt;igi_version != IGMP_VERSION_2) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: transition from v%d -&gt; v%d &quot;</span>
				    <span class="enscript-string">&quot;on 0x%llx(%s)\n&quot;</span>, __func__,
				    igi-&gt;igi_version, IGMP_VERSION_2,
				    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
				    if_name(igi-&gt;igi_ifp)));
				igi-&gt;igi_version = IGMP_VERSION_2;
				IF_DRAIN(&amp;igi-&gt;igi_gq);
				igmp_v3_cancel_link_timers(igi);
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_v1_timer &gt; 0) {
		<span class="enscript-comment">/*
		 * IGMPv1 Querier Present timer running.
		 * Stop IGMPv2 timer if running.
		 *
		 * If IGMPv1 was disabled since last timeout,
		 * revert to IGMPv3.
		 * If IGMPv1 is enabled, reset IGMPv2 timer if running.
		 */</span>
		<span class="enscript-keyword">if</span> (!igmp_v1enable) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: transition from v%d -&gt; v%d &quot;</span>
			    <span class="enscript-string">&quot;on 0x%llx(%s%d)\n&quot;</span>, __func__,
			    igi-&gt;igi_version, IGMP_VERSION_3,
			    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
			    igi-&gt;igi_ifp-&gt;if_name, igi-&gt;igi_ifp-&gt;if_unit));
			igi-&gt;igi_v1_timer = 0;
			igi-&gt;igi_version = IGMP_VERSION_3;
			IF_DRAIN(&amp;igi-&gt;igi_v2q);
		} <span class="enscript-keyword">else</span> {
			--igi-&gt;igi_v1_timer;
		}
		<span class="enscript-keyword">if</span> (igi-&gt;igi_v2_timer &gt; 0) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: cancel v2 timer on 0x%llx(%s%d)\n&quot;</span>,
			    __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(igi-&gt;igi_ifp),
			    igi-&gt;igi_ifp-&gt;if_name, igi-&gt;igi_ifp-&gt;if_unit));
			igi-&gt;igi_v2_timer = 0;
		}
	}
}

<span class="enscript-comment">/*
 * Dispatch an IGMPv1/v2 host report or leave message.
 * These are always small enough to fit inside a single mbuf.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_v1v2_queue_report</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">const</span> <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> igmp		*igmp;
	<span class="enscript-type">struct</span> ip		*ip;
	<span class="enscript-type">struct</span> mbuf		*m;
	<span class="enscript-type">int</span>			error = 0;

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_HELD(inm-&gt;inm_igi);

	ifp = inm-&gt;inm_ifp;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	MH_ALIGN(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp));

	m-&gt;m_pkthdr.len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp);

	m-&gt;m_data += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp);

	igmp = mtod(m, <span class="enscript-type">struct</span> igmp *);
	igmp-&gt;igmp_type = type;
	igmp-&gt;igmp_code = 0;
	igmp-&gt;igmp_group = inm-&gt;inm_addr;
	igmp-&gt;igmp_cksum = 0;
	igmp-&gt;igmp_cksum = in_cksum(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp));

	m-&gt;m_data -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	m-&gt;m_len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	ip-&gt;ip_tos = 0;
	ip-&gt;ip_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp);
	ip-&gt;ip_off = 0;
	ip-&gt;ip_p = IPPROTO_IGMP;
	ip-&gt;ip_src.s_addr = INADDR_ANY;

	<span class="enscript-keyword">if</span> (type == IGMP_HOST_LEAVE_MESSAGE)
		ip-&gt;ip_dst.s_addr = htonl(INADDR_ALLRTRS_GROUP);
	<span class="enscript-keyword">else</span>
		ip-&gt;ip_dst = inm-&gt;inm_addr;

	igmp_save_context(m, ifp);

	m-&gt;m_flags |= M_IGMPV2;
	<span class="enscript-keyword">if</span> (inm-&gt;inm_igi-&gt;igi_flags &amp; IGIF_LOOPBACK)
		m-&gt;m_flags |= M_IGMP_LOOP;

	<span class="enscript-comment">/*
	 * Due to the fact that at this point we are possibly holding
	 * in_multihead_lock in shared or exclusive mode, we can't call
	 * igmp_sendpkt() here since that will eventually call ip_output(),
	 * which will try to lock in_multihead_lock and cause a deadlock.
	 * Instead we defer the work to the igmp_timeout() thread, thus
	 * avoiding unlocking in_multihead_lock here.
	 */</span>
	<span class="enscript-keyword">if</span> (IF_QFULL(&amp;inm-&gt;inm_igi-&gt;igi_v2q)) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: v1/v2 outbound queue full\n&quot;</span>, __func__));
		error = ENOMEM;
		m_freem(m);
	} <span class="enscript-keyword">else</span> {
		IF_ENQUEUE(&amp;inm-&gt;inm_igi-&gt;igi_v2q, m);
		VERIFY(error == 0);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Process a state change from the upper layer for the given IPv4 group.
 *
 * Each socket holds a reference on the in_multi in its own ip_moptions.
 * The socket layer will have made the necessary updates to the group
 * state, it is now up to IGMP to issue a state change report if there
 * has been any change between T0 (when the last state-change was issued)
 * and T1 (now).
 *
 * We use the IGMPv3 state machine at group level. The IGMP module
 * however makes the decision as to which IGMP protocol version to speak.
 * A state change *from* INCLUDE {} always means an initial join.
 * A state change *to* INCLUDE {} always means a final leave.
 *
 * FUTURE: If IGIF_V3LITE is enabled for this interface, then we can
 * save ourselves a bunch of work; any exclusive mode groups need not
 * compute source filter lists.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_change_state</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">struct</span> igmp_tparams *itp)
{
	<span class="enscript-type">struct</span> igmp_ifinfo *igi;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(itp != NULL);
	bzero(itp, <span class="enscript-keyword">sizeof</span> (*itp));

	INM_LOCK_ASSERT_HELD(inm);
	VERIFY(inm-&gt;inm_igi != NULL);
	IGI_LOCK_ASSERT_NOTHELD(inm-&gt;inm_igi);

	<span class="enscript-comment">/*
	 * Try to detect if the upper layer just asked us to change state
	 * for an interface which has now gone away.
	 */</span>
	VERIFY(inm-&gt;inm_ifma != NULL);
	ifp = inm-&gt;inm_ifma-&gt;ifma_ifp;
	<span class="enscript-comment">/*
	 * Sanity check that netinet's notion of ifp is the same as net's.
	 */</span>
	VERIFY(inm-&gt;inm_ifp == ifp);

	igi = IGMP_IFINFO(ifp);
	VERIFY(igi != NULL);

	<span class="enscript-comment">/*
	 * If we detect a state transition to or from MCAST_UNDEFINED
	 * for this group, then we are starting or finishing an IGMP
	 * life cycle for this group.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_st[1].iss_fmode != inm-&gt;inm_st[0].iss_fmode) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: inm transition %d -&gt; %d\n&quot;</span>, __func__,
		    inm-&gt;inm_st[0].iss_fmode, inm-&gt;inm_st[1].iss_fmode));
		<span class="enscript-keyword">if</span> (inm-&gt;inm_st[0].iss_fmode == MCAST_UNDEFINED) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: initial join\n&quot;</span>, __func__));
			error = igmp_initial_join(inm, igi, itp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inm-&gt;inm_st[1].iss_fmode == MCAST_UNDEFINED) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: final leave\n&quot;</span>, __func__));
			igmp_final_leave(inm, igi, itp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: filter set change\n&quot;</span>, __func__));
	}

	error = igmp_handle_state_change(inm, igi, itp);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Perform the initial join for an IGMP group.
 *
 * When joining a group:
 *  If the group should have its IGMP traffic suppressed, do nothing.
 *  IGMPv1 starts sending IGMPv1 host membership reports.
 *  IGMPv2 starts sending IGMPv2 host membership reports.
 *  IGMPv3 will schedule an IGMPv3 state-change report containing the
 *  initial state of the membership.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_initial_join</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">struct</span> igmp_ifinfo *igi,
    <span class="enscript-type">struct</span> igmp_tparams *itp)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> ifqueue		*ifq;
	<span class="enscript-type">int</span>			 error, retval, syncstates;

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_NOTHELD(igi);
	VERIFY(itp != NULL);

	IGMP_INET_PRINTF(inm-&gt;inm_addr,
	    (<span class="enscript-string">&quot;%s: initial join %s on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    _igmp_inet_buf, (uint64_t)VM_KERNEL_ADDRPERM(inm-&gt;inm_ifp),
	    if_name(inm-&gt;inm_ifp)));

	error = 0;
	syncstates = 1;

	ifp = inm-&gt;inm_ifp;

	IGI_LOCK(igi);
	VERIFY(igi-&gt;igi_ifp == ifp);

	<span class="enscript-comment">/*
	 * Groups joined on loopback or marked as 'not reported',
	 * e.g. 224.0.0.1, enter the IGMP_SILENT_MEMBER state and
	 * are never reported in any IGMP protocol exchanges.
	 * All other groups enter the appropriate IGMP state machine
	 * for the version in use on this link.
	 * A link marked as IGIF_SILENT causes IGMP to be completely
	 * disabled for the link.
	 */</span>
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (igi-&gt;igi_flags &amp; IGIF_SILENT) ||
	    !igmp_isgroupreported(inm-&gt;inm_addr)) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: not kicking state machine for silent group\n&quot;</span>,
		    __func__));
		inm-&gt;inm_state = IGMP_SILENT_MEMBER;
		inm-&gt;inm_timer = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Deal with overlapping in_multi lifecycle.
		 * If this group was LEAVING, then make sure
		 * we drop the reference we picked up to keep the
		 * group around for the final INCLUDE {} enqueue.
		 * Since we cannot call in_multi_detach() here,
		 * defer this task to the timer routine.
		 */</span>
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_3 &amp;&amp;
		    inm-&gt;inm_state == IGMP_LEAVING_MEMBER) {
			VERIFY(inm-&gt;inm_nrelecnt != 0);
			SLIST_INSERT_HEAD(&amp;igi-&gt;igi_relinmhead, inm, inm_nrele);
		}

		inm-&gt;inm_state = IGMP_REPORTING_MEMBER;

		<span class="enscript-keyword">switch</span> (igi-&gt;igi_version) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_1</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_2</span>:
			inm-&gt;inm_state = IGMP_IDLE_MEMBER;
			error = igmp_v1v2_queue_report(inm,
			    (igi-&gt;igi_version == IGMP_VERSION_2) ?
			     IGMP_v2_HOST_MEMBERSHIP_REPORT :
			     IGMP_v1_HOST_MEMBERSHIP_REPORT);

			INM_LOCK_ASSERT_HELD(inm);
			IGI_LOCK_ASSERT_HELD(igi);

			<span class="enscript-keyword">if</span> (error == 0) {
				inm-&gt;inm_timer =
				    IGMP_RANDOM_DELAY(IGMP_V1V2_MAX_RI);
				itp-&gt;cst = 1;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_VERSION_3</span>:
			<span class="enscript-comment">/*
			 * Defer update of T0 to T1, until the first copy
			 * of the state change has been transmitted.
			 */</span>
			syncstates = 0;

			<span class="enscript-comment">/*
			 * Immediately enqueue a State-Change Report for
			 * this interface, freeing any previous reports.
			 * Don't kick the timers if there is nothing to do,
			 * or if an error occurred.
			 */</span>
			ifq = &amp;inm-&gt;inm_scq;
			IF_DRAIN(ifq);
			retval = igmp_v3_enqueue_group_record(ifq, inm, 1,
			    0, 0);
			itp-&gt;cst = (ifq-&gt;ifq_len &gt; 0);
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueue record = %d\n&quot;</span>,
			    __func__, retval));
			<span class="enscript-keyword">if</span> (retval &lt;= 0) {
				error = retval * -1;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * Schedule transmission of pending state-change
			 * report up to RV times for this link. The timer
			 * will fire at the next igmp_timeout (1 second),
			 * giving us an opportunity to merge the reports.
			 */</span>
			<span class="enscript-keyword">if</span> (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) {
				inm-&gt;inm_scrv = 1;
			} <span class="enscript-keyword">else</span> {
				VERIFY(igi-&gt;igi_rv &gt; 1);
				inm-&gt;inm_scrv = igi-&gt;igi_rv;
			}
			inm-&gt;inm_sctimer = 1;
			itp-&gt;sct = 1;

			error = 0;
			<span class="enscript-keyword">break</span>;
		}
	}
	IGI_UNLOCK(igi);

	<span class="enscript-comment">/*
	 * Only update the T0 state if state change is atomic,
	 * i.e. we don't need to wait for a timer to fire before we
	 * can consider the state change to have been communicated.
	 */</span>
	<span class="enscript-keyword">if</span> (syncstates) {
		inm_commit(inm);
		IGMP_INET_PRINTF(inm-&gt;inm_addr,
		    (<span class="enscript-string">&quot;%s: T1 -&gt; T0 for %s/%s\n&quot;</span>, __func__,
		    _igmp_inet_buf, if_name(inm-&gt;inm_ifp)));
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Issue an intermediate state change during the IGMP life-cycle.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_handle_state_change</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">struct</span> igmp_ifinfo *igi,
    <span class="enscript-type">struct</span> igmp_tparams *itp)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">int</span>			 retval = 0;

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_NOTHELD(igi);
	VERIFY(itp != NULL);

	IGMP_INET_PRINTF(inm-&gt;inm_addr,
	    (<span class="enscript-string">&quot;%s: state change for %s on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    _igmp_inet_buf, (uint64_t)VM_KERNEL_ADDRPERM(inm-&gt;inm_ifp),
	    if_name(inm-&gt;inm_ifp)));

	ifp = inm-&gt;inm_ifp;

	IGI_LOCK(igi);
	VERIFY(igi-&gt;igi_ifp == ifp);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (igi-&gt;igi_flags &amp; IGIF_SILENT) ||
	    !igmp_isgroupreported(inm-&gt;inm_addr) ||
	    (igi-&gt;igi_version != IGMP_VERSION_3)) {
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">if</span> (!igmp_isgroupreported(inm-&gt;inm_addr)) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: not kicking state &quot;</span>
			    <span class="enscript-string">&quot;machine for silent group\n&quot;</span>, __func__));
		}
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: nothing to do\n&quot;</span>, __func__));
		inm_commit(inm);
		IGMP_INET_PRINTF(inm-&gt;inm_addr,
		    (<span class="enscript-string">&quot;%s: T1 -&gt; T0 for %s/%s\n&quot;</span>, __func__,
		    _igmp_inet_buf, inm-&gt;inm_ifp-&gt;if_name));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	IF_DRAIN(&amp;inm-&gt;inm_scq);

	retval = igmp_v3_enqueue_group_record(&amp;inm-&gt;inm_scq, inm, 1, 0, 0);
	itp-&gt;cst = (inm-&gt;inm_scq.ifq_len &gt; 0);
	IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueue record = %d\n&quot;</span>, __func__, retval));
	<span class="enscript-keyword">if</span> (retval &lt;= 0) {
		IGI_UNLOCK(igi);
		retval *= -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * If record(s) were enqueued, start the state-change
	 * report timer for this group.
	 */</span>
	inm-&gt;inm_scrv = ((igi-&gt;igi_flags &amp; IGIF_LOOPBACK) ? 1 : igi-&gt;igi_rv);
	inm-&gt;inm_sctimer = 1;
	itp-&gt;sct = 1;
	IGI_UNLOCK(igi);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Perform the final leave for an IGMP group.
 *
 * When leaving a group:
 *  IGMPv1 does nothing.
 *  IGMPv2 sends a host leave message, if and only if we are the reporter.
 *  IGMPv3 enqueues a state-change report containing a transition
 *  to INCLUDE {} for immediate transmission.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_final_leave</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">struct</span> igmp_ifinfo *igi,
    <span class="enscript-type">struct</span> igmp_tparams *itp)
{
	<span class="enscript-type">int</span> syncstates = 1;

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_NOTHELD(igi);
	VERIFY(itp != NULL);

	IGMP_INET_PRINTF(inm-&gt;inm_addr,
	    (<span class="enscript-string">&quot;%s: final leave %s on ifp 0x%llx(%s)\n&quot;</span>, __func__,
	    _igmp_inet_buf, (uint64_t)VM_KERNEL_ADDRPERM(inm-&gt;inm_ifp),
	    if_name(inm-&gt;inm_ifp)));

	<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
		<span class="enscript-comment">/* Already leaving or left; do nothing. */</span>
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: not kicking state machine for silent group\n&quot;</span>,
		    __func__));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		IGI_LOCK(igi);
		<span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_2) {
			<span class="enscript-keyword">if</span> (inm-&gt;inm_state == IGMP_G_QUERY_PENDING_MEMBER ||
			    inm-&gt;inm_state == IGMP_SG_QUERY_PENDING_MEMBER) {
				panic(<span class="enscript-string">&quot;%s: IGMPv3 state reached, not IGMPv3 &quot;</span>
				    <span class="enscript-string">&quot;mode\n&quot;</span>, __func__);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-comment">/* scheduler timer if enqueue is successful */</span>
			itp-&gt;cst = (igmp_v1v2_queue_report(inm,
			    IGMP_HOST_LEAVE_MESSAGE) == 0);

			INM_LOCK_ASSERT_HELD(inm);
			IGI_LOCK_ASSERT_HELD(igi);

			inm-&gt;inm_state = IGMP_NOT_MEMBER;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (igi-&gt;igi_version == IGMP_VERSION_3) {
			<span class="enscript-comment">/*
			 * Stop group timer and all pending reports.
			 * Immediately enqueue a state-change report
			 * TO_IN {} to be sent on the next timeout,
			 * giving us an opportunity to merge reports.
			 */</span>
			IF_DRAIN(&amp;inm-&gt;inm_scq);
			inm-&gt;inm_timer = 0;
			<span class="enscript-keyword">if</span> (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) {
				inm-&gt;inm_scrv = 1;
			} <span class="enscript-keyword">else</span> {
				inm-&gt;inm_scrv = igi-&gt;igi_rv;
			}
			IGMP_INET_PRINTF(inm-&gt;inm_addr,
			    (<span class="enscript-string">&quot;%s: Leaving %s/%s with %d &quot;</span>
			    <span class="enscript-string">&quot;pending retransmissions.\n&quot;</span>, __func__,
			    _igmp_inet_buf, if_name(inm-&gt;inm_ifp),
			    inm-&gt;inm_scrv));
			<span class="enscript-keyword">if</span> (inm-&gt;inm_scrv == 0) {
				inm-&gt;inm_state = IGMP_NOT_MEMBER;
				inm-&gt;inm_sctimer = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">int</span> retval;
				<span class="enscript-comment">/*
				 * Stick around in the in_multihead list;
				 * the final detach will be issued by
				 * igmp_v3_process_group_timers() when
				 * the retransmit timer expires.
				 */</span>
				INM_ADDREF_LOCKED(inm);
				VERIFY(inm-&gt;inm_debug &amp; IFD_ATTACHED);
				inm-&gt;inm_reqcnt++;
				VERIFY(inm-&gt;inm_reqcnt &gt;= 1);
				inm-&gt;inm_nrelecnt++;
				VERIFY(inm-&gt;inm_nrelecnt != 0);

				retval = igmp_v3_enqueue_group_record(
				    &amp;inm-&gt;inm_scq, inm, 1, 0, 0);
				itp-&gt;cst = (inm-&gt;inm_scq.ifq_len &gt; 0);
				KASSERT(retval != 0,
				    (<span class="enscript-string">&quot;%s: enqueue record = %d\n&quot;</span>, __func__,
				     retval));

				inm-&gt;inm_state = IGMP_LEAVING_MEMBER;
				inm-&gt;inm_sctimer = 1;
				itp-&gt;sct = 1;
				syncstates = 0;
			}
		}
		IGI_UNLOCK(igi);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
		<span class="enscript-comment">/* Our reports are suppressed; do nothing. */</span>
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (syncstates) {
		inm_commit(inm);
		IGMP_INET_PRINTF(inm-&gt;inm_addr,
		    (<span class="enscript-string">&quot;%s: T1 -&gt; T0 for %s/%s\n&quot;</span>, __func__,
		    _igmp_inet_buf, if_name(inm-&gt;inm_ifp)));
		inm-&gt;inm_st[1].iss_fmode = MCAST_UNDEFINED;
		IGMP_INET_PRINTF(inm-&gt;inm_addr,
		    (<span class="enscript-string">&quot;%s: T1 now MCAST_UNDEFINED for %s/%s\n&quot;</span>,
		    __func__, _igmp_inet_buf, if_name(inm-&gt;inm_ifp)));
	}
}

<span class="enscript-comment">/*
 * Enqueue an IGMPv3 group record to the given output queue.
 *
 * XXX This function could do with having the allocation code
 * split out, and the multiple-tree-walks coalesced into a single
 * routine as has been done in igmp_v3_enqueue_filter_change().
 *
 * If is_state_change is zero, a current-state record is appended.
 * If is_state_change is non-zero, a state-change report is appended.
 *
 * If is_group_query is non-zero, an mbuf packet chain is allocated.
 * If is_group_query is zero, and if there is a packet with free space
 * at the tail of the queue, it will be appended to providing there
 * is enough free space.
 * Otherwise a new mbuf packet chain is allocated.
 *
 * If is_source_query is non-zero, each source is checked to see if
 * it was recorded for a Group-Source query, and will be omitted if
 * it is not both in-mode and recorded.
 *
 * The function will attempt to allocate leading space in the packet
 * for the IP/IGMP header to be prepended without fragmenting the chain.
 *
 * If successful the size of all data appended to the queue is returned,
 * otherwise an error code less than zero is returned, or zero if
 * no record(s) were appended.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_v3_enqueue_group_record</span>(<span class="enscript-type">struct</span> ifqueue *ifq, <span class="enscript-type">struct</span> in_multi *inm,
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> is_state_change, <span class="enscript-type">const</span> <span class="enscript-type">int</span> is_group_query,
    <span class="enscript-type">const</span> <span class="enscript-type">int</span> is_source_query)
{
	<span class="enscript-type">struct</span> igmp_grouprec	 ig;
	<span class="enscript-type">struct</span> igmp_grouprec	*pig;
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> ip_msource	*ims, *nims;
	<span class="enscript-type">struct</span> mbuf		*m0, *m, *md;
	<span class="enscript-type">int</span>			 error, is_filter_list_change;
	<span class="enscript-type">int</span>			 minrec0len, m0srcs, msrcs, nbytes, off;
	<span class="enscript-type">int</span>			 record_has_sources;
	<span class="enscript-type">int</span>			 now;
	<span class="enscript-type">int</span>			 type;
	in_addr_t		 naddr;
	uint8_t			 mode;
	u_int16_t		 ig_numsrc;

	INM_LOCK_ASSERT_HELD(inm);
	IGI_LOCK_ASSERT_HELD(inm-&gt;inm_igi);

	error = 0;
	ifp = inm-&gt;inm_ifp;
	is_filter_list_change = 0;
	m = NULL;
	m0 = NULL;
	m0srcs = 0;
	msrcs = 0;
	nbytes = 0;
	nims = NULL;
	record_has_sources = 1;
	pig = NULL;
	type = IGMP_DO_NOTHING;
	mode = inm-&gt;inm_st[1].iss_fmode;

	<span class="enscript-comment">/*
	 * If we did not transition out of ASM mode during t0-&gt;t1,
	 * and there are no source nodes to process, we can skip
	 * the generation of source records.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_st[0].iss_asm &gt; 0 &amp;&amp; inm-&gt;inm_st[1].iss_asm &gt; 0 &amp;&amp;
	    inm-&gt;inm_nsrc == 0)
		record_has_sources = 0;

	<span class="enscript-keyword">if</span> (is_state_change) {
		<span class="enscript-comment">/*
		 * Queue a state change record.
		 * If the mode did not change, and there are non-ASM
		 * listeners or source filters present,
		 * we potentially need to issue two records for the group.
		 * If we are transitioning to MCAST_UNDEFINED, we need
		 * not send any sources.
		 * If there are ASM listeners, and there was no filter
		 * mode transition of any kind, do nothing.
		 */</span>
		<span class="enscript-keyword">if</span> (mode != inm-&gt;inm_st[0].iss_fmode) {
			<span class="enscript-keyword">if</span> (mode == MCAST_EXCLUDE) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: change to EXCLUDE\n&quot;</span>,
				    __func__));
				type = IGMP_CHANGE_TO_EXCLUDE_MODE;
			} <span class="enscript-keyword">else</span> {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: change to INCLUDE\n&quot;</span>,
				    __func__));
				type = IGMP_CHANGE_TO_INCLUDE_MODE;
				<span class="enscript-keyword">if</span> (mode == MCAST_UNDEFINED)
					record_has_sources = 0;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (record_has_sources) {
				is_filter_list_change = 1;
			} <span class="enscript-keyword">else</span> {
				type = IGMP_DO_NOTHING;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Queue a current state record.
		 */</span>
		<span class="enscript-keyword">if</span> (mode == MCAST_EXCLUDE) {
			type = IGMP_MODE_IS_EXCLUDE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mode == MCAST_INCLUDE) {
			type = IGMP_MODE_IS_INCLUDE;
			VERIFY(inm-&gt;inm_st[1].iss_asm == 0);
		}
	}

	<span class="enscript-comment">/*
	 * Generate the filter list changes using a separate function.
	 */</span>
	<span class="enscript-keyword">if</span> (is_filter_list_change)
		<span class="enscript-keyword">return</span> (igmp_v3_enqueue_filter_change(ifq, inm));

	<span class="enscript-keyword">if</span> (type == IGMP_DO_NOTHING) {
		IGMP_INET_PRINTF(inm-&gt;inm_addr,
		    (<span class="enscript-string">&quot;%s: nothing to do for %s/%s\n&quot;</span>,
		    __func__, _igmp_inet_buf,
		    if_name(inm-&gt;inm_ifp)));
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * If any sources are present, we must be able to fit at least
	 * one in the trailing space of the tail packet's mbuf,
	 * ideally more.
	 */</span>
	minrec0len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec);
	<span class="enscript-keyword">if</span> (record_has_sources)
		minrec0len += <span class="enscript-keyword">sizeof</span>(in_addr_t);

	IGMP_INET_PRINTF(inm-&gt;inm_addr,
	    (<span class="enscript-string">&quot;%s: queueing %s for %s/%s\n&quot;</span>, __func__,
	    igmp_rec_type_to_str(type), _igmp_inet_buf,
	    if_name(inm-&gt;inm_ifp)));

	<span class="enscript-comment">/*
	 * Check if we have a packet in the tail of the queue for this
	 * group into which the first group record for this group will fit.
	 * Otherwise allocate a new packet.
	 * Always allocate leading space for IP+RA_OPT+IGMP+REPORT.
	 * Note: Group records for G/GSR query responses MUST be sent
	 * in their own packet.
	 */</span>
	m0 = ifq-&gt;ifq_tail;
	<span class="enscript-keyword">if</span> (!is_group_query &amp;&amp;
	    m0 != NULL &amp;&amp;
	    (m0-&gt;m_pkthdr.vt_nrecs + 1 &lt;= IGMP_V3_REPORT_MAXRECS) &amp;&amp;
	    (m0-&gt;m_pkthdr.len + minrec0len) &lt;
	     (ifp-&gt;if_mtu - IGMP_LEADINGSPACE)) {
		m0srcs = (ifp-&gt;if_mtu - m0-&gt;m_pkthdr.len -
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec)) / <span class="enscript-keyword">sizeof</span>(in_addr_t);
		m = m0;
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: use existing packet\n&quot;</span>, __func__));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IF_QFULL(ifq)) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: outbound queue full\n&quot;</span>, __func__));
			<span class="enscript-keyword">return</span> (-ENOMEM);
		}
		m = NULL;
		m0srcs = (ifp-&gt;if_mtu - IGMP_LEADINGSPACE -
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec)) / <span class="enscript-keyword">sizeof</span>(in_addr_t);
		<span class="enscript-keyword">if</span> (!is_state_change &amp;&amp; !is_group_query) {
			m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
			<span class="enscript-keyword">if</span> (m)
				m-&gt;m_data += IGMP_LEADINGSPACE;
		}
		<span class="enscript-keyword">if</span> (m == NULL) {
			m = m_gethdr(M_DONTWAIT, MT_DATA);
			<span class="enscript-keyword">if</span> (m)
				MH_ALIGN(m, IGMP_LEADINGSPACE);
		}
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (-ENOMEM);

		igmp_save_context(m, ifp);

		IGMP_PRINTF((<span class="enscript-string">&quot;%s: allocated first packet\n&quot;</span>, __func__));
	}

	<span class="enscript-comment">/*
	 * Append group record.
	 * If we have sources, we don't know how many yet.
	 */</span>
	ig.ig_type = type;
	ig.ig_datalen = 0;
	ig.ig_numsrc = 0;
	ig.ig_group = inm-&gt;inm_addr;
	<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec), (<span class="enscript-type">void</span> *)&amp;ig)) {
		<span class="enscript-keyword">if</span> (m != m0)
			m_freem(m);
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed.\n&quot;</span>, __func__));
		<span class="enscript-keyword">return</span> (-ENOMEM);
	}
	nbytes += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec);

	<span class="enscript-comment">/*
	 * Append as many sources as will fit in the first packet.
	 * If we are appending to a new packet, the chain allocation
	 * may potentially use clusters; use m_getptr() in this case.
	 * If we are appending to an existing packet, we need to obtain
	 * a pointer to the group record after m_append(), in case a new
	 * mbuf was allocated.
	 * Only append sources which are in-mode at t1. If we are
	 * transitioning to MCAST_UNDEFINED state on the group, do not
	 * include source entries.
	 * Only report recorded sources in our filter set when responding
	 * to a group-source query.
	 */</span>
	<span class="enscript-keyword">if</span> (record_has_sources) {
		<span class="enscript-keyword">if</span> (m == m0) {
			md = m_last(m);
			pig = (<span class="enscript-type">struct</span> igmp_grouprec *)(<span class="enscript-type">void</span> *)
			    (mtod(md, uint8_t *) + md-&gt;m_len - nbytes);
		} <span class="enscript-keyword">else</span> {
			md = m_getptr(m, 0, &amp;off);
			pig = (<span class="enscript-type">struct</span> igmp_grouprec *)(<span class="enscript-type">void</span> *)
			    (mtod(md, uint8_t *) + off);
		}
		msrcs = 0;
		RB_FOREACH_SAFE(ims, ip_msource_tree, &amp;inm-&gt;inm_srcs, nims) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
			<span class="enscript-type">char</span> buf[MAX_IPv4_STR_LEN];

			inet_ntop_haddr(ims-&gt;ims_haddr, buf, <span class="enscript-keyword">sizeof</span>(buf));
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: visit node %s\n&quot;</span>, __func__, buf));
#<span class="enscript-reference">endif</span>
			now = ims_get_mode(inm, ims, 1);
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: node is %d\n&quot;</span>, __func__, now));
			<span class="enscript-keyword">if</span> ((now != mode) ||
			    (now == mode &amp;&amp; mode == MCAST_UNDEFINED)) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip node\n&quot;</span>, __func__));
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (is_source_query &amp;&amp; ims-&gt;ims_stp == 0) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip unrecorded node\n&quot;</span>,
				    __func__));
				<span class="enscript-keyword">continue</span>;
			}
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: append node\n&quot;</span>, __func__));
			naddr = htonl(ims-&gt;ims_haddr);
			<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(in_addr_t), (<span class="enscript-type">void</span> *)&amp;naddr)) {
				<span class="enscript-keyword">if</span> (m != m0)
					m_freem(m);
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed.\n&quot;</span>,
				    __func__));
				<span class="enscript-keyword">return</span> (-ENOMEM);
			}
			nbytes += <span class="enscript-keyword">sizeof</span>(in_addr_t);
			++msrcs;
			<span class="enscript-keyword">if</span> (msrcs == m0srcs)
				<span class="enscript-keyword">break</span>;
		}
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: msrcs is %d this packet\n&quot;</span>, __func__,
		    msrcs));
		ig_numsrc = htons(msrcs);
		bcopy(&amp;ig_numsrc, &amp;pig-&gt;ig_numsrc, <span class="enscript-keyword">sizeof</span> (ig_numsrc));
		nbytes += (msrcs * <span class="enscript-keyword">sizeof</span>(in_addr_t));
	}

	<span class="enscript-keyword">if</span> (is_source_query &amp;&amp; msrcs == 0) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: no recorded sources to report\n&quot;</span>, __func__));
		<span class="enscript-keyword">if</span> (m != m0)
			m_freem(m);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * We are good to go with first packet.
	 */</span>
	<span class="enscript-keyword">if</span> (m != m0) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueueing first packet\n&quot;</span>, __func__));
		m-&gt;m_pkthdr.vt_nrecs = 1;
		IF_ENQUEUE(ifq, m);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.vt_nrecs++;
	}
	<span class="enscript-comment">/*
	 * No further work needed if no source list in packet(s).
	 */</span>
	<span class="enscript-keyword">if</span> (!record_has_sources)
		<span class="enscript-keyword">return</span> (nbytes);

	<span class="enscript-comment">/*
	 * Whilst sources remain to be announced, we need to allocate
	 * a new packet and fill out as many sources as will fit.
	 * Always try for a cluster first.
	 */</span>
	<span class="enscript-keyword">while</span> (nims != NULL) {
		<span class="enscript-keyword">if</span> (IF_QFULL(ifq)) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: outbound queue full\n&quot;</span>, __func__));
			<span class="enscript-keyword">return</span> (-ENOMEM);
		}
		m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
		<span class="enscript-keyword">if</span> (m)
			m-&gt;m_data += IGMP_LEADINGSPACE;
		<span class="enscript-keyword">if</span> (m == NULL) {
			m = m_gethdr(M_DONTWAIT, MT_DATA);
			<span class="enscript-keyword">if</span> (m)
				MH_ALIGN(m, IGMP_LEADINGSPACE);
		}
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (-ENOMEM);
		igmp_save_context(m, ifp);
		md = m_getptr(m, 0, &amp;off);
		pig = (<span class="enscript-type">struct</span> igmp_grouprec *)(<span class="enscript-type">void</span> *)
		    (mtod(md, uint8_t *) + off);
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: allocated next packet\n&quot;</span>, __func__));

		<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec), (<span class="enscript-type">void</span> *)&amp;ig)) {
			<span class="enscript-keyword">if</span> (m != m0)
				m_freem(m);
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed.\n&quot;</span>, __func__));
			<span class="enscript-keyword">return</span> (-ENOMEM);
		}
		m-&gt;m_pkthdr.vt_nrecs = 1;
		nbytes += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec);

		m0srcs = (ifp-&gt;if_mtu - IGMP_LEADINGSPACE -
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec)) / <span class="enscript-keyword">sizeof</span>(in_addr_t);

		msrcs = 0;
		RB_FOREACH_FROM(ims, ip_msource_tree, nims) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
			<span class="enscript-type">char</span> buf[MAX_IPv4_STR_LEN];

			inet_ntop_haddr(ims-&gt;ims_haddr, buf, <span class="enscript-keyword">sizeof</span>(buf));
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: visit node %s\n&quot;</span>, __func__, buf));
#<span class="enscript-reference">endif</span>
			now = ims_get_mode(inm, ims, 1);
			<span class="enscript-keyword">if</span> ((now != mode) ||
			    (now == mode &amp;&amp; mode == MCAST_UNDEFINED)) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip node\n&quot;</span>, __func__));
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (is_source_query &amp;&amp; ims-&gt;ims_stp == 0) {
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip unrecorded node\n&quot;</span>,
				    __func__));
				<span class="enscript-keyword">continue</span>;
			}
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: append node\n&quot;</span>, __func__));
			naddr = htonl(ims-&gt;ims_haddr);
			<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(in_addr_t), (<span class="enscript-type">void</span> *)&amp;naddr)) {
				<span class="enscript-keyword">if</span> (m != m0)
					m_freem(m);
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed.\n&quot;</span>,
				    __func__));
				<span class="enscript-keyword">return</span> (-ENOMEM);
			}
			++msrcs;
			<span class="enscript-keyword">if</span> (msrcs == m0srcs)
				<span class="enscript-keyword">break</span>;
		}
		ig_numsrc = htons(msrcs);
		bcopy(&amp;ig_numsrc, &amp;pig-&gt;ig_numsrc, <span class="enscript-keyword">sizeof</span> (ig_numsrc));
		nbytes += (msrcs * <span class="enscript-keyword">sizeof</span>(in_addr_t));

		IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueueing next packet\n&quot;</span>, __func__));
		IF_ENQUEUE(ifq, m);
	}

	<span class="enscript-keyword">return</span> (nbytes);
}

<span class="enscript-comment">/*
 * Type used to mark record pass completion.
 * We exploit the fact we can cast to this easily from the
 * current filter modes on each ip_msource node.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	REC_NONE = 0x00,	<span class="enscript-comment">/* MCAST_UNDEFINED */</span>
	REC_ALLOW = 0x01,	<span class="enscript-comment">/* MCAST_INCLUDE */</span>
	REC_BLOCK = 0x02,	<span class="enscript-comment">/* MCAST_EXCLUDE */</span>
	REC_FULL = REC_ALLOW | REC_BLOCK
} rectype_t;

<span class="enscript-comment">/*
 * Enqueue an IGMPv3 filter list change to the given output queue.
 *
 * Source list filter state is held in an RB-tree. When the filter list
 * for a group is changed without changing its mode, we need to compute
 * the deltas between T0 and T1 for each source in the filter set,
 * and enqueue the appropriate ALLOW_NEW/BLOCK_OLD records.
 *
 * As we may potentially queue two record types, and the entire R-B tree
 * needs to be walked at once, we break this out into its own function
 * so we can generate a tightly packed queue of packets.
 *
 * XXX This could be written to only use one tree walk, although that makes
 * serializing into the mbuf chains a bit harder. For now we do two walks
 * which makes things easier on us, and it may or may not be harder on
 * the L2 cache.
 *
 * If successful the size of all data appended to the queue is returned,
 * otherwise an error code less than zero is returned, or zero if
 * no record(s) were appended.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_v3_enqueue_filter_change</span>(<span class="enscript-type">struct</span> ifqueue *ifq, <span class="enscript-type">struct</span> in_multi *inm)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> MINRECLEN =
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec) + <span class="enscript-keyword">sizeof</span>(in_addr_t);
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> igmp_grouprec	 ig;
	<span class="enscript-type">struct</span> igmp_grouprec	*pig;
	<span class="enscript-type">struct</span> ip_msource	*ims, *nims;
	<span class="enscript-type">struct</span> mbuf		*m, *m0, *md;
	in_addr_t		 naddr;
	<span class="enscript-type">int</span>			 m0srcs, nbytes, npbytes, off, rsrcs, schanged;
	<span class="enscript-type">int</span>			 nallow, nblock;
	uint8_t			 mode, now, then;
	rectype_t		 crt, drt, nrt;
	u_int16_t		 ig_numsrc;

	INM_LOCK_ASSERT_HELD(inm);

	<span class="enscript-keyword">if</span> (inm-&gt;inm_nsrc == 0 ||
	    (inm-&gt;inm_st[0].iss_asm &gt; 0 &amp;&amp; inm-&gt;inm_st[1].iss_asm &gt; 0))
		<span class="enscript-keyword">return</span> (0);

	ifp = inm-&gt;inm_ifp;			<span class="enscript-comment">/* interface */</span>
	mode = inm-&gt;inm_st[1].iss_fmode;	<span class="enscript-comment">/* filter mode at t1 */</span>
	crt = REC_NONE;	<span class="enscript-comment">/* current group record type */</span>
	drt = REC_NONE;	<span class="enscript-comment">/* mask of completed group record types */</span>
	nrt = REC_NONE;	<span class="enscript-comment">/* record type for current node */</span>
	m0srcs = 0;	<span class="enscript-comment">/* # source which will fit in current mbuf chain */</span>
	nbytes = 0;	<span class="enscript-comment">/* # of bytes appended to group's state-change queue */</span>
	npbytes = 0;	<span class="enscript-comment">/* # of bytes appended this packet */</span>
	rsrcs = 0;	<span class="enscript-comment">/* # sources encoded in current record */</span>
	schanged = 0;	<span class="enscript-comment">/* # nodes encoded in overall filter change */</span>
	nallow = 0;	<span class="enscript-comment">/* # of source entries in ALLOW_NEW */</span>
	nblock = 0;	<span class="enscript-comment">/* # of source entries in BLOCK_OLD */</span>
	nims = NULL;	<span class="enscript-comment">/* next tree node pointer */</span>

	<span class="enscript-comment">/*
	 * For each possible filter record mode.
	 * The first kind of source we encounter tells us which
	 * is the first kind of record we start appending.
	 * If a node transitioned to UNDEFINED at t1, its mode is treated
	 * as the inverse of the group's filter mode.
	 */</span>
	<span class="enscript-keyword">while</span> (drt != REC_FULL) {
		<span class="enscript-keyword">do</span> {
			m0 = ifq-&gt;ifq_tail;
			<span class="enscript-keyword">if</span> (m0 != NULL &amp;&amp;
			    (m0-&gt;m_pkthdr.vt_nrecs + 1 &lt;=
			     IGMP_V3_REPORT_MAXRECS) &amp;&amp;
			    (m0-&gt;m_pkthdr.len + MINRECLEN) &lt;
			     (ifp-&gt;if_mtu - IGMP_LEADINGSPACE)) {
				m = m0;
				m0srcs = (ifp-&gt;if_mtu - m0-&gt;m_pkthdr.len -
					    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec)) /
				    <span class="enscript-keyword">sizeof</span>(in_addr_t);
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: use previous packet\n&quot;</span>,
				    __func__));
			} <span class="enscript-keyword">else</span> {
				m = m_getcl(M_DONTWAIT, MT_DATA, M_PKTHDR);
				<span class="enscript-keyword">if</span> (m)
					m-&gt;m_data += IGMP_LEADINGSPACE;
				<span class="enscript-keyword">if</span> (m == NULL) {
					m = m_gethdr(M_DONTWAIT, MT_DATA);
					<span class="enscript-keyword">if</span> (m)
						MH_ALIGN(m, IGMP_LEADINGSPACE);
				}
				<span class="enscript-keyword">if</span> (m == NULL) {
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_get*() failed\n&quot;</span>,
					    __func__));
					<span class="enscript-keyword">return</span> (-ENOMEM);
				}
				m-&gt;m_pkthdr.vt_nrecs = 0;
				igmp_save_context(m, ifp);
				m0srcs = (ifp-&gt;if_mtu - IGMP_LEADINGSPACE -
				    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec)) /
				    <span class="enscript-keyword">sizeof</span>(in_addr_t);
				npbytes = 0;
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: allocated new packet\n&quot;</span>,
				    __func__));
			}
			<span class="enscript-comment">/*
			 * Append the IGMP group record header to the
			 * current packet's data area.
			 * Recalculate pointer to free space for next
			 * group record, in case m_append() allocated
			 * a new mbuf or cluster.
			 */</span>
			memset(&amp;ig, 0, <span class="enscript-keyword">sizeof</span>(ig));
			ig.ig_group = inm-&gt;inm_addr;
			<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(ig), (<span class="enscript-type">void</span> *)&amp;ig)) {
				<span class="enscript-keyword">if</span> (m != m0)
					m_freem(m);
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed\n&quot;</span>,
				    __func__));
				<span class="enscript-keyword">return</span> (-ENOMEM);
			}
			npbytes += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec);
			<span class="enscript-keyword">if</span> (m != m0) {
				<span class="enscript-comment">/* new packet; offset in c hain */</span>
				md = m_getptr(m, npbytes -
				    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec), &amp;off);
				pig = (<span class="enscript-type">struct</span> igmp_grouprec *)(<span class="enscript-type">void</span> *)(mtod(md,
				    uint8_t *) + off);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* current packet; offset from last append */</span>
				md = m_last(m);
				pig = (<span class="enscript-type">struct</span> igmp_grouprec *)(<span class="enscript-type">void</span> *)(mtod(md,
				    uint8_t *) + md-&gt;m_len -
				    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec));
			}
			<span class="enscript-comment">/*
			 * Begin walking the tree for this record type
			 * pass, or continue from where we left off
			 * previously if we had to allocate a new packet.
			 * Only report deltas in-mode at t1.
			 * We need not report included sources as allowed
			 * if we are in inclusive mode on the group,
			 * however the converse is not true.
			 */</span>
			rsrcs = 0;
			<span class="enscript-keyword">if</span> (nims == NULL)
				nims = RB_MIN(ip_msource_tree, &amp;inm-&gt;inm_srcs);
			RB_FOREACH_FROM(ims, ip_msource_tree, nims) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
				<span class="enscript-type">char</span> buf[MAX_IPv4_STR_LEN];

				inet_ntop_haddr(ims-&gt;ims_haddr, buf, <span class="enscript-keyword">sizeof</span>(buf));
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: visit node %s\n&quot;</span>, __func__, buf));
#<span class="enscript-reference">endif</span>
				now = ims_get_mode(inm, ims, 1);
				then = ims_get_mode(inm, ims, 0);
				IGMP_PRINTF((<span class="enscript-string">&quot;%s: mode: t0 %d, t1 %d\n&quot;</span>,
				    __func__, then, now));
				<span class="enscript-keyword">if</span> (now == then) {
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip unchanged\n&quot;</span>,
					    __func__));
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (mode == MCAST_EXCLUDE &amp;&amp;
				    now == MCAST_INCLUDE) {
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: skip IN src on EX &quot;</span>
					    <span class="enscript-string">&quot;group\n&quot;</span>, __func__));
					<span class="enscript-keyword">continue</span>;
				}
				nrt = (rectype_t)now;
				<span class="enscript-keyword">if</span> (nrt == REC_NONE)
					nrt = (rectype_t)(~mode &amp; REC_FULL);
				<span class="enscript-keyword">if</span> (schanged++ == 0) {
					crt = nrt;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (crt != nrt)
					<span class="enscript-keyword">continue</span>;
				naddr = htonl(ims-&gt;ims_haddr);
				<span class="enscript-keyword">if</span> (!m_append(m, <span class="enscript-keyword">sizeof</span>(in_addr_t),
				    (<span class="enscript-type">void</span> *)&amp;naddr)) {
					<span class="enscript-keyword">if</span> (m != m0)
						m_freem(m);
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_append() failed\n&quot;</span>,
					    __func__));
					<span class="enscript-keyword">return</span> (-ENOMEM);
				}
				nallow += !!(crt == REC_ALLOW);
				nblock += !!(crt == REC_BLOCK);
				<span class="enscript-keyword">if</span> (++rsrcs == m0srcs)
					<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * If we did not append any tree nodes on this
			 * pass, back out of allocations.
			 */</span>
			<span class="enscript-keyword">if</span> (rsrcs == 0) {
				npbytes -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_grouprec);
				<span class="enscript-keyword">if</span> (m != m0) {
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_free(m)\n&quot;</span>,
					    __func__));
					m_freem(m);
				} <span class="enscript-keyword">else</span> {
					IGMP_PRINTF((<span class="enscript-string">&quot;%s: m_adj(m, -ig)\n&quot;</span>,
					    __func__));
					m_adj(m, -((<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(
					    <span class="enscript-type">struct</span> igmp_grouprec)));
				}
				<span class="enscript-keyword">continue</span>;
			}
			npbytes += (rsrcs * <span class="enscript-keyword">sizeof</span>(in_addr_t));
			<span class="enscript-keyword">if</span> (crt == REC_ALLOW)
				pig-&gt;ig_type = IGMP_ALLOW_NEW_SOURCES;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (crt == REC_BLOCK)
				pig-&gt;ig_type = IGMP_BLOCK_OLD_SOURCES;
			ig_numsrc = htons(rsrcs);
			bcopy(&amp;ig_numsrc, &amp;pig-&gt;ig_numsrc, <span class="enscript-keyword">sizeof</span> (ig_numsrc));
			<span class="enscript-comment">/*
			 * Count the new group record, and enqueue this
			 * packet if it wasn't already queued.
			 */</span>
			m-&gt;m_pkthdr.vt_nrecs++;
			<span class="enscript-keyword">if</span> (m != m0)
				IF_ENQUEUE(ifq, m);
			nbytes += npbytes;
		} <span class="enscript-keyword">while</span> (nims != NULL);
		drt |= crt;
		crt = (~crt &amp; REC_FULL);
	}

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: queued %d ALLOW_NEW, %d BLOCK_OLD\n&quot;</span>, __func__,
	    nallow, nblock));

	<span class="enscript-keyword">return</span> (nbytes);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">igmp_v3_merge_state_changes</span>(<span class="enscript-type">struct</span> in_multi *inm, <span class="enscript-type">struct</span> ifqueue *ifscq)
{
	<span class="enscript-type">struct</span> ifqueue	*gq;
	<span class="enscript-type">struct</span> mbuf	*m;		<span class="enscript-comment">/* pending state-change */</span>
	<span class="enscript-type">struct</span> mbuf	*m0;		<span class="enscript-comment">/* copy of pending state-change */</span>
	<span class="enscript-type">struct</span> mbuf	*mt;		<span class="enscript-comment">/* last state-change in packet */</span>
	<span class="enscript-type">struct</span> mbuf	*n;
	<span class="enscript-type">int</span>		 docopy, domerge;
	u_int		 recslen;

	INM_LOCK_ASSERT_HELD(inm);

	docopy = 0;
	domerge = 0;
	recslen = 0;

	<span class="enscript-comment">/*
	 * If there are further pending retransmissions, make a writable
	 * copy of each queued state-change message before merging.
	 */</span>
	<span class="enscript-keyword">if</span> (inm-&gt;inm_scrv &gt; 0)
		docopy = 1;

	gq = &amp;inm-&gt;inm_scq;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
	<span class="enscript-keyword">if</span> (gq-&gt;ifq_head == NULL) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: WARNING: queue for inm 0x%llx is empty\n&quot;</span>,
		    __func__, (uint64_t)VM_KERNEL_ADDRPERM(inm)));
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Use IF_REMQUEUE() instead of IF_DEQUEUE() below, since the
	 * packet might not always be at the head of the ifqueue.
	 */</span>
	m = gq-&gt;ifq_head;
	<span class="enscript-keyword">while</span> (m != NULL) {
		<span class="enscript-comment">/*
		 * Only merge the report into the current packet if
		 * there is sufficient space to do so; an IGMPv3 report
		 * packet may only contain 65,535 group records.
		 * Always use a simple mbuf chain concatentation to do this,
		 * as large state changes for single groups may have
		 * allocated clusters.
		 */</span>
		domerge = 0;
		mt = ifscq-&gt;ifq_tail;
		<span class="enscript-keyword">if</span> (mt != NULL) {
			recslen = m_length(m);

			<span class="enscript-keyword">if</span> ((mt-&gt;m_pkthdr.vt_nrecs +
			    m-&gt;m_pkthdr.vt_nrecs &lt;=
			    IGMP_V3_REPORT_MAXRECS) &amp;&amp;
			    (mt-&gt;m_pkthdr.len + recslen &lt;=
			    (inm-&gt;inm_ifp-&gt;if_mtu - IGMP_LEADINGSPACE)))
				domerge = 1;
		}

		<span class="enscript-keyword">if</span> (!domerge &amp;&amp; IF_QFULL(gq)) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: outbound queue full, skipping whole &quot;</span>
			    <span class="enscript-string">&quot;packet 0x%llx\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m)));
			n = m-&gt;m_nextpkt;
			<span class="enscript-keyword">if</span> (!docopy) {
				IF_REMQUEUE(gq, m);
				m_freem(m);
			}
			m = n;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (!docopy) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: dequeueing 0x%llx\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m)));
			n = m-&gt;m_nextpkt;
			IF_REMQUEUE(gq, m);
			m0 = m;
			m = n;
		} <span class="enscript-keyword">else</span> {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: copying 0x%llx\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m)));
			m0 = m_dup(m, M_NOWAIT);
			<span class="enscript-keyword">if</span> (m0 == NULL)
				<span class="enscript-keyword">return</span> (ENOMEM);
			m0-&gt;m_nextpkt = NULL;
			m = m-&gt;m_nextpkt;
		}

		<span class="enscript-keyword">if</span> (!domerge) {
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: queueing 0x%llx to ifscq 0x%llx)\n&quot;</span>,
			    __func__, (uint64_t)VM_KERNEL_ADDRPERM(m0),
			    (uint64_t)VM_KERNEL_ADDRPERM(ifscq)));
			IF_ENQUEUE(ifscq, m0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> mbuf *mtl;	<span class="enscript-comment">/* last mbuf of packet mt */</span>

			IGMP_PRINTF((<span class="enscript-string">&quot;%s: merging 0x%llx with ifscq tail &quot;</span>
			    <span class="enscript-string">&quot;0x%llx)\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m0),
			    (uint64_t)VM_KERNEL_ADDRPERM(mt)));

			mtl = m_last(mt);
			m0-&gt;m_flags &amp;= ~M_PKTHDR;
			mt-&gt;m_pkthdr.len += recslen;
			mt-&gt;m_pkthdr.vt_nrecs +=
			    m0-&gt;m_pkthdr.vt_nrecs;

			mtl-&gt;m_next = m0;
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Respond to a pending IGMPv3 General Query.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">igmp_v3_dispatch_general_query</span>(<span class="enscript-type">struct</span> igmp_ifinfo *igi)
{
	<span class="enscript-type">struct</span> ifnet		*ifp;
	<span class="enscript-type">struct</span> in_multi		*inm;
	<span class="enscript-type">struct</span> in_multistep	step;
	<span class="enscript-type">int</span>			 retval, loop;

	IGI_LOCK_ASSERT_HELD(igi);

	VERIFY(igi-&gt;igi_version == IGMP_VERSION_3);

	ifp = igi-&gt;igi_ifp;
	IGI_UNLOCK(igi);

	in_multihead_lock_shared();
	IN_FIRST_MULTI(step, inm);
	<span class="enscript-keyword">while</span> (inm != NULL) {
		INM_LOCK(inm);
		<span class="enscript-keyword">if</span> (inm-&gt;inm_ifp != ifp)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

		<span class="enscript-keyword">switch</span> (inm-&gt;inm_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_NOT_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SILENT_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_REPORTING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_IDLE_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LAZY_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SLEEPING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_AWAKENING_MEMBER</span>:
			inm-&gt;inm_state = IGMP_REPORTING_MEMBER;
			IGI_LOCK(igi);
			retval = igmp_v3_enqueue_group_record(&amp;igi-&gt;igi_gq,
			    inm, 0, 0, 0);
			IGI_UNLOCK(igi);
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: enqueue record = %d\n&quot;</span>,
			    __func__, retval));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_G_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_SG_QUERY_PENDING_MEMBER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_LEAVING_MEMBER</span>:
			<span class="enscript-keyword">break</span>;
		}
<span class="enscript-reference">next</span>:
		INM_UNLOCK(inm);
		IN_NEXT_MULTI(step, inm);
	}
	in_multihead_lock_done();

	IGI_LOCK(igi);
	loop = (igi-&gt;igi_flags &amp; IGIF_LOOPBACK) ? 1 : 0;
	igmp_dispatch_queue(igi, &amp;igi-&gt;igi_gq, IGMP_MAX_RESPONSE_BURST,
	    loop);
	IGI_LOCK_ASSERT_HELD(igi);
	<span class="enscript-comment">/*
	 * Slew transmission of bursts over 1 second intervals.
	 */</span>
	<span class="enscript-keyword">if</span> (igi-&gt;igi_gq.ifq_head != NULL) {
		igi-&gt;igi_v3_timer = 1 + IGMP_RANDOM_DELAY(
		    IGMP_RESPONSE_BURST_INTERVAL);
	}

	<span class="enscript-keyword">return</span> (igi-&gt;igi_v3_timer);
}

<span class="enscript-comment">/*
 * Transmit the next pending IGMP message in the output queue.
 *
 * Must not be called with inm_lock or igi_lock held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_sendpkt</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ip_moptions	*imo;
	<span class="enscript-type">struct</span> mbuf		*ipopts, *m0;
	<span class="enscript-type">int</span>			error;
	<span class="enscript-type">struct</span> route		ro;
	<span class="enscript-type">struct</span> ifnet		*ifp;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: transmit 0x%llx\n&quot;</span>, __func__,
	    (uint64_t)VM_KERNEL_ADDRPERM(m)));

	ifp = igmp_restore_context(m);
	<span class="enscript-comment">/*
	 * Check if the ifnet is still attached.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp == NULL || !ifnet_is_attached(ifp, 0)) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: dropped 0x%llx as ifp went away.\n&quot;</span>,
		    __func__, (uint64_t)VM_KERNEL_ADDRPERM(m)));
		m_freem(m);
		OSAddAtomic(1, &amp;ipstat.ips_noroute);
		<span class="enscript-keyword">return</span>;
	}

	ipopts = igmp_sendra ? m_raopt : NULL;

	imo = ip_allocmoptions(M_WAITOK);
	<span class="enscript-keyword">if</span> (imo == NULL) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}

	imo-&gt;imo_multicast_ttl  = 1;
	imo-&gt;imo_multicast_vif  = -1;
	imo-&gt;imo_multicast_loop = 0;

	<span class="enscript-comment">/*
	 * If the user requested that IGMP traffic be explicitly
	 * redirected to the loopback interface (e.g. they are running a
	 * MANET interface and the routing protocol needs to see the
	 * updates), handle this now.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_IGMP_LOOP)
		imo-&gt;imo_multicast_ifp = lo_ifp;
	<span class="enscript-keyword">else</span>
		imo-&gt;imo_multicast_ifp = ifp;

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_IGMPV2) {
		m0 = m;
	} <span class="enscript-keyword">else</span> {
		m0 = igmp_v3_encap_report(ifp, m);
		<span class="enscript-keyword">if</span> (m0 == NULL) {
			<span class="enscript-comment">/*
			 * If igmp_v3_encap_report() failed, then M_PREPEND()
			 * already freed the original mbuf chain.
			 * This means that we don't have to m_freem(m) here.
			 */</span>
			IGMP_PRINTF((<span class="enscript-string">&quot;%s: dropped 0x%llx\n&quot;</span>, __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m)));
			IMO_REMREF(imo);
			atomic_add_32(&amp;ipstat.ips_odropped, 1);
			<span class="enscript-keyword">return</span>;
		}
	}

	igmp_scrub_context(m0);
	m-&gt;m_flags &amp;= ~(M_PROTOFLAGS | M_IGMP_LOOP);
	m0-&gt;m_pkthdr.rcvif = lo_ifp;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MAC</span>
	mac_netinet_igmp_send(ifp, m0);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		<span class="enscript-comment">/*
		 * Use control service class if the interface supports
		 * transmit-start model.
		 */</span>
		(<span class="enscript-type">void</span>) m_set_service_class(m0, MBUF_SC_CTL);
	}
	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
	error = ip_output(m0, ipopts, &amp;ro, 0, imo, NULL);
	ROUTE_RELEASE(&amp;ro);

	IMO_REMREF(imo);

	<span class="enscript-keyword">if</span> (error) {
		IGMP_PRINTF((<span class="enscript-string">&quot;%s: ip_output(0x%llx) = %d\n&quot;</span>, __func__,
		    (uint64_t)VM_KERNEL_ADDRPERM(m0), error));
		<span class="enscript-keyword">return</span>;
	}

	IGMPSTAT_INC(igps_snd_reports);
	OIGMPSTAT_INC(igps_snd_reports);
}
<span class="enscript-comment">/*
 * Encapsulate an IGMPv3 report.
 *
 * The internal mbuf flag M_IGMPV3_HDR is used to indicate that the mbuf
 * chain has already had its IP/IGMPv3 header prepended. In this case
 * the function will not attempt to prepend; the lengths and checksums
 * will however be re-computed.
 *
 * Returns a pointer to the new mbuf chain head, or NULL if the
 * allocation failed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">igmp_v3_encap_report</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> igmp_report	*igmp;
	<span class="enscript-type">struct</span> ip		*ip;
	<span class="enscript-type">int</span>			 hdrlen, igmpreclen;

	VERIFY((m-&gt;m_flags &amp; M_PKTHDR));

	igmpreclen = m_length(m);
	hdrlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_report);

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_IGMPV3_HDR) {
		igmpreclen -= hdrlen;
	} <span class="enscript-keyword">else</span> {
		M_PREPEND(m, hdrlen, M_DONTWAIT, 1);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span> (NULL);
		m-&gt;m_flags |= M_IGMPV3_HDR;
	}

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: igmpreclen is %d\n&quot;</span>, __func__, igmpreclen));

	m-&gt;m_data += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	m-&gt;m_len -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);

	igmp = mtod(m, <span class="enscript-type">struct</span> igmp_report *);
	igmp-&gt;ir_type = IGMP_v3_HOST_MEMBERSHIP_REPORT;
	igmp-&gt;ir_rsv1 = 0;
	igmp-&gt;ir_rsv2 = 0;
	igmp-&gt;ir_numgrps = htons(m-&gt;m_pkthdr.vt_nrecs);
	igmp-&gt;ir_cksum = 0;
	igmp-&gt;ir_cksum = in_cksum(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> igmp_report) + igmpreclen);
	m-&gt;m_pkthdr.vt_nrecs = 0;

	m-&gt;m_data -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	m-&gt;m_len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	ip-&gt;ip_tos = IPTOS_PREC_INTERNETCONTROL;
	ip-&gt;ip_len = hdrlen + igmpreclen;
	ip-&gt;ip_off = IP_DF;
	ip-&gt;ip_p = IPPROTO_IGMP;
	ip-&gt;ip_sum = 0;

	ip-&gt;ip_src.s_addr = INADDR_ANY;

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_IGMP_LOOP) {
		<span class="enscript-type">struct</span> in_ifaddr *ia;

		IFP_TO_IA(ifp, ia);
		<span class="enscript-keyword">if</span> (ia != NULL) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			ip-&gt;ip_src = ia-&gt;ia_addr.sin_addr;
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
		}
	}

	ip-&gt;ip_dst.s_addr = htonl(INADDR_ALLRPTS_GROUP);

	<span class="enscript-keyword">return</span> (m);
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IGMP_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">igmp_rec_type_to_str</span>(<span class="enscript-type">const</span> <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">switch</span> (type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_CHANGE_TO_EXCLUDE_MODE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;TO_EX&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_CHANGE_TO_INCLUDE_MODE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;TO_IN&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_MODE_IS_EXCLUDE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;MODE_EX&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_MODE_IS_INCLUDE</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;MODE_IN&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_ALLOW_NEW_SOURCES</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;ALLOW_NEW&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IGMP_BLOCK_OLD_SOURCES</span>:
			<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;BLOCK_OLD&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> <span class="enscript-string">&quot;unknown&quot;</span>;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">igmp_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> igmp_initialized = 0;

	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-keyword">if</span> (igmp_initialized)
		<span class="enscript-keyword">return</span>;
	igmp_initialized = 1;

	IGMP_PRINTF((<span class="enscript-string">&quot;%s: initializing\n&quot;</span>, __func__));

	igmp_timers_are_running = 0;

	<span class="enscript-comment">/* Setup lock group and attribute for igmp_mtx */</span>
	igmp_mtx_grp_attr = lck_grp_attr_alloc_init();
	igmp_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;igmp_mtx&quot;</span>, igmp_mtx_grp_attr);
	igmp_mtx_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;igmp_mtx, igmp_mtx_grp, igmp_mtx_attr);

	LIST_INIT(&amp;igi_head);
	m_raopt = igmp_ra_alloc();

	igi_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> igmp_ifinfo);
	igi_zone = zinit(igi_size, IGI_ZONE_MAX * igi_size,
	    0, IGI_ZONE_NAME);
	<span class="enscript-keyword">if</span> (igi_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, IGI_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(igi_zone, Z_EXPAND, TRUE);
	zone_change(igi_zone, Z_CALLERACCT, FALSE);
}
</pre>
<hr />
</body></html>