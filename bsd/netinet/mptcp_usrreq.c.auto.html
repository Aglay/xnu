<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mptcp_usrreq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mptcp_usrreq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_timer.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_detach</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_detach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mppcb *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_connectx</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_list **, <span class="enscript-type">struct</span> proc *, uint32_t, sae_associd_t,
    sae_connid_t *, uint32_t, <span class="enscript-type">void</span> *, uint32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_connectx</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_list **, <span class="enscript-type">struct</span> proc *, uint32_t, sae_associd_t,
    sae_connid_t *, uint32_t, <span class="enscript-type">void</span> *, uint32_t, <span class="enscript-type">struct</span> uio *, user_ssize_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_getassocids</span>(<span class="enscript-type">struct</span> mptses *, uint32_t *, user_addr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_getconnids</span>(<span class="enscript-type">struct</span> mptses *, sae_associd_t, uint32_t *,
    user_addr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_getconninfo</span>(<span class="enscript-type">struct</span> mptses *, sae_connid_t *, uint32_t *,
    uint32_t *, int32_t *, user_addr_t, socklen_t *, user_addr_t, socklen_t *,
    uint32_t *, user_addr_t, uint32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_control</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_disconnectx</span>(<span class="enscript-type">struct</span> mptses *, sae_associd_t, sae_connid_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_disconnectx</span>(<span class="enscript-type">struct</span> socket *, sae_associd_t, sae_connid_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mptses *<span class="enscript-function-name">mptcp_usrclosed</span>(<span class="enscript-type">struct</span> mptses *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_peeloff</span>(<span class="enscript-type">struct</span> socket *, sae_associd_t, <span class="enscript-type">struct</span> socket **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_peeloff</span>(<span class="enscript-type">struct</span> mptses *, sae_associd_t, <span class="enscript-type">struct</span> socket **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_rcvd</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_send</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *,
    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_shutdown</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_uiotombuf</span>(<span class="enscript-type">struct</span> uio *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, uint32_t, <span class="enscript-type">struct</span> mbuf **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_sosend</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> uio *,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_usr_socheckopt</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_setopt_apply</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> mptopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_setopt</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_getopt</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mptcp_default_tcp_optval</span>(<span class="enscript-type">struct</span> mptses *, <span class="enscript-type">struct</span> sockopt *, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mptcp_connorder_helper</span>(<span class="enscript-type">struct</span> mptsub *mpts);

<span class="enscript-type">struct</span> pr_usrreqs mptcp_usrreqs = {
	.pru_attach =		mptcp_usr_attach,
	.pru_connectx =		mptcp_usr_connectx,
	.pru_control =		mptcp_usr_control,
	.pru_detach =		mptcp_usr_detach,
	.pru_disconnect =	mptcp_usr_disconnect,
	.pru_disconnectx =	mptcp_usr_disconnectx,
	.pru_peeloff =		mptcp_usr_peeloff,
	.pru_rcvd =		mptcp_usr_rcvd,
	.pru_send =		mptcp_usr_send,
	.pru_shutdown =		mptcp_usr_shutdown,
	.pru_sosend =		mptcp_usr_sosend,
	.pru_soreceive =	soreceive,
	.pru_socheckopt =	mptcp_usr_socheckopt,
};

<span class="enscript-comment">/*
 * Attaches an MPTCP control block to a socket.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_attach</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">int</span> error;

	VERIFY(sotomppcb(mp_so) == NULL);

	error = mptcp_attach(mp_so, p);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-comment">/*
	 * XXX: <a href="mailto:adi@apple.com">adi@apple.com</a>
	 *
	 * Might want to use a different SO_LINGER timeout than TCP's?
	 */</span>
	<span class="enscript-keyword">if</span> ((mp_so-&gt;so_options &amp; SO_LINGER) &amp;&amp; mp_so-&gt;so_linger == 0)
		mp_so-&gt;so_linger = TCP_LINGERTIME * hz;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Detaches an MPTCP control block from a socket.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_detach</span>(<span class="enscript-type">struct</span> socket *mp_so)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">int</span> error = 0;

	VERIFY(mpp != NULL);
	VERIFY(mpp-&gt;mpp_socket != NULL);

	error = mptcp_detach(mp_so, mpp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Attach MPTCP protocol to socket, allocating MP control block,
 * MPTCP session, control block, buffer space, etc.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_attach</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> mptses *mpte = NULL;
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;
	<span class="enscript-type">struct</span> mppcb *mpp = NULL;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mp_so-&gt;so_snd.sb_hiwat == 0 || mp_so-&gt;so_rcv.sb_hiwat == 0) {
		error = soreserve(mp_so, tcp_sendspace, MPTCP_RWIN_MAX);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * MPTCP socket buffers cannot be compressed, due to the
	 * fact that each mbuf chained via m_next is a M_PKTHDR
	 * which carries some MPTCP metadata.
	 */</span>
	mp_so-&gt;so_snd.sb_flags |= SB_NOCOMPRESS;
	mp_so-&gt;so_rcv.sb_flags |= SB_NOCOMPRESS;

	<span class="enscript-comment">/* Disable socket buffer auto-tuning. */</span>
	mp_so-&gt;so_rcv.sb_flags &amp;= ~SB_AUTOSIZE;
	mp_so-&gt;so_snd.sb_flags &amp;= ~SB_AUTOSIZE;

	<span class="enscript-keyword">if</span> ((error = mp_pcballoc(mp_so, &amp;mtcbinfo)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	mpp = sotomppcb(mp_so);
	VERIFY(mpp != NULL);
	mpte = (<span class="enscript-type">struct</span> mptses *)mpp-&gt;mpp_pcbe;
	VERIFY(mpte != NULL);
	mp_tp = mpte-&gt;mpte_mptcb;
	VERIFY(mp_tp != NULL);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Called when the socket layer loses its final reference to the socket;
 * at this point, there is only one case in which we will keep things
 * around: time wait.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_detach</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> mppcb *mpp)
{
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">struct</span> mppcbinfo *mppi;

	VERIFY(mp_so-&gt;so_pcb == mpp);
	VERIFY(mpp-&gt;mpp_socket == mp_so);

	mppi = mpp-&gt;mpp_pcbinfo;
	VERIFY(mppi != NULL);

	__IGNORE_WCASTALIGN(mpte = &amp;((<span class="enscript-type">struct</span> mpp_mtp *)mpp)-&gt;mpp_ses);
	VERIFY(mpte-&gt;mpte_mppcb == mpp);

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-comment">/*
	 * We are done with this MPTCP socket (it has been closed);
	 * trigger all subflows to be disconnected, if not already,
	 * by initiating the PCB detach sequence (SOF_PCBCLEARING
	 * will be set.)
	 */</span>
	mp_pcbdetach(mpp);

	(<span class="enscript-type">void</span>) mptcp_disconnectx(mpte, SAE_ASSOCID_ALL, SAE_CONNID_ALL);

	<span class="enscript-comment">/*
	 * XXX: <a href="mailto:adi@apple.com">adi@apple.com</a>
	 *
	 * Here, we would want to handle time wait state.
	 */</span>

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Common subroutine to open a MPTCP connection to one of the remote hosts
 * specified by dst_sl.  This includes allocating and establishing a
 * subflow TCP connection, either initially to establish MPTCP connection,
 * or to join an existing one.  Returns a connection handle upon success.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_connectx</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">aid</span>, <span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">arglen</span>)
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	VERIFY(dst_sl != NULL &amp;&amp; *dst_sl != NULL);
	VERIFY(pcid != NULL);

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: mp_so 0x%llx\n&quot;</span>, __func__,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so)),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

	DTRACE_MPTCP3(connectx, <span class="enscript-type">struct</span> mptses *, mpte, sae_associd_t, aid,
	    <span class="enscript-type">struct</span> socket *, mp_so);

	mpts = mptcp_subflow_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (mpts == NULL) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	MPTS_ADDREF(mpts);		<span class="enscript-comment">/* for this routine */</span>

	<span class="enscript-keyword">if</span> (src_sl != NULL) {
		mpts-&gt;mpts_src_sl = *src_sl;
		*src_sl = NULL;
	}
	mpts-&gt;mpts_dst_sl = *dst_sl;
	*dst_sl = NULL;

	error = mptcp_subflow_add(mpte, mpts, p, ifscope);
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pcid != NULL)
		*pcid = mpts-&gt;mpts_connid;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (mpts != NULL) {
		<span class="enscript-keyword">if</span> ((error != 0) &amp;&amp; (error != EWOULDBLOCK)) {
			MPTS_LOCK(mpts);
			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_ATTACHED) {
				MPTS_UNLOCK(mpts);
				MPTS_REMREF(mpts);
				mptcp_subflow_del(mpte, mpts, TRUE);
				<span class="enscript-keyword">return</span> (error);
			}
			MPTS_UNLOCK(mpts);
		}
		MPTS_REMREF(mpts);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * User-protocol pru_connectx callback.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_connectx</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">arglen</span>, <span class="enscript-variable-name">uio</span>, <span class="enscript-variable-name">bytes_written</span>)
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte = NULL;
	<span class="enscript-type">struct</span> mptcb *mp_tp = NULL;

	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	mp_tp = mpte-&gt;mpte_mptcb;
	VERIFY(mp_tp != NULL);

	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_flags &amp;  MPTCPF_FALLBACK_TO_TCP) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = mptcp_connectx(mpte, src_sl, dst_sl, p, ifscope,
	    aid, pcid, flags, arg, arglen);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SIOCGASSOCIDS ioctl for PF_MULTIPATH domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_getassocids</span>(<span class="enscript-type">struct</span> mptses *mpte, uint32_t *cnt, user_addr_t aidp)
{
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-comment">/* MPTCP has at most 1 association */</span>
	*cnt = (mpte-&gt;mpte_associd != SAE_ASSOCID_ANY) ? 1 : 0;

	<span class="enscript-comment">/* just asking how many there are? */</span>
	<span class="enscript-keyword">if</span> (aidp == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (copyout(&amp;mpte-&gt;mpte_associd, aidp,
	    <span class="enscript-keyword">sizeof</span> (mpte-&gt;mpte_associd)));
}

<span class="enscript-comment">/*
 * Handle SIOCGCONNIDS ioctl for PF_MULTIPATH domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_getconnids</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_associd_t aid, uint32_t *cnt,
    user_addr_t cidp)
{
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL &amp;&amp;
	    aid != mpte-&gt;mpte_associd)
		<span class="enscript-keyword">return</span> (EINVAL);

	*cnt = mpte-&gt;mpte_numflows;

	<span class="enscript-comment">/* just asking how many there are? */</span>
	<span class="enscript-keyword">if</span> (cidp == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);

	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;mpts-&gt;mpts_connid, cidp,
		    <span class="enscript-keyword">sizeof</span> (mpts-&gt;mpts_connid))) != 0)
			<span class="enscript-keyword">break</span>;

		cidp += <span class="enscript-keyword">sizeof</span> (mpts-&gt;mpts_connid);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SIOCGCONNINFO ioctl for PF_MULTIPATH domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_getconninfo</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_connid_t *cid, uint32_t *flags,
    uint32_t *ifindex, int32_t *soerror, user_addr_t src, socklen_t *src_len,
    user_addr_t dst, socklen_t *dst_len, uint32_t *aux_type,
    user_addr_t aux_data, uint32_t *aux_len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">aux_data</span>)
	<span class="enscript-type">struct</span> sockaddr_entry *se;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-keyword">if</span> (*cid == SAE_CONNID_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_connid == *cid || *cid == SAE_CONNID_ANY)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (mpts == NULL)
		<span class="enscript-keyword">return</span> ((*cid == SAE_CONNID_ANY) ? ENXIO : EINVAL);

	MPTS_LOCK(mpts);
	ifp = mpts-&gt;mpts_outif;
	*cid = mpts-&gt;mpts_connid;
	*ifindex = ((ifp != NULL) ? ifp-&gt;if_index : 0);
	*soerror = mpts-&gt;mpts_soerror;
	*flags = 0;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_CONNECTING)
		*flags |= CIF_CONNECTING;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_CONNECTED)
		*flags |= CIF_CONNECTED;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTING)
		*flags |= CIF_DISCONNECTING;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_DISCONNECTED)
		*flags |= CIF_DISCONNECTED;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_BOUND_IF)
		*flags |= CIF_BOUND_IF;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_BOUND_IP)
		*flags |= CIF_BOUND_IP;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_BOUND_PORT)
		*flags |= CIF_BOUND_PORT;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_PREFERRED)
		*flags |= CIF_PREFERRED;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE)
		*flags |= CIF_MP_CAPABLE;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_DEGRADED)
		*flags |= CIF_MP_DEGRADED;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_READY)
		*flags |= CIF_MP_READY;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_ACTIVE)
		*flags |= CIF_MP_ACTIVE;

	VERIFY(mpts-&gt;mpts_src_sl != NULL);
	se = TAILQ_FIRST(&amp;mpts-&gt;mpts_src_sl-&gt;sl_head);
	VERIFY(se != NULL &amp;&amp; se-&gt;se_addr != NULL);
	*src_len = se-&gt;se_addr-&gt;sa_len;
	<span class="enscript-keyword">if</span> (src != USER_ADDR_NULL) {
		error = copyout(se-&gt;se_addr, src, se-&gt;se_addr-&gt;sa_len);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VERIFY(mpts-&gt;mpts_dst_sl != NULL);
	se = TAILQ_FIRST(&amp;mpts-&gt;mpts_dst_sl-&gt;sl_head);
	VERIFY(se != NULL &amp;&amp; se-&gt;se_addr != NULL);
	*dst_len = se-&gt;se_addr-&gt;sa_len;
	<span class="enscript-keyword">if</span> (dst != USER_ADDR_NULL) {
		error = copyout(se-&gt;se_addr, dst, se-&gt;se_addr-&gt;sa_len);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	*aux_type = 0;
	*aux_len = 0;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_socket != NULL) {
		<span class="enscript-type">struct</span> conninfo_tcp tcp_ci;
		
		*aux_type = CIAUX_TCP;
		*aux_len = <span class="enscript-keyword">sizeof</span> (tcp_ci);
		
		<span class="enscript-keyword">if</span> (aux_data != USER_ADDR_NULL) {
			<span class="enscript-type">struct</span> socket *so = mpts-&gt;mpts_socket;

			VERIFY(SOCK_PROTO(so) == IPPROTO_TCP);
			bzero(&amp;tcp_ci, <span class="enscript-keyword">sizeof</span> (tcp_ci));
			socket_lock(so, 0);
			tcp_getconninfo(so, &amp;tcp_ci);
			socket_unlock(so, 0);
			error = copyout(&amp;tcp_ci, aux_data, <span class="enscript-keyword">sizeof</span> (tcp_ci));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d flags %x \n&quot;</span>,
	    __func__, mpts-&gt;mpts_connid, mpts-&gt;mpts_flags),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

<span class="enscript-reference">out</span>:
	MPTS_UNLOCK(mpts);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SIOCSCONNORDER
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_setconnorder</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_connid_t cid, uint32_t rank)
{
	<span class="enscript-type">struct</span> mptsub *mpts, *mpts1;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: cid %d rank %d \n&quot;</span>, __func__, cid, rank),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_VERBOSE);

	<span class="enscript-keyword">if</span> (cid == SAE_CONNID_ANY || cid == SAE_CONNID_ALL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_connid == cid)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (mpts == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (rank == 0 || rank &gt; 1) {
		<span class="enscript-comment">/*
		 * If rank is 0, determine whether this should be the
		 * primary or backup subflow, depending on what we have.
		 *
		 * Otherwise, if greater than 0, make it a backup flow.
		 */</span>
		TAILQ_FOREACH(mpts1, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			MPTS_LOCK(mpts1);
			<span class="enscript-keyword">if</span> (mpts1-&gt;mpts_flags &amp; MPTSF_PREFERRED) {
				MPTS_UNLOCK(mpts1);
				<span class="enscript-keyword">break</span>;
			}
			MPTS_UNLOCK(mpts1);
		}

		MPTS_LOCK(mpts);
		mpts-&gt;mpts_flags &amp;= ~MPTSF_PREFERRED;
		mpts-&gt;mpts_rank = rank;
		<span class="enscript-keyword">if</span> (mpts1 != NULL &amp;&amp; mpts != mpts1) {
			<span class="enscript-comment">/* preferred subflow found; set rank as necessary */</span>
			<span class="enscript-keyword">if</span> (rank == 0)
				mpts-&gt;mpts_rank = (mpts1-&gt;mpts_rank + 1);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rank == 0) {
			<span class="enscript-comment">/* no preferred one found; promote this */</span>
			rank = 1;
		}
		MPTS_UNLOCK(mpts);
	}

	<span class="enscript-keyword">if</span> (rank == 1) {
		<span class="enscript-comment">/*
		 * If rank is 1, promote this subflow to be preferred.
		 */</span>
		TAILQ_FOREACH(mpts1, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			MPTS_LOCK(mpts1);
			<span class="enscript-keyword">if</span> (mpts1 != mpts &amp;&amp;
			    (mpts1-&gt;mpts_flags &amp; MPTSF_PREFERRED)) {
				mpts1-&gt;mpts_flags &amp;= ~MPTSF_PREFERRED;
				<span class="enscript-keyword">if</span> (mpte-&gt;mpte_nummpcapflows &gt; 1)
					mptcp_connorder_helper(mpts1);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mpts1 == mpts) {
				mpts1-&gt;mpts_rank = 1;
				<span class="enscript-keyword">if</span> (mpts1-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE) {
					mpts1-&gt;mpts_flags |= MPTSF_PREFERRED;
					<span class="enscript-keyword">if</span> (mpte-&gt;mpte_nummpcapflows &gt; 1)
						mptcp_connorder_helper(mpts1);
				}
			}
			MPTS_UNLOCK(mpts1);
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mptcp_connorder_helper</span>(<span class="enscript-type">struct</span> mptsub *mpts)
{
	<span class="enscript-type">struct</span> socket *so = mpts-&gt;mpts_socket;
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;

	socket_lock(so, 0);
	
	tp = intotcpcb(sotoinpcb(so));
	tp-&gt;t_mpflags |= TMPF_SND_MPPRIO;
	<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_PREFERRED)
		tp-&gt;t_mpflags &amp;= ~TMPF_BACKUP_PATH;
	<span class="enscript-keyword">else</span>
		tp-&gt;t_mpflags |= TMPF_BACKUP_PATH;

	socket_unlock(so, 0);

}

<span class="enscript-comment">/*
 * Handle SIOCSGONNORDER
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_getconnorder</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_connid_t cid, uint32_t *rank)
{
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	VERIFY(rank != NULL);
	*rank = 0;

	<span class="enscript-keyword">if</span> (cid == SAE_CONNID_ANY || cid == SAE_CONNID_ALL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_connid == cid)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (mpts == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	MPTS_LOCK(mpts);
	*rank = mpts-&gt;mpts_rank;
	MPTS_UNLOCK(mpts);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * User-protocol pru_control callback.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_control</span>(<span class="enscript-type">struct</span> socket *mp_so, u_long cmd, caddr_t data,
    <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>: {		<span class="enscript-comment">/* struct so_aidreq32 */</span>
		<span class="enscript-type">struct</span> so_aidreq32 aidr;
		bcopy(data, &amp;aidr, <span class="enscript-keyword">sizeof</span> (aidr));
		error = mptcp_getassocids(mpte, &amp;aidr.sar_cnt,
		    aidr.sar_aidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;aidr, data, <span class="enscript-keyword">sizeof</span> (aidr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>: {		<span class="enscript-comment">/* struct so_aidreq64 */</span>
		<span class="enscript-type">struct</span> so_aidreq64 aidr;
		bcopy(data, &amp;aidr, <span class="enscript-keyword">sizeof</span> (aidr));
		error = mptcp_getassocids(mpte, &amp;aidr.sar_cnt,
		    aidr.sar_aidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;aidr, data, <span class="enscript-keyword">sizeof</span> (aidr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>: {		<span class="enscript-comment">/* struct so_cidreq32 */</span>
		<span class="enscript-type">struct</span> so_cidreq32 cidr;
		bcopy(data, &amp;cidr, <span class="enscript-keyword">sizeof</span> (cidr));
		error = mptcp_getconnids(mpte, cidr.scr_aid, &amp;cidr.scr_cnt,
		    cidr.scr_cidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cidr, data, <span class="enscript-keyword">sizeof</span> (cidr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>: {		<span class="enscript-comment">/* struct so_cidreq64 */</span>
		<span class="enscript-type">struct</span> so_cidreq64 cidr;
		bcopy(data, &amp;cidr, <span class="enscript-keyword">sizeof</span> (cidr));
		error = mptcp_getconnids(mpte, cidr.scr_aid, &amp;cidr.scr_cnt,
		    cidr.scr_cidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cidr, data, <span class="enscript-keyword">sizeof</span> (cidr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>: {		<span class="enscript-comment">/* struct so_cinforeq32 */</span>
		<span class="enscript-type">struct</span> so_cinforeq32 cifr;
		bcopy(data, &amp;cifr, <span class="enscript-keyword">sizeof</span> (cifr));
		error = mptcp_getconninfo(mpte, &amp;cifr.scir_cid,
		    &amp;cifr.scir_flags, &amp;cifr.scir_ifindex, &amp;cifr.scir_error,
		    cifr.scir_src, &amp;cifr.scir_src_len, cifr.scir_dst,
		    &amp;cifr.scir_dst_len, &amp;cifr.scir_aux_type, cifr.scir_aux_data,
		    &amp;cifr.scir_aux_len);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cifr, data, <span class="enscript-keyword">sizeof</span> (cifr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>: {		<span class="enscript-comment">/* struct so_cinforeq64 */</span>
		<span class="enscript-type">struct</span> so_cinforeq64 cifr;
		bcopy(data, &amp;cifr, <span class="enscript-keyword">sizeof</span> (cifr));
		error = mptcp_getconninfo(mpte, &amp;cifr.scir_cid,
		    &amp;cifr.scir_flags, &amp;cifr.scir_ifindex, &amp;cifr.scir_error,
		    cifr.scir_src, &amp;cifr.scir_src_len, cifr.scir_dst,
		    &amp;cifr.scir_dst_len, &amp;cifr.scir_aux_type, cifr.scir_aux_data,
		    &amp;cifr.scir_aux_len);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cifr, data, <span class="enscript-keyword">sizeof</span> (cifr));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSCONNORDER</span>: {		<span class="enscript-comment">/* struct so_cordreq */</span>
		<span class="enscript-type">struct</span> so_cordreq cor;
		bcopy(data, &amp;cor, <span class="enscript-keyword">sizeof</span> (cor));
		error = mptcp_setconnorder(mpte, cor.sco_cid, cor.sco_rank);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cor, data, <span class="enscript-keyword">sizeof</span> (cor));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNORDER</span>: {		<span class="enscript-comment">/* struct so_cordreq */</span>
		<span class="enscript-type">struct</span> so_cordreq cor;
		bcopy(data, &amp;cor, <span class="enscript-keyword">sizeof</span> (cor));
		error = mptcp_getconnorder(mpte, cor.sco_cid, &amp;cor.sco_rank);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;cor, data, <span class="enscript-keyword">sizeof</span> (cor));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		error = EOPNOTSUPP;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Initiate a disconnect.  MPTCP-level disconnection is specified by
 * CONNID_{ANY,ALL}.  Otherwise, selectively disconnect a subflow
 * connection while keeping the MPTCP-level connection (association).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_disconnectx</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_associd_t aid, sae_connid_t cid)
{
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: mp_so 0x%llx aid %d cid %d %d\n&quot;</span>, __func__,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), aid, cid, mp_so-&gt;so_error),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

	DTRACE_MPTCP5(disconnectx, <span class="enscript-type">struct</span> mptses *, mpte, sae_associd_t, aid,
	    sae_connid_t, cid, <span class="enscript-type">struct</span> socket *, mp_so, <span class="enscript-type">struct</span> mptcb *, mp_tp);

	VERIFY(aid == SAE_ASSOCID_ANY || aid == SAE_ASSOCID_ALL ||
	    aid == mpte-&gt;mpte_associd);

	<span class="enscript-comment">/* terminate the association? */</span>
	<span class="enscript-keyword">if</span> (cid == SAE_CONNID_ANY || cid == SAE_CONNID_ALL) {
		<span class="enscript-comment">/* if we're not detached, go thru socket state checks */</span>
		<span class="enscript-keyword">if</span> (!(mp_so-&gt;so_flags &amp; SOF_PCBCLEARING)) {
			<span class="enscript-keyword">if</span> (!(mp_so-&gt;so_state &amp; (SS_ISCONNECTED|
			    SS_ISCONNECTING))) {
				error = ENOTCONN;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (mp_so-&gt;so_state &amp; SS_ISDISCONNECTING) {
				error = EALREADY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		MPT_LOCK(mp_tp);
		mptcp_cancel_all_timers(mp_tp);
		<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &lt; MPTCPS_ESTABLISHED) {
			(<span class="enscript-type">void</span>) mptcp_close(mpte, mp_tp);
			MPT_UNLOCK(mp_tp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mp_so-&gt;so_options &amp; SO_LINGER) &amp;&amp;
		    mp_so-&gt;so_linger == 0) {
			(<span class="enscript-type">void</span>) mptcp_drop(mpte, mp_tp, 0);
			MPT_UNLOCK(mp_tp);
		} <span class="enscript-keyword">else</span> {
			MPT_UNLOCK(mp_tp);
			soisdisconnecting(mp_so);
			sbflush(&amp;mp_so-&gt;so_rcv);
			<span class="enscript-keyword">if</span> (mptcp_usrclosed(mpte) != NULL)
				(<span class="enscript-type">void</span>) mptcp_output(mpte);
		}
	} <span class="enscript-keyword">else</span> {
		bool disconnect_embryonic_subflows = false;
		<span class="enscript-type">struct</span> socket *so = NULL;
		
		TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			<span class="enscript-keyword">if</span> (mpts-&gt;mpts_connid != cid)
				<span class="enscript-keyword">continue</span>;

			MPTS_LOCK(mpts);
			<span class="enscript-comment">/*
			 * Check if disconnected subflow is the one used
			 * to initiate MPTCP connection.
			 * If it is and the connection is not yet join ready
			 * disconnect all other subflows.
			 */</span>
			so = mpts-&gt;mpts_socket;
			<span class="enscript-keyword">if</span> (!(mp_tp-&gt;mpt_flags &amp; MPTCPF_JOIN_READY) &amp;&amp; 
			    so &amp;&amp; !(so-&gt;so_flags &amp; SOF_MP_SEC_SUBFLOW)) {
				disconnect_embryonic_subflows = true;
			}

			mpts-&gt;mpts_flags |= MPTSF_USER_DISCONNECT;
			mptcp_subflow_disconnect(mpte, mpts, FALSE);
			MPTS_UNLOCK(mpts);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (mpts == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-keyword">if</span> (disconnect_embryonic_subflows) {
			TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
				<span class="enscript-keyword">if</span> (mpts-&gt;mpts_connid == cid)
					<span class="enscript-keyword">continue</span>;
				MPTS_LOCK(mpts);
				mptcp_subflow_disconnect(mpte, mpts, TRUE);
				MPTS_UNLOCK(mpts);
			}
		}
	}

	<span class="enscript-keyword">if</span> (error == 0)
		mptcp_thread_signal(mpte);

	<span class="enscript-keyword">if</span> ((mp_so-&gt;so_state &amp; (SS_CANTRCVMORE | SS_CANTSENDMORE)) ==
	    (SS_CANTRCVMORE | SS_CANTSENDMORE)) {
		<span class="enscript-comment">/* the socket has been shutdown, no more sockopt's */</span>
		mptcp_flush_sopts(mpte);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Wrapper function to support disconnect on socket 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_disconnect</span>(<span class="enscript-type">struct</span> socket *mp_so)
{
	<span class="enscript-type">int</span> error = 0;

	error = mptcp_usr_disconnectx(mp_so, SAE_ASSOCID_ALL, SAE_CONNID_ALL);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * User-protocol pru_disconnectx callback.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_disconnectx</span>(<span class="enscript-type">struct</span> socket *mp_so, sae_associd_t aid, sae_connid_t cid)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL &amp;&amp;
	    aid != mpte-&gt;mpte_associd) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = mptcp_disconnectx(mpte, aid, cid);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * User issued close, and wish to trail thru shutdown states.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mptses *
<span class="enscript-function-name">mptcp_usrclosed</span>(<span class="enscript-type">struct</span> mptses *mpte)
{
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> mptcb *mp_tp;
	<span class="enscript-type">struct</span> mptsub *mpts;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;
	mp_tp = mpte-&gt;mpte_mptcb;

	MPT_LOCK(mp_tp);
	mptcp_close_fsm(mp_tp, MPCE_CLOSE);

	<span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state == MPTCPS_CLOSED) {
		mpte = mptcp_close(mpte, mp_tp);
		MPT_UNLOCK(mp_tp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mp_tp-&gt;mpt_state &gt;= MPTCPS_FIN_WAIT_2) {
		MPT_UNLOCK(mp_tp);
		soisdisconnected(mp_so);
		TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			MPTS_LOCK(mpts);
			mpts-&gt;mpts_flags |= MPTSF_USER_DISCONNECT;
			MPTS_UNLOCK(mpts);
		}
	} <span class="enscript-keyword">else</span> {
		MPT_UNLOCK(mp_tp);

		TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
			MPTS_LOCK(mpts);
			mpts-&gt;mpts_flags |= MPTSF_USER_DISCONNECT;
			mptcp_subflow_disconnect(mpte, mpts, FALSE);
			MPTS_UNLOCK(mpts);
		}
	}

	<span class="enscript-keyword">return</span> (mpte);
}

<span class="enscript-comment">/*
 * User-protocol pru_peeloff callback.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_peeloff</span>(<span class="enscript-type">struct</span> socket *mp_so, sae_associd_t aid, <span class="enscript-type">struct</span> socket **psop)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(psop != NULL);

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	error = mptcp_peeloff(mpte, aid, psop);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Transform a previously connected TCP subflow connection which has
 * failed to negotiate MPTCP to its own socket which can be externalized
 * with a file descriptor.  Valid only when the MPTCP socket is not
 * yet associated (MPTCP-level connection has not been established.)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_peeloff</span>(<span class="enscript-type">struct</span> mptses *mpte, sae_associd_t aid, <span class="enscript-type">struct</span> socket **psop)
{
	<span class="enscript-type">struct</span> socket *so = NULL, *mp_so;
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">int</span> error = 0;

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	VERIFY(psop != NULL);
	*psop = NULL;

	DTRACE_MPTCP3(peeloff, <span class="enscript-type">struct</span> mptses *, mpte, sae_associd_t, aid,
	    <span class="enscript-type">struct</span> socket *, mp_so);

	<span class="enscript-comment">/* peeloff cannot happen after an association is established */</span>
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_associd != SAE_ASSOCID_ANY) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		MPTS_LOCK(mpts);
		<span class="enscript-keyword">if</span> (mpts-&gt;mpts_flags &amp; MPTSF_MP_CAPABLE) {
			panic(<span class="enscript-string">&quot;%s: so %p is MPTCP capable but mp_so %p &quot;</span>
			    <span class="enscript-string">&quot;aid is %d\n&quot;</span>, __func__, so, mp_so,
			    mpte-&gt;mpte_associd);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		MPTS_ADDREF_LOCKED(mpts);	<span class="enscript-comment">/* for us */</span>
		so = mpts-&gt;mpts_socket;
		VERIFY(so != NULL);
		<span class="enscript-comment">/*
		 * This subflow socket is about to be externalized; make it
		 * appear as if it has the same properties as the MPTCP socket,
		 * undo what's done earlier in mptcp_subflow_add().
		 */</span>
		mptcp_subflow_sopeeloff(mpte, mpts, so);
		MPTS_UNLOCK(mpts);

		mptcp_subflow_del(mpte, mpts, FALSE);
		MPTS_REMREF(mpts);		<span class="enscript-comment">/* ours */</span>
		<span class="enscript-comment">/*
		 * XXX <a href="mailto:adi@apple.com">adi@apple.com</a>
		 *
		 * Here we need to make sure the subflow socket is not
		 * flow controlled; need to clear both INP_FLOW_CONTROLLED
		 * and INP_FLOW_SUSPENDED on the subflow socket, since
		 * we will no longer be monitoring its events.
		 */</span>
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (so == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	*psop = so;

	mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
	    <span class="enscript-string">&quot;%s: mp_so 0x%llx\n&quot;</span>, __func__,
	    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so)),
	    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * After a receive, possible send some update to peer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_rcvd</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>)
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	error = mptcp_output(mpte);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do a send by putting data in the output queue.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_send</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">int</span> prus_flags, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">nam</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (prus_flags &amp; (PRUS_OOB|PRUS_EOF)) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (nam != NULL) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (control != NULL &amp;&amp; control-&gt;m_len != 0) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = ECONNRESET;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	<span class="enscript-keyword">if</span> (!(mp_so-&gt;so_state &amp; SS_ISCONNECTED)) {
		error = ENOTCONN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	mptcp_insert_dsn(mpp, m);
	VERIFY(mp_so-&gt;so_snd.sb_flags &amp; SB_NOCOMPRESS);
	(<span class="enscript-type">void</span>) sbappendstream(&amp;mp_so-&gt;so_snd, m);
	m = NULL;

	<span class="enscript-keyword">if</span> (mpte != NULL) {
		<span class="enscript-comment">/*
		 * XXX: <a href="mailto:adi@apple.com">adi@apple.com</a>
		 *
		 * PRUS_MORETOCOME could be set, but we don't check it now.
		 */</span>
		error = mptcp_output(mpte);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		<span class="enscript-keyword">if</span> (control != NULL)
			m_freem(control);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Mark the MPTCP connection as being incapable of further output.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_shutdown</span>(<span class="enscript-type">struct</span> socket *mp_so)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	VERIFY(mpte != NULL);

	socantsendmore(mp_so);

	mpte = mptcp_usrclosed(mpte);
	<span class="enscript-keyword">if</span> (mpte != NULL)
		error = mptcp_output(mpte);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Copy the contents of uio into a properly sized mbuf chain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_uiotombuf</span>(<span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> how, <span class="enscript-type">int</span> space, uint32_t align,
    <span class="enscript-type">struct</span> mbuf **top)
{
	<span class="enscript-type">struct</span> mbuf *m, *mb, *nm = NULL, *mtail = NULL;
	user_ssize_t resid, tot, len, progress;	<span class="enscript-comment">/* must be user_ssize_t */</span>
	<span class="enscript-type">int</span> error;

	VERIFY(top != NULL &amp;&amp; *top == NULL);

	<span class="enscript-comment">/*
	 * space can be zero or an arbitrary large value bound by
	 * the total data supplied by the uio.
	 */</span>
	resid = uio_resid(uio);
	<span class="enscript-keyword">if</span> (space &gt; 0)
		tot = imin(resid, space);
	<span class="enscript-keyword">else</span>
		tot = resid;

	<span class="enscript-comment">/*
	 * The smallest unit is a single mbuf with pkthdr.
	 * We can't align past it.
	 */</span>
	<span class="enscript-keyword">if</span> (align &gt;= MHLEN)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Give us the full allocation or nothing.
	 * If space is zero return the smallest empty mbuf.
	 */</span>
	<span class="enscript-keyword">if</span> ((len = tot + align) == 0)
		len = 1;

	<span class="enscript-comment">/* Loop and append maximum sized mbufs to the chain tail. */</span>
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		uint32_t m_needed = 1;

		<span class="enscript-keyword">if</span> (njcl &gt; 0 &amp;&amp; len &gt; MBIGCLBYTES)
			mb = m_getpackets_internal(&amp;m_needed, 1,
			    how, 1, M16KCLBYTES);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len &gt; MCLBYTES)
			mb = m_getpackets_internal(&amp;m_needed, 1,
			    how, 1, MBIGCLBYTES);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len &gt;= (<span class="enscript-type">signed</span>)MINCLSIZE)
			mb = m_getpackets_internal(&amp;m_needed, 1,
			    how, 1, MCLBYTES);
		<span class="enscript-keyword">else</span>
			mb = m_gethdr(how, MT_DATA);

		<span class="enscript-comment">/* Fail the whole operation if one mbuf can't be allocated. */</span>
		<span class="enscript-keyword">if</span> (mb == NULL) {
			<span class="enscript-keyword">if</span> (nm != NULL)
				m_freem(nm);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}

		<span class="enscript-comment">/* Book keeping. */</span>
		VERIFY(mb-&gt;m_flags &amp; M_PKTHDR);
		len -= ((mb-&gt;m_flags &amp; M_EXT) ? mb-&gt;m_ext.ext_size : MHLEN);
		<span class="enscript-keyword">if</span> (mtail != NULL)
			mtail-&gt;m_next = mb;
		<span class="enscript-keyword">else</span>
			nm = mb;
		mtail = mb;
	}

	m = nm;
	m-&gt;m_data += align;

	progress = 0;
	<span class="enscript-comment">/* Fill all mbufs with uio data and update header information. */</span>
	<span class="enscript-keyword">for</span> (mb = m; mb != NULL; mb = mb-&gt;m_next) {
		len = imin(M_TRAILINGSPACE(mb), tot - progress);

		error = uiomove(mtod(mb, <span class="enscript-type">char</span> *), len, uio);
		<span class="enscript-keyword">if</span> (error != 0) {
			m_freem(m);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* each mbuf is M_PKTHDR chained via m_next */</span>
		mb-&gt;m_len = len;
		mb-&gt;m_pkthdr.len = len;

		progress += len;
	}
	VERIFY(progress == tot);
	*top = m;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * MPTCP socket protocol-user socket send routine, derived from sosend().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_sosend</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> uio *uio,
    <span class="enscript-type">struct</span> mbuf *top, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">int</span> flags)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">addr</span>)
	int32_t space;
	user_ssize_t resid;
	<span class="enscript-type">int</span> error, sendflags;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span> sblocked = 0;

	<span class="enscript-comment">/* UIO is required for now, due to per-mbuf M_PKTHDR constrains */</span>
	<span class="enscript-keyword">if</span> (uio == NULL || top != NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	resid = uio_resid(uio);

	socket_lock(mp_so, 1);
	so_update_last_owner_locked(mp_so, p);
	so_update_policy(mp_so);

	VERIFY(mp_so-&gt;so_type == SOCK_STREAM);
	VERIFY(!(mp_so-&gt;so_flags &amp; SOF_MP_SUBFLOW));

	<span class="enscript-keyword">if</span> ((flags &amp; (MSG_OOB|MSG_DONTROUTE|MSG_HOLD|MSG_SEND|MSG_FLUSH)) ||
	    (mp_so-&gt;so_flags &amp; SOF_ENABLE_MSGS)) {
		error = EOPNOTSUPP;
		socket_unlock(mp_so, 1);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * In theory resid should be unsigned.  However, space must be
	 * signed, as it might be less than 0 if we over-committed, and we
	 * must use a signed comparison of space and resid.  On the other
	 * hand, a negative resid causes us to loop sending 0-length
	 * segments to the protocol.
	 */</span>
	<span class="enscript-keyword">if</span> (resid &lt; 0 || (flags &amp; MSG_EOR) || control != NULL) {
		error = EINVAL;
		socket_unlock(mp_so, 1);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgsnd);

	<span class="enscript-keyword">do</span> {
		error = sosendcheck(mp_so, NULL, resid, 0, 0, flags,
		    &amp;sblocked, NULL);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

		space = sbspace(&amp;mp_so-&gt;so_snd);
		<span class="enscript-keyword">do</span> {
			socket_unlock(mp_so, 0);
			<span class="enscript-comment">/*
			 * Copy the data from userland into an mbuf chain.
			 */</span>
			error = mptcp_uiotombuf(uio, M_WAITOK, space, 0, &amp;top);
			<span class="enscript-keyword">if</span> (error != 0) {
				socket_lock(mp_so, 0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}
			VERIFY(top != NULL);
			space -= resid - uio_resid(uio);
			resid = uio_resid(uio);
			socket_lock(mp_so, 0);

			<span class="enscript-comment">/*
			 * Compute flags here, for pru_send and NKEs.
			 */</span>
			sendflags = (resid &gt; 0 &amp;&amp; space &gt; 0) ?
			    PRUS_MORETOCOME : 0;

			<span class="enscript-comment">/*
			 * Socket filter processing
			 */</span>
			VERIFY(control == NULL);
			error = sflt_data_out(mp_so, NULL, &amp;top, &amp;control, 0);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
					error = 0;
					top = NULL;
					<span class="enscript-comment">/* always free control if any */</span>
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}
			<span class="enscript-keyword">if</span> (control != NULL) {
				m_freem(control);
				control = NULL;
			}

			<span class="enscript-comment">/*
			 * Pass data to protocol.
			 */</span>
			error = (*mp_so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_send)
			    (mp_so, sendflags, top, NULL, NULL, p);

			top = NULL;
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		} <span class="enscript-keyword">while</span> (resid != 0 &amp;&amp; space &gt; 0);
	} <span class="enscript-keyword">while</span> (resid != 0);

<span class="enscript-reference">release</span>:
	<span class="enscript-keyword">if</span> (sblocked)
		sbunlock(&amp;mp_so-&gt;so_snd, FALSE); <span class="enscript-comment">/* will unlock socket */</span>
	<span class="enscript-keyword">else</span>
		socket_unlock(mp_so, 1);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (top != NULL)
		m_freem(top);
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Called to filter SOPT_{SET,GET} for SOL_SOCKET level socket options.
 * This routine simply indicates to the caller whether or not to proceed
 * further with the given socket option.  This is invoked by sosetoptlock()
 * and sogetoptlock().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_usr_socheckopt</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> sockopt *sopt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">mp_so</span>)
	<span class="enscript-type">int</span> error = 0;

	VERIFY(sopt-&gt;sopt_level == SOL_SOCKET);

	<span class="enscript-comment">/*
	 * We could check for sopt_dir (set/get) here, but we'll just
	 * let the caller deal with it as appropriate; therefore the
	 * following is a superset of the socket options which we
	 * allow for set/get.
	 *
	 * XXX: <a href="mailto:adi@apple.com">adi@apple.com</a>
	 *
	 * Need to consider the following cases:
	 *
	 *   a. In the event peeloff(2) occurs on the subflow socket,
	 *	we may want to issue those options which are now
	 *	handled at the MP socket.  In that case, we will need
	 *	to record them in mptcp_setopt() so that they can
	 *	be replayed during peeloff.
	 *
	 *   b.	Certain socket options don't have a clear definition
	 *	on the expected behavior post connect(2).  At the time
	 *	those options are issued on the MP socket, there may
	 *	be existing subflow sockets that are already connected.
	 */</span>
	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER_SEC</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TYPE</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NREAD</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NWRITE</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ERROR</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDBUF</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVBUF</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDLOWAT</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVLOWAT</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDTIMEO</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVTIMEO</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NKE</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOSIGPIPE</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOADDRERR</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LABEL</span>:				<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PEERLABEL</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEFUNCTOK</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ISDEFUNCT</span>:			<span class="enscript-comment">/* MP */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS_DBG</span>:		<span class="enscript-comment">/* MP */</span>
		<span class="enscript-comment">/*
		 * Tell the caller that these options are to be processed.
		 */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEBUG</span>:				<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_KEEPALIVE</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_USELOOPBACK</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RANDOMPORT</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_TRAFFIC_CLASS</span>:		<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PRIVILEGED_TRAFFIC_CLASS</span>:	<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_ANYIF</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RESTRICTIONS</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:				<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_MPTCP_FASTJOIN</span>:			<span class="enscript-comment">/* MP + subflow */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOWAKEFROMSLEEP</span>:
		<span class="enscript-comment">/*
		 * Tell the caller that these options are to be processed;
		 * these will also be recorded later by mptcp_setopt().
		 *
		 * NOTE: Only support integer option value for now.
		 */</span>
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * Tell the caller to stop immediately and return an error.
		 */</span>
		error = ENOPROTOOPT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Issue SOPT_SET for all MPTCP subflows (for integer option values.)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_setopt_apply</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> mptopt *mpo)
{
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">struct</span> mptsub *mpts;
	<span class="enscript-type">struct</span> mptopt smpo;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* just bail now if this isn't applicable to subflow sockets */</span>
	<span class="enscript-keyword">if</span> (!(mpo-&gt;mpo_flags &amp; MPOF_SUBFLOW_OK)) {
		error = ENOPROTOOPT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Skip those that are handled internally; these options
	 * should not have been recorded and marked with the
	 * MPOF_SUBFLOW_OK by mptcp_setopt(), but just in case.
	 */</span>
	<span class="enscript-keyword">if</span> (mpo-&gt;mpo_level == SOL_SOCKET &amp;&amp;
	    (mpo-&gt;mpo_name == SO_NOSIGPIPE || mpo-&gt;mpo_name == SO_NOADDRERR)) {
		error = ENOPROTOOPT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	<span class="enscript-comment">/*
	 * Don't bother going further if there's no subflow; mark the option
	 * with MPOF_INTERIM so that we know whether or not to remove this
	 * option upon encountering an error while issuing it during subflow
	 * socket creation.
	 */</span>
	<span class="enscript-keyword">if</span> (mpte-&gt;mpte_numflows == 0) {
		VERIFY(TAILQ_EMPTY(&amp;mpte-&gt;mpte_subflows));
		mpo-&gt;mpo_flags |= MPOF_INTERIM;
		<span class="enscript-comment">/* return success */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	bzero(&amp;smpo, <span class="enscript-keyword">sizeof</span> (smpo));
	smpo.mpo_flags |= MPOF_SUBFLOW_OK;
	smpo.mpo_level = mpo-&gt;mpo_level;
	smpo.mpo_name = mpo-&gt;mpo_name;

	<span class="enscript-comment">/* grab exisiting values in case we need to rollback */</span>
	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-type">struct</span> socket *so;

		MPTS_LOCK(mpts);
		mpts-&gt;mpts_flags &amp;= ~(MPTSF_SOPT_OLDVAL|MPTSF_SOPT_INPROG);
		mpts-&gt;mpts_oldintval = 0;
		smpo.mpo_intval = 0;
		VERIFY(mpts-&gt;mpts_socket != NULL);
		so = mpts-&gt;mpts_socket;
		socket_lock(so, 0);
		<span class="enscript-keyword">if</span> (mptcp_subflow_sogetopt(mpte, so, &amp;smpo) == 0) {
			mpts-&gt;mpts_flags |= MPTSF_SOPT_OLDVAL;
			mpts-&gt;mpts_oldintval = smpo.mpo_intval;
		}
		socket_unlock(so, 0);
		MPTS_UNLOCK(mpts);
	}

	<span class="enscript-comment">/* apply socket option */</span>
	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-type">struct</span> socket *so;

		MPTS_LOCK(mpts);
		mpts-&gt;mpts_flags |= MPTSF_SOPT_INPROG;
		VERIFY(mpts-&gt;mpts_socket != NULL);
		so = mpts-&gt;mpts_socket;
		socket_lock(so, 0);
		error = mptcp_subflow_sosetopt(mpte, so, mpo);
		socket_unlock(so, 0);
		MPTS_UNLOCK(mpts);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* cleanup, and rollback if needed */</span>
	TAILQ_FOREACH(mpts, &amp;mpte-&gt;mpte_subflows, mpts_entry) {
		<span class="enscript-type">struct</span> socket *so;

		MPTS_LOCK(mpts);
		<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_SOPT_INPROG)) {
			<span class="enscript-comment">/* clear in case it's set */</span>
			mpts-&gt;mpts_flags &amp;= ~MPTSF_SOPT_OLDVAL;
			mpts-&gt;mpts_oldintval = 0;
			MPTS_UNLOCK(mpts);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (!(mpts-&gt;mpts_flags &amp; MPTSF_SOPT_OLDVAL)) {
			mpts-&gt;mpts_flags &amp;= ~MPTSF_SOPT_INPROG;
			VERIFY(mpts-&gt;mpts_oldintval == 0);
			MPTS_UNLOCK(mpts);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* error during sosetopt, so roll it back */</span>
		<span class="enscript-keyword">if</span> (error != 0) {
			VERIFY(mpts-&gt;mpts_socket != NULL);
			so = mpts-&gt;mpts_socket;
			socket_lock(so, 0);
			smpo.mpo_intval = mpts-&gt;mpts_oldintval;
			(<span class="enscript-type">void</span>) mptcp_subflow_sosetopt(mpte, so, &amp;smpo);
			socket_unlock(so, 0);
		}
		mpts-&gt;mpts_oldintval = 0;
		mpts-&gt;mpts_flags &amp;= ~(MPTSF_SOPT_OLDVAL|MPTSF_SOPT_INPROG);
		MPTS_UNLOCK(mpts);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SOPT_SET for socket options issued on MP socket.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_setopt</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0, optval, level, optname, rec = 1;
	<span class="enscript-type">struct</span> mptopt smpo, *mpo = NULL;
	<span class="enscript-type">struct</span> socket *mp_so;
	<span class="enscript-type">char</span> buf[32];

	level = sopt-&gt;sopt_level;
	optname = sopt-&gt;sopt_name;

	VERIFY(sopt-&gt;sopt_dir == SOPT_SET);
	VERIFY(level == SOL_SOCKET || level == IPPROTO_TCP);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>
	mp_so = mpte-&gt;mpte_mppcb-&gt;mpp_socket;

	<span class="enscript-comment">/*
	 * Record socket options which are applicable to subflow sockets so
	 * that we can replay them for new ones; see mptcp_usr_socheckopt()
	 * for the list of eligible socket-level options.
	 */</span>
	<span class="enscript-keyword">if</span> (level == SOL_SOCKET) {
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEBUG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_KEEPALIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_USELOOPBACK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RANDOMPORT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_TRAFFIC_CLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PRIVILEGED_TRAFFIC_CLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_ANYIF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RESTRICTIONS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOWAKEFROMSLEEP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_MPTCP_FASTJOIN</span>:
			<span class="enscript-comment">/* record it */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-comment">/* don't record it */</span>
			rec = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* nothing to do; just return success */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
			<span class="enscript-comment">/* eligible; record it */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
			<span class="enscript-comment">/* record at MPTCP level */</span>
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
			    <span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (optval == 0) {
					mp_so-&gt;so_flags &amp;= ~SOF_NOTSENT_LOWAT;
					error = mptcp_set_notsent_lowat(mpte,0);
				} <span class="enscript-keyword">else</span> {
					mp_so-&gt;so_flags |= SOF_NOTSENT_LOWAT;
					error = mptcp_set_notsent_lowat(mpte,
					    optval);
				}
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* not eligible */</span>
			error = ENOPROTOOPT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
	    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (rec) {
		<span class="enscript-comment">/* search for an existing one; if not found, allocate */</span>
		<span class="enscript-keyword">if</span> ((mpo = mptcp_sopt_find(mpte, sopt)) == NULL)
			mpo = mptcp_sopt_alloc(M_WAITOK);

		<span class="enscript-keyword">if</span> (mpo == NULL) {
			error = ENOBUFS;
		} <span class="enscript-keyword">else</span> {
			mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
			    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s &quot;</span>
			    <span class="enscript-string">&quot;val %d %s\n&quot;</span>, __func__,
			    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
			    mptcp_sopt2str(level, optname, buf,
			    <span class="enscript-keyword">sizeof</span> (buf)), optval,
			    (mpo-&gt;mpo_flags &amp; MPOF_ATTACHED) ?
			    <span class="enscript-string">&quot;updated&quot;</span> : <span class="enscript-string">&quot;recorded&quot;</span>),
			    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);

			<span class="enscript-comment">/* initialize or update, as needed */</span>
			mpo-&gt;mpo_intval = optval;
			<span class="enscript-keyword">if</span> (!(mpo-&gt;mpo_flags &amp; MPOF_ATTACHED)) {
				mpo-&gt;mpo_level = level;
				mpo-&gt;mpo_name = optname;
				mptcp_sopt_insert(mpte, mpo);
			}
			VERIFY(mpo-&gt;mpo_flags &amp; MPOF_ATTACHED);
			<span class="enscript-comment">/* this can be issued on the subflow socket */</span>
			mpo-&gt;mpo_flags |= MPOF_SUBFLOW_OK;
		}
	} <span class="enscript-keyword">else</span> {
		bzero(&amp;smpo, <span class="enscript-keyword">sizeof</span> (smpo));
		mpo = &amp;smpo;
		mpo-&gt;mpo_flags |= MPOF_SUBFLOW_OK;
		mpo-&gt;mpo_level = level;
		mpo-&gt;mpo_name = optname;
		mpo-&gt;mpo_intval = optval;
	}
	VERIFY(mpo == NULL || error == 0);

	<span class="enscript-comment">/* issue this socket option on existing subflows */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		error = mptcp_setopt_apply(mpte, mpo);
		<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; (mpo-&gt;mpo_flags &amp; MPOF_ATTACHED)) {
			VERIFY(mpo != &amp;smpo);
			mptcp_sopt_remove(mpte, mpo);
			mptcp_sopt_free(mpo);
		}
		<span class="enscript-keyword">if</span> (mpo == &amp;smpo)
			mpo-&gt;mpo_flags &amp;= ~MPOF_INTERIM;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; mpo != NULL) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s val %d set %s\n&quot;</span>,
		    __func__, (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(level, optname, buf,
		    <span class="enscript-keyword">sizeof</span> (buf)), optval, (mpo-&gt;mpo_flags &amp; MPOF_INTERIM) ?
		    <span class="enscript-string">&quot;pending&quot;</span> : <span class="enscript-string">&quot;successful&quot;</span>),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0) {
		mptcplog((LOG_ERR, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s can't be issued &quot;</span>
		    <span class="enscript-string">&quot;error %d\n&quot;</span>, __func__,
		    (u_int64_t)VM_KERNEL_ADDRPERM(mp_so), mptcp_sopt2str(level,
		    optname, buf, <span class="enscript-keyword">sizeof</span> (buf)), error),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_ERR);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SOPT_GET for socket options issued on MP socket.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_getopt</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0, optval;

	VERIFY(sopt-&gt;sopt_dir == SOPT_GET);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-comment">/*
	 * We only handle SOPT_GET for TCP level socket options; we should
	 * not get here for socket level options since they are already
	 * handled at the socket layer.
	 */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_TCP) {
		error = ENOPROTOOPT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
		<span class="enscript-comment">/* eligible; get the default value just in case */</span>
		error = mptcp_default_tcp_optval(mpte, sopt, &amp;optval);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* not eligible */</span>
		error = ENOPROTOOPT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
		<span class="enscript-keyword">if</span> (mpte-&gt;mpte_mppcb-&gt;mpp_socket-&gt;so_flags &amp; SOF_NOTSENT_LOWAT)
			optval = mptcp_get_notsent_lowat(mpte);
		<span class="enscript-keyword">else</span>
			optval = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Search for a previously-issued TCP level socket option and
	 * return the recorded option value.  This assumes that the
	 * value did not get modified by the lower layer after it was
	 * issued at setsockopt(2) time.  If not found, we'll return
	 * the default value obtained ealier.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-type">struct</span> mptopt *mpo;

		<span class="enscript-keyword">if</span> ((mpo = mptcp_sopt_find(mpte, sopt)) != NULL)
			optval = mpo-&gt;mpo_intval;

		error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>));
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return default values for TCP socket options.  Ideally we would query the
 * subflow TCP socket, but that requires creating a subflow socket before
 * connectx(2) time.  To simplify things, just return the default values
 * that we know of.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_default_tcp_optval</span>(<span class="enscript-type">struct</span> mptses *mpte, <span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">int</span> *optval)
{
	<span class="enscript-type">int</span> error = 0;

	VERIFY(sopt-&gt;sopt_level == IPPROTO_TCP);
	VERIFY(sopt-&gt;sopt_dir == SOPT_GET);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-comment">/* try to do what tcp_newtcpcb() does */</span>
	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
		*optval = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
		*optval = mptcp_subflow_keeptime;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
		*optval = tcp_max_persist_timeout;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ENOPROTOOPT;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * MPTCP SOPT_{SET,GET} socket option handler, for options issued on the MP
 * socket, at SOL_SOCKET and IPPROTO_TCP levels.  The former is restricted
 * to those that are allowed by mptcp_usr_socheckopt().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mptcp_ctloutput</span>(<span class="enscript-type">struct</span> socket *mp_so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">struct</span> mppcb *mpp = sotomppcb(mp_so);
	<span class="enscript-type">struct</span> mptses *mpte;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (mpp == NULL || mpp-&gt;mpp_state == MPPCB_STATE_DEAD) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mpte = mptompte(mpp);
	MPTE_LOCK_ASSERT_HELD(mpte);	<span class="enscript-comment">/* same as MP socket lock */</span>

	<span class="enscript-comment">/* we only handle socket and TCP-level socket options for MPTCP */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != SOL_SOCKET &amp;&amp; sopt-&gt;sopt_level != IPPROTO_TCP) {
		<span class="enscript-type">char</span> buf[32];
		mptcplog((LOG_DEBUG, <span class="enscript-string">&quot;MPTCP Socket: &quot;</span>
		    <span class="enscript-string">&quot;%s: mp_so 0x%llx sopt %s level not &quot;</span>
		    <span class="enscript-string">&quot;handled\n&quot;</span>, __func__, (u_int64_t)VM_KERNEL_ADDRPERM(mp_so),
		    mptcp_sopt2str(sopt-&gt;sopt_level,
		    sopt-&gt;sopt_name, buf, <span class="enscript-keyword">sizeof</span> (buf))),
		    MPTCP_SOCKET_DBG, MPTCP_LOGLVL_LOG);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
		error = mptcp_setopt(mpte, sopt);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
		error = mptcp_getopt(mpte, sopt);
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return a string representation of &lt;sopt_level,sopt_name&gt;
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">mptcp_sopt2str</span>(<span class="enscript-type">int</span> level, <span class="enscript-type">int</span> optname, <span class="enscript-type">char</span> *dst, <span class="enscript-type">int</span> size)
{
	<span class="enscript-type">char</span> lbuf[32], obuf[32];
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *l = lbuf, *o = obuf;

	(<span class="enscript-type">void</span>) snprintf(lbuf, <span class="enscript-keyword">sizeof</span> (lbuf), <span class="enscript-string">&quot;0x%x&quot;</span>, level);
	(<span class="enscript-type">void</span>) snprintf(obuf, <span class="enscript-keyword">sizeof</span> (obuf), <span class="enscript-string">&quot;0x%x&quot;</span>, optname);

	<span class="enscript-keyword">switch</span> (level) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOL_SOCKET</span>:
		l = <span class="enscript-string">&quot;SOL_SOCKET&quot;</span>;
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER</span>:
			o = <span class="enscript-string">&quot;SO_LINGER&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER_SEC</span>:
			o = <span class="enscript-string">&quot;SO_LINGER_SEC&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEBUG</span>:
			o = <span class="enscript-string">&quot;SO_DEBUG&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_KEEPALIVE</span>:
			o = <span class="enscript-string">&quot;SO_KEEPALIVE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_USELOOPBACK</span>:
			o = <span class="enscript-string">&quot;SO_USELOOPBACK&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TYPE</span>:
			o = <span class="enscript-string">&quot;SO_TYPE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NREAD</span>:
			o = <span class="enscript-string">&quot;SO_NREAD&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NWRITE</span>:
			o = <span class="enscript-string">&quot;SO_NWRITE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ERROR</span>:
			o = <span class="enscript-string">&quot;SO_ERROR&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDBUF</span>:
			o = <span class="enscript-string">&quot;SO_SNDBUF&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVBUF</span>:
			o = <span class="enscript-string">&quot;SO_RCVBUF&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDLOWAT</span>:
			o = <span class="enscript-string">&quot;SO_SNDLOWAT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVLOWAT</span>:
			o = <span class="enscript-string">&quot;SO_RCVLOWAT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDTIMEO</span>:
			o = <span class="enscript-string">&quot;SO_SNDTIMEO&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVTIMEO</span>:
			o = <span class="enscript-string">&quot;SO_RCVTIMEO&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NKE</span>:
			o = <span class="enscript-string">&quot;SO_NKE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOSIGPIPE</span>:
			o = <span class="enscript-string">&quot;SO_NOSIGPIPE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOADDRERR</span>:
			o = <span class="enscript-string">&quot;SO_NOADDRERR&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RESTRICTIONS</span>:
			o = <span class="enscript-string">&quot;SO_RESTRICTIONS&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LABEL</span>:
			o = <span class="enscript-string">&quot;SO_LABEL&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PEERLABEL</span>:
			o = <span class="enscript-string">&quot;SO_PEERLABEL&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RANDOMPORT</span>:
			o = <span class="enscript-string">&quot;SO_RANDOMPORT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS</span>:
			o = <span class="enscript-string">&quot;SO_TRAFFIC_CLASS&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_TRAFFIC_CLASS</span>:
			o = <span class="enscript-string">&quot;SO_RECV_TRAFFIC_CLASS&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS_DBG</span>:
			o = <span class="enscript-string">&quot;SO_TRAFFIC_CLASS_DBG&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PRIVILEGED_TRAFFIC_CLASS</span>:
			o = <span class="enscript-string">&quot;SO_PRIVILEGED_TRAFFIC_CLASS&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEFUNCTOK</span>:
			o = <span class="enscript-string">&quot;SO_DEFUNCTOK&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ISDEFUNCT</span>:
			o = <span class="enscript-string">&quot;SO_ISDEFUNCT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_OPPORTUNISTIC</span>:
			o = <span class="enscript-string">&quot;SO_OPPORTUNISTIC&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			o = <span class="enscript-string">&quot;SO_FLUSH&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_ANYIF</span>:
			o = <span class="enscript-string">&quot;SO_RECV_ANYIF&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOWAKEFROMSLEEP</span>:
			o = <span class="enscript-string">&quot;SO_NOWAKEFROMSLEEP&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_MPTCP_FASTJOIN</span>:
			o = <span class="enscript-string">&quot;SO_MPTCP_FASTJOIN&quot;</span>;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		l = <span class="enscript-string">&quot;IPPROTO_TCP&quot;</span>;
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
			o = <span class="enscript-string">&quot;TCP_KEEPALIVE&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
			o = <span class="enscript-string">&quot;TCP_KEEPINTVL&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
			o = <span class="enscript-string">&quot;TCP_KEEPCNT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
			o = <span class="enscript-string">&quot;TCP_CONNECTIONTIMEOUT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
			o = <span class="enscript-string">&quot;TCP_RXT_CONNDROPTIME&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
			o = <span class="enscript-string">&quot;PERSIST_TIMEOUT&quot;</span>;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	(<span class="enscript-type">void</span>) snprintf(dst, size, <span class="enscript-string">&quot;&lt;%s,%s&gt;&quot;</span>, l, o);
	<span class="enscript-keyword">return</span> (dst);
}
</pre>
<hr />
</body></html>