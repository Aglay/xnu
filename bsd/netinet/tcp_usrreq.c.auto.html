<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_usrreq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_usrreq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	From: @(#)tcp_usrreq.c	8.2 (Berkeley) 1/3/94
 * $FreeBSD: src/sys/netinet/tcp_usrreq.c,v 1.51.2.9 2001/08/22 00:59:12 silby Exp $
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kasl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/content_filter.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_debug.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>

<span class="enscript-type">void</span>	tcp_fill_info(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> tcp_info *);
errno_t <span class="enscript-function-name">tcp_fill_info_for_info_tuple</span>(<span class="enscript-type">struct</span> info_tuple *, <span class="enscript-type">struct</span> tcp_info *);

<span class="enscript-type">int</span> <span class="enscript-function-name">tcp_sysctl_info</span>(<span class="enscript-type">struct</span> sysctl_oid *, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span> , <span class="enscript-type">struct</span> sysctl_req *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_connection_fill_info</span>(<span class="enscript-type">struct</span> tcpcb *tp,
    <span class="enscript-type">struct</span> tcp_connection_info *tci);

<span class="enscript-comment">/*
 * TCP protocol interface to socket abstraction.
 */</span>
<span class="enscript-type">extern</span>	<span class="enscript-type">char</span> *tcpstates[];	<span class="enscript-comment">/* XXX ??? */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp_attach(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp_connect(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp6_connect(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp6_usr_connect(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *,
		    <span class="enscript-type">struct</span> proc *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcpcb *
		tcp_disconnect(<span class="enscript-type">struct</span> tcpcb *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcpcb *
		tcp_usrclosed(<span class="enscript-type">struct</span> tcpcb *);

<span class="enscript-type">extern</span> uint32_t tcp_autorcvbuf_max;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_trim</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPDEBUG0</span>	int ostate = 0
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCPDEBUG1</span>()	ostate = tp ? tp-&gt;t_state : 0
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCPDEBUG2</span>(req)	if (tp &amp;&amp; (so-&gt;so_options &amp; SO_DEBUG)) \
				tcp_trace(TA_USER, ostate, tp, 0, 0, req)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TCPDEBUG0</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCPDEBUG1</span>()
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">TCPDEBUG2</span>(req)
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, info,
    CTLFLAG_RW | CTLFLAG_LOCKED | CTLFLAG_ANYBODY | CTLFLAG_KERN,
    0 , 0, tcp_sysctl_info, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;TCP info per tuple&quot;</span>);

<span class="enscript-comment">/*
 * TCP attaches to socket via pru_attach(), reserving space,
 * and an internet control block.
 *
 * Returns:	0			Success
 *		EISCONN
 *	tcp_attach:ENOBUFS
 *	tcp_attach:ENOMEM
 *	tcp_attach:???			[IPSEC specific]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_attach</span>(<span class="enscript-type">struct</span> socket *so, __unused <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = 0;
	TCPDEBUG0;

	TCPDEBUG1();
	<span class="enscript-keyword">if</span> (inp) {
		error = EISCONN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	error = tcp_attach(so, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_LINGER) &amp;&amp; so-&gt;so_linger == 0)
		so-&gt;so_linger = TCP_LINGERTIME * hz;
	tp = sototcpcb(so);
<span class="enscript-reference">out</span>:
	TCPDEBUG2(PRU_ATTACH);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * pru_detach() detaches the TCP protocol from the socket.
 * If the protocol state is non-embryonic, then can't
 * do this directly: have to initiate a pru_disconnect(),
 * which may finish later; embryonic TCB's can just
 * be discarded here.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	TCPDEBUG0;

	<span class="enscript-keyword">if</span> (inp == 0 || (inp-&gt;inp_state == INPCB_STATE_DEAD)) {
		<span class="enscript-keyword">return</span> EINVAL;	<span class="enscript-comment">/* XXX */</span>
	}
	lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);
	tp = intotcpcb(inp);
	<span class="enscript-comment">/* In case we got disconnected from the peer */</span>
        <span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	TCPDEBUG1();

	calculate_tcp_clock();

	tp = tcp_disconnect(tp);
<span class="enscript-reference">out</span>:
	TCPDEBUG2(PRU_DETACH);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">COMMON_START</span>()	TCPDEBUG0;					\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)		\
		<span class="enscript-keyword">return</span> (EINVAL);					\
	<span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp))			\
		<span class="enscript-keyword">return</span> (EPROTOTYPE);					\
	tp = intotcpcb(inp);						\
	TCPDEBUG1();							\
	calculate_tcp_clock();						\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">COMMON_START</span>()	TCPDEBUG0;					\
<span class="enscript-keyword">do</span> {									\
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)		\
		<span class="enscript-keyword">return</span> (EINVAL);					\
	tp = intotcpcb(inp);						\
	TCPDEBUG1();							\
	calculate_tcp_clock();						\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !NECP */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">COMMON_END</span>(req)	out: TCPDEBUG2(req); return error; goto out


<span class="enscript-comment">/*
 * Give the socket an address.
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument [COMMON_START]
 *		EAFNOSUPPORT		Address family not supported
 *	in_pcbbind:EADDRNOTAVAIL	Address not available.
 *	in_pcbbind:EINVAL		Invalid argument
 *	in_pcbbind:EAFNOSUPPORT		Address family not supported [notdef]
 *	in_pcbbind:EACCES		Permission denied
 *	in_pcbbind:EADDRINUSE		Address in use
 *	in_pcbbind:EAGAIN		Resource unavailable, try again
 *	in_pcbbind:EPERM		Operation not permitted
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr_in *sinp;

	COMMON_START();

	<span class="enscript-keyword">if</span> (nam-&gt;sa_family != 0 &amp;&amp; nam-&gt;sa_family != AF_INET) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Must check for multicast addresses and disallow binding
	 * to them.
	 */</span>
	sinp = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-keyword">if</span> (sinp-&gt;sin_family == AF_INET &amp;&amp;
	    IN_MULTICAST(ntohl(sinp-&gt;sin_addr.s_addr))) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = in_pcbbind(inp, nam, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	COMMON_END(PRU_BIND);

}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_usr_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6p;

	COMMON_START();

	<span class="enscript-keyword">if</span> (nam-&gt;sa_family != 0 &amp;&amp; nam-&gt;sa_family != AF_INET6) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Must check for multicast addresses and disallow binding
	 * to them.
	 */</span>
	sin6p = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-keyword">if</span> (sin6p-&gt;sin6_family == AF_INET6 &amp;&amp;
	    IN6_IS_ADDR_MULTICAST(&amp;sin6p-&gt;sin6_addr)) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	inp-&gt;inp_vflag &amp;= ~INP_IPV4;
	inp-&gt;inp_vflag |= INP_IPV6;
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0) {
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;sin6p-&gt;sin6_addr))
			inp-&gt;inp_vflag |= INP_IPV4;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;sin6p-&gt;sin6_addr)) {
			<span class="enscript-type">struct</span> sockaddr_in sin;

			in6_sin6_2_sin(&amp;sin, sin6p);
			inp-&gt;inp_vflag |= INP_IPV4;
			inp-&gt;inp_vflag &amp;= ~INP_IPV6;
			error = in_pcbbind(inp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin, p);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	error = in6_pcbbind(inp, nam, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	COMMON_END(PRU_BIND);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Prepare to accept connections.
 *
 * Returns:	0			Success
 *		EINVAL [COMMON_START]
 *	in_pcbbind:EADDRNOTAVAIL	Address not available.
 *	in_pcbbind:EINVAL		Invalid argument
 *	in_pcbbind:EAFNOSUPPORT		Address family not supported [notdef]
 *	in_pcbbind:EACCES		Permission denied
 *	in_pcbbind:EADDRINUSE		Address in use
 *	in_pcbbind:EAGAIN		Resource unavailable, try again
 *	in_pcbbind:EPERM		Operation not permitted
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_listen</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	COMMON_START();
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0)
		error = in_pcbbind(inp, NULL, p);
	<span class="enscript-keyword">if</span> (error == 0)
		tp-&gt;t_state = TCPS_LISTEN;
	COMMON_END(PRU_LISTEN);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_usr_listen</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	COMMON_START();
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0) {
		inp-&gt;inp_vflag &amp;= ~INP_IPV4;
		<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0)
			inp-&gt;inp_vflag |= INP_IPV4;
		error = in6_pcbbind(inp, NULL, p);
	}
	<span class="enscript-keyword">if</span> (error == 0)
		tp-&gt;t_state = TCPS_LISTEN;
	COMMON_END(PRU_LISTEN);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_connect_complete</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> tcpcb *tp = sototcpcb(so);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* TFO delays the tcp_output until later, when the app calls write() */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA) {
		<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv(sotoinpcb(so), NULL, NULL))
			<span class="enscript-keyword">return</span> (EHOSTUNREACH);

		<span class="enscript-comment">/* Initialize enough state so that we can actually send data */</span>
		tcp_mss(tp, -1, IFSCOPE_NONE);
		tp-&gt;snd_wnd = tp-&gt;t_maxseg;
	} <span class="enscript-keyword">else</span> {
		error = tcp_output(tp);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Initiate connection to peer.
 * Create a template for use in transmissions on this connection.
 * Enter SYN_SENT state, and mark socket as connecting.
 * Start keep-alive timer, and seed output sequence space.
 * Send initial segment on connection.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr_in *sinp;

	TCPDEBUG0;
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD) {
		<span class="enscript-keyword">if</span> (so-&gt;so_error) {
			error = so-&gt;so_error;
			so-&gt;so_error = 0;
			<span class="enscript-keyword">return</span> error;
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp)) {
		uint32_t fd_ctl_unit = necp_socket_get_flow_divert_control_unit(inp);
		<span class="enscript-keyword">if</span> (fd_ctl_unit &gt; 0) {
			error = flow_divert_pcb_init(so, fd_ctl_unit);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = flow_divert_connect_out(so, nam, p);
			}
		} <span class="enscript-keyword">else</span> {
			error = ENETDOWN;
		}

		<span class="enscript-comment">/* Disable PRECONNECT_DATA, as we don't need to send a SYN anymore. */</span>
		so-&gt;so_flags1 &amp;= ~SOF1_PRECONNECT_DATA;
		<span class="enscript-keyword">return</span> error;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	error = cfil_sock_attach(so);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	tp = intotcpcb(inp);
	TCPDEBUG1();

	calculate_tcp_clock();

	<span class="enscript-keyword">if</span> (nam-&gt;sa_family != 0 &amp;&amp; nam-&gt;sa_family != AF_INET) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Must disallow TCP ``connections'' to multicast addresses.
	 */</span>
	sinp = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-keyword">if</span> (sinp-&gt;sin_family == AF_INET
	    &amp;&amp; IN_MULTICAST(ntohl(sinp-&gt;sin_addr.s_addr))) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((error = tcp_connect(tp, nam, p)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = tcp_connect_complete(so);

	COMMON_END(PRU_CONNECT);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_connectx_common</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> af,
    <span class="enscript-type">struct</span> sockaddr_list **src_sl, <span class="enscript-type">struct</span> sockaddr_list **dst_sl,
    <span class="enscript-type">struct</span> proc *p, uint32_t ifscope, sae_associd_t aid, sae_connid_t *pcid,
    uint32_t flags, <span class="enscript-type">void</span> *arg, uint32_t arglen, <span class="enscript-type">struct</span> uio *auio,
    user_ssize_t *bytes_written)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">aid</span>)
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">MPTCP</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">arglen</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !MPTCP */</span>
	<span class="enscript-type">struct</span> sockaddr_entry *src_se = NULL, *dst_se = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span> error;
	user_ssize_t datalen = 0;

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	VERIFY(dst_sl != NULL);

	<span class="enscript-comment">/* select source (if specified) and destination addresses */</span>
	error = in_selectaddrs(af, src_sl, &amp;src_se, dst_sl, &amp;dst_se);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	VERIFY(*dst_sl != NULL &amp;&amp; dst_se != NULL);
	VERIFY(src_se == NULL || *src_sl != NULL);
	VERIFY(dst_se-&gt;se_addr-&gt;sa_family == af);
	VERIFY(src_se == NULL || src_se-&gt;se_addr-&gt;sa_family == af);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	inp_update_necp_policy(inp, src_se ? src_se-&gt;se_addr : NULL, dst_se ? dst_se-&gt;se_addr : NULL, ifscope);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_DATA_IDEMPOTENT) &amp;&amp;
	    (tcp_fastopen &amp; TCP_FASTOPEN_CLIENT))
		sototcpcb(so)-&gt;t_flagsext |= TF_FASTOPEN;

	<span class="enscript-comment">/*
	 * We get here for 2 cases:
	 *
	 *   a. From MPTCP, to connect a subflow.  There is no need to
	 *	bind the socket to the source address and/or interface,
	 *	since everything has been taken care of by MPTCP.  We
	 *	simply check whether or not this is for the initial
	 *	MPTCP connection attempt, or to join an existing one.
	 *
	 *   b.	From the socket layer, to connect a TCP.  Perform the
	 *	bind to source address and/or interface as necessary.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-keyword">if</span> (flags &amp; CONNREQF_MPTCP) {
		<span class="enscript-type">struct</span> mptsub_connreq *mpcr = arg;

		<span class="enscript-comment">/* Check to make sure this came down from MPTCP */</span>
		<span class="enscript-keyword">if</span> (arg == NULL || arglen != <span class="enscript-keyword">sizeof</span> (*mpcr))
			<span class="enscript-keyword">return</span> (EOPNOTSUPP);

		<span class="enscript-keyword">switch</span> (mpcr-&gt;mpcr_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTSUB_CONNREQ_MP_ENABLE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MPTSUB_CONNREQ_MP_ADD</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EOPNOTSUPP);
		}
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
	{
		<span class="enscript-comment">/* bind socket to the specified interface, if requested */</span>
		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp;
		    (error = inp_bindif(inp, ifscope, NULL)) != 0)
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-comment">/* if source address and/or port is specified, bind to it */</span>
		<span class="enscript-keyword">if</span> (src_se != NULL) {
			<span class="enscript-type">struct</span> sockaddr *sa = src_se-&gt;se_addr;
			error = sobindlock(so, sa, 0);	<span class="enscript-comment">/* already locked */</span>
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">switch</span> (af) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		error = tcp_usr_connect(so, dst_se-&gt;se_addr, p);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		error = tcp6_usr_connect(so, dst_se-&gt;se_addr, p);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* if there is data, copy it */</span>
	<span class="enscript-keyword">if</span> (auio != NULL) {
		socket_unlock(so, 0);

		VERIFY(bytes_written != NULL);

		datalen = uio_resid(auio);
		error = so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sosend(so, NULL,
	            (uio_t)auio, NULL, NULL, 0);
		socket_lock(so, 0);

		<span class="enscript-keyword">if</span> (error == 0 || error == EWOULDBLOCK)
			*bytes_written = datalen - uio_resid(auio);

		<span class="enscript-comment">/*
		 * sosend returns EWOULDBLOCK if it's a non-blocking
		 * socket or a timeout occured (this allows to return
		 * the amount of queued data through sendit()).
		 *
		 * However, connectx() returns EINPROGRESS in case of a
		 * blocking socket. So we change the return value here.
		 */</span>
		<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
			error = EINPROGRESS;
	}

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; pcid != NULL)
		*pcid = 1; <span class="enscript-comment">/* there is only one connection in regular TCP */</span>

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_connectx</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
	<span class="enscript-keyword">return</span> (tcp_usr_connectx_common(so, AF_INET, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen, uio,
	    bytes_written));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_usr_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6p;

	TCPDEBUG0;
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_state == INPCB_STATE_DEAD) {
		<span class="enscript-keyword">if</span> (so-&gt;so_error) {
			error = so-&gt;so_error;
			so-&gt;so_error = 0;
			<span class="enscript-keyword">return</span> error;
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp)) {
		uint32_t fd_ctl_unit = necp_socket_get_flow_divert_control_unit(inp);
		<span class="enscript-keyword">if</span> (fd_ctl_unit &gt; 0) {
			error = flow_divert_pcb_init(so, fd_ctl_unit);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = flow_divert_connect_out(so, nam, p);
			}
		} <span class="enscript-keyword">else</span> {
			error = ENETDOWN;
		}
		<span class="enscript-keyword">return</span> error;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	error = cfil_sock_attach(so);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	tp = intotcpcb(inp);
	TCPDEBUG1();

	calculate_tcp_clock();

	<span class="enscript-keyword">if</span> (nam-&gt;sa_family != 0 &amp;&amp; nam-&gt;sa_family != AF_INET6) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Must disallow TCP ``connections'' to multicast addresses.
	 */</span>
	sin6p = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-keyword">if</span> (sin6p-&gt;sin6_family == AF_INET6
	    &amp;&amp; IN6_IS_ADDR_MULTICAST(&amp;sin6p-&gt;sin6_addr)) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;sin6p-&gt;sin6_addr)) {
		<span class="enscript-type">struct</span> sockaddr_in sin;

		<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) != 0)
			<span class="enscript-keyword">return</span> (EINVAL);

		in6_sin6_2_sin(&amp;sin, sin6p);
		inp-&gt;inp_vflag |= INP_IPV4;
		inp-&gt;inp_vflag &amp;= ~INP_IPV6;
		<span class="enscript-keyword">if</span> ((error = tcp_connect(tp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin, p)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		error = tcp_connect_complete(so);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	inp-&gt;inp_vflag &amp;= ~INP_IPV4;
	inp-&gt;inp_vflag |= INP_IPV6;
	<span class="enscript-keyword">if</span> ((error = tcp6_connect(tp, nam, p)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = tcp_connect_complete(so);
	COMMON_END(PRU_CONNECT);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_usr_connectx</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
	<span class="enscript-keyword">return</span> (tcp_usr_connectx_common(so, AF_INET6, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen, uio,
	    bytes_written));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Initiate disconnect from peer.
 * If connection never passed embryonic stage, just drop;
 * else if don't need to let data drain, then can just drop anyways,
 * else have to begin TCP shutdown process: mark socket disconnecting,
 * drain unread data, state switch to reflect user close, and
 * send segment (e.g. FIN) to peer.  Socket will be really disconnected
 * when peer sends FIN and acks ours.
 *
 * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
	    LCK_MTX_ASSERT_OWNED);
	COMMON_START();
        <span class="enscript-comment">/* In case we got disconnected from the peer */</span>
        <span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	tp = tcp_disconnect(tp);
	COMMON_END(PRU_DISCONNECT);
}

<span class="enscript-comment">/*
 * User-protocol pru_disconnectx callback.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_disconnectx</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, sae_connid_t cid)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cid</span>)
	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (tcp_usr_disconnect(so));
}

<span class="enscript-comment">/*
 * Accept a connection.  Essentially all the work is
 * done at higher levels; just return the address
 * of the peer, storing through addr.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_accept</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	TCPDEBUG0;

	in_getpeeraddr(so, nam);

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISDISCONNECTED) {
		error = ECONNABORTED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (EINVAL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp))
		<span class="enscript-keyword">return</span> (EPROTOTYPE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	error = cfil_sock_attach(so);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	tp = intotcpcb(inp);
	TCPDEBUG1();

	calculate_tcp_clock();

	COMMON_END(PRU_ACCEPT);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_usr_accept</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	TCPDEBUG0;

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISDISCONNECTED) {
		error = ECONNABORTED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (EINVAL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (necp_socket_should_use_flow_divert(inp))
		<span class="enscript-keyword">return</span> (EPROTOTYPE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	error = cfil_sock_attach(so);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	tp = intotcpcb(inp);
	TCPDEBUG1();

	calculate_tcp_clock();

	in6_mapped_peeraddr(so, nam);
	COMMON_END(PRU_ACCEPT);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Mark the connection as being incapable of further output.
 *
 * Returns:	0			Success
 *		EINVAL [COMMON_START]
 *	tcp_output:EADDRNOTAVAIL
 *	tcp_output:ENOBUFS
 *	tcp_output:EMSGSIZE
 *	tcp_output:EHOSTUNREACH
 *	tcp_output:ENETUNREACH
 *	tcp_output:ENETDOWN
 *	tcp_output:ENOMEM
 *	tcp_output:EACCES
 *	tcp_output:EMSGSIZE
 *	tcp_output:ENOBUFS
 *	tcp_output:???			[ignorable: mostly IPSEC/firewall/DLIL]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_shutdown</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	TCPDEBUG0;
	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (EINVAL);

	socantsendmore(so);

        <span class="enscript-comment">/*
	 * In case we got disconnected from the peer, or if this is
	 * a socket that is to be flow-diverted (but not yet).
	 */</span>
	tp = intotcpcb(inp);
	TCPDEBUG1();

	<span class="enscript-keyword">if</span> (tp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		<span class="enscript-keyword">if</span> (tp != NULL)
			error = EPROTOTYPE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	calculate_tcp_clock();

	tp = tcp_usrclosed(tp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* A reset has been sent but socket exists, do not send FIN */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp;
	    (tp) &amp;&amp; (tp-&gt;t_mpflags &amp; TMPF_RESET)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	<span class="enscript-comment">/* Don't send a FIN yet */</span>
	<span class="enscript-keyword">if</span> (tp &amp;&amp; !(so-&gt;so_state &amp; SS_ISDISCONNECTED) &amp;&amp;
		cfil_sock_data_pending(&amp;so-&gt;so_snd))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
	<span class="enscript-keyword">if</span> (tp)
		error = tcp_output(tp);
	COMMON_END(PRU_SHUTDOWN);
}

<span class="enscript-comment">/*
 * After a receive, possibly send window update to peer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_rcvd</span>(<span class="enscript-type">struct</span> socket *so, __unused <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	COMMON_START();
        <span class="enscript-comment">/* In case we got disconnected from the peer */</span>
        <span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	tcp_sbrcv_trim(tp, &amp;so-&gt;so_rcv);

	<span class="enscript-comment">/*
	 * This tcp_output is solely there to trigger window-updates.
	 * However, we really do not want these window-updates while we
	 * are still in SYN_SENT or SYN_RECEIVED.
	 */</span>
	<span class="enscript-keyword">if</span> (TCPS_HAVEESTABLISHED(tp-&gt;t_state))
		tcp_output(tp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	cfil_sock_buf_update(&amp;so-&gt;so_rcv);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>

	COMMON_END(PRU_RCVD);
}

<span class="enscript-comment">/*
 * Do a send by putting data in output queue and updating urgent
 * marker if URG set.  Possibly send more data.  Unlike the other
 * pru_*() routines, the mbuf chains are our responsibility.  We
 * must either enqueue them or free them.  The other pru_* routines
 * generally are caller-frees.
 *
 * Returns:	0			Success
 *		ECONNRESET
 *		EINVAL
 *		ENOBUFS
 *	tcp_connect:EADDRINUSE		Address in use
 *	tcp_connect:EADDRNOTAVAIL	Address not available.
 *	tcp_connect:EINVAL		Invalid argument
 *	tcp_connect:EAFNOSUPPORT	Address family not supported [notdef]
 *	tcp_connect:EACCES		Permission denied
 *	tcp_connect:EAGAIN		Resource unavailable, try again
 *	tcp_connect:EPERM		Operation not permitted
 *	tcp_output:EADDRNOTAVAIL
 *	tcp_output:ENOBUFS
 *	tcp_output:EMSGSIZE
 *	tcp_output:EHOSTUNREACH
 *	tcp_output:ENETUNREACH
 *	tcp_output:ENETDOWN
 *	tcp_output:ENOMEM
 *	tcp_output:EACCES
 *	tcp_output:EMSGSIZE
 *	tcp_output:ENOBUFS
 *	tcp_output:???			[ignorable: mostly IPSEC/firewall/DLIL]
 *	tcp6_connect:???		[IPV6 only]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m,
     <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;
	uint32_t msgpri = MSG_PRI_DEFAULT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6;
#<span class="enscript-reference">endif</span>
	TCPDEBUG0;

	<span class="enscript-keyword">if</span> (inp == NULL || inp-&gt;inp_state == INPCB_STATE_DEAD
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		<span class="enscript-comment">/*
		 * OOPS! we lost a race, the TCP session got reset after
		 * we checked SS_CANTSENDMORE, eg: while doing uiomove or a
		 * network interrupt in the non-splnet() section of sosend().
		 */</span>
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		<span class="enscript-keyword">if</span> (control != NULL) {
			m_freem(control);
			control = NULL;
		}

		<span class="enscript-keyword">if</span> (inp == NULL)
			error = ECONNRESET;	<span class="enscript-comment">/* XXX EPIPE? */</span>
		<span class="enscript-keyword">else</span>
			error = EPROTOTYPE;
		tp = NULL;
		TCPDEBUG1();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	isipv6 = nam &amp;&amp; nam-&gt;sa_family == AF_INET6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	tp = intotcpcb(inp);
	TCPDEBUG1();

	calculate_tcp_clock();

	<span class="enscript-keyword">if</span> (control != NULL) {
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
			<span class="enscript-comment">/* Get the msg priority from control mbufs */</span>
			error = tcp_get_msg_priority(control, &amp;msgpri);
			<span class="enscript-keyword">if</span> (error) {
				m_freem(control);
				<span class="enscript-keyword">if</span> (m != NULL)
					m_freem(m);
				control = NULL;
				m = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			m_freem(control);
			control = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (control-&gt;m_len) {
			<span class="enscript-comment">/* 
			 * if not unordered, TCP should not have 
			 * control mbufs
			 */</span>
			m_freem(control);
			<span class="enscript-keyword">if</span> (m != NULL)
				m_freem(m);
			control = NULL;
			m = NULL;
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
		VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
		m-&gt;m_pkthdr.msg_pri = msgpri;
	}

	<span class="enscript-comment">/* MPTCP sublow socket buffers must not be compressed */</span>
	VERIFY(!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) ||
	    (so-&gt;so_snd.sb_flags &amp; SB_NOCOMPRESS));

	<span class="enscript-keyword">if</span>(!(flags &amp; PRUS_OOB) || (so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA)) {
		<span class="enscript-comment">/* Call msg send if message delivery is enabled */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS)
			sbappendmsg_snd(&amp;so-&gt;so_snd, m);
		<span class="enscript-keyword">else</span>
			sbappendstream(&amp;so-&gt;so_snd, m);

		<span class="enscript-keyword">if</span> (nam &amp;&amp; tp-&gt;t_state &lt; TCPS_SYN_SENT) {

			<span class="enscript-comment">/*
			 * Do implied connect if not yet connected,
			 * initialize window to default value, and
			 * initialize maxseg/maxopd using peer's cached
			 * MSS.
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6)
				error = tcp6_connect(tp, nam, p);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				error = tcp_connect(tp, nam, p);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			tp-&gt;snd_wnd = TTCP_CLIENT_SND_WND;
			tcp_mss(tp, -1, IFSCOPE_NONE);
		}

		<span class="enscript-keyword">if</span> (flags &amp; PRUS_EOF) {
			<span class="enscript-comment">/*
			 * Close the send side of the connection after
			 * the data is sent.
			 */</span>
			socantsendmore(so);
			tp = tcp_usrclosed(tp);
		}
		<span class="enscript-keyword">if</span> (tp != NULL) {
			<span class="enscript-keyword">if</span> (flags &amp; PRUS_MORETOCOME)
				tp-&gt;t_flags |= TF_MORETOCOME;
			error = tcp_output(tp);
			<span class="enscript-keyword">if</span> (flags &amp; PRUS_MORETOCOME)
				tp-&gt;t_flags &amp;= ~TF_MORETOCOME;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (sbspace(&amp;so-&gt;so_snd) == 0) { 
			<span class="enscript-comment">/* if no space is left in sockbuf, 
			 * do not try to squeeze in OOB traffic */</span>
			m_freem(m);
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/*
		 * According to RFC961 (Assigned Protocols),
		 * the urgent pointer points to the last octet
		 * of urgent data.  We continue, however,
		 * to consider it to indicate the first octet
		 * of data past the urgent section.
		 * Otherwise, snd_up should be one lower.
		 */</span>
		sbappendstream(&amp;so-&gt;so_snd, m);
		<span class="enscript-keyword">if</span> (nam &amp;&amp; tp-&gt;t_state &lt; TCPS_SYN_SENT) {
			<span class="enscript-comment">/*
			 * Do implied connect if not yet connected,
			 * initialize window to default value, and
			 * initialize maxseg/maxopd using peer's cached
			 * MSS.
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">if</span> (isipv6)
				error = tcp6_connect(tp, nam, p);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			error = tcp_connect(tp, nam, p);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			tp-&gt;snd_wnd = TTCP_CLIENT_SND_WND;
			tcp_mss(tp, -1, IFSCOPE_NONE);
		}
		tp-&gt;snd_up = tp-&gt;snd_una + so-&gt;so_snd.sb_cc;
		tp-&gt;t_flagsext |= TF_FORCE;
		error = tcp_output(tp);
		tp-&gt;t_flagsext &amp;= ~TF_FORCE;
	}


	<span class="enscript-comment">/*
	 * We wait for the socket to successfully connect before returning.
	 * This allows us to signal a timeout to the application.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTING) {
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_NBIO)
			error = EWOULDBLOCK;
		<span class="enscript-keyword">else</span>
			error = sbwait(&amp;so-&gt;so_snd);
	}

	COMMON_END((flags &amp; PRUS_OOB) ? PRU_SENDOOB : 
		   ((flags &amp; PRUS_EOF) ? PRU_SEND_EOF : PRU_SEND));
}

<span class="enscript-comment">/*
 * Abort the TCP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_abort</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	COMMON_START();
        <span class="enscript-comment">/* In case we got disconnected from the peer */</span>
        <span class="enscript-keyword">if</span> (tp == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	tp = tcp_drop(tp, ECONNABORTED);
	so-&gt;so_usecount--;
	COMMON_END(PRU_ABORT);
}

<span class="enscript-comment">/*
 * Receive out-of-band data.
 *
 * Returns:	0			Success
 *		EINVAL [COMMON_START]
 *		EINVAL
 *		EWOULDBLOCK
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_rcvoob</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp;

	COMMON_START();
	<span class="enscript-keyword">if</span> ((so-&gt;so_oobmark == 0 &amp;&amp;
	     (so-&gt;so_state &amp; SS_RCVATMARK) == 0) ||
	    so-&gt;so_options &amp; SO_OOBINLINE ||
	    tp-&gt;t_oobflags &amp; TCPOOB_HADDATA) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((tp-&gt;t_oobflags &amp; TCPOOB_HAVEDATA) == 0) {
		error = EWOULDBLOCK;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	m-&gt;m_len = 1;
	*mtod(m, caddr_t) = tp-&gt;t_iobc;
	<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0)
		tp-&gt;t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
	COMMON_END(PRU_RCVOOB);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_usr_preconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = tcp_output(sototcpcb(so));

	<span class="enscript-comment">/* One read has been done. This was enough. Get back to &quot;normal&quot; behavior. */</span>
	so-&gt;so_flags1 &amp;= ~SOF1_PRECONNECT_DATA;

	COMMON_END(PRU_PRECONNECT);
}

<span class="enscript-comment">/* xxx - should be const */</span>
<span class="enscript-type">struct</span> pr_usrreqs tcp_usrreqs = {
	.pru_abort =		tcp_usr_abort,
	.pru_accept =		tcp_usr_accept,
	.pru_attach =		tcp_usr_attach,
	.pru_bind =		tcp_usr_bind,
	.pru_connect =		tcp_usr_connect,
	.pru_connectx =		tcp_usr_connectx,
	.pru_control =		in_control,
	.pru_detach =		tcp_usr_detach,
	.pru_disconnect =	tcp_usr_disconnect,
	.pru_disconnectx =	tcp_usr_disconnectx,
	.pru_listen =		tcp_usr_listen,
	.pru_peeraddr =		in_getpeeraddr,
	.pru_rcvd =		tcp_usr_rcvd,
	.pru_rcvoob =		tcp_usr_rcvoob,
	.pru_send =		tcp_usr_send,
	.pru_shutdown =		tcp_usr_shutdown,
	.pru_sockaddr =		in_getsockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
	.pru_preconnect =	tcp_usr_preconnect,
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> pr_usrreqs tcp6_usrreqs = {
	.pru_abort =		tcp_usr_abort,
	.pru_accept =		tcp6_usr_accept,
	.pru_attach =		tcp_usr_attach,
	.pru_bind =		tcp6_usr_bind,
	.pru_connect =		tcp6_usr_connect,
	.pru_connectx =		tcp6_usr_connectx,
	.pru_control =		in6_control,
	.pru_detach =		tcp_usr_detach,
	.pru_disconnect =	tcp_usr_disconnect,
	.pru_disconnectx =	tcp_usr_disconnectx,
	.pru_listen =		tcp6_usr_listen,
	.pru_peeraddr =		in6_mapped_peeraddr,
	.pru_rcvd =		tcp_usr_rcvd,
	.pru_rcvoob =		tcp_usr_rcvoob,
	.pru_send =		tcp_usr_send,
	.pru_shutdown =		tcp_usr_shutdown,
	.pru_sockaddr =		in6_mapped_sockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
	.pru_preconnect =	tcp_usr_preconnect,
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Common subroutine to open a TCP connection to remote host specified
 * by struct sockaddr_in in mbuf *nam.  Call in_pcbbind to assign a local
 * port number if needed.  Call in_pcbladdr to do the routing and to choose
 * a local host address (interface).  If there is an existing incarnation
 * of the same connection in TIME-WAIT state and if the remote host was
 * sending CC options and if the connection duration was &lt; MSL, then
 * truncate the previous TIME-WAIT state and proceed.
 * Initialize connection parameters and enter SYN-SENT state.
 *
 * Returns:	0			Success
 *		EADDRINUSE
 *		EINVAL
 *	in_pcbbind:EADDRNOTAVAIL	Address not available.
 *	in_pcbbind:EINVAL		Invalid argument
 *	in_pcbbind:EAFNOSUPPORT		Address family not supported [notdef]
 *	in_pcbbind:EACCES		Permission denied
 *	in_pcbbind:EADDRINUSE		Address in use
 *	in_pcbbind:EAGAIN		Resource unavailable, try again
 *	in_pcbbind:EPERM		Operation not permitted
 *	in_pcbladdr:EINVAL		Invalid argument
 *	in_pcbladdr:EAFNOSUPPORT	Address family not supported
 *	in_pcbladdr:EADDRNOTAVAIL	Address not available
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_connect</span>(tp, nam, p)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr *nam;
	<span class="enscript-type">struct</span> proc *p;
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb, *oinp;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">struct</span> tcpcb *otp;
	<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-type">struct</span> in_addr laddr;
	<span class="enscript-type">struct</span> rmxp_tao *taop;
	<span class="enscript-type">struct</span> rmxp_tao tao_noncached;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0) {
		error = in_pcbbind(inp, NULL, p);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Cannot simply call in_pcbconnect, because there might be an
	 * earlier incarnation of this same connection still in
	 * TIME_WAIT state, creating an ADDRINUSE error.
	 */</span>
	error = in_pcbladdr(inp, nam, &amp;laddr, IFSCOPE_NONE, &amp;outif);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	tcp_unlock(inp-&gt;inp_socket, 0, 0);
	oinp = in_pcblookup_hash(inp-&gt;inp_pcbinfo,
	    sin-&gt;sin_addr, sin-&gt;sin_port,
	    inp-&gt;inp_laddr.s_addr != INADDR_ANY ? inp-&gt;inp_laddr : laddr,
	    inp-&gt;inp_lport,  0, NULL);

	tcp_lock(inp-&gt;inp_socket, 0, 0);
	<span class="enscript-keyword">if</span> (oinp) {
		<span class="enscript-keyword">if</span> (oinp != inp) <span class="enscript-comment">/* 4143933: avoid deadlock if inp == oinp */</span>
			tcp_lock(oinp-&gt;inp_socket, 1, 0);
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(oinp, WNT_RELEASE, 1) == WNT_STOPUSING) {
			<span class="enscript-keyword">if</span> (oinp != inp)
				tcp_unlock(oinp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_oinp</span>;
		}

		<span class="enscript-keyword">if</span> (oinp != inp &amp;&amp; (otp = intotcpcb(oinp)) != NULL &amp;&amp;
		    otp-&gt;t_state == TCPS_TIME_WAIT &amp;&amp;
		    ((<span class="enscript-type">int</span>)(tcp_now - otp-&gt;t_starttime)) &lt; tcp_msl &amp;&amp;
		    (otp-&gt;t_flags &amp; TF_RCVD_CC)) {
			otp = tcp_close(otp);
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;tcp_connect: inp=0x%llx err=EADDRINUSE\n&quot;</span>,
			    (uint64_t)VM_KERNEL_ADDRPERM(inp));
			<span class="enscript-keyword">if</span> (oinp != inp)
				tcp_unlock(oinp-&gt;inp_socket, 1, 0);
			error = EADDRINUSE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (oinp != inp)
			tcp_unlock(oinp-&gt;inp_socket, 1, 0);
	}
<span class="enscript-reference">skip_oinp</span>:
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_laddr.s_addr == INADDR_ANY ? laddr.s_addr :
	    inp-&gt;inp_laddr.s_addr) == sin-&gt;sin_addr.s_addr &amp;&amp;
	    inp-&gt;inp_lport == sin-&gt;sin_port) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
		<span class="enscript-comment">/*lock inversion issue, mostly with udp multicast packets */</span>
		socket_unlock(inp-&gt;inp_socket, 0);
		lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
		socket_lock(inp-&gt;inp_socket, 0);
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_laddr.s_addr == INADDR_ANY) {
		inp-&gt;inp_laddr = laddr;
		<span class="enscript-comment">/* no reference needed */</span>
		inp-&gt;inp_last_outifp = outif;
		inp-&gt;inp_flags |= INP_INADDR_ANY;
	}
	inp-&gt;inp_faddr = sin-&gt;sin_addr;
	inp-&gt;inp_fport = sin-&gt;sin_port;
	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
		inp-&gt;inp_flowhash = inp_calc_flowhash(inp);

	tcp_set_max_rwinscale(tp, so);

	soisconnecting(so);
	tcpstat.tcps_connattempt++;
	tp-&gt;t_state = TCPS_SYN_SENT;
	tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, TCP_CONN_KEEPINIT(tp));
	tp-&gt;iss = tcp_new_isn(tp);
	tcp_sendseqinit(tp);
	<span class="enscript-keyword">if</span> (nstat_collect)
		nstat_route_connect_attempt(inp-&gt;inp_route.ro_rt);

	<span class="enscript-comment">/*
	 * Generate a CC value for this connection and
	 * check whether CC or CCnew should be used.
	 */</span>
	<span class="enscript-keyword">if</span> ((taop = tcp_gettaocache(tp-&gt;t_inpcb)) == NULL) {
		taop = &amp;tao_noncached;
		bzero(taop, <span class="enscript-keyword">sizeof</span>(*taop));
	}

	tp-&gt;cc_send = CC_INC(tcp_ccgen);
	<span class="enscript-keyword">if</span> (taop-&gt;tao_ccsent != 0 &amp;&amp;
	    CC_GEQ(tp-&gt;cc_send, taop-&gt;tao_ccsent)) {
		taop-&gt;tao_ccsent = tp-&gt;cc_send;
	} <span class="enscript-keyword">else</span> {
		taop-&gt;tao_ccsent = 0;
		tp-&gt;t_flags |= TF_SENDCCNEW;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (outif != NULL)
		ifnet_release(outif);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6_connect</span>(tp, nam, p)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> sockaddr *nam;
	<span class="enscript-type">struct</span> proc *p;
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb, *oinp;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">struct</span> tcpcb *otp;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-type">struct</span> in6_addr addr6;
	<span class="enscript-type">struct</span> rmxp_tao *taop;
	<span class="enscript-type">struct</span> rmxp_tao tao_noncached;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0) {
		error = in6_pcbbind(inp, NULL, p);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Cannot simply call in_pcbconnect, because there might be an
	 * earlier incarnation of this same connection still in
	 * TIME_WAIT state, creating an ADDRINUSE error.
	 *
	 * in6_pcbladdr() might return an ifp with its reference held
	 * even in the error case, so make sure that it's released
	 * whenever it's non-NULL.
	 */</span>
	error = in6_pcbladdr(inp, nam, &amp;addr6, &amp;outif);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	tcp_unlock(inp-&gt;inp_socket, 0, 0);
	oinp = in6_pcblookup_hash(inp-&gt;inp_pcbinfo,
				  &amp;sin6-&gt;sin6_addr, sin6-&gt;sin6_port,
				  IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)
				  ? &amp;addr6
				  : &amp;inp-&gt;in6p_laddr,
				  inp-&gt;inp_lport,  0, NULL);
	tcp_lock(inp-&gt;inp_socket, 0, 0);
	<span class="enscript-keyword">if</span> (oinp) {
		<span class="enscript-keyword">if</span> (oinp != inp &amp;&amp; (otp = intotcpcb(oinp)) != NULL &amp;&amp;
		    otp-&gt;t_state == TCPS_TIME_WAIT &amp;&amp;
		    ((<span class="enscript-type">int</span>)(tcp_now - otp-&gt;t_starttime)) &lt; tcp_msl &amp;&amp;
		    (otp-&gt;t_flags &amp; TF_RCVD_CC)) {
			otp = tcp_close(otp);
		} <span class="enscript-keyword">else</span> {
			error = EADDRINUSE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
		<span class="enscript-comment">/*lock inversion issue, mostly with udp multicast packets */</span>
		socket_unlock(inp-&gt;inp_socket, 0);
		lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
		socket_lock(inp-&gt;inp_socket, 0);
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
		inp-&gt;in6p_laddr = addr6;
		inp-&gt;in6p_last_outifp = outif;	<span class="enscript-comment">/* no reference needed */</span>
		inp-&gt;in6p_flags |= INP_IN6ADDR_ANY;
	}
	inp-&gt;in6p_faddr = sin6-&gt;sin6_addr;
	inp-&gt;inp_fport = sin6-&gt;sin6_port;
	<span class="enscript-keyword">if</span> ((sin6-&gt;sin6_flowinfo &amp; IPV6_FLOWINFO_MASK) != 0)
		inp-&gt;inp_flow = sin6-&gt;sin6_flowinfo;
	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
		inp-&gt;inp_flowhash = inp_calc_flowhash(inp);
	<span class="enscript-comment">/* update flowinfo - RFC 6437 */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flow == 0 &amp;&amp; inp-&gt;in6p_flags &amp; IN6P_AUTOFLOWLABEL) {
		inp-&gt;inp_flow &amp;= ~IPV6_FLOWLABEL_MASK;
		inp-&gt;inp_flow |=
		    (htonl(inp-&gt;inp_flowhash) &amp; IPV6_FLOWLABEL_MASK);
	}

	tcp_set_max_rwinscale(tp, so);

	soisconnecting(so);
	tcpstat.tcps_connattempt++;
	tp-&gt;t_state = TCPS_SYN_SENT;
	tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, 
		TCP_CONN_KEEPINIT(tp));
	tp-&gt;iss = tcp_new_isn(tp);
	tcp_sendseqinit(tp);
	<span class="enscript-keyword">if</span> (nstat_collect)
		nstat_route_connect_attempt(inp-&gt;inp_route.ro_rt);

	<span class="enscript-comment">/*
	 * Generate a CC value for this connection and
	 * check whether CC or CCnew should be used.
	 */</span>
	<span class="enscript-keyword">if</span> ((taop = tcp_gettaocache(tp-&gt;t_inpcb)) == NULL) {
		taop = &amp;tao_noncached;
		bzero(taop, <span class="enscript-keyword">sizeof</span>(*taop));
	}

	tp-&gt;cc_send = CC_INC(tcp_ccgen);
	<span class="enscript-keyword">if</span> (taop-&gt;tao_ccsent != 0 &amp;&amp;
	    CC_GEQ(tp-&gt;cc_send, taop-&gt;tao_ccsent)) {
		taop-&gt;tao_ccsent = tp-&gt;cc_send;
	} <span class="enscript-keyword">else</span> {
		taop-&gt;tao_ccsent = 0;
		tp-&gt;t_flags |= TF_SENDCCNEW;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (outif != NULL)
		ifnet_release(outif);

	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Export TCP internal state information via a struct tcp_info
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_fill_info</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcp_info *ti)
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	
	bzero(ti, <span class="enscript-keyword">sizeof</span>(*ti));

	ti-&gt;tcpi_state = tp-&gt;t_state;
	
	<span class="enscript-keyword">if</span> (tp-&gt;t_state &gt; TCPS_LISTEN) {
		<span class="enscript-keyword">if</span> (TSTMP_SUPPORTED(tp))
			ti-&gt;tcpi_options |= TCPI_OPT_TIMESTAMPS;
		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp))
			ti-&gt;tcpi_options |= TCPI_OPT_SACK;
		<span class="enscript-keyword">if</span> (TCP_WINDOW_SCALE_ENABLED(tp)) {
			ti-&gt;tcpi_options |= TCPI_OPT_WSCALE;
			ti-&gt;tcpi_snd_wscale = tp-&gt;snd_scale;
			ti-&gt;tcpi_rcv_wscale = tp-&gt;rcv_scale;
		}

		<span class="enscript-comment">/* Are we in retranmission episode */</span>
		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp) || tp-&gt;t_rxtshift &gt; 0)
			ti-&gt;tcpi_flags |= TCPI_FLAG_LOSSRECOVERY;

		ti-&gt;tcpi_rto = tp-&gt;t_timer[TCPT_REXMT] ? tp-&gt;t_rxtcur : 0;
		ti-&gt;tcpi_snd_mss = tp-&gt;t_maxseg;
		ti-&gt;tcpi_rcv_mss = tp-&gt;t_maxseg;

		ti-&gt;tcpi_rttcur = tp-&gt;t_rttcur;
		ti-&gt;tcpi_srtt = tp-&gt;t_srtt &gt;&gt; TCP_RTT_SHIFT;
		ti-&gt;tcpi_rttvar = tp-&gt;t_rttvar &gt;&gt; TCP_RTTVAR_SHIFT;
		ti-&gt;tcpi_rttbest = tp-&gt;t_rttbest &gt;&gt; TCP_RTT_SHIFT;

		ti-&gt;tcpi_snd_ssthresh = tp-&gt;snd_ssthresh;
		ti-&gt;tcpi_snd_cwnd = tp-&gt;snd_cwnd;
		ti-&gt;tcpi_snd_sbbytes = inp-&gt;inp_socket-&gt;so_snd.sb_cc;
	
		ti-&gt;tcpi_rcv_space = tp-&gt;rcv_wnd;

		ti-&gt;tcpi_snd_wnd = tp-&gt;snd_wnd;
		ti-&gt;tcpi_snd_nxt = tp-&gt;snd_nxt;
		ti-&gt;tcpi_rcv_nxt = tp-&gt;rcv_nxt;

		<span class="enscript-comment">/* convert bytes/msec to bits/sec */</span>
		<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) != 0 &amp;&amp;
			tp-&gt;t_bwmeas != NULL) {
			ti-&gt;tcpi_snd_bw	= (tp-&gt;t_bwmeas-&gt;bw_sndbw * 8000);
		}
		
		ti-&gt;tcpi_last_outif = (tp-&gt;t_inpcb-&gt;inp_last_outifp == NULL) ? 0 :
		    tp-&gt;t_inpcb-&gt;inp_last_outifp-&gt;if_index;

		<span class="enscript-comment">//atomic_get_64(ti-&gt;tcpi_txbytes, &amp;inp-&gt;inp_stat-&gt;txbytes);
</span>		ti-&gt;tcpi_txpackets = inp-&gt;inp_stat-&gt;txpackets;
		ti-&gt;tcpi_txbytes = inp-&gt;inp_stat-&gt;txbytes;
		ti-&gt;tcpi_txretransmitbytes = tp-&gt;t_stat.txretransmitbytes;
		ti-&gt;tcpi_txunacked = tp-&gt;snd_max - tp-&gt;snd_una;
		
		<span class="enscript-comment">//atomic_get_64(ti-&gt;tcpi_rxbytes, &amp;inp-&gt;inp_stat-&gt;rxbytes);
</span>		ti-&gt;tcpi_rxpackets = inp-&gt;inp_stat-&gt;rxpackets;
		ti-&gt;tcpi_rxbytes = inp-&gt;inp_stat-&gt;rxbytes;
		ti-&gt;tcpi_rxduplicatebytes = tp-&gt;t_stat.rxduplicatebytes;
		ti-&gt;tcpi_rxoutoforderbytes = tp-&gt;t_stat.rxoutoforderbytes;

		<span class="enscript-keyword">if</span> (tp-&gt;t_state &gt; TCPS_LISTEN) {
			ti-&gt;tcpi_synrexmits = tp-&gt;t_stat.synrxtshift;
		}
		ti-&gt;tcpi_cell_rxpackets = inp-&gt;inp_cstat-&gt;rxpackets;
		ti-&gt;tcpi_cell_rxbytes = inp-&gt;inp_cstat-&gt;rxbytes;
		ti-&gt;tcpi_cell_txpackets = inp-&gt;inp_cstat-&gt;txpackets;
		ti-&gt;tcpi_cell_txbytes = inp-&gt;inp_cstat-&gt;txbytes;

		ti-&gt;tcpi_wifi_rxpackets = inp-&gt;inp_wstat-&gt;rxpackets;
		ti-&gt;tcpi_wifi_rxbytes = inp-&gt;inp_wstat-&gt;rxbytes;
		ti-&gt;tcpi_wifi_txpackets = inp-&gt;inp_wstat-&gt;txpackets;
		ti-&gt;tcpi_wifi_txbytes = inp-&gt;inp_wstat-&gt;txbytes;

		ti-&gt;tcpi_wired_rxpackets = inp-&gt;inp_Wstat-&gt;rxpackets;
		ti-&gt;tcpi_wired_rxbytes = inp-&gt;inp_Wstat-&gt;rxbytes;
		ti-&gt;tcpi_wired_txpackets = inp-&gt;inp_Wstat-&gt;txpackets;
		ti-&gt;tcpi_wired_txbytes = inp-&gt;inp_Wstat-&gt;txbytes;
		tcp_get_connectivity_status(tp, &amp;ti-&gt;tcpi_connstatus);

		ti-&gt;tcpi_tfo_syn_data_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYNDATA_RCV);
		ti-&gt;tcpi_tfo_cookie_req_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIEREQ_RECV);
		ti-&gt;tcpi_tfo_cookie_sent = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_SENT);
		ti-&gt;tcpi_tfo_cookie_invalid = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_INVALID);

		ti-&gt;tcpi_tfo_cookie_req = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_REQ);
		ti-&gt;tcpi_tfo_cookie_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_RCV);
		ti-&gt;tcpi_tfo_syn_data_sent = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_SENT);
		ti-&gt;tcpi_tfo_syn_data_acked = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_ACKED);
		ti-&gt;tcpi_tfo_syn_loss = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_LOSS);
	}
}

__private_extern__ errno_t
<span class="enscript-function-name">tcp_fill_info_for_info_tuple</span>(<span class="enscript-type">struct</span> info_tuple *itpl, <span class="enscript-type">struct</span> tcp_info *ti)
{
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = NULL;
	<span class="enscript-type">struct</span> inpcb *inp = NULL;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> tcpcb *tp;
	
	<span class="enscript-keyword">if</span> (itpl-&gt;itpl_proto == IPPROTO_TCP)
		pcbinfo = &amp;tcbinfo;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-keyword">if</span> (itpl-&gt;itpl_local_sa.sa_family == AF_INET &amp;&amp;
		itpl-&gt;itpl_remote_sa.sa_family == AF_INET) {
		inp = in_pcblookup_hash(pcbinfo, 
			itpl-&gt;itpl_remote_sin.sin_addr,
			itpl-&gt;itpl_remote_sin.sin_port,
			itpl-&gt;itpl_local_sin.sin_addr,
			itpl-&gt;itpl_local_sin.sin_port,
			0, NULL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (itpl-&gt;itpl_local_sa.sa_family == AF_INET6 &amp;&amp;
		itpl-&gt;itpl_remote_sa.sa_family == AF_INET6) {
		<span class="enscript-type">struct</span> in6_addr ina6_local;
		<span class="enscript-type">struct</span> in6_addr ina6_remote;
		
		ina6_local = itpl-&gt;itpl_local_sin6.sin6_addr;
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ina6_local) &amp;&amp; 
			itpl-&gt;itpl_local_sin6.sin6_scope_id)
			ina6_local.s6_addr16[1] = htons(itpl-&gt;itpl_local_sin6.sin6_scope_id);

		ina6_remote = itpl-&gt;itpl_remote_sin6.sin6_addr;
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ina6_remote) &amp;&amp; 
			itpl-&gt;itpl_remote_sin6.sin6_scope_id)
			ina6_remote.s6_addr16[1] = htons(itpl-&gt;itpl_remote_sin6.sin6_scope_id);
		
		inp = in6_pcblookup_hash(pcbinfo, 
			&amp;ina6_remote,
			itpl-&gt;itpl_remote_sin6.sin6_port,
			&amp;ina6_local,
			itpl-&gt;itpl_local_sin6.sin6_port,
			0, NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (inp == NULL || (so = inp-&gt;inp_socket) == NULL)
		<span class="enscript-keyword">return</span> ENOENT;

	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
		socket_unlock(so, 0);
		<span class="enscript-keyword">return</span> ENOENT;
	}
	tp = intotcpcb(inp);

	tcp_fill_info(tp, ti);
	socket_unlock(so, 0);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_connection_fill_info</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> tcp_connection_info *tci)
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;

	bzero(tci, <span class="enscript-keyword">sizeof</span>(*tci));
	tci-&gt;tcpi_state = tp-&gt;t_state;
	<span class="enscript-keyword">if</span> (tp-&gt;t_state &gt; TCPS_LISTEN) {
		<span class="enscript-keyword">if</span> (TSTMP_SUPPORTED(tp))
			tci-&gt;tcpi_options |= TCPCI_OPT_TIMESTAMPS;
		<span class="enscript-keyword">if</span> (SACK_ENABLED(tp))
			tci-&gt;tcpi_options |= TCPCI_OPT_SACK;
		<span class="enscript-keyword">if</span> (TCP_WINDOW_SCALE_ENABLED(tp)) {
			tci-&gt;tcpi_options |= TCPCI_OPT_WSCALE;
			tci-&gt;tcpi_snd_wscale = tp-&gt;snd_scale;
			tci-&gt;tcpi_rcv_wscale = tp-&gt;rcv_scale;
		}
		<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp))
			tci-&gt;tcpi_options |= TCPCI_OPT_ECN;
		<span class="enscript-keyword">if</span> (IN_FASTRECOVERY(tp) || tp-&gt;t_rxtshift &gt; 0)
			tci-&gt;tcpi_flags |= TCPCI_FLAG_LOSSRECOVERY;
		<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_PKTS_REORDERED)
			tci-&gt;tcpi_flags |= TCPCI_FLAG_REORDERING_DETECTED;
		tci-&gt;tcpi_rto = (tp-&gt;t_timer[TCPT_REXMT] &gt; 0) ?
			tp-&gt;t_rxtcur : 0;
		tci-&gt;tcpi_maxseg = tp-&gt;t_maxseg;
		tci-&gt;tcpi_snd_ssthresh = tp-&gt;snd_ssthresh;
		tci-&gt;tcpi_snd_cwnd = tp-&gt;snd_cwnd;
		tci-&gt;tcpi_snd_wnd = tp-&gt;snd_wnd;
		tci-&gt;tcpi_snd_sbbytes = inp-&gt;inp_socket-&gt;so_snd.sb_cc;
		tci-&gt;tcpi_rcv_wnd = tp-&gt;rcv_wnd;
		tci-&gt;tcpi_rttcur = tp-&gt;t_rttcur;
		tci-&gt;tcpi_srtt = (tp-&gt;t_srtt &gt;&gt; TCP_RTT_SHIFT);
		tci-&gt;tcpi_rttvar = (tp-&gt;t_rttvar &gt;&gt; TCP_RTTVAR_SHIFT);
		tci-&gt;tcpi_txpackets = inp-&gt;inp_stat-&gt;txpackets;
		tci-&gt;tcpi_txbytes = inp-&gt;inp_stat-&gt;txbytes;
		tci-&gt;tcpi_txretransmitbytes = tp-&gt;t_stat.txretransmitbytes;
		tci-&gt;tcpi_rxpackets = inp-&gt;inp_stat-&gt;rxpackets;
		tci-&gt;tcpi_rxbytes = inp-&gt;inp_stat-&gt;rxbytes;
		tci-&gt;tcpi_rxoutoforderbytes = tp-&gt;t_stat.rxoutoforderbytes;

		tci-&gt;tcpi_tfo_syn_data_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYNDATA_RCV);
		tci-&gt;tcpi_tfo_cookie_req_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIEREQ_RECV);
		tci-&gt;tcpi_tfo_cookie_sent = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_SENT);
		tci-&gt;tcpi_tfo_cookie_invalid = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_INVALID);
		tci-&gt;tcpi_tfo_cookie_req = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_REQ);
		tci-&gt;tcpi_tfo_cookie_rcv = !!(tp-&gt;t_tfo_stats &amp; TFO_S_COOKIE_RCV);
		tci-&gt;tcpi_tfo_syn_data_sent = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_SENT);
		tci-&gt;tcpi_tfo_syn_data_acked = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_DATA_ACKED);
		tci-&gt;tcpi_tfo_syn_loss = !!(tp-&gt;t_tfo_stats &amp; TFO_S_SYN_LOSS);
	}
}


__private_extern__ <span class="enscript-type">int</span> 
<span class="enscript-function-name">tcp_sysctl_info</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> tcp_info ti;
	<span class="enscript-type">struct</span> info_tuple itpl;
	proc_t caller = PROC_NULL;
	proc_t caller_parent = PROC_NULL;
	<span class="enscript-type">char</span> command_name[MAXCOMLEN + 1] = <span class="enscript-string">&quot;&quot;</span>;
	<span class="enscript-type">char</span> parent_name[MAXCOMLEN + 1] = <span class="enscript-string">&quot;&quot;</span>;

	<span class="enscript-keyword">if</span> ((caller = proc_self()) != PROC_NULL) {
		<span class="enscript-comment">/* get process name */</span>
		strlcpy(command_name, caller-&gt;p_comm, <span class="enscript-keyword">sizeof</span>(command_name));

		<span class="enscript-comment">/* get parent process name if possible */</span>
		<span class="enscript-keyword">if</span> ((caller_parent = proc_find(caller-&gt;p_ppid)) != PROC_NULL) {
			strlcpy(parent_name, caller_parent-&gt;p_comm,
			    <span class="enscript-keyword">sizeof</span>(parent_name));
			proc_rele(caller_parent);
		}

		<span class="enscript-keyword">if</span> ((escape_str(command_name, strlen(command_name),
		    <span class="enscript-keyword">sizeof</span>(command_name)) == 0) &amp;&amp;
		    (escape_str(parent_name, strlen(parent_name),
		    <span class="enscript-keyword">sizeof</span>(parent_name)) == 0)) {
			kern_asl_msg(LOG_DEBUG, <span class="enscript-string">&quot;messagetracer&quot;</span>,
			    5,
			    <span class="enscript-string">&quot;com.apple.message.domain&quot;</span>,
			    <span class="enscript-string">&quot;com.apple.kernel.tcpstat&quot;</span>, <span class="enscript-comment">/* 1 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature&quot;</span>,
			    <span class="enscript-string">&quot;tcpinfo&quot;</span>, <span class="enscript-comment">/* 2 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature2&quot;</span>, command_name, <span class="enscript-comment">/* 3 */</span>
			    <span class="enscript-string">&quot;com.apple.message.signature3&quot;</span>, parent_name, <span class="enscript-comment">/* 4 */</span>
			    <span class="enscript-string">&quot;com.apple.message.summarize&quot;</span>, <span class="enscript-string">&quot;YES&quot;</span>, <span class="enscript-comment">/* 5 */</span>
			    NULL);
		}
	}

	<span class="enscript-keyword">if</span> (caller != PROC_NULL)
		proc_rele(caller);

	<span class="enscript-keyword">if</span> (req-&gt;newptr == USER_ADDR_NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (req-&gt;newlen &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> info_tuple)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	error = SYSCTL_IN(req, &amp;itpl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> info_tuple));
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> error;
	}
	error = tcp_fill_info_for_info_tuple(&amp;itpl, &amp;ti);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> error;
	}
	error = SYSCTL_OUT(req, &amp;ti, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_info));
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_lookup_peer_pid_locked</span>(<span class="enscript-type">struct</span> socket *so, pid_t *out_pid)
{
	<span class="enscript-type">int</span> error = EHOSTUNREACH;
	*out_pid = -1;
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISCONNECTED) == 0) <span class="enscript-keyword">return</span> ENOTCONN;
	
	<span class="enscript-type">struct</span> inpcb	*inp = (<span class="enscript-type">struct</span> inpcb*)so-&gt;so_pcb;
	uint16_t		lport = inp-&gt;inp_lport;
	uint16_t		fport = inp-&gt;inp_fport;
	<span class="enscript-type">struct</span> inpcb	*finp = NULL;
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV6) {
		<span class="enscript-type">struct</span>	in6_addr	laddr6 = inp-&gt;in6p_laddr;
		<span class="enscript-type">struct</span>	in6_addr	faddr6 = inp-&gt;in6p_faddr;
		socket_unlock(so, 0);
		finp = in6_pcblookup_hash(&amp;tcbinfo, &amp;laddr6, lport, &amp;faddr6, fport, 0, NULL);
		socket_lock(so, 0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		<span class="enscript-type">struct</span>	in_addr	laddr4 = inp-&gt;inp_laddr;
		<span class="enscript-type">struct</span>	in_addr	faddr4 = inp-&gt;inp_faddr;
		socket_unlock(so, 0);
		finp = in_pcblookup_hash(&amp;tcbinfo, laddr4, lport, faddr4, fport, 0, NULL);
		socket_lock(so, 0);
	}
	
	<span class="enscript-keyword">if</span> (finp) {
		*out_pid = finp-&gt;inp_socket-&gt;last_pid;
		error = 0;
		in_pcb_checkstate(finp, WNT_RELEASE, 0);
	}
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_getconninfo</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> conninfo_tcp *tcp_ci)
{
	(<span class="enscript-type">void</span>) tcp_lookup_peer_pid_locked(so, &amp;tcp_ci-&gt;tcpci_peer_pid);
	tcp_fill_info(sototcpcb(so), &amp;tcp_ci-&gt;tcpci_tcp_info);
}

<span class="enscript-comment">/*
 * The new sockopt interface makes it possible for us to block in the
 * copyin/out step (if we take a page fault).  Taking a page fault at
 * splnet() is probably a Bad Thing.  (Since sockets and pcbs both now
 * use TSM, there probably isn't any need for this function to run at
 * splnet() any more.  This needs more examination.)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_ctloutput</span>(so, sopt)
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> sockopt *sopt;
{
	<span class="enscript-type">int</span>	error, opt, optval;
	<span class="enscript-type">struct</span>	inpcb *inp;
	<span class="enscript-type">struct</span>	tcpcb *tp;

	error = 0;
	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		<span class="enscript-keyword">return</span> (ECONNRESET);
	}
	<span class="enscript-comment">/* Allow &lt;SOL_SOCKET,SO_FLUSH/SO_TRAFFIC_MGT_BACKGROUND&gt; at this level */</span>
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_TCP &amp;&amp;
	    !(sopt-&gt;sopt_level == SOL_SOCKET &amp;&amp; (sopt-&gt;sopt_name == SO_FLUSH ||
	    sopt-&gt;sopt_name == SO_TRAFFIC_MGT_BACKGROUND))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
			error = ip6_ctloutput(so, sopt);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		error = ip_ctloutput(so, sopt);
		<span class="enscript-keyword">return</span> (error);
	}
	tp = intotcpcb(inp);
	<span class="enscript-keyword">if</span> (tp == NULL) {
		<span class="enscript-keyword">return</span> (ECONNRESET);
	}

	calculate_tcp_clock();

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOOPT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOPUSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ENABLE_ECN</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
					    <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
				opt = TF_NODELAY;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOOPT</span>:
				opt = TF_NOOPT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOPUSH</span>:
				opt = TF_NOPUSH;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ENABLE_ECN</span>:
				opt = TF_ENABLE_ECN;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				opt = 0; <span class="enscript-comment">/* dead code to fool gcc */</span>
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (optval)
				tp-&gt;t_flags |= opt;
			<span class="enscript-keyword">else</span>
				tp-&gt;t_flags &amp;= ~opt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTIMEWAIT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
				<span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
				opt = TF_RXTFINDROP;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTIMEWAIT</span>:
				opt = TF_NOTIMEWAIT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				opt = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (optval)
				tp-&gt;t_flagsext |= opt;
			<span class="enscript-keyword">else</span>
				tp-&gt;t_flagsext &amp;= ~opt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MEASURE_SND_BW</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
				<span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			opt = TF_MEASURESNDBW;
			<span class="enscript-keyword">if</span> (optval) {
				<span class="enscript-keyword">if</span> (tp-&gt;t_bwmeas == NULL) {
					tp-&gt;t_bwmeas = tcp_bwmeas_alloc(tp);
					<span class="enscript-keyword">if</span> (tp-&gt;t_bwmeas == NULL) {
						error = ENOMEM;
						<span class="enscript-keyword">break</span>;
					}
				}
				tp-&gt;t_flagsext |= opt;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_flagsext &amp;= ~opt;
				<span class="enscript-comment">/* Reset snd bw measurement state */</span>
				tp-&gt;t_flagsext &amp;= ~(TF_BWMEAS_INPROGRESS);
				<span class="enscript-keyword">if</span> (tp-&gt;t_bwmeas != NULL) {
					tcp_bwmeas_free(tp);
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MEASURE_BW_BURST</span>: {
			<span class="enscript-type">struct</span> tcp_measure_bw_burst in;
			uint32_t minpkts, maxpkts;
			bzero(&amp;in, <span class="enscript-keyword">sizeof</span>(in));

			error = sooptcopyin(sopt, &amp;in, <span class="enscript-keyword">sizeof</span>(in),
				<span class="enscript-keyword">sizeof</span>(in));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) == 0 ||
				tp-&gt;t_bwmeas == NULL) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			minpkts = (in.min_burst_size != 0) ? in.min_burst_size : 
				tp-&gt;t_bwmeas-&gt;bw_minsizepkts;
			maxpkts = (in.max_burst_size != 0) ? in.max_burst_size :
				tp-&gt;t_bwmeas-&gt;bw_maxsizepkts;
			<span class="enscript-keyword">if</span> (minpkts &gt; maxpkts) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			tp-&gt;t_bwmeas-&gt;bw_minsizepkts = minpkts;
			tp-&gt;t_bwmeas-&gt;bw_maxsizepkts = maxpkts;
			tp-&gt;t_bwmeas-&gt;bw_minsize = (minpkts * tp-&gt;t_maxseg);
			tp-&gt;t_bwmeas-&gt;bw_maxsize = (maxpkts * tp-&gt;t_maxseg);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MAXSEG</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
					    <span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (optval &gt; 0 &amp;&amp; optval &lt;= tp-&gt;t_maxseg &amp;&amp;
			    optval + 40 &gt;= tcp_minmss)
				tp-&gt;t_maxseg = optval;
			<span class="enscript-keyword">else</span>
				error = EINVAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
						<span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; UINT32_MAX/TCP_RETRANSHZ) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_keepidle = optval * TCP_RETRANSHZ;
				<span class="enscript-comment">/* reset the timer to new value */</span>
				tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp, 
					TCP_CONN_KEEPIDLE(tp));
				tcp_check_timer_state(tp);
			}
                        <span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
						<span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; UINT32_MAX/TCP_RETRANSHZ) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_keepinit = optval * TCP_RETRANSHZ;
				<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_SYN_RECEIVED ||
					tp-&gt;t_state == TCPS_SYN_SENT) {
					tp-&gt;t_timer[TCPT_KEEP] = OFFSET_FROM_START(tp,
						TCP_CONN_KEEPINIT(tp));
					tcp_check_timer_state(tp);
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; UINT32_MAX/TCP_RETRANSHZ) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_keepintvl = optval * TCP_RETRANSHZ;
				<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_FIN_WAIT_2 &amp;&amp;
					TCP_CONN_MAXIDLE(tp) &gt; 0) {
					tp-&gt;t_timer[TCPT_2MSL] = OFFSET_FROM_START(tp,
						TCP_CONN_MAXIDLE(tp));
					tcp_check_timer_state(tp);
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; INT32_MAX) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_keepcnt = optval;
				<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_FIN_WAIT_2 &amp;&amp;
					TCP_CONN_MAXIDLE(tp) &gt; 0) {
					tp-&gt;t_timer[TCPT_2MSL] = OFFSET_FROM_START(tp,
						TCP_CONN_MAXIDLE(tp));
					tcp_check_timer_state(tp);
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval,
						<span class="enscript-keyword">sizeof</span> optval);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0)
				error = EINVAL;
			<span class="enscript-keyword">else</span> 
				tp-&gt;t_persist_timeout = optval * TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
					<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0)
				error = EINVAL;
			<span class="enscript-keyword">else</span>
				tp-&gt;t_rxt_conndroptime = optval * TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (optval == 0) {
					so-&gt;so_flags &amp;= ~(SOF_NOTSENT_LOWAT);
					tp-&gt;t_notsent_lowat = 0;
				} <span class="enscript-keyword">else</span> { 
					so-&gt;so_flags |= SOF_NOTSENT_LOWAT;
					tp-&gt;t_notsent_lowat = optval;
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ADAPTIVE_READ_TIMEOUT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || 
			    optval &gt; TCP_ADAPTIVE_TIMEOUT_MAX) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (optval == 0) {
				tp-&gt;t_adaptive_rtimo = 0;
				tcp_keepalive_reset(tp);
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_adaptive_rtimo = optval;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ADAPTIVE_WRITE_TIMEOUT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || 
			    optval &gt; TCP_ADAPTIVE_TIMEOUT_MAX) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_adaptive_wtimo = optval;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ENABLE_MSGS</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; 1) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (optval == 1) {
				<span class="enscript-comment">/*
				 * Check if messages option is already
				 * enabled, if so return.
				 */</span>
				<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
					VERIFY(so-&gt;so_msg_state != NULL);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/*
				 * allocate memory for storing message 
				 * related state
				 */</span>
				VERIFY(so-&gt;so_msg_state == NULL);
				MALLOC(so-&gt;so_msg_state, 
					<span class="enscript-type">struct</span> msg_state *,
					<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msg_state), 
					M_TEMP, M_WAITOK | M_ZERO);
				<span class="enscript-keyword">if</span> (so-&gt;so_msg_state == NULL) {
					error = ENOMEM;
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">/* Enable message delivery */</span>
				so-&gt;so_flags |= SOF_ENABLE_MSGS;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * Can't disable message delivery on socket 
				 * because of restrictions imposed by 
				 * encoding/decoding
				 */</span>
				error = EINVAL;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_SENDMOREACKS</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; 1) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (optval == 0) {
				tp-&gt;t_flagsext &amp;= ~(TF_NOSTRETCHACK);
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_flagsext |= TF_NOSTRETCHACK;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_DISABLE_BLACKHOLE_DETECTION</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; 1) {
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (optval == 0) {
				tp-&gt;t_flagsext &amp;= ~TF_NOBLACKHOLE_DETECTION;
			} <span class="enscript-keyword">else</span> {
				tp-&gt;t_flagsext |= TF_NOBLACKHOLE_DETECTION;
				<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_BLACKHOLE) &amp;&amp;
				    tp-&gt;t_pmtud_saved_maxopd &gt; 0)
					tcp_pmtud_revert_segment_size(tp);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_FASTOPEN</span>:
			<span class="enscript-keyword">if</span> (!(tcp_fastopen &amp; TCP_FASTOPEN_SERVER)) {
				error = ENOTSUP;
				<span class="enscript-keyword">break</span>;
			}

			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
				<span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (optval &lt; 0 || optval &gt; 1) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_LISTEN) {
				error =  EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (optval)
				tp-&gt;t_flagsext |= TF_FASTOPEN;
			<span class="enscript-keyword">else</span>
				tcp_disable_tfo(tp);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			error = inp_flush(inp, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_MGT_BACKGROUND</span>:
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (optval) {
				socket_set_traffic_mgt_flags_locked(so,
				    TRAFFIC_MGT_SO_BACKGROUND);
			} <span class="enscript-keyword">else</span> {
				socket_clear_traffic_mgt_flags_locked(so,
				    TRAFFIC_MGT_SO_BACKGROUND);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NODELAY</span>:
			optval = tp-&gt;t_flags &amp; TF_NODELAY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MAXSEG</span>:
			optval = tp-&gt;t_maxseg;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPALIVE</span>:
			optval = tp-&gt;t_keepidle / TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPINTVL</span>:
			optval = tp-&gt;t_keepintvl / TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_KEEPCNT</span>:
			optval = tp-&gt;t_keepcnt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOOPT</span>:
			optval = tp-&gt;t_flags &amp; TF_NOOPT;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOPUSH</span>:
			optval = tp-&gt;t_flags &amp; TF_NOPUSH;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ENABLE_ECN</span>:
			optval = (tp-&gt;t_flags &amp; TF_ENABLE_ECN) ? 1 : 0; 
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTIONTIMEOUT</span>:
			optval = tp-&gt;t_keepinit / TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PERSIST_TIMEOUT</span>:
			optval = tp-&gt;t_persist_timeout / TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_CONNDROPTIME</span>:
			optval = tp-&gt;t_rxt_conndroptime / TCP_RETRANSHZ;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_RXT_FINDROP</span>:
			optval = tp-&gt;t_flagsext &amp; TF_RXTFINDROP;
			<span class="enscript-keyword">break</span>; 
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTIMEWAIT</span>:
			optval = (tp-&gt;t_flagsext &amp; TF_NOTIMEWAIT) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_FASTOPEN</span>:
			<span class="enscript-keyword">if</span> (tp-&gt;t_state != TCPS_LISTEN ||
			    !(tcp_fastopen &amp; TCP_FASTOPEN_SERVER)) {
				error = ENOTSUP;
				<span class="enscript-keyword">break</span>;
			}
			optval = tfo_enabled(tp);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MEASURE_SND_BW</span>:
			optval = tp-&gt;t_flagsext &amp; TF_MEASURESNDBW;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_INFO</span>: {
			<span class="enscript-type">struct</span> tcp_info ti;

			tcp_fill_info(tp, &amp;ti);
			error = sooptcopyout(sopt, &amp;ti, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_info));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			<span class="enscript-comment">/* NOT REACHED */</span>
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_CONNECTION_INFO</span>: {
			<span class="enscript-type">struct</span> tcp_connection_info tci;
			tcp_connection_fill_info(tp, &amp;tci);
			error = sooptcopyout(sopt, &amp;tci,
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_connection_info));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_MEASURE_BW_BURST</span>: {
			<span class="enscript-type">struct</span> tcp_measure_bw_burst out;
			<span class="enscript-keyword">if</span> ((tp-&gt;t_flagsext &amp; TF_MEASURESNDBW) == 0 ||
				tp-&gt;t_bwmeas == NULL) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			out.min_burst_size = tp-&gt;t_bwmeas-&gt;bw_minsizepkts;
			out.max_burst_size = tp-&gt;t_bwmeas-&gt;bw_maxsizepkts;
			error = sooptcopyout(sopt, &amp;out, <span class="enscript-keyword">sizeof</span>(out));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_NOTSENT_LOWAT</span>:
			<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_NOTSENT_LOWAT) != 0) {
				optval = tp-&gt;t_notsent_lowat;
			} <span class="enscript-keyword">else</span> {
				optval = 0;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ENABLE_MSGS</span>:
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
				optval = 1;
			} <span class="enscript-keyword">else</span> {
				optval = 0;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_SENDMOREACKS</span>:
			<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_NOSTRETCHACK)
				optval = 1;
			<span class="enscript-keyword">else</span>
				optval = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_DISABLE_BLACKHOLE_DETECTION</span>:
			<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_NOBLACKHOLE_DETECTION)
				optval = 1;
			<span class="enscript-keyword">else</span>
				optval = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_PEER_PID</span>: {
			pid_t	pid;
			error = tcp_lookup_peer_pid_locked(so, &amp;pid);
			<span class="enscript-keyword">if</span> (error == 0)
				error = sooptcopyout(sopt, &amp;pid, <span class="enscript-keyword">sizeof</span>(pid));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ADAPTIVE_READ_TIMEOUT</span>:
			optval = tp-&gt;t_adaptive_rtimo;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCP_ADAPTIVE_WRITE_TIMEOUT</span>:
			optval = tp-&gt;t_adaptive_wtimo;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_MGT_BACKGROUND</span>:
			optval = (so-&gt;so_traffic_mgt_flags &amp;
			    TRAFFIC_MGT_SO_BACKGROUND) ? 1 : 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (error == 0)
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> optval);
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * tcp_sendspace and tcp_recvspace are the default send and receive window
 * sizes, respectively.  These are obsolescent (this information should
 * be set by the route).
 */</span>
u_int32_t	tcp_sendspace = 1448*256;
u_int32_t	tcp_recvspace = 1448*384;

<span class="enscript-comment">/* During attach, the size of socket buffer allocated is limited to
 * sb_max in sbreserve. Disallow setting the tcp send and recv space
 * to be more than sb_max because that will cause tcp_attach to fail
 * (see radar 5713060)
 */</span>  
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_tcp_sospace</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
	__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req) {
	u_int32_t new_value = 0, *space_p = NULL;
	<span class="enscript-type">int</span> changed = 0, error = 0;
	u_quad_t sb_effective_max = (sb_max / (MSIZE+MCLBYTES)) * MCLBYTES;

	<span class="enscript-keyword">switch</span> (oidp-&gt;oid_number) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPCTL_SENDSPACE</span>:
			space_p = &amp;tcp_sendspace;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPCTL_RECVSPACE</span>:
			space_p = &amp;tcp_recvspace;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> EINVAL;
	}
	error = sysctl_io_number(req, *space_p, <span class="enscript-keyword">sizeof</span>(u_int32_t),
		&amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-keyword">if</span> (new_value &gt; 0 &amp;&amp; new_value &lt;= sb_effective_max) {
			*space_p = new_value;
		} <span class="enscript-keyword">else</span> {
			error = ERANGE;
		}
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_SENDSPACE, sendspace, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_sendspace , 0, &amp;sysctl_tcp_sospace, <span class="enscript-string">&quot;IU&quot;</span>, <span class="enscript-string">&quot;Maximum outgoing TCP datagram size&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_RECVSPACE, recvspace, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_recvspace , 0, &amp;sysctl_tcp_sospace, <span class="enscript-string">&quot;IU&quot;</span>, <span class="enscript-string">&quot;Maximum incoming TCP datagram size&quot;</span>);

<span class="enscript-comment">/* Sysctl for testing and tuning the connectx with data api */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_PRECONNECT_SBSZ_MAX</span> 1460
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_PRECONNECT_SBSZ_MIN</span> (TCP_MSS)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_PRECONNECT_SBSZ_DEF</span>	(TCP6_MSS)
<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_preconnect_sbspace = TCP_PRECONNECT_SBSZ_DEF;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, preconn_sbsz, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_preconnect_sbspace, 0, <span class="enscript-string">&quot;Maximum preconnect space&quot;</span>);


<span class="enscript-comment">/*
 * Attach TCP protocol to socket, allocating
 * internet protocol control block, tcp control block,
 * bufer space, and entering LISTEN state if to accept connections.
 *
 * Returns:	0			Success
 *	in_pcballoc:ENOBUFS
 *	in_pcballoc:ENOMEM
 *	in_pcballoc:???			[IPSEC specific]
 *	soreserve:ENOBUFS
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_attach</span>(so, p)
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> proc *p;
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = SOCK_CHECK_DOM(so, PF_INET6) != 0;
#<span class="enscript-reference">endif</span>

	error = in_pcballoc(so, &amp;tcbinfo, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	inp = sotoinpcb(so);

	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_hiwat == 0 || so-&gt;so_rcv.sb_hiwat == 0) {
		error = soreserve(so, tcp_sendspace, tcp_recvspace);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_preconn_hiwat == 0) {
		soreserve_preconnect(so, imin(TCP_PRECONNECT_SBSZ_MAX,
		    imax(tcp_preconnect_sbspace, TCP_PRECONNECT_SBSZ_MIN)));
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_rcv.sb_flags &amp; SB_USRSIZE) == 0)
		so-&gt;so_rcv.sb_flags |= SB_AUTOSIZE;
	<span class="enscript-keyword">if</span> ((so-&gt;so_snd.sb_flags &amp; SB_USRSIZE) == 0)
		so-&gt;so_snd.sb_flags |= SB_AUTOSIZE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		inp-&gt;inp_vflag |= INP_IPV6;
		inp-&gt;in6p_hops = -1;	<span class="enscript-comment">/* use kernel default */</span>
	}
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	inp-&gt;inp_vflag |= INP_IPV4;
	tp = tcp_newtcpcb(inp);
	<span class="enscript-keyword">if</span> (tp == NULL) {
		<span class="enscript-type">int</span> nofd = so-&gt;so_state &amp; SS_NOFDREF;	<span class="enscript-comment">/* XXX */</span>

		so-&gt;so_state &amp;= ~SS_NOFDREF;	<span class="enscript-comment">/* don't free the socket yet */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			in6_pcbdetach(inp);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		in_pcbdetach(inp);
		so-&gt;so_state |= nofd;
		<span class="enscript-keyword">return</span> (ENOBUFS);
	}
	<span class="enscript-keyword">if</span> (nstat_collect)
		nstat_tcp_new_pcb(inp);
	tp-&gt;t_state = TCPS_CLOSED;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Initiate (or continue) disconnect.
 * If embryonic state, just send reset (once).
 * If in ``let data drain'' option and linger null, just drop.
 * Otherwise (hard), mark socket disconnecting and drop
 * current input data; switch states based on user close, and
 * send segment to peer (with FIN).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_disconnect</span>(tp)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (tp-&gt;t_state &lt; TCPS_ESTABLISHED)
		tp = tcp_close(tp);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_LINGER) &amp;&amp; so-&gt;so_linger == 0)
		tp = tcp_drop(tp, 0);
	<span class="enscript-keyword">else</span> {
		soisdisconnecting(so);
		sbflush(&amp;so-&gt;so_rcv);
		tp = tcp_usrclosed(tp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-comment">/* A reset has been sent but socket exists, do not send FIN */</span>
		<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp;
		    (tp) &amp;&amp; (tp-&gt;t_mpflags &amp; TMPF_RESET))
			<span class="enscript-keyword">return</span> (tp);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (tp)
			(<span class="enscript-type">void</span>) tcp_output(tp);
	}
	<span class="enscript-keyword">return</span> (tp);
}

<span class="enscript-comment">/*
 * User issued close, and wish to trail through shutdown states:
 * if never received SYN, just forget it.  If got a SYN from peer,
 * but haven't sent FIN, then go to FIN_WAIT_1 state to send peer a FIN.
 * If already got a FIN from peer, then almost done; go to LAST_ACK
 * state.  In all other cases, have already sent FIN to peer (e.g.
 * after PRU_SHUTDOWN), and just have to play tedious game waiting
 * for peer to send FIN or not respond to keep-alives, etc.
 * We can let the user exit from the close as soon as the FIN is acked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_usrclosed</span>(tp)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
{

	<span class="enscript-keyword">switch</span> (tp-&gt;t_state) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_LISTEN</span>:
		tp = tcp_close(tp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_SENT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_SYN_RECEIVED</span>:
		tp-&gt;t_flags |= TF_NEEDFIN;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_ESTABLISHED</span>:
		DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, 
			<span class="enscript-type">struct</span> inpcb *, tp-&gt;t_inpcb,
			<span class="enscript-type">struct</span> tcpcb *, tp, 
			int32_t, TCPS_FIN_WAIT_1);
		tp-&gt;t_state = TCPS_FIN_WAIT_1;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TCPS_CLOSE_WAIT</span>:
		DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, 
			<span class="enscript-type">struct</span> inpcb *, tp-&gt;t_inpcb,
			<span class="enscript-type">struct</span> tcpcb *, tp, 
			int32_t, TCPS_LAST_ACK);
		tp-&gt;t_state = TCPS_LAST_ACK;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (tp &amp;&amp; tp-&gt;t_state &gt;= TCPS_FIN_WAIT_2) {
		soisdisconnected(tp-&gt;t_inpcb-&gt;inp_socket);
		<span class="enscript-comment">/* To prevent the connection hanging in FIN_WAIT_2 forever. */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_FIN_WAIT_2)
			tp-&gt;t_timer[TCPT_2MSL] = OFFSET_FROM_START(tp, 
				TCP_CONN_MAXIDLE(tp));
	}
	<span class="enscript-keyword">return</span> (tp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_in_cksum_stats</span>(u_int32_t len)
{
	tcpstat.tcps_rcv_swcsum++;
	tcpstat.tcps_rcv_swcsum_bytes += len;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_out_cksum_stats</span>(u_int32_t len)
{
	tcpstat.tcps_snd_swcsum++;
	tcpstat.tcps_snd_swcsum_bytes += len;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_in6_cksum_stats</span>(u_int32_t len)
{
	tcpstat.tcps_rcv6_swcsum++;
	tcpstat.tcps_rcv6_swcsum_bytes += len;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_out6_cksum_stats</span>(u_int32_t len)
{
	tcpstat.tcps_snd6_swcsum++;
	tcpstat.tcps_snd6_swcsum_bytes += len;
}

<span class="enscript-comment">/* 
 * When messages are enabled on a TCP socket, the message priority
 * is sent as a control message. This function will extract it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_get_msg_priority</span>(<span class="enscript-type">struct</span> mbuf *control, uint32_t *msgpri) 
{
	<span class="enscript-type">struct</span> cmsghdr *cm;
	<span class="enscript-keyword">if</span> (control == NULL)
		<span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-keyword">for</span> (cm = M_FIRST_CMSGHDR(control); cm;
		cm = M_NXT_CMSGHDR(control, cm)) {
		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cmsghdr) ||
			cm-&gt;cmsg_len &gt; control-&gt;m_len) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_level == SOL_SOCKET &amp;&amp;
			cm-&gt;cmsg_type == SCM_MSG_PRIORITY) {
			*msgpri = *(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)CMSG_DATA(cm);
			<span class="enscript-keyword">break</span>;
		}
	}

	VERIFY(*msgpri &gt;= MSG_PRI_MIN &amp;&amp; *msgpri &lt;= MSG_PRI_MAX); 
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
</pre>
<hr />
</body></html>