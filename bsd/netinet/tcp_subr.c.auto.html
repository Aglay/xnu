<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tcp_subr.c	8.2 (Berkeley) 5/24/95
 * $FreeBSD: src/sys/netinet/tcp_subr.c,v 1.73.2.22 2001/08/22 00:59:12 silby Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/callout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/content_filter.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">tcp_minmssoverload</span> fring
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_fsm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/tcp6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcpip.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_debug.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">tcp_minmssoverload</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;corecrypto/ccaes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/aes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/md5.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/lro_ext.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_TCP_CLOSE</span>	NETDBG_CODE(DBG_NETTCP, ((5 &lt;&lt; 8) | 2))

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_lq_overflow;

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> tcptimerlist tcp_timer_list;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> tcptailq tcp_tw_tailq;

<span class="enscript-type">int</span> 	tcp_mssdflt = TCP_MSS;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, TCPCTL_MSSDFLT, mssdflt, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_mssdflt , 0, <span class="enscript-string">&quot;Default TCP Maximum Segment Size&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>	tcp_v6mssdflt = TCP6_MSS;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, TCPCTL_V6MSSDFLT, v6mssdflt,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_v6mssdflt , 0,
	<span class="enscript-string">&quot;Default TCP Maximum Segment Size for IPv6&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_do_autorcvbuf;

<span class="enscript-type">int</span> <span class="enscript-function-name">tcp_sysctl_fastopenkey</span>(<span class="enscript-type">struct</span> sysctl_oid *, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span> ,
    <span class="enscript-type">struct</span> sysctl_req *);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, fastopen_key,
    CTLTYPE_STRING | CTLFLAG_WR,
    0 , 0, tcp_sysctl_fastopenkey, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;TCP Fastopen key&quot;</span>);

<span class="enscript-comment">/* Current count of half-open TFO connections */</span>
<span class="enscript-type">int</span>	tcp_tfo_halfcnt = 0;

<span class="enscript-comment">/* Maximum of half-open TFO connection backlog */</span>
<span class="enscript-type">int</span>	tcp_tfo_backlog = 10;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, fastopen_backlog, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_tfo_backlog, 0, <span class="enscript-string">&quot;Backlog queue for half-open TFO connections&quot;</span>);

<span class="enscript-type">int</span>	tcp_fastopen = TCP_FASTOPEN_CLIENT | TCP_FASTOPEN_SERVER;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, fastopen, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_fastopen, 0, <span class="enscript-string">&quot;Enable TCP Fastopen (RFC 7413)&quot;</span>);

<span class="enscript-type">int</span>	tcp_tfo_fallback_min = 10;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, fastopen_fallback_min, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_tfo_fallback_min, 0, <span class="enscript-string">&quot;Mininum number of trials without TFO when in fallback mode&quot;</span>);

<span class="enscript-comment">/*
 * Minimum MSS we accept and use. This prevents DoS attacks where
 * we are forced to a ridiculous low MSS like 20 and send hundreds
 * of packets instead of one. The effect scales with the available
 * bandwidth and quickly saturates the CPU and network interface
 * with packet generation and sending. Set to zero to disable MINMSS
 * checking. This setting prevents us from sending too small packets.
 */</span>
<span class="enscript-type">int</span>	tcp_minmss = TCP_MINMSS;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, minmss, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_minmss , 0, <span class="enscript-string">&quot;Minmum TCP Maximum Segment Size&quot;</span>);
<span class="enscript-type">int</span> tcp_do_rfc1323 = 1;
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, TCPCTL_DO_RFC1323, rfc1323,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;tcp_do_rfc1323 , 0,
    <span class="enscript-string">&quot;Enable rfc1323 (high performance TCP) extensions&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (DEVELOPMENT || DEBUG) */</span>

<span class="enscript-comment">// Not used
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp_do_rfc1644 = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, TCPCTL_DO_RFC1644, rfc1644, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_do_rfc1644 , 0, <span class="enscript-string">&quot;Enable rfc1644 (TTCP) extensions&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	do_tcpdrain = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, do_tcpdrain, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;do_tcpdrain, 0,
     <span class="enscript-string">&quot;Enable tcp_drain routine for extra help when low on mbufs&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, pcbcount, CTLFLAG_RD | CTLFLAG_LOCKED, 
    &amp;tcbinfo.ipi_count, 0, <span class="enscript-string">&quot;Number of active PCBs&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tw_pcbcount, 
    CTLFLAG_RD | CTLFLAG_LOCKED,
    &amp;tcbinfo.ipi_twcount, 0, <span class="enscript-string">&quot;Number of pcbs in time-wait state&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	icmp_may_rst = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, icmp_may_rst, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;icmp_may_rst, 0, 
    <span class="enscript-string">&quot;Certain ICMP unreachable messages may abort connections in SYN_SENT&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp_strict_rfc1948 = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp_isn_reseed_interval = 0;
#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, strict_rfc1948,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_strict_rfc1948, 0, <span class="enscript-string">&quot;Determines if RFC1948 is followed exactly&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, isn_reseed_interval,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_isn_reseed_interval, 0, <span class="enscript-string">&quot;Seconds between reseeding of ISN secret&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* (DEVELOPMENT || DEBUG) */</span>

<span class="enscript-type">int</span> 	tcp_TCPTV_MIN = 100;	<span class="enscript-comment">/* 100ms minimum RTT */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rtt_min, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_TCPTV_MIN, 0, <span class="enscript-string">&quot;min rtt value allowed&quot;</span>);

<span class="enscript-type">int</span> tcp_rexmt_slop = TCPTV_REXMTSLOP;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, rexmt_slop, CTLFLAG_RW,
	&amp;tcp_rexmt_slop, 0, <span class="enscript-string">&quot;Slop added to retransmit timeout&quot;</span>);

__private_extern__ <span class="enscript-type">int</span> tcp_use_randomport = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, randomize_ports, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_use_randomport, 0, <span class="enscript-string">&quot;Randomize TCP port numbers&quot;</span>);

__private_extern__ <span class="enscript-type">int</span>	tcp_win_scale = 3;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, win_scale_factor,
    CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcp_win_scale, 0, <span class="enscript-string">&quot;Window scaling factor&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	tcp_cleartaocache(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	tcp_notify(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>);

<span class="enscript-type">struct</span> zone	*sack_hole_zone;
<span class="enscript-type">struct</span> zone	*tcp_reass_zone;
<span class="enscript-type">struct</span> zone	*tcp_bwmeas_zone;
<span class="enscript-type">struct</span> zone	*tcp_rxt_seg_zone;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> slowlink_wsize;	<span class="enscript-comment">/* window correction for slow links */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> path_mtu_discovery;

<span class="enscript-type">extern</span> u_int32_t tcp_autorcvbuf_max;
<span class="enscript-type">extern</span> u_int32_t tcp_autorcvbuf_inc_shift;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcp_sbrcv_grow_rwin</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_BWMEAS_BURST_MINSIZE</span> 6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_BWMEAS_BURST_MAXSIZE</span> 25

<span class="enscript-type">static</span> uint32_t bwmeas_elm_size;

<span class="enscript-comment">/*
 * Target size of TCP PCB hash tables. Must be a power of two.
 *
 * Note that this can be overridden by the kernel environment
 * variable net.inet.tcp.tcbhashsize
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">TCBHASHSIZE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCBHASHSIZE</span>	CONFIG_TCBHASHSIZE
#<span class="enscript-reference">endif</span>

__private_extern__ <span class="enscript-type">int</span>	tcp_tcbhashsize = TCBHASHSIZE;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_tcp, OID_AUTO, tcbhashsize, CTLFLAG_RD | CTLFLAG_LOCKED,
     &amp;tcp_tcbhashsize, 0, <span class="enscript-string">&quot;Size of TCP control-block hashtable&quot;</span>);

<span class="enscript-comment">/*
 * This is the actual shape of what we allocate using the zone
 * allocator.  Doing it this way allows us to protect both structures
 * using the same generation count, and also eliminates the overhead
 * of allocating tcpcbs separately.  By hiding the structure here,
 * we avoid changing most of the rest of the code (although it needs
 * to be changed, eventually, for greater efficiency).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ALIGNMENT</span>	32
<span class="enscript-type">struct</span>	inp_tp {
	<span class="enscript-type">struct</span>	inpcb	inp;
	<span class="enscript-type">struct</span>	tcpcb	tcb __attribute__((aligned(ALIGNMENT)));
};
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ALIGNMENT</span>

<span class="enscript-type">int</span>  <span class="enscript-function-name">get_inpcb_str_size</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>  <span class="enscript-function-name">get_tcp_str_size</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">tcpcb_to_otcpcb</span>(<span class="enscript-type">struct</span> tcpcb *, <span class="enscript-type">struct</span> otcpcb *);

<span class="enscript-type">static</span> lck_attr_t *tcp_uptime_mtx_attr = NULL;		<span class="enscript-comment">/* mutex attributes */</span>
<span class="enscript-type">static</span> lck_grp_t *tcp_uptime_mtx_grp = NULL;		<span class="enscript-comment">/* mutex group definition */</span>
<span class="enscript-type">static</span> lck_grp_attr_t *tcp_uptime_mtx_grp_attr = NULL;	<span class="enscript-comment">/* mutex group attributes */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">tcp_notsent_lowat_check</span>(<span class="enscript-type">struct</span> socket *so);

<span class="enscript-type">static</span> aes_encrypt_ctx tfo_ctx; <span class="enscript-comment">/* Crypto-context for TFO */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_gen_cookie</span>(<span class="enscript-type">struct</span> inpcb *inp, u_char *out, size_t blk_size)
{
	u_char in[CCAES_BLOCK_SIZE];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = inp-&gt;inp_vflag &amp; INP_IPV6;
#<span class="enscript-reference">endif</span>

	VERIFY(blk_size == CCAES_BLOCK_SIZE);

	bzero(&amp;in[0], CCAES_BLOCK_SIZE);
	bzero(&amp;out[0], CCAES_BLOCK_SIZE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6)
		memcpy(in, &amp;inp-&gt;in6p_faddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		memcpy(in, &amp;inp-&gt;inp_faddr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));

	aes_encrypt_cbc(in, NULL, 1, out, &amp;tfo_ctx);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_sysctl_fastopenkey</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
    __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-comment">/* TFO-key is expressed as a string in hex format (+1 to account for \0 char) */</span>
	<span class="enscript-type">char</span> keystring[TCP_FASTOPEN_KEYLEN * 2 + 1];
	u_int32_t key[TCP_FASTOPEN_KEYLEN / <span class="enscript-keyword">sizeof</span>(u_int32_t)];
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* -1, because newlen is len without the terminating \0 character */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newlen != (<span class="enscript-keyword">sizeof</span>(keystring) - 1)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* sysctl_io_string copies keystring into the oldptr of the sysctl_req.
	 * Make sure everything is zero, to avoid putting garbage in there or
	 * leaking the stack.
	 */</span>
	bzero(keystring, <span class="enscript-keyword">sizeof</span>(keystring));

	error = sysctl_io_string(req, keystring, <span class="enscript-keyword">sizeof</span>(keystring), 0, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (TCP_FASTOPEN_KEYLEN / <span class="enscript-keyword">sizeof</span>(u_int32_t)); i++) {
		<span class="enscript-comment">/* We jump over the keystring in 8-character (4 byte in hex) steps */</span>
		<span class="enscript-keyword">if</span> (sscanf(&amp;keystring[i * 8], <span class="enscript-string">&quot;%8x&quot;</span>, &amp;key[i]) != 1) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	aes_encrypt_key128((u_char *)key, &amp;tfo_ctx);

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>  <span class="enscript-function-name">get_inpcb_str_size</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> inpcb);
}

<span class="enscript-type">int</span>  <span class="enscript-function-name">get_tcp_str_size</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcpcb);
}

<span class="enscript-type">int</span>	tcp_freeq(<span class="enscript-type">struct</span> tcpcb *tp);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">scale_to_powerof2</span>(<span class="enscript-type">int</span> size);

<span class="enscript-comment">/*
 * This helper routine returns one of the following scaled value of size:
 * 1. Rounded down power of two value of size if the size value passed as 
 *    argument is not a power of two and the rounded up value overflows.
 * OR
 * 2. Rounded up power of two value of size if the size value passed as 
 *    argument is not a power of two and the rounded up value does not overflow  
 * OR
 * 3. Same value as argument size if it is already a power of two.
 */</span>    
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">scale_to_powerof2</span>(<span class="enscript-type">int</span> size) {
	<span class="enscript-comment">/* Handle special case of size = 0 */</span>
	<span class="enscript-type">int</span> ret = size ? size : 1;

	<span class="enscript-keyword">if</span> (!powerof2(ret)) {
		<span class="enscript-keyword">while</span>(!powerof2(size)) {
			<span class="enscript-comment">/* 
			 * Clear out least significant
			 * set bit till size is left with
			 * its highest set bit at which point
			 * it is rounded down power of two.
			 */</span> 
			size = size &amp; (size -1);
		}

		<span class="enscript-comment">/* Check for overflow when rounding up */</span>
		<span class="enscript-keyword">if</span> (0 == (size &lt;&lt; 1)) {
			ret = size;
		} <span class="enscript-keyword">else</span> {
			ret = size &lt;&lt; 1;
		}
	}

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_tfo_init</span>()
{
	u_char key[TCP_FASTOPEN_KEYLEN];

	read_random(key, <span class="enscript-keyword">sizeof</span>(key));
	aes_encrypt_key128(key, &amp;tfo_ctx);
}

<span class="enscript-comment">/*
 * Tcp initialization
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> tcp_initialized = 0;
	vm_size_t       str_size;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo;

	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-keyword">if</span> (tcp_initialized)
		<span class="enscript-keyword">return</span>;
	tcp_initialized = 1;

	tcp_ccgen = 1;
	tcp_cleartaocache();

	tcp_keepinit = TCPTV_KEEP_INIT;
	tcp_keepidle = TCPTV_KEEP_IDLE;
	tcp_keepintvl = TCPTV_KEEPINTVL;
	tcp_keepcnt = TCPTV_KEEPCNT;
	tcp_maxpersistidle = TCPTV_KEEP_IDLE;
	tcp_msl = TCPTV_MSL;

	microuptime(&amp;tcp_uptime);
	read_random(&amp;tcp_now, <span class="enscript-keyword">sizeof</span>(tcp_now));
	tcp_now = tcp_now &amp; 0x3fffffff; <span class="enscript-comment">/* Starts tcp internal clock at a random value */</span>

	tcp_tfo_init();

	LIST_INIT(&amp;tcb);
	tcbinfo.ipi_listhead = &amp;tcb;

	pcbinfo = &amp;tcbinfo;
	<span class="enscript-comment">/*
	 * allocate lock group attribute and group for tcp pcb mutexes
	 */</span>
	pcbinfo-&gt;ipi_lock_grp_attr = lck_grp_attr_alloc_init();
	pcbinfo-&gt;ipi_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tcppcb&quot;</span>, pcbinfo-&gt;ipi_lock_grp_attr);

	<span class="enscript-comment">/*
	 * allocate the lock attribute for tcp pcb mutexes
	 */</span>
	pcbinfo-&gt;ipi_lock_attr = lck_attr_alloc_init();

	<span class="enscript-keyword">if</span> ((pcbinfo-&gt;ipi_lock = lck_rw_alloc_init(pcbinfo-&gt;ipi_lock_grp,
	    pcbinfo-&gt;ipi_lock_attr)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate PCB lock\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (tcp_tcbhashsize == 0) {
		<span class="enscript-comment">/* Set to default */</span>
		tcp_tcbhashsize = 512;
	}

	<span class="enscript-keyword">if</span> (!powerof2(tcp_tcbhashsize)) {
		<span class="enscript-type">int</span> old_hash_size = tcp_tcbhashsize;
		tcp_tcbhashsize = scale_to_powerof2(tcp_tcbhashsize);
		<span class="enscript-comment">/* Lower limit of 16  */</span>
		<span class="enscript-keyword">if</span> (tcp_tcbhashsize &lt; 16) {
			tcp_tcbhashsize = 16;
		}
		printf(<span class="enscript-string">&quot;WARNING: TCB hash size not a power of 2, &quot;</span>
				<span class="enscript-string">&quot;scaled from %d to %d.\n&quot;</span>,
				old_hash_size,
				tcp_tcbhashsize);
	}

	tcbinfo.ipi_hashbase = hashinit(tcp_tcbhashsize, M_PCB, &amp;tcbinfo.ipi_hashmask);
	tcbinfo.ipi_porthashbase = hashinit(tcp_tcbhashsize, M_PCB,
					&amp;tcbinfo.ipi_porthashmask);
	str_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> inp_tp), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	tcbinfo.ipi_zone = zinit(str_size, 120000*str_size, 8192, <span class="enscript-string">&quot;tcpcb&quot;</span>);
	zone_change(tcbinfo.ipi_zone, Z_CALLERACCT, FALSE);
	zone_change(tcbinfo.ipi_zone, Z_EXPAND, TRUE);

	tcbinfo.ipi_gc = tcp_gc;
	tcbinfo.ipi_timer = tcp_itimer;
	in_pcbinfo_attach(&amp;tcbinfo);

	str_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sackhole), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	sack_hole_zone = zinit(str_size, 120000*str_size, 8192, <span class="enscript-string">&quot;sack_hole zone&quot;</span>);
	zone_change(sack_hole_zone, Z_CALLERACCT, FALSE);
	zone_change(sack_hole_zone, Z_EXPAND, TRUE);

	str_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tseg_qent), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	tcp_reass_zone = zinit(str_size, (nmbclusters &gt;&gt; 4) * str_size,
		0, <span class="enscript-string">&quot;tcp_reass_zone&quot;</span>);
	<span class="enscript-keyword">if</span> (tcp_reass_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating tcp_reass_zone&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(tcp_reass_zone, Z_CALLERACCT, FALSE);
	zone_change(tcp_reass_zone, Z_EXPAND, TRUE);

	bwmeas_elm_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bwmeas), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	tcp_bwmeas_zone = zinit(bwmeas_elm_size, (100 * bwmeas_elm_size), 0, <span class="enscript-string">&quot;tcp_bwmeas_zone&quot;</span>);
	<span class="enscript-keyword">if</span> (tcp_bwmeas_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating tcp_bwmeas_zone&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(tcp_bwmeas_zone, Z_CALLERACCT, FALSE);
	zone_change(tcp_bwmeas_zone, Z_EXPAND, TRUE);

	str_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_ccstate), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	tcp_cc_zone = zinit(str_size, 20000 * str_size, 0, <span class="enscript-string">&quot;tcp_cc_zone&quot;</span>);
	zone_change(tcp_cc_zone, Z_CALLERACCT, FALSE);
	zone_change(tcp_cc_zone, Z_EXPAND, TRUE);

	str_size = P2ROUNDUP(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcp_rxt_seg), <span class="enscript-keyword">sizeof</span>(u_int64_t));
	tcp_rxt_seg_zone = zinit(str_size, 10000 * str_size, 0,
	    <span class="enscript-string">&quot;tcp_rxt_seg_zone&quot;</span>);
	zone_change(tcp_rxt_seg_zone, Z_CALLERACCT, FALSE);
	zone_change(tcp_rxt_seg_zone, Z_EXPAND, TRUE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_MINPROTOHDR</span> (sizeof(struct ip6_hdr) + sizeof(struct tcphdr))
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TCP_MINPROTOHDR</span> (sizeof(struct tcpiphdr))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-keyword">if</span> (max_protohdr &lt; TCP_MINPROTOHDR) {
		_max_protohdr = TCP_MINPROTOHDR;
		_max_protohdr = max_protohdr;	<span class="enscript-comment">/* round it up */</span>
	}
	<span class="enscript-keyword">if</span> (max_linkhdr + max_protohdr &gt; MCLBYTES)
		panic(<span class="enscript-string">&quot;tcp_init&quot;</span>);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">TCP_MINPROTOHDR</span>

	<span class="enscript-comment">/* Initialize time wait and timer lists */</span>
	TAILQ_INIT(&amp;tcp_tw_tailq);

	bzero(&amp;tcp_timer_list, <span class="enscript-keyword">sizeof</span>(tcp_timer_list));
	LIST_INIT(&amp;tcp_timer_list.lhead);
	<span class="enscript-comment">/*
	 * allocate lock group attribute, group and attribute for the tcp timer list
	 */</span>
	tcp_timer_list.mtx_grp_attr = lck_grp_attr_alloc_init();
	tcp_timer_list.mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tcptimerlist&quot;</span>, tcp_timer_list.mtx_grp_attr);
	tcp_timer_list.mtx_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> ((tcp_timer_list.mtx = lck_mtx_alloc_init(tcp_timer_list.mtx_grp, tcp_timer_list.mtx_attr)) == NULL) {
		panic(<span class="enscript-string">&quot;failed to allocate memory for tcp_timer_list.mtx\n&quot;</span>);
	};
	<span class="enscript-keyword">if</span> ((tcp_timer_list.call = thread_call_allocate(tcp_run_timerlist, NULL)) == NULL) {
		panic(<span class="enscript-string">&quot;failed to allocate call entry 1 in tcp_init\n&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * allocate lock group attribute, group and attribute for tcp_uptime_lock
	 */</span>
	tcp_uptime_mtx_grp_attr = lck_grp_attr_alloc_init();
	tcp_uptime_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;tcpuptime&quot;</span>, tcp_uptime_mtx_grp_attr);
	tcp_uptime_mtx_attr = lck_attr_alloc_init();
	tcp_uptime_lock = lck_spin_alloc_init(tcp_uptime_mtx_grp, tcp_uptime_mtx_attr);

	<span class="enscript-comment">/* Initialize TCP LRO data structures */</span>
	tcp_lro_init();

	<span class="enscript-comment">/* Initialize TCP Cache */</span>
	tcp_cache_init();

	<span class="enscript-comment">/*
	 * If more than 60 MB of mbuf pool is available, increase the
	 * maximum allowed receive and send socket buffer size.
	 */</span>
	<span class="enscript-keyword">if</span> (nmbclusters &gt; 30720) {
		tcp_autorcvbuf_max = 1024 * 1024;
		tcp_autosndbuf_max = 1024 * 1024;
	}
}

<span class="enscript-comment">/*
 * Fill in the IP and TCP headers for an outgoing packet, given the tcpcb.
 * tcp_template used to store this data in mbufs, but we now recopy it out
 * of the tcpcb each time to conserve mbufs.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_fillheaders</span>(tp, ip_ptr, tcp_ptr)
	<span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">void</span> *ip_ptr;
	<span class="enscript-type">void</span> *tcp_ptr;
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> tcphdr *tcp_hdr = (<span class="enscript-type">struct</span> tcphdr *)tcp_ptr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0) {
		<span class="enscript-type">struct</span> ip6_hdr *ip6;

		ip6 = (<span class="enscript-type">struct</span> ip6_hdr *)ip_ptr;
		ip6-&gt;ip6_flow = (ip6-&gt;ip6_flow &amp; ~IPV6_FLOWINFO_MASK) |
			(inp-&gt;inp_flow &amp; IPV6_FLOWINFO_MASK);
		ip6-&gt;ip6_vfc = (ip6-&gt;ip6_vfc &amp; ~IPV6_VERSION_MASK) |
			(IPV6_VERSION &amp; IPV6_VERSION_MASK);
		ip6-&gt;ip6_nxt = IPPROTO_TCP;
		ip6-&gt;ip6_plen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr);
		ip6-&gt;ip6_src = inp-&gt;in6p_laddr;
		ip6-&gt;ip6_dst = inp-&gt;in6p_faddr;
		tcp_hdr-&gt;th_sum = in6_pseudo(&amp;inp-&gt;in6p_laddr, &amp;inp-&gt;in6p_faddr,
		    htonl(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) + IPPROTO_TCP));
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
	<span class="enscript-type">struct</span> ip *ip = (<span class="enscript-type">struct</span> ip *) ip_ptr;

	ip-&gt;ip_vhl = IP_VHL_BORING;
	ip-&gt;ip_tos = 0;
	ip-&gt;ip_len = 0;
	ip-&gt;ip_id = 0;
	ip-&gt;ip_off = 0;
	ip-&gt;ip_ttl = 0;
	ip-&gt;ip_sum = 0;
	ip-&gt;ip_p = IPPROTO_TCP;
	ip-&gt;ip_src = inp-&gt;inp_laddr;
	ip-&gt;ip_dst = inp-&gt;inp_faddr;
	tcp_hdr-&gt;th_sum = in_pseudo(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr,
		htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr) + IPPROTO_TCP));
	}

	tcp_hdr-&gt;th_sport = inp-&gt;inp_lport;
	tcp_hdr-&gt;th_dport = inp-&gt;inp_fport;
	tcp_hdr-&gt;th_seq = 0;
	tcp_hdr-&gt;th_ack = 0;
	tcp_hdr-&gt;th_x2 = 0;
	tcp_hdr-&gt;th_off = 5;
	tcp_hdr-&gt;th_flags = 0;
	tcp_hdr-&gt;th_win = 0;
	tcp_hdr-&gt;th_urp = 0;
}

<span class="enscript-comment">/*
 * Create template to be used to send tcp packets on a connection.
 * Allocates an mbuf and fills in a skeletal tcp/ip header.  The only
 * use for this function is in keepalives, which use tcp_respond.
 */</span>
<span class="enscript-type">struct</span> tcptemp *
<span class="enscript-function-name">tcp_maketemplate</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> tcptemp *n;

	m = m_get(M_DONTWAIT, MT_HEADER);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (0);
	m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcptemp);
	n = mtod(m, <span class="enscript-type">struct</span> tcptemp *);

	tcp_fillheaders(tp, (<span class="enscript-type">void</span> *)&amp;n-&gt;tt_ipgen, (<span class="enscript-type">void</span> *)&amp;n-&gt;tt_t);
	<span class="enscript-keyword">return</span> (n);
}

<span class="enscript-comment">/*
 * Send a single message to the TCP at address specified by
 * the given TCP/IP header.  If m == 0, then we make a copy
 * of the tcpiphdr at ti and send directly to the addressed host.
 * This is used to force keep alive messages out using the TCP
 * template for a connection.  If flags are given then we send
 * a message back to the TCP which originated the * segment ti,
 * and discard the mbuf containing it and any other attached mbufs.
 *
 * In any case the ack and sequence number of the transmitted
 * segment are as specified by the parameters.
 *
 * NOTE: If m != NULL, then ti must point to *inside* the mbuf.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_respond</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">void</span> *ipgen, <span class="enscript-type">struct</span> tcphdr *th, <span class="enscript-type">struct</span> mbuf *m,
    tcp_seq ack, tcp_seq seq, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> tcp_respond_args *tra)
{
	<span class="enscript-type">int</span> tlen;
	<span class="enscript-type">int</span> win = 0;
	<span class="enscript-type">struct</span> route *ro = 0;
	<span class="enscript-type">struct</span> route sro;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> tcphdr *nth;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> route_in6 *ro6 = 0;
	<span class="enscript-type">struct</span> route_in6 sro6;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> isipv6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> ifnet *outif;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	isipv6 = IP_VHL_V(((<span class="enscript-type">struct</span> ip *)ipgen)-&gt;ip_vhl) == 6;
	ip6 = ipgen;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	ip = ipgen;

	<span class="enscript-keyword">if</span> (tp) {
		<span class="enscript-keyword">if</span> (!(flags &amp; TH_RST)) {
			win = tcp_sbspace(tp);
			<span class="enscript-keyword">if</span> (win &gt; (int32_t)TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale)
				win = (int32_t)TCP_MAXWIN &lt;&lt; tp-&gt;rcv_scale;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			ro6 = &amp;tp-&gt;t_inpcb-&gt;in6p_route;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		ro = &amp;tp-&gt;t_inpcb-&gt;inp_route;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			ro6 = &amp;sro6;
			bzero(ro6, <span class="enscript-keyword">sizeof</span> *ro6);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			ro = &amp;sro;
			bzero(ro, <span class="enscript-keyword">sizeof</span> *ro);
		}
	}
	<span class="enscript-keyword">if</span> (m == 0) {
		m = m_gethdr(M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
		tlen = 0;
		m-&gt;m_data += max_linkhdr;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			VERIFY((MHLEN - max_linkhdr) &gt;=
			    (<span class="enscript-keyword">sizeof</span> (*ip6) + <span class="enscript-keyword">sizeof</span> (*nth)));
			bcopy((caddr_t)ip6, mtod(m, caddr_t), 
			      <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			nth = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip6 + 1);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		{
			VERIFY((MHLEN - max_linkhdr) &gt;=
			    (<span class="enscript-keyword">sizeof</span> (*ip) + <span class="enscript-keyword">sizeof</span> (*nth)));
			bcopy((caddr_t)ip, mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			nth = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip + 1);
		}
		bcopy((caddr_t)th, (caddr_t)nth, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">if</span> ((tp) &amp;&amp; (tp-&gt;t_mpflags &amp; TMPF_RESET))
			flags = (TH_RST | TH_ACK);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		flags = TH_ACK;
	} <span class="enscript-keyword">else</span> {
		m_freem(m-&gt;m_next);
		m-&gt;m_next = 0;
		m-&gt;m_data = (caddr_t)ipgen;
		<span class="enscript-comment">/* m_len is set later */</span>
		tlen = 0;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xchg</span>(a,b,type) { type t; t=a; a=b; b=t; }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			<span class="enscript-comment">/* Expect 32-bit aligned IP on strict-align platforms */</span>
			IP6_HDR_STRICT_ALIGNMENT_CHECK(ip6);
			xchg(ip6-&gt;ip6_dst, ip6-&gt;ip6_src, <span class="enscript-type">struct</span> in6_addr);
			nth = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip6 + 1);
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	      {
		<span class="enscript-comment">/* Expect 32-bit aligned IP on strict-align platforms */</span>
		IP_HDR_STRICT_ALIGNMENT_CHECK(ip);
		xchg(ip-&gt;ip_dst.s_addr, ip-&gt;ip_src.s_addr, n_long);
		nth = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip + 1);
	      }
		<span class="enscript-keyword">if</span> (th != nth) {
			<span class="enscript-comment">/*
			 * this is usually a case when an extension header
			 * exists between the IPv6 header and the
			 * TCP header.
			 */</span>
			nth-&gt;th_sport = th-&gt;th_sport;
			nth-&gt;th_dport = th-&gt;th_dport;
		}
		xchg(nth-&gt;th_dport, nth-&gt;th_sport, n_short);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">xchg</span>
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		ip6-&gt;ip6_plen = htons((u_short)(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) +
						tlen));
		tlen += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
      {
	tlen += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr);
	ip-&gt;ip_len = tlen;
	ip-&gt;ip_ttl = ip_defttl;
      }
	m-&gt;m_len = tlen;
	m-&gt;m_pkthdr.len = tlen;
	m-&gt;m_pkthdr.rcvif = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; tp-&gt;t_inpcb != NULL) {
		<span class="enscript-comment">/*
		 * Packet is associated with a socket, so allow the
		 * label of the response to reflect the socket label.
		 */</span>
		mac_mbuf_label_associate_inpcb(tp-&gt;t_inpcb, m);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Packet is not associated with a socket, so possibly
		 * update the label in place.
		 */</span>
		mac_netinet_tcp_reply(m);
	}
#<span class="enscript-reference">endif</span>

	nth-&gt;th_seq = htonl(seq);
	nth-&gt;th_ack = htonl(ack);
	nth-&gt;th_x2 = 0;
	nth-&gt;th_off = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) &gt;&gt; 2;
	nth-&gt;th_flags = flags;
	<span class="enscript-keyword">if</span> (tp)
		nth-&gt;th_win = htons((u_short) (win &gt;&gt; tp-&gt;rcv_scale));
	<span class="enscript-keyword">else</span>
		nth-&gt;th_win = htons((u_short)win);
	nth-&gt;th_urp = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		nth-&gt;th_sum = 0;
		nth-&gt;th_sum = in6_pseudo(&amp;ip6-&gt;ip6_src, &amp;ip6-&gt;ip6_dst,
		    htonl((tlen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) + IPPROTO_TCP));
		m-&gt;m_pkthdr.csum_flags = CSUM_TCPIPV6;
		m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> tcphdr, th_sum);
		ip6-&gt;ip6_hlim = in6_selecthlim(tp ? tp-&gt;t_inpcb : NULL,
					       ro6 &amp;&amp; ro6-&gt;ro_rt ?
					       ro6-&gt;ro_rt-&gt;rt_ifp :
					       NULL);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		nth-&gt;th_sum = in_pseudo(ip-&gt;ip_src.s_addr, ip-&gt;ip_dst.s_addr,
		htons((u_short)(tlen - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) + ip-&gt;ip_p)));
		m-&gt;m_pkthdr.csum_flags = CSUM_TCP;
		m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> tcphdr, th_sum);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (tp == NULL || (tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_options &amp; SO_DEBUG))
		tcp_trace(TA_OUTPUT, 0, tp, mtod(m, <span class="enscript-type">void</span> *), th, 0);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	necp_mark_packet_from_socket(m, tp ? tp-&gt;t_inpcb : NULL, 0, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; tp-&gt;t_inpcb-&gt;inp_sp != NULL &amp;&amp;
		ipsec_setsocket(m, tp ? tp-&gt;t_inpcb-&gt;inp_socket : NULL) != 0) {
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (tp != NULL) {
		u_int32_t svc_flags = 0;
		<span class="enscript-keyword">if</span> (isipv6) {
			svc_flags |= PKT_SCF_IPV6;
		}
		set_packet_service_class(m, tp-&gt;t_inpcb-&gt;inp_socket,
		    MBUF_SC_UNSPEC, svc_flags);

		<span class="enscript-comment">/* Embed flowhash and flow control flags */</span>
		m-&gt;m_pkthdr.pkt_flowsrc = FLOWSRC_INPCB;
		m-&gt;m_pkthdr.pkt_flowid = tp-&gt;t_inpcb-&gt;inp_flowhash;
		m-&gt;m_pkthdr.pkt_flags |= PKTF_FLOW_ID | PKTF_FLOW_LOCALSRC;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-comment">/* Disable flow advisory when using MPTCP. */</span>
		<span class="enscript-keyword">if</span> (!(tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
			m-&gt;m_pkthdr.pkt_flags |= PKTF_FLOW_ADV;
		m-&gt;m_pkthdr.pkt_proto = IPPROTO_TCP;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-type">struct</span> ip6_out_args ip6oa = { tra-&gt;ifscope, { 0 },
		    IP6OAF_SELECT_SRCIF | IP6OAF_BOUND_SRCADDR, 0 };

		<span class="enscript-keyword">if</span> (tra-&gt;ifscope != IFSCOPE_NONE)
			ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;
		<span class="enscript-keyword">if</span> (tra-&gt;nocell)
			ip6oa.ip6oa_flags |= IP6OAF_NO_CELLULAR;
		<span class="enscript-keyword">if</span> (tra-&gt;noexpensive)
			ip6oa.ip6oa_flags |= IP6OAF_NO_EXPENSIVE;
		<span class="enscript-keyword">if</span> (tra-&gt;awdl_unrestricted)
			ip6oa.ip6oa_flags |= IP6OAF_AWDL_UNRESTRICTED;

		(<span class="enscript-type">void</span>) ip6_output(m, NULL, ro6, IPV6_OUTARGS, NULL,
		    NULL, &amp;ip6oa);

		<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; ro6 != NULL &amp;&amp; ro6-&gt;ro_rt != NULL &amp;&amp;
		    (outif = ro6-&gt;ro_rt-&gt;rt_ifp) !=
		    tp-&gt;t_inpcb-&gt;in6p_last_outifp)
			tp-&gt;t_inpcb-&gt;in6p_last_outifp = outif;

		<span class="enscript-keyword">if</span> (ro6 == &amp;sro6)
			ROUTE_RELEASE(ro6);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	{
		<span class="enscript-type">struct</span> ip_out_args ipoa = { tra-&gt;ifscope, { 0 },
		    IPOAF_SELECT_SRCIF | IPOAF_BOUND_SRCADDR, 0 };

		<span class="enscript-keyword">if</span> (tra-&gt;ifscope != IFSCOPE_NONE)
			ipoa.ipoa_flags |= IPOAF_BOUND_IF;
		<span class="enscript-keyword">if</span> (tra-&gt;nocell)
			ipoa.ipoa_flags |= IPOAF_NO_CELLULAR;
		<span class="enscript-keyword">if</span> (tra-&gt;noexpensive)
			ipoa.ipoa_flags |= IPOAF_NO_EXPENSIVE;
		<span class="enscript-keyword">if</span> (tra-&gt;awdl_unrestricted)
			ipoa.ipoa_flags |= IPOAF_AWDL_UNRESTRICTED;

		<span class="enscript-keyword">if</span> (ro != &amp;sro) {
			<span class="enscript-comment">/* Copy the cached route and take an extra reference */</span>
			inp_route_copyout(tp-&gt;t_inpcb, &amp;sro);
		}
		<span class="enscript-comment">/*
		 * For consistency, pass a local route copy.
		 */</span>
		(<span class="enscript-type">void</span>) ip_output(m, NULL, &amp;sro, IP_OUTARGS, NULL, &amp;ipoa);

		<span class="enscript-keyword">if</span> (tp != NULL &amp;&amp; sro.ro_rt != NULL &amp;&amp;
		    (outif = sro.ro_rt-&gt;rt_ifp) !=
		    tp-&gt;t_inpcb-&gt;inp_last_outifp)
			tp-&gt;t_inpcb-&gt;inp_last_outifp = outif;

		<span class="enscript-keyword">if</span> (ro != &amp;sro) {
			<span class="enscript-comment">/* Synchronize cached PCB route */</span>
			inp_route_copyin(tp-&gt;t_inpcb, &amp;sro);
		} <span class="enscript-keyword">else</span> {
			ROUTE_RELEASE(&amp;sro);
		}
	}
}

<span class="enscript-comment">/*
 * Create a new TCP control block, making an
 * empty reassembly queue and hooking it to the argument
 * protocol control block.  The `inp' parameter must have
 * come from the zone allocator set up in tcp_init().
 */</span>
<span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_newtcpcb</span>(inp)
	<span class="enscript-type">struct</span> inpcb *inp;
{
	<span class="enscript-type">struct</span> inp_tp *it;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = (inp-&gt;inp_vflag &amp; INP_IPV6) != 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	calculate_tcp_clock();

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER) == 0) {
	     it = (<span class="enscript-type">struct</span> inp_tp *)(<span class="enscript-type">void</span> *)inp;
	     tp = &amp;it-&gt;tcb;
	} <span class="enscript-keyword">else</span> {
	     tp = (<span class="enscript-type">struct</span> tcpcb *)(<span class="enscript-type">void</span> *)inp-&gt;inp_saved_ppcb;
	}
	
	bzero((<span class="enscript-type">char</span> *) tp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcpcb));
	LIST_INIT(&amp;tp-&gt;t_segq);
	tp-&gt;t_maxseg = tp-&gt;t_maxopd =
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		tcp_mssdflt;

	<span class="enscript-keyword">if</span> (tcp_do_rfc1323)
		tp-&gt;t_flags = (TF_REQ_SCALE|TF_REQ_TSTMP);
	<span class="enscript-keyword">if</span> (tcp_do_sack)
		tp-&gt;t_flagsext |= TF_SACK_ENABLE;

	TAILQ_INIT(&amp;tp-&gt;snd_holes);
	SLIST_INIT(&amp;tp-&gt;t_rxt_segments);
	tp-&gt;t_inpcb = inp;	<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-comment">/*
	 * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
	 * rtt estimate.  Set rttvar so that srtt + 4 * rttvar gives
	 * reasonable initial retransmit time.
	 */</span>
	tp-&gt;t_srtt = TCPTV_SRTTBASE;
	tp-&gt;t_rttvar = ((TCPTV_RTOBASE - TCPTV_SRTTBASE) &lt;&lt; TCP_RTTVAR_SHIFT) / 4;
	tp-&gt;t_rttmin = tcp_TCPTV_MIN;
	tp-&gt;t_rxtcur = TCPTV_RTOBASE;

	<span class="enscript-keyword">if</span> (tcp_use_newreno)
		<span class="enscript-comment">/* use newreno by default */</span>
		tp-&gt;tcp_cc_index = TCP_CC_ALGO_NEWRENO_INDEX;
	<span class="enscript-keyword">else</span>
		tp-&gt;tcp_cc_index = TCP_CC_ALGO_CUBIC_INDEX;

	tcp_cc_allocate_state(tp);

	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;init != NULL)
		CC_ALGO(tp)-&gt;init(tp);

	tp-&gt;snd_cwnd = TCP_CC_CWND_INIT_BYTES;
	tp-&gt;snd_ssthresh = TCP_MAXWIN &lt;&lt; TCP_MAX_WINSHIFT;
	tp-&gt;snd_ssthresh_prev = TCP_MAXWIN &lt;&lt; TCP_MAX_WINSHIFT;
	tp-&gt;t_rcvtime = tcp_now;
	tp-&gt;tentry.timer_start = tcp_now;
	tp-&gt;t_persist_timeout = tcp_max_persist_timeout;
	tp-&gt;t_persist_stop = 0;
	tp-&gt;t_flagsext |= TF_RCVUNACK_WAITSS;
	tp-&gt;t_rexmtthresh = tcprexmtthresh;

	<span class="enscript-comment">/* Clear time wait tailq entry */</span>
	tp-&gt;t_twentry.tqe_next = NULL;
	tp-&gt;t_twentry.tqe_prev = NULL;

	<span class="enscript-comment">/*
	 * IPv4 TTL initialization is necessary for an IPv6 socket as well,
	 * because the socket may be bound to an IPv6 wildcard address,
	 * which may match an IPv4-mapped IPv6 address.
	 */</span>
	inp-&gt;inp_ip_ttl = ip_defttl;
	inp-&gt;inp_ppcb = (caddr_t)tp;
	<span class="enscript-keyword">return</span> (tp);		<span class="enscript-comment">/* XXX */</span>
}

<span class="enscript-comment">/*
 * Drop a TCP connection, reporting
 * the specified error.  If connection is synchronized,
 * then send a RST to peer.
 */</span>
<span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_drop</span>(tp, errno)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
	<span class="enscript-type">int</span> errno;
{
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (TCPS_HAVERCVDSYN(tp-&gt;t_state)) {
		DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
			<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_CLOSED);
		tp-&gt;t_state = TCPS_CLOSED;
		(<span class="enscript-type">void</span>) tcp_output(tp);
		tcpstat.tcps_drops++;
	} <span class="enscript-keyword">else</span>
		tcpstat.tcps_conndrops++;
	<span class="enscript-keyword">if</span> (errno == ETIMEDOUT &amp;&amp; tp-&gt;t_softerror)
		errno = tp-&gt;t_softerror;
	so-&gt;so_error = errno;
	<span class="enscript-keyword">return</span> (tcp_close(tp));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_getrt_rtt</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> rtentry *rt) 
{
	u_int32_t rtt = rt-&gt;rt_rmx.rmx_rtt;
	<span class="enscript-type">int</span> isnetlocal = (tp-&gt;t_flags &amp; TF_LOCAL);

	<span class="enscript-keyword">if</span> (rtt != 0) {
		<span class="enscript-comment">/*
		 * XXX the lock bit for RTT indicates that the value
		 * is also a minimum value; this is subject to time.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_locks &amp; RTV_RTT)
			tp-&gt;t_rttmin = rtt / (RTM_RTTUNIT / TCP_RETRANSHZ);
		<span class="enscript-keyword">else</span>
			tp-&gt;t_rttmin = isnetlocal ? tcp_TCPTV_MIN : TCPTV_REXMTMIN;
		tp-&gt;t_srtt = rtt / (RTM_RTTUNIT / (TCP_RETRANSHZ * TCP_RTT_SCALE));
		tcpstat.tcps_usedrtt++;
		<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_rttvar) {
			tp-&gt;t_rttvar = rt-&gt;rt_rmx.rmx_rttvar /
		    		(RTM_RTTUNIT / (TCP_RETRANSHZ * TCP_RTTVAR_SCALE));
			tcpstat.tcps_usedrttvar++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* default variation is +- 1 rtt */</span>
			tp-&gt;t_rttvar =
		    		tp-&gt;t_srtt * TCP_RTTVAR_SCALE / TCP_RTT_SCALE;
		}
		TCPT_RANGESET(tp-&gt;t_rxtcur,
			((tp-&gt;t_srtt &gt;&gt; 2) + tp-&gt;t_rttvar) &gt;&gt; 1,
			tp-&gt;t_rttmin, TCPTV_REXMTMAX,
			TCP_ADD_REXMTSLOP(tp));
	}
}

<span class="enscript-comment">/*
 * Close a TCP control block:
 *	discard all space held by the tcp
 *	discard internet protocol block
 *	wake up any sleepers
 */</span>
<span class="enscript-type">struct</span> tcpcb *
<span class="enscript-function-name">tcp_close</span>(tp)
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">struct</span> inpcb *inp = tp-&gt;t_inpcb;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = (inp-&gt;inp_vflag &amp; INP_IPV6) != 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> route *ro;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> dosavessthresh;

	<span class="enscript-comment">/* tcp_close was called previously, bail */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_ppcb == NULL) 
		<span class="enscript-keyword">return</span>(NULL);

	tcp_canceltimers(tp);
	KERNEL_DEBUG(DBG_FNC_TCP_CLOSE | DBG_FUNC_START, tp,0,0,0,0);

	<span class="enscript-comment">/*
	 * If another thread for this tcp is currently in ip (indicated by
	 * the TF_SENDINPROG flag), defer the cleanup until after it returns
	 * back to tcp.  This is done to serialize the close until after all
	 * pending output is finished, in order to avoid having the PCB be
	 * detached and the cached route cleaned, only for ip to cache the
	 * route back into the PCB again.  Note that we've cleared all the
	 * timers at this point.  Set TF_CLOSING to indicate to tcp_output()
	 * that is should call us again once it returns from ip; at that
	 * point both flags should be cleared and we can proceed further
	 * with the cleanup.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_CLOSING) ||
		inp-&gt;inp_sndinprog_cnt &gt; 0) {
		tp-&gt;t_flags |= TF_CLOSING;
		<span class="enscript-keyword">return</span> (NULL);
	}

	DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL, <span class="enscript-type">struct</span> inpcb *, inp,
		<span class="enscript-type">struct</span> tcpcb *, tp, int32_t, TCPS_CLOSED);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	ro = (isipv6 ? (<span class="enscript-type">struct</span> route *)&amp;inp-&gt;in6p_route : &amp;inp-&gt;inp_route);
#<span class="enscript-reference">else</span>
	ro = &amp;inp-&gt;inp_route;
#<span class="enscript-reference">endif</span>
	rt = ro-&gt;ro_rt;
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK_SPIN(rt);

	<span class="enscript-comment">/*
	 * If we got enough samples through the srtt filter,
	 * save the rtt and rttvar in the routing entry.
	 * 'Enough' is arbitrarily defined as the 16 samples.
	 * 16 samples is enough for the srtt filter to converge
	 * to within 5% of the correct value; fewer samples and
	 * we could save a very bogus rtt.
	 *
	 * Don't update the default route's characteristics and don't
	 * update anything that the user &quot;locked&quot;.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_rttupdated &gt;= 16) {
		<span class="enscript-type">register</span> u_int32_t i = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6) {
			<span class="enscript-type">struct</span> sockaddr_in6 *sin6;

			<span class="enscript-keyword">if</span> (rt == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_valid_rt</span>;
			sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)rt_key(rt);
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;sin6-&gt;sin6_addr))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_valid_rt</span>;
		}
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) ||
		    SIN(rt_key(rt))-&gt;sin_addr.s_addr == INADDR_ANY) {
			DTRACE_TCP4(state__change, <span class="enscript-type">void</span>, NULL,
			    <span class="enscript-type">struct</span> inpcb *, inp, <span class="enscript-type">struct</span> tcpcb *, tp,
			    int32_t, TCPS_CLOSED);
			tp-&gt;t_state = TCPS_CLOSED;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_valid_rt</span>;
		}

		RT_LOCK_ASSERT_HELD(rt);
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_rmx.rmx_locks &amp; RTV_RTT) == 0) {
			i = tp-&gt;t_srtt *
			    (RTM_RTTUNIT / (TCP_RETRANSHZ * TCP_RTT_SCALE));
			<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_rtt &amp;&amp; i)
				<span class="enscript-comment">/*
				 * filter this update to half the old &amp; half
				 * the new values, converting scale.
				 * See route.h and tcp_var.h for a
				 * description of the scaling constants.
				 */</span>
				rt-&gt;rt_rmx.rmx_rtt =
				    (rt-&gt;rt_rmx.rmx_rtt + i) / 2;
			<span class="enscript-keyword">else</span>
				rt-&gt;rt_rmx.rmx_rtt = i;
			tcpstat.tcps_cachedrtt++;
		}
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_rmx.rmx_locks &amp; RTV_RTTVAR) == 0) {
			i = tp-&gt;t_rttvar *
			    (RTM_RTTUNIT / (TCP_RETRANSHZ * TCP_RTTVAR_SCALE));
			<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_rttvar &amp;&amp; i)
				rt-&gt;rt_rmx.rmx_rttvar =
				    (rt-&gt;rt_rmx.rmx_rttvar + i) / 2;
			<span class="enscript-keyword">else</span>
				rt-&gt;rt_rmx.rmx_rttvar = i;
			tcpstat.tcps_cachedrttvar++;
		}
		<span class="enscript-comment">/*
		 * The old comment here said:
		 * update the pipelimit (ssthresh) if it has been updated
		 * already or if a pipesize was specified &amp; the threshhold
		 * got below half the pipesize.  I.e., wait for bad news
		 * before we start updating, then update on both good
		 * and bad news.
		 *
		 * But we want to save the ssthresh even if no pipesize is
		 * specified explicitly in the route, because such
		 * connections still have an implicit pipesize specified
		 * by the global tcp_sendspace.  In the absence of a reliable
		 * way to calculate the pipesize, it will have to do.
		 */</span>
		i = tp-&gt;snd_ssthresh;
		<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_sendpipe != 0)
			dosavessthresh = (i &lt; rt-&gt;rt_rmx.rmx_sendpipe / 2);
		<span class="enscript-keyword">else</span>
			dosavessthresh = (i &lt; so-&gt;so_snd.sb_hiwat / 2);
		<span class="enscript-keyword">if</span> (((rt-&gt;rt_rmx.rmx_locks &amp; RTV_SSTHRESH) == 0 &amp;&amp;
		     i != 0 &amp;&amp; rt-&gt;rt_rmx.rmx_ssthresh != 0)
		    || dosavessthresh) {
			<span class="enscript-comment">/*
			 * convert the limit from user data bytes to
			 * packets then to packet data bytes.
			 */</span>
			i = (i + tp-&gt;t_maxseg / 2) / tp-&gt;t_maxseg;
			<span class="enscript-keyword">if</span> (i &lt; 2)
				i = 2;
			i *= (u_int32_t)(tp-&gt;t_maxseg +
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				      (isipv6 ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) +
					       <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcphdr) :
#<span class="enscript-reference">endif</span>
				       <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				       )
#<span class="enscript-reference">endif</span>
				      );
			<span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_ssthresh)
				rt-&gt;rt_rmx.rmx_ssthresh =
				    (rt-&gt;rt_rmx.rmx_ssthresh + i) / 2;
			<span class="enscript-keyword">else</span>
				rt-&gt;rt_rmx.rmx_ssthresh = i;
			tcpstat.tcps_cachedssthresh++;
		}
	}

	<span class="enscript-comment">/*
	 * Mark route for deletion if no information is cached.
	 */</span>
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; (so-&gt;so_flags &amp; SOF_OVERFLOW) &amp;&amp; tcp_lq_overflow) {
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_RTT) &amp;&amp;
		    rt-&gt;rt_rmx.rmx_rtt == 0) {
			rt-&gt;rt_flags |= RTF_DELCLONE;
		}
	}

<span class="enscript-reference">no_valid_rt</span>:
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_UNLOCK(rt);

	<span class="enscript-comment">/* free the reassembly queue, if any */</span>
	(<span class="enscript-type">void</span>) tcp_freeq(tp);
	<span class="enscript-keyword">if</span> (TCP_ECN_ENABLED(tp)) {
		<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_RECV_ECN_CE)
			tcpstat.tcps_ecn_conn_recv_ce++;
		<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; TE_RECV_ECN_ECE)
			tcpstat.tcps_ecn_conn_recv_ece++;
		<span class="enscript-keyword">if</span> (tp-&gt;ecn_flags &amp; (TE_RECV_ECN_CE | TE_RECV_ECN_ECE)) {
			<span class="enscript-keyword">if</span> (tp-&gt;t_stat.txretransmitbytes &gt; 0 ||
			    tp-&gt;t_stat.rxoutoforderbytes &gt; 0)
				tcpstat.tcps_ecn_conn_pl_ce++;
			<span class="enscript-keyword">else</span>
				tcpstat.tcps_ecn_conn_nopl_ce++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (tp-&gt;t_stat.txretransmitbytes &gt; 0 ||
			    tp-&gt;t_stat.rxoutoforderbytes &gt; 0)
				tcpstat.tcps_ecn_conn_plnoce++;
		}
	}

	tcp_free_sackholes(tp);
	<span class="enscript-keyword">if</span> (tp-&gt;t_bwmeas != NULL) {
		tcp_bwmeas_free(tp);
	}
	tcp_rxtseg_clean(tp);
	<span class="enscript-comment">/* Free the packet list */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_pktlist_head != NULL)
		m_freem_list(tp-&gt;t_pktlist_head);
	TCP_PKTLIST_CLEAR(tp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/* Clear MPTCP state */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_MPTCP_TRUE) ||
	    (so-&gt;so_flags &amp; SOF_MP_SUBFLOW)) {
		soevent(so, (SO_FILT_HINT_LOCKED | SO_FILT_HINT_DELETEOK));
	}
	tp-&gt;t_mpflags = 0;
	tp-&gt;t_mptcb = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER)
	    inp-&gt;inp_saved_ppcb = (caddr_t) tp;

	tp-&gt;t_state = TCPS_CLOSED;

	<span class="enscript-comment">/* Issue a wakeup before detach so that we don't miss
	 * a wakeup
	 */</span>
	sodisconnectwakeup(so);

	<span class="enscript-comment">/* 
	 * Clean up any LRO state 
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_flagsext &amp; TF_LRO_OFFLOADED) {
		tcp_lro_remove_state(inp-&gt;inp_laddr, inp-&gt;inp_faddr,
		    inp-&gt;inp_lport, inp-&gt;inp_fport);
		tp-&gt;t_flagsext &amp;= ~TF_LRO_OFFLOADED;
	}

	<span class="enscript-comment">/*
	 * If this is a socket that does not want to wakeup the device
	 * for it's traffic, the application might need to know that the
	 * socket is closed, send a notification.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_NOWAKEFROMSLEEP) &amp;&amp;
	    inp-&gt;inp_state != INPCB_STATE_DEAD &amp;&amp;
	    !(inp-&gt;inp_flags2 &amp; INP2_TIMEWAIT))
		socket_post_kev_msg_closed(so);

	<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cleanup != NULL) {
		CC_ALGO(tp)-&gt;cleanup(tp);
	}

	<span class="enscript-keyword">if</span> (tp-&gt;t_ccstate != NULL) {
		zfree(tcp_cc_zone, tp-&gt;t_ccstate);
		tp-&gt;t_ccstate = NULL;
	}
	tp-&gt;tcp_cc_index = TCP_CC_ALGO_NONE;

	<span class="enscript-comment">/* Can happen if we close the socket before receiving the third ACK */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_tfo_flags &amp; TFO_F_COOKIE_VALID)) {
		OSDecrementAtomic(&amp;tcp_tfo_halfcnt);

		<span class="enscript-comment">/* Panic if something has gone terribly wrong. */</span>
		VERIFY(tcp_tfo_halfcnt &gt;= 0);

		tp-&gt;t_tfo_flags &amp;= ~TFO_F_COOKIE_VALID;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (SOCK_CHECK_DOM(so, PF_INET6))
		in6_pcbdetach(inp);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	in_pcbdetach(inp);

	<span class="enscript-comment">/* Call soisdisconnected after detach because it might unlock the socket */</span>
	soisdisconnected(so);
	tcpstat.tcps_closed++;
	KERNEL_DEBUG(DBG_FNC_TCP_CLOSE | DBG_FUNC_END,
	    tcpstat.tcps_closed, 0, 0, 0, 0);
	<span class="enscript-keyword">return</span>(NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_freeq</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{

	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tseg_qent *q;
	<span class="enscript-type">int</span> rv = 0;

	<span class="enscript-keyword">while</span>((q = LIST_FIRST(&amp;tp-&gt;t_segq)) != NULL) {
		LIST_REMOVE(q, tqe_q);
		m_freem(q-&gt;tqe_m);
		zfree(tcp_reass_zone, q);
		rv = 1;
	}
	tp-&gt;t_reassqlen = 0;
	<span class="enscript-keyword">return</span> (rv);
}


<span class="enscript-comment">/*
 * Walk the tcpbs, if existing, and flush the reassembly queue,
 * if there is one when do_tcpdrain is enabled
 * Also defunct the extended background idle socket
 * Do it next time if the pcbinfo lock is in use
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_drain</span>()
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> tcpcb *tp;

	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(tcbinfo.ipi_lock)) 
		<span class="enscript-keyword">return</span>;

	LIST_FOREACH(inp, tcbinfo.ipi_listhead, inp_list) {
		<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) !=
			WNT_STOPUSING) {
			tcp_lock(inp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1)
				== WNT_STOPUSING) {
				<span class="enscript-comment">/* lost a race, try the next one */</span>
				tcp_unlock(inp-&gt;inp_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			} 
			tp = intotcpcb(inp);

			<span class="enscript-keyword">if</span> (do_tcpdrain)	
				tcp_freeq(tp);

			so_drain_extended_bk_idle(inp-&gt;inp_socket);

			tcp_unlock(inp-&gt;inp_socket, 1, 0);
		}
	}
	lck_rw_done(tcbinfo.ipi_lock);

}

<span class="enscript-comment">/*
 * Notify a tcp user of an asynchronous error;
 * store error as soft error, but wake up user
 * (for now, won't do anything until can select for soft error).
 *
 * Do not wake up user since there currently is no mechanism for
 * reporting soft errors (yet - a kqueue filter may be added).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_notify</span>(inp, error)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;
{
	<span class="enscript-type">struct</span> tcpcb *tp;

	<span class="enscript-keyword">if</span> (inp == NULL || (inp-&gt;inp_state == INPCB_STATE_DEAD)) 
		<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* pcb is gone already */</span>

	tp = (<span class="enscript-type">struct</span> tcpcb *)inp-&gt;inp_ppcb;

	<span class="enscript-comment">/*
	 * Ignore some errors if we are hooked up.
	 * If connection hasn't completed, has retransmitted several times,
	 * and receives a second error, give up now.  This is better
	 * than waiting a long time to establish a connection that
	 * can never complete.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_state == TCPS_ESTABLISHED &amp;&amp;
	     (error == EHOSTUNREACH || error == ENETUNREACH ||
	      error == EHOSTDOWN)) {
		<span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tp-&gt;t_state &lt; TCPS_ESTABLISHED &amp;&amp; tp-&gt;t_rxtshift &gt; 3 &amp;&amp;
	    tp-&gt;t_softerror)
		tcp_drop(tp, error);
	<span class="enscript-keyword">else</span>
		tp-&gt;t_softerror = error;
#<span class="enscript-reference">if</span> 0
	wakeup((caddr_t) &amp;so-&gt;so_timeo);
	sorwakeup(so);
	sowwakeup(so);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">struct</span> bwmeas*
<span class="enscript-function-name">tcp_bwmeas_alloc</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> bwmeas *elm;
	elm = zalloc(tcp_bwmeas_zone);
	<span class="enscript-keyword">if</span> (elm == NULL)
		<span class="enscript-keyword">return</span>(elm);

	bzero(elm, bwmeas_elm_size);
	elm-&gt;bw_minsizepkts = TCP_BWMEAS_BURST_MINSIZE;
	elm-&gt;bw_maxsizepkts = TCP_BWMEAS_BURST_MAXSIZE;
	elm-&gt;bw_minsize = elm-&gt;bw_minsizepkts * tp-&gt;t_maxseg;
	elm-&gt;bw_maxsize = elm-&gt;bw_maxsizepkts * tp-&gt;t_maxseg;
	<span class="enscript-keyword">return</span>(elm);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_bwmeas_free</span>(<span class="enscript-type">struct</span> tcpcb* tp)
{
	zfree(tcp_bwmeas_zone, tp-&gt;t_bwmeas);
	tp-&gt;t_bwmeas = NULL;
	tp-&gt;t_flagsext &amp;= ~(TF_MEASURESNDBW);
}

<span class="enscript-comment">/*
 * tcpcb_to_otcpcb copies specific bits of a tcpcb to a otcpcb format.
 * The otcpcb data structure is passed to user space and must not change.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcpcb_to_otcpcb</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> otcpcb *otp)
{
	otp-&gt;t_segq = (uint32_t)VM_KERNEL_ADDRPERM(tp-&gt;t_segq.lh_first);
	otp-&gt;t_dupacks = tp-&gt;t_dupacks;
	otp-&gt;t_timer[TCPT_REXMT_EXT] = tp-&gt;t_timer[TCPT_REXMT];
	otp-&gt;t_timer[TCPT_PERSIST_EXT] = tp-&gt;t_timer[TCPT_PERSIST];
	otp-&gt;t_timer[TCPT_KEEP_EXT] = tp-&gt;t_timer[TCPT_KEEP];
	otp-&gt;t_timer[TCPT_2MSL_EXT] = tp-&gt;t_timer[TCPT_2MSL];
	otp-&gt;t_inpcb = (_TCPCB_PTR(<span class="enscript-type">struct</span> inpcb *))VM_KERNEL_ADDRPERM(tp-&gt;t_inpcb);
	otp-&gt;t_state = tp-&gt;t_state;
	otp-&gt;t_flags = tp-&gt;t_flags;
	otp-&gt;t_force = (tp-&gt;t_flagsext &amp; TF_FORCE) ? 1 : 0;
	otp-&gt;snd_una = tp-&gt;snd_una;
	otp-&gt;snd_max = tp-&gt;snd_max;
	otp-&gt;snd_nxt = tp-&gt;snd_nxt;
	otp-&gt;snd_up = tp-&gt;snd_up;
	otp-&gt;snd_wl1 = tp-&gt;snd_wl1;
	otp-&gt;snd_wl2 = tp-&gt;snd_wl2;
	otp-&gt;iss = tp-&gt;iss;
	otp-&gt;irs = tp-&gt;irs;
	otp-&gt;rcv_nxt = tp-&gt;rcv_nxt;
	otp-&gt;rcv_adv = tp-&gt;rcv_adv;
	otp-&gt;rcv_wnd = tp-&gt;rcv_wnd;
	otp-&gt;rcv_up = tp-&gt;rcv_up;
	otp-&gt;snd_wnd = tp-&gt;snd_wnd;
	otp-&gt;snd_cwnd = tp-&gt;snd_cwnd;
	otp-&gt;snd_ssthresh = tp-&gt;snd_ssthresh;
	otp-&gt;t_maxopd = tp-&gt;t_maxopd;
	otp-&gt;t_rcvtime = tp-&gt;t_rcvtime;
	otp-&gt;t_starttime = tp-&gt;t_starttime;
	otp-&gt;t_rtttime = tp-&gt;t_rtttime;
	otp-&gt;t_rtseq = tp-&gt;t_rtseq;
	otp-&gt;t_rxtcur = tp-&gt;t_rxtcur;
	otp-&gt;t_maxseg = tp-&gt;t_maxseg;
	otp-&gt;t_srtt = tp-&gt;t_srtt;
	otp-&gt;t_rttvar = tp-&gt;t_rttvar;
	otp-&gt;t_rxtshift = tp-&gt;t_rxtshift;
	otp-&gt;t_rttmin = tp-&gt;t_rttmin;
	otp-&gt;t_rttupdated = tp-&gt;t_rttupdated;
	otp-&gt;max_sndwnd = tp-&gt;max_sndwnd;
	otp-&gt;t_softerror = tp-&gt;t_softerror;
	otp-&gt;t_oobflags = tp-&gt;t_oobflags;
	otp-&gt;t_iobc = tp-&gt;t_iobc;
	otp-&gt;snd_scale = tp-&gt;snd_scale;
	otp-&gt;rcv_scale = tp-&gt;rcv_scale;
	otp-&gt;request_r_scale = tp-&gt;request_r_scale;
	otp-&gt;requested_s_scale = tp-&gt;requested_s_scale;
	otp-&gt;ts_recent = tp-&gt;ts_recent;
	otp-&gt;ts_recent_age = tp-&gt;ts_recent_age;
	otp-&gt;last_ack_sent = tp-&gt;last_ack_sent;
	otp-&gt;cc_send = tp-&gt;cc_send;
	otp-&gt;cc_recv = tp-&gt;cc_recv;
	otp-&gt;snd_recover = tp-&gt;snd_recover;
	otp-&gt;snd_cwnd_prev = tp-&gt;snd_cwnd_prev;
	otp-&gt;snd_ssthresh_prev = tp-&gt;snd_ssthresh_prev;
	otp-&gt;t_badrxtwin = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
tcp_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i = 0, n;
	<span class="enscript-type">struct</span> inpcb *inp, **inp_list;
	<span class="enscript-type">struct</span> tcpcb *tp;
	inp_gen_t gencnt;
	<span class="enscript-type">struct</span> xinpgen xig;

	<span class="enscript-comment">/*
	 * The process of preparing the TCB list is too time-consuming and
	 * resource-intensive to repeat twice on every request.
	 */</span>
	lck_rw_lock_shared(tcbinfo.ipi_lock);
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		n = tcbinfo.ipi_count;
		req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> xig)
			+ (n + n/8) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xtcpcb);
		lck_rw_done(tcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		lck_rw_done(tcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">/*
	 * OK, now we're committed to doing something.
	 */</span>
	gencnt = tcbinfo.ipi_gencnt;
	n = tcbinfo.ipi_count;

	bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
	xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
	xig.xig_count = n;
	xig.xig_gen = gencnt;
	xig.xig_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
	<span class="enscript-keyword">if</span> (error) {
		lck_rw_done(tcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		lck_rw_done(tcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> 0; 
	}

	inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> *inp_list, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (inp_list == 0) {
		lck_rw_done(tcbinfo.ipi_lock);
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	
	LIST_FOREACH(inp, tcbinfo.ipi_listhead, inp_list) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; 
			inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
		<span class="enscript-keyword">if</span> (i &gt;= n) <span class="enscript-keyword">break</span>;
	}

	TAILQ_FOREACH(tp, &amp;tcp_tw_tailq, t_twentry) {
		inp = tp-&gt;t_inpcb;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; 
			inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
		<span class="enscript-keyword">if</span> (i &gt;= n) <span class="enscript-keyword">break</span>;
	}

	n = i;

	error = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
		inp = inp_list[i];
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; 
			inp-&gt;inp_state != INPCB_STATE_DEAD) {
			<span class="enscript-type">struct</span> xtcpcb xt;
			caddr_t inp_ppcb;

			bzero(&amp;xt, <span class="enscript-keyword">sizeof</span>(xt));
			xt.xt_len = <span class="enscript-keyword">sizeof</span> xt;
			<span class="enscript-comment">/* XXX should avoid extra copy */</span>
			inpcb_to_compat(inp, &amp;xt.xt_inp);
			inp_ppcb = inp-&gt;inp_ppcb;
			<span class="enscript-keyword">if</span> (inp_ppcb != NULL) {
				tcpcb_to_otcpcb(
				    (<span class="enscript-type">struct</span> tcpcb *)(<span class="enscript-type">void</span> *)inp_ppcb,
				    &amp;xt.xt_tp);
			} <span class="enscript-keyword">else</span> {
				bzero((<span class="enscript-type">char</span> *) &amp;xt.xt_tp, <span class="enscript-keyword">sizeof</span> xt.xt_tp);
			}
			<span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
				sotoxsocket(inp-&gt;inp_socket, &amp;xt.xt_socket);
			error = SYSCTL_OUT(req, &amp;xt, <span class="enscript-keyword">sizeof</span> xt);
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
		xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
		xig.xig_gen = tcbinfo.ipi_gencnt;
		xig.xig_sogen = so_gencnt;
		xig.xig_count = tcbinfo.ipi_count;
		error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
	}
	FREE(inp_list, M_TEMP);
	lck_rw_done(tcbinfo.ipi_lock);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, TCPCTL_PCBLIST, pcblist,
	    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	    tcp_pcblist, <span class="enscript-string">&quot;S,xtcpcb&quot;</span>, <span class="enscript-string">&quot;List of active TCP connections&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcpcb_to_xtcpcb64</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> xtcpcb64 *otp)
{
        otp-&gt;t_segq = (uint32_t)VM_KERNEL_ADDRPERM(tp-&gt;t_segq.lh_first);
        otp-&gt;t_dupacks = tp-&gt;t_dupacks;
	otp-&gt;t_timer[TCPT_REXMT_EXT] = tp-&gt;t_timer[TCPT_REXMT];
	otp-&gt;t_timer[TCPT_PERSIST_EXT] = tp-&gt;t_timer[TCPT_PERSIST];
	otp-&gt;t_timer[TCPT_KEEP_EXT] = tp-&gt;t_timer[TCPT_KEEP];
	otp-&gt;t_timer[TCPT_2MSL_EXT] = tp-&gt;t_timer[TCPT_2MSL];
        otp-&gt;t_state = tp-&gt;t_state;
        otp-&gt;t_flags = tp-&gt;t_flags;
        otp-&gt;t_force = (tp-&gt;t_flagsext &amp; TF_FORCE) ? 1 : 0;
        otp-&gt;snd_una = tp-&gt;snd_una;
        otp-&gt;snd_max = tp-&gt;snd_max;
        otp-&gt;snd_nxt = tp-&gt;snd_nxt;
        otp-&gt;snd_up = tp-&gt;snd_up;
        otp-&gt;snd_wl1 = tp-&gt;snd_wl1;
        otp-&gt;snd_wl2 = tp-&gt;snd_wl2;
        otp-&gt;iss = tp-&gt;iss;
        otp-&gt;irs = tp-&gt;irs;
        otp-&gt;rcv_nxt = tp-&gt;rcv_nxt;
        otp-&gt;rcv_adv = tp-&gt;rcv_adv;
        otp-&gt;rcv_wnd = tp-&gt;rcv_wnd;
        otp-&gt;rcv_up = tp-&gt;rcv_up;
        otp-&gt;snd_wnd = tp-&gt;snd_wnd;
        otp-&gt;snd_cwnd = tp-&gt;snd_cwnd;
        otp-&gt;snd_ssthresh = tp-&gt;snd_ssthresh;
        otp-&gt;t_maxopd = tp-&gt;t_maxopd;
        otp-&gt;t_rcvtime = tp-&gt;t_rcvtime;
        otp-&gt;t_starttime = tp-&gt;t_starttime;
        otp-&gt;t_rtttime = tp-&gt;t_rtttime;
        otp-&gt;t_rtseq = tp-&gt;t_rtseq;
        otp-&gt;t_rxtcur = tp-&gt;t_rxtcur;
        otp-&gt;t_maxseg = tp-&gt;t_maxseg;
        otp-&gt;t_srtt = tp-&gt;t_srtt;
        otp-&gt;t_rttvar = tp-&gt;t_rttvar;
        otp-&gt;t_rxtshift = tp-&gt;t_rxtshift;
        otp-&gt;t_rttmin = tp-&gt;t_rttmin;
        otp-&gt;t_rttupdated = tp-&gt;t_rttupdated;
        otp-&gt;max_sndwnd = tp-&gt;max_sndwnd;
        otp-&gt;t_softerror = tp-&gt;t_softerror;
        otp-&gt;t_oobflags = tp-&gt;t_oobflags;
        otp-&gt;t_iobc = tp-&gt;t_iobc;
        otp-&gt;snd_scale = tp-&gt;snd_scale;
        otp-&gt;rcv_scale = tp-&gt;rcv_scale;
        otp-&gt;request_r_scale = tp-&gt;request_r_scale;
        otp-&gt;requested_s_scale = tp-&gt;requested_s_scale;
        otp-&gt;ts_recent = tp-&gt;ts_recent;
        otp-&gt;ts_recent_age = tp-&gt;ts_recent_age;
        otp-&gt;last_ack_sent = tp-&gt;last_ack_sent;
        otp-&gt;cc_send = tp-&gt;cc_send;
        otp-&gt;cc_recv = tp-&gt;cc_recv;
        otp-&gt;snd_recover = tp-&gt;snd_recover;
        otp-&gt;snd_cwnd_prev = tp-&gt;snd_cwnd_prev;
        otp-&gt;snd_ssthresh_prev = tp-&gt;snd_ssthresh_prev;
        otp-&gt;t_badrxtwin = 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
tcp_pcblist64 SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
        <span class="enscript-type">int</span> error, i = 0, n;
        <span class="enscript-type">struct</span> inpcb *inp, **inp_list;
	<span class="enscript-type">struct</span> tcpcb *tp;
        inp_gen_t gencnt;
        <span class="enscript-type">struct</span> xinpgen xig;

        <span class="enscript-comment">/*
         * The process of preparing the TCB list is too time-consuming and
         * resource-intensive to repeat twice on every request.
         */</span>
        lck_rw_lock_shared(tcbinfo.ipi_lock);
        <span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
                n = tcbinfo.ipi_count;
                req-&gt;oldidx = 2 * (<span class="enscript-keyword">sizeof</span> xig)
                        + (n + n/8) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xtcpcb64);
                lck_rw_done(tcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> 0;
        }

        <span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
                lck_rw_done(tcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> EPERM;
        }

        <span class="enscript-comment">/*
         * OK, now we're committed to doing something.
         */</span>
        gencnt = tcbinfo.ipi_gencnt;
        n = tcbinfo.ipi_count;

        bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
        xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
        xig.xig_count = n;
        xig.xig_gen = gencnt;
        xig.xig_sogen = so_gencnt;
        error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
        <span class="enscript-keyword">if</span> (error) {
                lck_rw_done(tcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> error;
        }
        <span class="enscript-comment">/*
         * We are done if there is no pcb
         */</span>
        <span class="enscript-keyword">if</span> (n == 0) {
                lck_rw_done(tcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> 0;
        }

        inp_list = _MALLOC(n * <span class="enscript-keyword">sizeof</span> *inp_list, M_TEMP, M_WAITOK);
        <span class="enscript-keyword">if</span> (inp_list == 0) {
                lck_rw_done(tcbinfo.ipi_lock);
                <span class="enscript-keyword">return</span> ENOMEM;
        }

	LIST_FOREACH(inp, tcbinfo.ipi_listhead, inp_list) {
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; 
			inp-&gt;inp_state != INPCB_STATE_DEAD)
                        inp_list[i++] = inp;
		<span class="enscript-keyword">if</span> (i &gt;= n) <span class="enscript-keyword">break</span>;
        }

	TAILQ_FOREACH(tp, &amp;tcp_tw_tailq, t_twentry) {
		inp = tp-&gt;t_inpcb;
		<span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; 
			inp-&gt;inp_state != INPCB_STATE_DEAD)
			inp_list[i++] = inp;
		<span class="enscript-keyword">if</span> (i &gt;= n) <span class="enscript-keyword">break</span>;
        }

        n = i;

        error = 0;
        <span class="enscript-keyword">for</span> (i = 0; i &lt; n; i++) {
                inp = inp_list[i];
                <span class="enscript-keyword">if</span> (inp-&gt;inp_gencnt &lt;= gencnt &amp;&amp; inp-&gt;inp_state != INPCB_STATE_DEAD) {
					<span class="enscript-type">struct</span> xtcpcb64 xt;
					
					bzero(&amp;xt, <span class="enscript-keyword">sizeof</span>(xt));
					xt.xt_len = <span class="enscript-keyword">sizeof</span> xt;
					inpcb_to_xinpcb64(inp, &amp;xt.xt_inpcb);
					xt.xt_inpcb.inp_ppcb = (uint64_t)VM_KERNEL_ADDRPERM(inp-&gt;inp_ppcb);
					<span class="enscript-keyword">if</span> (inp-&gt;inp_ppcb != NULL)
						tcpcb_to_xtcpcb64((<span class="enscript-type">struct</span> tcpcb *)inp-&gt;inp_ppcb, &amp;xt);
					<span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
						sotoxsocket64(inp-&gt;inp_socket, &amp;xt.xt_inpcb.xi_socket);
					error = SYSCTL_OUT(req, &amp;xt, <span class="enscript-keyword">sizeof</span> xt);
                }
        }
        <span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/*
			 * Give the user an updated idea of our state.
			 * If the generation differs from what we told
			 * her before, she knows that something happened
			 * while we were processing this request, and it
			 * might be necessary to retry.
			 */</span>
			bzero(&amp;xig, <span class="enscript-keyword">sizeof</span>(xig));
			xig.xig_len = <span class="enscript-keyword">sizeof</span> xig;
			xig.xig_gen = tcbinfo.ipi_gencnt;
			xig.xig_sogen = so_gencnt;
			xig.xig_count = tcbinfo.ipi_count;
			error = SYSCTL_OUT(req, &amp;xig, <span class="enscript-keyword">sizeof</span> xig);
        }
        FREE(inp_list, M_TEMP);
        lck_rw_done(tcbinfo.ipi_lock);
        <span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, pcblist64,
	    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
            tcp_pcblist64, <span class="enscript-string">&quot;S,xtcpcb64&quot;</span>, <span class="enscript-string">&quot;List of active TCP connections&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
tcp_pcblist_n SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;
	
	error = get_pcblist_n(IPPROTO_TCP, req, &amp;tcbinfo);
	
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_tcp, OID_AUTO, pcblist_n,
	    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
            tcp_pcblist_n, <span class="enscript-string">&quot;S,xtcpcb_n&quot;</span>, <span class="enscript-string">&quot;List of active TCP connections&quot;</span>);


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_get_ports_used</span>(uint32_t ifindex, <span class="enscript-type">int</span> protocol, uint32_t flags,
    bitstr_t *bitfield)
{
	inpcb_get_ports_used(ifindex, protocol, flags, 
		bitfield, &amp;tcbinfo);
}

__private_extern__ uint32_t
<span class="enscript-function-name">tcp_count_opportunistic</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex, u_int32_t flags)
{
	<span class="enscript-keyword">return</span> inpcb_count_opportunistic(ifindex, &amp;tcbinfo, flags);
}

__private_extern__ uint32_t
<span class="enscript-function-name">tcp_find_anypcb_byaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-keyword">return</span> inpcb_find_anypcb_byaddr(ifa, &amp;tcbinfo);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_ctlinput</span>(cmd, sa, vip)
	<span class="enscript-type">int</span> cmd;
	<span class="enscript-type">struct</span> sockaddr *sa;
	<span class="enscript-type">void</span> *vip;
{
	tcp_seq icmp_tcp_seq;
	<span class="enscript-type">struct</span> ip *ip = vip;
	<span class="enscript-type">struct</span> in_addr faddr;
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> tcpcb *tp;

	<span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>) = tcp_notify;

	faddr = ((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)sa)-&gt;sin_addr;
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_INET || faddr.s_addr == INADDR_ANY)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cmd &gt;= PRC_NCMDS)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (cmd == PRC_MSGSIZE)
		notify = tcp_mtudisc;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (icmp_may_rst &amp;&amp; (cmd == PRC_UNREACH_ADMIN_PROHIB ||
		cmd == PRC_UNREACH_PORT) &amp;&amp; ip)
		notify = tcp_drop_syn_sent;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PRC_IS_REDIRECT(cmd)) {
		ip = 0;
		notify = in_rtchange;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == PRC_HOSTDEAD)
		ip = 0;
	<span class="enscript-comment">/* Source quench is deprecated */</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == PRC_QUENCH) 
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inetctlerrmap[cmd] == 0)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (ip) {
		<span class="enscript-type">struct</span> tcphdr th;
		<span class="enscript-type">struct</span> icmp *icp;

		icp = (<span class="enscript-type">struct</span> icmp *)(<span class="enscript-type">void</span> *)
		    ((caddr_t)ip - offsetof(<span class="enscript-type">struct</span> icmp, icmp_ip));
		bcopy(((caddr_t)ip + (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2)),
		    &amp;th, <span class="enscript-keyword">sizeof</span> (th));
		inp = in_pcblookup_hash(&amp;tcbinfo, faddr, th.th_dport,
		    ip-&gt;ip_src, th.th_sport, 0, NULL);
		<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; inp-&gt;inp_socket != NULL) {
			tcp_lock(inp-&gt;inp_socket, 1, 0);
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_RELEASE, 1) == WNT_STOPUSING) {
				tcp_unlock(inp-&gt;inp_socket, 1, 0);
				<span class="enscript-keyword">return</span>;
			}
			icmp_tcp_seq = htonl(th.th_seq);
			tp = intotcpcb(inp);
			<span class="enscript-keyword">if</span> (SEQ_GEQ(icmp_tcp_seq, tp-&gt;snd_una) &amp;&amp;
			    SEQ_LT(icmp_tcp_seq, tp-&gt;snd_max)) {
				<span class="enscript-keyword">if</span> (cmd == PRC_MSGSIZE) {

					<span class="enscript-comment">/*
				  	 * MTU discovery:
				 	 * If we got a needfrag and there is a host route to the
				 	 * original destination, and the MTU is not locked, then
				 	 * set the MTU in the route to the suggested new value
				 	 * (if given) and then notify as usual.  The ULPs will
				 	 * notice that the MTU has changed and adapt accordingly.
				 	 * If no new MTU was suggested, then we guess a new one
				 	 * less than the current value.  If the new MTU is 
				 	 * unreasonably small (defined by sysctl tcp_minmss), then
				 	 * we reset the MTU to the interface value and enable the
				 	 * lock bit, indicating that we are no longer doing MTU
				 	 * discovery.
				 	 */</span>
					<span class="enscript-type">struct</span> rtentry *rt;
					<span class="enscript-type">int</span> mtu;
					<span class="enscript-type">struct</span> sockaddr_in icmpsrc = { <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in), AF_INET, 
										0 , { 0 }, { 0,0,0,0,0,0,0,0 } };
					icmpsrc.sin_addr = icp-&gt;icmp_ip.ip_dst;

					rt = rtalloc1((<span class="enscript-type">struct</span> sockaddr *)&amp;icmpsrc, 0,
					    RTF_CLONING | RTF_PRCLONING);
					<span class="enscript-keyword">if</span> (rt != NULL) {
						RT_LOCK(rt);
						<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_HOST) &amp;&amp;
						    !(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU)) {
							mtu = ntohs(icp-&gt;icmp_nextmtu);
							<span class="enscript-keyword">if</span> (!mtu)
								mtu = ip_next_mtu(rt-&gt;rt_rmx.
								    rmx_mtu, 1);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_MTUDISC</span>
							printf(<span class="enscript-string">&quot;MTU for %s reduced to %d\n&quot;</span>,
							    inet_ntop(AF_INET,
							    &amp;icmpsrc.sin_addr, ipv4str,
							    <span class="enscript-keyword">sizeof</span> (ipv4str)), mtu);
#<span class="enscript-reference">endif</span>
							<span class="enscript-keyword">if</span> (mtu &lt; max(296, (tcp_minmss +
							    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> tcpiphdr)))) {
								<span class="enscript-comment">/* rt-&gt;rt_rmx.rmx_mtu =
									rt-&gt;rt_ifp-&gt;if_mtu; */</span>
								rt-&gt;rt_rmx.rmx_locks |= RTV_MTU;
							} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_rmx.rmx_mtu &gt; mtu) {
								rt-&gt;rt_rmx.rmx_mtu = mtu;
							}
						}
						RT_UNLOCK(rt);
						rtfree(rt);
					}
				}

				(*notify)(inp, inetctlerrmap[cmd]);
			}
			tcp_unlock(inp-&gt;inp_socket, 1, 0);
		}
	} <span class="enscript-keyword">else</span>
		in_pcbnotifyall(&amp;tcbinfo, faddr, inetctlerrmap[cmd], notify);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp6_ctlinput</span>(cmd, sa, d)
	<span class="enscript-type">int</span> cmd;
	<span class="enscript-type">struct</span> sockaddr *sa;
	<span class="enscript-type">void</span> *d;
{
	<span class="enscript-type">struct</span> tcphdr th;
	<span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>) = tcp_notify;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip6ctlparam *ip6cp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 *sa6_src = NULL;
	<span class="enscript-type">int</span> off;
	<span class="enscript-type">struct</span> tcp_portonly {
		u_int16_t th_sport;
		u_int16_t th_dport;
	} *thp;

	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_INET6 ||
	    sa-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cmd &gt;= PRC_NCMDS)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (cmd == PRC_MSGSIZE)
		notify = tcp_mtudisc;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!PRC_IS_REDIRECT(cmd) &amp;&amp; (inet6ctlerrmap[cmd] == 0))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/* Source quench is deprecated */</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == PRC_QUENCH) 
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* if the parameter is from icmp6, decode it. */</span>
	<span class="enscript-keyword">if</span> (d != NULL) {
		ip6cp = (<span class="enscript-type">struct</span> ip6ctlparam *)d;
		m = ip6cp-&gt;ip6c_m;
		ip6 = ip6cp-&gt;ip6c_ip6;
		off = ip6cp-&gt;ip6c_off;
		sa6_src = ip6cp-&gt;ip6c_src;
	} <span class="enscript-keyword">else</span> {
		m = NULL;
		ip6 = NULL;
		off = 0;	<span class="enscript-comment">/* fool gcc */</span>
		sa6_src = &amp;sa6_any;
	}

	<span class="enscript-keyword">if</span> (ip6) {
		<span class="enscript-comment">/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */</span>

		<span class="enscript-comment">/* check if we can safely examine src and dst ports */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span>(*thp))
			<span class="enscript-keyword">return</span>;

		bzero(&amp;th, <span class="enscript-keyword">sizeof</span>(th));
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(*thp), (caddr_t)&amp;th);

		in6_pcbnotify(&amp;tcbinfo, sa, th.th_dport,
		    (<span class="enscript-type">struct</span> sockaddr *)ip6cp-&gt;ip6c_src,
		    th.th_sport, cmd, NULL, notify);
	} <span class="enscript-keyword">else</span> {
		in6_pcbnotify(&amp;tcbinfo, sa, 0,
		    (<span class="enscript-type">struct</span> sockaddr *)(size_t)sa6_src, 0, cmd, NULL, notify);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>


<span class="enscript-comment">/*
 * Following is where TCP initial sequence number generation occurs.
 *
 * There are two places where we must use initial sequence numbers:
 * 1.  In SYN-ACK packets.
 * 2.  In SYN packets.
 *
 * The ISNs in SYN-ACK packets have no monotonicity requirement, 
 * and should be as unpredictable as possible to avoid the possibility
 * of spoofing and/or connection hijacking.  To satisfy this
 * requirement, SYN-ACK ISNs are generated via the arc4random()
 * function.  If exact RFC 1948 compliance is requested via sysctl,
 * these ISNs will be generated just like those in SYN packets.
 *
 * The ISNs in SYN packets must be monotonic; TIME_WAIT recycling
 * depends on this property.  In addition, these ISNs should be
 * unguessable so as to prevent connection hijacking.  To satisfy
 * the requirements of this situation, the algorithm outlined in
 * RFC 1948 is used to generate sequence numbers.
 *
 * For more information on the theory of operation, please see
 * RFC 1948.
 *
 * Implementation details:
 *
 * Time is based off the system timer, and is corrected so that it
 * increases by one megabyte per second.  This allows for proper
 * recycling on high speed LANs while still leaving over an hour
 * before rollover.
 *
 * Two sysctls control the generation of ISNs:
 *
 * net.inet.tcp.isn_reseed_interval controls the number of seconds
 * between seeding of isn_secret.  This is normally set to zero,
 * as reseeding should not be necessary.
 *
 * net.inet.tcp.strict_rfc1948 controls whether RFC 1948 is followed
 * strictly.  When strict compliance is requested, reseeding is
 * disabled and SYN-ACKs will be generated in the same manner as
 * SYNs.  Strict mode is disabled by default.
 *
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ISN_BYTES_PER_SECOND</span> 1048576

tcp_seq
<span class="enscript-function-name">tcp_new_isn</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{
	u_int32_t md5_buffer[4];
	tcp_seq new_isn;
	<span class="enscript-type">struct</span> timeval timenow;
	u_char isn_secret[32];
	<span class="enscript-type">int</span> isn_last_reseed = 0;
	MD5_CTX isn_ctx;

	<span class="enscript-comment">/* Use arc4random for SYN-ACKs when not in exact RFC1948 mode. */</span>
	<span class="enscript-keyword">if</span> (((tp-&gt;t_state == TCPS_LISTEN) || (tp-&gt;t_state == TCPS_TIME_WAIT))
	   &amp;&amp; tcp_strict_rfc1948 == 0)
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
		<span class="enscript-keyword">return</span> RandomULong();
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">return</span> arc4random();
#<span class="enscript-reference">endif</span>
	getmicrotime(&amp;timenow);

	<span class="enscript-comment">/* Seed if this is the first use, reseed if requested. */</span>
	<span class="enscript-keyword">if</span> ((isn_last_reseed == 0) ||
	    ((tcp_strict_rfc1948 == 0) &amp;&amp; (tcp_isn_reseed_interval &gt; 0) &amp;&amp;
	     (((u_int)isn_last_reseed + (u_int)tcp_isn_reseed_interval*hz)
		&lt; (u_int)timenow.tv_sec))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
		read_random(&amp;isn_secret, <span class="enscript-keyword">sizeof</span>(isn_secret));
#<span class="enscript-reference">else</span>
		read_random_unlimited(&amp;isn_secret, <span class="enscript-keyword">sizeof</span>(isn_secret));
#<span class="enscript-reference">endif</span>
		isn_last_reseed = timenow.tv_sec;
	}
		
	<span class="enscript-comment">/* Compute the md5 hash and return the ISN. */</span>
	MD5Init(&amp;isn_ctx);
	MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;inp_fport, <span class="enscript-keyword">sizeof</span>(u_short));
	MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;inp_lport, <span class="enscript-keyword">sizeof</span>(u_short));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_inpcb-&gt;inp_vflag &amp; INP_IPV6) != 0) {
		MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;in6p_faddr,
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;in6p_laddr,
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;inp_faddr,
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
		MD5Update(&amp;isn_ctx, (u_char *) &amp;tp-&gt;t_inpcb-&gt;inp_laddr,
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
	}
	MD5Update(&amp;isn_ctx, (u_char *) &amp;isn_secret, <span class="enscript-keyword">sizeof</span>(isn_secret));
	MD5Final((u_char *) &amp;md5_buffer, &amp;isn_ctx);
	new_isn = (tcp_seq) md5_buffer[0];
	new_isn += timenow.tv_sec * (ISN_BYTES_PER_SECOND / hz);
	<span class="enscript-keyword">return</span> new_isn;
}


<span class="enscript-comment">/*
 * When a specific ICMP unreachable message is received and the
 * connection state is SYN-SENT, drop the connection.  This behavior
 * is controlled by the icmp_may_rst sysctl.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_drop_syn_sent</span>(inp, errno)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> errno;
{
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(inp);

	<span class="enscript-keyword">if</span> (tp &amp;&amp; tp-&gt;t_state == TCPS_SYN_SENT)
		tcp_drop(tp, errno);
}

<span class="enscript-comment">/*
 * When `need fragmentation' ICMP is received, update our idea of the MSS
 * based on the new value in the route.  Also nudge TCP to send something,
 * since we know the packet we just sent was dropped.
 * This duplicates some code in the tcp_mss() function in tcp_input.c.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_mtudisc</span>(
	<span class="enscript-type">struct</span> inpcb *inp,
	__unused <span class="enscript-type">int</span> errno
)
{
	<span class="enscript-type">struct</span> tcpcb *tp = intotcpcb(inp);
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> rmxp_tao *taop;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">int</span> offered;
	<span class="enscript-type">int</span> mss;
	u_int32_t mtu;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">int</span> isipv6 = (tp-&gt;t_inpcb-&gt;inp_vflag &amp; INP_IPV6) != 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	<span class="enscript-keyword">if</span> (tp) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> (isipv6)
			rt = tcp_rtlookup6(inp, IFSCOPE_NONE);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		rt = tcp_rtlookup(inp, IFSCOPE_NONE);
		<span class="enscript-keyword">if</span> (!rt || !rt-&gt;rt_rmx.rmx_mtu) {
			tp-&gt;t_maxopd = tp-&gt;t_maxseg =
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
				isipv6 ? tcp_v6mssdflt :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
				tcp_mssdflt;

			<span class="enscript-comment">/* Route locked during lookup above */</span>
			<span class="enscript-keyword">if</span> (rt != NULL)
				RT_UNLOCK(rt);
			<span class="enscript-keyword">return</span>;
		}
		taop = rmx_taop(rt-&gt;rt_rmx);
		offered = taop-&gt;tao_mssopt;
		mtu = rt-&gt;rt_rmx.rmx_mtu;

		<span class="enscript-comment">/* Route locked during lookup above */</span>
		RT_UNLOCK(rt);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-comment">// Adjust MTU if necessary.
</span>		mtu = necp_socket_get_effective_mtu(inp, mtu);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

		mss = mtu -
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			(isipv6 ?
			 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr) :
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcpiphdr)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			 )
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
			;

		<span class="enscript-keyword">if</span> (offered)
			mss = min(mss, offered);
		<span class="enscript-comment">/*
		 * XXX - The above conditional probably violates the TCP
		 * spec.  The problem is that, since we don't know the
		 * other end's MSS, we are supposed to use a conservative
		 * default.  But, if we do that, then MTU discovery will
		 * never actually take place, because the conservative
		 * default is much less than the MTUs typically seen
		 * on the Internet today.  For the moment, we'll sweep
		 * this under the carpet.
		 *
		 * The conservative default might not actually be a problem
		 * if the only case this occurs is when sending an initial
		 * SYN with options and data to a host we've never talked
		 * to before.  Then, they will reply with an MSS value which
		 * will get recorded and the new parameters should get
		 * recomputed.  For Further Study.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;t_maxopd &lt;= mss)
			<span class="enscript-keyword">return</span>;
		tp-&gt;t_maxopd = mss;

		<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &amp;&amp;
		    (tp-&gt;t_flags &amp; TF_RCVD_TSTMP) == TF_RCVD_TSTMP)
			mss -= TCPOLEN_TSTAMP_APPA;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		mss -= mptcp_adj_mss(tp, TRUE);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_hiwat &lt; mss)
			mss = so-&gt;so_snd.sb_hiwat;

		tp-&gt;t_maxseg = mss;

		<span class="enscript-comment">/*
		 * Reset the slow-start flight size as it may depends on the new MSS
		 */</span>
		<span class="enscript-keyword">if</span> (CC_ALGO(tp)-&gt;cwnd_init != NULL)
			CC_ALGO(tp)-&gt;cwnd_init(tp);
		tcpstat.tcps_mturesent++;
		tp-&gt;t_rtttime = 0;
		tp-&gt;snd_nxt = tp-&gt;snd_una;
		tcp_output(tp);
	}
}

<span class="enscript-comment">/*
 * Look-up the routing entry to the peer of this inpcb.  If no route
 * is found and it cannot be allocated the return NULL.  This routine
 * is called by TCP routines that access the rmx structure and by tcp_mss
 * to get the interface MTU.  If a route is found, this routine will
 * hold the rtentry lock; the caller is responsible for unlocking.
 */</span>
<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">tcp_rtlookup</span>(inp, input_ifscope)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> input_ifscope;
{
	<span class="enscript-type">struct</span> route *ro;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> tcpcb *tp;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);

	ro = &amp;inp-&gt;inp_route;
	<span class="enscript-keyword">if</span> ((rt = ro-&gt;ro_rt) != NULL)
		RT_LOCK(rt);

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro)) {
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_UNLOCK(rt);
			rt = NULL;
		}
		ROUTE_RELEASE(ro);
		<span class="enscript-comment">/* No route yet, so try to acquire one */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != INADDR_ANY) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

			ro-&gt;ro_dst.sa_family = AF_INET;
			ro-&gt;ro_dst.sa_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
			((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ro-&gt;ro_dst)-&gt;sin_addr =
				inp-&gt;inp_faddr;

			<span class="enscript-comment">/*
			 * If the socket was bound to an interface, then
			 * the bound-to-interface takes precedence over
			 * the inbound interface passed in by the caller
			 * (if we get here as part of the output path then
			 * input_ifscope is IFSCOPE_NONE).
			 */</span>
			ifscope = (inp-&gt;inp_flags &amp; INP_BOUND_IF) ?
			    inp-&gt;inp_boundifp-&gt;if_index : input_ifscope;

			rtalloc_scoped(ro, ifscope);
			<span class="enscript-keyword">if</span> ((rt = ro-&gt;ro_rt) != NULL)
				RT_LOCK(rt);
		}
	}
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/*
	 * Update MTU discovery determination. Don't do it if:
	 *	1) it is disabled via the sysctl
	 *	2) the route isn't up
	 *	3) the MTU is locked (if it is, then discovery has been
	 *	   disabled)
	 */</span>

	 tp = intotcpcb(inp);

	<span class="enscript-keyword">if</span> (!path_mtu_discovery || ((rt != NULL) &amp;&amp; 
	    (!(rt-&gt;rt_flags &amp; RTF_UP) || (rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU)))) 
		tp-&gt;t_flags &amp;= ~TF_PMTUD;
	<span class="enscript-keyword">else</span>
		tp-&gt;t_flags |= TF_PMTUD;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IFEF_NOWINDOWSCALE</span>
	<span class="enscript-keyword">if</span> (tcp_obey_ifef_nowindowscale &amp;&amp;
	    tp-&gt;t_state == TCPS_SYN_SENT &amp;&amp; rt != NULL &amp;&amp; rt-&gt;rt_ifp != NULL &amp;&amp;
	    (rt-&gt;rt_ifp-&gt;if_eflags &amp; IFEF_NOWINDOWSCALE)) {
		<span class="enscript-comment">/* Window scaling is enabled on this interface */</span>
		tp-&gt;t_flags &amp;= ~TF_REQ_SCALE;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; rt-&gt;rt_ifp != NULL) {
		somultipages(inp-&gt;inp_socket,
		    (rt-&gt;rt_ifp-&gt;if_hwassist &amp; IFNET_MULTIPAGES));
		tcp_set_tso(tp, rt-&gt;rt_ifp);
		soif2kcl(inp-&gt;inp_socket,
		    (rt-&gt;rt_ifp-&gt;if_eflags &amp; IFEF_2KCL));
	}

	<span class="enscript-comment">/* Note if the peer is local */</span>
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; !(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_POINTOPOINT) &amp;&amp;
		(rt-&gt;rt_gateway-&gt;sa_family == AF_LINK ||
		rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK ||
		in_localaddr(inp-&gt;inp_faddr))) {
		tp-&gt;t_flags |= TF_LOCAL;
	}
    
	<span class="enscript-comment">/*
	 * Caller needs to call RT_UNLOCK(rt).
	 */</span>
	<span class="enscript-keyword">return</span> rt;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">tcp_rtlookup6</span>(inp, input_ifscope)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> input_ifscope;
{
	<span class="enscript-type">struct</span> route_in6 *ro6;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> tcpcb *tp;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);

	ro6 = &amp;inp-&gt;in6p_route;
	<span class="enscript-keyword">if</span> ((rt = ro6-&gt;ro_rt) != NULL)
		RT_LOCK(rt);

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro6)) {
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_UNLOCK(rt);
			rt = NULL;
		}
		ROUTE_RELEASE(ro6);
		<span class="enscript-comment">/* No route yet, so try to acquire one */</span>
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr)) {
			<span class="enscript-type">struct</span> sockaddr_in6 *dst6;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

			dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ro6-&gt;ro_dst;
			dst6-&gt;sin6_family = AF_INET6;
			dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*dst6);
			dst6-&gt;sin6_addr = inp-&gt;in6p_faddr;

			<span class="enscript-comment">/*
			 * If the socket was bound to an interface, then
			 * the bound-to-interface takes precedence over
			 * the inbound interface passed in by the caller
			 * (if we get here as part of the output path then
			 * input_ifscope is IFSCOPE_NONE).
			 */</span>
			ifscope = (inp-&gt;inp_flags &amp; INP_BOUND_IF) ?
			    inp-&gt;inp_boundifp-&gt;if_index : input_ifscope;

			rtalloc_scoped((<span class="enscript-type">struct</span> route *)ro6, ifscope);
			<span class="enscript-keyword">if</span> ((rt = ro6-&gt;ro_rt) != NULL)
				RT_LOCK(rt);
		}
	}
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/*
	 * Update path MTU Discovery determination
	 * while looking up the route:
	 *  1) we have a valid route to the destination
	 *  2) the MTU is not locked (if it is, then discovery has been
	 *    disabled)
	 */</span>


	 tp = intotcpcb(inp);

	<span class="enscript-comment">/*
	 * Update MTU discovery determination. Don't do it if:
	 *	1) it is disabled via the sysctl
	 *	2) the route isn't up
	 *	3) the MTU is locked (if it is, then discovery has been
	 *	   disabled)
	 */</span>

	<span class="enscript-keyword">if</span> (!path_mtu_discovery || ((rt != NULL) &amp;&amp; 
	    (!(rt-&gt;rt_flags &amp; RTF_UP) || (rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU)))) 
		tp-&gt;t_flags &amp;= ~TF_PMTUD;
	<span class="enscript-keyword">else</span>
		tp-&gt;t_flags |= TF_PMTUD;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IFEF_NOWINDOWSCALE</span>
	<span class="enscript-keyword">if</span> (tcp_obey_ifef_nowindowscale &amp;&amp;
	    tp-&gt;t_state == TCPS_SYN_SENT &amp;&amp; rt != NULL &amp;&amp; rt-&gt;rt_ifp != NULL &amp;&amp;
	    (rt-&gt;rt_ifp-&gt;if_eflags &amp; IFEF_NOWINDOWSCALE)) {
		<span class="enscript-comment">/* Window scaling is not enabled on this interface */</span>
		tp-&gt;t_flags &amp;= ~TF_REQ_SCALE;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; rt-&gt;rt_ifp != NULL) {
		somultipages(inp-&gt;inp_socket,
		    (rt-&gt;rt_ifp-&gt;if_hwassist &amp; IFNET_MULTIPAGES));
		tcp_set_tso(tp, rt-&gt;rt_ifp);
		soif2kcl(inp-&gt;inp_socket,
		    (rt-&gt;rt_ifp-&gt;if_eflags &amp; IFEF_2KCL));
	}

	<span class="enscript-comment">/* Note if the peer is local */</span>
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; !(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_POINTOPOINT) &amp;&amp;
		(IN6_IS_ADDR_LOOPBACK(&amp;inp-&gt;in6p_faddr) ||
		IN6_IS_ADDR_LINKLOCAL(&amp;inp-&gt;in6p_faddr) ||
		rt-&gt;rt_gateway-&gt;sa_family == AF_LINK ||
		in6_localaddr(&amp;inp-&gt;in6p_faddr))) {
		tp-&gt;t_flags |= TF_LOCAL;
	}

	<span class="enscript-comment">/*
	 * Caller needs to call RT_UNLOCK(rt).
	 */</span>
	<span class="enscript-keyword">return</span> rt;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
<span class="enscript-comment">/* compute ESP/AH header size for TCP, including outer IP header. */</span>
size_t
<span class="enscript-function-name">ipsec_hdrsiz_tcp</span>(tp)
	<span class="enscript-type">struct</span> tcpcb *tp;
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> mbuf *m;
	size_t hdrsiz;
	<span class="enscript-type">struct</span> ip *ip;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-type">struct</span> tcphdr *th;

	<span class="enscript-keyword">if</span> ((tp == NULL) || ((inp = tp-&gt;t_inpcb) == NULL))
		<span class="enscript-keyword">return</span> 0;
	MGETHDR(m, M_DONTWAIT, MT_DATA);	<span class="enscript-comment">/* MAC-OK */</span>
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">return</span> 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0) {
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		th = (<span class="enscript-type">struct</span> tcphdr *)(<span class="enscript-type">void</span> *)(ip6 + 1);
		m-&gt;m_pkthdr.len = m-&gt;m_len =
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr);
		tcp_fillheaders(tp, ip6, th);
		hdrsiz = ipsec6_hdrsiz(m, IPSEC_DIR_OUTBOUND, inp);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
      {
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	th = (<span class="enscript-type">struct</span> tcphdr *)(ip + 1);
	m-&gt;m_pkthdr.len = m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcpiphdr);
	tcp_fillheaders(tp, ip, th);
	hdrsiz = ipsec4_hdrsiz(m, IPSEC_DIR_OUTBOUND, inp);
      }
	m_free(m);
	<span class="enscript-keyword">return</span> hdrsiz;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

<span class="enscript-comment">/*
 * Return a pointer to the cached information about the remote host.
 * The cached information is stored in the protocol specific part of
 * the route metrics.
 */</span>
<span class="enscript-type">struct</span> rmxp_tao *
<span class="enscript-function-name">tcp_gettaocache</span>(inp)
	<span class="enscript-type">struct</span> inpcb *inp;
{
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> rmxp_tao *taop;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_vflag &amp; INP_IPV6) != 0)
		rt = tcp_rtlookup6(inp, IFSCOPE_NONE);
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	rt = tcp_rtlookup(inp, IFSCOPE_NONE);

	<span class="enscript-comment">/* Make sure this is a host route and is up. */</span>
	<span class="enscript-keyword">if</span> (rt == NULL ||
	    (rt-&gt;rt_flags &amp; (RTF_UP|RTF_HOST)) != (RTF_UP|RTF_HOST)) {
		<span class="enscript-comment">/* Route locked during lookup above */</span>
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	taop = rmx_taop(rt-&gt;rt_rmx);
	<span class="enscript-comment">/* Route locked during lookup above */</span>
	RT_UNLOCK(rt);
	<span class="enscript-keyword">return</span> (taop);
}

<span class="enscript-comment">/*
 * Clear all the TAO cache entries, called from tcp_init.
 *
 * XXX
 * This routine is just an empty one, because we assume that the routing
 * routing tables are initialized at the same time when TCP, so there is
 * nothing in the cache left over.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_cleartaocache</span>()
{
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_lock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL) {
		lck_mtx_lock(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx);
	} <span class="enscript-keyword">else</span>  {
		panic(<span class="enscript-string">&quot;tcp_lock: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>, 
		    so, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;tcp_lock: so=%p so_pcb=%p lr=%p ref=%x lrh= %s\n&quot;</span>,
		    so, so-&gt;so_pcb, lr_saved, so-&gt;so_usecount, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount++;
	so-&gt;lock_lr[so-&gt;next_lock_lr] = lr_saved;
	so-&gt;next_lock_lr = (so-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_TCPLOCK_DEBUG</span>
	printf(<span class="enscript-string">&quot;tcp_unlock: so=0x%llx sopcb=0x%llx lock=0x%llx ref=%x &quot;</span>
	    <span class="enscript-string">&quot;lr=0x%llx\n&quot;</span>, (uint64_t)VM_KERNEL_ADDRPERM(so),
	    (uint64_t)VM_KERNEL_ADDRPERM(so-&gt;so_pcb),
	    (uint64_t)VM_KERNEL_ADDRPERM(&amp;(sotoinpcb(so)-&gt;inpcb_mtx)),
	    so-&gt;so_usecount, (uint64_t)VM_KERNEL_ADDRPERM(lr_saved));
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount--;

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;tcp_unlock: so=%p usecount=%x lrh= %s\n&quot;</span>, 
		    so, so-&gt;so_usecount, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		panic(<span class="enscript-string">&quot;tcp_unlock: so=%p NO PCB usecount=%x lr=%p lrh= %s\n&quot;</span>, 
		    so, so-&gt;so_usecount, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> {
		lck_mtx_assert(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx,
		    LCK_MTX_ASSERT_OWNED);
		so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
		so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;
		lck_mtx_unlock(&amp;((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inpcb_mtx);
	}
	<span class="enscript-keyword">return</span> (0);
}

lck_mtx_t *
<span class="enscript-function-name">tcp_getlock</span>(
	<span class="enscript-type">struct</span> socket *so,
	__unused <span class="enscript-type">int</span> locktype)
{
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb)  {
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0)
			panic(<span class="enscript-string">&quot;tcp_getlock: so=%p usecount=%x lrh= %s\n&quot;</span>, 
			    so, so-&gt;so_usecount, solockhistory_nr(so));	
		<span class="enscript-keyword">return</span>(&amp;inp-&gt;inpcb_mtx);
	}
	<span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;tcp_getlock: so=%p NULL so_pcb %s\n&quot;</span>, 
		    so, solockhistory_nr(so));
		<span class="enscript-keyword">return</span> (so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx);
	}
}

<span class="enscript-comment">/* 
 * Determine if we can grow the recieve socket buffer to avoid sending
 * a zero window update to the peer. We allow even socket buffers that 
 * have fixed size (set by the application) to grow if the resource
 * constraints are met. They will also be trimmed after the application
 * reads data.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_sbrcv_grow_rwin</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> sockbuf *sb)
{
	u_int32_t rcvbufinc = tp-&gt;t_maxseg &lt;&lt; 4;
	u_int32_t rcvbuf = sb-&gt;sb_hiwat;
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;

	<span class="enscript-comment">/*
	 * If message delivery is enabled, do not count
	 * unordered bytes in receive buffer towards hiwat
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS)
		rcvbuf = rcvbuf - so-&gt;so_msg_state-&gt;msg_uno_bytes;

	<span class="enscript-keyword">if</span> (tcp_do_autorcvbuf == 1 &amp;&amp;
		tcp_cansbgrow(sb) &amp;&amp;
		(tp-&gt;t_flags &amp; TF_SLOWLINK) == 0 &amp;&amp;
		(so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) == 0 &amp;&amp;
		(rcvbuf - sb-&gt;sb_cc) &lt; rcvbufinc &amp;&amp;
		rcvbuf &lt; tcp_autorcvbuf_max &amp;&amp;
		(sb-&gt;sb_idealsize &gt; 0 &amp;&amp;
		sb-&gt;sb_hiwat &lt;= (sb-&gt;sb_idealsize + rcvbufinc))) {
		sbreserve(sb,
		    min((sb-&gt;sb_hiwat + rcvbufinc), tcp_autorcvbuf_max));
	}
}

int32_t
<span class="enscript-function-name">tcp_sbspace</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> sockbuf *sb = &amp;tp-&gt;t_inpcb-&gt;inp_socket-&gt;so_rcv;
	u_int32_t rcvbuf = sb-&gt;sb_hiwat;
	int32_t space;
	<span class="enscript-type">struct</span> socket *so = tp-&gt;t_inpcb-&gt;inp_socket;
	int32_t pending = 0;

	<span class="enscript-comment">/*
	 * If message delivery is enabled, do not count
	 * unordered bytes in receive buffer towards hiwat mark.
	 * This value is used to return correct rwnd that does
	 * not reflect the extra unordered bytes added to the
	 * receive socket buffer.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS)
		rcvbuf = rcvbuf - so-&gt;so_msg_state-&gt;msg_uno_bytes;

	tcp_sbrcv_grow_rwin(tp, sb);

	space =  ((int32_t) imin((rcvbuf - sb-&gt;sb_cc),
		(sb-&gt;sb_mbmax - sb-&gt;sb_mbcnt)));
	<span class="enscript-keyword">if</span> (space &lt; 0) 
		space = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	<span class="enscript-comment">/* Compensate for data being processed by content filters */</span>
	pending = cfil_sock_data_space(sb);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
	<span class="enscript-keyword">if</span> (pending &gt; space)
		space = 0;
	<span class="enscript-keyword">else</span>
		space -= pending;

	<span class="enscript-comment">/* Avoid increasing window size if the current window
	 * is already very low, we could be in &quot;persist&quot; mode and
	 * we could break some apps (see rdar://5409343)
	 */</span>

	<span class="enscript-keyword">if</span> (space &lt; tp-&gt;t_maxseg) 
		<span class="enscript-keyword">return</span> space;

	<span class="enscript-comment">/* Clip window size for slower link */</span> 

	<span class="enscript-keyword">if</span> (((tp-&gt;t_flags &amp; TF_SLOWLINK) != 0) &amp;&amp; slowlink_wsize &gt; 0 )	
		<span class="enscript-keyword">return</span> imin(space, slowlink_wsize);

	<span class="enscript-keyword">return</span> space;
}
<span class="enscript-comment">/*
 * Checks TCP Segment Offloading capability for a given connection
 * and interface pair.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_tso</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> isipv6;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	<span class="enscript-comment">/*
	 * We can't use TSO if this tcpcb belongs to an MPTCP session.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;t_mpflags &amp; TMPF_MPTCP_TRUE) {
		tp-&gt;t_flags &amp;= ~TF_TSO;
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	inp = tp-&gt;t_inpcb;
	isipv6 = (inp-&gt;inp_vflag &amp; INP_IPV6) != 0;

	<span class="enscript-keyword">if</span> (isipv6) {
		<span class="enscript-keyword">if</span> (ifp &amp;&amp; (ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV6)) {
			tp-&gt;t_flags |= TF_TSO;
			<span class="enscript-keyword">if</span> (ifp-&gt;if_tso_v6_mtu != 0) 
				tp-&gt;tso_max_segment_size = ifp-&gt;if_tso_v6_mtu;
			<span class="enscript-keyword">else</span>
				tp-&gt;tso_max_segment_size = TCP_MAXWIN;
		} <span class="enscript-keyword">else</span>
				tp-&gt;t_flags &amp;= ~TF_TSO;

	} <span class="enscript-keyword">else</span> 
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

	{
		<span class="enscript-keyword">if</span> (ifp &amp;&amp; (ifp-&gt;if_hwassist &amp; IFNET_TSO_IPV4)) {
			tp-&gt;t_flags |= TF_TSO;
			<span class="enscript-keyword">if</span> (ifp-&gt;if_tso_v4_mtu != 0) 
				tp-&gt;tso_max_segment_size = ifp-&gt;if_tso_v4_mtu;
			<span class="enscript-keyword">else</span>
				tp-&gt;tso_max_segment_size = TCP_MAXWIN;
		} <span class="enscript-keyword">else</span>
				tp-&gt;t_flags &amp;= ~TF_TSO;
	}
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">TIMEVAL_TO_TCPHZ</span>(_tv_) ((_tv_).tv_sec * TCP_RETRANSHZ + (_tv_).tv_usec / TCP_RETRANSHZ_TO_USEC)

<span class="enscript-comment">/* Function to calculate the tcp clock. The tcp clock will get updated
 * at the boundaries of the tcp layer. This is done at 3 places:
 * 1. Right before processing an input tcp packet 
 * 2. Whenever a connection wants to access the network using tcp_usrreqs
 * 3. When a tcp timer fires or before tcp slow timeout
 *
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">calculate_tcp_clock</span>()
{
	<span class="enscript-type">struct</span> timeval tv = tcp_uptime;
	<span class="enscript-type">struct</span> timeval interval = {0, TCP_RETRANSHZ_TO_USEC};
	<span class="enscript-type">struct</span> timeval now, hold_now;
	uint32_t incr = 0;

	microuptime(&amp;now);

	<span class="enscript-comment">/*
	 * Update coarse-grained networking timestamp (in sec.); the idea
	 * is to update the counter returnable via net_uptime() when
	 * we read time.
	 */</span>
	net_update_uptime_secs(now.tv_sec);

	timevaladd(&amp;tv, &amp;interval);
	<span class="enscript-keyword">if</span> (timevalcmp(&amp;now, &amp;tv, &gt;)) {
		<span class="enscript-comment">/* time to update the clock */</span>
		lck_spin_lock(tcp_uptime_lock);
		<span class="enscript-keyword">if</span> (timevalcmp(&amp;tcp_uptime, &amp;now, &gt;=)) {
			<span class="enscript-comment">/* clock got updated while waiting for the lock */</span>
			lck_spin_unlock(tcp_uptime_lock);
			<span class="enscript-keyword">return</span>;
		}

		microuptime(&amp;now);
		hold_now = now;
		tv = tcp_uptime;
		timevalsub(&amp;now, &amp;tv);

		incr = TIMEVAL_TO_TCPHZ(now);
		<span class="enscript-keyword">if</span> (incr &gt; 0) {
			tcp_uptime = hold_now;
			tcp_now += incr;
		}

                lck_spin_unlock(tcp_uptime_lock);
        }
        <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* Compute receive window scaling that we are going to request 
 * for this connection based on  sb_hiwat. Try to leave some 
 * room to potentially increase the window size upto a maximum 
 * defined by the constant tcp_autorcvbuf_max.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_set_max_rwinscale</span>(<span class="enscript-type">struct</span> tcpcb *tp, <span class="enscript-type">struct</span> socket *so) {
	u_int32_t maxsockbufsize;
	<span class="enscript-keyword">if</span> (!tcp_do_rfc1323) {
		tp-&gt;request_r_scale = 0;
		<span class="enscript-keyword">return</span>;
	}

	tp-&gt;request_r_scale = max(tcp_win_scale, tp-&gt;request_r_scale);
	maxsockbufsize = ((so-&gt;so_rcv.sb_flags &amp; SB_USRSIZE) != 0) ?
		so-&gt;so_rcv.sb_hiwat : tcp_autorcvbuf_max;

	<span class="enscript-keyword">while</span> (tp-&gt;request_r_scale &lt; TCP_MAX_WINSHIFT &amp;&amp;
		(TCP_MAXWIN &lt;&lt; tp-&gt;request_r_scale) &lt; maxsockbufsize)
		tp-&gt;request_r_scale++;
	tp-&gt;request_r_scale = min(tp-&gt;request_r_scale, TCP_MAX_WINSHIFT);

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tcp_notsent_lowat_check</span>(<span class="enscript-type">struct</span> socket *so) {
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> tcpcb *tp = NULL;
	<span class="enscript-type">int</span> notsent = 0;
	<span class="enscript-keyword">if</span> (inp != NULL) {
		tp = intotcpcb(inp);
	}

	notsent = so-&gt;so_snd.sb_cc - 
		(tp-&gt;snd_nxt - tp-&gt;snd_una);

	<span class="enscript-comment">/* When we send a FIN or SYN, not_sent can be negative.
	 * In that case also we need to send a write event to the 
	 * process if it is waiting. In the FIN case, it will
	 * get an error from send because cantsendmore will be set.
	 */</span>
	<span class="enscript-keyword">if</span> (notsent &lt;= tp-&gt;t_notsent_lowat) {
		<span class="enscript-keyword">return</span>(1);
	}

	<span class="enscript-comment">/* When Nagle's algorithm is not disabled, it is better
	 * to wakeup the client until there is atleast one
	 * maxseg of data to write.
	 */</span>
	<span class="enscript-keyword">if</span> ((tp-&gt;t_flags &amp; TF_NODELAY) == 0 &amp;&amp; 
		notsent &gt; 0 &amp;&amp; notsent &lt; tp-&gt;t_maxseg) {
		<span class="enscript-keyword">return</span>(1);
	}
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_rxtseg_insert</span>(<span class="enscript-type">struct</span> tcpcb *tp, tcp_seq start, tcp_seq end) {
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg = NULL, *prev = NULL, *next = NULL;
	u_int32_t rxcount = 0;

	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))
		tp-&gt;t_dsack_lastuna = tp-&gt;snd_una;
	<span class="enscript-comment">/*
	 * First check if there is a segment already existing for this
	 * sequence space.
	 */</span>

	SLIST_FOREACH(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link) {
		<span class="enscript-keyword">if</span> (SEQ_GT(rxseg-&gt;rx_start, start))
			<span class="enscript-keyword">break</span>;
		prev = rxseg;
	}
	next = rxseg;

	<span class="enscript-comment">/* check if prev seg is for this sequence */</span>
	<span class="enscript-keyword">if</span> (prev != NULL &amp;&amp; SEQ_LEQ(prev-&gt;rx_start, start) &amp;&amp;
	    SEQ_GEQ(prev-&gt;rx_end, end)) {
		prev-&gt;rx_count++;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * There are a couple of possibilities at this point.
	 * 1. prev overlaps with the beginning of this sequence
	 * 2. next overlaps with the end of this sequence
	 * 3. there is no overlap.
	 */</span>

	<span class="enscript-keyword">if</span> (prev != NULL &amp;&amp; SEQ_GT(prev-&gt;rx_end, start)) {
		<span class="enscript-keyword">if</span> (prev-&gt;rx_start == start &amp;&amp; SEQ_GT(end, prev-&gt;rx_end)) {
			start = prev-&gt;rx_end + 1;
			prev-&gt;rx_count++;
		} <span class="enscript-keyword">else</span> {
			prev-&gt;rx_end = (start - 1);
			rxcount = prev-&gt;rx_count;
		}
	}

	<span class="enscript-keyword">if</span> (next != NULL &amp;&amp; SEQ_LT(next-&gt;rx_start, end)) {
		<span class="enscript-keyword">if</span> (SEQ_LEQ(next-&gt;rx_end, end)) {
			end = next-&gt;rx_start - 1;
			next-&gt;rx_count++;
		} <span class="enscript-keyword">else</span> {
			next-&gt;rx_start = end + 1;
			rxcount = next-&gt;rx_count;
		}
	}
	<span class="enscript-keyword">if</span> (!SEQ_LT(start, end))
		<span class="enscript-keyword">return</span>;

	rxseg = (<span class="enscript-type">struct</span> tcp_rxt_seg *) zalloc(tcp_rxt_seg_zone);
	<span class="enscript-keyword">if</span> (rxseg == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	bzero(rxseg, <span class="enscript-keyword">sizeof</span>(*rxseg));
	rxseg-&gt;rx_start = start;
	rxseg-&gt;rx_end = end;
	rxseg-&gt;rx_count = rxcount + 1;

	<span class="enscript-keyword">if</span> (prev != NULL) {
		SLIST_INSERT_AFTER(prev, rxseg, rx_link);
	} <span class="enscript-keyword">else</span> {
		SLIST_INSERT_HEAD(&amp;tp-&gt;t_rxt_segments, rxseg, rx_link);
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">struct</span> tcp_rxt_seg *
<span class="enscript-function-name">tcp_rxtseg_find</span>(<span class="enscript-type">struct</span> tcpcb *tp, tcp_seq start, tcp_seq end)
{
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg;
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))
		<span class="enscript-keyword">return</span> (NULL);

	SLIST_FOREACH(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link) {
		<span class="enscript-keyword">if</span> (SEQ_LEQ(rxseg-&gt;rx_start, start) &amp;&amp;
		    SEQ_GEQ(rxseg-&gt;rx_end, end))
			<span class="enscript-keyword">return</span> (rxseg);
		<span class="enscript-keyword">if</span> (SEQ_GT(rxseg-&gt;rx_start, start))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_rxtseg_clean</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg, *next;

	SLIST_FOREACH_SAFE(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link, next) {
		SLIST_REMOVE(&amp;tp-&gt;t_rxt_segments, rxseg,
		    tcp_rxt_seg, rx_link);
		zfree(tcp_rxt_seg_zone, rxseg);
	}
	tp-&gt;t_dsack_lastuna = tp-&gt;snd_max;
}

boolean_t
<span class="enscript-function-name">tcp_rxtseg_detect_bad_rexmt</span>(<span class="enscript-type">struct</span> tcpcb *tp, tcp_seq th_ack)
{
	boolean_t bad_rexmt;
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg;

	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-comment">/*
	 * If all of the segments in this window are not cumulatively
	 * acknowledged, then there can still be undetected packet loss.
	 * Do not restore congestion window in that case.
	 */</span>
	<span class="enscript-keyword">if</span> (SEQ_LT(th_ack, tp-&gt;snd_recover))
		<span class="enscript-keyword">return</span> (FALSE);

	bad_rexmt = TRUE;
	SLIST_FOREACH(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link) {
		<span class="enscript-keyword">if</span> (rxseg-&gt;rx_count &gt; 1 ||
		    !(rxseg-&gt;rx_flags &amp; TCP_RXT_SPURIOUS)) {
			bad_rexmt = FALSE;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (bad_rexmt);
}

boolean_t
<span class="enscript-function-name">tcp_rxtseg_dsack_for_tlp</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	boolean_t dsack_for_tlp = FALSE;
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg;
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;tp-&gt;t_rxt_segments))
		<span class="enscript-keyword">return</span> (FALSE);

	SLIST_FOREACH(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link) {
		<span class="enscript-keyword">if</span> (rxseg-&gt;rx_count == 1 &amp;&amp;
		    SLIST_NEXT(rxseg,rx_link) == NULL &amp;&amp;
		    (rxseg-&gt;rx_flags &amp; TCP_RXT_DSACK_FOR_TLP)) {
			dsack_for_tlp = TRUE;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (dsack_for_tlp);
}

u_int32_t
<span class="enscript-function-name">tcp_rxtseg_total_size</span>(<span class="enscript-type">struct</span> tcpcb *tp) {
	<span class="enscript-type">struct</span> tcp_rxt_seg *rxseg;
	u_int32_t total_size = 0;

	SLIST_FOREACH(rxseg, &amp;tp-&gt;t_rxt_segments, rx_link) {
		total_size += (rxseg-&gt;rx_end - rxseg-&gt;rx_start) + 1;
	}
	<span class="enscript-keyword">return</span> (total_size);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_get_connectivity_status</span>(<span class="enscript-type">struct</span> tcpcb *tp,
	<span class="enscript-type">struct</span> tcp_conn_status *connstatus)
{
	<span class="enscript-keyword">if</span> (tp == NULL || connstatus == NULL)
		<span class="enscript-keyword">return</span>;
	bzero(connstatus, <span class="enscript-keyword">sizeof</span>(*connstatus));
	<span class="enscript-keyword">if</span> (tp-&gt;t_rxtshift &gt;= TCP_CONNECTIVITY_PROBES_MAX) {
		<span class="enscript-keyword">if</span> (TCPS_HAVEESTABLISHED(tp-&gt;t_state)) {
			connstatus-&gt;write_probe_failed = 1;
		} <span class="enscript-keyword">else</span> {
			connstatus-&gt;conn_probe_failed = 1;
		}
	}
	<span class="enscript-keyword">if</span> (tp-&gt;t_rtimo_probes &gt;= TCP_CONNECTIVITY_PROBES_MAX)
		connstatus-&gt;read_probe_failed = 1;
	<span class="enscript-keyword">if</span> (tp-&gt;t_inpcb != NULL &amp;&amp; tp-&gt;t_inpcb-&gt;inp_last_outifp != NULL
	    &amp;&amp; (tp-&gt;t_inpcb-&gt;inp_last_outifp-&gt;if_eflags &amp; IFEF_PROBE_CONNECTIVITY))
		connstatus-&gt;probe_activated = 1;
	<span class="enscript-keyword">return</span>;
}

boolean_t
<span class="enscript-function-name">tfo_enabled</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> tcpcb *tp)
{
	<span class="enscript-keyword">return</span> !!(tp-&gt;t_flagsext &amp; TF_FASTOPEN);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">tcp_disable_tfo</span>(<span class="enscript-type">struct</span> tcpcb *tp)
{
	tp-&gt;t_flagsext &amp;= ~TF_FASTOPEN;
}

</pre>
<hr />
</body></html>