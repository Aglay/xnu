<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip_input.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip_input.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2007 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_IP_VHL</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/classq/classq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_perf.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_divert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/bootp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/lro_ext.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETIP, 0)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETIP, 2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_IP_INPUT</span>	NETDBG_CODE(DBG_NETIP, (2 &lt;&lt; 8))

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

lck_grp_t	*sadb_stat_mutex_grp;
lck_grp_attr_t	*sadb_stat_mutex_grp_attr;
lck_attr_t	*sadb_stat_mutex_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(, sadb_stat_mutex_data);
lck_mtx_t	*sadb_stat_mutex = &amp;sadb_stat_mutex_data;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

<span class="enscript-function-name">MBUFQ_HEAD</span>(fq_head);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> frag_timeout_run;		<span class="enscript-comment">/* frag timer is scheduled to run */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">frag_timeout</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">frag_sched_timeout</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipq *<span class="enscript-function-name">ipq_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipq_free</span>(<span class="enscript-type">struct</span> ipq *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipq_updateparams</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_input_second_pass</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ifnet *,
    u_int32_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> ip_fw_in_args *, <span class="enscript-type">int</span>);

<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, ipqlock);
<span class="enscript-type">static</span> lck_attr_t	*ipqlock_attr;
<span class="enscript-type">static</span> lck_grp_t	*ipqlock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*ipqlock_grp_attr;

<span class="enscript-comment">/* Packet reassembly stuff */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPREASS_NHASH_LOG2</span>	6
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPREASS_NHASH</span>		(1 &lt;&lt; IPREASS_NHASH_LOG2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPREASS_HMASK</span>		(IPREASS_NHASH - 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IPREASS_HASH</span>(x, y) \
	(((((x) &amp; 0xF) | ((((x) &gt;&gt; 8) &amp; 0xF) &lt;&lt; 4)) ^ (y)) &amp; IPREASS_HMASK)

<span class="enscript-comment">/* IP fragment reassembly queues (protected by ipqlock) */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(ipqhead, ipq) ipq[IPREASS_NHASH]; <span class="enscript-comment">/* ip reassembly queues */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> maxnipq;			<span class="enscript-comment">/* max packets in reass queues */</span>
<span class="enscript-type">static</span> u_int32_t maxfragsperpacket;	<span class="enscript-comment">/* max frags/packet in reass queues */</span>
<span class="enscript-type">static</span> u_int32_t nipq;			<span class="enscript-comment">/* # of packets in reass queues */</span>
<span class="enscript-type">static</span> u_int32_t ipq_limit;		<span class="enscript-comment">/* ipq allocation limit */</span>
<span class="enscript-type">static</span> u_int32_t ipq_count;		<span class="enscript-comment">/* current # of allocated ipq's */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ipforwarding SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_maxnipq SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_maxfragsperpacket SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_reset_ip_input_stats SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip_input_measure_bins SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip_input_getperf SYSCTL_HANDLER_ARGS;

<span class="enscript-type">int</span> ipforwarding = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, IPCTL_FORWARDING, forwarding,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ipforwarding, 0,
	sysctl_ipforwarding, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Enable IP forwarding between interfaces&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipsendredirects = 1; <span class="enscript-comment">/* XXX */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, IPCTL_SENDREDIRECTS, redirect,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ipsendredirects, 0,
	<span class="enscript-string">&quot;Enable sending IP redirects&quot;</span>);

<span class="enscript-type">int</span> ip_defttl = IPDEFTTL;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, IPCTL_DEFTTL, ttl, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_defttl, 0, <span class="enscript-string">&quot;Maximum TTL on IP packets&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_dosourceroute = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, IPCTL_SOURCEROUTE, sourceroute,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_dosourceroute, 0,
	<span class="enscript-string">&quot;Enable forwarding source routed IP packets&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_acceptsourceroute = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, IPCTL_ACCEPTSOURCEROUTE, accept_sourceroute,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_acceptsourceroute, 0,
	<span class="enscript-string">&quot;Enable accepting source routed IP packets&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_sendsourcequench = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, sendsourcequench,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_sendsourcequench, 0,
	<span class="enscript-string">&quot;Enable the transmission of source quench packets&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, maxfragpackets,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;maxnipq, 0, sysctl_maxnipq,
	<span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Maximum number of IPv4 fragment reassembly queue entries&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_ip, OID_AUTO, fragpackets, CTLFLAG_RD | CTLFLAG_LOCKED,
	&amp;nipq, 0, <span class="enscript-string">&quot;Current number of IPv4 fragment reassembly queue entries&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, maxfragsperpacket,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;maxfragsperpacket, 0,
	sysctl_maxfragsperpacket, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;Maximum number of IPv4 fragments allowed per packet&quot;</span>);

<span class="enscript-type">int</span> ip_doscopedroute = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, scopedroute, CTLFLAG_RD | CTLFLAG_LOCKED,
	&amp;ip_doscopedroute, 0, <span class="enscript-string">&quot;Enable IPv4 scoped routing&quot;</span>);

<span class="enscript-type">static</span> uint32_t ip_adj_clear_hwcksum = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet_ip, OID_AUTO, adj_clear_hwcksum,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_adj_clear_hwcksum, 0,
	<span class="enscript-string">&quot;Invalidate hwcksum info when adjusting length&quot;</span>);

<span class="enscript-comment">/*
 * XXX - Setting ip_checkinterface mostly implements the receive side of
 * the Strong ES model described in RFC 1122, but since the routing table
 * and transmit implementation do not implement the Strong ES model,
 * setting this to 1 results in an odd hybrid.
 *
 * XXX - ip_checkinterface currently must be disabled if you use ipnat
 * to translate the destination address to another local interface.
 *
 * XXX - ip_checkinterface must be disabled if you add IP aliases
 * to the loopback interface instead of the interface where the
 * packets for those addresses are received.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_checkinterface = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, check_interface, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_checkinterface, 0, <span class="enscript-string">&quot;Verify packet arrives on correct interface&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_chaining = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, rx_chaining, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_chaining, 1, <span class="enscript-string">&quot;Do receive side ip address based chaining&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_chainsz = 6;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, rx_chainsz, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_chainsz, 1, <span class="enscript-string">&quot;IP receive side max chaining&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_input_measure = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, input_perf,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_input_measure, 0, sysctl_reset_ip_input_stats, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Do time measurement&quot;</span>);

<span class="enscript-type">static</span> uint64_t ip_input_measure_bins = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, input_perf_bins,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_input_measure_bins, 0,
	sysctl_ip_input_measure_bins, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;bins for chaining performance data histogram&quot;</span>);

<span class="enscript-type">static</span> net_perf_t net_perf;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, OID_AUTO, input_perf_data,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
	0, 0, sysctl_ip_input_getperf, <span class="enscript-string">&quot;S,net_perf&quot;</span>,
	<span class="enscript-string">&quot;IP input performance data (struct net_perf, net/net_perf.h)&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipprintfs = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> protosw *ip_protox[IPPROTO_MAX];

<span class="enscript-type">static</span> lck_grp_attr_t	*in_ifaddr_rwlock_grp_attr;
<span class="enscript-type">static</span> lck_grp_t	*in_ifaddr_rwlock_grp;
<span class="enscript-type">static</span> lck_attr_t	*in_ifaddr_rwlock_attr;
<span class="enscript-function-name">decl_lck_rw_data</span>(, in_ifaddr_rwlock_data);
lck_rw_t		*in_ifaddr_rwlock = &amp;in_ifaddr_rwlock_data;

<span class="enscript-comment">/* Protected by in_ifaddr_rwlock */</span>
<span class="enscript-type">struct</span> in_ifaddrhead in_ifaddrhead;		<span class="enscript-comment">/* first inet address */</span>
<span class="enscript-type">struct</span> in_ifaddrhashhead *in_ifaddrhashtbl;	<span class="enscript-comment">/* inet addr hash table  */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INADDR_NHASH</span>	61
<span class="enscript-type">static</span> u_int32_t inaddr_nhash;			<span class="enscript-comment">/* hash table size */</span>
<span class="enscript-type">static</span> u_int32_t inaddr_hashp;			<span class="enscript-comment">/* next largest prime */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_getstat SYSCTL_HANDLER_ARGS;
<span class="enscript-type">struct</span> ipstat ipstat;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ip, IPCTL_STATS, stats,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
	0, 0, ip_getstat, <span class="enscript-string">&quot;S,ipstat&quot;</span>,
	<span class="enscript-string">&quot;IP statistics (struct ipstat, netinet/ip_var.h)&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPCTL_DEFMTU</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, IPCTL_DEFMTU, mtu, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_mtu, 0, <span class="enscript-string">&quot;Default MTU&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPCTL_DEFMTU */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSTEALTH</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ipstealth = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, stealth, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ipstealth, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSTEALTH */</span>

<span class="enscript-comment">/* Firewall hooks */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
ip_fw_chk_t *ip_fw_chk_ptr;
<span class="enscript-type">int</span> fw_enable = 1;
<span class="enscript-type">int</span> fw_bypass = 1;
<span class="enscript-type">int</span> fw_one_pass = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
ip_dn_io_t *ip_dn_io_ptr;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_ip, OID_AUTO, linklocal,
	CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;link local&quot;</span>);

<span class="enscript-type">struct</span> ip_linklocal_stat ip_linklocal_stat;
<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_inet_ip_linklocal, OID_AUTO, stat,
	CTLFLAG_RD | CTLFLAG_LOCKED, &amp;ip_linklocal_stat, ip_linklocal_stat,
	<span class="enscript-string">&quot;Number of link local packets with TTL less than 255&quot;</span>);

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet_ip_linklocal, OID_AUTO, in,
	CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;link local input&quot;</span>);

<span class="enscript-type">int</span> ip_linklocal_in_allowbadttl = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip_linklocal_in, OID_AUTO, allowbadttl,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip_linklocal_in_allowbadttl, 0,
	<span class="enscript-string">&quot;Allow incoming link local packets with TTL less than 255&quot;</span>);


<span class="enscript-comment">/*
 * We need to save the IP options in case a protocol wants to respond
 * to an incoming packet over the same route if the packet got here
 * using IP source routing.  This allows connection establishment and
 * maintenance when the remote end is on a network that is not known
 * to us.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ip_nhops = 0;
<span class="enscript-type">static</span>	<span class="enscript-type">struct</span> ip_srcrt {
	<span class="enscript-type">struct</span>	in_addr dst;			<span class="enscript-comment">/* final destination */</span>
	<span class="enscript-type">char</span>	nop;				<span class="enscript-comment">/* one NOP to align */</span>
	<span class="enscript-type">char</span>	srcopt[IPOPT_OFFSET + 1];	<span class="enscript-comment">/* OPTVAL, OLEN and OFFSET */</span>
	<span class="enscript-type">struct</span>	in_addr route[MAX_IPOPTLEN / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr)];
} ip_srcrt;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in_ifaddrhashtbl_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">save_rte</span>(u_char *, <span class="enscript-type">struct</span> in_addr);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip_dooptions</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr_in *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_forward</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr_in *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">frag_freef</span>(<span class="enscript-type">struct</span> ipqhead *, <span class="enscript-type">struct</span> ipq *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPDIVERT_44</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ip_reass</span>(<span class="enscript-type">struct</span> mbuf *, u_int32_t *, u_int16_t *);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPDIVERT_44 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ip_reass</span>(<span class="enscript-type">struct</span> mbuf *, u_int16_t *, u_int16_t *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPDIVERT_44 */</span>
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPDIVERT */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ip_reass</span>(<span class="enscript-type">struct</span> mbuf *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPDIVERT */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_fwd_route_copyout</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip_fwd_route_copyin</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> route *);
<span class="enscript-type">static</span> inline u_short <span class="enscript-function-name">ip_cksum</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);

<span class="enscript-type">int</span> ip_use_randomid = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ip, OID_AUTO, random_id, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip_use_randomid, 0, <span class="enscript-string">&quot;Randomize IP packets IDs&quot;</span>);

<span class="enscript-comment">/*
 * On platforms which require strict alignment (currently for anything but
 * i386 or x86_64), check if the IP header pointer is 32-bit aligned; if not,
 * copy the contents of the mbuf chain into a new chain, and free the original
 * one.  Create some head room in the first mbuf of the new chain, in case
 * it's needed later on.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IP_HDR_ALIGNMENT_FIXUP</span>(_m, _ifp, _action) do { } while (0)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IP_HDR_ALIGNMENT_FIXUP</span>(_m, _ifp, _action) do {			\
	<span class="enscript-keyword">if</span> (!IP_HDR_ALIGNED_P(mtod(_m, caddr_t))) {			\
		<span class="enscript-type">struct</span> mbuf *_n;					\
		<span class="enscript-type">struct</span> ifnet *__ifp = (_ifp);				\
		atomic_add_64(&amp;(__ifp)-&gt;if_alignerrs, 1);		\
		<span class="enscript-keyword">if</span> (((_m)-&gt;m_flags &amp; M_PKTHDR) &amp;&amp;			\
		    (_m)-&gt;m_pkthdr.pkt_hdr != NULL)			\
			(_m)-&gt;m_pkthdr.pkt_hdr = NULL;			\
		_n = m_defrag_offset(_m, max_linkhdr, M_NOWAIT);	\
		<span class="enscript-keyword">if</span> (_n == NULL) {					\
			atomic_add_32(&amp;ipstat.ips_toosmall, 1);		\
			m_freem(_m);					\
			(_m) = NULL;					\
			_action;					\
		} <span class="enscript-keyword">else</span> {						\
			VERIFY(_n != (_m));				\
			(_m) = _n;					\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>

<span class="enscript-comment">/*
 * GRE input handler function, settable via ip_gre_register_input() for PPTP.
 */</span>
<span class="enscript-type">static</span> gre_input_func_t gre_input_func;

<span class="enscript-comment">/*
 * IP initialization: fill in IP protocol switch table.
 * All protocols not implemented in kernel go to raw IP protocol handler.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip_initialized = 0;
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> i;

	domain_proto_mtx_lock_assert_held();
	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-comment">/* ipq_alloc() uses mbufs for IP fragment queue structures */</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipq) &lt;= _MLEN);

	<span class="enscript-comment">/*
	 * Some ioctls (e.g. SIOCAIFADDR) use ifaliasreq struct, which is
	 * interchangeable with in_aliasreq; they must have the same size.
	 */</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ifaliasreq) == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_aliasreq));

	<span class="enscript-keyword">if</span> (ip_initialized)
		<span class="enscript-keyword">return</span>;
	ip_initialized = 1;

	PE_parse_boot_argn(<span class="enscript-string">&quot;net.inet.ip.scopedroute&quot;</span>,
	    &amp;ip_doscopedroute, <span class="enscript-keyword">sizeof</span> (ip_doscopedroute));

	in_ifaddr_init();

	in_ifaddr_rwlock_grp_attr = lck_grp_attr_alloc_init();
	in_ifaddr_rwlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;in_ifaddr_rwlock&quot;</span>,
	    in_ifaddr_rwlock_grp_attr);
	in_ifaddr_rwlock_attr = lck_attr_alloc_init();
	lck_rw_init(in_ifaddr_rwlock, in_ifaddr_rwlock_grp,
	    in_ifaddr_rwlock_attr);

	TAILQ_INIT(&amp;in_ifaddrhead);
	in_ifaddrhashtbl_init();

	ip_moptions_init();

	pr = pffindproto_locked(PF_INET, IPPROTO_RAW, SOCK_RAW);
	<span class="enscript-keyword">if</span> (pr == NULL) {
		panic(<span class="enscript-string">&quot;%s: Unable to find [PF_INET,IPPROTO_RAW,SOCK_RAW]\n&quot;</span>,
		    __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Initialize the entire ip_protox[] array to IPPROTO_RAW. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPPROTO_MAX; i++)
		ip_protox[i] = pr;
	<span class="enscript-comment">/*
	 * Cycle through IP protocols and put them into the appropriate place
	 * in ip_protox[], skipping protocols IPPROTO_{IP,RAW}.
	 */</span>
	VERIFY(dp == inetdomain &amp;&amp; dp-&gt;dom_family == PF_INET);
	TAILQ_FOREACH(pr, &amp;dp-&gt;dom_protosw, pr_entry) {
		VERIFY(pr-&gt;pr_domain == dp);
		<span class="enscript-keyword">if</span> (pr-&gt;pr_protocol != 0 &amp;&amp; pr-&gt;pr_protocol != IPPROTO_RAW) {
			<span class="enscript-comment">/* Be careful to only index valid IP protocols. */</span>
			<span class="enscript-keyword">if</span> (pr-&gt;pr_protocol &lt; IPPROTO_MAX)
				ip_protox[pr-&gt;pr_protocol] = pr;
		}
	}

	<span class="enscript-comment">/* IP fragment reassembly queue lock */</span>
	ipqlock_grp_attr  = lck_grp_attr_alloc_init();
	ipqlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;ipqlock&quot;</span>, ipqlock_grp_attr);
	ipqlock_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;ipqlock, ipqlock_grp, ipqlock_attr);

	lck_mtx_lock(&amp;ipqlock);
	<span class="enscript-comment">/* Initialize IP reassembly queue. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPREASS_NHASH; i++)
		TAILQ_INIT(&amp;ipq[i]);

	maxnipq = nmbclusters / 32;
	maxfragsperpacket = 128; <span class="enscript-comment">/* enough for 64k in 512 byte fragments */</span>
	ipq_updateparams();
	lck_mtx_unlock(&amp;ipqlock);

	getmicrotime(&amp;tv);
	ip_id = RandomULong() ^ tv.tv_usec;
	ip_initid();

	ipf_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	sadb_stat_mutex_grp_attr = lck_grp_attr_alloc_init();
	sadb_stat_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;sadb_stat&quot;</span>,
	    sadb_stat_mutex_grp_attr);
	sadb_stat_mutex_attr = lck_attr_alloc_init();
	lck_mtx_init(sadb_stat_mutex, sadb_stat_mutex_grp,
	    sadb_stat_mutex_attr);

#<span class="enscript-reference">endif</span>
	arp_init();
}

<span class="enscript-comment">/*
 * Initialize IPv4 source address hash table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in_ifaddrhashtbl_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i, k, p;

	<span class="enscript-keyword">if</span> (in_ifaddrhashtbl != NULL)
		<span class="enscript-keyword">return</span>;

	PE_parse_boot_argn(<span class="enscript-string">&quot;inaddr_nhash&quot;</span>, &amp;inaddr_nhash,
	    <span class="enscript-keyword">sizeof</span> (inaddr_nhash));
	<span class="enscript-keyword">if</span> (inaddr_nhash == 0)
		inaddr_nhash = INADDR_NHASH;

	MALLOC(in_ifaddrhashtbl, <span class="enscript-type">struct</span> in_ifaddrhashhead *,
	    inaddr_nhash * <span class="enscript-keyword">sizeof</span> (*in_ifaddrhashtbl),
	    M_IFADDR, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (in_ifaddrhashtbl == NULL)
		panic(<span class="enscript-string">&quot;in_ifaddrhashtbl_init allocation failed&quot;</span>);

	<span class="enscript-comment">/*
	 * Generate the next largest prime greater than inaddr_nhash.
	 */</span>
	k = (inaddr_nhash % 2 == 0) ? inaddr_nhash + 1 : inaddr_nhash + 2;
	<span class="enscript-keyword">for</span> (;;) {
		p = 1;
		<span class="enscript-keyword">for</span> (i = 3; i * i &lt;= k; i += 2) {
			<span class="enscript-keyword">if</span> (k % i == 0)
				p = 0;
		}
		<span class="enscript-keyword">if</span> (p == 1)
			<span class="enscript-keyword">break</span>;
		k += 2;
	}
	inaddr_hashp = k;
}

u_int32_t
<span class="enscript-function-name">inaddr_hashval</span>(u_int32_t key)
{
	<span class="enscript-comment">/*
	 * The hash index is the computed prime times the key modulo
	 * the hash size, as documented in &quot;Introduction to Algorithms&quot;
	 * (Cormen, Leiserson, Rivest).
	 */</span>
	<span class="enscript-keyword">if</span> (inaddr_nhash &gt; 1)
		<span class="enscript-keyword">return</span> ((key * inaddr_hashp) % inaddr_nhash);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_proto_dispatch_in_wrapper</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hlen, u_int8_t proto)
{
	ip_proto_dispatch_in(m, hlen, proto, 0);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_proto_dispatch_in</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hlen, u_int8_t proto,
    ipfilter_t inject_ipfref)
{
	<span class="enscript-type">struct</span> ipfilter *filter;
	<span class="enscript-type">int</span> seen = (inject_ipfref == NULL);
	<span class="enscript-type">int</span>	changed_header = 0;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">void</span> (*pr_input)(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span> len);

	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ipv4_filters)) {
		ipf_ref();
		TAILQ_FOREACH(filter, &amp;ipv4_filters, ipf_link) {
			<span class="enscript-keyword">if</span> (seen == 0) {
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> ipfilter *)inject_ipfref == filter)
					seen = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.ipf_input) {
				errno_t result;

				<span class="enscript-keyword">if</span> (changed_header == 0) {
					<span class="enscript-comment">/*
					 * Perform IP header alignment fixup,
					 * if needed, before passing packet
					 * into filter(s).
					 */</span>
					IP_HDR_ALIGNMENT_FIXUP(m,
					    m-&gt;m_pkthdr.rcvif, ipf_unref());

					<span class="enscript-comment">/* ipf_unref() already called */</span>
					<span class="enscript-keyword">if</span> (m == NULL)
						<span class="enscript-keyword">return</span>;

					changed_header = 1;
					ip = mtod(m, <span class="enscript-type">struct</span> ip *);
					ip-&gt;ip_len = htons(ip-&gt;ip_len + hlen);
					ip-&gt;ip_off = htons(ip-&gt;ip_off);
					ip-&gt;ip_sum = 0;
					ip-&gt;ip_sum = ip_cksum_hdr_in(m, hlen);
				}
				result = filter-&gt;ipf_filter.ipf_input(
				    filter-&gt;ipf_filter.cookie, (mbuf_t *)&amp;m,
				    hlen, proto);
				<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
					ipf_unref();
					<span class="enscript-keyword">return</span>;
				}
				<span class="enscript-keyword">if</span> (result != 0) {
					ipf_unref();
					m_freem(m);
					<span class="enscript-keyword">return</span>;
				}
			}
		}
		ipf_unref();
	}

	<span class="enscript-comment">/* Perform IP header alignment fixup (post-filters), if needed */</span>
	IP_HDR_ALIGNMENT_FIXUP(m, m-&gt;m_pkthdr.rcvif, <span class="enscript-keyword">return</span>);

	<span class="enscript-comment">/*
	 * If there isn't a specific lock for the protocol
	 * we're about to call, use the generic lock for AF_INET.
	 * otherwise let the protocol deal with its own locking
	 */</span>
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	<span class="enscript-keyword">if</span> (changed_header) {
		ip-&gt;ip_len = ntohs(ip-&gt;ip_len) - hlen;
		ip-&gt;ip_off = ntohs(ip-&gt;ip_off);
	}

	<span class="enscript-keyword">if</span> ((pr_input = ip_protox[ip-&gt;ip_p]-&gt;pr_input) == NULL) {
		m_freem(m);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ip_protox[ip-&gt;ip_p]-&gt;pr_flags &amp; PR_PROTOLOCK)) {
		lck_mtx_lock(inet_domain_mutex);
		pr_input(m, hlen);
		lck_mtx_unlock(inet_domain_mutex);
	} <span class="enscript-keyword">else</span> {
		pr_input(m, hlen);
	}
}

<span class="enscript-type">struct</span> pktchain_elm {
	<span class="enscript-type">struct</span> mbuf	*pkte_head;
	<span class="enscript-type">struct</span> mbuf	*pkte_tail;
	<span class="enscript-type">struct</span> in_addr	pkte_saddr;
	<span class="enscript-type">struct</span> in_addr	pkte_daddr;
	uint16_t	pkte_npkts;
	uint16_t	pkte_proto;
	uint32_t	pkte_nbytes;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> pktchain_elm pktchain_elm_t;

<span class="enscript-comment">/* Store upto PKTTBL_SZ unique flows on the stack */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PKTTBL_SZ</span>	7

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ip_chain_insert</span>(<span class="enscript-type">struct</span> mbuf *packet, pktchain_elm_t *tbl)
{
	<span class="enscript-type">struct</span> ip*	ip;
	<span class="enscript-type">int</span>		pkttbl_idx = 0;

	ip = mtod(packet, <span class="enscript-type">struct</span> ip*);

	<span class="enscript-comment">/* reusing the hash function from inaddr_hashval */</span>
	pkttbl_idx = inaddr_hashval(ntohs(ip-&gt;ip_src.s_addr)) % PKTTBL_SZ;
	<span class="enscript-keyword">if</span> (tbl[pkttbl_idx].pkte_head == NULL) {
		tbl[pkttbl_idx].pkte_head = packet;
		tbl[pkttbl_idx].pkte_saddr.s_addr = ip-&gt;ip_src.s_addr;
		tbl[pkttbl_idx].pkte_daddr.s_addr = ip-&gt;ip_dst.s_addr;
		tbl[pkttbl_idx].pkte_proto = ip-&gt;ip_p;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((ip-&gt;ip_dst.s_addr == tbl[pkttbl_idx].pkte_daddr.s_addr) &amp;&amp;
		    (ip-&gt;ip_src.s_addr == tbl[pkttbl_idx].pkte_saddr.s_addr) &amp;&amp;
		    (ip-&gt;ip_p == tbl[pkttbl_idx].pkte_proto)) {
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> (packet);
		}
	}
	<span class="enscript-keyword">if</span> (tbl[pkttbl_idx].pkte_tail != NULL)
		mbuf_setnextpkt(tbl[pkttbl_idx].pkte_tail, packet);

	tbl[pkttbl_idx].pkte_tail = packet;
	tbl[pkttbl_idx].pkte_npkts += 1;
	tbl[pkttbl_idx].pkte_nbytes += packet-&gt;m_pkthdr.len;
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/* args is a dummy variable here for backward compatibility */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_second_pass_loop_tbl</span>(pktchain_elm_t *tbl, <span class="enscript-type">struct</span> ip_fw_in_args *args)
{
	<span class="enscript-type">int</span> i = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; PKTTBL_SZ; i++) {
		<span class="enscript-keyword">if</span> (tbl[i].pkte_head != NULL) {
			<span class="enscript-type">struct</span> mbuf *m = tbl[i].pkte_head;
			ip_input_second_pass(m, m-&gt;m_pkthdr.rcvif, 0,
			    tbl[i].pkte_npkts, tbl[i].pkte_nbytes, args, 0);

			<span class="enscript-keyword">if</span> (tbl[i].pkte_npkts &gt; 2)
				ipstat.ips_rxc_chainsz_gt2++;
			<span class="enscript-keyword">if</span> (tbl[i].pkte_npkts &gt; 4)
				ipstat.ips_rxc_chainsz_gt4++;

			<span class="enscript-keyword">if</span> (ip_input_measure)
				net_perf_histogram(&amp;net_perf, tbl[i].pkte_npkts);

			tbl[i].pkte_head = tbl[i].pkte_tail = NULL;
			tbl[i].pkte_npkts = 0;
			tbl[i].pkte_nbytes = 0;
			<span class="enscript-comment">/* no need to initialize address and protocol in tbl */</span>
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_cpout_args</span>(<span class="enscript-type">struct</span> ip_fw_in_args *args, <span class="enscript-type">struct</span> ip_fw_args *args1,
    boolean_t *done_init)
{
	<span class="enscript-keyword">if</span> (*done_init == FALSE) {
		bzero(args1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip_fw_args));
		*done_init = TRUE;
	}
	args1-&gt;fwa_next_hop = args-&gt;fwai_next_hop;
	args1-&gt;fwa_ipfw_rule = args-&gt;fwai_ipfw_rule;
	args1-&gt;fwa_pf_rule = args-&gt;fwai_pf_rule;
	args1-&gt;fwa_divert_rule = args-&gt;fwai_divert_rule;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_cpin_args</span>(<span class="enscript-type">struct</span> ip_fw_args *args1, <span class="enscript-type">struct</span> ip_fw_in_args *args)
{
	args-&gt;fwai_next_hop = args1-&gt;fwa_next_hop;
	args-&gt;fwai_ipfw_rule = args1-&gt;fwa_ipfw_rule;
	args-&gt;fwai_pf_rule = args1-&gt;fwa_pf_rule;
	args-&gt;fwai_divert_rule = args1-&gt;fwa_divert_rule;
}

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	IPINPUT_DOCHAIN = 0,
	IPINPUT_DONTCHAIN,
	IPINPUT_FREED,
	IPINPUT_DONE
} ipinput_chain_ret_t;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_update_nstat</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in_addr src_ip,
    u_int32_t packets, u_int32_t bytes)
{
	<span class="enscript-keyword">if</span> (nstat_collect) {
		<span class="enscript-type">struct</span> rtentry *rt = ifnet_cached_rtlookup_inet(ifp,
		    src_ip);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			nstat_route_rx(rt, packets, bytes, 0);
			rtfree(rt);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_dispatch_chain</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *tmp_mbuf = m;
	<span class="enscript-type">struct</span> mbuf *nxt_mbuf = NULL;
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hlen;

	ip = mtod(tmp_mbuf, <span class="enscript-type">struct</span> ip *);
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	<span class="enscript-keyword">while</span>(tmp_mbuf) {
		nxt_mbuf = mbuf_nextpkt(tmp_mbuf);
		mbuf_setnextpkt(tmp_mbuf, NULL);

		<span class="enscript-keyword">if</span> ((sw_lro) &amp;&amp; (ip-&gt;ip_p == IPPROTO_TCP))
			tmp_mbuf = tcp_lro(tmp_mbuf, hlen);
		<span class="enscript-keyword">if</span> (tmp_mbuf)
			ip_proto_dispatch_in(tmp_mbuf, hlen, ip-&gt;ip_p, 0);
		tmp_mbuf = nxt_mbuf;
		<span class="enscript-keyword">if</span> (tmp_mbuf) {
			ip = mtod(tmp_mbuf, <span class="enscript-type">struct</span> ip *);
			<span class="enscript-comment">/* first mbuf of chain already has adjusted ip_len */</span>
			hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
			ip-&gt;ip_len -= hlen;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_setdst_chain</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t ifindex, <span class="enscript-type">struct</span> in_ifaddr *ia)
{
	<span class="enscript-type">struct</span> mbuf *tmp_mbuf = m;

	<span class="enscript-keyword">while</span> (tmp_mbuf) {
		ip_setdstifaddr_info(tmp_mbuf, ifindex, ia);
		tmp_mbuf = mbuf_nextpkt(tmp_mbuf);
	}
}

<span class="enscript-comment">/*
 * First pass does all essential packet validation and places on a per flow
 * queue for doing operations that have same outcome for all packets of a flow.
 * div_info is packet divert/tee info
 */</span>
<span class="enscript-type">static</span> ipinput_chain_ret_t
<span class="enscript-function-name">ip_input_first_pass</span>(<span class="enscript-type">struct</span> mbuf *m, u_int32_t *div_info,
    <span class="enscript-type">struct</span> ip_fw_in_args *args, <span class="enscript-type">int</span> *ours, <span class="enscript-type">struct</span> mbuf **modm)
{
	<span class="enscript-type">struct</span> ip	*ip;
	<span class="enscript-type">struct</span> ifnet	*inifp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	hlen;
	<span class="enscript-type">int</span>		retval = IPINPUT_DOCHAIN;
	<span class="enscript-type">int</span>		len = 0;
	<span class="enscript-type">struct</span> in_addr	src_ip;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-type">int</span>		i;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> m_tag		*copy;
	<span class="enscript-type">struct</span> m_tag		*p;
	boolean_t		delete = FALSE;
	<span class="enscript-type">struct</span> ip_fw_args	args1;
	boolean_t		init = FALSE;
#<span class="enscript-reference">endif</span>
	ipfilter_t inject_filter_ref = NULL;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">args</span>)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPDIVERT</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">div_info</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">ours</span>)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">ours</span>)
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Check if the mbuf is still valid after interface filter processing */</span>
	MBUF_INPUT_CHECK(m, m-&gt;m_pkthdr.rcvif);
	inifp = mbuf_pkthdr_rcvif(m);
	VERIFY(inifp != NULL);

	<span class="enscript-comment">/* Perform IP header alignment fixup, if needed */</span>
	IP_HDR_ALIGNMENT_FIXUP(m, inifp, <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>);

	m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_FORWARDED;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>

	<span class="enscript-comment">/*
	 * Don't bother searching for tag(s) if there's none.
	 */</span>
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ipfw_tags_done</span>;

	<span class="enscript-comment">/* Grab info from mtags prepended to the chain */</span>
	p = m_tag_first(m);
	<span class="enscript-keyword">while</span> (p) {
		<span class="enscript-keyword">if</span> (p-&gt;m_tag_id == KERNEL_MODULE_TAG_ID) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
			<span class="enscript-keyword">if</span> (p-&gt;m_tag_type == KERNEL_TAG_TYPE_DUMMYNET) {
				<span class="enscript-type">struct</span> dn_pkt_tag *dn_tag;

				dn_tag = (<span class="enscript-type">struct</span> dn_pkt_tag *)(p+1);
				args-&gt;fwai_ipfw_rule = dn_tag-&gt;dn_ipfw_rule;
				args-&gt;fwai_pf_rule = dn_tag-&gt;dn_pf_rule;
				delete = TRUE;
			}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
			<span class="enscript-keyword">if</span> (p-&gt;m_tag_type == KERNEL_TAG_TYPE_DIVERT) {
				<span class="enscript-type">struct</span> divert_tag *div_tag;

				div_tag = (<span class="enscript-type">struct</span> divert_tag *)(p+1);
				args-&gt;fwai_divert_rule = div_tag-&gt;cookie;
				delete = TRUE;
			}
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (p-&gt;m_tag_type == KERNEL_TAG_TYPE_IPFORWARD) {
				<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag;

				ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(p+1);
				args-&gt;fwai_next_hop = ipfwd_tag-&gt;next_hop;
				delete = TRUE;
			}

			<span class="enscript-keyword">if</span> (delete) {
				copy = p;
				p = m_tag_next(m, p);
				m_tag_delete(m, copy);
			} <span class="enscript-keyword">else</span>	{
				p = m_tag_next(m, p);
			}
		} <span class="enscript-keyword">else</span> {
			p = m_tag_next(m, p);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		panic(<span class="enscript-string">&quot;ip_input no HDR&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (args-&gt;fwai_ipfw_rule || args-&gt;fwai_pf_rule) {
		<span class="enscript-comment">/* dummynet already filtered us */</span>
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
		inject_filter_ref = ipf_get_inject_filter(m);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		<span class="enscript-keyword">if</span> (args-&gt;fwai_ipfw_rule)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">iphack</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
		<span class="enscript-keyword">if</span> (args-&gt;fwai_pf_rule)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_with_pf</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
<span class="enscript-reference">ipfw_tags_done</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL || DUMMYNET */</span>

	<span class="enscript-comment">/*
	 * No need to process packet twice if we've already seen it.
	 */</span>
	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		inject_filter_ref = ipf_get_inject_filter(m);
	<span class="enscript-keyword">if</span> (inject_filter_ref != NULL) {
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;

		DTRACE_IP6(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
		    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, inifp,
		    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

		ip-&gt;ip_len = ntohs(ip-&gt;ip_len) - hlen;
		ip-&gt;ip_off = ntohs(ip-&gt;ip_off);
		ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, inject_filter_ref);
		<span class="enscript-keyword">return</span> (IPINPUT_DONE);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_tooshort);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))) == NULL) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_toosmall);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	*modm = m;

	KERNEL_DEBUG(DBG_LAYER_BEG, ip-&gt;ip_dst.s_addr, ip-&gt;ip_src.s_addr,
	    ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

	<span class="enscript-keyword">if</span> (IP_VHL_V(ip-&gt;ip_vhl) != IPVERSION) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_badvers);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (hlen &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_badhlen);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	<span class="enscript-keyword">if</span> (hlen &gt; m-&gt;m_len) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, hlen)) == NULL) {
			OSAddAtomic(1, &amp;ipstat.ips_total);
			OSAddAtomic(1, &amp;ipstat.ips_badhlen);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		*modm = m;
	}

	<span class="enscript-comment">/* 127/8 must not appear on wire - RFC1122 */</span>
	<span class="enscript-keyword">if</span> ((ntohl(ip-&gt;ip_dst.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
	    (ntohl(ip-&gt;ip_src.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
		<span class="enscript-comment">/*
		 * Allow for the following exceptions:
		 *
		 *   1. If the packet was sent to loopback (i.e. rcvif
		 *      would have been set earlier at output time.)
		 *
		 *   2. If the packet was sent out on loopback from a local
		 *      source address which belongs to a non-loopback
		 *      interface (i.e. rcvif may not necessarily be a
		 *      loopback interface, hence the test for PKTF_LOOP.)
		 *      Unlike IPv6, there is no interface scope ID, and
		 *      therefore we don't care so much about PKTF_IFINFO.
		 */</span>
		<span class="enscript-keyword">if</span> (!(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		     !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
			OSAddAtomic(1, &amp;ipstat.ips_total);
			OSAddAtomic(1, &amp;ipstat.ips_badaddr);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			m_freem(m);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
	}

	<span class="enscript-comment">/* IPv4 Link-Local Addresses as defined in RFC3927 */</span>
	<span class="enscript-keyword">if</span> ((IN_LINKLOCAL(ntohl(ip-&gt;ip_dst.s_addr)) ||
	    IN_LINKLOCAL(ntohl(ip-&gt;ip_src.s_addr)))) {
		ip_linklocal_stat.iplls_in_total++;
		<span class="enscript-keyword">if</span> (ip-&gt;ip_ttl != MAXTTL) {
			OSAddAtomic(1, &amp;ip_linklocal_stat.iplls_in_badttl);
			<span class="enscript-comment">/* Silently drop link local traffic with bad TTL */</span>
			<span class="enscript-keyword">if</span> (!ip_linklocal_in_allowbadttl) {
				OSAddAtomic(1, &amp;ipstat.ips_total);
				KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
				m_freem(m);
				<span class="enscript-keyword">return</span> (IPINPUT_FREED);
			}
		}
	}

	<span class="enscript-keyword">if</span> (ip_cksum(m, hlen)) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	DTRACE_IP6(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, inifp,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

	<span class="enscript-comment">/*
	 * Convert fields to host representation.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ip-&gt;ip_len &lt; hlen) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_badlen);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IP header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; ip-&gt;ip_len) {
		OSAddAtomic(1, &amp;ipstat.ips_total);
		OSAddAtomic(1, &amp;ipstat.ips_tooshort);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; ip-&gt;ip_len) {
		<span class="enscript-comment">/*
		 * Invalidate hardware checksum info if ip_adj_clear_hwcksum
		 * is set; useful to handle buggy drivers.  Note that this
		 * should not be enabled by default, as we may get here due
		 * to link-layer padding.
		 */</span>
		<span class="enscript-keyword">if</span> (ip_adj_clear_hwcksum &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID) &amp;&amp;
		    !(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
			m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DATA_VALID;
			m-&gt;m_pkthdr.csum_data = 0;
			ipstat.ips_adj_hwcsum_clr++;
		}

		ipstat.ips_adj++;
		<span class="enscript-keyword">if</span> (m-&gt;m_len == m-&gt;m_pkthdr.len) {
			m-&gt;m_len = ip-&gt;ip_len;
			m-&gt;m_pkthdr.len = ip-&gt;ip_len;
		} <span class="enscript-keyword">else</span>
			m_adj(m, ip-&gt;ip_len - m-&gt;m_pkthdr.len);
	}

	<span class="enscript-comment">/* for consistency */</span>
	m-&gt;m_pkthdr.pkt_proto = ip-&gt;ip_p;

	<span class="enscript-comment">/* for netstat route statistics */</span>
	src_ip = ip-&gt;ip_src;
	len = m-&gt;m_pkthdr.len;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">check_with_pf</span>:
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Invoke inbound packet filter */</span>
	<span class="enscript-keyword">if</span> (PF_IS_ENABLED) {
		<span class="enscript-type">int</span> error;
		ip_input_cpout_args(args, &amp;args1, &amp;init);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET, TRUE, &amp;args1);
#<span class="enscript-reference">else</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET, TRUE, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-keyword">if</span> (error != 0 || m == NULL) {
			<span class="enscript-keyword">if</span> (m != NULL) {
				panic(<span class="enscript-string">&quot;%s: unexpected packet %p\n&quot;</span>,
				    __func__, m);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-comment">/* Already freed by callee */</span>
			ip_input_update_nstat(inifp, src_ip, 1, len);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			OSAddAtomic(1, &amp;ipstat.ips_total);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
		*modm = m;
		ip_input_cpin_args(&amp;args1, args);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; ipsec_gethist(m, NULL)) {
		retval = IPINPUT_DONTCHAIN; <span class="enscript-comment">/* XXX scope for chaining here? */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">iphack</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	<span class="enscript-comment">/*
	 * Check if we want to allow this packet to be processed.
	 * Consider it to be bad if not.
	 */</span>
	<span class="enscript-keyword">if</span> (fw_enable &amp;&amp; IPFW_LOADED) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-comment">/*
		 * If we've been forwarded from the output side, then
		 * skip the firewall a second time
		 */</span>
		<span class="enscript-keyword">if</span> (args-&gt;fwai_next_hop) {
			*ours = 1;
			<span class="enscript-keyword">return</span> (IPINPUT_DONTCHAIN);
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>
		ip_input_cpout_args(args, &amp;args1, &amp;init);
		args1.fwa_m = m;

		i = ip_fw_chk_ptr(&amp;args1);
		m = args1.fwa_m;

		<span class="enscript-keyword">if</span> ((i &amp; IP_FW_PORT_DENY_FLAG) || m == NULL) { <span class="enscript-comment">/* drop */</span>
			<span class="enscript-keyword">if</span> (m)
				m_freem(m);
			ip_input_update_nstat(inifp, src_ip, 1, len);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			OSAddAtomic(1, &amp;ipstat.ips_total);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *); <span class="enscript-comment">/* just in case m changed */</span>
		*modm = m;
		ip_input_cpin_args(&amp;args1, args);

		<span class="enscript-keyword">if</span> (i == 0 &amp;&amp; args-&gt;fwai_next_hop == NULL) { <span class="enscript-comment">/* common case */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-keyword">if</span> (DUMMYNET_LOADED &amp;&amp; (i &amp; IP_FW_PORT_DYNT_FLAG) != 0) {
			<span class="enscript-comment">/* Send packet to the appropriate pipe */</span>
			ip_dn_io_ptr(m, i&amp;0xffff, DN_TO_IP_IN, &amp;args1,
			    DN_CLIENT_IPFW);
			ip_input_update_nstat(inifp, src_ip, 1, len);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			OSAddAtomic(1, &amp;ipstat.ips_total);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-keyword">if</span> (i != 0 &amp;&amp; (i &amp; IP_FW_PORT_DYNT_FLAG) == 0) {
			<span class="enscript-comment">/* Divert or tee packet */</span>
			*div_info = i;
			*ours = 1;
			<span class="enscript-keyword">return</span> (IPINPUT_DONTCHAIN);
		}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-keyword">if</span> (i == 0 &amp;&amp; args-&gt;fwai_next_hop != NULL) {
			retval = IPINPUT_DONTCHAIN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * if we get here, the packet must be dropped
		 */</span>
		ip_input_update_nstat(inifp, src_ip, 1, len);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		m_freem(m);
		OSAddAtomic(1, &amp;ipstat.ips_total);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span> | <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-reference">pass</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Process options and, if not destined for us,
	 * ship it on.  ip_dooptions returns 1 when an
	 * error was detected (causing an icmp message
	 * to be sent and the original packet to be freed).
	 */</span>
	ip_nhops = 0;		<span class="enscript-comment">/* for source routed packets */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    ip_dooptions(m, 0, args-&gt;fwai_next_hop)) {
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp; ip_dooptions(m, 0, NULL)) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
		ip_input_update_nstat(inifp, src_ip, 1, len);
		KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
		OSAddAtomic(1, &amp;ipstat.ips_total);
		<span class="enscript-keyword">return</span> (IPINPUT_FREED);
	}

	<span class="enscript-comment">/*
	 * Don't chain fragmented packets as the process of determining
	 * if it is our fragment or someone else's plus the complexity of
	 * divert and fw args makes it harder to do chaining.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_off &amp; ~(IP_DF | IP_RF))
		<span class="enscript-keyword">return</span> (IPINPUT_DONTCHAIN);

	<span class="enscript-comment">/* Allow DHCP/BootP responses through */</span>
	<span class="enscript-keyword">if</span> ((inifp-&gt;if_eflags &amp; IFEF_AUTOCONFIGURING) &amp;&amp;
	    hlen == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp; ip-&gt;ip_p == IPPROTO_UDP) {
		<span class="enscript-type">struct</span> udpiphdr *ui;

		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr) &amp;&amp;
		    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr))) == NULL) {
			OSAddAtomic(1, &amp;udpstat.udps_hdrops);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			OSAddAtomic(1, &amp;ipstat.ips_total);
			<span class="enscript-keyword">return</span> (IPINPUT_FREED);
		}
		*modm = m;
		ui = mtod(m, <span class="enscript-type">struct</span> udpiphdr *);
		<span class="enscript-keyword">if</span> (ntohs(ui-&gt;ui_dport) == IPPORT_BOOTPC) {
			ip_setdstifaddr_info(m, inifp-&gt;if_index, NULL);
			<span class="enscript-keyword">return</span> (IPINPUT_DONTCHAIN);
		}
	}

	<span class="enscript-comment">/* Avoid chaining raw sockets as ipsec checks occur later for them */</span>
	<span class="enscript-keyword">if</span> (ip_protox[ip-&gt;ip_p]-&gt;pr_flags &amp; PR_LASTHDR)
		<span class="enscript-keyword">return</span> (IPINPUT_DONTCHAIN);

	<span class="enscript-keyword">return</span> (retval);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span> (IPINPUT_FREED);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_second_pass</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *inifp, u_int32_t div_info,
    <span class="enscript-type">int</span> npkts_in_chain, <span class="enscript-type">int</span> bytes_in_chain, <span class="enscript-type">struct</span> ip_fw_in_args *args, <span class="enscript-type">int</span> ours)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		checkif;
	<span class="enscript-type">struct</span> mbuf		*tmp_mbuf = NULL;
	<span class="enscript-type">struct</span> in_ifaddr	*ia = NULL;
	<span class="enscript-type">struct</span> in_addr		pkt_dst;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		hlen;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">args</span>)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPDIVERT</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">div_info</span>)
#<span class="enscript-reference">endif</span>

	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;

	OSAddAtomic(npkts_in_chain, &amp;ipstat.ips_total);

	<span class="enscript-comment">/*
	 * Naively assume we can attribute inbound data to the route we would
	 * use to send to this destination. Asymmetric routing breaks this
	 * assumption, but it still allows us to account for traffic from
	 * a remote node in the routing table.
	 * this has a very significant performance impact so we bypass
	 * if nstat_collect is disabled. We may also bypass if the
	 * protocol is tcp in the future because tcp will have a route that
	 * we can use to attribute the data to. That does mean we would not
	 * account for forwarded tcp traffic.
	 */</span>
	ip_input_update_nstat(inifp, ip-&gt;ip_src, npkts_in_chain,
	    bytes_in_chain);

	<span class="enscript-keyword">if</span> (ours)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;

	<span class="enscript-comment">/*
	 * Check our list of addresses, to see if the packet is for us.
	 * If we don't have any addresses, assume any unicast packet
	 * we receive might be for us (and let the upper layers deal
	 * with it).
	 */</span>
	tmp_mbuf = m;
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;in_ifaddrhead)) {
		<span class="enscript-keyword">while</span> (tmp_mbuf) {
			<span class="enscript-keyword">if</span> (!(tmp_mbuf-&gt;m_flags &amp; (M_MCAST|M_BCAST))) {
				ip_setdstifaddr_info(tmp_mbuf, inifp-&gt;if_index,
				    NULL);
			}
			tmp_mbuf = mbuf_nextpkt(tmp_mbuf);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}
	<span class="enscript-comment">/*
	 * Cache the destination address of the packet; this may be
	 * changed by use of 'ipfw fwd'.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	pkt_dst = args-&gt;fwai_next_hop == NULL ?
	    ip-&gt;ip_dst : args-&gt;fwai_next_hop-&gt;sin_addr;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	pkt_dst = ip-&gt;ip_dst;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

	<span class="enscript-comment">/*
	 * Enable a consistency check between the destination address
	 * and the arrival interface for a unicast packet (the RFC 1122
	 * strong ES model) if IP forwarding is disabled and the packet
	 * is not locally generated and the packet is not subject to
	 * 'ipfw fwd'.
	 *
	 * XXX - Checking also should be disabled if the destination
	 * address is ipnat'ed to a different interface.
	 *
	 * XXX - Checking is incompatible with IP aliases added
	 * to the loopback interface instead of the interface where
	 * the packets are received.
	 */</span>
	checkif = ip_checkinterface &amp;&amp; (ipforwarding == 0) &amp;&amp;
	    !(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	    &amp;&amp; (args-&gt;fwai_next_hop == NULL);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
		;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

	<span class="enscript-comment">/*
	 * Check for exact addresses in the hash bucket.
	 */</span>
	lck_rw_lock_shared(in_ifaddr_rwlock);
	TAILQ_FOREACH(ia, INADDR_HASH(pkt_dst.s_addr), ia_hash) {
		<span class="enscript-comment">/*
		 * If the address matches, verify that the packet
		 * arrived via the correct interface if checking is
		 * enabled.
		 */</span>
		<span class="enscript-keyword">if</span> (IA_SIN(ia)-&gt;sin_addr.s_addr == pkt_dst.s_addr &amp;&amp;
		    (!checkif || ia-&gt;ia_ifp == inifp)) {
			ip_input_setdst_chain(m, 0, ia);
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
		}
	}
	lck_rw_done(in_ifaddr_rwlock);

	<span class="enscript-comment">/*
	 * Check for broadcast addresses.
	 *
	 * Only accept broadcast packets that arrive via the matching
	 * interface.  Reception of forwarded directed broadcasts would be
	 * handled via ip_forward() and ether_frameout() with the loopback
	 * into the stack for SIMPLEX interfaces handled by ether_frameout().
	 */</span>
	<span class="enscript-keyword">if</span> (inifp-&gt;if_flags &amp; IFF_BROADCAST) {
		<span class="enscript-type">struct</span> ifaddr *ifa;

		ifnet_lock_shared(inifp);
		TAILQ_FOREACH(ifa, &amp;inifp-&gt;if_addrhead, ifa_link) {
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {
				<span class="enscript-keyword">continue</span>;
			}
			ia = ifatoia(ifa);
			<span class="enscript-keyword">if</span> (satosin(&amp;ia-&gt;ia_broadaddr)-&gt;sin_addr.s_addr ==
			    pkt_dst.s_addr || ia-&gt;ia_netbroadcast.s_addr ==
			    pkt_dst.s_addr) {
				ip_input_setdst_chain(m, 0, ia);
				ifnet_lock_done(inifp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
			}
		}
		ifnet_lock_done(inifp);
	}

	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr))) {
		<span class="enscript-type">struct</span> in_multi *inm;
		<span class="enscript-comment">/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */</span>
		in_multihead_lock_shared();
		IN_LOOKUP_MULTI(&amp;ip-&gt;ip_dst, inifp, inm);
		in_multihead_lock_done();
		<span class="enscript-keyword">if</span> (inm == NULL) {
			OSAddAtomic(npkts_in_chain, &amp;ipstat.ips_notmember);
			m_freem_list(m);
			KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
			<span class="enscript-keyword">return</span>;
		}
		ip_input_setdst_chain(m, inifp-&gt;if_index, NULL);
		INM_REMREF(inm);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}

	<span class="enscript-keyword">if</span> (ip-&gt;ip_dst.s_addr == (u_int32_t)INADDR_BROADCAST ||
	    ip-&gt;ip_dst.s_addr == INADDR_ANY) {
		ip_input_setdst_chain(m, inifp-&gt;if_index, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}

	<span class="enscript-keyword">if</span> (ip-&gt;ip_p == IPPROTO_UDP) {
		<span class="enscript-type">struct</span> udpiphdr *ui;
		ui = mtod(m, <span class="enscript-type">struct</span> udpiphdr *);
		<span class="enscript-keyword">if</span> (ntohs(ui-&gt;ui_dport) == IPPORT_BOOTPC) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
		}
	}

	tmp_mbuf = m;
	<span class="enscript-type">struct</span> mbuf *nxt_mbuf = NULL;
	<span class="enscript-keyword">while</span> (tmp_mbuf) {
		nxt_mbuf = mbuf_nextpkt(tmp_mbuf);
		<span class="enscript-comment">/*
		 * Not for us; forward if possible and desirable.
		 */</span>
		mbuf_setnextpkt(tmp_mbuf, NULL);
		<span class="enscript-keyword">if</span> (ipforwarding == 0) {
			OSAddAtomic(1, &amp;ipstat.ips_cantforward);
			m_freem(tmp_mbuf);
		} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
			ip_forward(tmp_mbuf, 0, args-&gt;fwai_next_hop);
#<span class="enscript-reference">else</span>
			ip_forward(tmp_mbuf, 0, NULL);
#<span class="enscript-reference">endif</span>
		}
		tmp_mbuf = nxt_mbuf;
	}
	KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">ours</span>:
	<span class="enscript-comment">/*
	 * If offset or IP_MF are set, must reassemble.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_off &amp; ~(IP_DF | IP_RF)) {
		VERIFY(npkts_in_chain == 1);
		<span class="enscript-comment">/*
		 * ip_reass() will return a different mbuf, and update
		 * the divert info in div_info and args-&gt;fwai_divert_rule.
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		m = ip_reass(m, (u_int16_t *)&amp;div_info, &amp;args-&gt;fwai_divert_rule);
#<span class="enscript-reference">else</span>
		m = ip_reass(m);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-comment">/* Get the header length of the reassembled packet */</span>
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-comment">/* Restore original checksum before diverting packet */</span>
		<span class="enscript-keyword">if</span> (div_info != 0) {
			VERIFY(npkts_in_chain == 1);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			HTONS(ip-&gt;ip_len);
			HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
			ip-&gt;ip_sum = 0;
			ip-&gt;ip_sum = ip_cksum_hdr_in(m, hlen);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			NTOHS(ip-&gt;ip_off);
			NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>
		}
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/*
	 * Further protocols expect the packet length to be w/o the
	 * IP header.
	 */</span>
	ip-&gt;ip_len -= hlen;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-comment">/*
	 * Divert or tee packet to the divert protocol if required.
	 *
	 * If div_info is zero then cookie should be too, so we shouldn't
	 * need to clear them here.  Assume divert_packet() does so also.
	 */</span>
	<span class="enscript-keyword">if</span> (div_info != 0) {
		<span class="enscript-type">struct</span> mbuf *clone = NULL;
		VERIFY(npkts_in_chain == 1);

		<span class="enscript-comment">/* Clone packet if we're doing a 'tee' */</span>
		<span class="enscript-keyword">if</span> (div_info &amp; IP_FW_PORT_TEE_FLAG)
			clone = m_dup(m, M_DONTWAIT);

		<span class="enscript-comment">/* Restore packet header fields to original values */</span>
		ip-&gt;ip_len += hlen;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
		HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Deliver packet to divert input routine */</span>
		OSAddAtomic(1, &amp;ipstat.ips_delivered);
		divert_packet(m, 1, div_info &amp; 0xffff, args-&gt;fwai_divert_rule);

		<span class="enscript-comment">/* If 'tee', continue with original packet */</span>
		<span class="enscript-keyword">if</span> (clone == NULL) {
			<span class="enscript-keyword">return</span>;
		}
		m = clone;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * enforce IPsec policy checking if we are seeing last header.
	 * note that we do not visit this with protocols with pcb layer
	 * code - like udp/tcp/raw ip.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; (ip_protox[ip-&gt;ip_p]-&gt;pr_flags &amp; PR_LASTHDR)) {
		VERIFY(npkts_in_chain == 1);
		<span class="enscript-keyword">if</span> (ipsec4_in_reject(m, NULL)) {
			IPSEC_STAT_INCREMENT(ipsecstat.in_polvio);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Switch out to protocol's input routine.
	 */</span>
	OSAddAtomic(npkts_in_chain, &amp;ipstat.ips_delivered);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> (args-&gt;fwai_next_hop &amp;&amp; ip-&gt;ip_p == IPPROTO_TCP) {
		<span class="enscript-comment">/* TCP needs IPFORWARD info if available */</span>
		<span class="enscript-type">struct</span> m_tag *fwd_tag;
		<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag;

		VERIFY(npkts_in_chain == 1);
		fwd_tag = m_tag_create(KERNEL_MODULE_TAG_ID,
		    KERNEL_TAG_TYPE_IPFORWARD, <span class="enscript-keyword">sizeof</span> (*ipfwd_tag),
		    M_NOWAIT, m);
		<span class="enscript-keyword">if</span> (fwd_tag == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(fwd_tag+1);
		ipfwd_tag-&gt;next_hop = args-&gt;fwai_next_hop;

		m_tag_prepend(m, fwd_tag);

		KERNEL_DEBUG(DBG_LAYER_END, ip-&gt;ip_dst.s_addr,
		    ip-&gt;ip_src.s_addr, ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

		<span class="enscript-comment">/* TCP deals with its own locking */</span>
		ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, 0);
	} <span class="enscript-keyword">else</span> {
		KERNEL_DEBUG(DBG_LAYER_END, ip-&gt;ip_dst.s_addr,
		    ip-&gt;ip_src.s_addr, ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

		ip_input_dispatch_chain(m);

	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	ip_input_dispatch_chain(m);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">bad</span>:
	KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
	m_freem(m);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input_process_list</span>(<span class="enscript-type">struct</span> mbuf *packet_list)
{
	pktchain_elm_t	pktchain_tbl[PKTTBL_SZ];

	<span class="enscript-type">struct</span> mbuf	*packet = NULL;
	<span class="enscript-type">struct</span> mbuf	*modm = NULL; <span class="enscript-comment">/* modified mbuf */</span>
	<span class="enscript-type">int</span>		retval = 0;
	u_int32_t	div_info = 0;
	<span class="enscript-type">int</span>		ours = 0;
	<span class="enscript-type">struct</span> timeval start_tv;
	<span class="enscript-type">int</span>	num_pkts = 0;
	<span class="enscript-type">int</span> chain = 0;
	<span class="enscript-type">struct</span> ip_fw_in_args       args;

	<span class="enscript-keyword">if</span> (ip_chaining == 0) {
		<span class="enscript-type">struct</span> mbuf *m = packet_list;
		<span class="enscript-keyword">if</span> (ip_input_measure)
			net_perf_start_time(&amp;net_perf, &amp;start_tv);
		<span class="enscript-keyword">while</span> (m) {
			packet_list = mbuf_nextpkt(m);
			mbuf_setnextpkt(m, NULL);
			ip_input(m);
			m = packet_list;
			num_pkts++;
		}
		<span class="enscript-keyword">if</span> (ip_input_measure)
			net_perf_measure_time(&amp;net_perf, &amp;start_tv, num_pkts);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (ip_input_measure)
		net_perf_start_time(&amp;net_perf, &amp;start_tv);

	bzero(&amp;pktchain_tbl, <span class="enscript-keyword">sizeof</span>(pktchain_tbl));
<span class="enscript-reference">restart_list_process</span>:
	chain = 0;
	<span class="enscript-keyword">for</span> (packet = packet_list; packet; packet = packet_list) {
		packet_list = mbuf_nextpkt(packet);
		mbuf_setnextpkt(packet, NULL);

		num_pkts++;
		modm = NULL;
		div_info = 0;
		bzero(&amp;args, <span class="enscript-keyword">sizeof</span> (args));

		retval = ip_input_first_pass(packet, &amp;div_info, &amp;args,
		    &amp;ours, &amp;modm);

		<span class="enscript-keyword">if</span> (retval == IPINPUT_DOCHAIN) {
			<span class="enscript-keyword">if</span> (modm)
				packet = modm;
			packet = ip_chain_insert(packet, &amp;pktchain_tbl[0]);
			<span class="enscript-keyword">if</span> (packet == NULL) {
				ipstat.ips_rxc_chained++;
				chain++;
				<span class="enscript-keyword">if</span> (chain &gt; ip_chainsz)
					<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				ipstat.ips_rxc_collisions++;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval == IPINPUT_DONTCHAIN) {
			<span class="enscript-comment">/* in order to preserve order, exit from chaining */</span>
			<span class="enscript-keyword">if</span> (modm)
				packet = modm;
			ipstat.ips_rxc_notchain++;
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* packet was freed or delivered, do nothing. */</span>
		}
	}

	<span class="enscript-comment">/* do second pass here for pktchain_tbl */</span>
	<span class="enscript-keyword">if</span> (chain)
		ip_input_second_pass_loop_tbl(&amp;pktchain_tbl[0], &amp;args);

	<span class="enscript-keyword">if</span> (packet) {
		<span class="enscript-comment">/*
		 * equivalent update in chaining case if performed in
		 * ip_input_second_pass_loop_tbl().
		 */</span>
		<span class="enscript-keyword">if</span> (ip_input_measure)
			net_perf_histogram(&amp;net_perf, 1);

		ip_input_second_pass(packet, packet-&gt;m_pkthdr.rcvif, div_info,
		    1, packet-&gt;m_pkthdr.len, &amp;args, ours);
	}

	<span class="enscript-keyword">if</span> (packet_list)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart_list_process</span>;

	<span class="enscript-keyword">if</span> (ip_input_measure)
		net_perf_measure_time(&amp;net_perf, &amp;start_tv, num_pkts);
}
<span class="enscript-comment">/*
 * Ip input routine.  Checksum and byte swap header.  If fragmented
 * try to reassemble.  Process options.  Pass to next level.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_input</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> in_ifaddr *ia = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hlen, checkif;
	u_short sum = 0;
	<span class="enscript-type">struct</span> in_addr pkt_dst;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-type">int</span> i;
	u_int32_t div_info = 0;		<span class="enscript-comment">/* packet divert/tee info */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> ip_fw_args args;
	<span class="enscript-type">struct</span> m_tag	*tag;
#<span class="enscript-reference">endif</span>
	ipfilter_t inject_filter_ref = NULL;
	<span class="enscript-type">struct</span> ifnet *inifp;

	<span class="enscript-comment">/* Check if the mbuf is still valid after interface filter processing */</span>
	MBUF_INPUT_CHECK(m, m-&gt;m_pkthdr.rcvif);
	inifp = m-&gt;m_pkthdr.rcvif;
	VERIFY(inifp != NULL);

	ipstat.ips_rxc_notlist++;

	<span class="enscript-comment">/* Perform IP header alignment fixup, if needed */</span>
	IP_HDR_ALIGNMENT_FIXUP(m, inifp, <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>);

	m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_FORWARDED;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span> || <span class="enscript-variable-name">DUMMYNET</span>
	bzero(&amp;args, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip_fw_args));

	<span class="enscript-comment">/*
	 * Don't bother searching for tag(s) if there's none.
	 */</span>
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ipfw_tags_done</span>;

	<span class="enscript-comment">/* Grab info from mtags prepended to the chain */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DUMMYNET, NULL)) != NULL) {
		<span class="enscript-type">struct</span> dn_pkt_tag *dn_tag;

		dn_tag = (<span class="enscript-type">struct</span> dn_pkt_tag *)(tag+1);
		args.fwa_ipfw_rule = dn_tag-&gt;dn_ipfw_rule;
		args.fwa_pf_rule = dn_tag-&gt;dn_pf_rule;

		m_tag_delete(m, tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DIVERT, NULL)) != NULL) {
		<span class="enscript-type">struct</span> divert_tag *div_tag;

		div_tag = (<span class="enscript-type">struct</span> divert_tag *)(tag+1);
		args.fwa_divert_rule = div_tag-&gt;cookie;

		m_tag_delete(m, tag);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_IPFORWARD, NULL)) != NULL) {
		<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag;

		ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(tag+1);
		args.fwa_next_hop = ipfwd_tag-&gt;next_hop;

		m_tag_delete(m, tag);
	}

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		panic(<span class="enscript-string">&quot;ip_input no HDR&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (args.fwa_ipfw_rule || args.fwa_pf_rule) {
		<span class="enscript-comment">/* dummynet already filtered us */</span>
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
		inject_filter_ref = ipf_get_inject_filter(m);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		<span class="enscript-keyword">if</span> (args.fwa_ipfw_rule)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">iphack</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
		<span class="enscript-keyword">if</span> (args.fwa_pf_rule)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_with_pf</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
<span class="enscript-reference">ipfw_tags_done</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL || DUMMYNET */</span>

	<span class="enscript-comment">/*
	 * No need to process packet twice if we've already seen it.
	 */</span>
	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		inject_filter_ref = ipf_get_inject_filter(m);
	<span class="enscript-keyword">if</span> (inject_filter_ref != NULL) {
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;

		DTRACE_IP6(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
		    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, inifp,
		    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

		ip-&gt;ip_len = ntohs(ip-&gt;ip_len) - hlen;
		ip-&gt;ip_off = ntohs(ip-&gt;ip_off);
		ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, inject_filter_ref);
		<span class="enscript-keyword">return</span>;
	}

	OSAddAtomic(1, &amp;ipstat.ips_total);
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">tooshort</span>;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip))) == NULL) {
		OSAddAtomic(1, &amp;ipstat.ips_toosmall);
		<span class="enscript-keyword">return</span>;
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);

	KERNEL_DEBUG(DBG_LAYER_BEG, ip-&gt;ip_dst.s_addr, ip-&gt;ip_src.s_addr,
	    ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

	<span class="enscript-keyword">if</span> (IP_VHL_V(ip-&gt;ip_vhl) != IPVERSION) {
		OSAddAtomic(1, &amp;ipstat.ips_badvers);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	<span class="enscript-keyword">if</span> (hlen &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip)) {	<span class="enscript-comment">/* minimum header length */</span>
		OSAddAtomic(1, &amp;ipstat.ips_badhlen);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (hlen &gt; m-&gt;m_len) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, hlen)) == NULL) {
			OSAddAtomic(1, &amp;ipstat.ips_badhlen);
			<span class="enscript-keyword">return</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	}

	<span class="enscript-comment">/* 127/8 must not appear on wire - RFC1122 */</span>
	<span class="enscript-keyword">if</span> ((ntohl(ip-&gt;ip_dst.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
	    (ntohl(ip-&gt;ip_src.s_addr) &gt;&gt; IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
		<span class="enscript-comment">/*
		 * Allow for the following exceptions:
		 *
		 *   1. If the packet was sent to loopback (i.e. rcvif
		 *	would have been set earlier at output time.)
		 *
		 *   2. If the packet was sent out on loopback from a local
		 *	source address which belongs to a non-loopback
		 *	interface (i.e. rcvif may not necessarily be a
		 *	loopback interface, hence the test for PKTF_LOOP.)
		 *	Unlike IPv6, there is no interface scope ID, and
		 *	therefore we don't care so much about PKTF_IFINFO.
		 */</span>
		<span class="enscript-keyword">if</span> (!(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
			OSAddAtomic(1, &amp;ipstat.ips_badaddr);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-comment">/* IPv4 Link-Local Addresses as defined in RFC3927 */</span>
	<span class="enscript-keyword">if</span> ((IN_LINKLOCAL(ntohl(ip-&gt;ip_dst.s_addr)) ||
	    IN_LINKLOCAL(ntohl(ip-&gt;ip_src.s_addr)))) {
		ip_linklocal_stat.iplls_in_total++;
		<span class="enscript-keyword">if</span> (ip-&gt;ip_ttl != MAXTTL) {
			OSAddAtomic(1, &amp;ip_linklocal_stat.iplls_in_badttl);
			<span class="enscript-comment">/* Silently drop link local traffic with bad TTL */</span>
			<span class="enscript-keyword">if</span> (!ip_linklocal_in_allowbadttl)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	sum = ip_cksum(m, hlen);
	<span class="enscript-keyword">if</span> (sum) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	DTRACE_IP6(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ifnet *, inifp,
	    <span class="enscript-type">struct</span> ip *, ip, <span class="enscript-type">struct</span> ip6_hdr *, NULL);

	<span class="enscript-comment">/*
	 * Naively assume we can attribute inbound data to the route we would
	 * use to send to this destination. Asymmetric routing breaks this
	 * assumption, but it still allows us to account for traffic from
	 * a remote node in the routing table.
	 * this has a very significant performance impact so we bypass
	 * if nstat_collect is disabled. We may also bypass if the
	 * protocol is tcp in the future because tcp will have a route that
	 * we can use to attribute the data to. That does mean we would not
	 * account for forwarded tcp traffic.
	 */</span>
	<span class="enscript-keyword">if</span> (nstat_collect) {
		<span class="enscript-type">struct</span> rtentry *rt =
		    ifnet_cached_rtlookup_inet(inifp, ip-&gt;ip_src);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			nstat_route_rx(rt, 1, m-&gt;m_pkthdr.len, 0);
			rtfree(rt);
		}
	}

	<span class="enscript-comment">/*
	 * Convert fields to host representation.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (ip-&gt;ip_len &lt; hlen) {
		OSAddAtomic(1, &amp;ipstat.ips_badlen);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
	NTOHS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IP header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; ip-&gt;ip_len) {
<span class="enscript-reference">tooshort</span>:
		OSAddAtomic(1, &amp;ipstat.ips_tooshort);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; ip-&gt;ip_len) {
		<span class="enscript-comment">/*
		 * Invalidate hardware checksum info if ip_adj_clear_hwcksum
		 * is set; useful to handle buggy drivers.  Note that this
		 * should not be enabled by default, as we may get here due
		 * to link-layer padding.
		 */</span>
		<span class="enscript-keyword">if</span> (ip_adj_clear_hwcksum &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID) &amp;&amp;
		    !(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
			m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DATA_VALID;
			m-&gt;m_pkthdr.csum_data = 0;
			ipstat.ips_adj_hwcsum_clr++;
		}

		ipstat.ips_adj++;
		<span class="enscript-keyword">if</span> (m-&gt;m_len == m-&gt;m_pkthdr.len) {
			m-&gt;m_len = ip-&gt;ip_len;
			m-&gt;m_pkthdr.len = ip-&gt;ip_len;
		} <span class="enscript-keyword">else</span>
			m_adj(m, ip-&gt;ip_len - m-&gt;m_pkthdr.len);
	}

	<span class="enscript-comment">/* for consistency */</span>
	m-&gt;m_pkthdr.pkt_proto = ip-&gt;ip_p;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">check_with_pf</span>:
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Invoke inbound packet filter */</span>
	<span class="enscript-keyword">if</span> (PF_IS_ENABLED) {
		<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET, TRUE, &amp;args);
#<span class="enscript-reference">else</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET, TRUE, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
		<span class="enscript-keyword">if</span> (error != 0 || m == NULL) {
			<span class="enscript-keyword">if</span> (m != NULL) {
				panic(<span class="enscript-string">&quot;%s: unexpected packet %p\n&quot;</span>,
				    __func__, m);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-comment">/* Already freed by callee */</span>
			<span class="enscript-keyword">return</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; ipsec_gethist(m, NULL))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">iphack</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	<span class="enscript-comment">/*
	 * Check if we want to allow this packet to be processed.
	 * Consider it to be bad if not.
	 */</span>
	<span class="enscript-keyword">if</span> (fw_enable &amp;&amp; IPFW_LOADED) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-comment">/*
		 * If we've been forwarded from the output side, then
		 * skip the firewall a second time
		 */</span>
		<span class="enscript-keyword">if</span> (args.fwa_next_hop)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* IPFIREWALL_FORWARD */</span>

		args.fwa_m = m;

		i = ip_fw_chk_ptr(&amp;args);
		m = args.fwa_m;

		<span class="enscript-keyword">if</span> ((i &amp; IP_FW_PORT_DENY_FLAG) || m == NULL) { <span class="enscript-comment">/* drop */</span>
			<span class="enscript-keyword">if</span> (m)
				m_freem(m);
			<span class="enscript-keyword">return</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *); <span class="enscript-comment">/* just in case m changed */</span>

		<span class="enscript-keyword">if</span> (i == 0 &amp;&amp; args.fwa_next_hop == NULL) { <span class="enscript-comment">/* common case */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-keyword">if</span> (DUMMYNET_LOADED &amp;&amp; (i &amp; IP_FW_PORT_DYNT_FLAG) != 0) {
			<span class="enscript-comment">/* Send packet to the appropriate pipe */</span>
			ip_dn_io_ptr(m, i&amp;0xffff, DN_TO_IP_IN, &amp;args,
			    DN_CLIENT_IPFW);
			<span class="enscript-keyword">return</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-keyword">if</span> (i != 0 &amp;&amp; (i &amp; IP_FW_PORT_DYNT_FLAG) == 0) {
			<span class="enscript-comment">/* Divert or tee packet */</span>
			div_info = i;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
		}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL_FORWARD</span>
		<span class="enscript-keyword">if</span> (i == 0 &amp;&amp; args.fwa_next_hop != NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pass</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * if we get here, the packet must be dropped
		 */</span>
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span> | <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-reference">pass</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Process options and, if not destined for us,
	 * ship it on.  ip_dooptions returns 1 when an
	 * error was detected (causing an icmp message
	 * to be sent and the original packet to be freed).
	 */</span>
	ip_nhops = 0;		<span class="enscript-comment">/* for source routed packets */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    ip_dooptions(m, 0, args.fwa_next_hop)) {
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp; ip_dooptions(m, 0, NULL)) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Check our list of addresses, to see if the packet is for us.
	 * If we don't have any addresses, assume any unicast packet
	 * we receive might be for us (and let the upper layers deal
	 * with it).
	 */</span>
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;in_ifaddrhead) &amp;&amp; !(m-&gt;m_flags &amp; (M_MCAST|M_BCAST))) {
		ip_setdstifaddr_info(m, inifp-&gt;if_index, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}

	<span class="enscript-comment">/*
	 * Cache the destination address of the packet; this may be
	 * changed by use of 'ipfw fwd'.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	pkt_dst = args.fwa_next_hop == NULL ?
	    ip-&gt;ip_dst : args.fwa_next_hop-&gt;sin_addr;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	pkt_dst = ip-&gt;ip_dst;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

	<span class="enscript-comment">/*
	 * Enable a consistency check between the destination address
	 * and the arrival interface for a unicast packet (the RFC 1122
	 * strong ES model) if IP forwarding is disabled and the packet
	 * is not locally generated and the packet is not subject to
	 * 'ipfw fwd'.
	 *
	 * XXX - Checking also should be disabled if the destination
	 * address is ipnat'ed to a different interface.
	 *
	 * XXX - Checking is incompatible with IP aliases added
	 * to the loopback interface instead of the interface where
	 * the packets are received.
	 */</span>
	checkif = ip_checkinterface &amp;&amp; (ipforwarding == 0) &amp;&amp;
	    !(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	    &amp;&amp; (args.fwa_next_hop == NULL);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
		;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

	<span class="enscript-comment">/*
	 * Check for exact addresses in the hash bucket.
	 */</span>
	lck_rw_lock_shared(in_ifaddr_rwlock);
	TAILQ_FOREACH(ia, INADDR_HASH(pkt_dst.s_addr), ia_hash) {
		<span class="enscript-comment">/*
		 * If the address matches, verify that the packet
		 * arrived via the correct interface if checking is
		 * enabled.
		 */</span>
		<span class="enscript-keyword">if</span> (IA_SIN(ia)-&gt;sin_addr.s_addr == pkt_dst.s_addr &amp;&amp;
		    (!checkif || ia-&gt;ia_ifp == inifp)) {
			ip_setdstifaddr_info(m, 0, ia);
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
		}
	}
	lck_rw_done(in_ifaddr_rwlock);

	<span class="enscript-comment">/*
	 * Check for broadcast addresses.
	 *
	 * Only accept broadcast packets that arrive via the matching
	 * interface.  Reception of forwarded directed broadcasts would be
	 * handled via ip_forward() and ether_frameout() with the loopback
	 * into the stack for SIMPLEX interfaces handled by ether_frameout().
	 */</span>
	<span class="enscript-keyword">if</span> (inifp-&gt;if_flags &amp; IFF_BROADCAST) {
		<span class="enscript-type">struct</span> ifaddr *ifa;

		ifnet_lock_shared(inifp);
		TAILQ_FOREACH(ifa, &amp;inifp-&gt;if_addrhead, ifa_link) {
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET) {
				<span class="enscript-keyword">continue</span>;
			}
			ia = ifatoia(ifa);
			<span class="enscript-keyword">if</span> (satosin(&amp;ia-&gt;ia_broadaddr)-&gt;sin_addr.s_addr ==
			    pkt_dst.s_addr || ia-&gt;ia_netbroadcast.s_addr ==
			    pkt_dst.s_addr) {
				ip_setdstifaddr_info(m, 0, ia);
				ifnet_lock_done(inifp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
			}
		}
		ifnet_lock_done(inifp);
	}

	<span class="enscript-keyword">if</span> (IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr))) {
		<span class="enscript-type">struct</span> in_multi *inm;
		<span class="enscript-comment">/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */</span>
		in_multihead_lock_shared();
		IN_LOOKUP_MULTI(&amp;ip-&gt;ip_dst, inifp, inm);
		in_multihead_lock_done();
		<span class="enscript-keyword">if</span> (inm == NULL) {
			OSAddAtomic(1, &amp;ipstat.ips_notmember);
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}
		ip_setdstifaddr_info(m, inifp-&gt;if_index, NULL);
		INM_REMREF(inm);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}
	<span class="enscript-keyword">if</span> (ip-&gt;ip_dst.s_addr == (u_int32_t)INADDR_BROADCAST ||
	    ip-&gt;ip_dst.s_addr == INADDR_ANY) {
		ip_setdstifaddr_info(m, inifp-&gt;if_index, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
	}

	<span class="enscript-comment">/* Allow DHCP/BootP responses through */</span>
	<span class="enscript-keyword">if</span> ((inifp-&gt;if_eflags &amp; IFEF_AUTOCONFIGURING) &amp;&amp;
	    hlen == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp; ip-&gt;ip_p == IPPROTO_UDP) {
		<span class="enscript-type">struct</span> udpiphdr *ui;

		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr) &amp;&amp;
		    (m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udpiphdr))) == NULL) {
			OSAddAtomic(1, &amp;udpstat.udps_hdrops);
			<span class="enscript-keyword">return</span>;
		}
		ui = mtod(m, <span class="enscript-type">struct</span> udpiphdr *);
		<span class="enscript-keyword">if</span> (ntohs(ui-&gt;ui_dport) == IPPORT_BOOTPC) {
			ip_setdstifaddr_info(m, inifp-&gt;if_index, NULL);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ours</span>;
		}
		ip = mtod(m, <span class="enscript-type">struct</span> ip *); <span class="enscript-comment">/* in case it changed */</span>
	}

	<span class="enscript-comment">/*
	 * Not for us; forward if possible and desirable.
	 */</span>
	<span class="enscript-keyword">if</span> (ipforwarding == 0) {
		OSAddAtomic(1, &amp;ipstat.ips_cantforward);
		m_freem(m);
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
		ip_forward(m, 0, args.fwa_next_hop);
#<span class="enscript-reference">else</span>
		ip_forward(m, 0, NULL);
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">ours</span>:
	<span class="enscript-comment">/*
	 * If offset or IP_MF are set, must reassemble.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_off &amp; ~(IP_DF | IP_RF)) {
		<span class="enscript-comment">/*
		 * ip_reass() will return a different mbuf, and update
		 * the divert info in div_info and args.fwa_divert_rule.
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		m = ip_reass(m, (u_int16_t *)&amp;div_info, &amp;args.fwa_divert_rule);
#<span class="enscript-reference">else</span>
		m = ip_reass(m);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-comment">/* Get the header length of the reassembled packet */</span>
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-comment">/* Restore original checksum before diverting packet */</span>
		<span class="enscript-keyword">if</span> (div_info != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			HTONS(ip-&gt;ip_len);
			HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
			ip-&gt;ip_sum = 0;
			ip-&gt;ip_sum = ip_cksum_hdr_in(m, hlen);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			NTOHS(ip-&gt;ip_off);
			NTOHS(ip-&gt;ip_len);
#<span class="enscript-reference">endif</span>
		}
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/*
	 * Further protocols expect the packet length to be w/o the
	 * IP header.
	 */</span>
	ip-&gt;ip_len -= hlen;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-comment">/*
	 * Divert or tee packet to the divert protocol if required.
	 *
	 * If div_info is zero then cookie should be too, so we shouldn't
	 * need to clear them here.  Assume divert_packet() does so also.
	 */</span>
	<span class="enscript-keyword">if</span> (div_info != 0) {
		<span class="enscript-type">struct</span> mbuf *clone = NULL;

		<span class="enscript-comment">/* Clone packet if we're doing a 'tee' */</span>
		<span class="enscript-keyword">if</span> (div_info &amp; IP_FW_PORT_TEE_FLAG)
			clone = m_dup(m, M_DONTWAIT);

		<span class="enscript-comment">/* Restore packet header fields to original values */</span>
		ip-&gt;ip_len += hlen;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
		HTONS(ip-&gt;ip_len);
		HTONS(ip-&gt;ip_off);
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Deliver packet to divert input routine */</span>
		OSAddAtomic(1, &amp;ipstat.ips_delivered);
		divert_packet(m, 1, div_info &amp; 0xffff, args.fwa_divert_rule);

		<span class="enscript-comment">/* If 'tee', continue with original packet */</span>
		<span class="enscript-keyword">if</span> (clone == NULL) {
			<span class="enscript-keyword">return</span>;
		}
		m = clone;
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * enforce IPsec policy checking if we are seeing last header.
	 * note that we do not visit this with protocols with pcb layer
	 * code - like udp/tcp/raw ip.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; (ip_protox[ip-&gt;ip_p]-&gt;pr_flags &amp; PR_LASTHDR)) {
		<span class="enscript-keyword">if</span> (ipsec4_in_reject(m, NULL)) {
			IPSEC_STAT_INCREMENT(ipsecstat.in_polvio);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Switch out to protocol's input routine.
	 */</span>
	OSAddAtomic(1, &amp;ipstat.ips_delivered);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> (args.fwa_next_hop &amp;&amp; ip-&gt;ip_p == IPPROTO_TCP) {
		<span class="enscript-comment">/* TCP needs IPFORWARD info if available */</span>
		<span class="enscript-type">struct</span> m_tag *fwd_tag;
		<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag;

		fwd_tag = m_tag_create(KERNEL_MODULE_TAG_ID,
		    KERNEL_TAG_TYPE_IPFORWARD, <span class="enscript-keyword">sizeof</span> (*ipfwd_tag),
		    M_NOWAIT, m);
		<span class="enscript-keyword">if</span> (fwd_tag == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(fwd_tag+1);
		ipfwd_tag-&gt;next_hop = args.fwa_next_hop;

		m_tag_prepend(m, fwd_tag);

		KERNEL_DEBUG(DBG_LAYER_END, ip-&gt;ip_dst.s_addr,
		    ip-&gt;ip_src.s_addr, ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

		<span class="enscript-comment">/* TCP deals with its own locking */</span>
		ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, 0);
	} <span class="enscript-keyword">else</span> {
		KERNEL_DEBUG(DBG_LAYER_END, ip-&gt;ip_dst.s_addr,
		    ip-&gt;ip_src.s_addr, ip-&gt;ip_p, ip-&gt;ip_off, ip-&gt;ip_len);

		<span class="enscript-keyword">if</span> ((sw_lro) &amp;&amp; (ip-&gt;ip_p == IPPROTO_TCP)) {
			m = tcp_lro(m, hlen);
			<span class="enscript-keyword">if</span> (m == NULL)
				<span class="enscript-keyword">return</span>;
		}

		ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, 0);
	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	<span class="enscript-keyword">if</span> ((sw_lro) &amp;&amp; (ip-&gt;ip_p == IPPROTO_TCP)) {
		m = tcp_lro(m, hlen);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
	}
	ip_proto_dispatch_in(m, hlen, ip-&gt;ip_p, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	KERNEL_DEBUG(DBG_LAYER_END, 0, 0, 0, 0, 0);
	m_freem(m);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipq_updateparams</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;ipqlock, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-comment">/*
	 * -1 for unlimited allocation.
	 */</span>
	<span class="enscript-keyword">if</span> (maxnipq &lt; 0)
		ipq_limit = 0;
	<span class="enscript-comment">/*
	 * Positive number for specific bound.
	 */</span>
	<span class="enscript-keyword">if</span> (maxnipq &gt; 0)
		ipq_limit = maxnipq;
	<span class="enscript-comment">/*
	 * Zero specifies no further fragment queue allocation -- set the
	 * bound very low, but rely on implementation elsewhere to actually
	 * prevent allocation and reclaim current queues.
	 */</span>
	<span class="enscript-keyword">if</span> (maxnipq == 0)
		ipq_limit = 1;
	<span class="enscript-comment">/*
	 * Arm the purge timer if not already and if there's work to do
	 */</span>
	frag_sched_timeout();
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_maxnipq SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	lck_mtx_lock(&amp;ipqlock);
	i = maxnipq;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* impose bounds */</span>
	<span class="enscript-keyword">if</span> (i &lt; -1 || i &gt; (nmbclusters / 4)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	maxnipq = i;
	ipq_updateparams();
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(&amp;ipqlock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_maxfragsperpacket SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	lck_mtx_lock(&amp;ipqlock);
	i = maxfragsperpacket;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	maxfragsperpacket = i;
	ipq_updateparams();	<span class="enscript-comment">/* see if we need to arm timer */</span>
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(&amp;ipqlock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Take incoming datagram fragment and try to reassemble it into
 * whole datagram.  If a chain for reassembly of this datagram already
 * exists, then it is given as fp; otherwise have to make a chain.
 *
 * When IPDIVERT enabled, keep additional state with each packet that
 * tells us if we need to divert or tee the packet we're building.
 *
 * The IP header is *NOT* adjusted out of iplen.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
<span class="enscript-function-name">ip_reass</span>(<span class="enscript-type">struct</span> mbuf *m,
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPDIVERT_44</span>
    u_int32_t *divinfo,
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* IPDIVERT_44 */</span>
    u_int16_t *divinfo,
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT_44 */</span>
    u_int16_t *divcookie)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* IPDIVERT */</span>
<span class="enscript-function-name">ip_reass</span>(<span class="enscript-type">struct</span> mbuf *m)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> mbuf *p, *q, *nq, *t;
	<span class="enscript-type">struct</span> ipq *fp = NULL;
	<span class="enscript-type">struct</span> ipqhead *head;
	<span class="enscript-type">int</span> i, hlen, next;
	u_int8_t ecn, ecn0;
	uint32_t csum, csum_flags;
	uint16_t hash;
	<span class="enscript-type">struct</span> fq_head dfq;

	MBUFQ_INIT(&amp;dfq);	<span class="enscript-comment">/* for deferred frees */</span>

	<span class="enscript-comment">/* If maxnipq or maxfragsperpacket is 0, never accept fragments. */</span>
	<span class="enscript-keyword">if</span> (maxnipq == 0 || maxfragsperpacket == 0) {
		ipstat.ips_fragments++;
		ipstat.ips_fragdropped++;
		m_freem(m);
		<span class="enscript-keyword">if</span> (nipq &gt; 0) {
			lck_mtx_lock(&amp;ipqlock);
			frag_sched_timeout();	<span class="enscript-comment">/* purge stale fragments */</span>
			lck_mtx_unlock(&amp;ipqlock);
		}
		<span class="enscript-keyword">return</span> (NULL);
	}

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;

	lck_mtx_lock(&amp;ipqlock);

	hash = IPREASS_HASH(ip-&gt;ip_src.s_addr, ip-&gt;ip_id);
	head = &amp;ipq[hash];

	<span class="enscript-comment">/*
	 * Look for queue of fragments
	 * of this datagram.
	 */</span>
	TAILQ_FOREACH(fp, head, ipq_list) {
		<span class="enscript-keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;
		    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;
		    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		    mac_ipq_label_compare(m, fp) &amp;&amp;
#<span class="enscript-reference">endif</span>
		    ip-&gt;ip_p == fp-&gt;ipq_p)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	}

	fp = NULL;

	<span class="enscript-comment">/*
	 * Attempt to trim the number of allocated fragment queues if it
	 * exceeds the administrative limit.
	 */</span>
	<span class="enscript-keyword">if</span> ((nipq &gt; (<span class="enscript-type">unsigned</span>)maxnipq) &amp;&amp; (maxnipq &gt; 0)) {
		<span class="enscript-comment">/*
		 * drop something from the tail of the current queue
		 * before proceeding further
		 */</span>
		<span class="enscript-type">struct</span> ipq *fq = TAILQ_LAST(head, ipqhead);
		<span class="enscript-keyword">if</span> (fq == NULL) {   <span class="enscript-comment">/* gak */</span>
			<span class="enscript-keyword">for</span> (i = 0; i &lt; IPREASS_NHASH; i++) {
				<span class="enscript-type">struct</span> ipq *r = TAILQ_LAST(&amp;ipq[i], ipqhead);
				<span class="enscript-keyword">if</span> (r) {
					ipstat.ips_fragtimeout += r-&gt;ipq_nfrags;
					frag_freef(&amp;ipq[i], r);
					<span class="enscript-keyword">break</span>;
				}
			}
		} <span class="enscript-keyword">else</span> {
			ipstat.ips_fragtimeout += fq-&gt;ipq_nfrags;
			frag_freef(head, fq);
		}
	}

<span class="enscript-reference">found</span>:
	<span class="enscript-comment">/*
	 * Leverage partial checksum offload for IP fragments.  Narrow down
	 * the scope to cover only UDP without IP options, as that is the
	 * most common case.
	 *
	 * Perform 1's complement adjustment of octets that got included/
	 * excluded in the hardware-calculated checksum value.  Ignore cases
	 * where the value includes or excludes the IP header span, as the
	 * sum for those octets would already be 0xffff and thus no-op.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_p == IPPROTO_UDP &amp;&amp; hlen == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &amp;&amp;
	    (m-&gt;m_pkthdr.csum_flags &amp;
	    (CSUM_DATA_VALID | CSUM_PARTIAL | CSUM_PSEUDO_HDR)) ==
	    (CSUM_DATA_VALID | CSUM_PARTIAL)) {
		uint32_t start;

		start = m-&gt;m_pkthdr.csum_rx_start;
		csum = m-&gt;m_pkthdr.csum_rx_val;

		<span class="enscript-keyword">if</span> (start != 0 &amp;&amp; start != hlen) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			<span class="enscript-keyword">if</span> (start &lt; hlen) {
				HTONS(ip-&gt;ip_len);
				HTONS(ip-&gt;ip_off);
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* callee folds in sum */</span>
			csum = m_adj_sum16(m, start, hlen, csum);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BYTE_ORDER</span> != <span class="enscript-variable-name">BIG_ENDIAN</span>
			<span class="enscript-keyword">if</span> (start &lt; hlen) {
				NTOHS(ip-&gt;ip_off);
				NTOHS(ip-&gt;ip_len);
			}
#<span class="enscript-reference">endif</span>
		}
		csum_flags = m-&gt;m_pkthdr.csum_flags;
	} <span class="enscript-keyword">else</span> {
		csum = 0;
		csum_flags = 0;
	}

	<span class="enscript-comment">/* Invalidate checksum */</span>
	m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DATA_VALID;

	ipstat.ips_fragments++;

	<span class="enscript-comment">/*
	 * Adjust ip_len to not reflect header,
	 * convert offset of this to bytes.
	 */</span>
	ip-&gt;ip_len -= hlen;
	<span class="enscript-keyword">if</span> (ip-&gt;ip_off &amp; IP_MF) {
		<span class="enscript-comment">/*
		 * Make sure that fragments have a data length
		 * that's a non-zero multiple of 8 bytes.
		 */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_len == 0 || (ip-&gt;ip_len &amp; 0x7) != 0) {
			OSAddAtomic(1, &amp;ipstat.ips_toosmall);
			<span class="enscript-comment">/*
			 * Reassembly queue may have been found if previous
			 * fragments were valid; given that this one is bad,
			 * we need to drop it.  Make sure to set fp to NULL
			 * if not already, since we don't want to decrement
			 * ipq_nfrags as it doesn't include this packet.
			 */</span>
			fp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;
		}
		m-&gt;m_flags |= M_FRAG;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Clear the flag in case packet comes from loopback */</span>
		m-&gt;m_flags &amp;= ~M_FRAG;
	}
	ip-&gt;ip_off &lt;&lt;= 3;

	m-&gt;m_pkthdr.pkt_hdr = ip;

	<span class="enscript-comment">/* Previous ip_reass() started here. */</span>
	<span class="enscript-comment">/*
	 * Presence of header sizes in mbufs
	 * would confuse code below.
	 */</span>
	m-&gt;m_data += hlen;
	m-&gt;m_len -= hlen;

	<span class="enscript-comment">/*
	 * If first fragment to arrive, create a reassembly queue.
	 */</span>
	<span class="enscript-keyword">if</span> (fp == NULL) {
		fp = ipq_alloc(M_DONTWAIT);
		<span class="enscript-keyword">if</span> (fp == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		<span class="enscript-keyword">if</span> (mac_ipq_label_init(fp, M_NOWAIT) != 0) {
			ipq_free(fp);
			fp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;
		}
		mac_ipq_label_associate(m, fp);
#<span class="enscript-reference">endif</span>
		TAILQ_INSERT_HEAD(head, fp, ipq_list);
		nipq++;
		fp-&gt;ipq_nfrags = 1;
		fp-&gt;ipq_ttl = IPFRAGTTL;
		fp-&gt;ipq_p = ip-&gt;ip_p;
		fp-&gt;ipq_id = ip-&gt;ip_id;
		fp-&gt;ipq_src = ip-&gt;ip_src;
		fp-&gt;ipq_dst = ip-&gt;ip_dst;
		fp-&gt;ipq_frags = m;
		m-&gt;m_nextpkt = NULL;
		<span class="enscript-comment">/*
		 * If the first fragment has valid checksum offload
		 * info, the rest of fragments are eligible as well.
		 */</span>
		<span class="enscript-keyword">if</span> (csum_flags != 0) {
			fp-&gt;ipq_csum = csum;
			fp-&gt;ipq_csum_flags = csum_flags;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
		<span class="enscript-comment">/*
		 * Transfer firewall instructions to the fragment structure.
		 * Only trust info in the fragment at offset 0.
		 */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_off == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPDIVERT_44</span>
			fp-&gt;ipq_div_info = *divinfo;
#<span class="enscript-reference">else</span>
			fp-&gt;ipq_divert = *divinfo;
#<span class="enscript-reference">endif</span>
			fp-&gt;ipq_div_cookie = *divcookie;
		}
		*divinfo = 0;
		*divcookie = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>
		m = NULL;	<span class="enscript-comment">/* nothing to return */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> {
		fp-&gt;ipq_nfrags++;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		mac_ipq_label_update(m, fp);
#<span class="enscript-reference">endif</span>
	}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">GETIP</span>(m)	((struct ip *)((m)-&gt;m_pkthdr.pkt_hdr))

	<span class="enscript-comment">/*
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */</span>
	ecn = ip-&gt;ip_tos &amp; IPTOS_ECN_MASK;
	ecn0 = GETIP(fp-&gt;ipq_frags)-&gt;ip_tos &amp; IPTOS_ECN_MASK;
	<span class="enscript-keyword">if</span> (ecn == IPTOS_ECN_CE) {
		<span class="enscript-keyword">if</span> (ecn0 == IPTOS_ECN_NOTECT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;
		<span class="enscript-keyword">if</span> (ecn0 != IPTOS_ECN_CE)
			GETIP(fp-&gt;ipq_frags)-&gt;ip_tos |= IPTOS_ECN_CE;
	}
	<span class="enscript-keyword">if</span> (ecn == IPTOS_ECN_NOTECT &amp;&amp; ecn0 != IPTOS_ECN_NOTECT)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;

	<span class="enscript-comment">/*
	 * Find a segment which begins after this one does.
	 */</span>
	<span class="enscript-keyword">for</span> (p = NULL, q = fp-&gt;ipq_frags; q; p = q, q = q-&gt;m_nextpkt)
		<span class="enscript-keyword">if</span> (GETIP(q)-&gt;ip_off &gt; ip-&gt;ip_off)
			<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us, otherwise
	 * stick new segment in the proper place.
	 *
	 * If some of the data is dropped from the preceding
	 * segment, then it's checksum is invalidated.
	 */</span>
	<span class="enscript-keyword">if</span> (p) {
		i = GETIP(p)-&gt;ip_off + GETIP(p)-&gt;ip_len - ip-&gt;ip_off;
		<span class="enscript-keyword">if</span> (i &gt; 0) {
			<span class="enscript-keyword">if</span> (i &gt;= ip-&gt;ip_len)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropfrag</span>;
			m_adj(m, i);
			fp-&gt;ipq_csum_flags = 0;
			ip-&gt;ip_off += i;
			ip-&gt;ip_len -= i;
		}
		m-&gt;m_nextpkt = p-&gt;m_nextpkt;
		p-&gt;m_nextpkt = m;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_nextpkt = fp-&gt;ipq_frags;
		fp-&gt;ipq_frags = m;
	}

	<span class="enscript-comment">/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */</span>
	<span class="enscript-keyword">for</span> (; q != NULL &amp;&amp; ip-&gt;ip_off + ip-&gt;ip_len &gt; GETIP(q)-&gt;ip_off;
	    q = nq) {
		i = (ip-&gt;ip_off + ip-&gt;ip_len) - GETIP(q)-&gt;ip_off;
		<span class="enscript-keyword">if</span> (i &lt; GETIP(q)-&gt;ip_len) {
			GETIP(q)-&gt;ip_len -= i;
			GETIP(q)-&gt;ip_off += i;
			m_adj(q, i);
			fp-&gt;ipq_csum_flags = 0;
			<span class="enscript-keyword">break</span>;
		}
		nq = q-&gt;m_nextpkt;
		m-&gt;m_nextpkt = nq;
		ipstat.ips_fragdropped++;
		fp-&gt;ipq_nfrags--;
		<span class="enscript-comment">/* defer freeing until after lock is dropped */</span>
		MBUFQ_ENQUEUE(&amp;dfq, q);
	}

	<span class="enscript-comment">/*
	 * If this fragment contains similar checksum offload info
	 * as that of the existing ones, accumulate checksum.  Otherwise,
	 * invalidate checksum offload info for the entire datagram.
	 */</span>
	<span class="enscript-keyword">if</span> (csum_flags != 0 &amp;&amp; csum_flags == fp-&gt;ipq_csum_flags)
		fp-&gt;ipq_csum += csum;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fp-&gt;ipq_csum_flags != 0)
		fp-&gt;ipq_csum_flags = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-comment">/*
	 * Transfer firewall instructions to the fragment structure.
	 * Only trust info in the fragment at offset 0.
	 */</span>
	<span class="enscript-keyword">if</span> (ip-&gt;ip_off == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPDIVERT_44</span>
		fp-&gt;ipq_div_info = *divinfo;
#<span class="enscript-reference">else</span>
		fp-&gt;ipq_divert = *divinfo;
#<span class="enscript-reference">endif</span>
		fp-&gt;ipq_div_cookie = *divcookie;
	}
	*divinfo = 0;
	*divcookie = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>

	<span class="enscript-comment">/*
	 * Check for complete reassembly and perform frag per packet
	 * limiting.
	 *
	 * Frag limiting is performed here so that the nth frag has
	 * a chance to complete the packet before we drop the packet.
	 * As a result, n+1 frags are actually allowed per packet, but
	 * only n will ever be stored. (n = maxfragsperpacket.)
	 *
	 */</span>
	next = 0;
	<span class="enscript-keyword">for</span> (p = NULL, q = fp-&gt;ipq_frags; q; p = q, q = q-&gt;m_nextpkt) {
		<span class="enscript-keyword">if</span> (GETIP(q)-&gt;ip_off != next) {
			<span class="enscript-keyword">if</span> (fp-&gt;ipq_nfrags &gt; maxfragsperpacket) {
				ipstat.ips_fragdropped += fp-&gt;ipq_nfrags;
				frag_freef(head, fp);
			}
			m = NULL;	<span class="enscript-comment">/* nothing to return */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		next += GETIP(q)-&gt;ip_len;
	}
	<span class="enscript-comment">/* Make sure the last packet didn't have the IP_MF flag */</span>
	<span class="enscript-keyword">if</span> (p-&gt;m_flags &amp; M_FRAG) {
		<span class="enscript-keyword">if</span> (fp-&gt;ipq_nfrags &gt; maxfragsperpacket) {
			ipstat.ips_fragdropped += fp-&gt;ipq_nfrags;
			frag_freef(head, fp);
		}
		m = NULL;		<span class="enscript-comment">/* nothing to return */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Reassembly is complete.  Make sure the packet is a sane size.
	 */</span>
	q = fp-&gt;ipq_frags;
	ip = GETIP(q);
	<span class="enscript-keyword">if</span> (next + (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) &gt; IP_MAXPACKET) {
		ipstat.ips_toolong++;
		ipstat.ips_fragdropped += fp-&gt;ipq_nfrags;
		frag_freef(head, fp);
		m = NULL;		<span class="enscript-comment">/* nothing to return */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Concatenate fragments.
	 */</span>
	m = q;
	t = m-&gt;m_next;
	m-&gt;m_next = NULL;
	m_cat(m, t);
	nq = q-&gt;m_nextpkt;
	q-&gt;m_nextpkt = NULL;
	<span class="enscript-keyword">for</span> (q = nq; q != NULL; q = nq) {
		nq = q-&gt;m_nextpkt;
		q-&gt;m_nextpkt = NULL;
		m_cat(m, q);
	}

	<span class="enscript-comment">/*
	 * Store partial hardware checksum info from the fragment queue;
	 * the receive start offset is set to 20 bytes (see code at the
	 * top of this routine.)
	 */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;ipq_csum_flags != 0) {
		csum = fp-&gt;ipq_csum;

		ADDCARRY(csum);

		m-&gt;m_pkthdr.csum_rx_val = csum;
		m-&gt;m_pkthdr.csum_rx_start = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
		m-&gt;m_pkthdr.csum_flags = fp-&gt;ipq_csum_flags;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.rcvif-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		<span class="enscript-comment">/* loopback checksums are always OK */</span>
		m-&gt;m_pkthdr.csum_data = 0xffff;
		m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_PARTIAL;
		m-&gt;m_pkthdr.csum_flags =
		    CSUM_DATA_VALID | CSUM_PSEUDO_HDR |
		    CSUM_IP_CHECKED | CSUM_IP_VALID;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	<span class="enscript-comment">/*
	 * Extract firewall instructions from the fragment structure.
	 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPDIVERT_44</span>
	*divinfo = fp-&gt;ipq_div_info;
#<span class="enscript-reference">else</span>
	*divinfo = fp-&gt;ipq_divert;
#<span class="enscript-reference">endif</span>
	*divcookie = fp-&gt;ipq_div_cookie;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	mac_mbuf_label_associate_ipq(fp, m);
	mac_ipq_label_destroy(fp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Create header for new ip packet by modifying header of first
	 * packet; dequeue and discard fragment reassembly header.
	 * Make header visible.
	 */</span>
	ip-&gt;ip_len = (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) + next;
	ip-&gt;ip_src = fp-&gt;ipq_src;
	ip-&gt;ip_dst = fp-&gt;ipq_dst;

	fp-&gt;ipq_frags = NULL;	<span class="enscript-comment">/* return to caller as 'm' */</span>
	frag_freef(head, fp);
	fp = NULL;

	m-&gt;m_len += (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2);
	m-&gt;m_data -= (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2);
	<span class="enscript-comment">/* some debugging cruft by sklower, below, will go away soon */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)	<span class="enscript-comment">/* XXX this should be done elsewhere */</span>
		m_fixhdr(m);
	ipstat.ips_reassembled++;

	<span class="enscript-comment">/* arm the purge timer if not already and if there's work to do */</span>
	frag_sched_timeout();
	lck_mtx_unlock(&amp;ipqlock);
	<span class="enscript-comment">/* perform deferred free (if needed) now that lock is dropped */</span>
	<span class="enscript-keyword">if</span> (!MBUFQ_EMPTY(&amp;dfq))
		MBUFQ_DRAIN(&amp;dfq);
	VERIFY(MBUFQ_EMPTY(&amp;dfq));
	<span class="enscript-keyword">return</span> (m);

<span class="enscript-reference">done</span>:
	VERIFY(m == NULL);
	<span class="enscript-comment">/* arm the purge timer if not already and if there's work to do */</span>
	frag_sched_timeout();
	lck_mtx_unlock(&amp;ipqlock);
	<span class="enscript-comment">/* perform deferred free (if needed) */</span>
	<span class="enscript-keyword">if</span> (!MBUFQ_EMPTY(&amp;dfq))
		MBUFQ_DRAIN(&amp;dfq);
	VERIFY(MBUFQ_EMPTY(&amp;dfq));
	<span class="enscript-keyword">return</span> (NULL);

<span class="enscript-reference">dropfrag</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPDIVERT</span>
	*divinfo = 0;
	*divcookie = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPDIVERT */</span>
	ipstat.ips_fragdropped++;
	<span class="enscript-keyword">if</span> (fp != NULL)
		fp-&gt;ipq_nfrags--;
	<span class="enscript-comment">/* arm the purge timer if not already and if there's work to do */</span>
	frag_sched_timeout();
	lck_mtx_unlock(&amp;ipqlock);
	m_freem(m);
	<span class="enscript-comment">/* perform deferred free (if needed) */</span>
	<span class="enscript-keyword">if</span> (!MBUFQ_EMPTY(&amp;dfq))
		MBUFQ_DRAIN(&amp;dfq);
	VERIFY(MBUFQ_EMPTY(&amp;dfq));
	<span class="enscript-keyword">return</span> (NULL);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">GETIP</span>
}

<span class="enscript-comment">/*
 * Free a fragment reassembly header and all
 * associated datagrams.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">frag_freef</span>(<span class="enscript-type">struct</span> ipqhead *fhp, <span class="enscript-type">struct</span> ipq *fp)
{
	lck_mtx_assert(&amp;ipqlock, LCK_MTX_ASSERT_OWNED);

	fp-&gt;ipq_nfrags = 0;
	<span class="enscript-keyword">if</span> (fp-&gt;ipq_frags != NULL) {
		m_freem_list(fp-&gt;ipq_frags);
		fp-&gt;ipq_frags = NULL;
	}
	TAILQ_REMOVE(fhp, fp, ipq_list);
	nipq--;
	ipq_free(fp);
}

<span class="enscript-comment">/*
 * IP reassembly timer processing
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">frag_timeout</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> ipq *fp;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * Update coarse-grained networking timestamp (in sec.); the idea
	 * is to piggy-back on the timeout callout to update the counter
	 * returnable via net_uptime().
	 */</span>
	net_update_uptime();

	lck_mtx_lock(&amp;ipqlock);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPREASS_NHASH; i++) {
		<span class="enscript-keyword">for</span> (fp = TAILQ_FIRST(&amp;ipq[i]); fp; ) {
			<span class="enscript-type">struct</span> ipq *fpp;

			fpp = fp;
			fp = TAILQ_NEXT(fp, ipq_list);
			<span class="enscript-keyword">if</span> (--fpp-&gt;ipq_ttl == 0) {
				ipstat.ips_fragtimeout += fpp-&gt;ipq_nfrags;
				frag_freef(&amp;ipq[i], fpp);
			}
		}
	}
	<span class="enscript-comment">/*
	 * If we are over the maximum number of fragments
	 * (due to the limit being lowered), drain off
	 * enough to get down to the new limit.
	 */</span>
	<span class="enscript-keyword">if</span> (maxnipq &gt;= 0 &amp;&amp; nipq &gt; (<span class="enscript-type">unsigned</span>)maxnipq) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; IPREASS_NHASH; i++) {
			<span class="enscript-keyword">while</span> (nipq &gt; (<span class="enscript-type">unsigned</span>)maxnipq &amp;&amp;
			    !TAILQ_EMPTY(&amp;ipq[i])) {
				ipstat.ips_fragdropped +=
				    TAILQ_FIRST(&amp;ipq[i])-&gt;ipq_nfrags;
				frag_freef(&amp;ipq[i], TAILQ_FIRST(&amp;ipq[i]));
			}
		}
	}
	<span class="enscript-comment">/* re-arm the purge timer if there's work to do */</span>
	frag_timeout_run = 0;
	frag_sched_timeout();
	lck_mtx_unlock(&amp;ipqlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">frag_sched_timeout</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;ipqlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!frag_timeout_run &amp;&amp; nipq &gt; 0) {
		frag_timeout_run = 1;
		timeout(frag_timeout, NULL, hz);
	}
}

<span class="enscript-comment">/*
 * Drain off all datagram fragments.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">frag_drain</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	lck_mtx_lock(&amp;ipqlock);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPREASS_NHASH; i++) {
		<span class="enscript-keyword">while</span> (!TAILQ_EMPTY(&amp;ipq[i])) {
			ipstat.ips_fragdropped +=
			    TAILQ_FIRST(&amp;ipq[i])-&gt;ipq_nfrags;
			frag_freef(&amp;ipq[i], TAILQ_FIRST(&amp;ipq[i]));
		}
	}
	lck_mtx_unlock(&amp;ipqlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipq *
<span class="enscript-function-name">ipq_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mbuf *t;
	<span class="enscript-type">struct</span> ipq *fp;

	<span class="enscript-comment">/*
	 * See comments in ipq_updateparams().  Keep the count separate
	 * from nipq since the latter represents the elements already
	 * in the reassembly queues.
	 */</span>
	<span class="enscript-keyword">if</span> (ipq_limit &gt; 0 &amp;&amp; ipq_count &gt; ipq_limit)
		<span class="enscript-keyword">return</span> (NULL);

	t = m_get(how, MT_FTABLE);
	<span class="enscript-keyword">if</span> (t != NULL) {
		atomic_add_32(&amp;ipq_count, 1);
		fp = mtod(t, <span class="enscript-type">struct</span> ipq *);
		bzero(fp, <span class="enscript-keyword">sizeof</span> (*fp));
	} <span class="enscript-keyword">else</span> {
		fp = NULL;
	}
	<span class="enscript-keyword">return</span> (fp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipq_free</span>(<span class="enscript-type">struct</span> ipq *fp)
{
	(<span class="enscript-type">void</span>) m_free(dtom(fp));
	atomic_add_32(&amp;ipq_count, -1);
}

<span class="enscript-comment">/*
 * Drain callback
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_drain</span>(<span class="enscript-type">void</span>)
{
	frag_drain();		<span class="enscript-comment">/* fragments */</span>
	in_rtqdrain();		<span class="enscript-comment">/* protocol cloned routes */</span>
	in_arpdrain(NULL);	<span class="enscript-comment">/* cloned routes: ARP */</span>
}

<span class="enscript-comment">/*
 * Do option processing on a datagram,
 * possibly discarding it if bad options are encountered,
 * or forwarding it if source-routed.
 * The pass argument is used when operating in the IPSTEALTH
 * mode to tell what options to process:
 * [LS]SRR (pass 0) or the others (pass 1).
 * The reason for as many as two passes is that when doing IPSTEALTH,
 * non-routing options should be processed only if the packet is for us.
 * Returns 1 if packet has been forwarded/freed,
 * 0 if the packet should be processed further.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip_dooptions</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> pass, <span class="enscript-type">struct</span> sockaddr_in *next_hop)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pass</span>)
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	u_char *cp;
	<span class="enscript-type">struct</span> ip_timestamp *ipt;
	<span class="enscript-type">struct</span> in_ifaddr *ia;
	<span class="enscript-type">int</span> opt, optlen, cnt, off, code, type = ICMP_PARAMPROB, forward = 0;
	<span class="enscript-type">struct</span> in_addr *sin, dst;
	u_int32_t ntime;
	<span class="enscript-type">struct</span> sockaddr_in ipaddr = {
	    <span class="enscript-keyword">sizeof</span> (ipaddr), AF_INET, 0, { 0 }, { 0, } };

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	dst = ip-&gt;ip_dst;
	cp = (u_char *)(ip + 1);
	cnt = (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		<span class="enscript-keyword">if</span> (opt == IPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == IPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cnt &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp)) {
				code = &amp;cp[IPOPT_OLEN] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			optlen = cp[IPOPT_OLEN];
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp) ||
			    optlen &gt; cnt) {
				code = &amp;cp[IPOPT_OLEN] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
		<span class="enscript-keyword">switch</span> (opt) {

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Source routing with record.
		 * Find interface with current destination address.
		 * If none on this machine then drop if strictly routed,
		 * or do nothing if loosely routed.
		 * Record interface address and bring up next address
		 * component.  If strictly routed make sure next
		 * address is on directly accessible net.
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_LSRR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_SSRR</span>:
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OFFSET + <span class="enscript-keyword">sizeof</span> (*cp)) {
				code = &amp;cp[IPOPT_OLEN] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> ((off = cp[IPOPT_OFFSET]) &lt; IPOPT_MINOFF) {
				code = &amp;cp[IPOPT_OFFSET] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ipaddr.sin_addr = ip-&gt;ip_dst;
			ia = (<span class="enscript-type">struct</span> in_ifaddr *)ifa_ifwithaddr(SA(&amp;ipaddr));
			<span class="enscript-keyword">if</span> (ia == NULL) {
				<span class="enscript-keyword">if</span> (opt == IPOPT_SSRR) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				<span class="enscript-keyword">if</span> (!ip_dosourceroute)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nosourcerouting</span>;
				<span class="enscript-comment">/*
				 * Loose routing, and not at next destination
				 * yet; nothing to do except forward.
				 */</span>
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
				ia = NULL;
			}
			off--;			<span class="enscript-comment">/* 0 origin */</span>
			<span class="enscript-keyword">if</span> (off &gt; optlen - (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr)) {
				<span class="enscript-comment">/*
				 * End of source route.  Should be for us.
				 */</span>
				<span class="enscript-keyword">if</span> (!ip_acceptsourceroute)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nosourcerouting</span>;
				save_rte(cp, ip-&gt;ip_src);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!ip_dosourceroute) {
				<span class="enscript-keyword">if</span> (ipforwarding) {
					<span class="enscript-type">char</span> buf[MAX_IPv4_STR_LEN];
					<span class="enscript-type">char</span> buf2[MAX_IPv4_STR_LEN];
					<span class="enscript-comment">/*
					 * Acting as a router, so generate ICMP
					 */</span>
<span class="enscript-reference">nosourcerouting</span>:
					log(LOG_WARNING,
					    <span class="enscript-string">&quot;attempted source route from %s &quot;</span>
					    <span class="enscript-string">&quot;to %s\n&quot;</span>,
					    inet_ntop(AF_INET, &amp;ip-&gt;ip_src,
					    buf, <span class="enscript-keyword">sizeof</span> (buf)),
					    inet_ntop(AF_INET, &amp;ip-&gt;ip_dst,
					    buf2, <span class="enscript-keyword">sizeof</span> (buf2)));
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_SRCFAIL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * Not acting as a router,
					 * so silently drop.
					 */</span>
					OSAddAtomic(1, &amp;ipstat.ips_cantforward);
					m_freem(m);
					<span class="enscript-keyword">return</span> (1);
				}
			}

			<span class="enscript-comment">/*
			 * locate outgoing interface
			 */</span>
			(<span class="enscript-type">void</span>) memcpy(&amp;ipaddr.sin_addr, cp + off,
			    <span class="enscript-keyword">sizeof</span> (ipaddr.sin_addr));

			<span class="enscript-keyword">if</span> (opt == IPOPT_SSRR) {
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">INA</span>	struct in_ifaddr *
				<span class="enscript-keyword">if</span> ((ia = (INA)ifa_ifwithdstaddr(
				    SA(&amp;ipaddr))) == NULL) {
					ia = (INA)ifa_ifwithnet(SA(&amp;ipaddr));
				}
			} <span class="enscript-keyword">else</span> {
				ia = ip_rtaddr(ipaddr.sin_addr);
			}
			<span class="enscript-keyword">if</span> (ia == NULL) {
				type = ICMP_UNREACH;
				code = ICMP_UNREACH_SRCFAIL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ip-&gt;ip_dst = ipaddr.sin_addr;
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			(<span class="enscript-type">void</span>) memcpy(cp + off, &amp;(IA_SIN(ia)-&gt;sin_addr),
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
			ia = NULL;
			cp[IPOPT_OFFSET] += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
			<span class="enscript-comment">/*
			 * Let ip_intr's mcast routing check handle mcast pkts
			 */</span>
			forward = !IN_MULTICAST(ntohl(ip-&gt;ip_dst.s_addr));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_RR</span>:
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OFFSET + <span class="enscript-keyword">sizeof</span> (*cp)) {
				code = &amp;cp[IPOPT_OFFSET] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> ((off = cp[IPOPT_OFFSET]) &lt; IPOPT_MINOFF) {
				code = &amp;cp[IPOPT_OFFSET] - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-comment">/*
			 * If no space remains, ignore.
			 */</span>
			off--;			<span class="enscript-comment">/* 0 origin */</span>
			<span class="enscript-keyword">if</span> (off &gt; optlen - (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr))
				<span class="enscript-keyword">break</span>;
			(<span class="enscript-type">void</span>) memcpy(&amp;ipaddr.sin_addr, &amp;ip-&gt;ip_dst,
			    <span class="enscript-keyword">sizeof</span> (ipaddr.sin_addr));
			<span class="enscript-comment">/*
			 * locate outgoing interface; if we're the destination,
			 * use the incoming interface (should be same).
			 */</span>
			<span class="enscript-keyword">if</span> ((ia = (INA)ifa_ifwithaddr(SA(&amp;ipaddr))) == NULL) {
				<span class="enscript-keyword">if</span> ((ia = ip_rtaddr(ipaddr.sin_addr)) == NULL) {
					type = ICMP_UNREACH;
					code = ICMP_UNREACH_HOST;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
			}
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			(<span class="enscript-type">void</span>) memcpy(cp + off, &amp;(IA_SIN(ia)-&gt;sin_addr),
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);
			ia = NULL;
			cp[IPOPT_OFFSET] += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_TS</span>:
			code = cp - (u_char *)ip;
			ipt = (<span class="enscript-type">struct</span> ip_timestamp *)(<span class="enscript-type">void</span> *)cp;
			<span class="enscript-keyword">if</span> (ipt-&gt;ipt_len &lt; 4 || ipt-&gt;ipt_len &gt; 40) {
				code = (u_char *)&amp;ipt-&gt;ipt_len - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> (ipt-&gt;ipt_ptr &lt; 5) {
				code = (u_char *)&amp;ipt-&gt;ipt_ptr - (u_char *)ip;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> (ipt-&gt;ipt_ptr &gt;
			    ipt-&gt;ipt_len - (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (int32_t)) {
				<span class="enscript-keyword">if</span> (++ipt-&gt;ipt_oflw == 0) {
					code = (u_char *)&amp;ipt-&gt;ipt_ptr -
					    (u_char *)ip;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				<span class="enscript-keyword">break</span>;
			}
			sin = (<span class="enscript-type">struct</span> in_addr *)(<span class="enscript-type">void</span> *)(cp + ipt-&gt;ipt_ptr - 1);
			<span class="enscript-keyword">switch</span> (ipt-&gt;ipt_flg) {

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_TS_TSONLY</span>:
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_TS_TSANDADDR</span>:
				<span class="enscript-keyword">if</span> (ipt-&gt;ipt_ptr - 1 + <span class="enscript-keyword">sizeof</span> (n_time) +
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) &gt; ipt-&gt;ipt_len) {
					code = (u_char *)&amp;ipt-&gt;ipt_ptr -
					    (u_char *)ip;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				ipaddr.sin_addr = dst;
				ia = (INA)ifaof_ifpforaddr(SA(&amp;ipaddr),
				    m-&gt;m_pkthdr.rcvif);
				<span class="enscript-keyword">if</span> (ia == NULL)
					<span class="enscript-keyword">continue</span>;
				IFA_LOCK(&amp;ia-&gt;ia_ifa);
				(<span class="enscript-type">void</span>) memcpy(sin, &amp;IA_SIN(ia)-&gt;sin_addr,
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				ipt-&gt;ipt_ptr += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
				ia = NULL;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_TS_PRESPEC</span>:
				<span class="enscript-keyword">if</span> (ipt-&gt;ipt_ptr - 1 + <span class="enscript-keyword">sizeof</span> (n_time) +
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) &gt; ipt-&gt;ipt_len) {
					code = (u_char *)&amp;ipt-&gt;ipt_ptr -
					    (u_char *)ip;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				(<span class="enscript-type">void</span>) memcpy(&amp;ipaddr.sin_addr, sin,
				    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
				<span class="enscript-keyword">if</span> ((ia = (<span class="enscript-type">struct</span> in_ifaddr *)ifa_ifwithaddr(
				    SA(&amp;ipaddr))) == NULL)
					<span class="enscript-keyword">continue</span>;
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
				ia = NULL;
				ipt-&gt;ipt_ptr += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/* XXX can't take &amp;ipt-&gt;ipt_flg */</span>
				code = (u_char *)&amp;ipt-&gt;ipt_ptr -
				    (u_char *)ip + 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ntime = iptime();
			(<span class="enscript-type">void</span>) memcpy(cp + ipt-&gt;ipt_ptr - 1, &amp;ntime,
			    <span class="enscript-keyword">sizeof</span> (n_time));
			ipt-&gt;ipt_ptr += <span class="enscript-keyword">sizeof</span> (n_time);
		}
	}
	<span class="enscript-keyword">if</span> (forward &amp;&amp; ipforwarding) {
		ip_forward(m, 1, next_hop);
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">bad</span>:
	icmp_error(m, type, code, 0, 0);
	OSAddAtomic(1, &amp;ipstat.ips_badoptions);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Check for the presence of the IP Router Alert option [RFC2113]
 * in the header of an IPv4 datagram.
 *
 * This call is not intended for use from the forwarding path; it is here
 * so that protocol domains may check for the presence of the option.
 * Given how FreeBSD's IPv4 stack is currently structured, the Router Alert
 * option does not have much relevance to the implementation, though this
 * may change in future.
 * Router alert options SHOULD be passed if running in IPSTEALTH mode and
 * we are not the endpoint.
 * Length checks on individual options should already have been peformed
 * by ip_dooptions() therefore they are folded under DIAGNOSTIC here.
 *
 * Return zero if not present or options are invalid, non-zero if present.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_checkrouteralert</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	u_char *cp;
	<span class="enscript-type">int</span> opt, optlen, cnt, found_ra;

	found_ra = 0;
	cp = (u_char *)(ip + 1);
	cnt = (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	<span class="enscript-keyword">for</span> (; cnt &gt; 0; cnt -= optlen, cp += optlen) {
		opt = cp[IPOPT_OPTVAL];
		<span class="enscript-keyword">if</span> (opt == IPOPT_EOL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (opt == IPOPT_NOP)
			optlen = 1;
		<span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (cnt &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp))
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
			optlen = cp[IPOPT_OLEN];
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (optlen &lt; IPOPT_OLEN + <span class="enscript-keyword">sizeof</span> (*cp) || optlen &gt; cnt)
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		}
		<span class="enscript-keyword">switch</span> (opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_RA</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (optlen != IPOPT_OFFSET + <span class="enscript-keyword">sizeof</span> (uint16_t) ||
			    (*((uint16_t *)(<span class="enscript-type">void</span> *)&amp;cp[IPOPT_OFFSET]) != 0))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
				found_ra = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (found_ra);
}

<span class="enscript-comment">/*
 * Given address of next destination (final or next hop),
 * return internet address info of interface to be used to get there.
 */</span>
<span class="enscript-type">struct</span> in_ifaddr *
<span class="enscript-function-name">ip_rtaddr</span>(<span class="enscript-type">struct</span> in_addr dst)
{
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	<span class="enscript-type">struct</span> ifaddr *rt_ifa;
	<span class="enscript-type">struct</span> route ro;

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span> (ro));
	sin = SIN(&amp;ro.ro_dst);
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);
	sin-&gt;sin_addr = dst;

	rtalloc_ign(&amp;ro, RTF_PRCLONING);
	<span class="enscript-keyword">if</span> (ro.ro_rt == NULL) {
		ROUTE_RELEASE(&amp;ro);
		<span class="enscript-keyword">return</span> (NULL);
	}

	RT_LOCK(ro.ro_rt);
	<span class="enscript-keyword">if</span> ((rt_ifa = ro.ro_rt-&gt;rt_ifa) != NULL)
		IFA_ADDREF(rt_ifa);
	RT_UNLOCK(ro.ro_rt);
	ROUTE_RELEASE(&amp;ro);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> in_ifaddr *)rt_ifa);
}

<span class="enscript-comment">/*
 * Save incoming source route for use in replies,
 * to be picked up later by ip_srcroute if the receiver is interested.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">save_rte</span>(u_char *option, <span class="enscript-type">struct</span> in_addr dst)
{
	<span class="enscript-type">unsigned</span> olen;

	olen = option[IPOPT_OLEN];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (ipprintfs)
		printf(<span class="enscript-string">&quot;save_rte: olen %d\n&quot;</span>, olen);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (olen &gt; <span class="enscript-keyword">sizeof</span> (ip_srcrt) - (1 + <span class="enscript-keyword">sizeof</span> (dst)))
		<span class="enscript-keyword">return</span>;
	bcopy(option, ip_srcrt.srcopt, olen);
	ip_nhops = (olen - IPOPT_OFFSET - 1) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr);
	ip_srcrt.dst = dst;
}

<span class="enscript-comment">/*
 * Retrieve incoming source route for use in replies,
 * in the same form used by setsockopt.
 * The first hop is placed before the options, will be removed later.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ip_srcroute</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> in_addr *p, *q;
	<span class="enscript-type">struct</span> mbuf *m;

	<span class="enscript-keyword">if</span> (ip_nhops == 0)
		<span class="enscript-keyword">return</span> (NULL);

	m = m_get(M_DONTWAIT, MT_HEADER);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (NULL);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">OPTSIZ</span>	(sizeof (ip_srcrt.nop) + sizeof (ip_srcrt.srcopt))

	<span class="enscript-comment">/* length is (nhops+1)*sizeof(addr) + sizeof(nop + srcrt header) */</span>
	m-&gt;m_len = ip_nhops * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) +
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) + OPTSIZ;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (ipprintfs)
		printf(<span class="enscript-string">&quot;ip_srcroute: nhops %d mlen %d&quot;</span>, ip_nhops, m-&gt;m_len);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * First save first hop for return route
	 */</span>
	p = &amp;ip_srcrt.route[ip_nhops - 1];
	*(mtod(m, <span class="enscript-type">struct</span> in_addr *)) = *p--;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (ipprintfs)
		printf(<span class="enscript-string">&quot; hops %lx&quot;</span>,
		    (u_int32_t)ntohl(mtod(m, <span class="enscript-type">struct</span> in_addr *)-&gt;s_addr));
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Copy option fields and padding (nop) to mbuf.
	 */</span>
	ip_srcrt.nop = IPOPT_NOP;
	ip_srcrt.srcopt[IPOPT_OFFSET] = IPOPT_MINOFF;
	(<span class="enscript-type">void</span>) memcpy(mtod(m, caddr_t) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr),
	    &amp;ip_srcrt.nop, OPTSIZ);
	q = (<span class="enscript-type">struct</span> in_addr *)(<span class="enscript-type">void</span> *)(mtod(m, caddr_t) +
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr) + OPTSIZ);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">OPTSIZ</span>
	<span class="enscript-comment">/*
	 * Record return path as an IP source route,
	 * reversing the path (pointers are now aligned).
	 */</span>
	<span class="enscript-keyword">while</span> (p &gt;= ip_srcrt.route) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (ipprintfs)
			printf(<span class="enscript-string">&quot; %lx&quot;</span>, (u_int32_t)ntohl(q-&gt;s_addr));
#<span class="enscript-reference">endif</span>
		*q++ = *p--;
	}
	<span class="enscript-comment">/*
	 * Last hop goes to final destination.
	 */</span>
	*q = ip_srcrt.dst;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (ipprintfs)
		printf(<span class="enscript-string">&quot; %lx\n&quot;</span>, (u_int32_t)ntohl(q-&gt;s_addr));
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Strip out IP options, at higher
 * level protocol in the kernel.
 * Second argument is buffer to which options
 * will be moved, and return value is their length.
 * XXX should be deleted; last arg currently ignored.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_stripoptions</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf *mopt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">mopt</span>)
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	caddr_t opts;
	<span class="enscript-type">int</span> olen;

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	olen = (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip);
	opts = (caddr_t)(ip + 1);
	i = m-&gt;m_len - (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) + olen);
	bcopy(opts + olen, opts, (<span class="enscript-type">unsigned</span>)i);
	m-&gt;m_len -= olen;
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
		m-&gt;m_pkthdr.len -= olen;
	ip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip) &gt;&gt; 2);
}

u_char inetctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	ENETUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT,	ECONNREFUSED
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ipforwarding SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> i, was_ipforwarding = ipforwarding;

	i = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);
	<span class="enscript-keyword">if</span> (i != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (i);

	<span class="enscript-keyword">if</span> (was_ipforwarding &amp;&amp; !ipforwarding) {
		<span class="enscript-comment">/* clean up IPv4 forwarding cached routes */</span>
		ifnet_head_lock_shared();
		<span class="enscript-keyword">for</span> (i = 0; i &lt;= if_index; i++) {
			<span class="enscript-type">struct</span> ifnet *ifp = ifindex2ifnet[i];
			<span class="enscript-keyword">if</span> (ifp != NULL) {
				lck_mtx_lock(&amp;ifp-&gt;if_cached_route_lock);
				ROUTE_RELEASE(&amp;ifp-&gt;if_fwd_route);
				bzero(&amp;ifp-&gt;if_fwd_route,
				    <span class="enscript-keyword">sizeof</span> (ifp-&gt;if_fwd_route));
				lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
			}
		}
		ifnet_head_done();
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Similar to inp_route_{copyout,copyin} routines except that these copy
 * out the cached IPv4 forwarding route from struct ifnet instead of the
 * inpcb.  See comments for those routines for explanations.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_fwd_route_copyout</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route *dst)
{
	<span class="enscript-type">struct</span> route *src = &amp;ifp-&gt;if_fwd_route;

	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	<span class="enscript-comment">/* Minor sanity check */</span>
	<span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL &amp;&amp; rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET)
		panic(<span class="enscript-string">&quot;%s: wrong or corrupted route: %p&quot;</span>, __func__, src);

	route_copyout(dst, src, <span class="enscript-keyword">sizeof</span> (*dst));

	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_fwd_route_copyin</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route *src)
{
	<span class="enscript-type">struct</span> route *dst = &amp;ifp-&gt;if_fwd_route;

	lck_mtx_lock_spin(&amp;ifp-&gt;if_cached_route_lock);
	lck_mtx_convert_spin(&amp;ifp-&gt;if_cached_route_lock);

	<span class="enscript-comment">/* Minor sanity check */</span>
	<span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL &amp;&amp; rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET)
		panic(<span class="enscript-string">&quot;%s: wrong or corrupted route: %p&quot;</span>, __func__, src);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_fwd_cacheok)
		route_copyin(src, dst, <span class="enscript-keyword">sizeof</span> (*src));

	lck_mtx_unlock(&amp;ifp-&gt;if_cached_route_lock);
}

<span class="enscript-comment">/*
 * Forward a packet.  If some error occurs return the sender
 * an icmp packet.  Note we can't always generate a meaningful
 * icmp message because icmp doesn't have a large enough repertoire
 * of codes and types.
 *
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 * The srcrt parameter indicates whether the packet is being forwarded
 * via a source route.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip_forward</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> srcrt, <span class="enscript-type">struct</span> sockaddr_in *next_hop)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">IPFIREWALL</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">next_hop</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> ip *ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> route fwd_rt;
	<span class="enscript-type">int</span> error, type = 0, code = 0;
	<span class="enscript-type">struct</span> mbuf *mcopy;
	n_long dest;
	<span class="enscript-type">struct</span> in_addr pkt_dst;
	u_int32_t nextmtu = 0, len;
	<span class="enscript-type">struct</span> ip_out_args ipoa = { IFSCOPE_NONE, { 0 }, 0, 0 };
	<span class="enscript-type">struct</span> ifnet *rcvifp = m-&gt;m_pkthdr.rcvif;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">int</span> ipsecerror;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-type">struct</span> pf_mtag *pf_mtag;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	dest = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-comment">/*
	 * Cache the destination address of the packet; this may be
	 * changed by use of 'ipfw fwd'.
	 */</span>
	pkt_dst = ((next_hop != NULL) ? next_hop-&gt;sin_addr : ip-&gt;ip_dst);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
	pkt_dst = ip-&gt;ip_dst;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (ipprintfs)
		printf(<span class="enscript-string">&quot;forward: src %lx dst %lx ttl %x\n&quot;</span>,
		    (u_int32_t)ip-&gt;ip_src.s_addr, (u_int32_t)pkt_dst.s_addr,
		    ip-&gt;ip_ttl);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; (M_BCAST|M_MCAST) || !in_canforward(pkt_dst)) {
		OSAddAtomic(1, &amp;ipstat.ips_cantforward);
		m_freem(m);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSTEALTH</span>
	<span class="enscript-keyword">if</span> (!ipstealth) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSTEALTH */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_ttl &lt;= IPTTLDEC) {
			icmp_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS,
			    dest, 0);
			<span class="enscript-keyword">return</span>;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSTEALTH</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSTEALTH */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	pf_mtag = pf_find_mtag(m);
	<span class="enscript-keyword">if</span> (pf_mtag != NULL &amp;&amp; pf_mtag-&gt;pftag_rtableid != IFSCOPE_NONE) {
		ipoa.ipoa_boundif = pf_mtag-&gt;pftag_rtableid;
		ipoa.ipoa_flags |= IPOAF_BOUND_IF;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	ip_fwd_route_copyout(rcvifp, &amp;fwd_rt);

	sin = SIN(&amp;fwd_rt.ro_dst);
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;fwd_rt) || pkt_dst.s_addr != sin-&gt;sin_addr.s_addr) {
		ROUTE_RELEASE(&amp;fwd_rt);

		sin-&gt;sin_family = AF_INET;
		sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);
		sin-&gt;sin_addr = pkt_dst;

		rtalloc_scoped_ign(&amp;fwd_rt, RTF_PRCLONING, ipoa.ipoa_boundif);
		<span class="enscript-keyword">if</span> (fwd_rt.ro_rt == NULL) {
			icmp_error(m, ICMP_UNREACH, ICMP_UNREACH_HOST, dest, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	rt = fwd_rt.ro_rt;

	<span class="enscript-comment">/*
	 * Save the IP header and at most 8 bytes of the payload,
	 * in case we need to generate an ICMP message to the src.
	 *
	 * We don't use m_copy() because it might return a reference
	 * to a shared cluster. Both this function and ip_output()
	 * assume exclusive access to the IP header in `m', so any
	 * data in a cluster may change before we reach icmp_error().
	 */</span>
	MGET(mcopy, M_DONTWAIT, m-&gt;m_type);
	<span class="enscript-keyword">if</span> (mcopy != NULL) {
		M_COPY_PKTHDR(mcopy, m);
		mcopy-&gt;m_len = imin((IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2) + 8,
		    (<span class="enscript-type">int</span>)ip-&gt;ip_len);
		m_copydata(m, 0, mcopy-&gt;m_len, mtod(mcopy, caddr_t));
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSTEALTH</span>
	<span class="enscript-keyword">if</span> (!ipstealth) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSTEALTH */</span>
		ip-&gt;ip_ttl -= IPTTLDEC;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSTEALTH</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSTEALTH */</span>

	<span class="enscript-comment">/*
	 * If forwarding packet using same interface that it came in on,
	 * perhaps should send a redirect to sender to shortcut a hop.
	 * Only send redirect if source is sending directly to us,
	 * and if packet was not source routed (or has any options).
	 * Also, don't send redirect if forwarding using a default route
	 * or a route modified by a redirect.
	 */</span>
	RT_LOCK_SPIN(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp == m-&gt;m_pkthdr.rcvif &amp;&amp;
	    !(rt-&gt;rt_flags &amp; (RTF_DYNAMIC|RTF_MODIFIED)) &amp;&amp;
	    satosin(rt_key(rt))-&gt;sin_addr.s_addr != INADDR_ANY &amp;&amp;
	    ipsendredirects &amp;&amp; !srcrt &amp;&amp; rt-&gt;rt_ifa != NULL) {
		<span class="enscript-type">struct</span> in_ifaddr *ia = (<span class="enscript-type">struct</span> in_ifaddr *)rt-&gt;rt_ifa;
		u_int32_t src = ntohl(ip-&gt;ip_src.s_addr);

		<span class="enscript-comment">/* Become a regular mutex */</span>
		RT_CONVERT_LOCK(rt);
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((src &amp; ia-&gt;ia_subnetmask) == ia-&gt;ia_subnet) {
			<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY)
				dest = satosin(rt-&gt;rt_gateway)-&gt;sin_addr.s_addr;
			<span class="enscript-keyword">else</span>
				dest = pkt_dst.s_addr;
			<span class="enscript-comment">/*
			 * Router requirements says to only send
			 * host redirects.
			 */</span>
			type = ICMP_REDIRECT;
			code = ICMP_REDIRECT_HOST;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (ipprintfs)
				printf(<span class="enscript-string">&quot;redirect (%d) to %lx\n&quot;</span>, code,
				    (u_int32_t)dest);
#<span class="enscript-reference">endif</span>
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	RT_UNLOCK(rt);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
	<span class="enscript-keyword">if</span> (next_hop != NULL) {
		<span class="enscript-comment">/* Pass IPFORWARD info if available */</span>
		<span class="enscript-type">struct</span> m_tag *tag;
		<span class="enscript-type">struct</span> ip_fwd_tag *ipfwd_tag;

		tag = m_tag_create(KERNEL_MODULE_TAG_ID,
		    KERNEL_TAG_TYPE_IPFORWARD,
		    <span class="enscript-keyword">sizeof</span> (*ipfwd_tag), M_NOWAIT, m);
		<span class="enscript-keyword">if</span> (tag == NULL) {
			error = ENOBUFS;
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		ipfwd_tag = (<span class="enscript-type">struct</span> ip_fwd_tag *)(tag+1);
		ipfwd_tag-&gt;next_hop = next_hop;

		m_tag_prepend(m, tag);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>

	<span class="enscript-comment">/* Mark this packet as being forwarded from another interface */</span>
	m-&gt;m_pkthdr.pkt_flags |= PKTF_FORWARDED;
	len = m_pktlen(m);

	error = ip_output(m, NULL, &amp;fwd_rt, IP_FORWARDING | IP_OUTARGS,
	    NULL, &amp;ipoa);

	<span class="enscript-comment">/* Refresh rt since the route could have changed while in IP */</span>
	rt = fwd_rt.ro_rt;

	<span class="enscript-keyword">if</span> (error != 0) {
		OSAddAtomic(1, &amp;ipstat.ips_cantforward);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Increment stats on the source interface; the ones
		 * for destination interface has been taken care of
		 * during output above by virtue of PKTF_FORWARDED.
		 */</span>
		rcvifp-&gt;if_fpackets++;
		rcvifp-&gt;if_fbytes += len;

		OSAddAtomic(1, &amp;ipstat.ips_forward);
		<span class="enscript-keyword">if</span> (type != 0) {
			OSAddAtomic(1, &amp;ipstat.ips_redirectsent);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (mcopy != NULL) {
				<span class="enscript-comment">/*
				 * If we didn't have to go thru ipflow and
				 * the packet was successfully consumed by
				 * ip_output, the mcopy is rather a waste;
				 * this could be further optimized.
				 */</span>
				m_freem(mcopy);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	<span class="enscript-keyword">if</span> (mcopy == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:				<span class="enscript-comment">/* forwarded, but need redirect */</span>
		<span class="enscript-comment">/* type, code set above */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:		<span class="enscript-comment">/* shouldn't happen, checked above */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
	<span class="enscript-reference">default</span>:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_HOST;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
		type = ICMP_UNREACH;
		code = ICMP_UNREACH_NEEDFRAG;

		<span class="enscript-keyword">if</span> (rt == NULL) {
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			RT_LOCK_SPIN(rt);
			<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != NULL)
				nextmtu = rt-&gt;rt_ifp-&gt;if_mtu;
			RT_UNLOCK(rt);
		}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-keyword">if</span> (ipsec_bypass)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * If the packet is routed over IPsec tunnel, tell the
		 * originator the tunnel MTU.
		 *	tunnel MTU = if MTU - sizeof(IP) - ESP/AH hdrsiz
		 * XXX quickhack!!!
		 */</span>
		sp = ipsec4_getpolicybyaddr(mcopy, IPSEC_DIR_OUTBOUND,
		    IP_FORWARDING, &amp;ipsecerror);

		<span class="enscript-keyword">if</span> (sp == NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * find the correct route for outer IPv4
		 * header, compute tunnel MTU.
		 */</span>
		nextmtu = 0;

		<span class="enscript-keyword">if</span> (sp-&gt;req != NULL &amp;&amp;
		    sp-&gt;req-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
			<span class="enscript-type">struct</span> secasindex saidx;
			<span class="enscript-type">struct</span> secasvar *sav;
			<span class="enscript-type">struct</span> route *ro;
			<span class="enscript-type">struct</span> ip *ipm;
			<span class="enscript-type">int</span> ipsechdr;

			<span class="enscript-comment">/* count IPsec header size */</span>
			ipsechdr = ipsec_hdrsiz(sp);

			ipm = mtod(mcopy, <span class="enscript-type">struct</span> ip *);
			bcopy(&amp;sp-&gt;req-&gt;saidx, &amp;saidx, <span class="enscript-keyword">sizeof</span> (saidx));
			saidx.mode = sp-&gt;req-&gt;saidx.mode;
			saidx.reqid = sp-&gt;req-&gt;saidx.reqid;
			sin = SIN(&amp;saidx.src);
			<span class="enscript-keyword">if</span> (sin-&gt;sin_len == 0) {
				sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);
				sin-&gt;sin_family = AF_INET;
				sin-&gt;sin_port = IPSEC_PORT_ANY;
				bcopy(&amp;ipm-&gt;ip_src, &amp;sin-&gt;sin_addr,
				    <span class="enscript-keyword">sizeof</span> (sin-&gt;sin_addr));
			}
			sin = SIN(&amp;saidx.dst);
			<span class="enscript-keyword">if</span> (sin-&gt;sin_len == 0) {
				sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (*sin);
				sin-&gt;sin_family = AF_INET;
				sin-&gt;sin_port = IPSEC_PORT_ANY;
				bcopy(&amp;ipm-&gt;ip_dst, &amp;sin-&gt;sin_addr,
				    <span class="enscript-keyword">sizeof</span> (sin-&gt;sin_addr));
			}
			sav = key_allocsa_policy(&amp;saidx);
			<span class="enscript-keyword">if</span> (sav != NULL) {
				lck_mtx_lock(sadb_mutex);
				<span class="enscript-keyword">if</span> (sav-&gt;sah != NULL) {
					ro = &amp;sav-&gt;sah-&gt;sa_route;
					<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
						RT_LOCK(ro-&gt;ro_rt);
						<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_ifp != NULL) {
							nextmtu = ro-&gt;ro_rt-&gt;
							    rt_ifp-&gt;if_mtu;
							nextmtu -= ipsechdr;
						}
						RT_UNLOCK(ro-&gt;ro_rt);
					}
				}
				key_freesav(sav, KEY_SADB_LOCKED);
				lck_mtx_unlock(sadb_mutex);
			}
		}
		key_freesp(sp, KEY_SADB_UNLOCKED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
		<span class="enscript-comment">/*
		 * A router should not generate ICMP_SOURCEQUENCH as
		 * required in RFC1812 Requirements for IP Version 4 Routers.
		 * Source quench could be a big problem under DoS attacks,
		 * or if the underlying interface is rate-limited.
		 * Those who need source quench packets may re-enable them
		 * via the net.inet.ip.sendsourcequench sysctl.
		 */</span>
		<span class="enscript-keyword">if</span> (ip_sendsourcequench == 0) {
			m_freem(mcopy);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> {
			type = ICMP_SOURCEQUENCH;
			code = 0;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">EACCES</span>:			<span class="enscript-comment">/* ipfw denied packet */</span>
		m_freem(mcopy);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (type == ICMP_UNREACH &amp;&amp; code == ICMP_UNREACH_NEEDFRAG)
		OSAddAtomic(1, &amp;ipstat.ips_cantfrag);

	icmp_error(mcopy, type, code, dest, nextmtu);
<span class="enscript-reference">done</span>:
	ip_fwd_route_copyin(rcvifp, &amp;fwd_rt);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_savecontrol</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> ip *ip,
    <span class="enscript-type">struct</span> mbuf *m)
{
	*mp = NULL;
	<span class="enscript-keyword">if</span> (inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) {
		<span class="enscript-type">struct</span> timeval tv;

		getmicrotime(&amp;tv);
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;tv, <span class="enscript-keyword">sizeof</span> (tv),
		    SCM_TIMESTAMP, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) {
		uint64_t time;

		time = mach_absolute_time();
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;time, <span class="enscript-keyword">sizeof</span> (time),
		    SCM_TIMESTAMP_MONOTONIC, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECVDSTADDR) {
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;ip-&gt;ip_dst,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr), IP_RECVDSTADDR, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
	<span class="enscript-comment">/*
	 * XXX
	 * Moving these out of udp_input() made them even more broken
	 * than they already were.
	 */</span>
	<span class="enscript-comment">/* options were tossed already */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECVOPTS) {
		mp = sbcreatecontrol_mbuf((caddr_t)opts_deleted_above,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr), IP_RECVOPTS, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-comment">/* ip_srcroute doesn't do what we want here, need to fix */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECVRETOPTS) {
		mp = sbcreatecontrol_mbuf((caddr_t)ip_srcroute(),
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr), IP_RECVRETOPTS, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* notyet */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECVIF) {
		<span class="enscript-type">struct</span> ifnet *ifp;
		uint8_t sdlbuf[SOCK_MAXADDRLEN + 1];
		<span class="enscript-type">struct</span> sockaddr_dl *sdl2 = SDL(&amp;sdlbuf);

		<span class="enscript-comment">/*
		 * Make sure to accomodate the largest possible
		 * size of SA(if_lladdr)-&gt;sa_len.
		 */</span>
		_CASSERT(<span class="enscript-keyword">sizeof</span> (sdlbuf) == (SOCK_MAXADDRLEN + 1));

		ifnet_head_lock_shared();
		<span class="enscript-keyword">if</span> ((ifp = m-&gt;m_pkthdr.rcvif) != NULL &amp;&amp;
		    ifp-&gt;if_index &amp;&amp; (ifp-&gt;if_index &lt;= if_index)) {
			<span class="enscript-type">struct</span> ifaddr *ifa = ifnet_addrs[ifp-&gt;if_index - 1];
			<span class="enscript-type">struct</span> sockaddr_dl *sdp;

			<span class="enscript-keyword">if</span> (!ifa || !ifa-&gt;ifa_addr)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">makedummy</span>;

			IFA_LOCK_SPIN(ifa);
			sdp = SDL(ifa-&gt;ifa_addr);
			<span class="enscript-comment">/*
			 * Change our mind and don't try copy.
			 */</span>
			<span class="enscript-keyword">if</span> (sdp-&gt;sdl_family != AF_LINK) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">makedummy</span>;
			}
			<span class="enscript-comment">/* the above _CASSERT ensures sdl_len fits in sdlbuf */</span>
			bcopy(sdp, sdl2, sdp-&gt;sdl_len);
			IFA_UNLOCK(ifa);
		} <span class="enscript-keyword">else</span> {
<span class="enscript-reference">makedummy</span>:
			sdl2-&gt;sdl_len =
			    offsetof(<span class="enscript-type">struct</span> sockaddr_dl, sdl_data[0]);
			sdl2-&gt;sdl_family = AF_LINK;
			sdl2-&gt;sdl_index = 0;
			sdl2-&gt;sdl_nlen = sdl2-&gt;sdl_alen = sdl2-&gt;sdl_slen = 0;
		}
		ifnet_head_done();
		mp = sbcreatecontrol_mbuf((caddr_t)sdl2, sdl2-&gt;sdl_len,
		    IP_RECVIF, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_RECVTTL) {
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;ip-&gt;ip_ttl,
		    <span class="enscript-keyword">sizeof</span> (ip-&gt;ip_ttl), IP_RECVTTL, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_socket-&gt;so_flags &amp; SOF_RECV_TRAFFIC_CLASS) {
		<span class="enscript-type">int</span> tc = m_get_traffic_class(m);

		mp = sbcreatecontrol_mbuf((caddr_t)&amp;tc, <span class="enscript-keyword">sizeof</span> (tc),
		    SO_TRAFFIC_CLASS, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_PKTINFO) {
		<span class="enscript-type">struct</span> in_pktinfo pi;

		bzero(&amp;pi, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_pktinfo));
		bcopy(&amp;ip-&gt;ip_dst, &amp;pi.ipi_addr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_addr));
		pi.ipi_ifindex = (m != NULL &amp;&amp; m-&gt;m_pkthdr.rcvif != NULL) ?
		    m-&gt;m_pkthdr.rcvif-&gt;if_index : 0;

		mp = sbcreatecontrol_mbuf((caddr_t)&amp;pi,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in_pktinfo), IP_RECVPKTINFO, IPPROTO_IP, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
		}
	}
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">no_mbufs</span>:
	ipstat.ips_pktdropcntrl++;
	<span class="enscript-keyword">return</span> (ENOBUFS);
}

<span class="enscript-type">static</span> inline u_short
<span class="enscript-function-name">ip_cksum</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hlen)
{
	u_short sum;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP_CHECKED) {
		sum = !(m-&gt;m_pkthdr.csum_flags &amp; CSUM_IP_VALID);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.rcvif-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		<span class="enscript-comment">/*
		 * The packet arrived on an interface which isn't capable
		 * of performing IP header checksum; compute it now.
		 */</span>
		sum = ip_cksum_hdr_in(m, hlen);
	} <span class="enscript-keyword">else</span> {
		sum = 0;
		m-&gt;m_pkthdr.csum_flags |= (CSUM_DATA_VALID | CSUM_PSEUDO_HDR |
		    CSUM_IP_CHECKED | CSUM_IP_VALID);
		m-&gt;m_pkthdr.csum_data = 0xffff;
	}

	<span class="enscript-keyword">if</span> (sum != 0)
		OSAddAtomic(1, &amp;ipstat.ips_badsum);

	<span class="enscript-keyword">return</span> (sum);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
ip_getstat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;ipstat, MIN(<span class="enscript-keyword">sizeof</span> (ipstat), req-&gt;oldlen)));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_setsrcifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t src_idx, <span class="enscript-type">struct</span> in_ifaddr *ia)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/*
	 * If the source ifaddr is specified, pick up the information
	 * from there; otherwise just grab the passed-in ifindex as the
	 * caller may not have the ifaddr available.
	 */</span>
	<span class="enscript-keyword">if</span> (ia != NULL) {
		m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
		m-&gt;m_pkthdr.src_ifindex = ia-&gt;ia_ifp-&gt;if_index;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.src_ifindex = src_idx;
		<span class="enscript-keyword">if</span> (src_idx != 0)
			m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip_setdstifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t dst_idx, <span class="enscript-type">struct</span> in_ifaddr *ia)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/*
	 * If the destination ifaddr is specified, pick up the information
	 * from there; otherwise just grab the passed-in ifindex as the
	 * caller may not have the ifaddr available.
	 */</span>
	<span class="enscript-keyword">if</span> (ia != NULL) {
		m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
		m-&gt;m_pkthdr.dst_ifindex = ia-&gt;ia_ifp-&gt;if_index;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.dst_ifindex = dst_idx;
		<span class="enscript-keyword">if</span> (dst_idx != 0)
			m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_getsrcifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t *src_idx, uint32_t *iaf)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (src_idx != NULL)
		*src_idx = m-&gt;m_pkthdr.src_ifindex;

	<span class="enscript-keyword">if</span> (iaf != NULL)
		*iaf = 0;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_getdstifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t *dst_idx, uint32_t *iaf)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (dst_idx != NULL)
		*dst_idx = m-&gt;m_pkthdr.dst_ifindex;

	<span class="enscript-keyword">if</span> (iaf != NULL)
		*iaf = 0;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Protocol input handler for IPPROTO_GRE.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">gre_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off)
{
	gre_input_func_t fn = gre_input_func;

	<span class="enscript-comment">/*
	 * If there is a registered GRE input handler, pass mbuf to it.
	 */</span>
	<span class="enscript-keyword">if</span> (fn != NULL) {
		lck_mtx_unlock(inet_domain_mutex);
		m = fn(m, off, (mtod(m, <span class="enscript-type">struct</span> ip *))-&gt;ip_p);
		lck_mtx_lock(inet_domain_mutex);
	}

	<span class="enscript-comment">/*
	 * If no matching tunnel that is up is found, we inject
	 * the mbuf to raw ip socket to see if anyone picks it up.
	 */</span>
	<span class="enscript-keyword">if</span> (m != NULL)
		rip_input(m, off);
}

<span class="enscript-comment">/*
 * Private KPI for PPP/PPTP.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip_gre_register_input</span>(gre_input_func_t fn)
{
	lck_mtx_lock(inet_domain_mutex);
	gre_input_func = fn;
	lck_mtx_unlock(inet_domain_mutex);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_reset_ip_input_stats SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	i = ip_input_measure;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* impose bounds */</span>
	<span class="enscript-keyword">if</span> (i &lt; 0 || i &gt; 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (ip_input_measure != i &amp;&amp; i == 1) {
		net_perf_initialize(&amp;net_perf, ip_input_measure_bins);
	}
	ip_input_measure = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip_input_measure_bins SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	uint64_t i;

	i = ip_input_measure_bins;
	error = sysctl_handle_quad(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* validate data */</span>
	<span class="enscript-keyword">if</span> (!net_perf_validate_bins(i)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	ip_input_measure_bins = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip_input_getperf SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;net_perf, MIN(<span class="enscript-keyword">sizeof</span> (net_perf), req-&gt;oldlen)));
}

</pre>
<hr />
</body></html>