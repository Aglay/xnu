<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_bsm_klib.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_bsm_klib.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 1999-2009 Apple Inc.
 * Copyright (c) 2005 Robert N. M. Watson
 * All rights reserved.
 *
 * @APPLE_BSD_LICENSE_HEADER_START@
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * @APPLE_BSD_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sem.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
<span class="enscript-comment">/*
 * Hash table functions for the audit event number to event class mask
 * mapping.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EVCLASSMAP_HASH_TABLE_SIZE</span>	251
<span class="enscript-type">struct</span> evclass_elem {
	au_event_t event;
	au_class_t class;
	LIST_ENTRY(evclass_elem) entry;
};
<span class="enscript-type">struct</span> evclass_list {
	LIST_HEAD(, evclass_elem) head;
};

<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDITEVCLASS, <span class="enscript-string">&quot;audit_evclass&quot;</span>, <span class="enscript-string">&quot;Audit event class&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rwlock   		evclass_lock;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> evclass_list 	evclass_hash[EVCLASSMAP_HASH_TABLE_SIZE];

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">EVCLASS_LOCK_INIT</span>()	rw_init(&amp;evclass_lock, <span class="enscript-string">&quot;evclass_lock&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">EVCLASS_RLOCK</span>()		rw_rlock(&amp;evclass_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">EVCLASS_RUNLOCK</span>()	rw_runlock(&amp;evclass_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">EVCLASS_WLOCK</span>()		rw_wlock(&amp;evclass_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">EVCLASS_WUNLOCK</span>()	rw_wunlock(&amp;evclass_lock)

<span class="enscript-comment">/*
 * Look up the class for an audit event in the class mapping table.
 */</span>
au_class_t
<span class="enscript-function-name">au_event_class</span>(au_event_t event)
{
	<span class="enscript-type">struct</span> evclass_list *evcl;
	<span class="enscript-type">struct</span> evclass_elem *evc;
	au_class_t class;

	EVCLASS_RLOCK();
	evcl = &amp;evclass_hash[event % EVCLASSMAP_HASH_TABLE_SIZE];
	class = 0;
	LIST_FOREACH(evc, &amp;evcl-&gt;head, entry) {
		<span class="enscript-keyword">if</span> (evc-&gt;event == event) {
			class = evc-&gt;class;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
<span class="enscript-reference">out</span>:
	EVCLASS_RUNLOCK();
	<span class="enscript-keyword">return</span> (class);
}

<span class="enscript-comment">/*
 * Insert a event to class mapping. If the event already exists in the
 * mapping, then replace the mapping with the new one.
 *
 * XXX There is currently no constraints placed on the number of mappings.
 * May want to either limit to a number, or in terms of memory usage.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">au_evclassmap_insert</span>(au_event_t event, au_class_t class)
{
	<span class="enscript-type">struct</span> evclass_list *evcl;
	<span class="enscript-type">struct</span> evclass_elem *evc, *evc_new;

	<span class="enscript-comment">/*
	 * If this event requires auditing a system call then add it to  our
	 * audit kernel event mask.  We use audit_kevent_mask to check to see
	 * if the audit syscalls flag needs to be set when preselection masks
	 * are set.
	 */</span>
	<span class="enscript-keyword">if</span> (AUE_IS_A_KEVENT(event))
		audit_kevent_mask |= class; 

	<span class="enscript-comment">/*
	 * Pessimistically, always allocate storage before acquiring mutex.
	 * Free if there is already a mapping for this event.
	 */</span>
	evc_new = malloc(<span class="enscript-keyword">sizeof</span>(*evc), M_AUDITEVCLASS, M_WAITOK);
	
	EVCLASS_WLOCK();
	evcl = &amp;evclass_hash[event % EVCLASSMAP_HASH_TABLE_SIZE];
	LIST_FOREACH(evc, &amp;evcl-&gt;head, entry) {
		<span class="enscript-keyword">if</span> (evc-&gt;event == event) {
			evc-&gt;class = class;
			EVCLASS_WUNLOCK();
			free(evc_new, M_AUDITEVCLASS);
			<span class="enscript-keyword">return</span>;
		}
	}
	evc = evc_new;
	evc-&gt;event = event;
	evc-&gt;class = class;
	LIST_INSERT_HEAD(&amp;evcl-&gt;head, evc, entry);
	EVCLASS_WUNLOCK();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">au_evclassmap_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	EVCLASS_LOCK_INIT();
	<span class="enscript-keyword">for</span> (i = 0; i &lt; EVCLASSMAP_HASH_TABLE_SIZE; i++)
		LIST_INIT(&amp;evclass_hash[i].head);

	<span class="enscript-comment">/*
	 * Set up the initial event to class mapping for system calls.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NUM_SYSENT; i++) {
		<span class="enscript-keyword">if</span> (sys_au_event[i] != AUE_NULL)
			au_evclassmap_insert(sys_au_event[i], 0);

	}

	<span class="enscript-comment">/*
	 *  Add the Mach system call events. These are not in sys_au_event[].
	 */</span>
	au_evclassmap_insert(AUE_TASKFORPID, 0);
	au_evclassmap_insert(AUE_PIDFORTASK, 0);
	au_evclassmap_insert(AUE_SWAPON, 0);
	au_evclassmap_insert(AUE_SWAPOFF, 0);
	au_evclassmap_insert(AUE_MAPFD, 0);
	au_evclassmap_insert(AUE_INITPROCESS, 0);
}

<span class="enscript-comment">/*
 * Check whether an event is aditable by comparing the mask of classes this
 * event is part of against the given mask.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">au_preselect</span>(__unused au_event_t event, au_class_t class, au_mask_t *mask_p,
    <span class="enscript-type">int</span> sorf)
{
	au_class_t effmask = 0;

	<span class="enscript-keyword">if</span> (mask_p == NULL)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/*
	 * Perform the actual check of the masks against the event.
	 */</span>
	<span class="enscript-keyword">if</span> (sorf &amp; AU_PRS_SUCCESS)
		effmask |= (mask_p-&gt;am_success &amp; class);

	<span class="enscript-keyword">if</span> (sorf &amp; AU_PRS_FAILURE)
		effmask |= (mask_p-&gt;am_failure &amp; class);

	<span class="enscript-keyword">if</span> (effmask)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Convert sysctl names and present arguments to events.
 */</span>
au_event_t
<span class="enscript-function-name">audit_ctlname_to_sysctlevent</span>(<span class="enscript-type">int</span> name[], uint64_t valid_arg)
{

	<span class="enscript-comment">/* can't parse it - so return the worst case */</span>
	<span class="enscript-keyword">if</span> ((valid_arg &amp; (ARG_CTLNAME | ARG_LEN)) != (ARG_CTLNAME | ARG_LEN))
		<span class="enscript-keyword">return</span> (AUE_SYSCTL);

	<span class="enscript-keyword">switch</span> (name[0]) {
	<span class="enscript-comment">/* non-admin &quot;lookups&quot; treat them special */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OSTYPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OSRELEASE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OSREV</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_VERSION</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_ARGMAX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_CLOCKRATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_BOOTTIME</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_POSIX1</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_NGROUPS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_JOB_CONTROL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SAVED_IDS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OSRELDATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_NETBOOT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SYMFILE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SHREG_PRIVATIZABLE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OSVERSION</span>:
		<span class="enscript-keyword">return</span> (AUE_SYSCTL_NONADMIN);

	<span class="enscript-comment">/* only treat the changeable controls as admin */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MAXVNODES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MAXPROC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MAXFILES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MAXPROCPERUID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_MAXFILESPERPROC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_HOSTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_AIOMAX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_AIOPROCMAX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_AIOTHREADS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_COREDUMP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUGID_COREDUMP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_NX_PROTECTION</span>:
		<span class="enscript-keyword">return</span> ((valid_arg &amp; ARG_VALUE32) ?
		    AUE_SYSCTL : AUE_SYSCTL_NONADMIN);

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (AUE_SYSCTL);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * Convert an open flags specifier into a specific type of open event for
 * auditing purposes.
 */</span>
au_event_t
<span class="enscript-function-name">audit_flags_and_error_to_openevent</span>(<span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error)
{
	au_event_t aevent;

	<span class="enscript-comment">/*
	 * Need to check only those flags we care about.
	 */</span>
	oflags = oflags &amp; (O_RDONLY | O_CREAT | O_TRUNC | O_RDWR | O_WRONLY);

	<span class="enscript-comment">/*
	 * These checks determine what flags are on with the condition that
	 * ONLY that combination is on, and no other flags are on.
	 */</span>
	<span class="enscript-keyword">switch</span> (oflags) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDONLY</span>:
		aevent = AUE_OPEN_R;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT):
		aevent = AUE_OPEN_RC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_RTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_TRUNC):
		aevent = AUE_OPEN_RT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDWR</span>:
		aevent = AUE_OPEN_RW;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT):
		aevent = AUE_OPEN_RWC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_RWTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_TRUNC):
		aevent = AUE_OPEN_RWT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_WRONLY</span>:
		aevent = AUE_OPEN_W;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT):
		aevent = AUE_OPEN_WC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_WTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_TRUNC):
		aevent = AUE_OPEN_WT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		aevent = AUE_OPEN;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Convert chatty errors to better matching events.  Failures to
	 * find a file are really just attribute events -- so recast them as
	 * such.
	 *
	 * XXXAUDIT: Solaris defines that AUE_OPEN will never be returned, it
	 * is just a placeholder.  However, in Darwin we return that in
	 * preference to other events.
	 *
	 * XXXRW: This behavior differs from FreeBSD, so possibly revise this
	 * code or this comment.
	 */</span>
	<span class="enscript-keyword">switch</span> (aevent) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_R</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_RT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_RW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_RWT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_W</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_WT</span>:
		<span class="enscript-keyword">if</span> (error == ENOENT)
			aevent = AUE_OPEN;
	}
	<span class="enscript-keyword">return</span> (aevent);
}

<span class="enscript-comment">/*
 * Convert an open flags specifier into a specific type of open_extended event
 * for auditing purposes.
 */</span>
au_event_t
<span class="enscript-function-name">audit_flags_and_error_to_openextendedevent</span>(<span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error)
{
	au_event_t aevent;

	<span class="enscript-comment">/*
	 * Need to check only those flags we care about.
	 */</span>
	oflags = oflags &amp; (O_RDONLY | O_CREAT | O_TRUNC | O_RDWR | O_WRONLY);

	<span class="enscript-comment">/*
	 * These checks determine what flags are on with the condition that
	 * ONLY that combination is on, and no other flags are on.
	 */</span>
	<span class="enscript-keyword">switch</span> (oflags) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDONLY</span>:
		aevent = AUE_OPEN_EXTENDED_R;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT):
		aevent = AUE_OPEN_EXTENDED_RC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_RTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_RT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDWR</span>:
		aevent = AUE_OPEN_EXTENDED_RW;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT):
		aevent = AUE_OPEN_EXTENDED_RWC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_RWTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_RWT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_WRONLY</span>:
		aevent = AUE_OPEN_EXTENDED_W;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT):
		aevent = AUE_OPEN_EXTENDED_WC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_WTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_TRUNC):
		aevent = AUE_OPEN_EXTENDED_WT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		aevent = AUE_OPEN_EXTENDED;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Convert chatty errors to better matching events.  Failures to
	 * find a file are really just attribute events -- so recast them as
	 * such.
	 *
	 * XXXAUDIT: Solaris defines that AUE_OPEN will never be returned, it
	 * is just a placeholder.  However, in Darwin we return that in
	 * preference to other events.
	 *
	 * XXXRW: This behavior differs from FreeBSD, so possibly revise this
	 * code or this comment.
	 */</span>
	<span class="enscript-keyword">switch</span> (aevent) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_R</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_RT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_RW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_RWT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_W</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_WT</span>:
		<span class="enscript-keyword">if</span> (error == ENOENT)
			aevent = AUE_OPEN_EXTENDED;
	}
	<span class="enscript-keyword">return</span> (aevent);
}

<span class="enscript-comment">/*
 * Convert an open flags specifier into a specific type of open_extended event
 * for auditing purposes.
 */</span>
au_event_t
<span class="enscript-function-name">audit_flags_and_error_to_openatevent</span>(<span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error)
{
	au_event_t aevent;

	<span class="enscript-comment">/*
	 * Need to check only those flags we care about.
	 */</span>
	oflags = oflags &amp; (O_RDONLY | O_CREAT | O_TRUNC | O_RDWR | O_WRONLY);

	<span class="enscript-comment">/*
	 * These checks determine what flags are on with the condition that
	 * ONLY that combination is on, and no other flags are on.
	 */</span>
	<span class="enscript-keyword">switch</span> (oflags) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDONLY</span>:
		aevent = AUE_OPENAT_R;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT):
		aevent = AUE_OPENAT_RC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPENAT_RTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_TRUNC):
		aevent = AUE_OPENAT_RT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDWR</span>:
		aevent = AUE_OPENAT_RW;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT):
		aevent = AUE_OPENAT_RWC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_CREAT | O_TRUNC):
		aevent = AUE_OPENAT_RWTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_TRUNC):
		aevent = AUE_OPENAT_RWT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_WRONLY</span>:
		aevent = AUE_OPENAT_W;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT):
		aevent = AUE_OPENAT_WC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_CREAT | O_TRUNC):
		aevent = AUE_OPENAT_WTC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_TRUNC):
		aevent = AUE_OPENAT_WT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		aevent = AUE_OPENAT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Convert chatty errors to better matching events.  Failures to
	 * find a file are really just attribute events -- so recast them as
	 * such.
	 *
	 * XXXAUDIT: Solaris defines that AUE_OPENAT will never be returned, it
	 * is just a placeholder.  However, in Darwin we return that in
	 * preference to other events.
	 *
	 * XXXRW: This behavior differs from FreeBSD, so possibly revise this
	 * code or this comment.
	 */</span>
	<span class="enscript-keyword">switch</span> (aevent) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_R</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_RT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_RW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_RWT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_W</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_WT</span>:
		<span class="enscript-keyword">if</span> (error == ENOENT)
			aevent = AUE_OPENAT;
	}
	<span class="enscript-keyword">return</span> (aevent);
}

<span class="enscript-comment">/*
 * Convert an open flags specifier into a specific type of openbyid event
 * for auditing purposes.
 */</span>
au_event_t
<span class="enscript-function-name">audit_flags_and_error_to_openbyidevent</span>(<span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error)
{
	au_event_t aevent;

	<span class="enscript-comment">/*
	 * Need to check only those flags we care about.
	 */</span>
	oflags = oflags &amp; (O_RDONLY | O_TRUNC | O_RDWR | O_WRONLY);

	<span class="enscript-comment">/*
	 * These checks determine what flags are on with the condition that
	 * ONLY that combination is on, and no other flags are on.
	 */</span>
	<span class="enscript-keyword">switch</span> (oflags) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDONLY</span>:
		aevent = AUE_OPENBYID_R;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDONLY | O_TRUNC):
		aevent = AUE_OPENBYID_RT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_RDWR</span>:
		aevent = AUE_OPENBYID_RW;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_RDWR | O_TRUNC):
		aevent = AUE_OPENBYID_RWT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">O_WRONLY</span>:
		aevent = AUE_OPENBYID_W;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> (O_WRONLY | O_TRUNC):
		aevent = AUE_OPENBYID_WT;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		aevent = AUE_OPENBYID;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Convert chatty errors to better matching events.  Failures to
	 * find a file are really just attribute events -- so recast them as
	 * such.
	 */</span>
	<span class="enscript-keyword">switch</span> (aevent) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_R</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_RT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_RW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_RWT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_W</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_WT</span>:
		<span class="enscript-keyword">if</span> (error == ENOENT)
			aevent = AUE_OPENBYID;
	}
	<span class="enscript-keyword">return</span> (aevent);
}

<span class="enscript-comment">/*
 * Convert a MSGCTL command to a specific event.
 */</span>
au_event_t
<span class="enscript-function-name">audit_msgctl_to_event</span>(<span class="enscript-type">int</span> cmd)
{

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_RMID</span>:
		<span class="enscript-keyword">return</span> (AUE_MSGCTL_RMID);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_SET</span>:
		<span class="enscript-keyword">return</span> (AUE_MSGCTL_SET);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_STAT</span>:
		<span class="enscript-keyword">return</span> (AUE_MSGCTL_STAT);

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* We will audit a bad command. */</span>
		<span class="enscript-keyword">return</span> (AUE_MSGCTL);
	}
}

<span class="enscript-comment">/*
 * Convert a SEMCTL command to a specific event.
 */</span>
au_event_t
<span class="enscript-function-name">audit_semctl_to_event</span>(<span class="enscript-type">int</span> cmd)
{

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETALL</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_GETALL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETNCNT</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_GETNCNT);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETPID</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_GETPID);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETVAL</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_GETVAL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETZCNT</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_GETZCNT);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_RMID</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_RMID);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_SET</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_SET);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SETALL</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_SETALL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SETVAL</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_SETVAL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_STAT</span>:
		<span class="enscript-keyword">return</span> (AUE_SEMCTL_STAT);

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* We will audit a bad command. */</span>
		<span class="enscript-keyword">return</span> (AUE_SEMCTL);
	}
}

<span class="enscript-comment">/*
 * Convert a command for the auditon() system call to a audit event.
 */</span>
au_event_t
<span class="enscript-function-name">auditon_command_event</span>(<span class="enscript-type">int</span> cmd)
{

	<span class="enscript-keyword">switch</span>(cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPOLICY</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GPOLICY);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPOLICY</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SPOLICY);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKMASK</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETKMASK);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKMASK</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETKMASK);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETQCTRL</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GQCTRL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETQCTRL</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SQCTRL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCWD</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETCWD);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCAR</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETCAR);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSTAT</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETSTAT);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSTAT</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETSTAT);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETUMASK</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETUMASK);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSMASK</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETSMASK);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCOND</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETCOND);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCOND</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETCOND);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCLASS</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_GETCLASS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCLASS</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON_SETCLASS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETFSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETFSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO_ADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKAUDIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKAUDIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSINFO_ADDR</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (AUE_AUDITON);	<span class="enscript-comment">/* No special record */</span>
	}
}

<span class="enscript-comment">/*
 * For darwin we rewrite events generated by fcntl(F_OPENFROM,...) and
 * fcntl(F_UNLINKFROM,...) system calls to AUE_OPENAT_* and AUE_UNLINKAT audit
 * events. 
 */</span>
au_event_t
<span class="enscript-function-name">audit_fcntl_command_event</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">switch</span>(cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_OPENFROM</span>:
		<span class="enscript-keyword">return</span> (audit_flags_and_error_to_openatevent(oflags, error));
		
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLINKFROM</span>:
		<span class="enscript-keyword">return</span> (AUE_UNLINKAT);

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (AUE_FCNTL);   <span class="enscript-comment">/* Don't change from AUE_FCNTL. */</span>
	}
}

<span class="enscript-comment">/*
 * Create a canonical path from given path by prefixing either the root
 * directory, or the current working directory. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_canon_path</span>(<span class="enscript-type">struct</span> vnode *cwd_vp, <span class="enscript-type">char</span> *path, <span class="enscript-type">char</span> *cpath)
{
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">char</span> *bufp = path;

	<span class="enscript-comment">/*
	 * Convert multiple leading '/' into a single '/' if the cwd_vp is
	 * NULL (i.e. an absolute path), and strip them entirely if the
	 * cwd_vp represents a chroot directory (i.e. the caller checked for
	 * an initial '/' character itself, saw one, and passed fdp-&gt;fd_rdir).
	 * Somewhat complicated, but it places the onus for locking structs
	 * involved on the caller, and makes proxy operations explicit rather
	 * than implicit.
	 */</span>
	<span class="enscript-keyword">if</span> (*(path) == <span class="enscript-string">'/'</span>) {
		<span class="enscript-keyword">while</span> (*(bufp) == <span class="enscript-string">'/'</span>)
			bufp++;		<span class="enscript-comment">/* skip leading '/'s */</span>
		<span class="enscript-keyword">if</span> (cwd_vp == NULL)
			bufp--;		<span class="enscript-comment">/* restore one '/' */</span>
	}
	<span class="enscript-keyword">if</span> (cwd_vp != NULL) {
		len = MAXPATHLEN;
		ret = vn_getpath(cwd_vp, cpath, &amp;len);
		<span class="enscript-keyword">if</span> (ret != 0) {
			cpath[0] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">return</span> (ret);
		}
		<span class="enscript-keyword">if</span> (len &lt; MAXPATHLEN)
			cpath[len-1] = <span class="enscript-string">'/'</span>;
		strlcpy(cpath + len, bufp, MAXPATHLEN - len);
	} <span class="enscript-keyword">else</span> {
		strlcpy(cpath, bufp, MAXPATHLEN);
	}
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>