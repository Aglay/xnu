<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_pipe.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_pipe.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 2006 Robert N. M. Watson
 * Copyright (c) 2008-2009 Apple, Inc.
 * All rights reserved.
 *
 * This software was developed by Robert Watson for the TrustedBSD Project.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/poll.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
<span class="enscript-comment">/*
 * Implementation of a clonable special device providing a live stream of BSM
 * audit data.  Consumers receive a &quot;tee&quot; of the system audit trail by
 * default, but may also define alternative event selections using ioctls.
 * This interface provides unreliable but timely access to audit events.
 * Consumers should be very careful to avoid introducing event cycles.
 */</span>

<span class="enscript-comment">/*
 * Memory types.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDIT_PIPE, <span class="enscript-string">&quot;audit_pipe&quot;</span>, <span class="enscript-string">&quot;Audit pipes&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDIT_PIPE_ENTRY, <span class="enscript-string">&quot;audit_pipeent&quot;</span>,
    <span class="enscript-string">&quot;Audit pipe entries and buffers&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDIT_PIPE_PRESELECT, <span class="enscript-string">&quot;audit_pipe_presel&quot;</span>,
    <span class="enscript-string">&quot;Audit pipe preselection structure&quot;</span>);

<span class="enscript-comment">/*
 * Audit pipe buffer parameters.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_QLIMIT_DEFAULT</span>	(128)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_QLIMIT_MIN</span>		(1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_QLIMIT_MAX</span>		(1024)

<span class="enscript-comment">/*
 * Description of an entry in an audit_pipe.
 */</span>
<span class="enscript-type">struct</span> audit_pipe_entry {
	<span class="enscript-type">void</span>				*ape_record;
	u_int				 ape_record_len;
	TAILQ_ENTRY(audit_pipe_entry)	 ape_queue;
};

<span class="enscript-comment">/*
 * Audit pipes allow processes to express &quot;interest&quot; in the set of records
 * that are delivered via the pipe.  They do this in a similar manner to the
 * mechanism for audit trail configuration, by expressing two global masks,
 * and optionally expressing per-auid masks.  The following data structure is
 * the per-auid mask description.  The global state is stored in the audit
 * pipe data structure.
 *
 * We may want to consider a more space/time-efficient data structure once
 * usage patterns for per-auid specifications are clear.
 */</span>
<span class="enscript-type">struct</span> audit_pipe_preselect {
	au_id_t					 app_auid;
	au_mask_t				 app_mask;
	TAILQ_ENTRY(audit_pipe_preselect)	 app_list;
};

<span class="enscript-comment">/*
 * Description of an individual audit_pipe.  Consists largely of a bounded
 * length queue.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_ASYNC</span>	0x00000001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_NBIO</span>		0x00000002
<span class="enscript-type">struct</span> audit_pipe {
	<span class="enscript-type">int</span>				 ap_open;	<span class="enscript-comment">/* Device open? */</span>
	u_int				 ap_flags;

	<span class="enscript-type">struct</span> selinfo			 ap_selinfo;
	pid_t				 ap_sigio;

	<span class="enscript-comment">/*
	 * Per-pipe mutex protecting most fields in this data structure.
	 */</span>
	<span class="enscript-type">struct</span> mtx			 ap_mtx;

	<span class="enscript-comment">/*
	 * Per-pipe sleep lock serializing user-generated reads and flushes.
	 * uiomove() is called to copy out the current head record's data
	 * while the record remains in the queue, so we prevent other threads
	 * from removing it using this lock.
	 */</span>
	<span class="enscript-type">struct</span> slck			 ap_sx;

	<span class="enscript-comment">/*
	 * Condition variable to signal when data has been delivered to a
	 * pipe.
	 */</span>
	<span class="enscript-type">struct</span> cv			 ap_cv;

	<span class="enscript-comment">/*
	 * Various queue-related variables:  qlen and qlimit are a count of
	 * records in the queue; qbyteslen is the number of bytes of data
	 * across all records, and qoffset is the amount read so far of the
	 * first record in the queue.  The number of bytes available for
	 * reading in the queue is qbyteslen - qoffset.
	 */</span>
	u_int				 ap_qlen;
	u_int				 ap_qlimit;
	u_int				 ap_qbyteslen;
	u_int				 ap_qoffset;

	<span class="enscript-comment">/*
	 * Per-pipe operation statistics.
	 */</span>
	u_int64_t			 ap_inserts;	<span class="enscript-comment">/* Records added. */</span>
	u_int64_t			 ap_reads;	<span class="enscript-comment">/* Records read. */</span>
	u_int64_t			 ap_drops;	<span class="enscript-comment">/* Records dropped. */</span>

	<span class="enscript-comment">/*
	 * Fields relating to pipe interest: global masks for unmatched
	 * processes (attributable, non-attributable), and a list of specific
	 * interest specifications by auid.
	 */</span>
	<span class="enscript-type">int</span>				 ap_preselect_mode;
	au_mask_t			 ap_preselect_flags;
	au_mask_t			 ap_preselect_naflags;
	TAILQ_HEAD(, audit_pipe_preselect)	ap_preselect_list;

	<span class="enscript-comment">/*
	 * Current pending record list.  Protected by a combination of ap_mtx
	 * and ap_sx.  Note particularly that *both* locks are required to
	 * remove a record from the head of the queue, as an in-progress read
	 * may sleep while copying and therefore cannot hold ap_mtx.
	 */</span>
	TAILQ_HEAD(, audit_pipe_entry)	 ap_queue;

	<span class="enscript-comment">/*
	 * Global pipe list.
	 */</span>
	TAILQ_ENTRY(audit_pipe)		 ap_list;
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LOCK</span>(ap)		mtx_lock(&amp;(ap)-&gt;ap_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LOCK_ASSERT</span>(ap)	mtx_assert(&amp;(ap)-&gt;ap_mtx, MA_OWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LOCK_DESTROY</span>(ap)	mtx_destroy(&amp;(ap)-&gt;ap_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LOCK_INIT</span>(ap)	mtx_init(&amp;(ap)-&gt;ap_mtx, \
					    <span class="enscript-string">&quot;audit_pipe_mtx&quot;</span>, NULL, MTX_DEF)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_UNLOCK</span>(ap)		mtx_unlock(&amp;(ap)-&gt;ap_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_MTX</span>(ap)		(&amp;(ap)-&gt;ap_mtx)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_SX_LOCK_DESTROY</span>(ap)	slck_destroy(&amp;(ap)-&gt;ap_sx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_SX_LOCK_INIT</span>(ap)	slck_init(&amp;(ap)-&gt;ap_sx, <span class="enscript-string">&quot;audit_pipe_sx&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_SX_XLOCK_ASSERT</span>(ap)	slck_assert(&amp;(ap)-&gt;ap_sx, SA_XLOCKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_SX_XLOCK_SIG</span>(ap)	slck_lock_sig(&amp;(ap)-&gt;ap_sx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_SX_XUNLOCK</span>(ap)	slck_unlock(&amp;(ap)-&gt;ap_sx)


<span class="enscript-comment">/*
 * Global list of audit pipes, rwlock to protect it.  Individual record
 * queues on pipes are protected by per-pipe locks; these locks synchronize
 * between threads walking the list to deliver to individual pipes and add/
 * remove of pipes, and are mostly acquired for read.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, audit_pipe)	 audit_pipe_list;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rwlock		 audit_pipe_lock;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_LOCK_INIT</span>()	rw_init(&amp;audit_pipe_lock, \
					    <span class="enscript-string">&quot;audit_pipe_list_lock&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_RLOCK</span>()  	rw_rlock(&amp;audit_pipe_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_RUNLOCK</span>()	rw_runlock(&amp;audit_pipe_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_WLOCK</span>()		rw_wlock(&amp;audit_pipe_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_WLOCK_ASSERT</span>()	rw_assert(&amp;audit_pipe_lock, \
					    RA_WLOCKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_PIPE_LIST_WUNLOCK</span>()	rw_wunlock(&amp;audit_pipe_lock)

<span class="enscript-comment">/*
 * Cloning related variables and constants.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_PIPE_NAME</span>		<span class="enscript-string">&quot;auditpipe&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_AUDIT_PIPES</span>		32
<span class="enscript-type">static</span> <span class="enscript-type">int</span> audit_pipe_major;

<span class="enscript-comment">/*
 * dev_t doesn't have a pointer for &quot;softc&quot; data.  So we have to keep track of
 * it with the following global array (indexed by the minor number).
 *
 * XXX We may want to dynamically grow this as needed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> audit_pipe	*audit_pipe_dtab[MAX_AUDIT_PIPES];


<span class="enscript-comment">/*
 * Special device methods and definition.
 */</span>
<span class="enscript-type">static</span> open_close_fcn_t		audit_pipe_open;
<span class="enscript-type">static</span> open_close_fcn_t		audit_pipe_close;
<span class="enscript-type">static</span> read_write_fcn_t		audit_pipe_read;
<span class="enscript-type">static</span> ioctl_fcn_t		audit_pipe_ioctl;
<span class="enscript-type">static</span> select_fcn_t		audit_pipe_poll;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw audit_pipe_cdevsw = {
	.d_open      =          audit_pipe_open,
	.d_close     =          audit_pipe_close,
	.d_read      =          audit_pipe_read,
	.d_write     =          eno_rdwrt,
	.d_ioctl     =          audit_pipe_ioctl,
	.d_stop      =          eno_stop,
	.d_reset     =          eno_reset,
	.d_ttys      =          NULL,
	.d_select    =          audit_pipe_poll,
	.d_mmap      =          eno_mmap,
	.d_strategy  =          eno_strat,
	.d_type      =          0
};

<span class="enscript-comment">/*
 * Some global statistics on audit pipes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		audit_pipe_count;	<span class="enscript-comment">/* Current number of pipes. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_pipe_ever;	<span class="enscript-comment">/* Pipes ever allocated. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_pipe_records;	<span class="enscript-comment">/* Records seen. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_pipe_drops;	<span class="enscript-comment">/* Global record drop count. */</span>

<span class="enscript-comment">/*
 * Free an audit pipe entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_entry_free</span>(<span class="enscript-type">struct</span> audit_pipe_entry *ape)
{

	free(ape-&gt;ape_record, M_AUDIT_PIPE_ENTRY);
	free(ape, M_AUDIT_PIPE_ENTRY);
}

<span class="enscript-comment">/*
 * Find an audit pipe preselection specification for an auid, if any.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> audit_pipe_preselect *
<span class="enscript-function-name">audit_pipe_preselect_find</span>(<span class="enscript-type">struct</span> audit_pipe *ap, au_id_t auid)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app;

	AUDIT_PIPE_LOCK_ASSERT(ap);

	TAILQ_FOREACH(app, &amp;ap-&gt;ap_preselect_list, app_list) {
		<span class="enscript-keyword">if</span> (app-&gt;app_auid == auid)
			<span class="enscript-keyword">return</span> (app);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Query the per-pipe mask for a specific auid.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_preselect_get</span>(<span class="enscript-type">struct</span> audit_pipe *ap, au_id_t auid,
    au_mask_t *maskp)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app;
	<span class="enscript-type">int</span> error;

	AUDIT_PIPE_LOCK(ap);
	app = audit_pipe_preselect_find(ap, auid);
	<span class="enscript-keyword">if</span> (app != NULL) {
		*maskp = app-&gt;app_mask;
		error = 0;
	} <span class="enscript-keyword">else</span>
		error = ENOENT;
	AUDIT_PIPE_UNLOCK(ap);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set the per-pipe mask for a specific auid.  Add a new entry if needed;
 * otherwise, update the current entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_preselect_set</span>(<span class="enscript-type">struct</span> audit_pipe *ap, au_id_t auid, au_mask_t mask)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app, *app_new;

	<span class="enscript-comment">/*
	 * Pessimistically assume that the auid doesn't already have a mask
	 * set, and allocate.  We will free it if it is unneeded.
	 */</span>
	app_new = malloc(<span class="enscript-keyword">sizeof</span>(*app_new), M_AUDIT_PIPE_PRESELECT, M_WAITOK);
	AUDIT_PIPE_LOCK(ap);
	app = audit_pipe_preselect_find(ap, auid);
	<span class="enscript-keyword">if</span> (app == NULL) {
		app = app_new;
		app_new = NULL;
		app-&gt;app_auid = auid;
		TAILQ_INSERT_TAIL(&amp;ap-&gt;ap_preselect_list, app, app_list);
	}
	app-&gt;app_mask = mask;
	AUDIT_PIPE_UNLOCK(ap);
	<span class="enscript-keyword">if</span> (app_new != NULL)
		free(app_new, M_AUDIT_PIPE_PRESELECT);
}

<span class="enscript-comment">/*
 * Delete a per-auid mask on an audit pipe.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_preselect_delete</span>(<span class="enscript-type">struct</span> audit_pipe *ap, au_id_t auid)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app;
	<span class="enscript-type">int</span> error;

	AUDIT_PIPE_LOCK(ap);
	app = audit_pipe_preselect_find(ap, auid);
	<span class="enscript-keyword">if</span> (app != NULL) {
		TAILQ_REMOVE(&amp;ap-&gt;ap_preselect_list, app, app_list);
		error = 0;
	} <span class="enscript-keyword">else</span>
		error = ENOENT;
	AUDIT_PIPE_UNLOCK(ap);
	<span class="enscript-keyword">if</span> (app != NULL)
		free(app, M_AUDIT_PIPE_PRESELECT);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Delete all per-auid masks on an audit pipe.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_preselect_flush_locked</span>(<span class="enscript-type">struct</span> audit_pipe *ap)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app;

	AUDIT_PIPE_LOCK_ASSERT(ap);

	<span class="enscript-keyword">while</span> ((app = TAILQ_FIRST(&amp;ap-&gt;ap_preselect_list)) != NULL) {
		TAILQ_REMOVE(&amp;ap-&gt;ap_preselect_list, app, app_list);
		free(app, M_AUDIT_PIPE_PRESELECT);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_preselect_flush</span>(<span class="enscript-type">struct</span> audit_pipe *ap)
{

	AUDIT_PIPE_LOCK(ap);
	audit_pipe_preselect_flush_locked(ap);
	AUDIT_PIPE_UNLOCK(ap);
}

<span class="enscript-comment">/*-
 * Determine whether a specific audit pipe matches a record with these
 * properties.  Algorithm is as follows:
 *
 * - If the pipe is configured to track the default trail configuration, then
 *   use the results of global preselection matching.
 * - If not, search for a specifically configured auid entry matching the
 *   event.  If an entry is found, use that.
 * - Otherwise, use the default flags or naflags configured for the pipe.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_preselect_check</span>(<span class="enscript-type">struct</span> audit_pipe *ap, au_id_t auid,
    au_event_t event, au_class_t class, <span class="enscript-type">int</span> sorf, <span class="enscript-type">int</span> trail_preselect)
{
	<span class="enscript-type">struct</span> audit_pipe_preselect *app;

	AUDIT_PIPE_LOCK_ASSERT(ap);

	<span class="enscript-keyword">switch</span> (ap-&gt;ap_preselect_mode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_PRESELECT_MODE_TRAIL</span>:
		<span class="enscript-keyword">return</span> (trail_preselect);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_PRESELECT_MODE_LOCAL</span>:
		app = audit_pipe_preselect_find(ap, auid);
		<span class="enscript-keyword">if</span> (app == NULL) {
			<span class="enscript-keyword">if</span> (auid == (uid_t)AU_DEFAUDITID)
				<span class="enscript-keyword">return</span> (au_preselect(event, class,
				    &amp;ap-&gt;ap_preselect_naflags, sorf));
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> (au_preselect(event, class,
				    &amp;ap-&gt;ap_preselect_flags, sorf));
		} <span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (au_preselect(event, class, &amp;app-&gt;app_mask,
			    sorf));

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;audit_pipe_preselect_check: mode %d&quot;</span>,
		    ap-&gt;ap_preselect_mode);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Determine whether there exists a pipe interested in a record with specific
 * properties.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_preselect</span>(au_id_t auid, au_event_t event, au_class_t class,
    <span class="enscript-type">int</span> sorf, <span class="enscript-type">int</span> trail_preselect)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	<span class="enscript-comment">/* Lockless read to avoid acquiring the global lock if not needed. */</span>
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;audit_pipe_list))
		<span class="enscript-keyword">return</span> (0);

	AUDIT_PIPE_LIST_RLOCK();
	TAILQ_FOREACH(ap, &amp;audit_pipe_list, ap_list) {
		 AUDIT_PIPE_LOCK(ap);
		<span class="enscript-keyword">if</span> (audit_pipe_preselect_check(ap, auid, event, class, sorf,
		    trail_preselect)) {
			AUDIT_PIPE_UNLOCK(ap);
			AUDIT_PIPE_LIST_RUNLOCK();
			<span class="enscript-keyword">return</span> (1);
		}
		AUDIT_PIPE_UNLOCK(ap);
	}
	AUDIT_PIPE_LIST_RUNLOCK();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Append individual record to a queue -- allocate queue-local buffer, and
 * add to the queue.  If the queue is full or we can't allocate memory, drop
 * the newest record.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_append</span>(<span class="enscript-type">struct</span> audit_pipe *ap, <span class="enscript-type">void</span> *record, u_int record_len)
{
	<span class="enscript-type">struct</span> audit_pipe_entry *ape;

	AUDIT_PIPE_LOCK_ASSERT(ap);

	<span class="enscript-keyword">if</span> (ap-&gt;ap_qlen &gt;= ap-&gt;ap_qlimit) {
		ap-&gt;ap_drops++;
		audit_pipe_drops++;
		<span class="enscript-keyword">return</span>;
	}

	ape = malloc(<span class="enscript-keyword">sizeof</span>(*ape), M_AUDIT_PIPE_ENTRY, M_NOWAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (ape == NULL) {
		ap-&gt;ap_drops++;
		audit_pipe_drops++;
		<span class="enscript-keyword">return</span>;
	}

	ape-&gt;ape_record = malloc(record_len, M_AUDIT_PIPE_ENTRY, M_NOWAIT);
	<span class="enscript-keyword">if</span> (ape-&gt;ape_record == NULL) {
		free(ape, M_AUDIT_PIPE_ENTRY);
		ap-&gt;ap_drops++;
		audit_pipe_drops++;
		<span class="enscript-keyword">return</span>;
	}

	bcopy(record, ape-&gt;ape_record, record_len);
	ape-&gt;ape_record_len = record_len;

	TAILQ_INSERT_TAIL(&amp;ap-&gt;ap_queue, ape, ape_queue);
	ap-&gt;ap_inserts++;
	ap-&gt;ap_qlen++;
	ap-&gt;ap_qbyteslen += ape-&gt;ape_record_len;
	selwakeup(&amp;ap-&gt;ap_selinfo);
	<span class="enscript-keyword">if</span> (ap-&gt;ap_flags &amp; AUDIT_PIPE_ASYNC)
		pgsigio(ap-&gt;ap_sigio, SIGIO);
#<span class="enscript-reference">if</span> 0  <span class="enscript-comment">/* XXX - fix select */</span>
	selwakeuppri(&amp;ap-&gt;ap_selinfo, PSOCK);
	KNOTE_LOCKED(&amp;ap-&gt;ap_selinfo.si_note, 0);
	<span class="enscript-keyword">if</span> (ap-&gt;ap_flags &amp; AUDIT_PIPE_ASYNC)
		pgsigio(&amp;ap-&gt;ap_sigio, SIGIO, 0);
#<span class="enscript-reference">endif</span>
	cv_broadcast(&amp;ap-&gt;ap_cv);
}

<span class="enscript-comment">/*
 * audit_pipe_submit(): audit_worker submits audit records via this
 * interface, which arranges for them to be delivered to pipe queues.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_submit</span>(au_id_t auid, au_event_t event, au_class_t class, <span class="enscript-type">int</span> sorf,
    <span class="enscript-type">int</span> trail_select, <span class="enscript-type">void</span> *record, u_int record_len)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	<span class="enscript-comment">/*
	 * Lockless read to avoid lock overhead if pipes are not in use.
	 */</span>
	<span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;audit_pipe_list) == NULL)
		<span class="enscript-keyword">return</span>;

	AUDIT_PIPE_LIST_RLOCK();
	TAILQ_FOREACH(ap, &amp;audit_pipe_list, ap_list) {
		AUDIT_PIPE_LOCK(ap);
		<span class="enscript-keyword">if</span> (audit_pipe_preselect_check(ap, auid, event, class, sorf,
		    trail_select))
			audit_pipe_append(ap, record, record_len);
		AUDIT_PIPE_UNLOCK(ap);
	}
	AUDIT_PIPE_LIST_RUNLOCK();

	<span class="enscript-comment">/* Unlocked increment. */</span>
	audit_pipe_records++;
}

<span class="enscript-comment">/*
 * audit_pipe_submit_user(): the same as audit_pipe_submit(), except that
 * since we don't currently have selection information available, it is
 * delivered to the pipe unconditionally.
 *
 * XXXRW: This is a bug.  The BSM check routine for submitting a user record
 * should parse that information and return it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_submit_user</span>(<span class="enscript-type">void</span> *record, u_int record_len)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	<span class="enscript-comment">/*
	 * Lockless read to avoid lock overhead if pipes are not in use.
	 */</span>
	<span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;audit_pipe_list) == NULL)
		<span class="enscript-keyword">return</span>;

	AUDIT_PIPE_LIST_RLOCK();
	TAILQ_FOREACH(ap, &amp;audit_pipe_list, ap_list) {
		AUDIT_PIPE_LOCK(ap);
		audit_pipe_append(ap, record, record_len);
		AUDIT_PIPE_UNLOCK(ap);
	}
	AUDIT_PIPE_LIST_RUNLOCK();

	<span class="enscript-comment">/* Unlocked increment. */</span>
	audit_pipe_records++;
}

<span class="enscript-comment">/*
 * Allocate a new audit pipe.  Connects the pipe, on success, to the global
 * list and updates statistics.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> audit_pipe *
<span class="enscript-function-name">audit_pipe_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	AUDIT_PIPE_LIST_WLOCK_ASSERT();

	ap = malloc(<span class="enscript-keyword">sizeof</span>(*ap), M_AUDIT_PIPE, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ap == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	ap-&gt;ap_qlimit = AUDIT_PIPE_QLIMIT_DEFAULT;
	TAILQ_INIT(&amp;ap-&gt;ap_queue);
#<span class="enscript-reference">ifndef</span>  <span class="enscript-variable-name">__APPLE__</span>
	knlist_init(&amp;ap-&gt;ap_selinfo.si_note, AUDIT_PIPE_MTX(ap), NULL, NULL,
	    NULL);
#<span class="enscript-reference">endif</span>
	AUDIT_PIPE_LOCK_INIT(ap);
	AUDIT_PIPE_SX_LOCK_INIT(ap);
	cv_init(&amp;ap-&gt;ap_cv, <span class="enscript-string">&quot;audit_pipe&quot;</span>);

	<span class="enscript-comment">/*
	 * Default flags, naflags, and auid-specific preselection settings to
	 * 0.  Initialize the mode to the global trail so that if praudit(1)
	 * is run on /dev/auditpipe, it sees events associated with the
	 * default trail.  Pipe-aware application can clear the flag, set
	 * custom masks, and flush the pipe as needed.
	 */</span>
	bzero(&amp;ap-&gt;ap_preselect_flags, <span class="enscript-keyword">sizeof</span>(ap-&gt;ap_preselect_flags));
	bzero(&amp;ap-&gt;ap_preselect_naflags, <span class="enscript-keyword">sizeof</span>(ap-&gt;ap_preselect_naflags));
	TAILQ_INIT(&amp;ap-&gt;ap_preselect_list);
	ap-&gt;ap_preselect_mode = AUDITPIPE_PRESELECT_MODE_TRAIL;

	<span class="enscript-comment">/*
	 * Add to global list and update global statistics.
	 */</span>
	TAILQ_INSERT_HEAD(&amp;audit_pipe_list, ap, ap_list);
	audit_pipe_count++;
	audit_pipe_ever++;

	<span class="enscript-keyword">return</span> (ap);
}

<span class="enscript-comment">/*
 * Flush all records currently present in an audit pipe; assume mutex is held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_flush</span>(<span class="enscript-type">struct</span> audit_pipe *ap)
{
	<span class="enscript-type">struct</span> audit_pipe_entry *ape;

	AUDIT_PIPE_LOCK_ASSERT(ap);

	<span class="enscript-keyword">while</span> ((ape = TAILQ_FIRST(&amp;ap-&gt;ap_queue)) != NULL) {
		TAILQ_REMOVE(&amp;ap-&gt;ap_queue, ape, ape_queue);
		ap-&gt;ap_qbyteslen -= ape-&gt;ape_record_len;
		audit_pipe_entry_free(ape);
		ap-&gt;ap_qlen--;
	}
	ap-&gt;ap_qoffset = 0;

	KASSERT(ap-&gt;ap_qlen == 0, (<span class="enscript-string">&quot;audit_pipe_free: ap_qbyteslen&quot;</span>));
	KASSERT(ap-&gt;ap_qbyteslen == 0, (<span class="enscript-string">&quot;audit_pipe_flush: ap_qbyteslen&quot;</span>));
}

<span class="enscript-comment">/*
 * Free an audit pipe; this means freeing all preselection state and all
 * records in the pipe.  Assumes global write lock and pipe mutex are held to
 * revent any new records from being inserted during the free, and that the
 * audit pipe is still on the global list.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_free</span>(<span class="enscript-type">struct</span> audit_pipe *ap)
{

	AUDIT_PIPE_LIST_WLOCK_ASSERT();
	AUDIT_PIPE_LOCK_ASSERT(ap);

	audit_pipe_preselect_flush_locked(ap);
	audit_pipe_flush(ap);
	cv_destroy(&amp;ap-&gt;ap_cv);
	AUDIT_PIPE_SX_LOCK_DESTROY(ap);
	AUDIT_PIPE_UNLOCK(ap);
	AUDIT_PIPE_LOCK_DESTROY(ap);
#<span class="enscript-reference">ifndef</span>  <span class="enscript-variable-name">__APPLE__</span>
	knlist_destroy(&amp;ap-&gt;ap_selinfo.si_note);
#<span class="enscript-reference">endif</span>
	TAILQ_REMOVE(&amp;audit_pipe_list, ap, ap_list);
	free(ap, M_AUDIT_PIPE);
	audit_pipe_count--;
}

<span class="enscript-comment">/*
 * Audit pipe clone routine -- provides a new minor number, or to return (-1),
 * if one can't be provided.  Called with DEVFS_LOCK held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_clone</span>(__unused dev_t dev, <span class="enscript-type">int</span> action)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (action == DEVFS_CLONE_ALLOC) {
		<span class="enscript-keyword">for</span>(i = 0; i &lt; MAX_AUDIT_PIPES; i++)
			<span class="enscript-keyword">if</span> (audit_pipe_dtab[i] == NULL)
				<span class="enscript-keyword">return</span> (i);

		<span class="enscript-comment">/*
		 * XXX Should really return -1 here but that seems to hang
		 * things in devfs.  Instead return 0 and let _open() tell
		 * userland the bad news.
		 */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * Audit pipe open method.  Explicit privilege check isn't used as this
 * allows file permissions on the special device to be used to grant audit
 * review access.  Those file permissions should be managed carefully.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_open</span>(dev_t dev, __unused <span class="enscript-type">int</span> flags,  __unused <span class="enscript-type">int</span> devtype,
    __unused proc_t p)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;
	<span class="enscript-type">int</span> u;

	u = minor(dev);
	<span class="enscript-keyword">if</span> (u &lt; 0 || u &gt; MAX_AUDIT_PIPES)
		<span class="enscript-keyword">return</span> (ENXIO);

	AUDIT_PIPE_LIST_WLOCK();
	ap = audit_pipe_dtab[u];
	<span class="enscript-keyword">if</span> (ap == NULL) {
		ap = audit_pipe_alloc();
		<span class="enscript-keyword">if</span> (ap == NULL) {
			AUDIT_PIPE_LIST_WUNLOCK();
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		audit_pipe_dtab[u] = ap;
	} <span class="enscript-keyword">else</span> {
		KASSERT(ap-&gt;ap_open, (<span class="enscript-string">&quot;audit_pipe_open: ap &amp;&amp; !ap_open&quot;</span>));
		AUDIT_PIPE_LIST_WUNLOCK();
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	ap-&gt;ap_open = 1;
	AUDIT_PIPE_LIST_WUNLOCK();
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
	fsetown(td-&gt;td_proc-&gt;p_pid, &amp;ap-&gt;ap_sigio);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Close audit pipe, tear down all records, etc.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_close</span>(dev_t dev, __unused <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">int</span> devtype,
    __unused proc_t p)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;
	<span class="enscript-type">int</span> u;

	u = minor(dev);
	ap = audit_pipe_dtab[u];
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_close: ap == NULL&quot;</span>));
	KASSERT(ap-&gt;ap_open, (<span class="enscript-string">&quot;audit_pipe_close: !ap_open&quot;</span>));

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
	funsetown(&amp;ap-&gt;ap_sigio);
#<span class="enscript-reference">endif</span>
	AUDIT_PIPE_LIST_WLOCK();
	AUDIT_PIPE_LOCK(ap);
	ap-&gt;ap_open = 0;
	audit_pipe_free(ap);
	audit_pipe_dtab[u] = NULL;
	AUDIT_PIPE_LIST_WUNLOCK();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Audit pipe ioctl() routine.  Handle file descriptor and audit pipe layer
 * commands.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_ioctl</span>(dev_t dev, u_long cmd, caddr_t data,
    __unused <span class="enscript-type">int</span> flag, __unused proc_t p)
{
	<span class="enscript-type">struct</span> auditpipe_ioctl_preselect *aip;
	<span class="enscript-type">struct</span> audit_pipe *ap;
	au_mask_t *maskp;
	<span class="enscript-type">int</span> error, mode;
	au_id_t auid;

	ap = audit_pipe_dtab[minor(dev)];
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_ioctl: ap == NULL&quot;</span>));

	<span class="enscript-comment">/*
	 * Audit pipe ioctls: first come standard device node ioctls, then
	 * manipulation of pipe settings, and finally, statistics query
	 * ioctls.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:
		AUDIT_PIPE_LOCK(ap);
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			ap-&gt;ap_flags |= AUDIT_PIPE_NBIO;
		<span class="enscript-keyword">else</span>
			ap-&gt;ap_flags &amp;= ~AUDIT_PIPE_NBIO;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONREAD</span>:
		AUDIT_PIPE_LOCK(ap);
		*(<span class="enscript-type">int</span> *)data = ap-&gt;ap_qbyteslen - ap-&gt;ap_qoffset;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOASYNC</span>:
		AUDIT_PIPE_LOCK(ap);
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			ap-&gt;ap_flags |= AUDIT_PIPE_ASYNC;
		<span class="enscript-keyword">else</span>
			ap-&gt;ap_flags &amp;= ~AUDIT_PIPE_ASYNC;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOSETOWN</span>:
		error = fsetown(*(<span class="enscript-type">int</span> *)data, &amp;ap-&gt;ap_sigio);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOGETOWN</span>:
		*(<span class="enscript-type">int</span> *)data = fgetown(&amp;ap-&gt;ap_sigio);
		error = 0;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__APPLE__ */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_QLEN</span>:
		*(u_int *)data = ap-&gt;ap_qlen;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_QLIMIT</span>:
		*(u_int *)data = ap-&gt;ap_qlimit;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_SET_QLIMIT</span>:
		<span class="enscript-comment">/* Lockless integer write. */</span>
		<span class="enscript-keyword">if</span> (*(u_int *)data &gt;= AUDIT_PIPE_QLIMIT_MIN ||
		    *(u_int *)data &lt;= AUDIT_PIPE_QLIMIT_MAX) {
			ap-&gt;ap_qlimit = *(u_int *)data;
			error = 0;
		} <span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_QLIMIT_MIN</span>:
		*(u_int *)data = AUDIT_PIPE_QLIMIT_MIN;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_QLIMIT_MAX</span>:
		*(u_int *)data = AUDIT_PIPE_QLIMIT_MAX;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_PRESELECT_FLAGS</span>:
		AUDIT_PIPE_LOCK(ap);
		maskp = (au_mask_t *)data;
		*maskp = ap-&gt;ap_preselect_flags;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_SET_PRESELECT_FLAGS</span>:
		AUDIT_PIPE_LOCK(ap);
		maskp = (au_mask_t *)data;
		ap-&gt;ap_preselect_flags = *maskp;
		AUDIT_CHECK_IF_KEVENTS_MASK(ap-&gt;ap_preselect_flags);
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_PRESELECT_NAFLAGS</span>:
		AUDIT_PIPE_LOCK(ap);
		maskp = (au_mask_t *)data;
		*maskp = ap-&gt;ap_preselect_naflags;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_SET_PRESELECT_NAFLAGS</span>:
		AUDIT_PIPE_LOCK(ap);
		maskp = (au_mask_t *)data;
		ap-&gt;ap_preselect_naflags = *maskp;
		AUDIT_CHECK_IF_KEVENTS_MASK(ap-&gt;ap_preselect_naflags);
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_PRESELECT_AUID</span>:
		aip = (<span class="enscript-type">struct</span> auditpipe_ioctl_preselect *)data;
		error = audit_pipe_preselect_get(ap, aip-&gt;aip_auid,
		    &amp;aip-&gt;aip_mask);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_SET_PRESELECT_AUID</span>:
		aip = (<span class="enscript-type">struct</span> auditpipe_ioctl_preselect *)data;
		audit_pipe_preselect_set(ap, aip-&gt;aip_auid, aip-&gt;aip_mask);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_DELETE_PRESELECT_AUID</span>:
		auid = *(au_id_t *)data;
		error = audit_pipe_preselect_delete(ap, auid);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_FLUSH_PRESELECT_AUID</span>:
		audit_pipe_preselect_flush(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_PRESELECT_MODE</span>:
		AUDIT_PIPE_LOCK(ap);
		*(<span class="enscript-type">int</span> *)data = ap-&gt;ap_preselect_mode;
		AUDIT_PIPE_UNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_SET_PRESELECT_MODE</span>:
		mode = *(<span class="enscript-type">int</span> *)data;
		<span class="enscript-keyword">switch</span> (mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_PRESELECT_MODE_TRAIL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_PRESELECT_MODE_LOCAL</span>:
			AUDIT_PIPE_LOCK(ap);
			ap-&gt;ap_preselect_mode = mode;
			AUDIT_PIPE_UNLOCK(ap);
			error = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_FLUSH</span>:
		<span class="enscript-keyword">if</span> (AUDIT_PIPE_SX_XLOCK_SIG(ap) != 0)
			<span class="enscript-keyword">return</span> (EINTR);
		AUDIT_PIPE_LOCK(ap);
		audit_pipe_flush(ap);
		AUDIT_PIPE_UNLOCK(ap);
		AUDIT_PIPE_SX_XUNLOCK(ap);
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_MAXAUDITDATA</span>:
		*(u_int *)data = MAXAUDITDATA;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_INSERTS</span>:
		*(u_int *)data = ap-&gt;ap_inserts;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_READS</span>:
		*(u_int *)data = ap-&gt;ap_reads;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_DROPS</span>:
		*(u_int *)data = ap-&gt;ap_drops;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITPIPE_GET_TRUNCATES</span>:
		*(u_int *)data = 0;
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ENOTTY;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Audit pipe read.  Read one or more partial or complete records to user
 * memory.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_read</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flag)
{
	<span class="enscript-type">struct</span> audit_pipe_entry *ape;
	<span class="enscript-type">struct</span> audit_pipe *ap;
	u_int toread;
	<span class="enscript-type">int</span> error;

	ap = audit_pipe_dtab[minor(dev)];
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_read: ap == NULL&quot;</span>));

	<span class="enscript-comment">/*
	 * We hold an sleep lock over read and flush because we rely on the
	 * stability of a record in the queue during uiomove(9).
	 */</span>
	<span class="enscript-keyword">if</span> (AUDIT_PIPE_SX_XLOCK_SIG(ap) != 0)
		<span class="enscript-keyword">return</span> (EINTR);
	AUDIT_PIPE_LOCK(ap);
	<span class="enscript-keyword">while</span> (TAILQ_EMPTY(&amp;ap-&gt;ap_queue)) {
		<span class="enscript-keyword">if</span> (ap-&gt;ap_flags &amp; AUDIT_PIPE_NBIO) {
			AUDIT_PIPE_UNLOCK(ap);
			AUDIT_PIPE_SX_XUNLOCK(ap);
			<span class="enscript-keyword">return</span> (EAGAIN);
		}
		error = cv_wait_sig(&amp;ap-&gt;ap_cv, AUDIT_PIPE_MTX(ap));
		<span class="enscript-keyword">if</span> (error) {
			AUDIT_PIPE_UNLOCK(ap);
			AUDIT_PIPE_SX_XUNLOCK(ap);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/*
	 * Copy as many remaining bytes from the current record to userspace
	 * as we can.  Keep processing records until we run out of records in
	 * the queue, or until the user buffer runs out of space.
	 *
	 * Note: we rely on the sleep lock to maintain ape's stability here.
	 */</span>
	ap-&gt;ap_reads++;
	<span class="enscript-keyword">while</span> ((ape = TAILQ_FIRST(&amp;ap-&gt;ap_queue)) != NULL &amp;&amp;
	    uio_resid(uio) &gt; 0) {
		AUDIT_PIPE_LOCK_ASSERT(ap);

		KASSERT(ape-&gt;ape_record_len &gt; ap-&gt;ap_qoffset,
		    (<span class="enscript-string">&quot;audit_pipe_read: record_len &gt; qoffset (1)&quot;</span>));
		toread = MIN((<span class="enscript-type">int</span>)(ape-&gt;ape_record_len - ap-&gt;ap_qoffset),
		    uio_resid(uio));
		AUDIT_PIPE_UNLOCK(ap);
		error = uiomove((<span class="enscript-type">char</span> *)ape-&gt;ape_record + ap-&gt;ap_qoffset,
		    toread, uio);
		<span class="enscript-keyword">if</span> (error) {
			AUDIT_PIPE_SX_XUNLOCK(ap);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/*
		 * If the copy succeeded, update book-keeping, and if no
		 * bytes remain in the current record, free it.
		 */</span>
		AUDIT_PIPE_LOCK(ap);
		KASSERT(TAILQ_FIRST(&amp;ap-&gt;ap_queue) == ape,
		    (<span class="enscript-string">&quot;audit_pipe_read: queue out of sync after uiomove&quot;</span>));
		ap-&gt;ap_qoffset += toread;
		KASSERT(ape-&gt;ape_record_len &gt;= ap-&gt;ap_qoffset,
		    (<span class="enscript-string">&quot;audit_pipe_read: record_len &gt;= qoffset (2)&quot;</span>));
		<span class="enscript-keyword">if</span> (ap-&gt;ap_qoffset == ape-&gt;ape_record_len) {
			TAILQ_REMOVE(&amp;ap-&gt;ap_queue, ape, ape_queue);
			ap-&gt;ap_qbyteslen -= ape-&gt;ape_record_len;
			audit_pipe_entry_free(ape);
			ap-&gt;ap_qlen--;
			ap-&gt;ap_qoffset = 0;
		}
	}
	AUDIT_PIPE_UNLOCK(ap);
	AUDIT_PIPE_SX_XUNLOCK(ap);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Audit pipe poll.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_poll</span>(dev_t dev, <span class="enscript-type">int</span> events, <span class="enscript-type">void</span> *wql, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;
	<span class="enscript-type">int</span> revents;

	revents = 0;
	ap = audit_pipe_dtab[minor(dev)];
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_poll: ap == NULL&quot;</span>));

	<span class="enscript-keyword">if</span> (events &amp; (POLLIN | POLLRDNORM)) {
		AUDIT_PIPE_LOCK(ap);
		<span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;ap-&gt;ap_queue) != NULL)
			revents |= events &amp; (POLLIN | POLLRDNORM);
		<span class="enscript-keyword">else</span>
			selrecord(p, &amp;ap-&gt;ap_selinfo, wql);
		AUDIT_PIPE_UNLOCK(ap);
	}
	<span class="enscript-keyword">return</span> (revents);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
<span class="enscript-comment">/*
 * Return true if there are records available for reading on the pipe.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_kqread</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	ap = (<span class="enscript-type">struct</span> audit_pipe *)kn-&gt;kn_hook;
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_kqread: ap == NULL&quot;</span>));
	AUDIT_PIPE_LOCK_ASSERT(ap);

	<span class="enscript-keyword">if</span> (ap-&gt;ap_qlen != 0) {
		kn-&gt;kn_data = ap-&gt;ap_qbyteslen - ap-&gt;ap_qoffset;
		<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		kn-&gt;kn_data = 0;
		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-comment">/*
 * Detach kqueue state from audit pipe.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_pipe_kqdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> audit_pipe *ap;

	ap = (<span class="enscript-type">struct</span> audit_pipe *)kn-&gt;kn_hook;
	KASSERT(ap != NULL, (<span class="enscript-string">&quot;audit_pipe_kqdetach: ap == NULL&quot;</span>));

	AUDIT_PIPE_LOCK(ap);
	knlist_remove(&amp;ap-&gt;ap_selinfo.si_note, kn, 1);
	AUDIT_PIPE_UNLOCK(ap);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__APPLE__ */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *devnode;

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_init</span>(<span class="enscript-type">void</span>)
{
	dev_t dev;

	TAILQ_INIT(&amp;audit_pipe_list);
	AUDIT_PIPE_LIST_LOCK_INIT();

	audit_pipe_major = cdevsw_add(-1, &amp;audit_pipe_cdevsw);
	<span class="enscript-keyword">if</span> (audit_pipe_major &lt; 0)
	  <span class="enscript-keyword">return</span> (KERN_FAILURE);

	dev = makedev(audit_pipe_major, 0);
	devnode = devfs_make_node_clone(dev, DEVFS_CHAR, UID_ROOT, GID_WHEEL,
	    0600, audit_pipe_clone, <span class="enscript-string">&quot;auditpipe&quot;</span>, 0);

	<span class="enscript-keyword">if</span> (devnode == NULL)
		<span class="enscript-keyword">return</span> (KERN_FAILURE);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_pipe_shutdown</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-comment">/* unwind everything */</span>
	devfs_remove(devnode);
	(<span class="enscript-type">void</span>) cdevsw_remove(audit_pipe_major, &amp;audit_pipe_cdevsw);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>