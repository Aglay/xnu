<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_session.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_session.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 2008-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/poll.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/audit_sessionport.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

<span class="enscript-comment">/*
 * Audit Session Entry.  This is treated as an object with public and private
 * data.   The se_auinfo field is the only information that is public and
 * needs to be the first entry.
 */</span>
<span class="enscript-type">struct</span> au_sentry {
	auditinfo_addr_t	se_auinfo;	<span class="enscript-comment">/* Public audit session data. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">se_asid</span>		se_auinfo.ai_asid
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">se_auid</span>		se_auinfo.ai_auid
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">se_mask</span>		se_auinfo.ai_mask
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">se_termid</span>	se_auinfo.ai_termid
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">se_flags</span>	se_auinfo.ai_flags

	<span class="enscript-type">long</span>			se_refcnt;	<span class="enscript-comment">/* Reference count. */</span>
	<span class="enscript-type">long</span>			se_procnt;	<span class="enscript-comment">/* Processes in session. */</span>
	ipc_port_t		se_port;	<span class="enscript-comment">/* Session port. */</span>
	LIST_ENTRY(au_sentry)	se_link; 	<span class="enscript-comment">/* Hash bucket link list (1) */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> au_sentry au_sentry_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AU_SENTRY_PTR</span>(aia_p)	((au_sentry_t *)(aia_p))

<span class="enscript-comment">/*
 * The default au_sentry/auditinfo_addr entry for ucred. 
 */</span>

<span class="enscript-type">static</span> au_sentry_t audit_default_se = {
	.se_auinfo = {
			.ai_auid = AU_DEFAUDITID,
			.ai_asid = AU_DEFAUDITSID,
			.ai_termid = { .at_type = AU_IPv4, },
	},
	.se_refcnt = 1, 
	.se_procnt = 1,
};

<span class="enscript-type">struct</span> auditinfo_addr *audit_default_aia_p = &amp;audit_default_se.se_auinfo;

kern_return_t <span class="enscript-function-name">ipc_object_copyin</span>(ipc_space_t, mach_port_name_t,
    mach_msg_type_name_t, ipc_port_t *);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>


<span class="enscript-comment">/*
 * Currently the hash table is a fixed size.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HASH_TABLE_SIZE</span>		97
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">HASH_ASID</span>(asid)		(audit_session_hash(asid) % HASH_TABLE_SIZE)

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rwlock	se_entry_lck;		<span class="enscript-comment">/* (1) lock for se_link above */</span>

<span class="enscript-function-name">LIST_HEAD</span>(au_sentry_head, au_sentry);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> au_sentry_head *au_sentry_bucket = NULL;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AU_HISTORY_LOGGING</span> 0
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AU_HISTORY_LOGGING</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> au_history_event {
	AU_HISTORY_EVENT_UNKNOWN = 0,
	AU_HISTORY_EVENT_REF     = 1,
	AU_HISTORY_EVENT_UNREF   = 2,
	AU_HISTORY_EVENT_BIRTH   = 3,
	AU_HISTORY_EVENT_DEATH   = 4,
	AU_HISTORY_EVENT_FIND    = 5
} au_history_event_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AU_HISTORY_MAX_STACK_DEPTH</span> 8

<span class="enscript-type">struct</span> au_history {
	<span class="enscript-type">struct</span> au_sentry	*ptr;
	<span class="enscript-type">struct</span> au_sentry	 se;
	<span class="enscript-type">void</span>			*stack[AU_HISTORY_MAX_STACK_DEPTH];
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		 stack_depth;
	au_history_event_t	 event;
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> au_history *au_history;
<span class="enscript-type">static</span> size_t		  au_history_size = 65536;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	  au_history_index;

<span class="enscript-type">static</span> inline <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">au_history_entries</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (au_history_index &gt;= au_history_size)
		<span class="enscript-keyword">return</span> au_history_size;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> au_history_index;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">au_history_record</span>(au_sentry_t *se, au_history_event_t event)
{
	<span class="enscript-type">struct</span> au_history *p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	i = OSAddAtomic(1, &amp;au_history_index);
	p = &amp;au_history[i % au_history_size];

	bzero(p, <span class="enscript-keyword">sizeof</span>(*p));
	p-&gt;event = event;
	bcopy(se, &amp;p-&gt;se, <span class="enscript-keyword">sizeof</span>(p-&gt;se));
	p-&gt;stack_depth = OSBacktrace(&amp;p-&gt;stack[0], AU_HISTORY_MAX_STACK_DEPTH);
	p-&gt;ptr = se;
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">au_history_record</span>(se, event) do {} while (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_AU_SESSION, <span class="enscript-string">&quot;audit_session&quot;</span>, <span class="enscript-string">&quot;Audit session data&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	audit_ref_session(au_sentry_t *se);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	audit_unref_session(au_sentry_t *se);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 	audit_session_event(<span class="enscript-type">int</span> event, auditinfo_addr_t *aia_p);

<span class="enscript-comment">/*
 * Audit session device.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDIT_SDEV, <span class="enscript-string">&quot;audit_sdev&quot;</span>, <span class="enscript-string">&quot;Audit sdevs&quot;</span>);
<span class="enscript-type">static</span> <span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDIT_SDEV_ENTRY, <span class="enscript-string">&quot;audit_sdevent&quot;</span>,
    <span class="enscript-string">&quot;Audit sdev entries and buffers&quot;</span>);

<span class="enscript-comment">/*
 * Default audit sdev buffer parameters.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_QLIMIT_DEFAULT</span>	128
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_QLIMIT_MIN</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_QLIMIT_MAX</span>		1024

<span class="enscript-comment">/*
 * Entry structure.
 */</span>
<span class="enscript-type">struct</span>	audit_sdev_entry {
	<span class="enscript-type">void</span>				*ase_record;
	u_int		 		 ase_record_len;
	TAILQ_ENTRY(audit_sdev_entry)	 ase_queue;
};

<span class="enscript-comment">/*
 * Per audit sdev structure.  
 */</span>

<span class="enscript-type">struct</span> audit_sdev {
	<span class="enscript-type">int</span>		asdev_open;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_ASYNC</span>	0x00000001
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_NBIO</span>		0x00000002

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_ALLSESSIONS</span>	0x00010000
	u_int		asdev_flags;

	<span class="enscript-type">struct</span> selinfo	asdev_selinfo;
	pid_t		asdev_sigio;

	au_id_t		asdev_auid;
	au_asid_t	asdev_asid;

	<span class="enscript-comment">/* Per-sdev mutex for most fields in this struct. */</span>
	<span class="enscript-type">struct</span> mtx	asdev_mtx;

	<span class="enscript-comment">/*
	 * Per-sdev sleep lock serializing user-generated reads and
	 * flushes. uiomove() is called to copy out the current head
	 * record's data whie the record remains in the queue, so we
	 * prevent other threads from removing it using this lock.
	 */</span>
	<span class="enscript-type">struct</span> slck	asdev_sx;

	<span class="enscript-comment">/*
	 * Condition variable to signal when data has been delivered to 
	 * a sdev.
	 */</span>
	<span class="enscript-type">struct</span> cv	asdev_cv;

	<span class="enscript-comment">/* Count and bound of records in the queue. */</span>
	u_int		asdev_qlen;
	u_int		asdev_qlimit;

	<span class="enscript-comment">/* The number of bytes of data across all records. */</span>
	u_int		asdev_qbyteslen;
	
	<span class="enscript-comment">/* 
	 * The amount read so far of the first record in the queue.
	 * (The number of bytes available for reading in the queue is
	 * qbyteslen - qoffset.)
	 */</span>
	u_int		asdev_qoffset;

	<span class="enscript-comment">/*
	 * Per-sdev operation statistics.
	 */</span>
	u_int64_t	asdev_inserts;	<span class="enscript-comment">/* Records added. */</span>
	u_int64_t	asdev_reads;	<span class="enscript-comment">/* Records read. */</span>
	u_int64_t	asdev_drops;	<span class="enscript-comment">/* Records dropped. */</span>

	<span class="enscript-comment">/*
	 * Current pending record list.  This is protected by a
	 * combination of asdev_mtx and asdev_sx.  Note that both
	 * locks are required to remove a record from the head of the
	 * queue, as an in-progress read may sleep while copying and,
	 * therefore, cannot hold asdev_mtx.
	 */</span>
	TAILQ_HEAD(, audit_sdev_entry)	asdev_queue;

	<span class="enscript-comment">/* Global sdev list. */</span>
	TAILQ_ENTRY(audit_sdev)		asdev_list;
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LOCK</span>(asdev)		mtx_lock(&amp;(asdev)-&gt;asdev_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LOCK_ASSERT</span>(asdev)	mtx_assert(&amp;(asdev)-&gt;asdev_mtx, \
					    MA_OWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LOCK_DESTROY</span>(asdev)	mtx_destroy(&amp;(asdev)-&gt;asdev_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LOCK_INIT</span>(asdev)	mtx_init(&amp;(asdev)-&gt;asdev_mtx, \
					    <span class="enscript-string">&quot;audit_sdev_mtx&quot;</span>, NULL, MTX_DEF)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_UNLOCK</span>(asdev)	mtx_unlock(&amp;(asdev)-&gt;asdev_mtx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_MTX</span>(asdev)		(&amp;(asdev)-&gt;asdev_mtx)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_SX_LOCK_DESTROY</span>(asd)	slck_destroy(&amp;(asd)-&gt;asdev_sx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_SX_LOCK_INIT</span>(asd)	slck_init(&amp;(asd)-&gt;asdev_sx, \
    					    <span class="enscript-string">&quot;audit_sdev_sx&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_SX_XLOCK_ASSERT</span>(asd)	slck_assert(&amp;(asd)-&gt;asdev_sx, \
    					    SA_XLOCKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_SX_XLOCK_SIG</span>(asd)	slck_lock_sig(&amp;(asd)-&gt;asdev_sx)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_SX_XUNLOCK</span>(asd)	slck_unlock(&amp;(asd)-&gt;asdev_sx)

<span class="enscript-comment">/*
 * Cloning variables and constants.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SDEV_NAME</span>		<span class="enscript-string">&quot;auditsessions&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_AUDIT_SDEVS</span>		32

<span class="enscript-type">static</span> <span class="enscript-type">int</span> audit_sdev_major;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *devnode;

<span class="enscript-comment">/*
 * Global list of audit sdevs.  The list is protected by a rw lock.
 * Individaul record queues are protected by  per-sdev locks.  These
 * locks synchronize between threads walking the list to deliver to 
 * individual sdevs and adds/removes of sdevs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, audit_sdev) audit_sdev_list;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rwlock		audit_sdev_lock;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_LOCK_INIT</span>()	rw_init(&amp;audit_sdev_lock, \
    					    <span class="enscript-string">&quot;audit_sdev_list_lock&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_RLOCK</span>()		rw_rlock(&amp;audit_sdev_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_RUNLOCK</span>()	rw_runlock(&amp;audit_sdev_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_WLOCK</span>()         rw_wlock(&amp;audit_sdev_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_WLOCK_ASSERT</span>()	rw_assert(&amp;audit_sdev_lock, \
    					    RA_WLOCKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SDEV_LIST_WUNLOCK</span>()       rw_wunlock(&amp;audit_sdev_lock)

<span class="enscript-comment">/*
 * dev_t doesn't have a pointer for &quot;softc&quot; data so we have to keep track of
 * it with the following global array (indexed by the minor number).
 *
 * XXX We may want to dynamically grow this as need.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> audit_sdev	*audit_sdev_dtab[MAX_AUDIT_SDEVS];

<span class="enscript-comment">/*
 * Special device methods and definition.
 */</span>
<span class="enscript-type">static</span> open_close_fcn_t		audit_sdev_open;
<span class="enscript-type">static</span> open_close_fcn_t		audit_sdev_close;
<span class="enscript-type">static</span> read_write_fcn_t		audit_sdev_read;
<span class="enscript-type">static</span> ioctl_fcn_t		audit_sdev_ioctl; 
<span class="enscript-type">static</span> select_fcn_t		audit_sdev_poll;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw audit_sdev_cdevsw = {
	.d_open      =          audit_sdev_open,
	.d_close     =          audit_sdev_close,
	.d_read      =          audit_sdev_read,
	.d_write     =          eno_rdwrt,
	.d_ioctl     =          audit_sdev_ioctl,
	.d_stop      =          eno_stop,
	.d_reset     =          eno_reset,
	.d_ttys      =          NULL,
	.d_select    =          audit_sdev_poll,
	.d_mmap      =          eno_mmap,
	.d_strategy  =          eno_strat,
	.d_type      =          0
};

<span class="enscript-comment">/*
 * Global statistics on audit sdevs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		audit_sdev_count;	<span class="enscript-comment">/* Current number of sdevs. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_sdev_ever;	<span class="enscript-comment">/* Sdevs ever allocated. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_sdev_records; 	<span class="enscript-comment">/* Total records seen. */</span>
<span class="enscript-type">static</span> u_int64_t	audit_sdev_drops;	<span class="enscript-comment">/* Global record drop count. */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">audit_sdev_init</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_RWLOCK_INIT</span>()	rw_init(&amp;se_entry_lck, \
					    <span class="enscript-string">&quot;se_entry_lck&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_RLOCK</span>()		rw_rlock(&amp;se_entry_lck)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_WLOCK</span>()		rw_wlock(&amp;se_entry_lck)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_RWLOCK_ASSERT</span>()	rw_assert(&amp;se_entry_lck, RA_LOCKED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_RUNLOCK</span>()		rw_runlock(&amp;se_entry_lck)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_SENTRY_WUNLOCK</span>()		rw_wunlock(&amp;se_entry_lck)

<span class="enscript-comment">/* Access control on the auditinfo_addr.ai_flags member. */</span>
<span class="enscript-type">static</span> uint64_t audit_session_superuser_set_sflags_mask;
<span class="enscript-type">static</span> uint64_t audit_session_superuser_clear_sflags_mask;
<span class="enscript-type">static</span> uint64_t audit_session_member_set_sflags_mask;
<span class="enscript-type">static</span> uint64_t audit_session_member_clear_sflags_mask;
<span class="enscript-function-name">SYSCTL_NODE</span>(, OID_AUTO, audit, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Audit controls&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_audit, OID_AUTO, session, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Audit sessions&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_audit_session, OID_AUTO, superuser_set_sflags_mask, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;audit_session_superuser_set_sflags_mask,
    <span class="enscript-string">&quot;Audit session flags settable by superuser&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_audit_session, OID_AUTO, superuser_clear_sflags_mask, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;audit_session_superuser_clear_sflags_mask,
    <span class="enscript-string">&quot;Audit session flags clearable by superuser&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_audit_session, OID_AUTO, member_set_sflags_mask, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;audit_session_member_set_sflags_mask,
    <span class="enscript-string">&quot;Audit session flags settable by a session member&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_audit_session, OID_AUTO, member_clear_sflags_mask, CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;audit_session_member_clear_sflags_mask,
    <span class="enscript-string">&quot;Audit session flags clearable by a session member&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_SESSION_DEBUG</span>	0
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">AUDIT_SESSION_DEBUG</span>
<span class="enscript-comment">/*
 * The following is debugging code that can be used to get a snapshot of the 
 * session state.  The audit session information is read out using sysctl:
 *
 * error = sysctlbyname(&quot;kern.audit_session_debug&quot;, buffer_ptr, &amp;buffer_len,
 * 		NULL, 0);
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

<span class="enscript-comment">/*
 * The per session record structure for the snapshot data.
 */</span>
<span class="enscript-type">struct</span> au_sentry_debug {
	auditinfo_addr_t	se_auinfo;
	int64_t			se_refcnt;	<span class="enscript-comment">/* refereence count */</span>
	int64_t			se_procnt;	<span class="enscript-comment">/* process count */</span>
	int64_t			se_ptcnt;	<span class="enscript-comment">/* process count from 
						   proc table */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> au_sentry_debug au_sentry_debug_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">audit_sysctl_session_debug</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1,
    <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, audit_session_debug, CTLFLAG_RD | CTLFLAG_LOCKED,
    NULL, 0, audit_sysctl_session_debug, <span class="enscript-string">&quot;S,audit_session_debug&quot;</span>,
    <span class="enscript-string">&quot;Current session debug info for auditing.&quot;</span>);

<span class="enscript-comment">/*
 * Callouts for proc_interate() which is used to reconcile the audit session
 * proc state information with the proc table.  We get everything we need
 * in the filterfn while the proc_lock() is held so we really don't need the
 * callout() function.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">audit_session_debug_callout</span>(__unused proc_t p, __unused <span class="enscript-type">void</span> *arg)
{

	<span class="enscript-keyword">return</span> (PROC_RETURNED_DONE);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_debug_filterfn</span>(proc_t p, <span class="enscript-type">void</span> *st)
{
	kauth_cred_t cred = p-&gt;p_ucred; 
	auditinfo_addr_t *aia_p = cred-&gt;cr_audit.as_aia_p;
	au_sentry_debug_t *sed_tab = (au_sentry_debug_t *) st;
	au_sentry_debug_t  *sdtp;
	au_sentry_t *se;

	<span class="enscript-keyword">if</span> (IS_VALID_SESSION(aia_p)) {
		sdtp = &amp;sed_tab[0];
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (aia_p-&gt;ai_asid == sdtp-&gt;se_asid) {
				sdtp-&gt;se_ptcnt++;

				<span class="enscript-comment">/* Do some santy checks. */</span>
				se = AU_SENTRY_PTR(aia_p);
				<span class="enscript-keyword">if</span> (se-&gt;se_refcnt != sdtp-&gt;se_refcnt) {
					sdtp-&gt;se_refcnt =
					    (int64_t)se-&gt;se_refcnt;
				}
				<span class="enscript-keyword">if</span> (se-&gt;se_procnt != sdtp-&gt;se_procnt) {
					sdtp-&gt;se_procnt =
					    (int64_t)se-&gt;se_procnt;
				}
				<span class="enscript-keyword">break</span>;
			}
			sdtp++;
		} <span class="enscript-keyword">while</span> (sdtp-&gt;se_asid != 0 &amp;&amp; sdtp-&gt;se_auid != 0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* add it to the default sesison */</span>
		sed_tab-&gt;se_ptcnt++;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Copy out the session debug info via the sysctl interface.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sysctl_session_debug</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp,
    __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	au_sentry_t *se;
	au_sentry_debug_t *sed_tab, *next_sed;
	<span class="enscript-type">int</span> i, entry_cnt = 0;
	size_t sz;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-comment">/*
	 * This provides a read-only node.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/*
	 * Walk the audit session hash table to determine the size.
	 */</span>
	AUDIT_SENTRY_RLOCK();
	<span class="enscript-keyword">for</span>(i = 0; i &lt; HASH_TABLE_SIZE; i++)
		LIST_FOREACH(se, &amp;au_sentry_bucket[i], se_link)
		    <span class="enscript-keyword">if</span> (se != NULL) 
			    entry_cnt++;

	entry_cnt++;  <span class="enscript-comment">/* add one for the default entry */</span>
	<span class="enscript-comment">/*
	 * If just querying then return the space required.  There is an 
	 * obvious race condition here so we just fudge this by 3 in case
	 * the audit session table grows.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = (entry_cnt + 3) * <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t);
		AUDIT_SENTRY_RUNLOCK();
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Alloc a temporary buffer.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldlen &lt; (entry_cnt * <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t))) {
		AUDIT_SENTRY_RUNLOCK();
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	<span class="enscript-comment">/*
	 * We hold the lock over the alloc since we don't want the table to
	 * grow on us.   Therefore, use the non-blocking version of kalloc().
	 */</span>
	sed_tab = (au_sentry_debug_t *)kalloc_noblock(entry_cnt *
	    <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t));
	<span class="enscript-keyword">if</span> (sed_tab == NULL) {
		AUDIT_SENTRY_RUNLOCK();
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero(sed_tab, entry_cnt * <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t));

	<span class="enscript-comment">/*
	 * Walk the audit session hash table and build the record array.
	 */</span>
	sz = 0;
	next_sed = sed_tab;
	<span class="enscript-comment">/* add the first entry for processes not tracked in sessions. */</span>
	bcopy(audit_default_aia_p, &amp;next_sed-&gt;se_auinfo, <span class="enscript-keyword">sizeof</span> (au_sentry_t));
	next_sed-&gt;se_refcnt = (int64_t)audit_default_se.se_refcnt;
	next_sed-&gt;se_procnt = (int64_t)audit_default_se.se_procnt;
	next_sed++;
	sz += <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t);
	<span class="enscript-keyword">for</span>(i = 0; i &lt; HASH_TABLE_SIZE; i++) {
		LIST_FOREACH(se, &amp;au_sentry_bucket[i], se_link) {
			<span class="enscript-keyword">if</span> (se != NULL) {
				next_sed-&gt;se_auinfo = se-&gt;se_auinfo;
				next_sed-&gt;se_refcnt = (int64_t)se-&gt;se_refcnt;
				next_sed-&gt;se_procnt = (int64_t)se-&gt;se_procnt;
				next_sed++;
				sz += <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t);
			}
		}
	}
	AUDIT_SENTRY_RUNLOCK();

	<span class="enscript-comment">/* Reconcile with the process table. */</span>
	(<span class="enscript-type">void</span>) proc_iterate(PROC_ALLPROCLIST | PROC_ZOMBPROCLIST,
	    audit_session_debug_callout, NULL,
	    audit_session_debug_filterfn, (<span class="enscript-type">void</span> *)&amp;sed_tab[0]);


	req-&gt;oldlen = sz;
	err = SYSCTL_OUT(req, sed_tab, sz);
	kfree(sed_tab, entry_cnt * <span class="enscript-keyword">sizeof</span>(au_sentry_debug_t));

	<span class="enscript-keyword">return</span> (err);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* AUDIT_SESSION_DEBUG */</span>

<span class="enscript-comment">/*
 * Create and commit a session audit event. The proc and se arguments needs to
 * be that of the subject and not necessarily the current process.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_event</span>(<span class="enscript-type">int</span> event, auditinfo_addr_t *aia_p)
{
	<span class="enscript-type">struct</span> kaudit_record *ar;

	KASSERT(AUE_SESSION_START == event || AUE_SESSION_UPDATE == event ||
	    AUE_SESSION_END == event || AUE_SESSION_CLOSE == event,
	    (<span class="enscript-string">&quot;audit_session_event: invalid event: %d&quot;</span>, event));

	<span class="enscript-keyword">if</span> (NULL == aia_p)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* 
	 * Create a new audit record.  The record will contain the subject
	 * ruid, rgid, egid, pid, auid, asid, amask, and term_addr 
	 * (implicitly added by audit_new).
	 */</span>
	ar = audit_new(event, PROC_NULL, <span class="enscript-comment">/* Not used */</span> NULL);
	<span class="enscript-keyword">if</span> (NULL == ar)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Audit session events are always generated because they are used
	 * by some userland consumers so just set the preselect flag.
	 */</span>
	ar-&gt;k_ar_commit |= AR_PRESELECT_FILTER;

	<span class="enscript-comment">/* 
	 * Populate the subject information.  Note that the ruid, rgid,
	 * egid, and pid values are incorrect. We only need the  auditinfo_addr
	 * information.
	 */</span>
	ar-&gt;k_ar.ar_subj_ruid = 0;
	ar-&gt;k_ar.ar_subj_rgid = 0;
	ar-&gt;k_ar.ar_subj_egid = 0;
	ar-&gt;k_ar.ar_subj_pid = 0;
	ar-&gt;k_ar.ar_subj_auid = aia_p-&gt;ai_auid;
	ar-&gt;k_ar.ar_subj_asid = aia_p-&gt;ai_asid;
	bcopy(&amp;aia_p-&gt;ai_termid, &amp;ar-&gt;k_ar.ar_subj_term_addr,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_tid_addr));

	<span class="enscript-comment">/* Add the audit masks to the record. */</span>
	ar-&gt;k_ar.ar_arg_amask.am_success = aia_p-&gt;ai_mask.am_success;
	ar-&gt;k_ar.ar_arg_amask.am_failure = aia_p-&gt;ai_mask.am_failure;
	ARG_SET_VALID(ar, ARG_AMASK);

	<span class="enscript-comment">/* Add the audit session flags to the record. */</span>
	ar-&gt;k_ar.ar_arg_value64 = aia_p-&gt;ai_flags; 
	ARG_SET_VALID(ar, ARG_VALUE64);


	<span class="enscript-comment">/* Commit the record to the queue. */</span>
	audit_commit(ar, 0, 0);
}

<span class="enscript-comment">/*
 * Hash the audit session ID using a simple 32-bit mix.
 */</span>
<span class="enscript-type">static</span> inline uint32_t 
<span class="enscript-function-name">audit_session_hash</span>(au_asid_t asid)
{
	uint32_t a = (uint32_t) asid;

	a = (a - (a &lt;&lt; 6)) ^ (a &gt;&gt; 17); 
	a = (a - (a &lt;&lt; 9)) ^ (a &lt;&lt; 4);
	a = (a - (a &lt;&lt; 3)) ^ (a &lt;&lt; 10);
	a = a ^ (a &gt;&gt; 15);
	
	<span class="enscript-keyword">return</span> (a);
}

<span class="enscript-comment">/*
 * Do an hash lookup and find the session entry for a given ASID.  Return NULL
 * if not found. If the session is found then audit_session_find takes a 
 * reference. 
 */</span>
<span class="enscript-type">static</span> au_sentry_t *
<span class="enscript-function-name">audit_session_find</span>(au_asid_t asid)
{
	uint32_t	 hkey;
	au_sentry_t	*found_se;

	AUDIT_SENTRY_RWLOCK_ASSERT();

	hkey = HASH_ASID(asid);

	LIST_FOREACH(found_se, &amp;au_sentry_bucket[hkey], se_link)
		<span class="enscript-keyword">if</span> (found_se-&gt;se_asid == asid) {
			au_history_record(found_se, AU_HISTORY_EVENT_FIND);
			audit_ref_session(found_se);
			<span class="enscript-keyword">return</span> (found_se);
		}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Remove the given audit_session entry from the hash table.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_remove</span>(au_sentry_t *se)
{
	uint32_t	 hkey;
	au_sentry_t	*found_se, *tmp_se;

	au_history_record(se, AU_HISTORY_EVENT_DEATH);
	KASSERT(se-&gt;se_refcnt == 0, (<span class="enscript-string">&quot;audit_session_remove: ref count != 0&quot;</span>));	
	KASSERT(se != &amp;audit_default_se,
		(<span class="enscript-string">&quot;audit_session_remove: removing default session&quot;</span>));

	hkey = HASH_ASID(se-&gt;se_asid);

	AUDIT_SENTRY_WLOCK();
	<span class="enscript-comment">/*
	 * Check and see if someone got a reference before we got the lock.
	 */</span>
	<span class="enscript-keyword">if</span> (se-&gt;se_refcnt != 0) {
		AUDIT_SENTRY_WUNLOCK();
		<span class="enscript-keyword">return</span>;
	}

	audit_session_portdestroy(&amp;se-&gt;se_port);
	LIST_FOREACH_SAFE(found_se, &amp;au_sentry_bucket[hkey], se_link, tmp_se) {
		<span class="enscript-keyword">if</span> (found_se == se) {

			<span class="enscript-comment">/*
			 * Generate an audit event to notify userland of the
			 * session close.
			 */</span>
			audit_session_event(AUE_SESSION_CLOSE,
			    &amp;found_se-&gt;se_auinfo);

			LIST_REMOVE(found_se, se_link);
			AUDIT_SENTRY_WUNLOCK();
			free(found_se, M_AU_SESSION);

			<span class="enscript-keyword">return</span>;
		}
	}
	AUDIT_SENTRY_WUNLOCK();
}

<span class="enscript-comment">/*
 * Reference the session by incrementing the sentry ref count.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_ref_session</span>(au_sentry_t *se)
{
	<span class="enscript-type">long</span> old_val;

	<span class="enscript-keyword">if</span> (se == NULL || se == &amp;audit_default_se)
		<span class="enscript-keyword">return</span>;

	au_history_record(se, AU_HISTORY_EVENT_REF);

	old_val = OSAddAtomicLong(1, &amp;se-&gt;se_refcnt);
	KASSERT(old_val &lt; 100000,
	    (<span class="enscript-string">&quot;audit_ref_session: Too many references on session.&quot;</span>));
}

<span class="enscript-comment">/*
 * Decrement the sentry ref count and remove the session entry if last one.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_unref_session</span>(au_sentry_t *se)
{
	<span class="enscript-type">long</span> old_val;

	<span class="enscript-keyword">if</span> (se == NULL || se == &amp;audit_default_se)
		<span class="enscript-keyword">return</span>;

	au_history_record(se, AU_HISTORY_EVENT_UNREF);

	old_val = OSAddAtomicLong(-1, &amp;se-&gt;se_refcnt);
	<span class="enscript-keyword">if</span> (old_val == 1)
		audit_session_remove(se);
	KASSERT(old_val &gt; 0,
	    (<span class="enscript-string">&quot;audit_unref_session: Too few references on session.&quot;</span>));
}

<span class="enscript-comment">/*
 * Increment the process count in the session.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_inc_procount</span>(au_sentry_t *se)
{
	<span class="enscript-type">long</span> old_val;

	<span class="enscript-keyword">if</span> (se == NULL || se == &amp;audit_default_se)
		<span class="enscript-keyword">return</span>;
	
	old_val = OSAddAtomicLong(1, &amp;se-&gt;se_procnt);
	KASSERT(old_val &lt;= PID_MAX,
	    (<span class="enscript-string">&quot;audit_inc_procount: proc count &gt; PID_MAX&quot;</span>));
}

<span class="enscript-comment">/*
 * Decrement the process count and add a knote if it is the last process
 * to exit the session.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_dec_procount</span>(au_sentry_t *se)
{
	<span class="enscript-type">long</span> old_val;

	<span class="enscript-keyword">if</span> (se == NULL || se == &amp;audit_default_se)
		<span class="enscript-keyword">return</span>;

	old_val = OSAddAtomicLong(-1, &amp;se-&gt;se_procnt);
	<span class="enscript-comment">/*
	 * If this was the last process generate an audit event to notify
	 * userland of the session ending.
	 */</span>
	<span class="enscript-keyword">if</span> (old_val == 1)
		audit_session_event(AUE_SESSION_END, &amp;se-&gt;se_auinfo);
	KASSERT(old_val &gt;= 1,
	    (<span class="enscript-string">&quot;audit_dec_procount: proc count &lt; 0&quot;</span>));
}	

<span class="enscript-comment">/*
 * Update the session entry and check to see if anything was updated.
 * Returns:
 *    0    Nothing was updated (We don't care about process preselection masks) 
 *    1    Something was updated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_update_sentry</span>(au_sentry_t *se, auditinfo_addr_t *new_aia)
{
	auditinfo_addr_t *aia = &amp;se-&gt;se_auinfo;
	<span class="enscript-type">int</span> update;

	KASSERT(new_aia != audit_default_aia_p, 
	  (<span class="enscript-string">&quot;audit_update_sentry: Trying to update the default aia.&quot;</span>));

	update = (aia-&gt;ai_auid != new_aia-&gt;ai_auid ||
	    bcmp(&amp;aia-&gt;ai_termid, &amp;new_aia-&gt;ai_termid,
		<span class="enscript-keyword">sizeof</span>(new_aia-&gt;ai_termid)) ||
	    aia-&gt;ai_flags != new_aia-&gt;ai_flags);

	<span class="enscript-keyword">if</span> (update)
		bcopy(new_aia, aia, <span class="enscript-keyword">sizeof</span>(*aia));

	<span class="enscript-keyword">return</span> (update);
}

<span class="enscript-comment">/*
 * Return the next session ID.  The range of kernel generated audit session IDs
 * is ASSIGNED_ASID_MIN to ASSIGNED_ASID_MAX.
 */</span>
<span class="enscript-type">static</span> uint32_t 
<span class="enscript-function-name">audit_session_nextid</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> uint32_t next_asid = ASSIGNED_ASID_MIN; 

	AUDIT_SENTRY_RWLOCK_ASSERT();

	<span class="enscript-keyword">if</span> (next_asid &gt; ASSIGNED_ASID_MAX)
		next_asid = ASSIGNED_ASID_MIN;

	<span class="enscript-keyword">return</span> (next_asid++);
}

<span class="enscript-comment">/*
 * Allocated a new audit_session entry and add it to the hash table.  If the
 * given ASID is set to AU_ASSIGN_ASID then audit_session_new() will pick an
 * audit session ID.  Otherwise, it attempts use the one given. It creates a
 * reference to the entry that must be unref'ed.
 */</span>
<span class="enscript-type">static</span> auditinfo_addr_t *
<span class="enscript-function-name">audit_session_new</span>(auditinfo_addr_t *new_aia_p, auditinfo_addr_t *old_aia_p)
{
	au_asid_t new_asid;
	au_sentry_t *se = NULL;
	au_sentry_t *found_se = NULL;
	auditinfo_addr_t *aia = NULL;
	
	KASSERT(new_aia_p != NULL, (<span class="enscript-string">&quot;audit_session_new: new_aia_p == NULL&quot;</span>));

	new_asid = new_aia_p-&gt;ai_asid; 

	<span class="enscript-comment">/*
	 * Alloc a new session entry now so we don't wait holding the lock.
	 */</span>
	se = malloc(<span class="enscript-keyword">sizeof</span>(au_sentry_t), M_AU_SESSION, M_WAITOK | M_ZERO);

	<span class="enscript-comment">/*
	 * Find an unique session ID, if desired.
	 */</span>
	AUDIT_SENTRY_WLOCK();
	<span class="enscript-keyword">if</span> (new_asid == AU_ASSIGN_ASID) {
		<span class="enscript-keyword">do</span> {

			new_asid = (au_asid_t)audit_session_nextid();
			found_se = audit_session_find(new_asid);
			
			<span class="enscript-comment">/* 
			 * If the session ID is currently active then drop the
			 * reference and try again.
			 */</span>
			<span class="enscript-keyword">if</span> (found_se != NULL)
				audit_unref_session(found_se);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">while</span>(1);
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * Check to see if the requested ASID is already in the
		 * hash table.  If so, update it with the new auditinfo.
		 */</span>	
		<span class="enscript-keyword">if</span> ((found_se = audit_session_find(new_asid)) != NULL) {
			<span class="enscript-type">int</span> updated;

			updated = audit_update_sentry(found_se, new_aia_p);

			AUDIT_SENTRY_WUNLOCK();
			free(se, M_AU_SESSION);

			<span class="enscript-comment">/* If a different session then add this process in. */</span>
			<span class="enscript-keyword">if</span> (new_aia_p != old_aia_p)
				audit_inc_procount(found_se);

			<span class="enscript-comment">/*
			 * If the session information was updated then
			 * generate an audit event to notify userland.
			 */</span>
			<span class="enscript-keyword">if</span> (updated)
				audit_session_event(AUE_SESSION_UPDATE,
				    &amp;found_se-&gt;se_auinfo);

			<span class="enscript-keyword">return</span> (&amp;found_se-&gt;se_auinfo);
		}
	}

	<span class="enscript-comment">/*
	 * Start the reference and proc count at 1 to account for the process
	 * that invoked this via setaudit_addr() (or friends).
	 */</span>
	se-&gt;se_refcnt = se-&gt;se_procnt = 1;

	<span class="enscript-comment">/*
	 * Populate the new session entry.  Note that process masks are stored
	 * in kauth ucred so just zero them here.
	 */</span>
	se-&gt;se_port = IPC_PORT_NULL;
	aia = &amp;se-&gt;se_auinfo;
	aia-&gt;ai_asid = new_asid;
	aia-&gt;ai_auid = new_aia_p-&gt;ai_auid;
	bzero(&amp;new_aia_p-&gt;ai_mask, <span class="enscript-keyword">sizeof</span>(new_aia_p-&gt;ai_mask));
	bcopy(&amp;new_aia_p-&gt;ai_termid, &amp;aia-&gt;ai_termid, <span class="enscript-keyword">sizeof</span>(aia-&gt;ai_termid));
	aia-&gt;ai_flags = new_aia_p-&gt;ai_flags;

	<span class="enscript-comment">/*
	 * Add it to the hash table.
	 */</span>
	LIST_INSERT_HEAD(&amp;au_sentry_bucket[HASH_ASID(new_asid)], se, se_link);
	AUDIT_SENTRY_WUNLOCK();

	<span class="enscript-comment">/*
	 * Generate an audit event to notify userland of the new session.
	 */</span>
	audit_session_event(AUE_SESSION_START, aia);
	au_history_record(se, AU_HISTORY_EVENT_BIRTH);
	<span class="enscript-keyword">return</span> (aia);
}

<span class="enscript-comment">/*
 * Lookup an existing session.  A copy of the audit session info for a given
 * ASID is returned in ret_aia.  Returns 0 on success.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_lookup</span>(au_asid_t asid, auditinfo_addr_t *ret_aia)
{
	au_sentry_t *se = NULL;

	<span class="enscript-keyword">if</span> ((uint32_t)asid &gt; ASSIGNED_ASID_MAX)
		<span class="enscript-keyword">return</span> (-1);
	AUDIT_SENTRY_RLOCK();
	<span class="enscript-keyword">if</span> ((se = audit_session_find(asid)) == NULL) {
		AUDIT_SENTRY_RUNLOCK();
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-comment">/* We have a reference on the session so it is safe to drop the lock. */</span>
	AUDIT_SENTRY_RUNLOCK();
	<span class="enscript-keyword">if</span> (ret_aia != NULL)
		bcopy(&amp;se-&gt;se_auinfo, ret_aia, <span class="enscript-keyword">sizeof</span>(*ret_aia));
	audit_unref_session(se);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_aiaref</span>(auditinfo_addr_t *aia_p)
{

	audit_ref_session(AU_SENTRY_PTR(aia_p));
}
	
<span class="enscript-comment">/*
 * Add a reference to the session entry.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_ref</span>(kauth_cred_t cred)
{
	auditinfo_addr_t *aia_p;

	KASSERT(IS_VALID_CRED(cred),
	    (<span class="enscript-string">&quot;audit_session_ref: Invalid kauth_cred.&quot;</span>));

 	aia_p = cred-&gt;cr_audit.as_aia_p;
	audit_session_aiaref(aia_p);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">audit_session_aiaunref</span>(auditinfo_addr_t *aia_p)
{

	audit_unref_session(AU_SENTRY_PTR(aia_p));
}

<span class="enscript-comment">/* 
 * Remove a reference to the session entry.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_unref</span>(kauth_cred_t cred)
{
	auditinfo_addr_t *aia_p;

	KASSERT(IS_VALID_CRED(cred),
	    (<span class="enscript-string">&quot;audit_session_unref: Invalid kauth_cred.&quot;</span>));

 	aia_p = cred-&gt;cr_audit.as_aia_p;
	audit_session_aiaunref(aia_p);
}

<span class="enscript-comment">/*
 * Increment the per audit session process count.  Assumes that the caller has
 * a reference on the process' cred.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_procnew</span>(proc_t p)
{
	kauth_cred_t cred = p-&gt;p_ucred;
	auditinfo_addr_t *aia_p;
	
	KASSERT(IS_VALID_CRED(cred), 
	    (<span class="enscript-string">&quot;audit_session_procnew: Invalid kauth_cred.&quot;</span>));

	aia_p = cred-&gt;cr_audit.as_aia_p; 

	audit_inc_procount(AU_SENTRY_PTR(aia_p));
}

<span class="enscript-comment">/*
 * Decrement the per audit session process count.  Assumes that the caller has
 * a reference on the cred.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_procexit</span>(proc_t p)
{
	kauth_cred_t cred = p-&gt;p_ucred;
	auditinfo_addr_t *aia_p;

	KASSERT(IS_VALID_CRED(cred), 
	    (<span class="enscript-string">&quot;audit_session_procexit: Invalid kauth_cred.&quot;</span>));

	aia_p = cred-&gt;cr_audit.as_aia_p; 

	audit_dec_procount(AU_SENTRY_PTR(aia_p));
}

<span class="enscript-comment">/*
 * Init the audit session code.  
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_session_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	KASSERT((ASSIGNED_ASID_MAX - ASSIGNED_ASID_MIN) &gt; PID_MAX,
	    (<span class="enscript-string">&quot;audit_session_init: ASSIGNED_ASID_MAX is not large enough.&quot;</span>));
	
	AUDIT_SENTRY_RWLOCK_INIT();

	au_sentry_bucket = malloc( <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_sentry) *
	    HASH_TABLE_SIZE, M_AU_SESSION, M_WAITOK | M_ZERO);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; HASH_TABLE_SIZE; i++)
		LIST_INIT(&amp;au_sentry_bucket[i]);

	(<span class="enscript-type">void</span>)audit_sdev_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AU_HISTORY_LOGGING</span>
	au_history = malloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_history) * au_history_size,
	    M_AU_SESSION, M_WAITOK|M_ZERO);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_update_check</span>(kauth_cred_t cred, auditinfo_addr_t *old,
    auditinfo_addr_t *new)
{
	uint64_t n;

	<span class="enscript-comment">/* If the current audit ID is not the default then it is immutable. */</span>
	<span class="enscript-keyword">if</span> (old-&gt;ai_auid != AU_DEFAUDITID &amp;&amp; old-&gt;ai_auid != new-&gt;ai_auid)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* If the current termid is not the default then it is immutable. */</span>
	<span class="enscript-keyword">if</span> ((old-&gt;ai_termid.at_type != AU_IPv4 ||
	     old-&gt;ai_termid.at_port != 0 ||
	     old-&gt;ai_termid.at_addr[0] != 0) &amp;&amp;
	    (old-&gt;ai_termid.at_port != new-&gt;ai_termid.at_port ||
	     old-&gt;ai_termid.at_type != new-&gt;ai_termid.at_type ||
	     0 != bcmp(&amp;old-&gt;ai_termid.at_addr, &amp;new-&gt;ai_termid.at_addr,
		 <span class="enscript-keyword">sizeof</span> (old-&gt;ai_termid.at_addr))))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* The flags may be set only according to the
	 * audit_session_*_set_sflags_masks.
	 */</span>
	n = ~old-&gt;ai_flags &amp; new-&gt;ai_flags;
	<span class="enscript-keyword">if</span> (0 != n &amp;&amp;
	    !((n == (audit_session_superuser_set_sflags_mask &amp; n) &amp;&amp;
		kauth_cred_issuser(cred)) ||
	      (n == (audit_session_member_set_sflags_mask &amp; n)    &amp;&amp;
		old-&gt;ai_asid == new-&gt;ai_asid)))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* The flags may be cleared only according to the
	 * audit_session_*_clear_sflags_masks.
	 */</span>
	n = ~new-&gt;ai_flags &amp; old-&gt;ai_flags;
	<span class="enscript-keyword">if</span> (0 != n &amp;&amp;
	    !((n == (audit_session_superuser_clear_sflags_mask &amp; n) &amp;&amp;
		kauth_cred_issuser(cred)) ||
	      (n == (audit_session_member_clear_sflags_mask &amp; n)    &amp;&amp;
		old-&gt;ai_asid == new-&gt;ai_asid)))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* The audit masks are mutable. */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Safely update kauth cred of the given process with new the given audit info. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_setaia</span>(proc_t p, auditinfo_addr_t *new_aia_p)
{
	kauth_cred_t my_cred, my_new_cred;
	<span class="enscript-type">struct</span> au_session  as;
	<span class="enscript-type">struct</span> au_session  tmp_as;
	auditinfo_addr_t caia, *old_aia_p;
	<span class="enscript-type">int</span> ret;

	<span class="enscript-comment">/*
	 * If this is going to modify an existing session then do some
	 * immutable checks.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_session_lookup(new_aia_p-&gt;ai_asid, &amp;caia) == 0) {
		my_cred = kauth_cred_proc_ref(p);
		ret = audit_session_update_check(my_cred, &amp;caia, new_aia_p);
		kauth_cred_unref(&amp;my_cred);
		<span class="enscript-keyword">if</span> (ret)
			<span class="enscript-keyword">return</span> (ret);
	}

	my_cred = kauth_cred_proc_ref(p);
	bcopy(&amp;new_aia_p-&gt;ai_mask, &amp;as.as_mask, <span class="enscript-keyword">sizeof</span>(as.as_mask));
	old_aia_p = my_cred-&gt;cr_audit.as_aia_p;
	<span class="enscript-comment">/* audit_session_new() adds a reference on the session */</span>
	as.as_aia_p = audit_session_new(new_aia_p, old_aia_p);

	<span class="enscript-comment">/* If the process left a session then update the process count. */</span>
	<span class="enscript-keyword">if</span> (old_aia_p != new_aia_p)
		audit_dec_procount(AU_SENTRY_PTR(old_aia_p));


	<span class="enscript-comment">/*
	 * We are modifying the audit info in a credential so we need a new
	 * credential (or take another reference on an existing credential that
	 * matches our new one).  We must do this because the audit info in the
	 * credential is used as part of our hash key.	Get current credential
	 * in the target process and take a reference while we muck with it.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-comment">/*
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
		 */</span>
		bcopy(&amp;as, &amp;tmp_as, <span class="enscript-keyword">sizeof</span>(tmp_as));
		my_new_cred = kauth_cred_setauditinfo(my_cred, &amp;tmp_as);

		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {
			proc_lock(p);
			<span class="enscript-comment">/* Need to protect for a race where another thread also
			 * changed the credential after we took our reference.
			 * If p_ucred has changed then we should restart this
			 * again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				audit_session_unref(my_new_cred);
				kauth_cred_unref(&amp;my_new_cred);
				<span class="enscript-comment">/* try again */</span>
				my_cred = kauth_cred_proc_ref(p);
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			proc_unlock(p);
		}
		<span class="enscript-comment">/*
		 * Drop old proc reference or our extra reference.
		 */</span>
		kauth_cred_unref(&amp;my_cred);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Drop the reference taken by audit_session_new() above. */</span>
	audit_unref_session(AU_SENTRY_PTR(as.as_aia_p));

	<span class="enscript-comment">/* Propagate the change from the process to the Mach task. */</span>
	set_security_token(p);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * audit_session_self  (system call)
 *
 * Description: Obtain a Mach send right for the current session.   
 *
 * Parameters:	p		Process calling audit_session_self().
 * 
 * Returns:	*ret_port	Named Mach send right, which may be
 * 				MACH_PORT_NULL in the failure case.
 *
 * Errno:	0		Success
 * 		EINVAL		The calling process' session has not be set.
 * 		ESRCH		Bad process, can't get valid cred for process. 
 * 		ENOMEM		Port allocation failed due to no free memory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_self</span>(proc_t p, __unused <span class="enscript-type">struct</span> audit_session_self_args *uap,
    mach_port_name_t *ret_port)
{
	ipc_port_t sendport = IPC_PORT_NULL;
	kauth_cred_t cred = NULL;
	auditinfo_addr_t *aia_p;
	au_sentry_t *se;
	<span class="enscript-type">int</span> err = 0;

	cred = kauth_cred_proc_ref(p);
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred)) {
		err = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	aia_p = cred-&gt;cr_audit.as_aia_p;
	<span class="enscript-keyword">if</span> (!IS_VALID_SESSION(aia_p)) {
		<span class="enscript-comment">/* Can't join the default session. */</span>
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	se = AU_SENTRY_PTR(aia_p); 

	<span class="enscript-comment">/* 
	 * Processes that join using this mach port will inherit this process'
	 * pre-selection masks.
	 */</span>
	<span class="enscript-keyword">if</span> (se-&gt;se_port == IPC_PORT_NULL) 
		bcopy(&amp;cred-&gt;cr_audit.as_mask, &amp;se-&gt;se_mask,
		    <span class="enscript-keyword">sizeof</span>(se-&gt;se_mask));

	<span class="enscript-comment">/*
	 * Get a send right to the session's Mach port and insert it in the
	 * process' mach port namespace.
	 */</span>
	sendport = audit_session_mksend(aia_p, &amp;se-&gt;se_port);
	*ret_port = ipc_port_copyout_send(sendport, get_task_ipcspace(p-&gt;task));

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (cred != NULL)
		kauth_cred_unref(&amp;cred);	
	<span class="enscript-keyword">if</span> (err != 0)
		*ret_port = MACH_PORT_NULL;
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * audit_session_port  (system call)
 *
 * Description: Obtain a Mach send right for the given session ID.
 *
 * Parameters:	p		Process calling audit_session_port().
 *              uap-&gt;asid       The target audit session ID.  The special
 *              		value -1 can be used to target the process's
 *              		own session.
 *              uap-&gt;portnamep  User address at which to place port name.
 *
 * Returns:	0		Success
 * 		EINVAL		The calling process' session has not be set.
 * 		EINVAL		The given session ID could not be found.
 * 		EINVAL		The Mach port right could not be copied out.
 * 		ESRCH		Bad process, can't get valid cred for process.
 * 		EPERM		Only the superuser can reference sessions other
 * 				than the process's own.
 * 		ENOMEM		Port allocation failed due to no free memory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_port</span>(proc_t p, <span class="enscript-type">struct</span> audit_session_port_args *uap,
    __unused <span class="enscript-type">int</span> *retval)
{
	ipc_port_t sendport = IPC_PORT_NULL;
	mach_port_name_t portname = MACH_PORT_NULL;
	kauth_cred_t cred = NULL;
	auditinfo_addr_t *aia_p = NULL;
	au_sentry_t *se = NULL;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-comment">/* Note: Currently this test will never be true, because
	 * ASSIGNED_ASID_MAX is effectively (uint32_t)-2.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;asid != -1 &amp;&amp; (uint32_t)uap-&gt;asid &gt; ASSIGNED_ASID_MAX) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	cred = kauth_cred_proc_ref(p);
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred)) {
		err = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	aia_p = cred-&gt;cr_audit.as_aia_p;

	<span class="enscript-comment">/* Find the session corresponding to the requested audit
	 * session ID.  If found, take a reference on it so that
	 * the session is not dropped until the join is later done.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;asid == (au_asid_t)-1 ||
	    uap-&gt;asid == aia_p-&gt;ai_asid) {

		<span class="enscript-keyword">if</span> (!IS_VALID_SESSION(aia_p)) {
			<span class="enscript-comment">/* Can't join the default session. */</span>
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-comment">/* No privilege is required to obtain a port for our
		 * own session.
		 */</span>
		se = AU_SENTRY_PTR(aia_p);
		audit_ref_session(se);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kauth_cred_issuser(cred)) {
		<span class="enscript-comment">/* The superuser may obtain a port for any existing
		 * session.
		 */</span>
		AUDIT_SENTRY_RLOCK();
		se = audit_session_find(uap-&gt;asid);
		AUDIT_SENTRY_RUNLOCK();
		<span class="enscript-keyword">if</span> (NULL == se) {
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		aia_p = &amp;se-&gt;se_auinfo;
	} <span class="enscript-keyword">else</span> {
		err = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Processes that join using this mach port will inherit this process'
	 * pre-selection masks.
	 */</span>
	<span class="enscript-keyword">if</span> (se-&gt;se_port == IPC_PORT_NULL)
		bcopy(&amp;cred-&gt;cr_audit.as_mask, &amp;se-&gt;se_mask,
		    <span class="enscript-keyword">sizeof</span>(se-&gt;se_mask));

	<span class="enscript-comment">/*
	 * Use the session reference to create a mach port reference for the
	 * session (at which point we are free to drop the session reference)
	 * and then copy out the mach port to the process' mach port namespace.
	 */</span>
	sendport = audit_session_mksend(aia_p, &amp;se-&gt;se_port);
	portname = ipc_port_copyout_send(sendport, get_task_ipcspace(p-&gt;task));
	<span class="enscript-keyword">if</span> (!MACH_PORT_VALID(portname)) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	err = copyout(&amp;portname, uap-&gt;portnamep, <span class="enscript-keyword">sizeof</span>(mach_port_name_t));
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (cred != NULL)
		kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">if</span> (NULL != se)
		audit_unref_session(se);
	<span class="enscript-keyword">if</span> (MACH_PORT_VALID(portname) &amp;&amp; 0 != err)
                (<span class="enscript-type">void</span>)mach_port_deallocate(get_task_ipcspace(p-&gt;task),
		    portname);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_join_internal</span>(proc_t p, ipc_port_t port, au_asid_t *new_asid)
{
	auditinfo_addr_t *new_aia_p, *old_aia_p;
	kauth_cred_t my_cred = NULL;
	au_asid_t old_asid;
	<span class="enscript-type">int</span> err = 0;

	*new_asid = AU_DEFAUDITSID;

	<span class="enscript-keyword">if</span> ((new_aia_p = audit_session_porttoaia(port)) == NULL) {
		err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	proc_lock(p);
	kauth_cred_ref(p-&gt;p_ucred);
	my_cred = p-&gt;p_ucred;
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(my_cred)) {
		kauth_cred_unref(&amp;my_cred);	
		proc_unlock(p);
		err = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	old_aia_p = my_cred-&gt;cr_audit.as_aia_p;
	old_asid = old_aia_p-&gt;ai_asid;
	*new_asid = new_aia_p-&gt;ai_asid;

	<span class="enscript-comment">/*
	 * Add process in if not already in the session.
	 */</span>
	<span class="enscript-keyword">if</span> (*new_asid != old_asid) {
		kauth_cred_t my_new_cred;
		<span class="enscript-type">struct</span> au_session new_as;

		bcopy(&amp;new_aia_p-&gt;ai_mask, &amp;new_as.as_mask,
			<span class="enscript-keyword">sizeof</span>(new_as.as_mask));
		new_as.as_aia_p = new_aia_p;

		my_new_cred = kauth_cred_setauditinfo(my_cred, &amp;new_as);
		p-&gt;p_ucred = my_new_cred;
		PROC_UPDATE_CREDS_ONPROC(p);

		<span class="enscript-comment">/* Increment the proc count of new session */</span>
		audit_inc_procount(AU_SENTRY_PTR(new_aia_p));

		proc_unlock(p);

		<span class="enscript-comment">/* Propagate the change from the process to the Mach task. */</span>
		set_security_token(p);

		<span class="enscript-comment">/* Decrement the process count of the former session. */</span>
		audit_dec_procount(AU_SENTRY_PTR(old_aia_p));
	} <span class="enscript-keyword">else</span>  {
		proc_unlock(p);
	}
	kauth_cred_unref(&amp;my_cred);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (port != IPC_PORT_NULL)
		ipc_port_release_send(port);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * audit_session_spawnjoin
 *
 * Description: posix_spawn() interface to audit_session_join_internal().
 *
 * Returns:	0		Success
 * 		EINVAL		Invalid Mach port name.
 * 		ESRCH		Invalid calling process/cred.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_spawnjoin</span>(proc_t p, ipc_port_t port)
{
	au_asid_t new_asid;
	
	<span class="enscript-keyword">return</span> (audit_session_join_internal(p, port, &amp;new_asid));
}

<span class="enscript-comment">/*
 * audit_session_join  (system call)
 *
 * Description:	Join the session for a given Mach port send right.
 * 
 * Parameters:	p		Process calling session join.
 * 		uap-&gt;port	A Mach send right.
 *
 * Returns:	*ret_asid	Audit session ID of new session.
 *				In the failure case the return value will be -1
 *				and 'errno' will be set to a non-zero value
 *				described below.
 *
 * Errno:	0		Success	
 * 		EINVAL		Invalid Mach port name.
 * 		ESRCH		Invalid calling process/cred.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_join</span>(proc_t p, <span class="enscript-type">struct</span> audit_session_join_args *uap,
    au_asid_t *ret_asid)
{
	ipc_port_t port = IPC_PORT_NULL;
	mach_port_name_t send = uap-&gt;port;
	<span class="enscript-type">int</span> err = 0;

	
	<span class="enscript-keyword">if</span> (ipc_object_copyin(get_task_ipcspace(p-&gt;task), send,
		MACH_MSG_TYPE_COPY_SEND, &amp;port) != KERN_SUCCESS) {
		*ret_asid = AU_DEFAUDITSID;
		err = EINVAL;
	} <span class="enscript-keyword">else</span>
		err = audit_session_join_internal(p, port, ret_asid);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * Audit session device.
 */</span>

<span class="enscript-comment">/*
 * Free an audit sdev entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_sdev_entry_free</span>(<span class="enscript-type">struct</span> audit_sdev_entry *ase)
{

	free(ase-&gt;ase_record, M_AUDIT_SDEV_ENTRY);
	free(ase, M_AUDIT_SDEV_ENTRY);
}

<span class="enscript-comment">/*
 * Append individual record to a queue.  Allocate queue-local buffer and
 * add to the queue.  If the queue is full or we can't allocate memory,
 * drop the newest record.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_sdev_append</span>(<span class="enscript-type">struct</span> audit_sdev *asdev, <span class="enscript-type">void</span> *record, u_int record_len)
{
	<span class="enscript-type">struct</span> audit_sdev_entry *ase;

	AUDIT_SDEV_LOCK_ASSERT(asdev);

	<span class="enscript-keyword">if</span> (asdev-&gt;asdev_qlen &gt;= asdev-&gt;asdev_qlimit) {
		asdev-&gt;asdev_drops++;
		audit_sdev_drops++;
		<span class="enscript-keyword">return</span>;
	}

	ase = malloc(<span class="enscript-keyword">sizeof</span> (*ase), M_AUDIT_SDEV_ENTRY, M_NOWAIT | M_ZERO);
	<span class="enscript-keyword">if</span> (NULL == ase) {
		asdev-&gt;asdev_drops++;
		audit_sdev_drops++;
		<span class="enscript-keyword">return</span>;
	}

	ase-&gt;ase_record = malloc(record_len, M_AUDIT_SDEV_ENTRY, M_NOWAIT);
	<span class="enscript-keyword">if</span> (NULL == ase-&gt;ase_record) {
		free(ase, M_AUDIT_SDEV_ENTRY);
		asdev-&gt;asdev_drops++;
		audit_sdev_drops++;
		<span class="enscript-keyword">return</span>;
	}

	bcopy(record, ase-&gt;ase_record, record_len);
	ase-&gt;ase_record_len = record_len;

	TAILQ_INSERT_TAIL(&amp;asdev-&gt;asdev_queue, ase, ase_queue);
	asdev-&gt;asdev_inserts++;
	asdev-&gt;asdev_qlen++;
	asdev-&gt;asdev_qbyteslen += ase-&gt;ase_record_len;
	selwakeup(&amp;asdev-&gt;asdev_selinfo);
	<span class="enscript-keyword">if</span> (asdev-&gt;asdev_flags &amp; AUDIT_SDEV_ASYNC)
		pgsigio(asdev-&gt;asdev_sigio, SIGIO);

	cv_broadcast(&amp;asdev-&gt;asdev_cv);
}

<span class="enscript-comment">/*
 * Submit an audit record to be queued in the audit session device.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_sdev_submit</span>(__unused au_id_t auid, __unused au_asid_t asid, <span class="enscript-type">void</span> *record,
    u_int record_len)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;

	<span class="enscript-comment">/*
	 * Lockless read to avoid lock overhead if sessio devices are not in
	 * use.
	 */</span>
	<span class="enscript-keyword">if</span> (NULL == TAILQ_FIRST(&amp;audit_sdev_list))
		<span class="enscript-keyword">return</span>;

	AUDIT_SDEV_LIST_RLOCK();
	TAILQ_FOREACH(asdev, &amp;audit_sdev_list, asdev_list) {
		AUDIT_SDEV_LOCK(asdev);
		
		<span class="enscript-comment">/* 
		 * Only append to the sdev queue if the AUID and ASID match that
		 * of the process that opened this session device or if the
		 * ALLSESSIONS flag is set.
		 */</span>
		<span class="enscript-keyword">if</span> ((<span class="enscript-comment">/* XXXss auid == asdev-&gt;asdev_auid &amp;&amp; */</span>
			asid == asdev-&gt;asdev_asid) ||
		    (asdev-&gt;asdev_flags &amp; AUDIT_SDEV_ALLSESSIONS) != 0)
			audit_sdev_append(asdev, record, record_len);
		AUDIT_SDEV_UNLOCK(asdev);
	}
	AUDIT_SDEV_LIST_RUNLOCK();

	<span class="enscript-comment">/* Unlocked increment. */</span>
	audit_sdev_records++;
}

<span class="enscript-comment">/*
 * Allocate a new audit sdev.  Connects the sdev, on succes, to the global
 * list and updates statistics.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> audit_sdev *
<span class="enscript-function-name">audit_sdev_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;

	AUDIT_SDEV_LIST_WLOCK_ASSERT();

	asdev = malloc(<span class="enscript-keyword">sizeof</span> (*asdev), M_AUDIT_SDEV, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (NULL == asdev)
		<span class="enscript-keyword">return</span> (NULL);

	asdev-&gt;asdev_qlimit = AUDIT_SDEV_QLIMIT_DEFAULT;
	TAILQ_INIT(&amp;asdev-&gt;asdev_queue);
	AUDIT_SDEV_LOCK_INIT(asdev);
	AUDIT_SDEV_SX_LOCK_INIT(asdev);
	cv_init(&amp;asdev-&gt;asdev_cv, <span class="enscript-string">&quot;audit_sdev_cv&quot;</span>);

	<span class="enscript-comment">/*
	 * Add to global list and update global statistics.
	 */</span>
	TAILQ_INSERT_HEAD(&amp;audit_sdev_list, asdev, asdev_list);
	audit_sdev_count++;
	audit_sdev_ever++;

	<span class="enscript-keyword">return</span> (asdev);
}

<span class="enscript-comment">/*
 * Flush all records currently present in an audit sdev.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_sdev_flush</span>(<span class="enscript-type">struct</span> audit_sdev *asdev)
{
	<span class="enscript-type">struct</span> audit_sdev_entry *ase;

	AUDIT_SDEV_LOCK_ASSERT(asdev);

	<span class="enscript-keyword">while</span> ((ase = TAILQ_FIRST(&amp;asdev-&gt;asdev_queue)) != NULL) {
		TAILQ_REMOVE(&amp;asdev-&gt;asdev_queue, ase, ase_queue);
		asdev-&gt;asdev_qbyteslen -= ase-&gt;ase_record_len;
		audit_sdev_entry_free(ase);
		asdev-&gt;asdev_qlen--;
	}
	asdev-&gt;asdev_qoffset = 0;

	KASSERT(0 == asdev-&gt;asdev_qlen, (<span class="enscript-string">&quot;audit_sdev_flush: asdev_qlen&quot;</span>));
	KASSERT(0 == asdev-&gt;asdev_qbyteslen,
	    (<span class="enscript-string">&quot;audit_sdev_flush: asdev_qbyteslen&quot;</span>));
}

<span class="enscript-comment">/*
 * Free an audit sdev.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_sdev_free</span>(<span class="enscript-type">struct</span> audit_sdev *asdev)
{

	AUDIT_SDEV_LIST_WLOCK_ASSERT();
	AUDIT_SDEV_LOCK_ASSERT(asdev);

	<span class="enscript-comment">/* XXXss - preselect hook here */</span>
	audit_sdev_flush(asdev);
	cv_destroy(&amp;asdev-&gt;asdev_cv);
	AUDIT_SDEV_SX_LOCK_DESTROY(asdev);
	AUDIT_SDEV_UNLOCK(asdev);
	AUDIT_SDEV_LOCK_DESTROY(asdev);

	TAILQ_REMOVE(&amp;audit_sdev_list, asdev, asdev_list);
	free(asdev, M_AUDIT_SDEV);
	audit_sdev_count--;
}

<span class="enscript-comment">/*
 * Get the auditinfo_addr of the proc and check to see if suser.  Will return
 * non-zero if not suser.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_get_aia</span>(proc_t p, <span class="enscript-type">struct</span> auditinfo_addr *aia_p)
{
	<span class="enscript-type">int</span> error;
	kauth_cred_t scred;

	scred = kauth_cred_proc_ref(p);
	error = suser(scred, &amp;p-&gt;p_acflag);

	<span class="enscript-keyword">if</span> (NULL != aia_p)
		bcopy(scred-&gt;cr_audit.as_aia_p, aia_p, <span class="enscript-keyword">sizeof</span> (*aia_p));
	kauth_cred_unref(&amp;scred);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Audit session dev open method.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_open</span>(dev_t dev, __unused <span class="enscript-type">int</span> flags,  __unused <span class="enscript-type">int</span> devtype, proc_t p)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;
	<span class="enscript-type">struct</span> auditinfo_addr aia;
	<span class="enscript-type">int</span> u;

	u = minor(dev);
	<span class="enscript-keyword">if</span> (u &lt; 0 || u &gt; MAX_AUDIT_SDEVS)
		<span class="enscript-keyword">return</span> (ENXIO);

	(<span class="enscript-type">void</span>) audit_sdev_get_aia(p, &amp;aia);

	AUDIT_SDEV_LIST_WLOCK();
	asdev = audit_sdev_dtab[u];
	<span class="enscript-keyword">if</span> (NULL == asdev) {
		asdev = audit_sdev_alloc();
		<span class="enscript-keyword">if</span> (NULL == asdev) {
			AUDIT_SDEV_LIST_WUNLOCK();
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		audit_sdev_dtab[u] = asdev;
	} <span class="enscript-keyword">else</span> {
		KASSERT(asdev-&gt;asdev_open, (<span class="enscript-string">&quot;audit_sdev_open: Already open&quot;</span>));
		AUDIT_SDEV_LIST_WUNLOCK();
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	asdev-&gt;asdev_open = 1;
	asdev-&gt;asdev_auid = aia.ai_auid;
	asdev-&gt;asdev_asid = aia.ai_asid;
	asdev-&gt;asdev_flags = 0; 

	AUDIT_SDEV_LIST_WUNLOCK();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Audit session dev close method.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_close</span>(dev_t dev, __unused <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">int</span> devtype,
    __unused proc_t p)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;
	<span class="enscript-type">int</span> u;

	u = minor(dev);
	asdev = audit_sdev_dtab[u];

	KASSERT(asdev != NULL, (<span class="enscript-string">&quot;audit_sdev_close: asdev == NULL&quot;</span>));
	KASSERT(asdev-&gt;asdev_open, (<span class="enscript-string">&quot;audit_sdev_close: !asdev_open&quot;</span>));

	AUDIT_SDEV_LIST_WLOCK();
	AUDIT_SDEV_LOCK(asdev);
	asdev-&gt;asdev_open = 0;
	audit_sdev_free(asdev);  <span class="enscript-comment">/* sdev lock unlocked in audit_sdev_free() */</span>
	audit_sdev_dtab[u] = NULL;
	AUDIT_SDEV_LIST_WUNLOCK();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Audit session dev ioctl method.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_ioctl</span>(dev_t dev, u_long cmd, caddr_t data,
    __unused <span class="enscript-type">int</span> flag, proc_t p)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;
	<span class="enscript-type">int</span> error;

	asdev = audit_sdev_dtab[minor(dev)];
	KASSERT(asdev != NULL, (<span class="enscript-string">&quot;audit_sdev_ioctl: asdev == NULL&quot;</span>));

	error = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:
		AUDIT_SDEV_LOCK(asdev);
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			asdev-&gt;asdev_flags |= AUDIT_SDEV_NBIO;
		<span class="enscript-keyword">else</span>
			asdev-&gt;asdev_flags &amp;= ~AUDIT_SDEV_NBIO;
		AUDIT_SDEV_UNLOCK(asdev);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONREAD</span>:
		AUDIT_SDEV_LOCK(asdev);
		*(<span class="enscript-type">int</span> *)data = asdev-&gt;asdev_qbyteslen - asdev-&gt;asdev_qoffset;
		AUDIT_SDEV_UNLOCK(asdev);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_QLEN</span>:
		*(u_int *)data = asdev-&gt;asdev_qlen;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_QLIMIT</span>:
		*(u_int *)data = asdev-&gt;asdev_qlimit;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_SET_QLIMIT</span>:
		<span class="enscript-keyword">if</span> (*(u_int *)data &gt;= AUDIT_SDEV_QLIMIT_MIN ||
		    *(u_int *)data &lt;= AUDIT_SDEV_QLIMIT_MAX) {
			asdev-&gt;asdev_qlimit = *(u_int *)data;
		} <span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_QLIMIT_MIN</span>:
		*(u_int *)data = AUDIT_SDEV_QLIMIT_MIN;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_QLIMIT_MAX</span>:
		*(u_int *)data = AUDIT_SDEV_QLIMIT_MAX;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_FLUSH</span>:
		<span class="enscript-keyword">if</span> (AUDIT_SDEV_SX_XLOCK_SIG(asdev) != 0)
			<span class="enscript-keyword">return</span> (EINTR);
		AUDIT_SDEV_LOCK(asdev);
		audit_sdev_flush(asdev);
		AUDIT_SDEV_UNLOCK(asdev);
		AUDIT_SDEV_SX_XUNLOCK(asdev);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_MAXDATA</span>:
		*(u_int *)data = MAXAUDITDATA;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-comment">/* XXXss these should be 64 bit, maybe. */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_INSERTS</span>:
		*(u_int *)data = asdev-&gt;asdev_inserts;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_READS</span>:
		*(u_int *)data = asdev-&gt;asdev_reads;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_DROPS</span>:
		*(u_int *)data = asdev-&gt;asdev_drops;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_GET_ALLSESSIONS</span>:
		error = audit_sdev_get_aia(p, NULL);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		*(u_int *)data = (asdev-&gt;asdev_flags &amp; AUDIT_SDEV_ALLSESSIONS) ?
		    1 : 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUDITSDEV_SET_ALLSESSIONS</span>:
		error = audit_sdev_get_aia(p, NULL);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;

		AUDIT_SDEV_LOCK(asdev);
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			asdev-&gt;asdev_flags |= AUDIT_SDEV_ALLSESSIONS;
		<span class="enscript-keyword">else</span>
			asdev-&gt;asdev_flags &amp;= ~AUDIT_SDEV_ALLSESSIONS;
		AUDIT_SDEV_UNLOCK(asdev);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ENOTTY;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Audit session dev read method. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_read</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flag)
{
	<span class="enscript-type">struct</span> audit_sdev_entry *ase;
	<span class="enscript-type">struct</span> audit_sdev *asdev;
	u_int toread;
	<span class="enscript-type">int</span> error;

	asdev = audit_sdev_dtab[minor(dev)];
	KASSERT(NULL != asdev, (<span class="enscript-string">&quot;audit_sdev_read: asdev == NULL&quot;</span>));

	<span class="enscript-comment">/*
	 * We hold a sleep lock over read and flush because we rely on the
	 * stability of a record in the queue during uiomove.
	 */</span>
	<span class="enscript-keyword">if</span> (0 != AUDIT_SDEV_SX_XLOCK_SIG(asdev))
		<span class="enscript-keyword">return</span> (EINTR);
	AUDIT_SDEV_LOCK(asdev);
	<span class="enscript-keyword">while</span> (TAILQ_EMPTY(&amp;asdev-&gt;asdev_queue)) {
		<span class="enscript-keyword">if</span> (asdev-&gt;asdev_flags &amp; AUDIT_SDEV_NBIO) {
			AUDIT_SDEV_UNLOCK(asdev);
			AUDIT_SDEV_SX_XUNLOCK(asdev);
			<span class="enscript-keyword">return</span> (EAGAIN);
		}
		error = cv_wait_sig(&amp;asdev-&gt;asdev_cv, AUDIT_SDEV_MTX(asdev));
		<span class="enscript-keyword">if</span> (error) {
			AUDIT_SDEV_UNLOCK(asdev);
			AUDIT_SDEV_SX_XUNLOCK(asdev);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/*
	 * Copy as many remaining bytes from the current record to userspace
	 * as we can. Keep processing records until we run out of records in
	 * the queue or until the user buffer runs out of space.
	 *
	 * We rely on the sleep lock to maintain ase's stability here.
	 */</span>
	asdev-&gt;asdev_reads++;
	<span class="enscript-keyword">while</span> ((ase = TAILQ_FIRST(&amp;asdev-&gt;asdev_queue)) != NULL &amp;&amp;
	    uio_resid(uio) &gt; 0) {
		AUDIT_SDEV_LOCK_ASSERT(asdev);

		KASSERT(ase-&gt;ase_record_len &gt; asdev-&gt;asdev_qoffset,
		    (<span class="enscript-string">&quot;audit_sdev_read: record_len &gt; qoffset (1)&quot;</span>));
		toread = MIN((<span class="enscript-type">int</span>)(ase-&gt;ase_record_len - asdev-&gt;asdev_qoffset),
		    uio_resid(uio));
		AUDIT_SDEV_UNLOCK(asdev);
		error = uiomove((<span class="enscript-type">char</span> *) ase-&gt;ase_record + asdev-&gt;asdev_qoffset,
		    toread, uio);
		<span class="enscript-keyword">if</span> (error) {
			AUDIT_SDEV_SX_XUNLOCK(asdev);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/*
		 * If the copy succeeded then update book-keeping, and if no
		 * bytes remain in the current record then free it.
		 */</span>
		AUDIT_SDEV_LOCK(asdev);
		KASSERT(TAILQ_FIRST(&amp;asdev-&gt;asdev_queue) == ase,
		    (<span class="enscript-string">&quot;audit_sdev_read: queue out of sync after uiomove&quot;</span>));
		asdev-&gt;asdev_qoffset += toread;
		KASSERT(ase-&gt;ase_record_len &gt;= asdev-&gt;asdev_qoffset,
		     (<span class="enscript-string">&quot;audit_sdev_read: record_len &gt;= qoffset (2)&quot;</span>));
		 <span class="enscript-keyword">if</span> (asdev-&gt;asdev_qoffset == ase-&gt;ase_record_len) {
			 TAILQ_REMOVE(&amp;asdev-&gt;asdev_queue, ase, ase_queue);
			 asdev-&gt;asdev_qbyteslen -= ase-&gt;ase_record_len;
			 audit_sdev_entry_free(ase);
			 asdev-&gt;asdev_qlen--;
			 asdev-&gt;asdev_qoffset = 0;
		 }
	}
	AUDIT_SDEV_UNLOCK(asdev);
	AUDIT_SDEV_SX_XUNLOCK(asdev);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Audit session device poll method.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_poll</span>(dev_t dev, <span class="enscript-type">int</span> events, <span class="enscript-type">void</span> *wql, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> audit_sdev *asdev;
	<span class="enscript-type">int</span> revents;

	revents = 0;
	asdev = audit_sdev_dtab[minor(dev)];
	KASSERT(NULL != asdev, (<span class="enscript-string">&quot;audit_sdev_poll: asdev == NULL&quot;</span>));

	<span class="enscript-keyword">if</span> (events &amp; (POLLIN | POLLRDNORM)) {
		AUDIT_SDEV_LOCK(asdev);
		<span class="enscript-keyword">if</span> (NULL != TAILQ_FIRST(&amp;asdev-&gt;asdev_queue))
			revents |= events &amp; (POLLIN | POLLRDNORM);
		<span class="enscript-keyword">else</span>
			selrecord(p, &amp;asdev-&gt;asdev_selinfo, wql);
		AUDIT_SDEV_UNLOCK(asdev);
	}
	<span class="enscript-keyword">return</span> (revents);
}

<span class="enscript-comment">/*
 * Audit sdev clone routine.  Provides a new minor number or returns -1.
 * This called with DEVFS_LOCK held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_clone</span>(__unused dev_t dev, <span class="enscript-type">int</span> action)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (DEVFS_CLONE_ALLOC == action) {
		<span class="enscript-keyword">for</span>(i = 0; i &lt; MAX_AUDIT_SDEVS; i++)
			<span class="enscript-keyword">if</span> (NULL == audit_sdev_dtab[i])
				<span class="enscript-keyword">return</span> (i);

		<span class="enscript-comment">/* 
		 * This really should return -1 here but that seems to
		 * hang things in devfs.  We instead return 0 and let
		 * audit_sdev_open tell userland the bad news.
		 */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sdev_init</span>(<span class="enscript-type">void</span>)
{
	dev_t dev;

	TAILQ_INIT(&amp;audit_sdev_list);
	AUDIT_SDEV_LIST_LOCK_INIT();

	audit_sdev_major = cdevsw_add(-1, &amp;audit_sdev_cdevsw);
	<span class="enscript-keyword">if</span> (audit_sdev_major &lt; 0)
		<span class="enscript-keyword">return</span> (KERN_FAILURE);

	dev = makedev(audit_sdev_major, 0);
	devnode = devfs_make_node_clone(dev, DEVFS_CHAR, UID_ROOT, GID_WHEEL,
	    0644, audit_sdev_clone, AUDIT_SDEV_NAME, 0);

	<span class="enscript-keyword">if</span> (NULL == devnode)
		<span class="enscript-keyword">return</span> (KERN_FAILURE);

	<span class="enscript-keyword">return</span> (KERN_SUCCESS);
}

<span class="enscript-comment">/* XXXss
static int
audit_sdev_shutdown(void)
{

	devfs_remove(devnode);
	(void) cdevsw_remove(audit_sdev_major, &amp;audit_sdev_cdevsw);

	return (KERN_SUCCESS);
}
*/</span>

#<span class="enscript-reference">else</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_self</span>(proc_t p, <span class="enscript-type">struct</span> audit_session_self_args *uap,
    mach_port_name_t *ret_port)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">ret_port</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_join</span>(proc_t p, <span class="enscript-type">struct</span> audit_session_join_args *uap,
    au_asid_t *ret_asid)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">ret_asid</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_session_port</span>(proc_t p, <span class="enscript-type">struct</span> audit_session_port_args *uap, <span class="enscript-type">int</span> *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>