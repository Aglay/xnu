<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_worker.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_worker.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 1999-2011 Apple Inc.
 * Copyright (c) 2006-2008 Robert N. M. Watson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/un.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/audit_triggers_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>

<span class="enscript-comment">/*
 * Worker thread that will schedule disk I/O, etc.
 */</span>
<span class="enscript-type">static</span> thread_t audit_thread;

<span class="enscript-comment">/*
 * audit_ctx and audit_vp are the stored credential and vnode to use for
 * active audit trail.  They are protected by audit_worker_sl, which will be
 * held across all I/O and all rotation to prevent them from being replaced
 * (rotated) while in use.  The audit_file_rotate_wait flag is set when the
 * kernel has delivered a trigger to auditd to rotate the trail, and is
 * cleared when the next rotation takes place.  It is also protected by
 * audit_worker_sl.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			audit_file_rotate_wait;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> slck 		audit_worker_sl;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vfs_context	audit_ctx;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnode		*audit_vp;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_WORKER_SX_INIT</span>()		slck_init(&amp;audit_worker_sl, 	\
    					    <span class="enscript-string">&quot;audit_worker_sl&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_WORKER_SX_XLOCK</span>()		slck_lock(&amp;audit_worker_sl)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_WORKER_SX_XUNLOCK</span>()	slck_unlock(&amp;audit_worker_sl)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_WORKER_SX_ASSERT</span>()	slck_assert(&amp;audit_worker_sl, SL_OWNED)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_WORKER_SX_DESTROY</span>()	slck_destroy(&amp;audit_worker_sl)

<span class="enscript-comment">/*
 * The audit_q_draining flag is set when audit is disabled and the audit
 * worker queue is being drained.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>			audit_q_draining;

<span class="enscript-comment">/*
 * The special kernel audit record, audit_drain_kar, is used to mark the end of
 * the queue when draining it.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kaudit_record 	audit_drain_kar = {
	.k_ar = {
		.ar_event = AUE_NULL,
	},
	.k_ar_commit = AR_DRAIN_QUEUE,
};

<span class="enscript-comment">/*
 * Write an audit record to a file, performed as the last stage after both
 * preselection and BSM conversion.  Both space management and write failures
 * are handled in this function.
 *
 * No attempt is made to deal with possible failure to deliver a trigger to
 * the audit daemon, since the message is asynchronous anyway.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_record_write</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> vfs_context *ctx, <span class="enscript-type">void</span> *data,
    size_t len)
{
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval last_lowspace_trigger;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval last_fail;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> cur_lowspace_trigger;
	<span class="enscript-type">struct</span> vfsstatfs *mnt_stat;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> cur_fail;
	uint64_t temp;
	off_t file_size;

	AUDIT_WORKER_SX_ASSERT();	<span class="enscript-comment">/* audit_file_rotate_wait. */</span>

	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (vnode_getwithref(vp))
		<span class="enscript-keyword">return</span> <span class="enscript-comment">/*(ENOENT)*/</span>;

	mnt_stat = &amp;vp-&gt;v_mount-&gt;mnt_vfsstat;

	<span class="enscript-comment">/*
	 * First, gather statistics on the audit log file and file system so
	 * that we know how we're doing on space.  Consider failure of these
	 * operations to indicate a future inability to write to the file.
	 */</span>
	error = vfs_update_vfsstat(vp-&gt;v_mount, ctx, VFS_KERNEL_EVENT);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	error = vnode_size(vp, &amp;file_size, ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	audit_fstat.af_currsz = (u_quad_t)file_size;

	<span class="enscript-comment">/*
	 * We handle four different space-related limits:
	 *
	 * - A fixed (hard) limit on the minimum free blocks we require on
	 *   the file system, and results in record loss, a trigger, and
	 *   possible fail stop due to violating invariants.
	 *
	 * - An administrative (soft) limit, which when fallen below, results
	 *   in the kernel notifying the audit daemon of low space.
	 *
	 * - An audit trail size limit, which when gone above, results in the
	 *   kernel notifying the audit daemon that rotation is desired.
	 *
	 * - The total depth of the kernel audit record exceeding free space,
	 *   which can lead to possible fail stop (with drain), in order to
	 *   prevent violating invariants.  Failure here doesn't halt
	 *   immediately, but prevents new records from being generated.
	 *
	 * Possibly, the last of these should be handled differently, always
	 * allowing a full queue to be lost, rather than trying to prevent
	 * loss.
	 *
	 * First, handle the hard limit, which generates a trigger and may
	 * fail stop.  This is handled in the same manner as ENOSPC from
	 * VOP_WRITE, and results in record loss.
	 */</span>
	<span class="enscript-keyword">if</span> (mnt_stat-&gt;f_bfree &lt; AUDIT_HARD_LIMIT_FREE_BLOCKS) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail_enospc</span>;
	}

	<span class="enscript-comment">/*
	 * Second, handle falling below the soft limit, if defined; we send
	 * the daemon a trigger and continue processing the record.  Triggers
	 * are limited to 1/sec.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_qctrl.aq_minfree != 0) {
		temp = mnt_stat-&gt;f_blocks / (100 / audit_qctrl.aq_minfree);
		<span class="enscript-keyword">if</span> (mnt_stat-&gt;f_bfree &lt; temp &amp;&amp;
		    ppsratecheck(&amp;last_lowspace_trigger,
		    &amp;cur_lowspace_trigger, 1))
				(<span class="enscript-type">void</span>)audit_send_trigger(
				    AUDIT_TRIGGER_LOW_SPACE);
	}

	<span class="enscript-comment">/*
	 * If the current file is getting full, generate a rotation trigger
	 * to the daemon.  This is only approximate, which is fine as more
	 * records may be generated before the daemon rotates the file.
	 */</span>
	<span class="enscript-keyword">if</span> ((audit_fstat.af_filesz != 0) &amp;&amp; (audit_file_rotate_wait == 0) &amp;&amp;
	    ((u_quad_t)file_size &gt;= audit_fstat.af_filesz)) {
		AUDIT_WORKER_SX_ASSERT();

		audit_file_rotate_wait = 1;
		(<span class="enscript-type">void</span>)audit_send_trigger(AUDIT_TRIGGER_ROTATE_KERNEL);
	}

	<span class="enscript-comment">/*
	 * If the estimated amount of audit data in the audit event queue
	 * (plus records allocated but not yet queued) has reached the amount
	 * of free space on the disk, then we need to go into an audit fail
	 * stop state, in which we do not permit the allocation/committing of
	 * any new audit records.  We continue to process records but don't
	 * allow any activities that might generate new records.  In the
	 * future, we might want to detect when space is available again and
	 * allow operation to continue, but this behavior is sufficient to
	 * meet fail stop requirements in CAPP.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_fail_stop) {
		<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)((audit_q_len + audit_pre_q_len + 1) *
		    MAX_AUDIT_RECORD_SIZE) / mnt_stat-&gt;f_bsize &gt;=
		    (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)(mnt_stat-&gt;f_bfree)) {
			<span class="enscript-keyword">if</span> (ppsratecheck(&amp;last_fail, &amp;cur_fail, 1))
				printf(<span class="enscript-string">&quot;audit_record_write: free space &quot;</span>
				    <span class="enscript-string">&quot;below size of audit queue, failing &quot;</span>
				    <span class="enscript-string">&quot;stop\n&quot;</span>);
			audit_in_failure = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (audit_in_failure) {
			<span class="enscript-comment">/*
			 * Note: if we want to handle recovery, this is the
			 * spot to do it: unset audit_in_failure, and issue a
			 * wakeup on the cv.
			 */</span>
		}
	}

	error = vn_rdwr(UIO_WRITE, vp, data, len, (off_t)0, UIO_SYSSPACE,
	    IO_APPEND|IO_UNIT, vfs_context_ucred(ctx), NULL,
	    vfs_context_proc(ctx));
	<span class="enscript-keyword">if</span> (error == ENOSPC)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail_enospc</span>;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/*
	 * Catch completion of a queue drain here; if we're draining and the
	 * queue is now empty, fail stop.  That audit_fail_stop is implicitly
	 * true, since audit_in_failure can only be set of audit_fail_stop is
	 * set.
	 *
	 * Note: if we handle recovery from audit_in_failure, then we need to
	 * make panic here conditional.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_in_failure) {
		<span class="enscript-keyword">if</span> (audit_q_len == 0 &amp;&amp; audit_pre_q_len == 0) {
			(<span class="enscript-type">void</span>)VNOP_FSYNC(vp, MNT_WAIT, ctx);
			panic(<span class="enscript-string">&quot;Audit store overflow; record queue drained.&quot;</span>);
		}
	}

	vnode_put(vp);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail_enospc</span>:
	<span class="enscript-comment">/*
	 * ENOSPC is considered a special case with respect to failures, as
	 * this can reflect either our preemptive detection of insufficient
	 * space, or ENOSPC returned by the vnode write call.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_fail_stop) {
		(<span class="enscript-type">void</span>)VNOP_FSYNC(vp, MNT_WAIT, ctx);
		panic(<span class="enscript-string">&quot;Audit log space exhausted and fail-stop set.&quot;</span>);
	}
	(<span class="enscript-type">void</span>)audit_send_trigger(AUDIT_TRIGGER_NO_SPACE);
	audit_suspended = 1;

	<span class="enscript-comment">/* FALLTHROUGH */</span>
<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">/*
	 * We have failed to write to the file, so the current record is
	 * lost, which may require an immediate system halt.
	 */</span>
	<span class="enscript-keyword">if</span> (audit_panic_on_write_fail) {
		(<span class="enscript-type">void</span>)VNOP_FSYNC(vp, MNT_WAIT, ctx);
		panic(<span class="enscript-string">&quot;audit_worker: write error %d\n&quot;</span>, error);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ppsratecheck(&amp;last_fail, &amp;cur_fail, 1))
		printf(<span class="enscript-string">&quot;audit_worker: write error %d\n&quot;</span>, error);
	vnode_put(vp);
}

<span class="enscript-comment">/*
 * Given a kernel audit record, process as required.  Kernel audit records
 * are converted to one, or possibly two, BSM records, depending on whether
 * there is a user audit record present also.  Kernel records need be
 * converted to BSM before they can be written out.  Both types will be
 * written to disk, and audit pipes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_worker_process_record</span>(<span class="enscript-type">struct</span> kaudit_record *ar)
{
	<span class="enscript-type">struct</span> au_record *bsm;
	au_class_t class;
	au_event_t event;
	au_id_t auid;
	<span class="enscript-type">int</span> error, sorf;
	<span class="enscript-type">int</span> trail_locked;

	<span class="enscript-comment">/*
	 * We hold the audit_worker_sl lock over both writes, if there are
	 * two, so that the two records won't be split across a rotation and
	 * end up in two different trail files.
	 */</span>
	<span class="enscript-keyword">if</span> (((ar-&gt;k_ar_commit &amp; AR_COMMIT_USER) &amp;&amp;
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_USER_TRAIL)) ||
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_TRAIL)) {
		AUDIT_WORKER_SX_XLOCK();
		trail_locked = 1;
	} <span class="enscript-keyword">else</span>
		trail_locked = 0;

	<span class="enscript-comment">/*
	 * First, handle the user record, if any: commit to the system trail
	 * and audit pipes as selected.
	 */</span>
	<span class="enscript-keyword">if</span> ((ar-&gt;k_ar_commit &amp; AR_COMMIT_USER) &amp;&amp;
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_USER_TRAIL)) {
		AUDIT_WORKER_SX_ASSERT();
		audit_record_write(audit_vp, &amp;audit_ctx, ar-&gt;k_udata,
		    ar-&gt;k_ulen);
	}

	<span class="enscript-keyword">if</span> ((ar-&gt;k_ar_commit &amp; AR_COMMIT_USER) &amp;&amp;
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_USER_PIPE))
		audit_pipe_submit_user(ar-&gt;k_udata, ar-&gt;k_ulen);

	<span class="enscript-keyword">if</span> (!(ar-&gt;k_ar_commit &amp; AR_COMMIT_KERNEL) ||
	    ((ar-&gt;k_ar_commit &amp; AR_PRESELECT_PIPE) == 0 &amp;&amp;
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_TRAIL) == 0 &amp;&amp;
	    (ar-&gt;k_ar_commit &amp; AR_PRESELECT_FILTER) == 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	auid = ar-&gt;k_ar.ar_subj_auid;
	event = ar-&gt;k_ar.ar_event;
	class = au_event_class(event);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_errno == 0)
		sorf = AU_PRS_SUCCESS;
	<span class="enscript-keyword">else</span>
		sorf = AU_PRS_FAILURE;

	error = kaudit_to_bsm(ar, &amp;bsm);
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSM_NOAUDIT</span>:
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSM_FAILURE</span>:
		printf(<span class="enscript-string">&quot;audit_worker_process_record: BSM_FAILURE\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">BSM_SUCCESS</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;kaudit_to_bsm returned %d&quot;</span>, error);
	}

	<span class="enscript-keyword">if</span> (ar-&gt;k_ar_commit &amp; AR_PRESELECT_TRAIL) {
		AUDIT_WORKER_SX_ASSERT();
		audit_record_write(audit_vp, &amp;audit_ctx, bsm-&gt;data, bsm-&gt;len);
	}

	<span class="enscript-keyword">if</span> (ar-&gt;k_ar_commit &amp; AR_PRESELECT_PIPE)
		audit_pipe_submit(auid, event, class, sorf,
		    ar-&gt;k_ar_commit &amp; AR_PRESELECT_TRAIL, bsm-&gt;data,
		    bsm-&gt;len);

	<span class="enscript-keyword">if</span> (ar-&gt;k_ar_commit &amp; AR_PRESELECT_FILTER) {

		<span class="enscript-comment">/*
		 *  XXXss - This needs to be generalized so new filters can
		 *  be easily plugged in.
		 */</span>
		audit_sdev_submit(auid, ar-&gt;k_ar.ar_subj_asid, bsm-&gt;data,
		    bsm-&gt;len);
	}

	kau_free(bsm);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (trail_locked)
		AUDIT_WORKER_SX_XUNLOCK();
}

<span class="enscript-comment">/*
 * The audit_worker thread is responsible for watching the event queue,
 * dequeueing records, converting them to BSM format, and committing them to
 * disk.  In order to minimize lock thrashing, records are dequeued in sets
 * to a thread-local work queue.
 *
 * Note: this means that the effect bound on the size of the pending record
 * queue is 2x the length of the global queue.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_worker</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> kaudit_queue ar_worklist;
	<span class="enscript-type">struct</span> kaudit_record *ar;
	<span class="enscript-type">int</span> lowater_signal;

	<span class="enscript-keyword">if</span> (audit_ctx.vc_thread == NULL)
		audit_ctx.vc_thread = current_thread();

	TAILQ_INIT(&amp;ar_worklist);
	mtx_lock(&amp;audit_mtx);
	<span class="enscript-keyword">while</span> (1) {
		mtx_assert(&amp;audit_mtx, MA_OWNED);

		<span class="enscript-comment">/*
		 * Wait for a record.
		 */</span>
		<span class="enscript-keyword">while</span> (TAILQ_EMPTY(&amp;audit_q))
			cv_wait_continuation(&amp;audit_worker_cv, &amp;audit_mtx,
			    (thread_continue_t)audit_worker);

		<span class="enscript-comment">/*
		 * If there are records in the global audit record queue,
		 * transfer them to a thread-local queue and process them
		 * one by one.  If we cross the low watermark threshold,
		 * signal any waiting processes that they may wake up and
		 * continue generating records.
		 */</span>
		lowater_signal = 0;
		<span class="enscript-keyword">while</span> ((ar = TAILQ_FIRST(&amp;audit_q))) {
			TAILQ_REMOVE(&amp;audit_q, ar, k_q);
			audit_q_len--;
			<span class="enscript-keyword">if</span> (audit_q_len == audit_qctrl.aq_lowater)
				lowater_signal++;
			TAILQ_INSERT_TAIL(&amp;ar_worklist, ar, k_q);
		}
		<span class="enscript-keyword">if</span> (lowater_signal)
			cv_broadcast(&amp;audit_watermark_cv);

		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">while</span> ((ar = TAILQ_FIRST(&amp;ar_worklist))) {
			TAILQ_REMOVE(&amp;ar_worklist, ar, k_q);
			<span class="enscript-keyword">if</span> (ar-&gt;k_ar_commit &amp; AR_DRAIN_QUEUE) {
				audit_q_draining = 0;
				cv_broadcast(&amp;audit_drain_cv);
			} <span class="enscript-keyword">else</span> {
				audit_worker_process_record(ar);
				audit_free(ar);
			}
		}
		mtx_lock(&amp;audit_mtx);
	}
}

<span class="enscript-comment">/*
 * audit_rotate_vnode() is called by a user or kernel thread to configure or
 * de-configure auditing on a vnode.  The arguments are the replacement
 * credential (referenced) and vnode (referenced and opened) to substitute
 * for the current credential and vnode, if any.  If either is set to NULL,
 * both should be NULL, and this is used to indicate that audit is being
 * disabled.  Any previous cred/vnode will be closed and freed.  We re-enable
 * generating rotation requests to auditd.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_rotate_vnode</span>(kauth_cred_t cred, <span class="enscript-type">struct</span> vnode *vp)
{
	kauth_cred_t old_audit_cred;
	<span class="enscript-type">struct</span> vnode *old_audit_vp;

	KASSERT((cred != NULL &amp;&amp; vp != NULL) || (cred == NULL &amp;&amp; vp == NULL),
	    (<span class="enscript-string">&quot;audit_rotate_vnode: cred %p vp %p&quot;</span>, cred, vp));


	mtx_lock(&amp;audit_mtx);
	<span class="enscript-keyword">if</span> (audit_enabled &amp;&amp; (NULL == vp)) {
		<span class="enscript-comment">/* Auditing is currently enabled but will be disabled. */</span>

		<span class="enscript-comment">/*
		 * Disable auditing now so nothing more is added while the
		 * audit worker thread is draining the audit record queue.
		 */</span>
		audit_enabled = 0;

		<span class="enscript-comment">/*
		 * Drain the auditing queue by inserting a drain record at the
		 * end of the queue and waiting for the audit worker thread
		 * to find this record and signal that it is done before
		 * we close the audit trail.
		 */</span>
		audit_q_draining = 1;
		<span class="enscript-keyword">while</span> (audit_q_len &gt;= audit_qctrl.aq_hiwater)
			cv_wait(&amp;audit_watermark_cv, &amp;audit_mtx);
		TAILQ_INSERT_TAIL(&amp;audit_q, &amp;audit_drain_kar, k_q);
		audit_q_len++;
		cv_signal(&amp;audit_worker_cv);
	}

	<span class="enscript-comment">/* If the audit queue is draining then wait here until it's done. */</span>
	<span class="enscript-keyword">while</span> (audit_q_draining)
		cv_wait(&amp;audit_drain_cv, &amp;audit_mtx);
	mtx_unlock(&amp;audit_mtx);


	<span class="enscript-comment">/*
	 * Rotate the vnode/cred, and clear the rotate flag so that we will
	 * send a rotate trigger if the new file fills.
	 */</span>
	AUDIT_WORKER_SX_XLOCK();
	old_audit_cred = audit_ctx.vc_ucred;
	old_audit_vp = audit_vp;
	audit_ctx.vc_ucred = cred;
	audit_vp = vp;
	audit_file_rotate_wait = 0;
	audit_enabled = (audit_vp != NULL);
	AUDIT_WORKER_SX_XUNLOCK();

	<span class="enscript-comment">/*
	 * If there was an old vnode/credential, close and free.
	 */</span>
	<span class="enscript-keyword">if</span> (old_audit_vp != NULL) {
		<span class="enscript-keyword">if</span> (vnode_get(old_audit_vp) == 0) {
			vn_close(old_audit_vp, AUDIT_CLOSE_FLAGS,
			    vfs_context_kernel());
			vnode_put(old_audit_vp);
		} <span class="enscript-keyword">else</span>
			printf(<span class="enscript-string">&quot;audit_rotate_vnode: Couldn't close &quot;</span>
			    <span class="enscript-string">&quot;audit file.\n&quot;</span>);
		kauth_cred_unref(&amp;old_audit_cred);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_worker_init</span>(<span class="enscript-type">void</span>)
{

	AUDIT_WORKER_SX_INIT();
	kernel_thread_start((thread_continue_t)audit_worker, NULL,
	    &amp;audit_thread);
	<span class="enscript-keyword">if</span> (audit_thread == THREAD_NULL)
		panic(<span class="enscript-string">&quot;audit_worker_init: Couldn't create audit_worker thread&quot;</span>);
}
</pre>
<hr />
</body></html>