<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_syscalls.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_syscalls.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 1999-2010, Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/un.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/audit_triggers_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_record.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_policy.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IS_NOT_VALID_PID</span>(p)	((p) &lt; 1 || (p) &gt; PID_MAX)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">AUDIT_API_WARNINGS</span>
<span class="enscript-comment">/*
 * Macro to warn about auditinfo_addr_t/auditpinfo_addr_t changing sizes
 * to encourage the userland code to be recompiled and updated.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">WARN_IF_AINFO_ADDR_CHANGED</span>(sz1, sz2, scall, tp) do {		\
	<span class="enscript-keyword">if</span> ((size_t)(sz1) != (size_t)(sz2)) {				\
		<span class="enscript-type">char</span> pn[MAXCOMLEN + 1];					\
									\
		proc_selfname(pn, MAXCOMLEN + 1);			\
		printf(<span class="enscript-string">&quot;Size of %s used by %s in %s is different from &quot;</span> \
		    <span class="enscript-string">&quot;kernel's.  Please recompile %s.\n&quot;</span>, (tp),	 	\
		    (scall), pn, pn);					\
	}								\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Macro to warn about using ASID's outside the range [1 to PID_MAX] to 
 * encourage userland code changes.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">WARN_IF_BAD_ASID</span>(asid, scall) do {				\
	<span class="enscript-keyword">if</span> (((asid) &lt; 1 || (asid) &gt; PID_MAX) &amp;&amp;				\
	     (asid) != AU_ASSIGN_ASID) {				\
		<span class="enscript-type">char</span> pn[MAXCOMLEN + 1];					\
									\
		proc_selfname(pn, MAXCOMLEN + 1);			\
		printf(<span class="enscript-string">&quot;%s in %s is using an ASID (%u) outside the &quot;</span>	\
		    <span class="enscript-string">&quot;range [1 to %d].  Please change %s to use an ASID &quot;</span>\
		    <span class="enscript-string">&quot;within this range or use AU_ASSIGN_ASID.\n&quot;</span>,	\
		    (scall), pn, (uint32_t)(asid), PID_MAX, pn);	\
	}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* ! AUDIT_API_WARNINGS */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">WARN_IF_AINFO_ADDR_CHANGED</span>(sz1, sz2, scall, tp) do {		\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">WARN_IF_BAD_ASID</span>(asid, scall) do {				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* AUDIT_API_WARNINGS */</span>

<span class="enscript-comment">/*
 * System call to allow a user space application to submit a BSM audit record
 * to the kernel for inclusion in the audit log.  This function does little
 * verification on the audit record that is submitted.
 *
 * XXXAUDIT: Audit preselection for user records does not currently work,
 * since we pre-select only based on the AUE_audit event type, not the event
 * type submitted as part of the user audit data.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">audit</span>(proc_t p, <span class="enscript-type">struct</span> audit_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">void</span> * rec;
	<span class="enscript-type">struct</span> kaudit_record *ar;
	<span class="enscript-type">struct</span> uthread *uthr;

	error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	mtx_lock(&amp;audit_mtx);
	<span class="enscript-keyword">if</span> ((uap-&gt;length &lt;= 0) || (uap-&gt;length &gt; (<span class="enscript-type">int</span>)audit_qctrl.aq_bufsz)) {
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	mtx_unlock(&amp;audit_mtx);

	ar = currecord();

	<span class="enscript-comment">/*
	 * If there's no current audit record (audit() itself not audited)
	 * commit the user audit record.
	 */</span>
	<span class="enscript-keyword">if</span> (ar == NULL) {
		uthr = curthread();
		<span class="enscript-keyword">if</span> (uthr == NULL)	<span class="enscript-comment">/* can this happen? */</span>
			<span class="enscript-keyword">return</span> (ENOTSUP);

		<span class="enscript-comment">/*
		 * This is not very efficient; we're required to allocate a
		 * complete kernel audit record just so the user record can
		 * tag along.
		 */</span>
		uthr-&gt;uu_ar = audit_new(AUE_NULL, p, uthr);
		<span class="enscript-keyword">if</span> (uthr-&gt;uu_ar == NULL)
			<span class="enscript-keyword">return</span> (ENOTSUP);
		ar = uthr-&gt;uu_ar;
	}

	<span class="enscript-keyword">if</span> (uap-&gt;length &gt; MAX_AUDIT_RECORD_SIZE)
		<span class="enscript-keyword">return</span> (EINVAL);

	rec = malloc(uap-&gt;length, M_AUDITDATA, M_WAITOK);

	error = copyin(uap-&gt;record, rec, uap-&gt;length);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_out</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_system_check_audit(kauth_cred_get(), rec, uap-&gt;length);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Verify the record. */</span>
	<span class="enscript-keyword">if</span> (bsm_rec_verify(rec) == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_out</span>;
	}

	<span class="enscript-comment">/*
	 * Attach the user audit record to the kernel audit record.  Because
	 * this system call is an auditable event, we will write the user
	 * record along with the record for this audit event.
	 *
	 * XXXAUDIT: KASSERT appropriate starting values of k_udata, k_ulen,
	 * k_ar_commit &amp; AR_COMMIT_USER?
	 */</span>
	ar-&gt;k_udata = rec;
	ar-&gt;k_ulen  = uap-&gt;length;
	ar-&gt;k_ar_commit |= AR_COMMIT_USER;

	<span class="enscript-comment">/*
	 * Currently we assume that all preselection has been performed in
	 * userspace.  We unconditionally set these masks so that the records
	 * get committed both to the trail and pipe.  In the future we will
	 * want to setup kernel based preselection.
	 */</span>
	ar-&gt;k_ar_commit |= (AR_PRESELECT_USER_TRAIL | AR_PRESELECT_USER_PIPE);
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">free_out</span>:
	<span class="enscript-comment">/*
	 * audit_syscall_exit() will free the audit record on the thread even
	 * if we allocated it above.
	 */</span>
	free(rec, M_AUDITDATA);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 *  System call to manipulate auditing.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">auditon</span>(proc_t p, <span class="enscript-type">struct</span> auditon_args *uap, __unused int32_t *retval)
{
	kauth_cred_t scred;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">union</span> auditon_udata udata;
	proc_t tp = PROC_NULL;
	<span class="enscript-type">struct</span> auditinfo_addr aia;

	AUDIT_ARG(cmd, uap-&gt;cmd);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_system_check_auditon(kauth_cred_get(), uap-&gt;cmd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((uap-&gt;length &lt;= 0) || (uap-&gt;length &gt;
	    (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">union</span> auditon_udata)))
		<span class="enscript-keyword">return</span> (EINVAL);

	memset((<span class="enscript-type">void</span> *)&amp;udata, 0, <span class="enscript-keyword">sizeof</span>(udata));

	<span class="enscript-comment">/*
	 * Some of the GET commands use the arguments too.
	 */</span>
	<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSTAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETUMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCLASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETFSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKAUDIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCLASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO_ADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SENDTRIGGER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSINFO_ADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSFLAGS</span>:
		error = copyin(uap-&gt;data, (<span class="enscript-type">void</span> *)&amp;udata, uap-&gt;length);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		AUDIT_ARG(auditon, &amp;udata);
		AUDIT_ARG(len, uap-&gt;length);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Check appropriate privilege. */</span>
	<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
	<span class="enscript-comment">/*
	 * A_GETSINFO doesn't require priviledge but only superuser  
	 * gets to see the audit masks. 
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSINFO_ADDR</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_kau_info) != uap-&gt;length) ||
	   		(audit_session_lookup(udata.au_kau_info.ai_asid,
					      &amp;udata.au_kau_info) != 0))
			error = EINVAL;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			udata.au_kau_info.ai_mask.am_success = ~0;
			udata.au_kau_info.ai_mask.am_failure = ~0;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSFLAGS</span>:
		<span class="enscript-comment">/* Getting one's own audit session flags requires no
		 * privilege.  Setting the flags is subject to access
		 * control implemented in audit_session_setaia().
		 */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * XXX Need to implement these commands by accessing the global
	 * values associated with the commands.
	 */</span>
	<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPOLICY</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_policy64) == uap-&gt;length) {
			mtx_lock(&amp;audit_mtx);
			<span class="enscript-keyword">if</span> (!audit_fail_stop)
				udata.au_policy64 |= AUDIT_CNT;
			<span class="enscript-keyword">if</span> (audit_panic_on_write_fail)
				udata.au_policy64 |= AUDIT_AHLT;
			<span class="enscript-keyword">if</span> (audit_argv)
				udata.au_policy64 |= AUDIT_ARGV;
			<span class="enscript-keyword">if</span> (audit_arge)
				udata.au_policy64 |= AUDIT_ARGE;
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_policy) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		<span class="enscript-keyword">if</span> (!audit_fail_stop)
			udata.au_policy |= AUDIT_CNT;
		<span class="enscript-keyword">if</span> (audit_panic_on_write_fail)
			udata.au_policy |= AUDIT_AHLT;
		<span class="enscript-keyword">if</span> (audit_argv)
			udata.au_policy |= AUDIT_ARGV;
		<span class="enscript-keyword">if</span> (audit_arge)
			udata.au_policy |= AUDIT_ARGE;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPOLICY</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_policy64) == uap-&gt;length) {
			<span class="enscript-keyword">if</span> (udata.au_policy64 &amp; ~(AUDIT_CNT|AUDIT_AHLT|
				AUDIT_ARGV|AUDIT_ARGE))
				<span class="enscript-keyword">return</span> (EINVAL);
			mtx_lock(&amp;audit_mtx);
			audit_fail_stop = ((udata.au_policy64 &amp; AUDIT_CNT) ==
			    0);
			audit_panic_on_write_fail = (udata.au_policy64 &amp;
			    AUDIT_AHLT);
			audit_argv = (udata.au_policy64 &amp; AUDIT_ARGV);
			audit_arge = (udata.au_policy64 &amp; AUDIT_ARGE);
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		}	
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_policy) != uap-&gt;length) ||
		    (udata.au_policy &amp; ~(AUDIT_CNT|AUDIT_AHLT|AUDIT_ARGV|
					 AUDIT_ARGE)))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-comment">/*
		 * XXX - Need to wake up waiters if the policy relaxes?
		 */</span>
		mtx_lock(&amp;audit_mtx);
		audit_fail_stop = ((udata.au_policy &amp; AUDIT_CNT) == 0);
		audit_panic_on_write_fail = (udata.au_policy &amp; AUDIT_AHLT);
		audit_argv = (udata.au_policy &amp; AUDIT_ARGV);
		audit_arge = (udata.au_policy &amp; AUDIT_ARGE);
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKMASK</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_mask) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		udata.au_mask = audit_nae_mask;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKMASK</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_mask) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		audit_nae_mask = udata.au_mask;
		AUDIT_CHECK_IF_KEVENTS_MASK(audit_nae_mask);
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETQCTRL</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_qctrl64) == uap-&gt;length) {
			mtx_lock(&amp;audit_mtx);
			udata.au_qctrl64.aq64_hiwater =
			    (u_int64_t)audit_qctrl.aq_hiwater;
			udata.au_qctrl64.aq64_lowater =
			    (u_int64_t)audit_qctrl.aq_lowater;
			udata.au_qctrl64.aq64_bufsz =
			    (u_int64_t)audit_qctrl.aq_bufsz;
			udata.au_qctrl64.aq64_delay =
			    (u_int64_t)audit_qctrl.aq_delay;
			udata.au_qctrl64.aq64_minfree = 
			    (int64_t)audit_qctrl.aq_minfree;
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		} 
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_qctrl) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		udata.au_qctrl = audit_qctrl;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETQCTRL</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_qctrl64) == uap-&gt;length) {
			 <span class="enscript-keyword">if</span> ((udata.au_qctrl64.aq64_hiwater &gt; AQ_MAXHIGH) ||
			     (udata.au_qctrl64.aq64_lowater &gt;= 
			      udata.au_qctrl64.aq64_hiwater) ||
			     (udata.au_qctrl64.aq64_bufsz &gt; AQ_MAXBUFSZ) ||
			     (udata.au_qctrl64.aq64_minfree &lt; 0) ||
			     (udata.au_qctrl64.aq64_minfree &gt; 100))
				<span class="enscript-keyword">return</span> (EINVAL);
			mtx_lock(&amp;audit_mtx);
			audit_qctrl.aq_hiwater =
			     (<span class="enscript-type">int</span>)udata.au_qctrl64.aq64_hiwater;
			audit_qctrl.aq_lowater =
			     (<span class="enscript-type">int</span>)udata.au_qctrl64.aq64_lowater;
			audit_qctrl.aq_bufsz =
			     (<span class="enscript-type">int</span>)udata.au_qctrl64.aq64_bufsz;
			audit_qctrl.aq_minfree = 
			    (<span class="enscript-type">int</span>)udata.au_qctrl64.aq64_minfree;
			audit_qctrl.aq_delay = -1;  <span class="enscript-comment">/* Not used. */</span>
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_qctrl) != uap-&gt;length) ||
		    (udata.au_qctrl.aq_hiwater &gt; AQ_MAXHIGH) ||
		    (udata.au_qctrl.aq_lowater &gt;= udata.au_qctrl.aq_hiwater) ||
		    (udata.au_qctrl.aq_bufsz &gt; AQ_MAXBUFSZ) ||
		    (udata.au_qctrl.aq_minfree &lt; 0) ||
		    (udata.au_qctrl.aq_minfree &gt; 100))
			<span class="enscript-keyword">return</span> (EINVAL);

		mtx_lock(&amp;audit_mtx);
		audit_qctrl = udata.au_qctrl;
		<span class="enscript-comment">/* XXX The queue delay value isn't used with the kernel. */</span>
		audit_qctrl.aq_delay = -1;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCWD</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCAR</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSTAT</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSTAT</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETUMASK</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSMASK</span>:
		<span class="enscript-keyword">return</span> (ENOSYS);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCOND</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_cond64) == uap-&gt;length) {
			mtx_lock(&amp;audit_mtx);
			<span class="enscript-keyword">if</span> (audit_enabled &amp;&amp; !audit_suspended)
				udata.au_cond64 = AUC_AUDITING;
			<span class="enscript-keyword">else</span>
				udata.au_cond64 = AUC_NOAUDIT;
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_cond) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		<span class="enscript-keyword">if</span> (audit_enabled &amp;&amp; !audit_suspended)
			udata.au_cond = AUC_AUDITING;
		<span class="enscript-keyword">else</span>
			udata.au_cond = AUC_NOAUDIT;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDSETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCOND</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_cond64) == uap-&gt;length) {
			mtx_lock(&amp;audit_mtx);
			<span class="enscript-keyword">if</span> (udata.au_cond64 == AUC_NOAUDIT)
				audit_suspended = 1;
			<span class="enscript-keyword">if</span> (udata.au_cond64 == AUC_AUDITING)
				audit_suspended = 0;
			<span class="enscript-keyword">if</span> (udata.au_cond64 == AUC_DISABLED) {
				audit_suspended = 1;
				mtx_unlock(&amp;audit_mtx);
				audit_shutdown();
				<span class="enscript-keyword">break</span>;
			}
			mtx_unlock(&amp;audit_mtx);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_cond) != uap-&gt;length) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		mtx_lock(&amp;audit_mtx);
		<span class="enscript-keyword">if</span> (udata.au_cond == AUC_NOAUDIT)
			audit_suspended = 1;
		<span class="enscript-keyword">if</span> (udata.au_cond == AUC_AUDITING)
			audit_suspended = 0;
		<span class="enscript-keyword">if</span> (udata.au_cond == AUC_DISABLED) {
			audit_suspended = 1;
			mtx_unlock(&amp;audit_mtx);
			audit_shutdown();
			<span class="enscript-keyword">break</span>;
		}
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCLASS</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_evclass) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		udata.au_evclass.ec_class = au_event_class(
		    udata.au_evclass.ec_number);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETCLASS</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_evclass) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		au_evclassmap_insert(udata.au_evclass.ec_number,
		    udata.au_evclass.ec_class);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_aupinfo) != uap-&gt;length) ||
		    IS_NOT_VALID_PID(udata.au_aupinfo.ap_pid))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((tp = proc_find(udata.au_aupinfo.ap_pid)) == NULL)
			<span class="enscript-keyword">return</span> (ESRCH);

		scred = kauth_cred_proc_ref(tp);
		<span class="enscript-keyword">if</span> (scred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_type == AU_IPv6) {
			kauth_cred_unref(&amp;scred);
			proc_rele(tp);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		
		udata.au_aupinfo.ap_auid =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
		udata.au_aupinfo.ap_mask.am_success =
		    scred-&gt;cr_audit.as_mask.am_success;
		udata.au_aupinfo.ap_mask.am_failure =
		    scred-&gt;cr_audit.as_mask.am_failure;
		udata.au_aupinfo.ap_termid.machine =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[0];
		udata.au_aupinfo.ap_termid.port =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_port;
		udata.au_aupinfo.ap_asid =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_asid;
		kauth_cred_unref(&amp;scred);
		proc_rele(tp);
		tp = PROC_NULL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETPMASK</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_aupinfo) != uap-&gt;length) ||
		    IS_NOT_VALID_PID(udata.au_aupinfo.ap_pid))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((tp = proc_find(udata.au_aupinfo.ap_pid)) == NULL)
			<span class="enscript-keyword">return</span> (ESRCH);
		scred = kauth_cred_proc_ref(tp);
		bcopy(scred-&gt;cr_audit.as_aia_p, &amp;aia, <span class="enscript-keyword">sizeof</span>(aia));
		kauth_cred_unref(&amp;scred);
		aia.ai_mask.am_success =
		    udata.au_aupinfo.ap_mask.am_success;
		aia.ai_mask.am_failure =
		    udata.au_aupinfo.ap_mask.am_failure;
		AUDIT_CHECK_IF_KEVENTS_MASK(aia.ai_mask);
		error = audit_session_setaia(tp, &amp;aia);
		proc_rele(tp);
		tp = PROC_NULL;
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETFSIZE</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_fstat) != uap-&gt;length) ||
		    ((udata.au_fstat.af_filesz != 0) &amp;&amp;
		     (udata.au_fstat.af_filesz &lt; MIN_AUDIT_FILE_SIZE)))
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		audit_fstat.af_filesz = udata.au_fstat.af_filesz;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETFSIZE</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_fstat) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		mtx_lock(&amp;audit_mtx);
		udata.au_fstat.af_filesz = audit_fstat.af_filesz;
		udata.au_fstat.af_currsz = audit_fstat.af_currsz;
		mtx_unlock(&amp;audit_mtx);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO_ADDR</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_aupinfo_addr) != uap-&gt;length) ||
		    IS_NOT_VALID_PID(udata.au_aupinfo_addr.ap_pid))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((tp = proc_find(udata.au_aupinfo.ap_pid)) == NULL)
			<span class="enscript-keyword">return</span> (ESRCH);
		WARN_IF_AINFO_ADDR_CHANGED(uap-&gt;length,
		    <span class="enscript-keyword">sizeof</span>(auditpinfo_addr_t), <span class="enscript-string">&quot;auditon(A_GETPINFO_ADDR,...)&quot;</span>,
		    <span class="enscript-string">&quot;auditpinfo_addr_t&quot;</span>);
		scred = kauth_cred_proc_ref(tp);
		udata.au_aupinfo_addr.ap_auid =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
		udata.au_aupinfo_addr.ap_asid =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_asid;
		udata.au_aupinfo_addr.ap_mask.am_success =
		    scred-&gt;cr_audit.as_mask.am_success;
		udata.au_aupinfo_addr.ap_mask.am_failure =
		    scred-&gt;cr_audit.as_mask.am_failure;
		bcopy(&amp;scred-&gt;cr_audit.as_aia_p-&gt;ai_termid, 
		    &amp;udata.au_aupinfo_addr.ap_termid,
		    <span class="enscript-keyword">sizeof</span>(au_tid_addr_t));
		udata.au_aupinfo_addr.ap_flags =
		    scred-&gt;cr_audit.as_aia_p-&gt;ai_flags;
		kauth_cred_unref(&amp;scred);
		proc_rele(tp);
		tp = PROC_NULL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKAUDIT</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_kau_info) != uap-&gt;length) 
			<span class="enscript-keyword">return</span> (EINVAL);
		audit_get_kinfo(&amp;udata.au_kau_info);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETKAUDIT</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_kau_info) != uap-&gt;length) ||
		    (udata.au_kau_info.ai_termid.at_type != AU_IPv4 &amp;&amp;
		    udata.au_kau_info.ai_termid.at_type != AU_IPv6))
			<span class="enscript-keyword">return</span> (EINVAL);
		audit_set_kinfo(&amp;udata.au_kau_info);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SENDTRIGGER</span>:
		<span class="enscript-keyword">if</span> ((<span class="enscript-keyword">sizeof</span>(udata.au_trigger) != uap-&gt;length) || 
		    (udata.au_trigger &lt; AUDIT_TRIGGER_MIN) ||
		    (udata.au_trigger &gt; AUDIT_TRIGGER_MAX))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">return</span> (audit_send_trigger(udata.au_trigger));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSINFO_ADDR</span>:
		<span class="enscript-comment">/* Handled above before switch(). */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSFLAGS</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_flags) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		bcopy(&amp;(kauth_cred_get()-&gt;cr_audit.as_aia_p-&gt;ai_flags),
		    &amp;udata.au_flags, <span class="enscript-keyword">sizeof</span>(udata.au_flags));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_SETSFLAGS</span>:
		<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(udata.au_flags) != uap-&gt;length)
			<span class="enscript-keyword">return</span> (EINVAL);
		bcopy(kauth_cred_get()-&gt;cr_audit.as_aia_p, &amp;aia, <span class="enscript-keyword">sizeof</span>(aia));
		aia.ai_flags = udata.au_flags;
		error = audit_session_setaia(p, &amp;aia);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * Copy data back to userspace for the GET comands.
	 */</span>
	<span class="enscript-keyword">switch</span> (uap-&gt;cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETPOLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKMASK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETQCTRL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCWD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCAR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSTAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_OLDGETCOND</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETCLASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETFSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETPINFO_ADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETKAUDIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSINFO_ADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">A_GETSFLAGS</span>:
		error = copyout((<span class="enscript-type">void</span> *)&amp;udata, uap-&gt;data, uap-&gt;length);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (ENOSYS);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * System calls to manage the user audit information.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getauid</span>(proc_t p, <span class="enscript-type">struct</span> getauid_args *uap, __unused int32_t *retval)
{
	au_id_t id;
	<span class="enscript-type">int</span> error;
	kauth_cred_t scred;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_getauid(p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>
	scred = kauth_cred_proc_ref(p);
	id = scred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
	kauth_cred_unref(&amp;scred);

	error = copyout((<span class="enscript-type">void</span> *)&amp;id, uap-&gt;auid, <span class="enscript-keyword">sizeof</span>(id));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setauid</span>(proc_t p, <span class="enscript-type">struct</span> setauid_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	au_id_t	id;
	kauth_cred_t scred;
	<span class="enscript-type">struct</span> auditinfo_addr aia;

	error = copyin(uap-&gt;auid, &amp;id, <span class="enscript-keyword">sizeof</span>(id));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	AUDIT_ARG(auid, id);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_setauid(p, id);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	scred = kauth_cred_proc_ref(p);
	error = suser(scred, &amp;p-&gt;p_acflag);
	<span class="enscript-keyword">if</span> (error) {
		kauth_cred_unref(&amp;scred);
		<span class="enscript-keyword">return</span> (error);
	}

	bcopy(scred-&gt;cr_audit.as_aia_p, &amp;aia, <span class="enscript-keyword">sizeof</span>(aia));
	<span class="enscript-keyword">if</span> (aia.ai_asid == AU_DEFAUDITSID) {
		aia.ai_asid = AU_ASSIGN_ASID;
	}
	bcopy(&amp;scred-&gt;cr_audit.as_mask, &amp;aia.ai_mask, <span class="enscript-keyword">sizeof</span>(au_mask_t));
	kauth_cred_unref(&amp;scred);
	aia.ai_auid = id;
	error = audit_session_setaia(p, &amp;aia);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getaudit_addr_internal</span>(proc_t p, user_addr_t user_addr, size_t length)
{
	kauth_cred_t scred;
	auditinfo_addr_t aia;

	scred = kauth_cred_proc_ref(p);
	bcopy(scred-&gt;cr_audit.as_aia_p, &amp;aia, <span class="enscript-keyword">sizeof</span> (auditinfo_addr_t));
	<span class="enscript-comment">/*
	 * Only superuser gets to see the real mask.
	 */</span>
	<span class="enscript-keyword">if</span> (suser(scred, &amp;p-&gt;p_acflag)) {
		aia.ai_mask.am_success = ~0;
		aia.ai_mask.am_failure = ~0;
	}
	kauth_cred_unref(&amp;scred);

	<span class="enscript-keyword">return</span> (copyout(&amp;aia, user_addr, min(<span class="enscript-keyword">sizeof</span>(aia), length)));
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getaudit_addr</span>(proc_t p, <span class="enscript-type">struct</span> getaudit_addr_args *uap,
    __unused int32_t *retval)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> error = mac_proc_check_getaudit(p);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>
	WARN_IF_AINFO_ADDR_CHANGED(uap-&gt;length, <span class="enscript-keyword">sizeof</span>(auditinfo_addr_t),
	    <span class="enscript-string">&quot;getaudit_addr(2)&quot;</span>, <span class="enscript-string">&quot;auditinfo_addr_t&quot;</span>);
	
	<span class="enscript-keyword">return</span> (getaudit_addr_internal(p, uap-&gt;auditinfo_addr, uap-&gt;length));
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setaudit_addr</span>(proc_t p, <span class="enscript-type">struct</span> setaudit_addr_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> auditinfo_addr aia;
	kauth_cred_t scred;
	<span class="enscript-type">int</span> error;

	bzero(&amp;aia, <span class="enscript-keyword">sizeof</span>(auditinfo_addr_t));
	error = copyin(uap-&gt;auditinfo_addr, &amp;aia, 
	    min(<span class="enscript-keyword">sizeof</span>(aia), uap-&gt;length));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	AUDIT_ARG(auditinfo_addr, &amp;aia);
	<span class="enscript-keyword">if</span> (aia.ai_termid.at_type != AU_IPv6 &amp;&amp;
	    aia.ai_termid.at_type != AU_IPv4)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (aia.ai_asid != AU_ASSIGN_ASID &amp;&amp; 
	    (uint32_t)aia.ai_asid &gt; ASSIGNED_ASID_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_setaudit(p, &amp;aia);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	scred = kauth_cred_proc_ref(p);
	error = suser(scred, &amp;p-&gt;p_acflag);
	<span class="enscript-keyword">if</span> (error) {
		kauth_cred_unref(&amp;scred);
		<span class="enscript-keyword">return</span> (error);
	}

	WARN_IF_AINFO_ADDR_CHANGED(uap-&gt;length, <span class="enscript-keyword">sizeof</span>(auditinfo_addr_t),
	    <span class="enscript-string">&quot;setaudit_addr(2)&quot;</span>, <span class="enscript-string">&quot;auditinfo_addr_t&quot;</span>);
	WARN_IF_BAD_ASID(aia.ai_asid, <span class="enscript-string">&quot;setaudit_addr(2)&quot;</span>);
	kauth_cred_unref(&amp;scred);

	AUDIT_CHECK_IF_KEVENTS_MASK(aia.ai_mask);
	<span class="enscript-keyword">if</span> (aia.ai_asid == AU_DEFAUDITSID)
		aia.ai_asid = AU_ASSIGN_ASID;

	error = audit_session_setaia(p, &amp;aia);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * If asked to assign an ASID then let the user know what the ASID is
	 * by copying the auditinfo_addr struct back out.
	 */</span>
	<span class="enscript-keyword">if</span> (aia.ai_asid == AU_ASSIGN_ASID)
		error = getaudit_addr_internal(p, uap-&gt;auditinfo_addr,
		    uap-&gt;length);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Syscall to manage audit files.
 *
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">auditctl</span>(proc_t p, <span class="enscript-type">struct</span> auditctl_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> nameidata nd;
	kauth_cred_t cred;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> error = 0;

	error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	vp = NULL;
	cred = NULL;

	<span class="enscript-comment">/*
	 * If a path is specified, open the replacement vnode, perform
	 * validity checks, and grab another reference to the current
	 * credential.
	 *
	 * XXX Changes API slightly.  NULL path no longer disables audit but
	 * returns EINVAL.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;path == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | LOCKLEAF | AUDITVNPATH1,
	    (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 :
	    UIO_USERSPACE32), uap-&gt;path, vfs_context_current());
	error = vn_open(&amp;nd, AUDIT_OPEN_FLAGS, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	vp = nd.ni_vp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Accessibility of the vnode was determined in vn_open; the
	 * mac_system_check_auditctl should only determine whether that vnode
	 * is appropriate for storing audit data, or that the caller was
	 * permitted to control the auditing system at all.  For example, a
	 * confidentiality policy may want to ensure that audit files are
	 * always high sensitivity.
	 */</span>
	error = mac_system_check_auditctl(kauth_cred_get(), vp);
	<span class="enscript-keyword">if</span> (error) {
		vn_close(vp, AUDIT_CLOSE_FLAGS, vfs_context_current());
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type != VREG) {
		vn_close(vp, AUDIT_CLOSE_FLAGS, vfs_context_current());
		vnode_put(vp);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	mtx_lock(&amp;audit_mtx);
	<span class="enscript-comment">/*
	 * XXXAUDIT: Should audit_suspended actually be cleared by
	 * audit_worker?
	 */</span>
	audit_suspended = 0;
	mtx_unlock(&amp;audit_mtx);

	<span class="enscript-comment">/*
	 * The following gets unreferenced in audit_rotate_vnode()
	 * after the rotation and it is no longer needed.
	 */</span>
	cred = kauth_cred_get_with_ref();
	audit_rotate_vnode(cred, vp);
	vnode_put(vp);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !CONFIG_AUDIT */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit</span>(proc_t p, <span class="enscript-type">struct</span> audit_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">auditon</span>(proc_t p, <span class="enscript-type">struct</span> auditon_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getauid</span>(proc_t p, <span class="enscript-type">struct</span> getauid_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">setauid</span>(proc_t p, <span class="enscript-type">struct</span> setauid_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">getaudit_addr</span>(proc_t p, <span class="enscript-type">struct</span> getaudit_addr_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">setaudit_addr</span>(proc_t p, <span class="enscript-type">struct</span> setaudit_addr_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">auditctl</span>(proc_t p, <span class="enscript-type">struct</span> auditctl_args *uap, int32_t *retval)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">uap</span>, <span class="enscript-variable-name">retval</span>)

	<span class="enscript-keyword">return</span> (ENOSYS);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>