<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 1999-2009 Apple Inc.
 * Copyright (c) 2006-2007 Robert N. M. Watson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/un.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_kevents.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/audit_triggers_server.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
<span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDITDATA, <span class="enscript-string">&quot;audit_data&quot;</span>, <span class="enscript-string">&quot;Audit data storage&quot;</span>);
<span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDITPATH, <span class="enscript-string">&quot;audit_path&quot;</span>, <span class="enscript-string">&quot;Audit path storage&quot;</span>);
<span class="enscript-function-name">MALLOC_DEFINE</span>(M_AUDITTEXT, <span class="enscript-string">&quot;audit_text&quot;</span>, <span class="enscript-string">&quot;Audit text storage&quot;</span>);

<span class="enscript-comment">/*
 * Audit control settings that are set/read by system calls and are hence
 * non-static.
 *
 * Define the audit control flags.
 */</span>
<span class="enscript-type">int</span>			audit_enabled;
<span class="enscript-type">int</span>			audit_suspended;

<span class="enscript-type">int</span>			audit_syscalls;
au_class_t 		audit_kevent_mask;

<span class="enscript-comment">/*
 * Flags controlling behavior in low storage situations.  Should we panic if
 * a write fails?  Should we fail stop if we're out of disk space?
 */</span>
<span class="enscript-type">int</span>			audit_panic_on_write_fail;
<span class="enscript-type">int</span>			audit_fail_stop;
<span class="enscript-type">int</span>			audit_argv;
<span class="enscript-type">int</span>			audit_arge;

<span class="enscript-comment">/*
 * Are we currently &quot;failing stop&quot; due to out of disk space?
 */</span>
<span class="enscript-type">int</span>			audit_in_failure;

<span class="enscript-comment">/*
 * Global audit statistics.
 */</span>
<span class="enscript-type">struct</span> audit_fstat	audit_fstat;

<span class="enscript-comment">/*
 * Preselection mask for non-attributable events.
 */</span>
<span class="enscript-type">struct</span> au_mask		audit_nae_mask;

<span class="enscript-comment">/*
 * Mutex to protect global variables shared between various threads and
 * processes.
 */</span>
<span class="enscript-type">struct</span> mtx		audit_mtx;

<span class="enscript-comment">/*
 * Queue of audit records ready for delivery to disk.  We insert new records
 * at the tail, and remove records from the head.  Also, a count of the
 * number of records used for checking queue depth.  In addition, a counter
 * of records that we have allocated but are not yet in the queue, which is
 * needed to estimate the total size of the combined set of records
 * outstanding in the system.
 */</span>
<span class="enscript-type">struct</span> kaudit_queue	audit_q;
<span class="enscript-type">int</span>			audit_q_len;
<span class="enscript-type">int</span>			audit_pre_q_len;

<span class="enscript-comment">/*
 * Audit queue control settings (minimum free, low/high water marks, etc.)
 */</span>
<span class="enscript-type">struct</span> au_qctrl		audit_qctrl;

<span class="enscript-comment">/*
 * Condition variable to signal to the worker that it has work to do: either
 * new records are in the queue, or a log replacement is taking place.
 */</span>
<span class="enscript-type">struct</span> cv		audit_worker_cv;

<span class="enscript-comment">/*
 * Condition variable to signal when the worker is done draining the audit
 * queue.
 */</span>
<span class="enscript-type">struct</span> cv		audit_drain_cv;

<span class="enscript-comment">/*
 * Condition variable to flag when crossing the low watermark, meaning that
 * threads blocked due to hitting the high watermark can wake up and continue
 * to commit records.
 */</span>
<span class="enscript-type">struct</span> cv		audit_watermark_cv;

<span class="enscript-comment">/*
 * Condition variable for  auditing threads wait on when in fail-stop mode.
 * Threads wait on this CV forever (and ever), never seeing the light of day
 * again.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cv	audit_fail_cv;

<span class="enscript-type">static</span> zone_t		audit_record_zone;

<span class="enscript-comment">/*
 * Kernel audit information.  This will store the current audit address
 * or host information that the kernel will use when it's generating
 * audit records.  This data is modified by the A_GET{SET}KAUDIT auditon(2)
 * command.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> auditinfo_addr	audit_kinfo;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> rwlock		audit_kinfo_lock;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KINFO_LOCK_INIT</span>()	rw_init(&amp;audit_kinfo_lock,		\
					<span class="enscript-string">&quot;audit_kinfo_lock&quot;</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KINFO_RLOCK</span>()		rw_rlock(&amp;audit_kinfo_lock)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KINFO_WLOCK</span>()		rw_wlock(&amp;audit_kinfo_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KINFO_RUNLOCK</span>()		rw_runlock(&amp;audit_kinfo_lock)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KINFO_WUNLOCK</span>()		rw_wunlock(&amp;audit_kinfo_lock)

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_set_kinfo</span>(<span class="enscript-type">struct</span> auditinfo_addr *ak)
{

	KASSERT(ak-&gt;ai_termid.at_type == AU_IPv4 ||
	    ak-&gt;ai_termid.at_type == AU_IPv6,
	    (<span class="enscript-string">&quot;audit_set_kinfo: invalid address type&quot;</span>));

	KINFO_WLOCK();
	bcopy(ak, &amp;audit_kinfo, <span class="enscript-keyword">sizeof</span>(audit_kinfo));
	KINFO_WUNLOCK();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_get_kinfo</span>(<span class="enscript-type">struct</span> auditinfo_addr *ak)
{

	KASSERT(audit_kinfo.ai_termid.at_type == AU_IPv4 ||
	    audit_kinfo.ai_termid.at_type == AU_IPv6,
	    (<span class="enscript-string">&quot;audit_set_kinfo: invalid address type&quot;</span>));

	KINFO_RLOCK();
	bcopy(&amp;audit_kinfo, ak, <span class="enscript-keyword">sizeof</span>(*ak));
	KINFO_RUNLOCK();
}

<span class="enscript-comment">/*
 * Construct an audit record for the passed thread.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_record_ctor</span>(proc_t p, <span class="enscript-type">struct</span> kaudit_record *ar)
{
	kauth_cred_t cred;

	bzero(ar, <span class="enscript-keyword">sizeof</span>(*ar));
	ar-&gt;k_ar.ar_magic = AUDIT_RECORD_MAGIC;
	nanotime(&amp;ar-&gt;k_ar.ar_starttime);

	<span class="enscript-keyword">if</span> (PROC_NULL != p) {
		cred = kauth_cred_proc_ref(p);

		<span class="enscript-comment">/*
	 	 * Export the subject credential.
	 	 */</span>
		cru2x(cred, &amp;ar-&gt;k_ar.ar_subj_cred);
		ar-&gt;k_ar.ar_subj_ruid = kauth_cred_getruid(cred);
		ar-&gt;k_ar.ar_subj_rgid = kauth_cred_getrgid(cred);
		ar-&gt;k_ar.ar_subj_egid = kauth_cred_getgid(cred);
		ar-&gt;k_ar.ar_subj_pid = p-&gt;p_pid;
		ar-&gt;k_ar.ar_subj_auid = cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
		ar-&gt;k_ar.ar_subj_asid = cred-&gt;cr_audit.as_aia_p-&gt;ai_asid;
		bcopy(&amp;cred-&gt;cr_audit.as_mask, &amp;ar-&gt;k_ar.ar_subj_amask,
    		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_mask));
		bcopy(&amp;cred-&gt;cr_audit.as_aia_p-&gt;ai_termid,
		    &amp;ar-&gt;k_ar.ar_subj_term_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_tid_addr));
		kauth_cred_unref(&amp;cred);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">audit_record_dtor</span>(<span class="enscript-type">struct</span> kaudit_record *ar)
{

	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_upath1 != NULL)
		free(ar-&gt;k_ar.ar_arg_upath1, M_AUDITPATH);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_upath2 != NULL)
		free(ar-&gt;k_ar.ar_arg_upath2, M_AUDITPATH);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_kpath1 != NULL)
		free(ar-&gt;k_ar.ar_arg_kpath1, M_AUDITPATH);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_kpath2 != NULL)
		free(ar-&gt;k_ar.ar_arg_kpath2, M_AUDITPATH);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_text != NULL)
		free(ar-&gt;k_ar.ar_arg_text, M_AUDITTEXT);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_opaque != NULL)
		free(ar-&gt;k_ar.ar_arg_opaque, M_AUDITDATA);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_data != NULL)
		free(ar-&gt;k_ar.ar_arg_data, M_AUDITDATA);
	<span class="enscript-keyword">if</span> (ar-&gt;k_udata != NULL)
		free(ar-&gt;k_udata, M_AUDITDATA);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_argv != NULL)
		free(ar-&gt;k_ar.ar_arg_argv, M_AUDITTEXT);
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_arg_envv != NULL)
		free(ar-&gt;k_ar.ar_arg_envv, M_AUDITTEXT);
}

<span class="enscript-comment">/*
 * Initialize the Audit subsystem: configuration state, work queue,
 * synchronization primitives, worker thread, and trigger device node.  Also
 * call into the BSM assembly code to initialize it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_init</span>(<span class="enscript-type">void</span>)
{

	audit_enabled = 0;
	audit_syscalls = 0;
	audit_kevent_mask = 0;
	audit_suspended = 0;
	audit_panic_on_write_fail = 0;
	audit_fail_stop = 0;
	audit_in_failure = 0;
	audit_argv = 0;
	audit_arge = 0;

	audit_fstat.af_filesz = 0;	<span class="enscript-comment">/* '0' means unset, unbounded. */</span>
	audit_fstat.af_currsz = 0;
	audit_nae_mask.am_success = 0;
	audit_nae_mask.am_failure = 0;

	TAILQ_INIT(&amp;audit_q);
	audit_q_len = 0;
	audit_pre_q_len = 0;
	audit_qctrl.aq_hiwater = AQ_HIWATER;
	audit_qctrl.aq_lowater = AQ_LOWATER;
	audit_qctrl.aq_bufsz = AQ_BUFSZ;
	audit_qctrl.aq_minfree = AU_FS_MINFREE;

	audit_kinfo.ai_termid.at_type = AU_IPv4;
	audit_kinfo.ai_termid.at_addr[0] = INADDR_ANY;

	_audit_lck_grp_init();
	mtx_init(&amp;audit_mtx, <span class="enscript-string">&quot;audit_mtx&quot;</span>, NULL, MTX_DEF);
	KINFO_LOCK_INIT();
	cv_init(&amp;audit_worker_cv, <span class="enscript-string">&quot;audit_worker_cv&quot;</span>);
	cv_init(&amp;audit_drain_cv, <span class="enscript-string">&quot;audit_drain_cv&quot;</span>);
	cv_init(&amp;audit_watermark_cv, <span class="enscript-string">&quot;audit_watermark_cv&quot;</span>);
	cv_init(&amp;audit_fail_cv, <span class="enscript-string">&quot;audit_fail_cv&quot;</span>);

	audit_record_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kaudit_record),
	    AQ_HIWATER*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kaudit_record), 8192, <span class="enscript-string">&quot;audit_zone&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	audit_mac_init();
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Init audit session subsystem. */</span>
	audit_session_init();

	<span class="enscript-comment">/* Initialize the BSM audit subsystem. */</span>
	kau_init();

	<span class="enscript-comment">/* audit_trigger_init(); */</span>

	<span class="enscript-comment">/* Start audit worker thread. */</span>
	(<span class="enscript-type">void</span>) audit_pipe_init();

	<span class="enscript-comment">/* Start audit worker thread. */</span>
	audit_worker_init();
}

<span class="enscript-comment">/*
 * Drain the audit queue and close the log at shutdown.  Note that this can
 * be called both from the system shutdown path and also from audit
 * configuration syscalls, so 'arg' and 'howto' are ignored.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_shutdown</span>(<span class="enscript-type">void</span>)
{

	audit_rotate_vnode(NULL, NULL);
}

<span class="enscript-comment">/*
 * Return the current thread's audit record, if any.
 */</span>
<span class="enscript-type">struct</span> kaudit_record *
<span class="enscript-function-name">currecord</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-keyword">return</span> (curthread()-&gt;uu_ar);
}

<span class="enscript-comment">/*
 * XXXAUDIT: There are a number of races present in the code below due to
 * release and re-grab of the mutex.  The code should be revised to become
 * slightly less racy.
 *
 * XXXAUDIT: Shouldn't there be logic here to sleep waiting on available
 * pre_q space, suspending the system call until there is room?
 */</span>
<span class="enscript-type">struct</span> kaudit_record *
<span class="enscript-function-name">audit_new</span>(<span class="enscript-type">int</span> event, proc_t p, __unused <span class="enscript-type">struct</span> uthread *uthread)
{
	<span class="enscript-type">struct</span> kaudit_record *ar;
	<span class="enscript-type">int</span> no_record;
	<span class="enscript-type">int</span> audit_override;

	<span class="enscript-comment">/*
	 * Override the audit_suspended and audit_enabled if it always
	 * audits session events.
	 *
	 * XXXss - This really needs to be a generalized call to a filter
	 * interface so if other things that use the audit subsystem in the
	 * future can simply plugged in.
	 */</span>
	audit_override = (AUE_SESSION_START == event ||
	    AUE_SESSION_UPDATE == event || AUE_SESSION_END == event ||
	    AUE_SESSION_CLOSE == event);
	
	mtx_lock(&amp;audit_mtx);
	no_record = (audit_suspended || !audit_enabled);
	mtx_unlock(&amp;audit_mtx);
	<span class="enscript-keyword">if</span> (!audit_override &amp;&amp; no_record)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-comment">/*
	 * Initialize the audit record header.
	 * XXX: We may want to fail-stop if allocation fails.
	 *
	 * Note: the number of outstanding uncommitted audit records is
	 * limited to the number of concurrent threads servicing system calls
	 * in the kernel.
	 */</span>
	ar = zalloc(audit_record_zone);
	<span class="enscript-keyword">if</span> (ar == NULL)
		<span class="enscript-keyword">return</span> NULL;
	audit_record_ctor(p, ar);
	ar-&gt;k_ar.ar_event = event;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (PROC_NULL != p) {
		<span class="enscript-keyword">if</span> (audit_mac_new(p, ar) != 0) {
			zfree(audit_record_zone, ar);
			<span class="enscript-keyword">return</span> (NULL);
		}
	} <span class="enscript-keyword">else</span>
		ar-&gt;k_ar.ar_mac_records = NULL;
#<span class="enscript-reference">endif</span>

	mtx_lock(&amp;audit_mtx);
	audit_pre_q_len++;
	mtx_unlock(&amp;audit_mtx);

	<span class="enscript-keyword">return</span> (ar);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_free</span>(<span class="enscript-type">struct</span> kaudit_record *ar)
{

	audit_record_dtor(ar);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (NULL != ar-&gt;k_ar.ar_mac_records)
		audit_mac_free(ar);
#<span class="enscript-reference">endif</span>
	zfree(audit_record_zone, ar);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_commit</span>(<span class="enscript-type">struct</span> kaudit_record *ar, <span class="enscript-type">int</span> error, <span class="enscript-type">int</span> retval)
{
	au_event_t event;
	au_class_t class;
	au_id_t auid;
	<span class="enscript-type">int</span> sorf;
	<span class="enscript-type">struct</span> au_mask *aumask;
	<span class="enscript-type">int</span> audit_override;

	<span class="enscript-keyword">if</span> (ar == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Decide whether to commit the audit record by checking the error
	 * value from the system call and using the appropriate audit mask.
	 */</span>
	<span class="enscript-keyword">if</span> (ar-&gt;k_ar.ar_subj_auid == AU_DEFAUDITID)
		aumask = &amp;audit_nae_mask;
	<span class="enscript-keyword">else</span>
		aumask = &amp;ar-&gt;k_ar.ar_subj_amask;

	<span class="enscript-keyword">if</span> (error)
		sorf = AU_PRS_FAILURE;
	<span class="enscript-keyword">else</span>
		sorf = AU_PRS_SUCCESS;

	<span class="enscript-keyword">switch</span>(ar-&gt;k_ar.ar_event) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_RWTC</span>:
		<span class="enscript-comment">/*
		 * The open syscall always writes a AUE_OPEN_RWTC event;
		 * change it to the proper type of event based on the flags
		 * and the error value.
		 */</span>
		ar-&gt;k_ar.ar_event = audit_flags_and_error_to_openevent(
		    ar-&gt;k_ar.ar_arg_fflags, error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPEN_EXTENDED_RWTC</span>:
		<span class="enscript-comment">/*
		 * The open_extended syscall always writes a
		 * AUE_OPEN_EXTENDEDRWTC event; change it to the proper type of
		 * event based on the flags and the error value.
		 */</span>
		ar-&gt;k_ar.ar_event = audit_flags_and_error_to_openextendedevent(
		    ar-&gt;k_ar.ar_arg_fflags, error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENAT_RWTC</span>:
		<span class="enscript-comment">/*
		 * The openat syscall always writes a
		 * AUE_OPENAT_RWTC event; change it to the proper type of
		 * event based on the flags and the error value.
		 */</span>
		ar-&gt;k_ar.ar_event = audit_flags_and_error_to_openatevent(
		    ar-&gt;k_ar.ar_arg_fflags, error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_OPENBYID_RWT</span>:
		<span class="enscript-comment">/*
		 * The openbyid syscall always writes a
		 * AUE_OPENBYID_RWT event; change it to the proper type of
		 * event based on the flags and the error value.
		 */</span>
		ar-&gt;k_ar.ar_event = audit_flags_and_error_to_openbyidevent(
		    ar-&gt;k_ar.ar_arg_fflags, error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_SYSCTL</span>:
		ar-&gt;k_ar.ar_event = audit_ctlname_to_sysctlevent(
		    ar-&gt;k_ar.ar_arg_ctlname, ar-&gt;k_ar.ar_valid_arg);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_AUDITON</span>:
		<span class="enscript-comment">/* Convert the auditon() command to an event. */</span>
		ar-&gt;k_ar.ar_event = auditon_command_event(ar-&gt;k_ar.ar_arg_cmd);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">AUE_FCNTL</span>:
		<span class="enscript-comment">/* Convert some fcntl() commands to their own events. */</span>
		ar-&gt;k_ar.ar_event = audit_fcntl_command_event(
		    ar-&gt;k_ar.ar_arg_cmd, ar-&gt;k_ar.ar_arg_fflags, error);
		<span class="enscript-keyword">break</span>;
	}

	auid = ar-&gt;k_ar.ar_subj_auid;
	event = ar-&gt;k_ar.ar_event;
	class = au_event_class(event);

	<span class="enscript-comment">/*
	 * See if we need to override the audit_suspend and audit_enabled
	 * flags.
	 *
	 * XXXss - This check needs to be generalized so new filters can
	 * easily be added.
	 */</span>
	audit_override = (AUE_SESSION_START == event ||
	    AUE_SESSION_UPDATE == event || AUE_SESSION_END == event ||
	    AUE_SESSION_CLOSE == event);

	ar-&gt;k_ar_commit |= AR_COMMIT_KERNEL;
	<span class="enscript-keyword">if</span> (au_preselect(event, class, aumask, sorf) != 0)
		ar-&gt;k_ar_commit |= AR_PRESELECT_TRAIL;
	<span class="enscript-keyword">if</span> (audit_pipe_preselect(auid, event, class, sorf,
	    ar-&gt;k_ar_commit &amp; AR_PRESELECT_TRAIL) != 0)
		ar-&gt;k_ar_commit |= AR_PRESELECT_PIPE;
	<span class="enscript-keyword">if</span> ((ar-&gt;k_ar_commit &amp; (AR_PRESELECT_TRAIL | AR_PRESELECT_PIPE |
	    AR_PRESELECT_USER_TRAIL | AR_PRESELECT_USER_PIPE |
	    AR_PRESELECT_FILTER)) == 0) {
		mtx_lock(&amp;audit_mtx);
		audit_pre_q_len--;
		mtx_unlock(&amp;audit_mtx);
		audit_free(ar);
		<span class="enscript-keyword">return</span>;
	}

	ar-&gt;k_ar.ar_errno = error;
	ar-&gt;k_ar.ar_retval = retval;
	nanotime(&amp;ar-&gt;k_ar.ar_endtime);

	<span class="enscript-comment">/*
	 * Note: it could be that some records initiated while audit was
	 * enabled should still be committed?
	 */</span>
	mtx_lock(&amp;audit_mtx);
	<span class="enscript-keyword">if</span> (!audit_override &amp;&amp; (audit_suspended || !audit_enabled)) {
		audit_pre_q_len--;
		mtx_unlock(&amp;audit_mtx);
		audit_free(ar);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Constrain the number of committed audit records based on the
	 * configurable parameter.
	 */</span>
	<span class="enscript-keyword">while</span> (audit_q_len &gt;= audit_qctrl.aq_hiwater)
		cv_wait(&amp;audit_watermark_cv, &amp;audit_mtx);

	TAILQ_INSERT_TAIL(&amp;audit_q, ar, k_q);
	audit_q_len++;
	audit_pre_q_len--;
	cv_signal(&amp;audit_worker_cv);
	mtx_unlock(&amp;audit_mtx);
}

<span class="enscript-comment">/*
 * audit_syscall_enter() is called on entry to each system call.  It is
 * responsible for deciding whether or not to audit the call (preselection),
 * and if so, allocating a per-thread audit record.  audit_new() will fill in
 * basic thread/credential properties.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_syscall_enter</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> code, proc_t proc, <span class="enscript-type">struct</span> uthread *uthread)
{
	<span class="enscript-type">struct</span> au_mask *aumask;
	au_class_t class;
	au_event_t event;
	au_id_t auid;
	kauth_cred_t cred;

	<span class="enscript-comment">/*
	 * In FreeBSD, each ABI has its own system call table, and hence
	 * mapping of system call codes to audit events.  Convert the code to
	 * an audit event identifier using the process system call table
	 * reference.  In Darwin, there's only one, so we use the global
	 * symbol for the system call table.  No audit record is generated
	 * for bad system calls, as no operation has been performed.
	 *
	 * In Mac OS X, the audit events are stored in a table seperate from
	 * the syscall table(s).  This table is generated by makesyscalls.sh
	 * from syscalls.master and stored in audit_kevents.c.
	 */</span>
	<span class="enscript-keyword">if</span> (code &gt; NUM_SYSENT)
		<span class="enscript-keyword">return</span>;
	event = sys_au_event[code];
	<span class="enscript-keyword">if</span> (event == AUE_NULL)
		<span class="enscript-keyword">return</span>;

	KASSERT(uthread-&gt;uu_ar == NULL,
	    (<span class="enscript-string">&quot;audit_syscall_enter: uthread-&gt;uu_ar != NULL&quot;</span>));

	<span class="enscript-comment">/*
	 * Check which audit mask to use; either the kernel non-attributable
	 * event mask or the process audit mask.
	 */</span>
	cred = kauth_cred_proc_ref(proc);
	auid = cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
	<span class="enscript-keyword">if</span> (auid == AU_DEFAUDITID) 
		aumask = &amp;audit_nae_mask;
	<span class="enscript-keyword">else</span>
		aumask = &amp;cred-&gt;cr_audit.as_mask;

	<span class="enscript-comment">/*
	 * Allocate an audit record, if preselection allows it, and store in
	 * the thread for later use.
	 */</span>
	class = au_event_class(event);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Note: audit_mac_syscall_enter() may call audit_new() and allocate
	 * memory for the audit record (uu_ar).
	 */</span>
	<span class="enscript-keyword">if</span> (audit_mac_syscall_enter(code, proc, uthread, cred, event) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (au_preselect(event, class, aumask, AU_PRS_BOTH)) {
		<span class="enscript-comment">/*
		 * If we're out of space and need to suspend unprivileged
		 * processes, do that here rather than trying to allocate
		 * another audit record.
		 *
		 * Note: we might wish to be able to continue here in the
		 * future, if the system recovers.  That should be possible
		 * by means of checking the condition in a loop around
		 * cv_wait().  It might be desirable to reevaluate whether an
		 * audit record is still required for this event by
		 * re-calling au_preselect().
		 */</span>
		<span class="enscript-keyword">if</span> (audit_in_failure &amp;&amp;
		    suser(cred, &amp;proc-&gt;p_acflag) != 0) {
			cv_wait(&amp;audit_fail_cv, &amp;audit_mtx);
			panic(<span class="enscript-string">&quot;audit_failing_stop: thread continued&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (uthread-&gt;uu_ar == NULL)
			uthread-&gt;uu_ar = audit_new(event, proc, uthread);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (audit_pipe_preselect(auid, event, class, AU_PRS_BOTH, 0)) {
		<span class="enscript-keyword">if</span> (uthread-&gt;uu_ar == NULL)
			uthread-&gt;uu_ar = audit_new(event, proc, uthread);
	} 

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;cred);
}

<span class="enscript-comment">/*
 * audit_syscall_exit() is called from the return of every system call, or in
 * the event of exit1(), during the execution of exit1().  It is responsible
 * for committing the audit record, if any, along with return condition.
 *
 * Note: The audit_syscall_exit() parameter list was modified to support
 * mac_audit_check_postselect(), which requires the syscall number.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_syscall_exit</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> error, __unused proc_t proc,
    <span class="enscript-type">struct</span> uthread *uthread)
#<span class="enscript-reference">else</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_syscall_exit</span>(<span class="enscript-type">int</span> error, __unsed proc_t proc, <span class="enscript-type">struct</span> uthread *uthread)
#<span class="enscript-reference">endif</span>
{
	<span class="enscript-type">int</span> retval;

	<span class="enscript-comment">/*
	 * Commit the audit record as desired; once we pass the record into
	 * audit_commit(), the memory is owned by the audit subsystem.  The
	 * return value from the system call is stored on the user thread.
	 * If there was an error, the return value is set to -1, imitating
	 * the behavior of the cerror routine.
	 */</span>
	<span class="enscript-keyword">if</span> (error)
		retval = -1;
	<span class="enscript-keyword">else</span>
		retval = uthread-&gt;uu_rval[0];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (audit_mac_syscall_exit(code, uthread, error, retval) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	audit_commit(uthread-&gt;uu_ar, error, retval);

<span class="enscript-reference">out</span>:
	uthread-&gt;uu_ar = NULL;
}

<span class="enscript-comment">/*
 * Calls to set up and tear down audit structures used during Mach system
 * calls.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_mach_syscall_enter</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> event)
{
	<span class="enscript-type">struct</span> uthread *uthread;
	proc_t proc;
	<span class="enscript-type">struct</span> au_mask *aumask;
	kauth_cred_t cred;
	au_class_t class;
	au_id_t auid;

	<span class="enscript-keyword">if</span> (event == AUE_NULL)
		<span class="enscript-keyword">return</span>;

	uthread = curthread();
	<span class="enscript-keyword">if</span> (uthread == NULL)
		<span class="enscript-keyword">return</span>;

	proc = current_proc();
	<span class="enscript-keyword">if</span> (proc == NULL)
		<span class="enscript-keyword">return</span>;

	KASSERT(uthread-&gt;uu_ar == NULL,
	    (<span class="enscript-string">&quot;audit_mach_syscall_enter: uthread-&gt;uu_ar != NULL&quot;</span>));

	cred = kauth_cred_proc_ref(proc);
	auid = cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;

	<span class="enscript-comment">/*
	 * Check which audit mask to use; either the kernel non-attributable
	 * event mask or the process audit mask.
	 */</span>
	<span class="enscript-keyword">if</span> (auid == AU_DEFAUDITID) 
		aumask = &amp;audit_nae_mask;
	<span class="enscript-keyword">else</span>
		aumask = &amp;cred-&gt;cr_audit.as_mask;

	<span class="enscript-comment">/*
	 * Allocate an audit record, if desired, and store in the BSD thread
	 * for later use.
	 */</span>
	class = au_event_class(event);
	<span class="enscript-keyword">if</span> (au_preselect(event, class, aumask, AU_PRS_BOTH))
		uthread-&gt;uu_ar = audit_new(event, proc, uthread);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (audit_pipe_preselect(auid, event, class, AU_PRS_BOTH, 0))
		uthread-&gt;uu_ar = audit_new(event, proc, uthread);
	<span class="enscript-keyword">else</span>
		uthread-&gt;uu_ar = NULL;

	kauth_cred_unref(&amp;cred);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_mach_syscall_exit</span>(<span class="enscript-type">int</span> retval, <span class="enscript-type">struct</span> uthread *uthread)
{
	<span class="enscript-comment">/*
	 * The error code from Mach system calls is the same as the
	 * return value
	 */</span>
	<span class="enscript-comment">/* XXX Is the above statement always true? */</span>
	audit_commit(uthread-&gt;uu_ar, retval, retval);
	uthread-&gt;uu_ar = NULL;
}

<span class="enscript-comment">/*
 * kau_will_audit can be used by a security policy to determine
 * if an audit record will be stored, reducing wasted memory allocation
 * and string handling.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kau_will_audit</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-keyword">return</span> (audit_enabled &amp;&amp; currecord() != NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">audit_proc_coredump</span>(proc_t proc, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> errcode)
{
	<span class="enscript-type">struct</span> kaudit_record *ar;
	<span class="enscript-type">struct</span> au_mask *aumask;
	au_class_t class;
	<span class="enscript-type">int</span> ret, sorf;
	<span class="enscript-type">char</span> **pathp;
	au_id_t auid;
	kauth_cred_t my_cred;
	<span class="enscript-type">struct</span> uthread *uthread;

	ret = 0;

	<span class="enscript-comment">/*
	 * Make sure we are using the correct preselection mask.
	 */</span>
	my_cred = kauth_cred_proc_ref(proc);
	auid = my_cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
	<span class="enscript-keyword">if</span> (auid == AU_DEFAUDITID) 
		aumask = &amp;audit_nae_mask;
	<span class="enscript-keyword">else</span>
		aumask = &amp;my_cred-&gt;cr_audit.as_mask;
	kauth_cred_unref(&amp;my_cred);
	<span class="enscript-comment">/*
	 * It's possible for coredump(9) generation to fail.  Make sure that
	 * we handle this case correctly for preselection.
	 */</span>
	<span class="enscript-keyword">if</span> (errcode != 0)
		sorf = AU_PRS_FAILURE;
	<span class="enscript-keyword">else</span>
		sorf = AU_PRS_SUCCESS;
	class = au_event_class(AUE_CORE);
	<span class="enscript-keyword">if</span> (au_preselect(AUE_CORE, class, aumask, sorf) == 0 &amp;&amp;
	    audit_pipe_preselect(auid, AUE_CORE, class, sorf, 0) == 0)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/*
	 * If we are interested in seeing this audit record, allocate it.
	 * Where possible coredump records should contain a pathname and arg32
	 * (signal) tokens.
	 */</span>
	uthread = curthread();
	ar = audit_new(AUE_CORE, proc, uthread);
	<span class="enscript-keyword">if</span> (path != NULL) {
		pathp = &amp;ar-&gt;k_ar.ar_arg_upath1;
		*pathp = malloc(MAXPATHLEN, M_AUDITPATH, M_WAITOK);
		<span class="enscript-keyword">if</span> (audit_canon_path(vfs_context_cwd(vfs_context_current()), path,
		    *pathp))
			free(*pathp, M_AUDITPATH);
		<span class="enscript-keyword">else</span>
			ARG_SET_VALID(ar, ARG_UPATH1);
	}
	ar-&gt;k_ar.ar_arg_signum = proc-&gt;p_sigacts-&gt;ps_sig;
	ARG_SET_VALID(ar, ARG_SIGNUM);
	<span class="enscript-keyword">if</span> (errcode != 0)
		ret = 1;
	audit_commit(ar, errcode, ret);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>