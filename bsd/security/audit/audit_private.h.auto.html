<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_private.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_private.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 1999-2009 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * This include file contains function prototypes and type definitions used
 * within the audit implementation.
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_SECURITY_AUDIT_PRIVATE_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">_SECURITY_AUDIT_PRIVATE_H_</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_KERNEL</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL</span>)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ipc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>	<span class="enscript-comment">/* for PID_MAX */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MALLOC_DECLARE</span>
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_AUDITBSM);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_AUDITDATA);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_AUDITPATH);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_AUDITTEXT);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Audit control variables that are usually set/read via system calls and
 * used to control various aspects of auditing.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> au_qctrl		audit_qctrl;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> audit_fstat	audit_fstat;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> au_mask		audit_nae_mask;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_panic_on_write_fail;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_fail_stop;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_argv;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_arge;

<span class="enscript-comment">/*
 * Kernel mask that is used to check to see if system calls need to be audited.
 */</span>
<span class="enscript-type">extern</span> au_class_t		audit_kevent_mask;

<span class="enscript-comment">/*
 * The macro used to check to see if the system calls need to be auditing. 
 * This will pessimisticly set the audit syscalls flag if the audit kevent
 * mask has not been created yet.  User code should build the event/class
 * mapping table before setting preselection masks to avoid this.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">AUDIT_CHECK_IF_KEVENTS_MASK</span>(m) do {				\
	<span class="enscript-keyword">if</span> ((m).am_success || (m).am_failure)				\
		<span class="enscript-keyword">if</span> (!audit_kevent_mask || 				\
		    (audit_kevent_mask &amp; (m).am_success) ||		\
		    (audit_kevent_mask &amp; (m).am_failure))		\
			audit_syscalls = 1;				\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Success/failure conditions for the conversion of a kernel audit record to
 * BSM format.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BSM_SUCCESS</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BSM_FAILURE</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">BSM_NOAUDIT</span>	2

<span class="enscript-comment">/*
 * Defines for the kernel audit record k_ar_commit field.  Flags are set to
 * indicate what sort of record it is, and which preselection mechanism
 * selected it.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_COMMIT_KERNEL</span>	0x00000001U
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_COMMIT_USER</span>		0x00000010U

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_PRESELECT_TRAIL</span>	0x00001000U
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_PRESELECT_PIPE</span>	0x00002000U

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_PRESELECT_USER_TRAIL</span>	0x00004000U
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_PRESELECT_USER_PIPE</span>	0x00008000U

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_PRESELECT_FILTER</span>	0x00010000U

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AR_DRAIN_QUEUE</span>		0x80000000U

<span class="enscript-comment">/*
 * Audit data is generated as a stream of struct audit_record structures,
 * linked by struct kaudit_record, and contain storage for possible audit so
 * that it will not need to be allocated during the processing of a system
 * call, both improving efficiency and avoiding sleeping at untimely moments.
 * This structure is converted to BSM format before being written to disk.
 */</span>
<span class="enscript-type">struct</span> vnode_au_info {
	mode_t	vn_mode;
	uid_t	vn_uid;
	gid_t	vn_gid;
	dev_t	vn_dev;
	<span class="enscript-type">long</span>	vn_fsid;
	<span class="enscript-type">long</span>	vn_fileid;
	<span class="enscript-type">long</span>	vn_gen;
};

<span class="enscript-type">struct</span> groupset {
	gid_t	gidset[NGROUPS];
	u_int	gidset_size;
};

<span class="enscript-type">struct</span> socket_au_info {
	<span class="enscript-type">int</span>		 	sai_domain;
	<span class="enscript-type">int</span>		 	sai_type;
	<span class="enscript-type">int</span>		 	sai_protocol;

	<span class="enscript-comment">/* Foreign (remote) address/port. */</span>
	<span class="enscript-type">struct</span> sockaddr_storage	sai_faddr;

	<span class="enscript-comment">/* Local address/port. */</span>
	<span class="enscript-type">struct</span> sockaddr_storage	sai_laddr;
};

<span class="enscript-comment">/*
 *  The following is used for A_OLDSETQCTRL and A_OLDGETQCTRL and a 64-bit
 *  userland.
 */</span>
<span class="enscript-type">struct</span>	au_qctrl64 {
	u_int64_t		aq64_hiwater;
	u_int64_t		aq64_lowater;
	u_int64_t		aq64_bufsz;
	u_int64_t		aq64_delay;
	int64_t			aq64_minfree;
};
<span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> au_qctrl64 au_qctrl64_t;

<span class="enscript-type">union</span> auditon_udata {
	<span class="enscript-type">char</span>			*au_path;
	<span class="enscript-type">int</span>			au_cond;
	<span class="enscript-type">int</span>			au_policy;
	int64_t			au_cond64;
	int64_t			au_policy64;
	<span class="enscript-type">int</span>			au_trigger;
	au_evclass_map_t	au_evclass;
	au_mask_t		au_mask;
	au_asflgs_t		au_flags;
	auditinfo_t		au_auinfo;
	auditpinfo_t		au_aupinfo;
	auditpinfo_addr_t	au_aupinfo_addr;
	au_qctrl_t		au_qctrl;
	au_qctrl64_t		au_qctrl64;
	au_stat_t		au_stat;
	au_fstat_t		au_fstat;
	auditinfo_addr_t	au_kau_info;
};

<span class="enscript-type">struct</span> posix_ipc_perm {
	uid_t	pipc_uid;
	gid_t	pipc_gid;
	mode_t	pipc_mode;
};

<span class="enscript-type">struct</span> audit_record {
	<span class="enscript-comment">/* Audit record header. */</span>
	u_int32_t		ar_magic;
	<span class="enscript-type">int</span>			ar_event;
	<span class="enscript-type">int</span>			ar_retval; <span class="enscript-comment">/* value returned to the process */</span>
	<span class="enscript-type">int</span>			ar_errno;  <span class="enscript-comment">/* return status of system call */</span>
	<span class="enscript-type">struct</span> timespec		ar_starttime;
	<span class="enscript-type">struct</span> timespec		ar_endtime;
	u_int64_t		ar_valid_arg;  <span class="enscript-comment">/* Bitmask of valid arguments */</span>

	<span class="enscript-comment">/* Audit subject information. */</span>
	<span class="enscript-type">struct</span> xucred		ar_subj_cred;
	uid_t			ar_subj_ruid;
	gid_t			ar_subj_rgid;
	gid_t			ar_subj_egid;
	uid_t			ar_subj_auid; <span class="enscript-comment">/* Audit user ID */</span>
	pid_t			ar_subj_asid; <span class="enscript-comment">/* Audit session ID */</span>
	pid_t			ar_subj_pid;
	<span class="enscript-type">struct</span> au_tid		ar_subj_term;
	<span class="enscript-type">struct</span> au_tid_addr	ar_subj_term_addr;
	<span class="enscript-type">struct</span> au_mask		ar_subj_amask;

	<span class="enscript-comment">/* Operation arguments. */</span>
	uid_t			ar_arg_euid;
	uid_t			ar_arg_ruid;
	uid_t			ar_arg_suid;
	gid_t			ar_arg_egid;
	gid_t			ar_arg_rgid;
	gid_t			ar_arg_sgid;
	pid_t			ar_arg_pid;
	pid_t			ar_arg_asid;
	<span class="enscript-type">struct</span> au_tid		ar_arg_termid;
	<span class="enscript-type">struct</span> au_tid_addr	ar_arg_termid_addr;
	uid_t			ar_arg_uid;
	uid_t			ar_arg_auid;
	gid_t			ar_arg_gid;
	<span class="enscript-type">struct</span> groupset		ar_arg_groups;
	<span class="enscript-type">int</span>			ar_arg_fd;
	<span class="enscript-type">int</span>			ar_arg_fflags;
	mode_t			ar_arg_mode;
	uint32_t		ar_arg_value32;
	uint64_t		ar_arg_value64;
	user_addr_t		ar_arg_addr;
	user_size_t		ar_arg_len;
	<span class="enscript-type">int</span>			ar_arg_mask;
	u_int			ar_arg_signum;
	<span class="enscript-type">char</span>			ar_arg_login[MAXLOGNAME];
	<span class="enscript-type">int</span>			ar_arg_ctlname[CTL_MAXNAME];
	<span class="enscript-type">struct</span> socket_au_info	ar_arg_sockinfo;
	<span class="enscript-type">char</span>			*ar_arg_upath1;
	<span class="enscript-type">char</span>			*ar_arg_upath2;
	<span class="enscript-type">char</span>			*ar_arg_kpath1;		<span class="enscript-comment">/* darwin-only */</span>
	<span class="enscript-type">char</span>			*ar_arg_kpath2;		<span class="enscript-comment">/* darwin-only */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">char</span>			*ar_vnode1_mac_labels;
	<span class="enscript-type">char</span>			*ar_vnode2_mac_labels;
	<span class="enscript-type">char</span>			*ar_cred_mac_labels;
	<span class="enscript-type">char</span>			*ar_arg_mac_string;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">char</span>			*ar_arg_text;
	<span class="enscript-type">void</span>			*ar_arg_opaque;		<span class="enscript-comment">/* darwin-only */</span>
	<span class="enscript-type">void</span>			*ar_arg_data;		<span class="enscript-comment">/* darwin-only */</span>
	u_int16_t		ar_arg_opq_size;	<span class="enscript-comment">/* darwin-only */</span>
	u_char			ar_arg_data_type;	<span class="enscript-comment">/* darwin-only */</span>
	u_char			ar_arg_data_count;	<span class="enscript-comment">/* darwin-only */</span>
	<span class="enscript-type">struct</span> au_mask		ar_arg_amask;
	<span class="enscript-type">struct</span> vnode_au_info	ar_arg_vnode1;
	<span class="enscript-type">struct</span> vnode_au_info	ar_arg_vnode2;
	<span class="enscript-type">int</span>			ar_arg_cmd;
	<span class="enscript-type">int</span>			ar_arg_svipc_cmd;
	<span class="enscript-type">struct</span> ipc_perm		ar_arg_svipc_perm;
	<span class="enscript-type">int</span>			ar_arg_svipc_id;
	user_addr_t		ar_arg_svipc_addr;
	<span class="enscript-type">struct</span> posix_ipc_perm	ar_arg_pipc_perm;
	mach_port_name_t	ar_arg_mach_port1;	<span class="enscript-comment">/* darwin-only */</span>
	mach_port_name_t	ar_arg_mach_port2;	<span class="enscript-comment">/* darwin-only */</span>
	<span class="enscript-type">union</span> auditon_udata	ar_arg_auditon;
	<span class="enscript-type">char</span>			*ar_arg_argv;
	<span class="enscript-type">int</span>			ar_arg_argc;
	<span class="enscript-type">char</span>			*ar_arg_envv;
	<span class="enscript-type">int</span>			ar_arg_envc;
	<span class="enscript-type">int</span>			ar_arg_exitstatus;
	<span class="enscript-type">int</span>			ar_arg_exitretval;
	<span class="enscript-type">struct</span> sockaddr_storage ar_arg_sockaddr;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * MAC security related fields added by MAC policies ar_forced_by_mac
	 * is 1 if mac_audit_check_preselect() forced this call to be audited,
	 * 0 otherwise.
 	 */</span>
	LIST_HEAD(mac_audit_record_list_t, mac_audit_record)	*ar_mac_records;
	<span class="enscript-type">int</span>			ar_forced_by_mac;
#<span class="enscript-reference">endif</span>
};

<span class="enscript-comment">/*
 * Arguments in the audit record are initially not defined; flags are set to
 * indicate if they are present so they can be included in the audit log
 * stream only if defined.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ARG_IS_VALID</span>(kar, arg)	((kar)-&gt;k_ar.ar_valid_arg &amp; (arg))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ARG_SET_VALID</span>(kar, arg) do {					\
	(kar)-&gt;k_ar.ar_valid_arg |= (arg);				\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Current thread macro.  get_bsdthread_info() returns a void ptr for some
 * reason.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">curthread</span>()	((struct uthread *)get_bsdthread_info(current_thread()))

<span class="enscript-comment">/*
 * In-kernel version of audit record; the basic record plus queue meta-data.
 * This record can also have a pointer set to some opaque data that will be
 * passed through to the audit writing mechanism.
 */</span>
<span class="enscript-type">struct</span> kaudit_record {
	<span class="enscript-type">struct</span> audit_record		 k_ar;
	u_int32_t			 k_ar_commit;
	<span class="enscript-type">void</span>				*k_udata;	<span class="enscript-comment">/* User data. */</span>
	u_int				 k_ulen;	<span class="enscript-comment">/* User data length. */</span>
	<span class="enscript-type">struct</span> uthread			*k_uthread;	<span class="enscript-comment">/* Audited thread. */</span>
	TAILQ_ENTRY(kaudit_record)	 k_q;
};
<span class="enscript-function-name">TAILQ_HEAD</span>(kaudit_queue, kaudit_record);

<span class="enscript-comment">/*
 * Functions to manage the allocation, release, and commit of kernel audit
 * records.
 */</span>
<span class="enscript-type">void</span>			 audit_abort(<span class="enscript-type">struct</span> kaudit_record *ar);
<span class="enscript-type">void</span>			 audit_commit(<span class="enscript-type">struct</span> kaudit_record *ar, <span class="enscript-type">int</span> error,
			    <span class="enscript-type">int</span> retval);
<span class="enscript-type">struct</span> kaudit_record	*audit_new(<span class="enscript-type">int</span> event, proc_t p, <span class="enscript-type">struct</span> uthread *td);

<span class="enscript-comment">/*
 * Functions relating to the conversion of internal kernel audit records to
 * the BSM file format.
 */</span>
<span class="enscript-type">struct</span> au_record;
<span class="enscript-type">int</span>	 kaudit_to_bsm(<span class="enscript-type">struct</span> kaudit_record *kar, <span class="enscript-type">struct</span> au_record **pau);
<span class="enscript-type">int</span>	 bsm_rec_verify(<span class="enscript-type">void</span> *rec);

<span class="enscript-comment">/*
 * Kernel versions of the libbsm audit record functions.
 */</span>
<span class="enscript-type">void</span>	 kau_free(<span class="enscript-type">struct</span> au_record *rec);
<span class="enscript-type">void</span>	 kau_init(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Return values for pre-selection and post-selection decisions.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AU_PRS_SUCCESS</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AU_PRS_FAILURE</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AU_PRS_BOTH</span>	(AU_PRS_SUCCESS|AU_PRS_FAILURE)

<span class="enscript-comment">/*
 * Data structures relating to the kernel audit queue.  Ideally, these might
 * be abstracted so that only accessor methods are exposed.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> mtx		audit_mtx;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> cv		audit_watermark_cv;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> cv		audit_worker_cv;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> cv		audit_drain_cv;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> kaudit_queue	audit_q;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_q_len;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_pre_q_len;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			audit_in_failure;

<span class="enscript-comment">/*
 * Flags to use on audit files when opening and closing.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_OPEN_FLAGS</span>	(FWRITE | O_APPEND)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_CLOSE_FLAGS</span>	(FWRITE | O_APPEND)

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

<span class="enscript-comment">/*
 * Some of the BSM tokenizer functions take different parameters in the
 * kernel implementations in order to save the copying of large kernel data
 * structures.  The prototypes of these functions are declared here.
 */</span>
token_t		*kau_to_socket(<span class="enscript-type">struct</span> socket_au_info *soi);

<span class="enscript-comment">/*
 * audit_klib prototypes
 */</span>
<span class="enscript-type">int</span>		 au_preselect(au_event_t event, au_class_t class,
		    au_mask_t *mask_p, <span class="enscript-type">int</span> sorf);
<span class="enscript-type">void</span>		 au_evclassmap_init(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>		 au_evclassmap_insert(au_event_t event, au_class_t class);
au_class_t	 au_event_class(au_event_t event);
au_event_t	 audit_ctlname_to_sysctlevent(<span class="enscript-type">int</span> name[], uint64_t valid_arg);
au_event_t	 audit_flags_and_error_to_openevent(<span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error);
au_event_t	 audit_flags_and_error_to_openextendedevent(<span class="enscript-type">int</span> oflags,
		    <span class="enscript-type">int</span> error);
au_event_t	 audit_flags_and_error_to_openatevent(<span class="enscript-type">int</span> oflags,
		    <span class="enscript-type">int</span> error);
au_event_t	 audit_flags_and_error_to_openbyidevent(<span class="enscript-type">int</span> oflags,
		    <span class="enscript-type">int</span> error);
au_event_t	 audit_msgctl_to_event(<span class="enscript-type">int</span> cmd);
au_event_t	 audit_semctl_to_event(<span class="enscript-type">int</span> cmr);
<span class="enscript-type">int</span>		 audit_canon_path(<span class="enscript-type">struct</span> vnode *cwd_vp, <span class="enscript-type">char</span> *path,
		    <span class="enscript-type">char</span> *cpath);
au_event_t	 auditon_command_event(<span class="enscript-type">int</span> cmd);
au_event_t	 audit_fcntl_command_event(<span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> oflags, <span class="enscript-type">int</span> error);

<span class="enscript-comment">/*
 * Audit trigger events notify user space of kernel audit conditions
 * asynchronously.
 */</span>
<span class="enscript-type">int</span>		 audit_send_trigger(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> trigger);

<span class="enscript-comment">/*
 * Accessor functions to manage global audit state.
 */</span>
<span class="enscript-type">void</span>		audit_set_kinfo(<span class="enscript-type">struct</span> auditinfo_addr *);
<span class="enscript-type">void</span>		audit_get_kinfo(<span class="enscript-type">struct</span> auditinfo_addr *);

<span class="enscript-comment">/*
 * General audit related functions.
 */</span>
<span class="enscript-type">struct</span> kaudit_record	*currecord(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>			 audit_free(<span class="enscript-type">struct</span> kaudit_record *ar);
<span class="enscript-type">void</span>			 audit_rotate_vnode(<span class="enscript-type">struct</span> ucred *cred,
			    <span class="enscript-type">struct</span> vnode *vp);
<span class="enscript-type">void</span>			 audit_worker_init(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * Audit pipe functions.
 */</span>
<span class="enscript-type">int</span>	 audit_pipe_init(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	 audit_pipe_shutdown(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	 audit_pipe_preselect(au_id_t auid, au_event_t event,
	    au_class_t class, <span class="enscript-type">int</span> sorf, <span class="enscript-type">int</span> trail_select);
<span class="enscript-type">void</span>	 audit_pipe_submit(au_id_t auid, au_event_t event, au_class_t class,
	    <span class="enscript-type">int</span> sorf, <span class="enscript-type">int</span> trail_select, <span class="enscript-type">void</span> *record, u_int record_len);
<span class="enscript-type">void</span>	 audit_pipe_submit_user(<span class="enscript-type">void</span> *record, u_int record_len);

<span class="enscript-comment">/*
 * Audit MAC prototypes.
 */</span>
<span class="enscript-type">void</span>	audit_mac_init(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	audit_mac_new(proc_t p, <span class="enscript-type">struct</span> kaudit_record *ar);
<span class="enscript-type">void</span>	audit_mac_free(<span class="enscript-type">struct</span> kaudit_record *ar);
<span class="enscript-type">int</span>	audit_mac_syscall_enter(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> code, proc_t p,
	    <span class="enscript-type">struct</span> uthread *uthread, kauth_cred_t my_cred, au_event_t event);
<span class="enscript-type">int</span>	audit_mac_syscall_exit(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span> code, <span class="enscript-type">struct</span> uthread *uthread,
	    <span class="enscript-type">int</span> error, <span class="enscript-type">int</span> retval);

<span class="enscript-comment">/*
 * Audit Session.
 */</span>
<span class="enscript-type">void</span>	audit_session_init(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> 	audit_session_setaia(proc_t p, auditinfo_addr_t *aia_p);
auditinfo_addr_t *<span class="enscript-function-name">audit_session_update</span>(auditinfo_addr_t *new_aia);
<span class="enscript-type">int</span>	audit_session_lookup(au_asid_t asid, auditinfo_addr_t *ret_aia);

<span class="enscript-comment">/*
 * Kernel assigned audit session IDs start at PID_MAX + 1 and ends at
 * ASSIGNED_ASID_MAX.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ASSIGNED_ASID_MIN</span>	(PID_MAX + 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ASSIGNED_ASID_MAX</span>	(0xFFFFFFFF - 1)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(KERNEL) || defined(_KERNEL) */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! _SECURITY_AUDIT_PRIVATE_H_ */</span>
</pre>
<hr />
</body></html>