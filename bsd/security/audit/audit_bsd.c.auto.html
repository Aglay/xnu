<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>audit_bsd.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">audit_bsd.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*-
 * Copyright (c) 2008-2010 Apple Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1.  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 * 2.  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 *     its contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;bsm/audit_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_bsd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit_private.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/audit_triggers_server.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
<span class="enscript-type">struct</span> mhdr {
	size_t 		 	 mh_size;
	au_malloc_type_t 	*mh_type;
	u_long			 mh_magic;
	<span class="enscript-type">char</span>		 	 mh_data[0];
};

<span class="enscript-comment">/*
 * The lock group for the audit subsystem. 
 */</span>
<span class="enscript-type">static</span> lck_grp_t *audit_lck_grp = NULL;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_MHMAGIC</span>	0x4D656C53

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AUDIT_MALLOC_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AU_MAX_SHORTDESC</span>	20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AU_MAX_LASTCALLER</span>	20
<span class="enscript-type">struct</span> au_malloc_debug_info {
	SInt64		md_size;
	SInt64		md_maxsize;
	SInt32		md_inuse;
	SInt32		md_maxused;
	<span class="enscript-type">unsigned</span> 	md_type;
	<span class="enscript-type">unsigned</span>	md_magic;
	<span class="enscript-type">char</span>		md_shortdesc[AU_MAX_SHORTDESC];
	<span class="enscript-type">char</span>		md_lastcaller[AU_MAX_LASTCALLER];
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> au_malloc_debug_info   au_malloc_debug_info_t;

au_malloc_type_t	*audit_malloc_types[NUM_MALLOC_TYPES];

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">audit_sysctl_malloc_debug</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1,
    <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, audit_malloc_debug, CTLFLAG_RD, NULL, 0,
    audit_sysctl_malloc_debug, <span class="enscript-string">&quot;S,audit_malloc_debug&quot;</span>,
    <span class="enscript-string">&quot;Current malloc debug info for auditing.&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AU_MALLOC_DBINFO_SZ</span> \
    (NUM_MALLOC_TYPES * <span class="enscript-keyword">sizeof</span>(au_malloc_debug_info_t))

<span class="enscript-comment">/*
 * Copy out the malloc debug info via the sysctl interface.  The userland code 
 * is something like the following:
 *
 *  error = sysctlbyname(&quot;kern.audit_malloc_debug&quot;, buffer_ptr, &amp;buffer_len,
 *             NULL, 0);
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">audit_sysctl_malloc_debug</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
    __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> i;
	size_t sz;
	au_malloc_debug_info_t *amdi_ptr, *nxt_ptr;
	<span class="enscript-type">int</span> err;

	<span class="enscript-comment">/*
	 * This provides a read-only node.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/*
	 * If just querying then return the space required. 
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = AU_MALLOC_DBINFO_SZ; 
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 *  Alloc a temporary buffer.
	 */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldlen &lt; AU_MALLOC_DBINFO_SZ)
		<span class="enscript-keyword">return</span> (ENOMEM);
	amdi_ptr = (au_malloc_debug_info_t *)kalloc(AU_MALLOC_DBINFO_SZ);
	<span class="enscript-keyword">if</span> (amdi_ptr == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	bzero(amdi_ptr, AU_MALLOC_DBINFO_SZ);

	<span class="enscript-comment">/*
	 * Build the record array. 
	 */</span>
	sz = 0;
	nxt_ptr = amdi_ptr;
	<span class="enscript-keyword">for</span>(i = 0; i &lt; NUM_MALLOC_TYPES; i++) {
		<span class="enscript-keyword">if</span> (audit_malloc_types[i] == NULL)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (audit_malloc_types[i]-&gt;mt_magic != M_MAGIC) {
			nxt_ptr-&gt;md_magic = audit_malloc_types[i]-&gt;mt_magic;
			<span class="enscript-keyword">continue</span>;
		}
		nxt_ptr-&gt;md_magic = audit_malloc_types[i]-&gt;mt_magic;
		nxt_ptr-&gt;md_size = audit_malloc_types[i]-&gt;mt_size;
		nxt_ptr-&gt;md_maxsize = audit_malloc_types[i]-&gt;mt_maxsize;
		nxt_ptr-&gt;md_inuse = (<span class="enscript-type">int</span>)audit_malloc_types[i]-&gt;mt_inuse;
		nxt_ptr-&gt;md_maxused = (<span class="enscript-type">int</span>)audit_malloc_types[i]-&gt;mt_maxused;
		strlcpy(nxt_ptr-&gt;md_shortdesc,
		    audit_malloc_types[i]-&gt;mt_shortdesc, AU_MAX_SHORTDESC - 1);
		strlcpy(nxt_ptr-&gt;md_lastcaller,
		    audit_malloc_types[i]-&gt;mt_lastcaller, AU_MAX_LASTCALLER-1);
		sz += <span class="enscript-keyword">sizeof</span>(au_malloc_debug_info_t);
		nxt_ptr++;
	}

	req-&gt;oldlen = sz;
	err = SYSCTL_OUT(req, amdi_ptr, sz);
	kfree(amdi_ptr, AU_MALLOC_DBINFO_SZ);

	<span class="enscript-keyword">return</span> (err);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* AUDIT_MALLOC_DEBUG */</span>
	
<span class="enscript-comment">/*
 * BSD malloc()
 * 
 * If the M_NOWAIT flag is set then it may not block and return NULL.
 * If the M_ZERO flag is set then zero out the buffer.
 */</span>
<span class="enscript-type">void</span> *
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AUDIT_MALLOC_DEBUG</span>
<span class="enscript-function-name">_audit_malloc</span>(size_t size, au_malloc_type_t *type, <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fn)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_malloc</span>(size_t size, au_malloc_type_t *type, <span class="enscript-type">int</span> flags)
#<span class="enscript-reference">endif</span>
{
	<span class="enscript-type">struct</span> mhdr	*hdr;
	size_t	memsize = <span class="enscript-keyword">sizeof</span> (*hdr) + size;

	<span class="enscript-keyword">if</span> (size == 0)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">if</span> (flags &amp; M_NOWAIT) {
		hdr = (<span class="enscript-type">void</span> *)kalloc_noblock(memsize);
	} <span class="enscript-keyword">else</span> {
		hdr = (<span class="enscript-type">void</span> *)kalloc(memsize);
		<span class="enscript-keyword">if</span> (hdr == NULL)
			panic(<span class="enscript-string">&quot;_audit_malloc: kernel memory exhausted&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (hdr == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	hdr-&gt;mh_size = memsize;
	hdr-&gt;mh_type = type;
	hdr-&gt;mh_magic = AUDIT_MHMAGIC;
	<span class="enscript-keyword">if</span> (flags &amp; M_ZERO)
		memset(hdr-&gt;mh_data, 0, size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AUDIT_MALLOC_DEBUG</span>
	<span class="enscript-keyword">if</span> (type != NULL &amp;&amp; type-&gt;mt_type &lt; NUM_MALLOC_TYPES) {
		OSAddAtomic64(memsize, &amp;type-&gt;mt_size);
		type-&gt;mt_maxsize = max(type-&gt;mt_size, type-&gt;mt_maxsize);
		OSAddAtomic(1, &amp;type-&gt;mt_inuse);
		type-&gt;mt_maxused = max(type-&gt;mt_inuse, type-&gt;mt_maxused);
		type-&gt;mt_lastcaller = fn;
		audit_malloc_types[type-&gt;mt_type] = type;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* AUDIT_MALLOC_DEBUG */</span>
	<span class="enscript-keyword">return</span> (hdr-&gt;mh_data);
}

<span class="enscript-comment">/*
 * BSD free()
 */</span>
<span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AUDIT_MALLOC_DEBUG</span>
<span class="enscript-function-name">_audit_free</span>(<span class="enscript-type">void</span> *addr, au_malloc_type_t *type)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_free</span>(<span class="enscript-type">void</span> *addr, __unused au_malloc_type_t *type)
#<span class="enscript-reference">endif</span>
{
	<span class="enscript-type">struct</span> mhdr *hdr;
	
	<span class="enscript-keyword">if</span> (addr == NULL)
		<span class="enscript-keyword">return</span>;
	hdr = addr; hdr--;

	KASSERT(hdr-&gt;mh_magic == AUDIT_MHMAGIC,
	    (<span class="enscript-string">&quot;_audit_free(): hdr-&gt;mh_magic != AUDIT_MHMAGIC&quot;</span>));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">AUDIT_MALLOC_DEBUG</span>
	<span class="enscript-keyword">if</span> (type != NULL) {
		OSAddAtomic64(-hdr-&gt;mh_size, &amp;type-&gt;mt_size);
		OSAddAtomic(-1, &amp;type-&gt;mt_inuse);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* AUDIT_MALLOC_DEBUG */</span>
	kfree(hdr, hdr-&gt;mh_size);
}

<span class="enscript-comment">/*
 * Initialize a condition variable.  Must be called before use.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_cv_init</span>(<span class="enscript-type">struct</span> cv *cvp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *desc)
{

	<span class="enscript-keyword">if</span> (desc == NULL)
		cvp-&gt;cv_description = <span class="enscript-string">&quot;UNKNOWN&quot;</span>;
	<span class="enscript-keyword">else</span>
		cvp-&gt;cv_description = desc;
	cvp-&gt;cv_waiters = 0;
}

<span class="enscript-comment">/*
 *  Destory a condition variable.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_cv_destroy</span>(<span class="enscript-type">struct</span> cv *cvp)
{

	cvp-&gt;cv_description = NULL;
	cvp-&gt;cv_waiters = 0;
}

<span class="enscript-comment">/*
 * Signal a condition variable, wakes up one waiting thread.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_cv_signal</span>(<span class="enscript-type">struct</span> cv *cvp)
{

	<span class="enscript-keyword">if</span> (cvp-&gt;cv_waiters &gt; 0) {
		wakeup_one((caddr_t)cvp);
		cvp-&gt;cv_waiters--;
	}
}

<span class="enscript-comment">/*
 * Broadcast a signal to a condition variable.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_cv_broadcast</span>(<span class="enscript-type">struct</span> cv *cvp)
{

	<span class="enscript-keyword">if</span> (cvp-&gt;cv_waiters &gt; 0) {
		wakeup((caddr_t)cvp);
		cvp-&gt;cv_waiters = 0;
	}
}

<span class="enscript-comment">/*
 * Wait on a condition variable. A cv_signal or cv_broadcast on the same
 * condition variable will resume the thread. It is recommended that the mutex
 * be held when cv_signal or cv_broadcast are called.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_cv_wait</span>(<span class="enscript-type">struct</span> cv *cvp, lck_mtx_t *mp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *desc)
{

	cvp-&gt;cv_waiters++;
	(<span class="enscript-type">void</span>) msleep(cvp, mp, PZERO, desc, 0);
}

<span class="enscript-comment">/*
 * Wait on a condition variable, allowing interruption by signals.  Return 0
 * if the thread was resumed with cv_signal or cv_broadcast, EINTR or
 * ERESTART if a signal was caught.  If ERESTART is returned the system call
 * should be restarted if possible.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">_audit_cv_wait_sig</span>(<span class="enscript-type">struct</span> cv *cvp, lck_mtx_t *mp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *desc)
{

	cvp-&gt;cv_waiters++;
	<span class="enscript-keyword">return</span> (msleep(cvp, mp, PSOCK | PCATCH, desc, 0));
}

<span class="enscript-comment">/*
 * BSD Mutexes.
 */</span>
<span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-function-name">_audit_mtx_init</span>(<span class="enscript-type">struct</span> mtx *mp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_mtx_init</span>(<span class="enscript-type">struct</span> mtx *mp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">endif</span>
{
	mp-&gt;mtx_lock = lck_mtx_alloc_init(audit_lck_grp, LCK_ATTR_NULL);
	KASSERT(mp-&gt;mtx_lock != NULL, 
	    (<span class="enscript-string">&quot;_audit_mtx_init: Could not allocate a mutex.&quot;</span>));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	strlcpy(mp-&gt;mtx_name, lckname, AU_MAX_LCK_NAME);	
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_mtx_destroy</span>(<span class="enscript-type">struct</span> mtx *mp)
{

	<span class="enscript-keyword">if</span> (mp-&gt;mtx_lock) {
		lck_mtx_free(mp-&gt;mtx_lock, audit_lck_grp);
		mp-&gt;mtx_lock = NULL;
	}
}

<span class="enscript-comment">/*
 * BSD rw locks.
 */</span>
<span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-function-name">_audit_rw_init</span>(<span class="enscript-type">struct</span> rwlock *lp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_rw_init</span>(<span class="enscript-type">struct</span> rwlock *lp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">endif</span>
{
	lp-&gt;rw_lock = lck_rw_alloc_init(audit_lck_grp, LCK_ATTR_NULL);
	KASSERT(lp-&gt;rw_lock != NULL, 
	    (<span class="enscript-string">&quot;_audit_rw_init: Could not allocate a rw lock.&quot;</span>));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	strlcpy(lp-&gt;rw_name, lckname, AU_MAX_LCK_NAME);	
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_rw_destroy</span>(<span class="enscript-type">struct</span> rwlock *lp)
{

	<span class="enscript-keyword">if</span> (lp-&gt;rw_lock) {
		lck_rw_free(lp-&gt;rw_lock, audit_lck_grp);
		lp-&gt;rw_lock = NULL;
	}
}
<span class="enscript-comment">/*
 * Wait on a condition variable in a continuation (i.e. yield kernel stack).
 * A cv_signal or cv_broadcast on the same condition variable will cause
 * the thread to be scheduled.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">_audit_cv_wait_continuation</span>(<span class="enscript-type">struct</span> cv *cvp, lck_mtx_t *mp, thread_continue_t function)
{
	<span class="enscript-type">int</span> status = KERN_SUCCESS;

	cvp-&gt;cv_waiters++;
	assert_wait(cvp, THREAD_UNINT);
	lck_mtx_unlock(mp);

	status = thread_block(function);

	<span class="enscript-comment">/* should not be reached, but just in case, re-lock */</span>
	lck_mtx_lock(mp);

	<span class="enscript-keyword">return</span> status;
}

<span class="enscript-comment">/*
 * Simple recursive lock. 
 */</span>
<span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-function-name">_audit_rlck_init</span>(<span class="enscript-type">struct</span> rlck *lp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_rlck_init</span>(<span class="enscript-type">struct</span> rlck *lp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">endif</span>
{

	lp-&gt;rl_mtx = lck_mtx_alloc_init(audit_lck_grp, LCK_ATTR_NULL);
	KASSERT(lp-&gt;rl_mtx != NULL, 
	    (<span class="enscript-string">&quot;_audit_rlck_init: Could not allocate a recursive lock.&quot;</span>));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	strlcpy(lp-&gt;rl_name, lckname, AU_MAX_LCK_NAME);	
#<span class="enscript-reference">endif</span>
	lp-&gt;rl_thread = 0;
	lp-&gt;rl_recurse = 0;
}

<span class="enscript-comment">/*
 * Recursive lock.  Allow same thread to recursively lock the same lock.
 */</span> 
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_rlck_lock</span>(<span class="enscript-type">struct</span> rlck *lp)
{

	<span class="enscript-keyword">if</span> (lp-&gt;rl_thread == current_thread()) {
		OSAddAtomic(1, &amp;lp-&gt;rl_recurse);
		KASSERT(lp-&gt;rl_recurse &lt; 10000,
		    (<span class="enscript-string">&quot;_audit_rlck_lock: lock nested too deep.&quot;</span>));
	} <span class="enscript-keyword">else</span> {
		lck_mtx_lock(lp-&gt;rl_mtx);
		lp-&gt;rl_thread = current_thread();
		lp-&gt;rl_recurse = 1;
	}
}

<span class="enscript-comment">/*
 * Recursive unlock.  It should be the same thread that does the unlock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_rlck_unlock</span>(<span class="enscript-type">struct</span> rlck *lp)
{
	KASSERT(lp-&gt;rl_thread == current_thread(), 
	    (<span class="enscript-string">&quot;_audit_rlck_unlock(): Don't own lock.&quot;</span>));

	<span class="enscript-comment">/* Note: OSAddAtomic returns old value. */</span>
	<span class="enscript-keyword">if</span> (OSAddAtomic(-1, &amp;lp-&gt;rl_recurse) == 1) {
		lp-&gt;rl_thread = 0;
		lck_mtx_unlock(lp-&gt;rl_mtx);
	}
}
		
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_rlck_destroy</span>(<span class="enscript-type">struct</span> rlck *lp)
{

	<span class="enscript-keyword">if</span> (lp-&gt;rl_mtx) {
		lck_mtx_free(lp-&gt;rl_mtx, audit_lck_grp);
		lp-&gt;rl_mtx = NULL;
	}
}

<span class="enscript-comment">/*
 * Recursive lock assert.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_rlck_assert</span>(<span class="enscript-type">struct</span> rlck *lp, u_int assert)
{
	thread_t cthd = current_thread();
	
	<span class="enscript-keyword">if</span> (assert == LCK_MTX_ASSERT_OWNED &amp;&amp; lp-&gt;rl_thread == cthd)
		panic(<span class="enscript-string">&quot;recursive lock (%p) not held by this thread (%p).&quot;</span>,
		    lp, cthd);
	<span class="enscript-keyword">if</span> (assert == LCK_MTX_ASSERT_NOTOWNED &amp;&amp; lp-&gt;rl_thread != 0)
		panic(<span class="enscript-string">&quot;recursive lock (%p) held by thread (%p).&quot;</span>,
		    lp, cthd);
}

<span class="enscript-comment">/*
 * Simple sleep lock.
 */</span>
<span class="enscript-type">void</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
<span class="enscript-function-name">_audit_slck_init</span>(<span class="enscript-type">struct</span> slck *lp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">_audit_slck_init</span>(<span class="enscript-type">struct</span> slck *lp, __unused <span class="enscript-type">const</span> <span class="enscript-type">char</span> *lckname)
#<span class="enscript-reference">endif</span>
{

	lp-&gt;sl_mtx = lck_mtx_alloc_init(audit_lck_grp, LCK_ATTR_NULL);
	KASSERT(lp-&gt;sl_mtx != NULL, 
	    (<span class="enscript-string">&quot;_audit_slck_init: Could not allocate a sleep lock.&quot;</span>));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	strlcpy(lp-&gt;sl_name, lckname, AU_MAX_LCK_NAME);	
#<span class="enscript-reference">endif</span>
	lp-&gt;sl_locked = 0;
	lp-&gt;sl_waiting = 0;
}

<span class="enscript-comment">/*
 * Sleep lock lock.  The 'intr' flag determines if the lock is interruptible.
 * If 'intr' is true then signals or other events can interrupt the sleep lock. 
 */</span>
wait_result_t
<span class="enscript-function-name">_audit_slck_lock</span>(<span class="enscript-type">struct</span> slck *lp, <span class="enscript-type">int</span> intr)
{
	wait_result_t res = THREAD_AWAKENED;

	lck_mtx_lock(lp-&gt;sl_mtx);
	<span class="enscript-keyword">while</span> (lp-&gt;sl_locked &amp;&amp; res == THREAD_AWAKENED) {
		lp-&gt;sl_waiting = 1;
		res = lck_mtx_sleep(lp-&gt;sl_mtx, LCK_SLEEP_DEFAULT,
		   (event_t) lp, (intr) ? THREAD_INTERRUPTIBLE : THREAD_UNINT);
	}
	<span class="enscript-keyword">if</span> (res == THREAD_AWAKENED)
		lp-&gt;sl_locked = 1;
	lck_mtx_unlock(lp-&gt;sl_mtx);
	
	<span class="enscript-keyword">return</span> (res);
}

<span class="enscript-comment">/*
 * Sleep lock unlock.  Wake up all the threads waiting for this lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_slck_unlock</span>(<span class="enscript-type">struct</span> slck *lp)
{
	
	lck_mtx_lock(lp-&gt;sl_mtx);
	lp-&gt;sl_locked = 0;
	<span class="enscript-keyword">if</span> (lp-&gt;sl_waiting) {
		lp-&gt;sl_waiting = 0;

		<span class="enscript-comment">/* Wake up *all* sleeping threads. */</span>
		wakeup((event_t) lp);
	}
	lck_mtx_unlock(lp-&gt;sl_mtx);
}

<span class="enscript-comment">/*
 * Sleep lock try.  Don't sleep if it doesn't get the lock. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">_audit_slck_trylock</span>(<span class="enscript-type">struct</span> slck *lp)
{
	<span class="enscript-type">int</span> result;

	lck_mtx_lock(lp-&gt;sl_mtx);
	result = !lp-&gt;sl_locked;
	<span class="enscript-keyword">if</span> (result)
		lp-&gt;sl_locked = 1;
	lck_mtx_unlock(lp-&gt;sl_mtx);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Sleep lock assert.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_slck_assert</span>(<span class="enscript-type">struct</span> slck *lp, u_int assert)
{

	<span class="enscript-keyword">if</span> (assert == LCK_MTX_ASSERT_OWNED &amp;&amp; lp-&gt;sl_locked == 0)
		panic(<span class="enscript-string">&quot;sleep lock (%p) not held.&quot;</span>, lp);
	<span class="enscript-keyword">if</span> (assert == LCK_MTX_ASSERT_NOTOWNED &amp;&amp; lp-&gt;sl_locked == 1)
		panic(<span class="enscript-string">&quot;sleep lock (%p) held.&quot;</span>, lp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_slck_destroy</span>(<span class="enscript-type">struct</span> slck *lp)
{

	<span class="enscript-keyword">if</span> (lp-&gt;sl_mtx) {
		lck_mtx_free(lp-&gt;sl_mtx, audit_lck_grp);
		lp-&gt;sl_mtx = NULL;
	}
}

<span class="enscript-comment">/*
 * XXXss - This code was taken from bsd/netinet6/icmp6.c.  Maybe ppsratecheck()
 * should be made global in icmp6.c.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">timersub</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">timersub</span>(tvp, uvp, vvp)                                         \
        <span class="enscript-keyword">do</span> {                                                            \
                (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec;          \
                (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec;       \
                <span class="enscript-keyword">if</span> ((vvp)-&gt;tv_usec &lt; 0) {                               \
                        (vvp)-&gt;tv_sec--;                                \
                        (vvp)-&gt;tv_usec += 1000000;                      \
                }                                                       \
        } <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Packets (or events) per second limitation.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">_audit_ppsratecheck</span>(<span class="enscript-type">struct</span> timeval *lasttime, <span class="enscript-type">int</span> *curpps, <span class="enscript-type">int</span> maxpps)
{
	<span class="enscript-type">struct</span> timeval tv, delta;
	<span class="enscript-type">int</span> rv;

	microtime(&amp;tv);

	timersub(&amp;tv, lasttime, &amp;delta);

	<span class="enscript-comment">/*
	 * Check for 0,0 so that the message will be seen at least once.
	 * If more than one second has passed since the last update of
	 * lasttime, reset the counter.
	 *
	 * we do increment *curpps even in *curpps &lt; maxpps case, as some may
	 * try to use *curpps for stat purposes as well.
	 */</span>
	<span class="enscript-keyword">if</span> ((lasttime-&gt;tv_sec == 0 &amp;&amp; lasttime-&gt;tv_usec == 0) ||
	    delta.tv_sec &gt;= 1) {
		*lasttime = tv;
		*curpps = 0;
		rv = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (maxpps &lt; 0)
		rv = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*curpps &lt; maxpps)
		rv = 1;
	<span class="enscript-keyword">else</span>
		rv = 0;
	<span class="enscript-keyword">if</span> (*curpps + 1 &gt; 0)
		*curpps = *curpps + 1;

	<span class="enscript-keyword">return</span> (rv);	
}

<span class="enscript-comment">/*
 * Initialize lock group for audit related locks/mutexes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">_audit_lck_grp_init</span>(<span class="enscript-type">void</span>)
{
	audit_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;Audit&quot;</span>, LCK_GRP_ATTR_NULL);

	KASSERT(audit_lck_grp != NULL,
	    (<span class="enscript-string">&quot;audit_get_lck_grp: Could not allocate the audit lock group.&quot;</span>));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">audit_send_trigger</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> trigger)
{
	mach_port_t audit_port;
	<span class="enscript-type">int</span> error;

	error = host_get_audit_control_port(host_priv_self(), &amp;audit_port);
	<span class="enscript-keyword">if</span> (error == KERN_SUCCESS &amp;&amp; audit_port != MACH_PORT_NULL) {
		audit_triggers(audit_port, trigger);
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;Cannot get audit control port\n&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_AUDIT */</span>
</pre>
<hr />
</body></html>