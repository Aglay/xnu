<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_catalog.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_catalog.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__HFS_CATALOG__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__HFS_CATALOG__</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_format.h&gt;</span>

<span class="enscript-comment">/* HFS Catalog */</span>


<span class="enscript-comment">/*
 * Catalog ADTs
 *
 * The cat_desc, cat_attr, and cat_fork structures are
 * use to import/export data to/from the Catalog file.
 * The fields in these structures are always in BSD
 * runtime format (e.g. dates and names).
 */</span>
 
<span class="enscript-type">typedef</span> u_int32_t	cnid_t;

<span class="enscript-comment">/*
 * Catalog Node Descriptor (runtime)
 */</span>
<span class="enscript-type">struct</span> cat_desc {
	u_int8_t  cd_flags;       <span class="enscript-comment">/* see below (8 bits) */</span>
	u_int8_t  cd_encoding;    <span class="enscript-comment">/* name encoding */</span>
	int16_t   cd_namelen;     <span class="enscript-comment">/* length of cnode name */</span>
	cnid_t    cd_parentcnid;  <span class="enscript-comment">/* parent directory CNID */</span>
	u_int32_t    cd_hint;        <span class="enscript-comment">/* catalog file hint */</span>
	cnid_t    cd_cnid;        <span class="enscript-comment">/* cnode id (for getattrlist) */</span>
	<span class="enscript-type">const</span> u_int8_t * cd_nameptr; <span class="enscript-comment">/* pointer to cnode name */</span>
};

<span class="enscript-comment">/* cd_flags
 *
 * CD_EOF is used by hfs_vnop_readdir / cat_getdirentries to indicate EOF was
 * encountered during a directory enumeration.  When this flag is observed
 * on the next call to hfs_vnop_readdir it tells the caller that there's no
 * need to descend into the catalog as EOF was encountered during the last call.
 * This flag should only be set on the descriptor embedded in the directoryhint. 
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CD_HASBUF</span>	0x01	<span class="enscript-comment">/* allocated filename buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CD_DECOMPOSED</span>	0x02	<span class="enscript-comment">/* name is fully decomposed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CD_EOF</span>		0x04	<span class="enscript-comment">/* see above */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CD_ISMETA</span>	0x40	<span class="enscript-comment">/* describes a metadata file */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CD_ISDIR</span>	0x80	<span class="enscript-comment">/* describes a directory */</span>

<span class="enscript-comment">/*
 * Catalog Node Attributes (runtime)
 */</span>
<span class="enscript-type">struct</span> cat_attr {
	cnid_t		ca_fileid;	<span class="enscript-comment">/* inode number (for stat) normally == cnid */</span>
	mode_t		ca_mode;	<span class="enscript-comment">/* file access mode and type (16 bits) */</span>
	u_int16_t	ca_recflags;	<span class="enscript-comment">/* catalog record flags (16 bit integer) */</span>
	u_int32_t	ca_linkcount;	<span class="enscript-comment">/* real hard link count */</span>
	uid_t		ca_uid;		<span class="enscript-comment">/* file owner */</span>
	gid_t		ca_gid;		<span class="enscript-comment">/* file group */</span>
	<span class="enscript-type">union</span> {
	    dev_t	cau_rdev;	<span class="enscript-comment">/* special file device (VBLK or VCHAR only) */</span>
	    u_int32_t	cau_linkref;	<span class="enscript-comment">/* hardlink reference number */</span>
	} ca_union1;
	time_t		ca_atime;	<span class="enscript-comment">/* last access time */</span>
	time_t		ca_atimeondisk;	<span class="enscript-comment">/* access time value on disk */</span>
	time_t		ca_mtime;	<span class="enscript-comment">/* last data modification time */</span>
	time_t		ca_ctime;	<span class="enscript-comment">/* last file status change */</span>
	time_t		ca_itime;	<span class="enscript-comment">/* file initialization time */</span>
	time_t		ca_btime;	<span class="enscript-comment">/* last backup time */</span>
	u_int32_t	ca_flags;	<span class="enscript-comment">/* status flags (chflags) */</span>
	<span class="enscript-type">union</span> {
	    u_int32_t	cau_blocks;	<span class="enscript-comment">/* total file blocks used (rsrc + data) */</span>
	    u_int32_t	cau_entries;	<span class="enscript-comment">/* total directory entries (valence) */</span>
	} ca_union2;
	<span class="enscript-type">union</span> {
	    u_int32_t	cau_dircount;	<span class="enscript-comment">/* count of sub dirs (for posix nlink) */</span>
	    u_int32_t	cau_firstlink;	<span class="enscript-comment">/* first hardlink link (files only) */</span>
	} ca_union3;
	<span class="enscript-type">union</span> {
		u_int8_t 	ca_finderinfo[32]; <span class="enscript-comment">/* Opaque Finder information */</span>
		<span class="enscript-type">struct</span> {
			FndrFileInfo 					ca_finderfileinfo;
			<span class="enscript-type">struct</span> FndrExtendedFileInfo 	ca_finderextendedfileinfo;
		};
		<span class="enscript-type">struct</span> {
			FndrDirInfo 					ca_finderdirinfo;
			<span class="enscript-type">struct</span> FndrExtendedDirInfo 		ca_finderextendeddirinfo;
		};
	};
};

<span class="enscript-comment">/* Aliases for common fields */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_rdev</span>		ca_union1.cau_rdev	
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_linkref</span>	ca_union1.cau_linkref
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_blocks</span>	ca_union2.cau_blocks
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_entries</span>	ca_union2.cau_entries
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_dircount</span>	ca_union3.cau_dircount
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ca_firstlink</span>	ca_union3.cau_firstlink

<span class="enscript-comment">/*
 * Catalog Node Fork (runtime)
 *
 * NOTE: this is not the same as a struct HFSPlusForkData
 *
 * NOTE: if cf_new_size &gt; cf_size, then a write is in progress and is extending
 * the EOF; the new EOF will be cf_new_size.  Writes and pageouts may validly
 * write up to cf_new_size, but reads should only read up to cf_size.  When
 * an extending write is not in progress, cf_new_size is zero.
 */</span>
<span class="enscript-type">struct</span> cat_fork {
	off_t          cf_size;        <span class="enscript-comment">/* fork's logical size in bytes */</span>
	off_t          cf_new_size;    <span class="enscript-comment">/* fork's logical size after write completes */</span>
	<span class="enscript-type">union</span> {
	    u_int32_t  cfu_clump;      <span class="enscript-comment">/* fork's clump size in bytes (sys files only) */</span>
	    u_int64_t  cfu_bytesread;  <span class="enscript-comment">/* bytes read from this fork */</span>
	} cf_union;
	u_int32_t      cf_vblocks;     <span class="enscript-comment">/* virtual (unalloated) blocks */</span>
	u_int32_t      cf_blocks;      <span class="enscript-comment">/* total blocks used by this fork */</span>
	<span class="enscript-type">struct</span> HFSPlusExtentDescriptor  cf_extents[8];  <span class="enscript-comment">/* initial set of extents */</span>

	<span class="enscript-comment">/*
	 * NOTE: If you change this structure, make sure you change you change
	 * hfs_fork_copy.
	 */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cf_clump</span>	cf_union.cfu_clump
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">cf_bytesread</span>	cf_union.cfu_bytesread

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_fork_copy</span>(<span class="enscript-type">struct</span> cat_fork *dst, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *src,
				   HFSPlusExtentDescriptor *extents);

<span class="enscript-comment">/*
 * Directory Hint
 * Used to hold state across directory enumerations.
 *
 */</span>
<span class="enscript-type">struct</span> directoryhint {
	TAILQ_ENTRY(directoryhint) dh_link; <span class="enscript-comment">/* chain */</span>
	<span class="enscript-type">int</span>     dh_index;                   <span class="enscript-comment">/* index into directory (zero relative) */</span>
	u_int32_t  dh_threadhint;           <span class="enscript-comment">/* node hint of a directory's thread record */</span>
	u_int32_t  dh_time;
	<span class="enscript-type">struct</span>  cat_desc  dh_desc;          <span class="enscript-comment">/* entry's descriptor */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> directoryhint directoryhint_t;

<span class="enscript-comment">/* 
 * HFS_MAXDIRHINTS cannot be larger than 63 without reducing
 * HFS_INDEX_BITS, because given the 6-bit tag, at most 63 different
 * tags can exist.  When HFS_MAXDIRHINTS is larger than 63, the same
 * list may contain dirhints of the same tag, and a staled dirhint may
 * be returned.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MAXDIRHINTS</span> 32
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_DIRHINT_TTL</span> 45

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_INDEX_MASK</span>  0x03ffffff
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_INDEX_BITS</span>  26


<span class="enscript-comment">/*
 * Catalog Node Entry
 *
 * A cat_entry is used for bulk enumerations (hfs_readdirattr).
 */</span>
<span class="enscript-type">struct</span> cat_entry {
	<span class="enscript-type">struct</span> cat_desc	ce_desc;
	<span class="enscript-type">struct</span> cat_attr	ce_attr;
	off_t		ce_datasize;
	off_t		ce_rsrcsize;
	u_int32_t		ce_datablks;
	u_int32_t		ce_rsrcblks;
};

<span class="enscript-comment">/*
 * Starting in 10.5, hfs_vnop_readdirattr() only makes one
 * call to cat_getentriesattr(). So we increased MAXCATENTRIES
 * while keeping the total size of the CE LIST buffer &lt;= 8K
 * (which works out to be 60 entries per call).  The 8K limit
 * keeps the memory coming from a kalloc zone instead of
 * valuable/fragment-able kernel map space.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXCATENTRIES</span>	\
	(1 + (8192 - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cat_entrylist)) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cat_entry))

<span class="enscript-comment">/*
 * Catalog Node Entry List
 *
 * A cat_entrylist is a list of Catalog Node Entries.
 */</span>
<span class="enscript-type">struct</span> cat_entrylist {
	u_int32_t  maxentries;    <span class="enscript-comment">/* number of entries requested */</span>
	u_int32_t  realentries;   <span class="enscript-comment">/* number of valid entries returned */</span>
	u_int32_t  skipentries;   <span class="enscript-comment">/* number of entries skipped (reserved HFS+ files) */</span>
	<span class="enscript-type">struct</span> cat_entry  entry[1];   <span class="enscript-comment">/* array of entries */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CE_LIST_SIZE</span>(entries)	\
	<span class="enscript-keyword">sizeof</span> (*ce_list) + (((entries) - 1) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cat_entry))

<span class="enscript-type">struct</span> hfsmount;

<span class="enscript-comment">/*
 * Catalog FileID/CNID Acquisition / Lookup 
 *
 * Some use-cases require that we find a valid CNID
 * before we may be ready to enter the item into the namespace.
 * In order to resolve this, we support a hashtable attached to
 * the mount that is secured by the catalog lock.  
 * 
 * Finding the next valid CNID is easy if the wraparound bit is
 * not set -- you just pull from the hfsmp next pointer.  
 * If it is set then you must find a free entry in the catalog
 * and also query the hashtable to see if the item is free or not.
 * 
 * If you want to request a CNID before there is a backing item
 * in the catalog, you must find one that is valid, then insert
 * it into the hash table until such time that the item is
 * inserted into the catalog.  After successful catalog insertion,
 * you must remove the item from the hashtable.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cat_preflightid {
	cnid_t fileid;
	LIST_ENTRY(cat_preflightid) id_hash;
} cat_preflightid_t;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_remove_idhash</span> (cat_preflightid_t *preflight);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_insert_idhash</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cat_preflightid_t *preflight);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_check_idhash</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t test_fileid);

<span class="enscript-comment">/* initialize the id look up hashtable during mount */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_idhash_init</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/* release the id lookup hashtable during unmount */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_idhash_destroy</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/* Get a new CNID for use */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_acquire_cnid</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t *new_cnid);


<span class="enscript-comment">/* default size of ID hash is 64 entries */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_IDHASH_DEFAULT</span> 64


<span class="enscript-comment">/*
 * Catalog Operations Hint
 *
 * lower 16 bits: count of B-tree insert operations
 * upper 16 bits: count of B-tree delete operations
 *
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CAT_DELETE</span>	0x00010000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CAT_CREATE</span>	0x00000002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CAT_RENAME</span>	0x00010002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CAT_EXCHANGE</span>	0x00010002

<span class="enscript-type">typedef</span> u_int32_t	catops_t;

<span class="enscript-comment">/*
 * The size of cat_cookie_t much match the size of
 * the nreserve struct (in BTreeNodeReserve.c).
 */</span>
<span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> cat_cookie_t {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-type">char</span>	opaque[40];
#<span class="enscript-reference">else</span>
	<span class="enscript-type">char</span>	opaque[24];
#<span class="enscript-reference">endif</span>
} cat_cookie_t;

<span class="enscript-comment">/* Universal catalog key */</span>
<span class="enscript-type">union</span> CatalogKey {
	HFSCatalogKey      hfs;
	HFSPlusCatalogKey  hfsPlus;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> CatalogKey  CatalogKey;

<span class="enscript-comment">/* Universal catalog data record */</span>
<span class="enscript-type">union</span> CatalogRecord {
	int16_t               recordType;
	HFSCatalogFolder      hfsFolder;
	HFSCatalogFile        hfsFile;
	HFSCatalogThread      hfsThread;
	HFSPlusCatalogFolder  hfsPlusFolder;
	HFSPlusCatalogFile    hfsPlusFile;
	HFSPlusCatalogThread  hfsPlusThread;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> CatalogRecord  CatalogRecord;

<span class="enscript-comment">/* Constants for HFS fork types */</span>
<span class="enscript-type">enum</span> {
	kHFSDataForkType = 0x0, 	<span class="enscript-comment">/* data fork */</span>
	kHFSResourceForkType = 0xff	<span class="enscript-comment">/* resource fork */</span>
};

<span class="enscript-comment">/*
 * Catalog Interface
 *
 * These functions perform a catalog transactions. The
 * catalog b-tree is abstracted through this interface.
 * (please don't go around it)
 */</span>


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cat_releasedesc</span>(<span class="enscript-type">struct</span> cat_desc *descp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_create</span> (	<span class="enscript-type">struct</span> hfsmount *hfsmp,
			cnid_t new_fileid,
			<span class="enscript-type">struct</span> cat_desc *descp,
			<span class="enscript-type">struct</span> cat_attr *attrp,
			<span class="enscript-type">struct</span> cat_desc *out_descp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_delete</span> (	<span class="enscript-type">struct</span> hfsmount *hfsmp,
			<span class="enscript-type">struct</span> cat_desc *descp,
			<span class="enscript-type">struct</span> cat_attr *attrp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookup</span> (	<span class="enscript-type">struct</span> hfsmount *hfsmp,
			<span class="enscript-type">struct</span> cat_desc *descp,
			<span class="enscript-type">int</span> wantrsrc,
			<span class="enscript-type">int</span> force_casesensitive_lookup,
			<span class="enscript-type">struct</span> cat_desc *outdescp,
			<span class="enscript-type">struct</span> cat_attr *attrp,
			<span class="enscript-type">struct</span> cat_fork *forkp,
    			cnid_t          *desc_cnid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_idlookup</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp,
			cnid_t cnid,
			<span class="enscript-type">int</span> allow_system_files,
			<span class="enscript-type">int</span> wantrsrc,
			<span class="enscript-type">struct</span> cat_desc *outdescp,
			<span class="enscript-type">struct</span> cat_attr *attrp,
			<span class="enscript-type">struct</span> cat_fork *forkp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_findname</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp,
                         cnid_t cnid,
                         <span class="enscript-type">struct</span> cat_desc *outdescp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_getentriesattr</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			directoryhint_t *dirhint,
			<span class="enscript-type">struct</span> cat_entrylist *ce_list, 
			<span class="enscript-type">int</span> *reachedeof);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_rename</span> (	<span class="enscript-type">struct</span> hfsmount * hfsmp,
			<span class="enscript-type">struct</span> cat_desc * from_cdp,
			<span class="enscript-type">struct</span> cat_desc * todir_cdp,
			<span class="enscript-type">struct</span> cat_desc * to_cdp,
			<span class="enscript-type">struct</span> cat_desc * cdp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_update</span> (	<span class="enscript-type">struct</span> hfsmount *hfsmp,
			<span class="enscript-type">struct</span> cat_desc *descp,
			<span class="enscript-type">struct</span> cat_attr *attrp,
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dataforkp,
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *rsrcforkp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_getdirentries</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			u_int32_t entrycnt,
			directoryhint_t *dirhint,
			uio_t uio,
			<span class="enscript-type">int</span> extended,
			<span class="enscript-type">int</span> * items,
			<span class="enscript-type">int</span> * eofflag);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_insertfilethread</span> (
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			<span class="enscript-type">struct</span> cat_desc *descp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_preflight</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			catops_t ops,
			cat_cookie_t *cookie,
			<span class="enscript-type">struct</span> proc *p);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cat_postflight</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			cat_cookie_t *cookie,
			<span class="enscript-type">struct</span> proc *p);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_binarykeycompare</span>(
			HFSPlusCatalogKey *searchKey,
			HFSPlusCatalogKey *trialKey);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">CompareCatalogKeys</span>(
			HFSCatalogKey *searchKey,
			HFSCatalogKey *trialKey);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">CompareExtendedCatalogKeys</span>(
			HFSPlusCatalogKey *searchKey,
			HFSPlusCatalogKey *trialKey);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cat_convertattr</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			CatalogRecord * recp,
			<span class="enscript-type">struct</span> cat_attr *attrp,
			<span class="enscript-type">struct</span> cat_fork *datafp,
			<span class="enscript-type">struct</span> cat_fork *rsrcfp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_convertkey</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			CatalogKey *key,
			CatalogRecord * recp,
			<span class="enscript-type">struct</span> cat_desc *descp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_getkeyplusattr</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp, 
			cnid_t cnid, 
			CatalogKey *key, 
			<span class="enscript-type">struct</span> cat_attr *attrp);

<span class="enscript-comment">/* Hard link functions. */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_check_link_ancestry</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp,
			cnid_t parentid, 
			cnid_t pointed_at_cnid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_set_childlinkbit</span>(
			<span class="enscript-type">struct</span> hfsmount *hfsmp, 
			cnid_t cnid);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_IGNORABLE_LINK</span>  0x00000001

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_resolvelink</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                            u_int32_t linkref,
                            <span class="enscript-type">int</span> isdirlink,
                            <span class="enscript-type">struct</span> HFSPlusCatalogFile *recp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_createlink</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                           <span class="enscript-type">struct</span> cat_desc *descp,
                           <span class="enscript-type">struct</span> cat_attr *attr,
                           cnid_t nextlinkid,
                           cnid_t *linkfileid);

<span class="enscript-comment">/* Finder Info's file type and creator for directory hard link alias */</span>
<span class="enscript-type">enum</span> {
	kHFSAliasType    = 0x66647270,  <span class="enscript-comment">/* 'fdrp' */</span>
	kHFSAliasCreator = 0x4D414353   <span class="enscript-comment">/* 'MACS' */</span>
};

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_deletelink</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                           <span class="enscript-type">struct</span> cat_desc *descp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_update_siblinglinks</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                           cnid_t linkfileid,
                           cnid_t prevlinkid,
                           cnid_t nextlinkid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookuplink</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                           <span class="enscript-type">struct</span> cat_desc *descp,
                           cnid_t *linkfileid,
                           cnid_t *prevlinkid,
                           cnid_t *nextlinkid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookup_siblinglinks</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                               cnid_t linkfileid,
                               cnid_t *prevlinkid,
                               cnid_t *nextlinkid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookup_lastlink</span>( <span class="enscript-type">struct</span> hfsmount *hfsmp,
                               cnid_t startid,
                               cnid_t *nextlinkid,
							   <span class="enscript-type">struct</span> cat_desc *cdesc);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookup_dirlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, 
			     cnid_t dirlink_id, 
			     u_int8_t forktype, 
			     <span class="enscript-type">struct</span> cat_desc *outdescp, 
			     <span class="enscript-type">struct</span> cat_attr *attrp, 
			     <span class="enscript-type">struct</span> cat_fork *forkp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_update_dirlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, 
			      u_int8_t forktype, 
			      <span class="enscript-type">struct</span> cat_desc *descp, 
			      <span class="enscript-type">struct</span> cat_attr *attrp, 
			      <span class="enscript-type">struct</span> cat_fork *rsrcforkp);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __HFS_CATALOG__ */</span>
</pre>
<hr />
</body></html>