<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>BTreeNodeOps.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">BTreeNodeOps.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000, 2002, 2005-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
	File:		BTreeNodeOps.c

	Contains:	Single-node operations for the BTree Module.

	Version:	xxx put the technology version here xxx

	Written by:	Gordon Sheridan and Bill Bruffey

	Copyright:	© 1992-1999 by Apple Computer, Inc., all rights reserved.

	File Ownership:

		DRI:				Don Brady

		Other Contact:		Mark Day

		Technology:			File Systems

	Writers:

		(msd)	Mark Day
		(djb)	Don Brady

	Change History (most recent first):

	   &lt;MOSXS&gt;	  6/1/99	djb		Sync up with Mac OS 8.6.
	   &lt;MOSXS&gt;	4/113/99	djb		Fix key size checking bug in CheckNode.
	   &lt;MOSXS&gt;	 3/19/99	djb		Added key size checking to CheckNode.
	   &lt;MOSXS&gt;	 3/26/98	djb		Added PrintNode for debugging.
	   &lt;CS5&gt;	  9/4/97	djb		Removed GetRightSiblingNode and GetLeftSiblingNode - they are
									now macros. SearchNode is now in BTreeSearchNode.a.
	   &lt;CS4&gt;	 8/22/97	djb		Turn off debugging code in CheckKey.
	   &lt;CS3&gt;	 7/24/97	djb		Add summary traces for Get/Rel Node. Made GetRecordOffset into a
									macro. Only call CheckNode if the node came from disk.
	   &lt;CS2&gt;	 7/21/97	msd		Make GetRecordByIndex check its record index input; it now
									returns an OSStatus.
	   &lt;CS1&gt;	 4/23/97	djb		first checked in

	  &lt;HFS3&gt;	 2/19/97	djb		Changes to support big node cache.
	  &lt;HFS2&gt;	  1/3/97	djb		Added support for large keys.
	  &lt;HFS1&gt;	12/19/96	djb		first checked in


	History applicable to original Scarecrow Design:

		 &lt;6&gt;	10/25/96	ser		Changing for new VFPI
		 &lt;5&gt;	 9/17/96	dkh		Add bounds checking to GetNode. Update GetNode to not assert
									that CheckNode failed if the node is all zeroes. This can happen
									if the hint case if the fetched node has been deallocated
		 &lt;4&gt;	  3/7/96	dkh		Change GetNewNode() to not use kGetEmptyBlock. Instead use
									kGetBlock to fetch a block from the disk itself.  €€€ Why?
		 &lt;3&gt;	 1/22/96	dkh		Add #include Memory.h
		 &lt;2&gt;	 1/10/96	msd		Change 64-bit math to use real function names from Math64.i.
		 &lt;1&gt;	10/18/95	rst		Moved from Scarecrow project.

		&lt;17&gt;	 7/18/95	mbb		Change MoveData &amp; ClearBytes to BlockMoveData &amp; BlockZero.
		&lt;16&gt;	 1/31/95	prp		GetBlockProc interface uses a 64 bit node number.
		&lt;15&gt;	 1/12/95	wjk		Adopt Model FileSystem changes in D5.
		&lt;14&gt;	 9/30/94	prp		Get in sync with D2 interface changes.
		&lt;13&gt;	 7/25/94	wjk		Eliminate usage of BytePtr in favor of UInt8 *.
		&lt;12&gt;	 7/22/94	wjk		Convert to the new set of header files.
		&lt;11&gt;	 12/2/93	wjk		Move from Makefiles to BuildFiles. Fit into the ModernOS and
									NRCmds environments.
		&lt;10&gt;	11/30/93	wjk		Change some Ptr's to BytePtr's in function definitions so they
									agree with their prototypes.
		 &lt;9&gt;	 8/31/93	prp		Use U64SetU instead of S64Set.
		 &lt;8&gt;	 5/21/93	gs		Maintain statistical counters on Get/Release node routines.
		 &lt;7&gt;	 5/10/93	gs		Change keySize parameter to keyLength for InsertKeyRecord
									routine. Calculate number of bytes in key from keyLength to
									account for length and pad bytes. Add GetChildNodeNum routine.
		 &lt;6&gt;	 3/23/93	gs		Add InsertKeyRecord routine.
		 &lt;5&gt;	  2/8/93	gs		Fix bug in SearchNode that caused &quot;off by 1&quot; error when final
									compare was searchKey &gt; trialKey. Add UpdateNode.
		 &lt;4&gt;	12/10/92	gs		Change keyLength field of key to 'length'.
		 &lt;3&gt;	 12/8/92	gs		Incorporate suggestions from preliminary code review.
		 &lt;2&gt;	 12/2/92	gs		Implement routines.
		 &lt;1&gt;	11/15/92	gs		Define routine interfaces.

*/</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../headers/BTreesPrivate.h&quot;</span>



<span class="enscript-comment">///////////////////////// BTree Module Node Operations //////////////////////////
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	GetNode 			- Call FS Agent to get node
</span><span class="enscript-comment">//	GetNewNode			- Call FS Agent to get a new node
</span><span class="enscript-comment">//	ReleaseNode			- Call FS Agent to release node obtained by GetNode.
</span><span class="enscript-comment">//	UpdateNode			- Mark a node as dirty and call FS Agent to release it.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	ClearNode			- Clear a node to all zeroes.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	InsertRecord		- Inserts a record into a BTree node.
</span><span class="enscript-comment">//	InsertKeyRecord		- Inserts a key and record pair into a BTree node.
</span><span class="enscript-comment">//	DeleteRecord		- Deletes a record from a BTree node.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	SearchNode			- Return index for record that matches key.
</span><span class="enscript-comment">//	LocateRecord		- Return pointer to key and data, and size of data.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	GetNodeDataSize		- Return the amount of space used for data in the node.
</span><span class="enscript-comment">//	GetNodeFreeSize		- Return the amount of free space in the node.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	GetRecordOffset		- Return the offset for record &quot;index&quot;.
</span><span class="enscript-comment">//	GetRecordAddress	- Return address of record &quot;index&quot;.
</span><span class="enscript-comment">//	GetOffsetAddress	- Return address of offset for record &quot;index&quot;.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//	InsertOffset		- Inserts a new offset into a node.
</span><span class="enscript-comment">//	DeleteOffset		- Deletes an offset from a node.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">/////////////////////////////////////////////////////////////////////////////////
</span>


<span class="enscript-comment">////////////////////// Routines Internal To BTreeNodeOps.c //////////////////////
</span>
u_int16_t	GetRecordOffset		(BTreeControlBlockPtr	 btree,
								 NodeDescPtr			 node,
								 u_int16_t				 index );

u_int16_t	*GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				index );
								 
<span class="enscript-type">void</span>		InsertOffset		(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				 index,
								 u_int16_t				 delta );

<span class="enscript-type">void</span>		DeleteOffset		(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				 index );


<span class="enscript-comment">/////////////////////////////////////////////////////////////////////////////////
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GetRecordOffset</span>(btreePtr,node,index)		(*(short *) ((u_int8_t *)(node) + (btreePtr)-&gt;nodeSize - ((index) &lt;&lt; 1) - kOffsetSize))

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_DIAGNOSTIC</span>
		#include &lt;sys/systm.h&gt;
	    #define PRINTIT kprintf
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">PrintNode</span>(<span class="enscript-type">const</span> NodeDescPtr node, u_int16_t nodeSize, u_int32_t nodeNumber);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_DIAGNOSTIC */</span>




<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetNode	-	Call FS Agent to get node

Function:	Gets an existing BTree node from FS Agent and verifies it.

Input:		btreePtr	- pointer to BTree control block
			nodeNum		- number of node to request
			
Output:		nodePtr		- pointer to beginning of node (nil if error)
			
Result:
			noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	GetNode		(BTreeControlBlockPtr	 btreePtr,
						 u_int32_t				 nodeNum,
			   			 u_int32_t				 flags, 
						 NodeRec				*nodePtr )
{
	OSStatus			err;
	GetBlockProcPtr		getNodeProc;
	u_int32_t			options;
	

	<span class="enscript-comment">// is nodeNum within proper range?
</span>	<span class="enscript-keyword">if</span>( nodeNum &gt;= btreePtr-&gt;totalNodes )
	{
		Panic(<span class="enscript-string">&quot;GetNode:nodeNum &gt;= totalNodes&quot;</span>);
		err = fsBTInvalidNodeErr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	
	nodePtr-&gt;blockSize = btreePtr-&gt;nodeSize;	<span class="enscript-comment">// indicate the size of a node
</span>
	options = kGetBlock;
	<span class="enscript-keyword">if</span> ( flags &amp; kGetNodeHint ) 
	{
		options |= kGetBlockHint;
	}
	
	getNodeProc = btreePtr-&gt;getBlockProc;
	err = getNodeProc (btreePtr-&gt;fileRefNum,
					   nodeNum,
					   options,
					   nodePtr );

	<span class="enscript-keyword">if</span> (err != noErr)
	{
		Panic (<span class="enscript-string">&quot;GetNode: getNodeProc returned error.&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	++btreePtr-&gt;numGetNodes;

	<span class="enscript-keyword">return</span> noErr;

<span class="enscript-reference">ErrorExit</span>:
	nodePtr-&gt;buffer			= nil;
	nodePtr-&gt;blockHeader	= nil;

	<span class="enscript-keyword">return</span>	err;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetNewNode	-	Call FS Agent to get a new node

Function:	Gets a new BTree node from FS Agent and initializes it to an empty
			state.

Input:		btreePtr		- pointer to BTree control block
			nodeNum			- number of node to request
			
Output:		returnNodePtr	- pointer to beginning of node (nil if error)
			
Result:		noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	GetNewNode	(BTreeControlBlockPtr	 btreePtr,
						 u_int32_t				 nodeNum,
						 NodeRec				*returnNodePtr )
{
	OSStatus			 err;
	NodeDescPtr			 node;
	<span class="enscript-type">void</span>				*pos;
	GetBlockProcPtr		 getNodeProc;
	

	<span class="enscript-comment">//////////////////////// get buffer for new node ////////////////////////////
</span>
	returnNodePtr-&gt;blockSize = btreePtr-&gt;nodeSize;	<span class="enscript-comment">// indicate the size of a node
</span>
	getNodeProc = btreePtr-&gt;getBlockProc;
	err = getNodeProc (btreePtr-&gt;fileRefNum,
					   nodeNum,
					   kGetBlock+kGetEmptyBlock,
					   returnNodePtr );
					   
	<span class="enscript-keyword">if</span> (err != noErr)
	{
		Panic (<span class="enscript-string">&quot;GetNewNode: getNodeProc returned error.&quot;</span>);
	<span class="enscript-comment">//	returnNodePtr-&gt;buffer = nil;
</span>		<span class="enscript-keyword">return</span> err;
	}
	++btreePtr-&gt;numGetNewNodes;
	

	<span class="enscript-comment">////////////////////////// initialize the node //////////////////////////////
</span>
	node = returnNodePtr-&gt;buffer;
	
	ClearNode (btreePtr, node);						<span class="enscript-comment">// clear the node
</span>
	pos = (<span class="enscript-type">char</span> *)node + btreePtr-&gt;nodeSize - 2;	<span class="enscript-comment">// find address of last offset
</span>	*(u_int16_t *)pos = <span class="enscript-keyword">sizeof</span> (BTNodeDescriptor);	<span class="enscript-comment">// set offset to beginning of free space
</span>

	<span class="enscript-keyword">return</span> noErr;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	ReleaseNode	-	Call FS Agent to release node obtained by GetNode.

Function:	Informs the FS Agent that a BTree node may be released.

Input:		btreePtr		- pointer to BTree control block
			nodeNum			- number of node to release
						
Result:		noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	ReleaseNode	(BTreeControlBlockPtr	 btreePtr,
						 NodePtr				 nodePtr )
{
	OSStatus			 err;
	ReleaseBlockProcPtr	 releaseNodeProc;


	err = noErr;
	
	<span class="enscript-keyword">if</span> (nodePtr-&gt;buffer != nil)
	{
		releaseNodeProc = btreePtr-&gt;releaseBlockProc;
		err = releaseNodeProc (btreePtr-&gt;fileRefNum,
							   nodePtr,
							   kReleaseBlock );
		PanicIf (err, <span class="enscript-string">&quot;ReleaseNode: releaseNodeProc returned error.&quot;</span>);
		++btreePtr-&gt;numReleaseNodes;
	}

	nodePtr-&gt;buffer			= nil;
	nodePtr-&gt;blockHeader	= nil;

	<span class="enscript-keyword">return</span> err;
}




<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	TrashNode	-	Call FS Agent to release node obtained by GetNode, and
							not store it...mark it as bad.

Function:	Informs the FS Agent that a BTree node may be released and thrown away.

Input:		btreePtr		- pointer to BTree control block
			nodeNum			- number of node to release
						
Result:		noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	TrashNode	(BTreeControlBlockPtr	 btreePtr,
						 NodePtr				 nodePtr )
{
	OSStatus			 err;
	ReleaseBlockProcPtr	 releaseNodeProc;
	

	err = noErr;
	
	<span class="enscript-keyword">if</span> (nodePtr-&gt;buffer != nil)
	{
		releaseNodeProc = btreePtr-&gt;releaseBlockProc;
		err = releaseNodeProc (btreePtr-&gt;fileRefNum,
							   nodePtr,
							   kReleaseBlock | kTrashBlock );
		PanicIf (err, <span class="enscript-string">&quot;TrashNode: releaseNodeProc returned error.&quot;</span>);
		++btreePtr-&gt;numReleaseNodes;
	}

	nodePtr-&gt;buffer			= nil;
	nodePtr-&gt;blockHeader	= nil;
	
	<span class="enscript-keyword">return</span> err;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	UpdateNode	-	Mark a node as dirty and call FS Agent to release it.

Function:	Marks a BTree node dirty and informs the FS Agent that it may be released.

Input:		btreePtr		- pointer to BTree control block
			nodeNum			- number of node to release
			transactionID	- ID of transaction this node update is a part of
			flags			- special flags to pass to ReleaseNodeProc
						
Result:		noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	UpdateNode	(BTreeControlBlockPtr	 btreePtr,
						 NodePtr				 nodePtr,
						 u_int32_t				 transactionID,
						 u_int32_t				 flags )
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">transactionID</span>)

	OSStatus			 err;
	ReleaseBlockProcPtr	 releaseNodeProc;
	
	
	err = noErr;
		
	<span class="enscript-keyword">if</span> (nodePtr-&gt;buffer != nil)			<span class="enscript-comment">// Why call UpdateNode if nil ?!?
</span>	{
		releaseNodeProc = btreePtr-&gt;releaseBlockProc;
		err = releaseNodeProc (btreePtr-&gt;fileRefNum,
							   nodePtr,
							   flags | kMarkBlockDirty );
		++btreePtr-&gt;numUpdateNodes;
		M_ExitOnError (err);
	}
	
	nodePtr-&gt;buffer			= nil;
	nodePtr-&gt;blockHeader	= nil;

	<span class="enscript-keyword">return</span>	noErr;

<span class="enscript-reference">ErrorExit</span>:
	
	<span class="enscript-keyword">return</span>	err;
}



#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_DIAGNOSTIC</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">PrintNode</span>(<span class="enscript-type">const</span> NodeDescPtr node, u_int16_t nodeSize, u_int32_t nodeNumber)
{
	<span class="enscript-type">struct</span> row {
		u_int16_t	word[8];
	};
	<span class="enscript-type">struct</span> row	*offset;
	u_int16_t	rows;
	u_int32_t	*lp;

	PRINTIT(<span class="enscript-string">&quot;Dump of B-tree node #%ld ($%08lX)\n&quot;</span>, nodeNumber, nodeNumber);

	rows = nodeSize/16;
	lp = (u_int32_t*) node;
	offset = 0;
	
	<span class="enscript-keyword">while</span> (rows-- &gt; 0)
		PRINTIT(<span class="enscript-string">&quot;%04X: %08lX %08lX %08lX %08lX\n&quot;</span>, (u_int)offset++, *lp++, *lp++, *lp++, *lp++);
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	ClearNode	-	Clear a node to all zeroes.

Function:	Writes zeroes from beginning of node for nodeSize bytes.

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node to clear
						
Result:		none
-------------------------------------------------------------------------------*/</span>

<span class="enscript-type">void</span>	ClearNode	(BTreeControlBlockPtr	btreePtr, NodeDescPtr	 node )
{
	ClearMemory( node, btreePtr-&gt;nodeSize );
}

<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	InsertRecord	-	Inserts a record into a BTree node.

Function:	

Note:		Record size must be even!

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node to insert the record
			index			- position record is to be inserted
			recPtr			- pointer to record to insert

Result:		noErr		- success
			fsBTFullErr	- record larger than remaining free space.
-------------------------------------------------------------------------------*/</span>

Boolean		InsertRecord	(BTreeControlBlockPtr	btreePtr,
							 NodeDescPtr 			node,
							 u_int16_t	 			index,
							 RecordPtr				recPtr,
							 u_int16_t				recSize )
{
	u_int16_t	freeSpace;
	u_int16_t	indexOffset;
	u_int16_t	freeOffset;
	u_int16_t	bytesToMove;
	<span class="enscript-type">void</span>	   *src;
	<span class="enscript-type">void</span>	   *dst;
	
	<span class="enscript-comment">//// will new record fit in node?
</span>
	freeSpace = GetNodeFreeSize (btreePtr, node);
											<span class="enscript-comment">//€€ we could get freeOffset &amp; calc freeSpace
</span>	<span class="enscript-keyword">if</span> ( freeSpace &lt; recSize + 2)
	{
		<span class="enscript-keyword">return</span> false;
	}

	
	<span class="enscript-comment">//// make hole for new record
</span>
	indexOffset = GetRecordOffset (btreePtr, node, index);
	freeOffset	= GetRecordOffset (btreePtr, node, node-&gt;numRecords);

	src = ((Ptr) node) + indexOffset;
	dst = ((Ptr) src)  + recSize;
	bytesToMove = freeOffset - indexOffset;
	<span class="enscript-keyword">if</span> (bytesToMove)
		MoveRecordsRight (src, dst, bytesToMove);


	<span class="enscript-comment">//// adjust offsets for moved records
</span>
	InsertOffset (btreePtr, node, index, recSize);


	<span class="enscript-comment">//// move in the new record
</span>
	dst = ((Ptr) node) + indexOffset;
	MoveRecordsLeft (recPtr, dst, recSize);

	<span class="enscript-keyword">return</span> true;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	InsertKeyRecord	-	Inserts a record into a BTree node.

Function:	

Note:		Record size must be even!

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node to insert the record
			index			- position record is to be inserted
			keyPtr			- pointer to key for record to insert
			keyLength		- length of key (or maxKeyLength)
			recPtr			- pointer to record to insert
			recSize			- number of bytes to copy for record

Result:		noErr		- success
			fsBTFullErr	- record larger than remaining free space.
-------------------------------------------------------------------------------*/</span>

Boolean		InsertKeyRecord		(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr 			 node,
								 u_int16_t	 			 index,
								 KeyPtr					 keyPtr,
								 u_int16_t				 keyLength,
								 RecordPtr				 recPtr,
								 u_int16_t				 recSize )
{
	u_int16_t		freeSpace;
	u_int16_t		indexOffset;
	u_int16_t		freeOffset;
	u_int16_t		bytesToMove;
	u_int8_t *		src;
	u_int8_t *		dst;
	u_int16_t		keySize;
	u_int16_t		rawKeyLength;
	u_int16_t		sizeOfLength;
	
	<span class="enscript-comment">//// calculate actual key size
</span>
	<span class="enscript-keyword">if</span> ( btreePtr-&gt;attributes &amp; kBTBigKeysMask )
		keySize = keyLength + <span class="enscript-keyword">sizeof</span>(u_int16_t);
	<span class="enscript-keyword">else</span>
		keySize = keyLength + <span class="enscript-keyword">sizeof</span>(u_int8_t);
	
	<span class="enscript-keyword">if</span> ( M_IsOdd (keySize) )
		++keySize;			<span class="enscript-comment">// add pad byte
</span>

	<span class="enscript-comment">//// will new record fit in node?
</span>
	freeSpace = GetNodeFreeSize (btreePtr, node);
											<span class="enscript-comment">//€€ we could get freeOffset &amp; calc freeSpace
</span>	<span class="enscript-keyword">if</span> ( freeSpace &lt; keySize + recSize + 2)
	{
		<span class="enscript-keyword">return</span> false;
	}

	
	<span class="enscript-comment">//// make hole for new record
</span>
	indexOffset = GetRecordOffset (btreePtr, node, index);
	freeOffset	= GetRecordOffset (btreePtr, node, node-&gt;numRecords);

	src = ((u_int8_t *) node) + indexOffset;
	dst = ((u_int8_t *) src) + keySize + recSize;
	bytesToMove = freeOffset - indexOffset;
	<span class="enscript-keyword">if</span> (bytesToMove)
		MoveRecordsRight (src, dst, bytesToMove);


	<span class="enscript-comment">//// adjust offsets for moved records
</span>
	InsertOffset (btreePtr, node, index, keySize + recSize);
	

	<span class="enscript-comment">//// copy record key
</span>
	dst = ((u_int8_t *) node) + indexOffset;

	<span class="enscript-keyword">if</span> ( btreePtr-&gt;attributes &amp; kBTBigKeysMask )
	{
		*((u_int16_t *)dst) = keyLength;			<span class="enscript-comment">// use keyLength rather than key.length
</span>  		dst = (u_int8_t *) (((u_int16_t *)dst) + 1);
		rawKeyLength = keyPtr-&gt;length16;
		sizeOfLength = 2;
	}
	<span class="enscript-keyword">else</span>
	{
		*dst++ = keyLength;					<span class="enscript-comment">// use keyLength rather than key.length
</span>		rawKeyLength = keyPtr-&gt;length8;
		sizeOfLength = 1;
	}
	
	MoveRecordsLeft ( ((u_int8_t *) keyPtr) + sizeOfLength, dst, rawKeyLength);	<span class="enscript-comment">// copy key
</span>
	<span class="enscript-comment">// any pad bytes?
</span>	bytesToMove = keySize - rawKeyLength;
	<span class="enscript-keyword">if</span> (bytesToMove)
		ClearMemory (dst + rawKeyLength, bytesToMove);	<span class="enscript-comment">// clear pad bytes in index key
</span>

	<span class="enscript-comment">//// copy record data
</span>
	dst = ((u_int8_t *) node) + indexOffset + keySize;
	MoveRecordsLeft (recPtr, dst, recSize);

	<span class="enscript-keyword">return</span> true;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	DeleteRecord	-	Deletes a record from a BTree node.

Function:	

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node to insert the record
			index			- position record is to be inserted

Result:		none
-------------------------------------------------------------------------------*/</span>

<span class="enscript-type">void</span>		DeleteRecord	(BTreeControlBlockPtr	btreePtr,
							 NodeDescPtr 			node,
							 u_int16_t	 			index )
{
	int16_t		indexOffset;
	int16_t		nextOffset;
	int16_t		freeOffset;
	int16_t		bytesToMove;
	<span class="enscript-type">void</span>	   *src;
	<span class="enscript-type">void</span>	   *dst;
	
	<span class="enscript-comment">//// compress records
</span>	indexOffset = GetRecordOffset (btreePtr, node, index);
	nextOffset	= GetRecordOffset (btreePtr, node, index + 1);
	freeOffset	= GetRecordOffset (btreePtr, node, node-&gt;numRecords);

	src = ((Ptr) node) + nextOffset;
	dst = ((Ptr) node) + indexOffset;
	bytesToMove = freeOffset - nextOffset;
	<span class="enscript-keyword">if</span> (bytesToMove)
		MoveRecordsLeft (src, dst, bytesToMove);

	<span class="enscript-comment">//// Adjust the offsets
</span>	DeleteOffset (btreePtr, node, index);
	
	<span class="enscript-comment">/* clear out new free space */</span>
	bytesToMove = nextOffset - indexOffset;
	ClearMemory(GetRecordAddress(btreePtr, node, node-&gt;numRecords), bytesToMove);

}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	SearchNode	-	Return index for record that matches key.

Function:	Returns the record index for the record that matches the search key.
			If no record was found that matches the search key, the &quot;insert index&quot;
			of where the record should go is returned instead.

Algorithm:	A binary search algorithm is used to find the specified key.

Input:		btreePtr	- pointer to BTree control block
			node		- pointer to node that contains the record
			searchKey	- pointer to the key to match

Output:		index		- pointer to beginning of key for record

Result:		true	- success (index = record index)
			false	- key did not match anything in node (index = insert index)
-------------------------------------------------------------------------------*/</span>
Boolean
<span class="enscript-function-name">SearchNode</span>( BTreeControlBlockPtr btreePtr,
	    NodeDescPtr node,
	    KeyPtr searchKey,
	    u_int16_t *returnIndex )
{
	int32_t		lowerBound;
	int32_t		upperBound;
	int32_t		index;
	int32_t		result;
	KeyPtr		trialKey;
	u_int16_t	*offset;
	KeyCompareProcPtr compareProc = btreePtr-&gt;keyCompareProc;

	lowerBound = 0;
	upperBound = node-&gt;numRecords - 1;
	offset = (u_int16_t *) ((u_int8_t *)(node) + (btreePtr)-&gt;nodeSize - kOffsetSize);
	
	<span class="enscript-keyword">while</span> (lowerBound &lt;= upperBound) {
		index = (lowerBound + upperBound) &gt;&gt; 1;

		trialKey = (KeyPtr) ((u_int8_t *)node + *(offset - index));
		
		result = compareProc(searchKey, trialKey);

		<span class="enscript-keyword">if</span> (result &lt;  0) {
			upperBound = index - 1;	  <span class="enscript-comment">/* search &lt; trial */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result &gt;  0) {
			lowerBound = index + 1;	  <span class="enscript-comment">/* search &gt; trial */</span>
		} <span class="enscript-keyword">else</span> {	
			*returnIndex = index;	  <span class="enscript-comment">/* search == trial */</span>
			<span class="enscript-keyword">return</span> true;
		}
	}
	
	*returnIndex = lowerBound;	<span class="enscript-comment">/* lowerBound is insert index */</span>
	<span class="enscript-keyword">return</span> false;
}


<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetRecordByIndex	-	Return pointer to key and data, and size of data.

Function:	Returns a pointer to beginning of key for record, a pointer to the
			beginning of the data for the record, and the size of the record data
			(does not include the size of the key).

Input:		btreePtr	- pointer to BTree control block
			node		- pointer to node that contains the record
			index		- index of record to get

Output:		keyPtr		- pointer to beginning of key for record
			dataPtr		- pointer to beginning of data for record
			dataSize	- size of the data portion of the record

Result:		none
-------------------------------------------------------------------------------*/</span>

OSStatus	GetRecordByIndex	(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				 index,
								 KeyPtr					*keyPtr,
								 u_int8_t *				*dataPtr,
								 u_int16_t				*dataSize )
{
	u_int16_t		offset;
	u_int16_t		nextOffset;
	u_int16_t		keySize;
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Make sure index is valid (in range 0..numRecords-1)
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (index &gt;= node-&gt;numRecords)
		<span class="enscript-keyword">return</span> fsBTRecordNotFoundErr;

	<span class="enscript-comment">//// find keyPtr
</span>	offset		= GetRecordOffset (btreePtr, node, index);
	*keyPtr		= (KeyPtr) ((Ptr)node + offset);

	<span class="enscript-comment">//// find dataPtr
</span>	keySize	= CalcKeySize(btreePtr, *keyPtr);
	<span class="enscript-keyword">if</span> ( M_IsOdd (keySize) )
		++keySize;	<span class="enscript-comment">// add pad byte
</span>
	offset += keySize;			<span class="enscript-comment">// add the key length to find data offset
</span>	*dataPtr = (u_int8_t *) node + offset;
	
	<span class="enscript-comment">//// find dataSize
</span>	nextOffset	= GetRecordOffset (btreePtr, node, index + 1);
	*dataSize	= nextOffset - offset;
	
	<span class="enscript-keyword">return</span> noErr;
}
								 


<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetNodeDataSize	-	Return the amount of space used for data in the node.

Function:	Gets the size of the data currently contained in a node, excluding
			the node header. (record data + offset overhead)

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record

Result:		- number of bytes used for data and offsets in the node.
-------------------------------------------------------------------------------*/</span>

u_int16_t	GetNodeDataSize	(BTreeControlBlockPtr	btreePtr, NodeDescPtr	 node )
{
	u_int16_t freeOffset;
	
	freeOffset = GetRecordOffset (btreePtr, node, node-&gt;numRecords);
	
	<span class="enscript-keyword">return</span>	freeOffset + (node-&gt;numRecords &lt;&lt; 1) - <span class="enscript-keyword">sizeof</span> (BTNodeDescriptor);
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetNodeFreeSize	-	Return the amount of free space in the node.

Function:	

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record

Result:		- number of bytes of free space in the node.
-------------------------------------------------------------------------------*/</span>

u_int16_t		GetNodeFreeSize	(BTreeControlBlockPtr	btreePtr, NodeDescPtr	 node )
{
	u_int16_t	freeOffset;
	
	freeOffset = GetRecordOffset (btreePtr, node, node-&gt;numRecords);	<span class="enscript-comment">//€€ inline?
</span>	
	<span class="enscript-keyword">return</span> btreePtr-&gt;nodeSize - freeOffset - (node-&gt;numRecords &lt;&lt; 1) - kOffsetSize;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetRecordOffset	-	Return the offset for record &quot;index&quot;.

Function:	

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record
			index			- record to obtain offset for

Result:		- offset (in bytes) from beginning of node of record specified by index
-------------------------------------------------------------------------------*/</span>
<span class="enscript-comment">// make this a macro (for inlining)
</span>#<span class="enscript-reference">if</span> 0
u_int16_t	GetRecordOffset	(BTreeControlBlockPtr	btreePtr,
							 NodeDescPtr			node,
							 u_int16_t				index )
{
	<span class="enscript-type">void</span>	*pos;
	
		
	pos = (u_int8_t *)node + btreePtr-&gt;nodeSize - (index &lt;&lt; 1) - kOffsetSize;
	
	<span class="enscript-keyword">return</span> *(<span class="enscript-type">short</span> *)pos;
}
#<span class="enscript-reference">endif</span>



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetRecordAddress	-	Return address of record &quot;index&quot;.

Function:	

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record
			index			- record to obtain offset address for

Result:		- pointer to record &quot;index&quot;.
-------------------------------------------------------------------------------*/</span>
<span class="enscript-comment">// make this a macro (for inlining)
</span>#<span class="enscript-reference">if</span> 0
u_int8_t *	GetRecordAddress	(BTreeControlBlockPtr	btreePtr,
								 NodeDescPtr			node,
								 u_int16_t				index )
{
	u_int8_t *	pos;
	
	pos = (u_int8_t *)node + GetRecordOffset (btreePtr, node, index);
	
	<span class="enscript-keyword">return</span> pos;
}
#<span class="enscript-reference">endif</span>



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetRecordSize	-	Return size of record &quot;index&quot;.

Function:	

Note:		This does not work on the FreeSpace index!

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record
			index			- record to obtain record size for

Result:		- size of record &quot;index&quot;.
-------------------------------------------------------------------------------*/</span>

u_int16_t	GetRecordSize		(BTreeControlBlockPtr	btreePtr,
								 NodeDescPtr			node,
								 u_int16_t				index )
{
	u_int16_t	*pos;
		
	pos = (u_int16_t *) ((Ptr)node + btreePtr-&gt;nodeSize - (index &lt;&lt; 1) - kOffsetSize);
	
	<span class="enscript-keyword">return</span>  *(pos-1) - *pos;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------
Routine:	GetOffsetAddress	-	Return address of offset for record &quot;index&quot;.

Function:	

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record
			index			- record to obtain offset address for

Result:		- pointer to offset for record &quot;index&quot;.
-------------------------------------------------------------------------------*/</span>

u_int16_t	 *GetOffsetAddress	(BTreeControlBlockPtr	btreePtr,
								 NodeDescPtr			node,
								 u_int16_t				index )
{
	<span class="enscript-type">void</span>	*pos;
	
	pos = (Ptr)node + btreePtr-&gt;nodeSize - (index &lt;&lt; 1) -2;
	
	<span class="enscript-keyword">return</span> (u_int16_t *)pos;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------
Routine:	GetChildNodeNum	-	Return child node number from index record &quot;index&quot;.

Function:	Returns the first u_int32_t stored after the key for record &quot;index&quot;.

Assumes:	The node is an Index Node.
			The key.length stored at record &quot;index&quot; is ODD. //€€ change for variable length index keys

Input:		btreePtr		- pointer to BTree control block
			node			- pointer to node that contains the record
			index			- record to obtain child node number from

Result:		- child node number from record &quot;index&quot;.
-------------------------------------------------------------------------------*/</span>

u_int32_t	GetChildNodeNum			(BTreeControlBlockPtr	 btreePtr,
									 NodeDescPtr			 nodePtr,
									 u_int16_t				 index )
{
	u_int8_t *		pos;
	
	pos = GetRecordAddress (btreePtr, nodePtr, index);
	pos += CalcKeySize(btreePtr, (BTreeKey *) pos);		<span class="enscript-comment">// key.length + size of length field
</span>	
	<span class="enscript-keyword">return</span>	*(u_int32_t *)pos;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------
Routine:	InsertOffset	-	Add an offset and adjust existing offsets by delta.

Function:	Add an offset at 'index' by shifting 'index+1' through the last offset
			and adjusting them by 'delta', the size of the record to be inserted.
			The number of records contained in the node is also incremented.

Input:		btreePtr	- pointer to BTree control block
			node		- pointer to node
			index		- index at which to insert record
			delta		- size of record to be inserted

Result:		none
-------------------------------------------------------------------------------*/</span>

<span class="enscript-type">void</span>		InsertOffset		(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				 index,
								 u_int16_t				 delta )
{
	u_int16_t	*src, *dst;
	u_int16_t	 numOffsets;
	
	src = GetOffsetAddress (btreePtr, node, node-&gt;numRecords);	<span class="enscript-comment">// point to free offset
</span>	dst = src - 1; 												<span class="enscript-comment">// point to new offset
</span>	numOffsets = node-&gt;numRecords++ - index;			<span class="enscript-comment">// subtract index  &amp; postincrement
</span>	
	<span class="enscript-keyword">do</span> {
		*dst++ = *src++ + delta;								<span class="enscript-comment">// to tricky?
</span>	} <span class="enscript-keyword">while</span> (numOffsets--);
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	DeleteOffset	-	Delete an offset.

Function:	Delete the offset at 'index' by shifting 'index+1' through the last offset
			and adjusting them by the size of the record 'index'.
			The number of records contained in the node is also decremented.

Input:		btreePtr	- pointer to BTree control block
			node		- pointer to node
			index		- index at which to delete record

Result:		none
-------------------------------------------------------------------------------*/</span>

<span class="enscript-type">void</span>		DeleteOffset		(BTreeControlBlockPtr	 btreePtr,
								 NodeDescPtr			 node,
								 u_int16_t				 index )
{
	u_int16_t		*src, *dst;
	u_int16_t		 numOffsets;
	u_int16_t		 delta;
	
	dst			= GetOffsetAddress (btreePtr, node, index);
	src			= dst - 1;
	delta		= *src - *dst;
	numOffsets	= --node-&gt;numRecords - index;	<span class="enscript-comment">// predecrement numRecords &amp; subtract index
</span>	
	<span class="enscript-keyword">while</span> (numOffsets--)
	{
		*--dst = *--src - delta;				<span class="enscript-comment">// work our way left
</span>	}
}


</pre>
<hr />
</body></html>