<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>BTreeAllocate.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">BTreeAllocate.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2003, 2005-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
	File:		BTreeAllocate.c

	Contains:	BTree Node Allocation routines for the BTree Module.

	Version:	xxx put the technology version here xxx

	Written by:	Gordon Sheridan and Bill Bruffey

	Copyright:	© 1992-1999 by Apple Computer, Inc., all rights reserved.

	File Ownership:

		DRI:				Don Brady

		Other Contact:		Mark Day

		Technology:			File Systems

	Writers:

		(djb)	Don Brady
		(ser)	Scott Roberts
		(msd)	Mark Day

	Change History (most recent first):

	   &lt;MOSXS&gt;	  6/1/99	djb		Sync up with Mac OS 8.6.
	   &lt;CS3&gt;	11/24/97	djb		Remove some debug code (Panic calls).
	   &lt;CS2&gt;	 7/24/97	djb		CallbackProcs now take refnum instead of an FCB.
	   &lt;CS1&gt;	 4/23/97	djb		first checked in

	  &lt;HFS2&gt;	 2/19/97	djb		Change E_BadNodeType to fsBTBadNodeType.
	  &lt;HFS1&gt;	12/19/96	djb		first checked in

	History applicable to original Scarecrow Design:

		 &lt;4&gt;	10/25/96	ser		Changing for new VFPI
		 &lt;3&gt;	10/18/96	ser		Converting over VFPI changes
		 &lt;2&gt;	 1/10/96	msd		Change 64-bit math to use real function names from Math64.i.
		 &lt;1&gt;	10/18/95	rst		Moved from Scarecrow project.

		 &lt;8&gt;	 1/12/95	wjk		Adopt Model FileSystem changes in D5.
		 &lt;7&gt;	 9/30/94	prp		Get in sync with D2 interface changes.
		 &lt;6&gt;	 7/22/94	wjk		Convert to the new set of header files.
		 &lt;5&gt;	 8/31/93	prp		Use U64SetU instead of S64Set.
		 &lt;4&gt;	 5/21/93	gs		Fix ExtendBTree bug.
		 &lt;3&gt;	 5/10/93	gs		Fix pointer arithmetic bug in AllocateNode.
		 &lt;2&gt;	 3/23/93	gs		finish ExtendBTree routine.
		 &lt;1&gt;	  2/8/93	gs		first checked in
		 &lt;0&gt;	  1/1/93	gs		begin AllocateNode and FreeNode

*/</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_btreeio.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../headers/BTreesPrivate.h&quot;</span>

<span class="enscript-comment">///////////////////// Routines Internal To BTreeAllocate.c //////////////////////
</span>
<span class="enscript-type">static</span> OSStatus	GetMapNode (BTreeControlBlockPtr	  btreePtr,
						BlockDescriptor			 *nodePtr,
						u_int16_t					**mapPtr,
						u_int16_t					 *mapSize );

<span class="enscript-comment">/////////////////////////////////////////////////////////////////////////////////
</span>
<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	AllocateNode	-	Find Free Node, Mark It Used, and Return Node Number.

Function:	Searches the map records for the first free node, marks it &quot;in use&quot; and
			returns the node number found. This routine should really only be called
			when we know there are free blocks, otherwise it's just a waste of time.

Note:		We have to examine map nodes a word at a time rather than a long word
			because the External BTree Mgr used map records that were not an integral
			number of long words. Too bad. In our spare time could develop a more
			sophisticated algorithm that read map records by long words (and long
			word aligned) and handled the spare bytes at the beginning and end
			appropriately.

Input:		btreePtr	- pointer to control block for BTree file		

Output:		nodeNum		- number of node allocated
			
			
Result:		noErr			- success
			fsBTNoMoreMapNodesErr	- no free blocks were found
			!= noErr		- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	AllocateNode (BTreeControlBlockPtr		btreePtr, u_int32_t	*nodeNum)
{
	OSStatus		 err;
	BlockDescriptor	 node;
	u_int16_t		*mapPtr, *pos;
	u_int16_t		 mapSize, size;
	u_int16_t		 freeWord;
	u_int16_t		 mask;
	u_int16_t		 bitOffset;
	u_int32_t		 nodeNumber;
	
	
	nodeNumber		= 0;				<span class="enscript-comment">// first node number of header map record
</span>	node.buffer		= nil;				<span class="enscript-comment">// clear node.buffer to get header node
</span>										<span class="enscript-comment">//	- and for ErrorExit
</span>	node.blockHeader = nil;
	
	<span class="enscript-keyword">while</span> (true)
	{
		err = GetMapNode (btreePtr, &amp;node, &amp;mapPtr, &amp;mapSize);
		M_ExitOnError (err);
		
		<span class="enscript-comment">// XXXdbg
</span>		ModifyBlockStart(btreePtr-&gt;fileRefNum, &amp;node);
								
	<span class="enscript-comment">//////////////////////// Find Word with Free Bit ////////////////////////////
</span>
		pos		= mapPtr;
		size	= mapSize;
		size  &gt;&gt;= 1;						<span class="enscript-comment">// convert to number of words
</span>						<span class="enscript-comment">//€€ assumes mapRecords contain an integral number of words
</span>
		<span class="enscript-keyword">while</span> ( size-- )
		{
			<span class="enscript-keyword">if</span> ( *pos++ != 0xFFFF )			<span class="enscript-comment">// assume test fails, and increment pos
</span>				<span class="enscript-keyword">break</span>;
		}

		--pos;								<span class="enscript-comment">// whoa! backup
</span>
		<span class="enscript-keyword">if</span> (*pos != 0xFFFF)					<span class="enscript-comment">// hey, we got one!
</span>			<span class="enscript-keyword">break</span>;
		
		nodeNumber += mapSize &lt;&lt; 3;			<span class="enscript-comment">// covert to number of bits (nodes)
</span>	}
	
	<span class="enscript-comment">///////////////////////// Find Free Bit in Word /////////////////////////////
</span>
	freeWord	= SWAP_BE16 (*pos);
	bitOffset	=  15;
	mask		=  0x8000;
	
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> ( (freeWord &amp; mask) == 0)
			<span class="enscript-keyword">break</span>;
		mask &gt;&gt;= 1;
	} <span class="enscript-keyword">while</span> (--bitOffset);

	<span class="enscript-comment">////////////////////// Calculate Free Node Number ///////////////////////////
</span>	
	nodeNumber += ((pos - mapPtr) &lt;&lt; 4) + (15 - bitOffset);	<span class="enscript-comment">// (pos-mapPtr) = # of words!
</span>	
	
	<span class="enscript-comment">///////////////////////// Check for End of Map //////////////////////////////
</span>
	<span class="enscript-keyword">if</span> (nodeNumber &gt;= btreePtr-&gt;totalNodes)
	{
		err = fsBTFullErr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}

	<span class="enscript-comment">/////////////////////////// Allocate the Node ///////////////////////////////
</span>
	*pos |= SWAP_BE16 (mask);				<span class="enscript-comment">// set the map bit for the node
</span>
	err = UpdateNode (btreePtr, &amp;node, 0, kLockTransaction);
	M_ExitOnError (err);
	
	--btreePtr-&gt;freeNodes;
	M_BTreeHeaderDirty(btreePtr);
	
	<span class="enscript-comment">/* Account for allocations from node reserve */</span>
	BTUpdateReserve(btreePtr, 1);

	*nodeNum = nodeNumber;
	
	<span class="enscript-keyword">return</span> noErr;

<span class="enscript-comment">////////////////////////////////// Error Exit ///////////////////////////////////
</span>
<span class="enscript-reference">ErrorExit</span>:
	
	(<span class="enscript-type">void</span>) ReleaseNode (btreePtr, &amp;node);
	*nodeNum = 0;
	
	<span class="enscript-keyword">return</span>	err;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	FreeNode	-	Clear allocation bit for node.

Function:	Finds the bit representing the node specified by nodeNum in the node
			map and clears the bit.


Input:		btreePtr	- pointer to control block for BTree file
			nodeNum		- number of node to mark free

Output:		none			
			
Result:		noErr			- success
			fsBTNoMoreMapNodesErr	- node number is beyond end of node map
			!= noErr		- GetNode or ReleaseNode encountered some difficulty
-------------------------------------------------------------------------------*/</span>

OSStatus	FreeNode (BTreeControlBlockPtr		btreePtr, u_int32_t	nodeNum)
{
	OSStatus		 err;
	BlockDescriptor	 node;
	u_int32_t		 nodeIndex;
	u_int16_t		 mapSize;
	u_int16_t		*mapPos;
	u_int16_t		 bitOffset;
	

	<span class="enscript-comment">//////////////////////////// Find Map Record ////////////////////////////////
</span>	nodeIndex			= 0;				<span class="enscript-comment">// first node number of header map record
</span>	node.buffer			= nil;				<span class="enscript-comment">// invalidate node.buffer to get header node
</span>	node.blockHeader    = nil;
	
	<span class="enscript-keyword">while</span> (nodeNum &gt;= nodeIndex)
	{
		err = GetMapNode (btreePtr, &amp;node, &amp;mapPos, &amp;mapSize);
		M_ExitOnError (err);
		
		nodeIndex += mapSize &lt;&lt; 3;			<span class="enscript-comment">// covert to number of bits (nodes)
</span>	}
	
	<span class="enscript-comment">//////////////////////////// Mark Node Free /////////////////////////////////
</span>
	<span class="enscript-comment">// XXXdbg
</span>	ModifyBlockStart(btreePtr-&gt;fileRefNum, &amp;node);
								
	nodeNum -= (nodeIndex - (mapSize &lt;&lt; 3));			<span class="enscript-comment">// relative to this map record
</span>	bitOffset = 15 - (nodeNum &amp; 0x0000000F);			<span class="enscript-comment">// last 4 bits are bit offset
</span>	mapPos += nodeNum &gt;&gt; 4;								<span class="enscript-comment">// point to word containing map bit
</span>
    M_SWAP_BE16_ClearBitNum (*mapPos, bitOffset);		<span class="enscript-comment">// clear it
</span>    
	err = UpdateNode (btreePtr, &amp;node, 0, kLockTransaction);
	M_ExitOnError (err);
	
	++btreePtr-&gt;freeNodes;
	M_BTreeHeaderDirty(btreePtr);

	<span class="enscript-keyword">return</span> noErr;

<span class="enscript-reference">ErrorExit</span>:

	(<span class="enscript-type">void</span>) ReleaseNode (btreePtr, &amp;node);

	<span class="enscript-keyword">return</span>	err;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	ExtendBTree	-	Call FSAgent to extend file, and allocate necessary map nodes.

Function:	This routine calls the the FSAgent to extend the end of fork, if necessary,
			to accomodate the number of nodes requested. It then allocates as many
			map nodes as are necessary to account for all the nodes in the B*Tree.
			If newTotalNodes is less than the current number of nodes, no action is
			taken.

Note:		Internal HFS File Manager BTree Module counts on an integral number of
			long words in map records, although they are not long word aligned.

Input:		btreePtr		- pointer to control block for BTree file
			newTotalNodes	- total number of nodes the B*Tree is to extended to
			
Output:		none
			
Result:		noErr		- success
			!= noErr	- failure
-------------------------------------------------------------------------------*/</span>

OSStatus	ExtendBTree	(BTreeControlBlockPtr	btreePtr,
						 u_int32_t				newTotalNodes )
{
	OSStatus				 err;
	FCB						*filePtr;
	FSSize					 minEOF, maxEOF;	
	u_int16_t				 nodeSize;
	u_int32_t				 oldTotalNodes;
	u_int32_t				 newMapNodes;
	u_int32_t				 mapBits, totalMapBits;
	u_int32_t				 recStartBit;
	u_int32_t				 nodeNum, nextNodeNum;
	u_int32_t				 firstNewMapNodeNum, lastNewMapNodeNum;
	BlockDescriptor			 mapNode, newNode;
	u_int16_t				*mapPos;
	u_int16_t				*mapStart;
	u_int16_t				 mapSize;
	u_int16_t				 mapNodeRecSize;
	u_int32_t				 bitInWord, bitInRecord;
	u_int16_t				 mapIndex;


	oldTotalNodes	 	= btreePtr-&gt;totalNodes;
	<span class="enscript-keyword">if</span> (newTotalNodes  &lt;= oldTotalNodes)				<span class="enscript-comment">// we're done!
</span>		<span class="enscript-keyword">return</span>	noErr;

	nodeSize			= btreePtr-&gt;nodeSize;
	filePtr				= GetFileControlBlock(btreePtr-&gt;fileRefNum);
	
	mapNode.buffer		= nil;
	mapNode.blockHeader = nil;
	newNode.buffer		= nil;
	newNode.blockHeader = nil;

	mapNodeRecSize	= nodeSize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) - 6;	<span class="enscript-comment">// 2 bytes of free space (see note)
</span>

	<span class="enscript-comment">//////////////////////// Count Bits In Node Map /////////////////////////////
</span>	
	totalMapBits = 0;
	<span class="enscript-keyword">do</span> {
		err = GetMapNode (btreePtr, &amp;mapNode, &amp;mapStart, &amp;mapSize);
		M_ExitOnError (err);
		
		mapBits		= mapSize &lt;&lt; 3;				<span class="enscript-comment">// mapSize (in bytes) * 8
</span>		recStartBit	= totalMapBits;				<span class="enscript-comment">// bit number of first bit in map record
</span>		totalMapBits  += mapBits;
		
	} <span class="enscript-keyword">while</span> ( ((BTNodeDescriptor*)mapNode.buffer)-&gt;fLink != 0 );

	<span class="enscript-keyword">if</span> (DEBUG_BUILD &amp;&amp; totalMapBits != CalcMapBits (btreePtr))
		Panic (<span class="enscript-string">&quot;ExtendBTree: totalMapBits != CalcMapBits&quot;</span>);
		
	<span class="enscript-comment">/////////////////////// Extend LEOF If Necessary ////////////////////////////
</span>
	minEOF = (u_int64_t)newTotalNodes * (u_int64_t)nodeSize;
	<span class="enscript-keyword">if</span> ( (u_int64_t)filePtr-&gt;fcbEOF &lt; minEOF )
	{
		maxEOF = (u_int64_t)0x7fffffffLL * (u_int64_t)nodeSize;

		err = btreePtr-&gt;setEndOfForkProc (btreePtr-&gt;fileRefNum, minEOF, maxEOF);
		M_ExitOnError (err);
	}

	
	<span class="enscript-comment">//////////////////// Calc New Total Number Of Nodes /////////////////////////
</span>	
	newTotalNodes = filePtr-&gt;fcbEOF / nodeSize;		<span class="enscript-comment">// hack!
</span>	<span class="enscript-comment">// do we wish to perform any verification of newTotalNodes at this point?
</span>
	btreePtr-&gt;totalNodes	 =  newTotalNodes;		<span class="enscript-comment">// do we need to update freeNodes here too?
</span>

	<span class="enscript-comment">////////////// Calculate Number Of New Map Nodes Required ///////////////////
</span>
	newMapNodes		= 0;
	<span class="enscript-keyword">if</span> (newTotalNodes &gt; totalMapBits)
	{
		newMapNodes			= (((newTotalNodes - totalMapBits) &gt;&gt; 3) / mapNodeRecSize) + 1;
		firstNewMapNodeNum	= oldTotalNodes;
		lastNewMapNodeNum	= firstNewMapNodeNum + newMapNodes - 1;
	}
	<span class="enscript-keyword">else</span>
	{
		err = ReleaseNode (btreePtr, &amp;mapNode);
		M_ExitOnError (err);
	
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Success</span>;
	}
	

	<span class="enscript-comment">/////////////////////// Initialize New Map Nodes ////////////////////////////
</span>	<span class="enscript-comment">// XXXdbg - this is the correct place for this:
</span>	ModifyBlockStart(btreePtr-&gt;fileRefNum, &amp;mapNode);

	((BTNodeDescriptor*)mapNode.buffer)-&gt;fLink = firstNewMapNodeNum;

	nodeNum		= firstNewMapNodeNum;
	<span class="enscript-keyword">while</span> (true)
	{
		err = GetNewNode (btreePtr, nodeNum, &amp;newNode);
		M_ExitOnError (err);
		
		<span class="enscript-comment">// XXXdbg
</span>		ModifyBlockStart(btreePtr-&gt;fileRefNum, &amp;newNode);

		((NodeDescPtr)newNode.buffer)-&gt;numRecords	= 1;
		((NodeDescPtr)newNode.buffer)-&gt;kind = kBTMapNode;
		
		<span class="enscript-comment">// set free space offset
</span>		*(u_int16_t *)((Ptr)newNode.buffer + nodeSize - 4) = nodeSize - 6;

		<span class="enscript-keyword">if</span> (nodeNum++ == lastNewMapNodeNum)
			<span class="enscript-keyword">break</span>;

		((BTNodeDescriptor*)newNode.buffer)-&gt;fLink = nodeNum;	<span class="enscript-comment">// point to next map node
</span>			
		err = UpdateNode (btreePtr, &amp;newNode, 0, kLockTransaction);
		M_ExitOnError (err);
	}
	
	err = UpdateNode (btreePtr, &amp;newNode, 0, kLockTransaction);
	M_ExitOnError (err);
		

	<span class="enscript-comment">///////////////////// Mark New Map Nodes Allocated //////////////////////////
</span>
	nodeNum = firstNewMapNodeNum;
	<span class="enscript-keyword">do</span> {	
		bitInRecord	= nodeNum - recStartBit;

		<span class="enscript-keyword">while</span> (bitInRecord &gt;= mapBits)
		{
			nextNodeNum = ((NodeDescPtr)mapNode.buffer)-&gt;fLink;
			<span class="enscript-keyword">if</span> ( nextNodeNum == 0)
			{
				err = fsBTNoMoreMapNodesErr;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
			}
			
			err = UpdateNode (btreePtr, &amp;mapNode, 0, kLockTransaction);
			M_ExitOnError (err);
			
			err = GetNode (btreePtr, nextNodeNum, 0, &amp;mapNode);
			M_ExitOnError (err);
			
			<span class="enscript-comment">// XXXdbg
</span>			ModifyBlockStart(btreePtr-&gt;fileRefNum, &amp;mapNode);

			mapIndex = 0;
			
			mapStart	 = (u_int16_t *) GetRecordAddress (btreePtr, mapNode.buffer, mapIndex);
			mapSize		 = GetRecordSize (btreePtr, mapNode.buffer, mapIndex);
			
			<span class="enscript-keyword">if</span> (DEBUG_BUILD &amp;&amp; mapSize != M_MapRecordSize (btreePtr-&gt;nodeSize) )
			{
				Panic (<span class="enscript-string">&quot;ExtendBTree: mapSize != M_MapRecordSize&quot;</span>);
			}
			
			mapBits		= mapSize &lt;&lt; 3;		<span class="enscript-comment">// mapSize (in bytes) * 8
</span>			recStartBit	= totalMapBits;		<span class="enscript-comment">// bit number of first bit in map record
</span>			totalMapBits  += mapBits;

			bitInRecord	= nodeNum - recStartBit;
		}

		mapPos		= mapStart + ((nodeNum - recStartBit) &gt;&gt; 4);
		bitInWord	= 15 - ((nodeNum - recStartBit) &amp; 0x0000000F);
        
        M_SWAP_BE16_SetBitNum (*mapPos, bitInWord);
        
		++nodeNum;
		
	} <span class="enscript-keyword">while</span> (nodeNum &lt;= lastNewMapNodeNum);

	err = UpdateNode (btreePtr, &amp;mapNode, 0, kLockTransaction);
	M_ExitOnError (err);

	
	<span class="enscript-comment">//////////////////////////////// Success ////////////////////////////////////
</span>
<span class="enscript-reference">Success</span>:
	
	btreePtr-&gt;totalNodes	 =  newTotalNodes;
	btreePtr-&gt;freeNodes		+= (newTotalNodes - oldTotalNodes) - newMapNodes;

	M_BTreeHeaderDirty(btreePtr);

	<span class="enscript-comment">/* Force the b-tree header changes to disk */</span>
	(<span class="enscript-type">void</span>) UpdateHeader (btreePtr, true);
	
	<span class="enscript-keyword">return</span>	noErr;


	<span class="enscript-comment">////////////////////////////// Error Exit ///////////////////////////////////
</span>
<span class="enscript-reference">ErrorExit</span>:
	
	(<span class="enscript-type">void</span>) ReleaseNode (btreePtr, &amp;mapNode);
	(<span class="enscript-type">void</span>) ReleaseNode (btreePtr, &amp;newNode);
	
	<span class="enscript-keyword">return</span>	err;
}



<span class="enscript-comment">/*-------------------------------------------------------------------------------

Routine:	GetMapNode	-	Get the next map node and pointer to the map record.

Function:	Given a BlockDescriptor to a map node in nodePtr, GetMapNode releases
			it and gets the next node. If nodePtr-&gt;buffer is nil, then the header
			node is retrieved.


Input:		btreePtr	- pointer to control block for BTree file
			nodePtr		- pointer to a BlockDescriptor of a map node
			
Output:		nodePtr		- pointer to the BlockDescriptor for the next map node
			mapPtr		- pointer to the map record within the map node
			mapSize		- number of bytes in the map record
			
Result:		noErr			- success
			fsBTNoMoreMapNodesErr	- we've run out of map nodes
			fsBTInvalidNodeErr			- bad node, or not node type kMapNode
			!= noErr		- failure
-------------------------------------------------------------------------------*/</span>

<span class="enscript-type">static</span>
OSStatus	GetMapNode (BTreeControlBlockPtr	  btreePtr,
						BlockDescriptor			 *nodePtr,
						u_int16_t				**mapPtr, 			
						u_int16_t				 *mapSize )
{
	OSStatus	err;
	u_int16_t	mapIndex;
	u_int32_t	nextNodeNum;
	
	<span class="enscript-keyword">if</span> (nodePtr-&gt;buffer != nil)		<span class="enscript-comment">// if iterator is valid...
</span>	{
		nextNodeNum = ((NodeDescPtr)nodePtr-&gt;buffer)-&gt;fLink;
		<span class="enscript-keyword">if</span> (nextNodeNum == 0)
		{
			err = fsBTNoMoreMapNodesErr;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		
		err = ReleaseNode (btreePtr, nodePtr);
		M_ExitOnError (err);
		
		err = GetNode (btreePtr, nextNodeNum, 0, nodePtr);
		M_ExitOnError (err);
		
		<span class="enscript-keyword">if</span> ( ((NodeDescPtr)nodePtr-&gt;buffer)-&gt;kind != kBTMapNode)
		{
			err = fsBTBadNodeType;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		
		++btreePtr-&gt;numMapNodesRead;
		mapIndex = 0;
	} <span class="enscript-keyword">else</span> {
		err = GetNode (btreePtr, kHeaderNodeNum, 0, nodePtr);
		M_ExitOnError (err);
		
		<span class="enscript-keyword">if</span> ( ((NodeDescPtr)nodePtr-&gt;buffer)-&gt;kind != kBTHeaderNode)
		{
			err = fsBTInvalidHeaderErr;				<span class="enscript-comment">//€€ or fsBTBadNodeType
</span>			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		
		mapIndex = 2;
	}
	
		
	*mapPtr		= (u_int16_t *) GetRecordAddress (btreePtr, nodePtr-&gt;buffer, mapIndex);
	*mapSize	= GetRecordSize (btreePtr, nodePtr-&gt;buffer, mapIndex);
	
	<span class="enscript-keyword">return</span> noErr;
	
	
<span class="enscript-reference">ErrorExit</span>:
	
	(<span class="enscript-type">void</span>) ReleaseNode (btreePtr, nodePtr);
	
	*mapPtr		= nil;
	*mapSize	= 0;
	
	<span class="enscript-keyword">return</span>	err;
}



<span class="enscript-comment">////////////////////////////////// CalcMapBits //////////////////////////////////
</span>
u_int32_t		CalcMapBits	(BTreeControlBlockPtr	 btreePtr)
{
	u_int32_t		mapBits;
	
	mapBits		= M_HeaderMapRecordSize (btreePtr-&gt;nodeSize) &lt;&lt; 3;
	
	<span class="enscript-keyword">while</span> (mapBits &lt; btreePtr-&gt;totalNodes)
		mapBits	+= M_MapRecordSize (btreePtr-&gt;nodeSize) &lt;&lt; 3;
	
	<span class="enscript-keyword">return</span>	mapBits;
}


<span class="enscript-comment">/*-------------------------------------------------------------------------------
Routine:	BTZeroUnusedNodes

Function:	Write zeros to all nodes in the B-tree that are not currently in use.
-------------------------------------------------------------------------------*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">BTZeroUnusedNodes</span>(FCB *filePtr)
{
	<span class="enscript-type">int</span>						err;
	vnode_t					vp;
	BTreeControlBlockPtr	btreePtr;
	BlockDescriptor			mapNode;
	buf_t					bp;
	u_int32_t				nodeNumber;
	u_int16_t				*mapPtr, *pos;
	u_int16_t				mapSize, size;
	u_int16_t				mask;
	u_int16_t				bitNumber;
	u_int16_t				word;
	<span class="enscript-type">int</span>						numWritten;
	
	vp = FTOV(filePtr);
	btreePtr = (BTreeControlBlockPtr) filePtr-&gt;fcbBTCBPtr;
	bp = NULL;
	nodeNumber = 0;
	mapNode.buffer = nil;
	mapNode.blockHeader = nil;
	numWritten = 0;
	
	<span class="enscript-comment">/* Iterate over map nodes. */</span>
	<span class="enscript-keyword">while</span> (true)
	{
		err = GetMapNode (btreePtr, &amp;mapNode, &amp;mapPtr, &amp;mapSize);
		<span class="enscript-keyword">if</span> (err)
		{
			err = MacToVFSError(err);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		
		pos		= mapPtr;
		size	= mapSize;
		size  &gt;&gt;= 1;					<span class="enscript-comment">/* convert to number of 16-bit words */</span>

		<span class="enscript-comment">/* Iterate over 16-bit words in the map record. */</span>
		<span class="enscript-keyword">while</span> (size--)
		{
			<span class="enscript-keyword">if</span> (*pos != 0xFFFF)			<span class="enscript-comment">/* Anything free in this word? */</span>
			{
				word = SWAP_BE16(*pos);
				
				<span class="enscript-comment">/* Iterate over bits in the word. */</span>
				<span class="enscript-keyword">for</span> (bitNumber = 0, mask = 0x8000;
				     bitNumber &lt; 16;
				     ++bitNumber, mask &gt;&gt;= 1)
				{
					<span class="enscript-keyword">if</span> (word &amp; mask)
						<span class="enscript-keyword">continue</span>;				<span class="enscript-comment">/* This node is in use. */</span>
					
					<span class="enscript-keyword">if</span> (nodeNumber + bitNumber &gt;= btreePtr-&gt;totalNodes)
					{
						<span class="enscript-comment">/* We've processed all of the nodes. */</span>
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
					}
					
					<span class="enscript-comment">/*
					 * Get a buffer full of zeros and write it to the unused
					 * node.  Since we'll probably be writing a lot of nodes,
					 * bypass the journal (to avoid a transaction that's too
					 * big).  Instead, this behaves more like clearing out
					 * nodes when extending a B-tree (eg., ClearBTNodes).
					 */</span>
					bp = buf_getblk(vp, nodeNumber + bitNumber, btreePtr-&gt;nodeSize, 0, 0, BLK_META);
					<span class="enscript-keyword">if</span> (bp == NULL)
					{
						printf(<span class="enscript-string">&quot;hfs: BTZeroUnusedNodes: unable to read node %u\n&quot;</span>, nodeNumber + bitNumber);
						err = EIO;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
					}

					<span class="enscript-keyword">if</span> (buf_flags(bp) &amp; B_LOCKED) {
						<span class="enscript-comment">/* 
						 * This node is already part of a transaction and will be written when
						 * the transaction is committed, so don't write it here.  If we did, then
						 * we'd hit a panic in hfs_vnop_bwrite because the B_LOCKED bit is still set.
						 */</span>
						buf_brelse(bp);
						<span class="enscript-keyword">continue</span>;
					}
					
					buf_clear(bp);
					buf_markaged(bp);
					
					<span class="enscript-comment">/*
					 * Try not to hog the buffer cache.  Wait for the write
					 * every 32 nodes.   If VNOP_BWRITE reports an error, bail out and bubble
					 * it up to the function calling us.  If we tried to update a read-only 
					 * mount on read-only media, for example, catching the error will let 
					 * us alert the callers of this function that they should maintain 
					 * the mount in read-only mode.

					 */</span>
					++numWritten;
					<span class="enscript-keyword">if</span> (numWritten % 32 == 0) {
						err = VNOP_BWRITE(bp);
						<span class="enscript-keyword">if</span> (err) {
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
						}
					}
					<span class="enscript-keyword">else</span> {
						buf_bawrite(bp);
					}
				}
			}
			
			<span class="enscript-comment">/* Go to the next word in the bitmap */</span>
			++pos;
			nodeNumber += 16;
		}
	}

<span class="enscript-reference">ErrorExit</span>:
<span class="enscript-reference">done</span>:
	(<span class="enscript-type">void</span>) ReleaseNode(btreePtr, &amp;mapNode);
	
	<span class="enscript-keyword">return</span> err;
}
</pre>
<hr />
</body></html>