<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>VolumeAllocation.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">VolumeAllocation.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
	File:		VolumeAllocation.c

	Contains:	Routines for accessing and modifying the volume bitmap.

	Version:	HFS Plus 1.0

	Copyright:	ï¿½ 1996-2009 by Apple Computer, Inc., all rights reserved.

*/</span>

<span class="enscript-comment">/*
Public routines:
	BlockAllocate / hfs_block_alloc
					Allocate space on a volume.  Can allocate space contiguously.
					If not contiguous, then allocation may be less than what was
					asked for.  Returns the starting block number, and number of
					blocks.  It will only return a single extent.

	BlockDeallocate
					Deallocate a contiguous run of allocation blocks.
 
	BlockMarkAllocated
					Exported wrapper to mark blocks as in-use.  This will correctly determine
					whether or not the red-black tree is enabled and call the appropriate function 
					if applicable.
	BlockMarkFree
					Exported wrapper to mark blocks as freed.  This will correctly determine whether or
					not the red-black tree is enabled and call the appropriate function if applicable.

 
	ResetVCBFreeExtCache
					Since the red-black tree obviates the need to maintain the free extent cache, we do
					not update it if the tree is also live.  As a result, if we ever need to destroy the trees
					we should reset the free extent cache so it doesn't confuse us when we need to fall back to the
					bitmap scanning allocator.
					We also reset and disable the free extent cache when volume resizing is 
					in flight.
 
	UpdateAllocLimit 
					Adjusts the AllocLimit field in the hfs mount point.  This is used when we need to prevent
					allocations from occupying space in the region we are modifying during a filesystem resize.  
					At other times, it should be consistent with the total number of allocation blocks in the 
					filesystem.  It is also used to shrink or grow the number of blocks that the red-black tree should
					know about. If growing, scan the new range of bitmap, and if shrinking, reduce the
					number of items in the tree that we can allocate from.

	ScanUnmapBlocks	
					Traverse the entire allocation bitmap.  Potentially issue DKIOCUNMAPs to the device as it 
					tracks unallocated ranges when iterating the volume bitmap.  Additionally, build up the in-core
					summary table of the allocation bitmap.
 
Internal routines:
	BlockMarkFreeInternal
					Mark a contiguous range of blocks as free.  The corresponding
					bits in the volume bitmap will be cleared.  This will actually do the work
					of modifying the bitmap for us.
					
	BlockMarkAllocatedInternal
					Mark a contiguous range of blocks as allocated.  The cor-
					responding bits in the volume bitmap are set.  Also tests to see
					if any of the blocks were previously unallocated.  
	BlockFindContiguous
					Find a contiguous range of blocks of a given size.  The caller
					specifies where to begin the search (by block number).  The
					block number of the first block in the range is returned.  This is only
					called by the bitmap scanning logic as the red-black tree should be able
					to do this internally by searching its tree. 
	BlockFindAny
					Find and allocate a contiguous range of blocks up to a given size.  The
					first range of contiguous free blocks found are allocated, even if there
					are fewer blocks than requested (and even if a contiguous range of blocks
					of the given size exists elsewhere).
	BlockFindAnyBitmap
					Finds a range of blocks per the above requirements without using the 
					Allocation RB Tree.  This relies on the bitmap-scanning logic in order to find
					any valid range of free space needed.
	BlockFindContig
					Find a contiguous range of blocks of a given size.
					If the minimum cannot be satisfied, nothing is
					returned.
	BlockFindKnown
					Try to allocate space from known free space in the volume's
					free extent cache.
	ReadBitmapBlock
					Given an allocation block number, read the bitmap block that
					contains that allocation block into a caller-supplied buffer.

	ReleaseBitmapBlock
					Release a bitmap block back into the buffer cache.
	
	ReadBitmapRange
					Given an allocation block number, read a range of bitmap that
					must begin at that allocation block into a caller supplied buffer.

	ReleaseBitmapRange
					Release and invalidate a buf_t corresponding to the bitmap
					back into the UBC in order to prevent coherency issues.

	remove_free_extent_cache
					Remove an extent from the free extent cache.  Handles overlaps
					with multiple extents in the cache, and handles splitting an
					extent in the cache if the extent to be removed is in the middle
					of a cached extent.
	
	add_free_extent_cache
					Add an extent to the free extent cache.  It will merge the
					input extent with extents already in the cache.
	CheckUnmappedBytes
					Check whether or not the current transaction
					has allocated blocks that were recently freed. This may have data safety implications.


 
Debug/Test Routines
	hfs_isallocated
					Test to see if any blocks in a range are allocated.  Journal or
					allocation file lock must be held.
 
	hfs_isallocated_scan
					Test to see if any blocks in a range are allocated.  Releases and
					invalidates the block used when finished.
	 
Optimization Routines 
	hfs_alloc_scan_block
					Given a starting allocation block number, figures out which physical block contains that 
					allocation block's bit, and scans it from the starting bit until either the ending bit or
					the end of the block.  Free space extents are inserted into the appropriate red-black tree.
					
*/</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_macos_defs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
<span class="enscript-comment">/* For VM Page size */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_journal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../headers/FileMgrInternal.h&quot;</span>

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_dbg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_format.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_kdebug.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../rangelist.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../hfs_extents.h&quot;</span>

<span class="enscript-comment">/* Headers for unmap-on-mount support */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_HFS_TRIM</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONFIG_HFS_TRIM</span> 0
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Use sysctl vfs.generic.hfs.kdebug.allocation to control which
 * KERNEL_DEBUG_CONSTANT events are enabled at runtime.  (They're
 * disabled by default because there can be a lot of these events,
 * and we don't want to overwhelm the kernel debug buffer.  If you
 * want to watch these events in particular, just set the sysctl.)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> hfs_kdebug_allocation = 0;
<span class="enscript-function-name">SYSCTL_DECL</span>(_vfs_generic);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic, OID_AUTO, hfs, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;HFS file system&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic_hfs, OID_AUTO, kdebug, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;HFS kdebug&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_hfs_kdebug, OID_AUTO, allocation, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;hfs_kdebug_allocation, 0, <span class="enscript-string">&quot;Enable kdebug logging for HFS allocations&quot;</span>);
<span class="enscript-type">enum</span> {
	<span class="enscript-comment">/*
	 * HFSDBG_ALLOC_ENABLED: Log calls to BlockAllocate and
	 * BlockDeallocate, including the internal BlockAllocateXxx
	 * routines so we can see how an allocation was satisfied.
	 *
	 * HFSDBG_EXT_CACHE_ENABLED: Log routines that read or write the
	 * free extent cache.
	 *
	 * HFSDBG_UNMAP_ENABLED: Log events involving the trim list.
	 *
	 * HFSDBG_BITMAP_ENABLED: Log accesses to the volume bitmap (setting
	 * or clearing bits, scanning the bitmap).
	 */</span>
	HFSDBG_ALLOC_ENABLED		= 1,
	HFSDBG_EXT_CACHE_ENABLED	= 2,
	HFSDBG_UNMAP_ENABLED		= 4,
	HFSDBG_BITMAP_ENABLED		= 8
};

<span class="enscript-type">enum</span> {
	kBytesPerWord			=	4,
	kBitsPerByte			=	8,
	kBitsPerWord			=	32,

	kBitsWithinWordMask		=	kBitsPerWord-1
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kLowBitInWordMask</span>	0x00000001ul
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHighBitInWordMask</span>	0x80000000ul
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kAllBitsSetInWord</span>	0xFFFFFFFFul

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MIN_SUMMARY_BLOCKSIZE</span> 4096

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ALLOC_DEBUG</span> 0

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReadBitmapBlock</span>(
		ExtendedVCB		*vcb,
		u_int32_t		bit,
		u_int32_t		**buffer,
		uintptr_t		*blockRef,
		hfs_block_alloc_flags_t flags);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReleaseBitmapBlock</span>(
		ExtendedVCB		*vcb,
		uintptr_t		blockRef,
		Boolean			dirty);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">hfs_block_alloc_int</span>(hfsmount_t *hfsmp,
								 HFSPlusExtentDescriptor *extent,
								 hfs_block_alloc_flags_t flags,
								 hfs_alloc_extra_args_t *ap);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindAny</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		endingBlock,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		Boolean			trustSummary,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindAnyBitmap</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		endingBlock,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindContig</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		minBlocks,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindContiguous</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		endingBlock,
		u_int32_t		minBlocks,
		u_int32_t		maxBlocks,
		Boolean			useMetaZone,
		Boolean			trustSummary,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks,
		hfs_block_alloc_flags_t flags);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindKnown</span>(
		ExtendedVCB		*vcb,
		u_int32_t		maxBlocks,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">hfs_alloc_try_hard</span>(hfsmount_t *hfsmp,
								HFSPlusExtentDescriptor *extent,
								uint32_t max_blocks,
								hfs_block_alloc_flags_t flags);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockMarkAllocatedInternal</span> (
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		numBlocks,
		hfs_block_alloc_flags_t flags);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockMarkFreeInternal</span>(
		ExtendedVCB	*vcb,
		u_int32_t	startingBlock,
		u_int32_t	numBlocks, 
		Boolean 	do_validate);


<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReadBitmapRange</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t offset, uint32_t iosize,
		uint32_t **buffer, <span class="enscript-type">struct</span> buf **blockRef);

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReleaseScanBitmapRange</span>( <span class="enscript-type">struct</span> buf *bp );

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_track_unmap_blocks</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t offset, 
		u_int32_t numBlocks, <span class="enscript-type">struct</span> jnl_trim_list *list);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_issue_unmap</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> jnl_trim_list *list);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_alloc_scan_range</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, 
		u_int32_t startbit, 
		u_int32_t *bitToScan,
		<span class="enscript-type">struct</span> jnl_trim_list *list);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_scan_range_size</span> (<span class="enscript-type">struct</span> hfsmount* hfsmp, uint32_t start, uint32_t *iosize);
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">CheckUnmappedBytes</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint64_t blockno, uint64_t numblocks, <span class="enscript-type">int</span> *recent, uint32_t *next);

<span class="enscript-comment">/* Bitmap Re-use Detection */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">extents_overlap</span> (uint32_t start1, uint32_t len1,
		uint32_t start2, uint32_t len2) {
	<span class="enscript-keyword">return</span> !( ((start1 + len1) &lt;= start2) || ((start2 + len2) &lt;= start1) );
}


<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_isallocated_scan</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp,
		u_int32_t startingBlock,
		u_int32_t *bp_buf);

<span class="enscript-comment">/* Summary Table Functions */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_set_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t summarybit, uint32_t inuse);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_get_summary_index</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block, uint32_t *index);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_find_summary_free</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block, uint32_t *newblock);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_get_summary_allocblock</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t summarybit, uint32_t *alloc);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_release_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t start, uint32_t length);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_check_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t start, uint32_t *freeblocks);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_rebuild_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_get_next_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block, uint32_t *newblock);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Used in external mount code to initialize the summary table */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_init_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ALLOC_DEBUG</span> 
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_validate_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* Functions for manipulating free extent cache */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">remove_free_extent_cache</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, u_int32_t blockCount);
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">add_free_extent_cache</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, u_int32_t blockCount);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sanity_check_free_ext</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> check_allocated);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_release_reserved</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> rl_entry *range, <span class="enscript-type">int</span> list);

<span class="enscript-comment">/* Functions for getting free exents */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> bitmap_context {
	<span class="enscript-type">void</span>			*bitmap;				<span class="enscript-comment">// current bitmap chunk
</span>	uint32_t		run_offset;				<span class="enscript-comment">// offset (in bits) from start of bitmap to start of current run
</span>	uint32_t		chunk_current;			<span class="enscript-comment">// next bit to scan in the chunk
</span>	uint32_t		chunk_end;				<span class="enscript-comment">// number of valid bits in this chunk
</span>	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> buf		*bp;
	uint32_t		last_free_summary_bit;	<span class="enscript-comment">// last marked free summary bit
</span>	<span class="enscript-type">int</span>				lockflags;
	uint64_t		lock_start;
} bitmap_context_t;


<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">get_more_bits</span>(bitmap_context_t *bitmap_ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bit_count_set</span>(<span class="enscript-type">void</span> *bitmap, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bit_count_clr</span>(<span class="enscript-type">void</span> *bitmap, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count</span>(bitmap_context_t *bitmap_ctx, <span class="enscript-type">int</span> (*fn)(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span> ,<span class="enscript-type">int</span>), uint32_t *bit_count);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count_set</span>(bitmap_context_t *bitmap_ctx, uint32_t *count);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count_clr</span>(bitmap_context_t *bitmap_ctx, uint32_t *count);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">update_summary_table</span>(bitmap_context_t *bitmap_ctx, uint32_t start, uint32_t count, bool set);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">clzll</span>(uint64_t x);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ALLOC_DEBUG</span>
<span class="enscript-comment">/*
 * Validation Routine to verify that the TRIM list maintained by the journal
 * is in good shape relative to what we think the bitmap should have.  We should
 * never encounter allocated blocks in the TRIM list, so if we ever encounter them,
 * we panic.  
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">trim_validate_bitmap</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">int</span> <span class="enscript-function-name">trim_validate_bitmap</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	u_int64_t blockno_offset;
	u_int64_t numblocks;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> count;
	u_int32_t startblk;
	u_int32_t blks;
	<span class="enscript-type">int</span> err = 0;
	uint32_t alloccount = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		<span class="enscript-type">struct</span> journal *jnl = (<span class="enscript-type">struct</span> journal*)hfsmp-&gt;jnl;
		<span class="enscript-keyword">if</span> (jnl-&gt;active_tr) {
			<span class="enscript-type">struct</span> jnl_trim_list *trim = &amp;(jnl-&gt;active_tr-&gt;trim);
			count = trim-&gt;extent_count;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
				blockno_offset = trim-&gt;extents[i].offset;
				blockno_offset = blockno_offset - (uint64_t)hfsmp-&gt;hfsPlusIOPosOffset;
				blockno_offset = blockno_offset / hfsmp-&gt;blockSize;
				numblocks = trim-&gt;extents[i].length / hfsmp-&gt;blockSize;

				startblk = (u_int32_t)blockno_offset;
				blks = (u_int32_t) numblocks;
				err = hfs_count_allocated (hfsmp, startblk, blks, &amp;alloccount);

				<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; alloccount != 0) {
					panic (<span class="enscript-string">&quot;trim_validate_bitmap: %d blocks @ ABN %d are allocated!&quot;</span>, alloccount, startblk);
				}
			}
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		hfs_unmap_free_extent
 ;
 ; Function:		Make note of a range of allocation blocks that should be
 ;				unmapped (trimmed).  That is, the given range of blocks no
 ;				longer have useful content, and the device can unmap the
 ;				previous contents.  For example, a solid state disk may reuse
 ;				the underlying storage for other blocks.
 ;
 ;				This routine is only supported for journaled volumes.  The extent
 ;				being freed is passed to the journal code, and the extent will
 ;				be unmapped after the current transaction is written to disk.
 ;
 ; Input Arguments:
 ;	hfsmp			- The volume containing the allocation blocks.
 ;	startingBlock	- The first allocation block of the extent being freed.
 ;	numBlocks		- The number of allocation blocks of the extent being freed.
 ;________________________________________________________________________________
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unmap_free_extent</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, u_int32_t numBlocks)
{
	u_int64_t offset;
	u_int64_t length;
	u_int64_t device_sz;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_FREE | DBG_FUNC_START, startingBlock, numBlocks, 0, 0, 0);

	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		<span class="enscript-keyword">if</span> (hfs_isallocated(hfsmp, startingBlock, numBlocks)) {
			panic(<span class="enscript-string">&quot;hfs: %p: (%u,%u) unmapping allocated blocks&quot;</span>, hfsmp, startingBlock, numBlocks);
		}
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl != NULL) {
		device_sz = hfsmp-&gt;hfs_logical_bytes;
		offset = (u_int64_t) startingBlock * hfsmp-&gt;blockSize + (u_int64_t) hfsmp-&gt;hfsPlusIOPosOffset;
		length = (u_int64_t) numBlocks * hfsmp-&gt;blockSize;

		<span class="enscript-comment">/* Validate that the trim is in a valid range of bytes */</span>
		<span class="enscript-keyword">if</span> ((offset &gt;= device_sz) || ((offset + length) &gt; device_sz)) {
			printf(<span class="enscript-string">&quot;hfs_unmap_free_ext: ignoring trim vol=%s @ off %lld len %lld \n&quot;</span>, hfsmp-&gt;vcbVN, offset, length);
			err = EINVAL;
		}

		<span class="enscript-keyword">if</span> (err == 0) {
			err = journal_trim_add_extent(hfsmp-&gt;jnl, offset, length);
			<span class="enscript-keyword">if</span> (err) {
				printf(<span class="enscript-string">&quot;hfs_unmap_free_extent: error %d from journal_trim_add_extent for vol=%s&quot;</span>, err, hfsmp-&gt;vcbVN);
			}
		}
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_FREE | DBG_FUNC_END, err, 0, 0, 0, 0);
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		hfs_track_unmap_blocks
 ;
 ; Function:	Make note of a range of allocation blocks that should be
 ;				unmapped (trimmed).  That is, the given range of blocks no
 ;				longer have useful content, and the device can unmap the
 ;				previous contents.  For example, a solid state disk may reuse
 ;				the underlying storage for other blocks.
 ;
 ;				This routine is only supported for journaled volumes.  
 ; 
 ;              *****NOTE*****: 
 ;              This function should *NOT* be used when the volume is fully 
 ;              mounted.  This function is intended to support a bitmap iteration
 ;              at mount time to fully inform the SSD driver of the state of all blocks
 ;              at mount time, and assumes that there is no allocation/deallocation
 ;              interference during its iteration.,
 ;
 ; Input Arguments:
 ;	hfsmp			- The volume containing the allocation blocks.
 ;	offset          - The first allocation block of the extent being freed.
 ;	numBlocks		- The number of allocation blocks of the extent being freed.
 ;  list            - The list of currently tracked trim ranges.
 ;________________________________________________________________________________
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_track_unmap_blocks</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t start, 
		u_int32_t numBlocks, <span class="enscript-type">struct</span> jnl_trim_list *list) {

	u_int64_t offset;
	u_int64_t length;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_UNMAP) &amp;&amp; (hfsmp-&gt;jnl != NULL) &amp;&amp; list-&gt;allocated_count &amp;&amp; list-&gt;extents != NULL) {
		<span class="enscript-type">int</span> extent_no = list-&gt;extent_count;
		offset = (u_int64_t) start * hfsmp-&gt;blockSize + (u_int64_t) hfsmp-&gt;hfsPlusIOPosOffset;
		length = (u_int64_t) numBlocks * hfsmp-&gt;blockSize;


		list-&gt;extents[extent_no].offset = offset;
		list-&gt;extents[extent_no].length = length;
		list-&gt;extent_count++;
		<span class="enscript-keyword">if</span> (list-&gt;extent_count == list-&gt;allocated_count) {
			error = hfs_issue_unmap (hfsmp, list);
		}
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		hfs_issue_unmap
 ;
 ; Function:	Issue a DKIOCUNMAP for all blocks currently tracked by the jnl_trim_list
 ;
 ; Input Arguments:
 ;	hfsmp			- The volume containing the allocation blocks.
 ;  list            - The list of currently tracked trim ranges.
 ;________________________________________________________________________________
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_issue_unmap</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> jnl_trim_list *list) 
{
	dk_unmap_t unmap;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_SCAN_TRIM | DBG_FUNC_START, hfsmp-&gt;hfs_raw_dev, 0, 0, 0, 0);
	}

	<span class="enscript-keyword">if</span> (list-&gt;extent_count &gt; 0 &amp;&amp; list-&gt;extents != NULL) {
		bzero(&amp;unmap, <span class="enscript-keyword">sizeof</span>(unmap));
		unmap.extents = list-&gt;extents;
		unmap.extentsCount = list-&gt;extent_count;

		<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED) {
			KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_SCAN_TRIM | DBG_FUNC_NONE, hfsmp-&gt;hfs_raw_dev, unmap.extentsCount, 0, 0, 0);
		}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">/* 
		 * If we have not yet completed the first scan through the bitmap, then
		 * optionally inform the block driver below us that this is an initialization
		 * TRIM scan, if it can deal with this information.
		 */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;scan_var &amp; HFS_ALLOCATOR_SCAN_COMPLETED) == 0) {
			unmap.options |= _DK_UNMAP_INITIALIZE;	
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Issue a TRIM and flush them out */</span>
		error = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, DKIOCUNMAP, (caddr_t)&amp;unmap, 0, vfs_context_kernel());

		bzero (list-&gt;extents, (list-&gt;allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t)));
		bzero (&amp;unmap, <span class="enscript-keyword">sizeof</span>(unmap));
		list-&gt;extent_count = 0;
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_SCAN_TRIM | DBG_FUNC_END, error, hfsmp-&gt;hfs_raw_dev, 0, 0, 0);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		hfs_unmap_alloc_extent
 ;
 ; Function:		Make note of a range of allocation blocks, some of
 ;				which may have previously been passed to hfs_unmap_free_extent,
 ;				is now in use on the volume.  The given blocks will be removed
 ;				from any pending DKIOCUNMAP.
 ;
 ; Input Arguments:
 ;	hfsmp			- The volume containing the allocation blocks.
 ;	startingBlock	- The first allocation block of the extent being allocated.
 ;	numBlocks		- The number of allocation blocks being allocated.
 ;________________________________________________________________________________
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unmap_alloc_extent</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, u_int32_t numBlocks)
{
	u_int64_t offset;
	u_int64_t length;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_ALLOC | DBG_FUNC_START, startingBlock, numBlocks, 0, 0, 0);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl != NULL) {
		offset = (u_int64_t) startingBlock * hfsmp-&gt;blockSize + (u_int64_t) hfsmp-&gt;hfsPlusIOPosOffset;
		length = (u_int64_t) numBlocks * hfsmp-&gt;blockSize;

		err = journal_trim_remove_extent(hfsmp-&gt;jnl, offset, length);
		<span class="enscript-keyword">if</span> (err) {
			printf(<span class="enscript-string">&quot;hfs_unmap_alloc_extent: error %d from journal_trim_remove_extent for vol=%s&quot;</span>, err, hfsmp-&gt;vcbVN);
		}
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_ALLOC | DBG_FUNC_END, err, 0, 0, 0, 0);
}


<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:		hfs_trim_callback
;
; Function:		This function is called when a transaction that freed extents
;				(via hfs_unmap_free_extent/journal_trim_add_extent) has been
;				written to the on-disk journal.  This routine will add those
;				extents to the free extent cache so that they can be reused.
;
;				CAUTION: This routine is called while the journal's trim lock
;				is held shared, so that no other thread can reuse any portion
;				of those extents.  We must be very careful about which locks
;				we take from within this callback, to avoid deadlock.  The
;				call to add_free_extent_cache will end up taking the cache's
;				lock (just long enough to add these extents to the cache).
;
;				CAUTION: If the journal becomes invalid (eg., due to an I/O
;				error when trying to write to the journal), this callback
;				will stop getting called, even if extents got freed before
;				the journal became invalid!
;
; Input Arguments:
;	arg				- The hfsmount of the volume containing the extents.
;	extent_count	- The number of extents freed in the transaction.
;	extents			- An array of extents (byte ranges) that were freed.
;________________________________________________________________________________
*/</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_trim_callback</span>(<span class="enscript-type">void</span> *arg, uint32_t extent_count, <span class="enscript-type">const</span> dk_extent_t *extents)
{
	uint32_t i;
	uint32_t startBlock, numBlocks;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = arg;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_CALLBACK | DBG_FUNC_START, 0, extent_count, 0, 0, 0);

	<span class="enscript-keyword">for</span> (i=0; i&lt;extent_count; ++i) {
		<span class="enscript-comment">/* Convert the byte range in *extents back to a range of allocation blocks. */</span>
		startBlock = (extents[i].offset - hfsmp-&gt;hfsPlusIOPosOffset) / hfsmp-&gt;blockSize;
		numBlocks = extents[i].length / hfsmp-&gt;blockSize;
		(<span class="enscript-type">void</span>) add_free_extent_cache(hfsmp, startBlock, numBlocks);
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_CALLBACK | DBG_FUNC_END, 0, 0, 0, 0, 0);
}


<span class="enscript-comment">/*
   ;________________________________________________________________________________
   ;
   ; Routine:		CheckUnmappedBytes
   ;
   ; Function:	From the specified inputs, determine if the extent in question overlaps 
   ;				space that was recently freed, where the recently freed space may still be
   ;				lingering in an uncommitted journal transaction.  This may have data safety 
   ;				implications.  The intended use is to decide whether or not to force a journal flush
   ;				before allowing file data I/O to be issued.  If we did not do this
   ;				then it would be possible to issue the file I/O ahead of the
   ;				journal, resulting in data being overwritten if the transaction either
   ;				is not committed or cannot be replayed.
   ;
   ;		NOTE: This function assumes that the journal and catalog/extent locks are held.
   ;
   ; Input Arguments:
   ;	hfsmp			- The volume containing the allocation blocks.
   ;	foffset			- start of the extent in question (in allocation blocks)
   ;	numbytes		- number of blocks in the extent.
   ;  recently_freed:	- output pointer containing whether or not the blocks were freed recently
   ;  overlap_end 		- end of the overlap between the argument extent and the trim list (in allocation blocks)
   ;
   ; Output:
   ;
   ; 		Returns 0 if we could determine extent validity for this (or a previous transaction)
   ; 		Returns errno if there was an error
   ;
   ;		If returned 0, then recently freed will contain a boolean that indicates
   ;		that it was recently freed.
   ;________________________________________________________________________________
 */</span>

u_int32_t
<span class="enscript-function-name">CheckUnmappedBytes</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint64_t blockno, uint64_t numblocks, <span class="enscript-type">int</span> *recently_freed, uint32_t *overlap_end) {
	uint64_t device_offset;
	uint64_t numbytes;
	uint32_t err = 0;
	uint64_t lba_overlap_end;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl != NULL) {
		<span class="enscript-comment">/*
		 * Convert the allocation block # and the number of blocks into device-relative
		 * offsets so that they can be compared using the TRIM list.
		 */</span>
		uint64_t device_sz = hfsmp-&gt;hfs_logical_bytes;
		device_offset = blockno * ((uint64_t)hfsmp-&gt;blockSize);
		device_offset += hfsmp-&gt;hfsPlusIOPosOffset;
		numbytes = (((uint64_t)hfsmp-&gt;blockSize) * numblocks);

		<span class="enscript-comment">/* 
		 * Since we check that the device_offset isn't too large, it's safe to subtract it
		 * from the size in the second check.
		 */</span>
		<span class="enscript-keyword">if</span> ((device_offset &gt;= device_sz) || (numbytes &gt; (device_sz - device_offset))) {
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/* Ask the journal if this extent overlaps with any pending TRIMs */</span>
		<span class="enscript-keyword">if</span> (journal_trim_extent_overlap (hfsmp-&gt;jnl, device_offset, numbytes, &amp;lba_overlap_end)) {
			*recently_freed = 1;

			<span class="enscript-comment">/* Convert lba_overlap_end back into allocation blocks */</span>
			uint64_t end_offset = lba_overlap_end - hfsmp-&gt;hfsPlusIOPosOffset;
			end_offset = end_offset / ((uint64_t) hfsmp-&gt;blockSize);
			*overlap_end = (uint32_t) end_offset;
		}
		<span class="enscript-keyword">else</span> {
			*recently_freed = 0;
		}
		err = 0;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* There may not be a journal.  In that case, always return success.  */</span>
		*recently_freed = 0;
	}
	<span class="enscript-keyword">return</span> err;

}


<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:		ScanUnmapBlocks
 ;
 ; Function:	Traverse the bitmap, and potentially issue DKIOCUNMAPs to the underlying
 ;				device as needed so that the underlying disk device is as
 ;				up-to-date as possible with which blocks are unmapped.
 ;				Additionally build up the summary table as needed.
 ;
 ;				This function reads the bitmap in large block size 
 ; 				(up to 1MB) unlink the runtime which reads the bitmap 
 ; 				in 4K block size.  So if this function is being called 
 ;				after the volume is mounted and actively modified, the 
 ;				caller needs to invalidate all of the existing buffers 
 ;				associated with the bitmap vnode before calling this 
 ; 				function.  If the buffers are not invalidated, it can 
 ;				cause but_t collision and potential data corruption.
 ;  
 ; Input Arguments:
 ;	hfsmp			- The volume containing the allocation blocks.
 ;________________________________________________________________________________
 */</span>

__private_extern__
u_int32_t <span class="enscript-function-name">ScanUnmapBlocks</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) 
{
	u_int32_t blocks_scanned = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> jnl_trim_list trimlist;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_SCAN | DBG_FUNC_START, hfsmp-&gt;hfs_raw_dev, 0, 0, 0, 0);
	}

	<span class="enscript-comment">/*
	 *struct jnl_trim_list {
	 uint32_t    allocated_count;
	 uint32_t    extent_count;
	 dk_extent_t *extents;
	 };
	 */</span>
	bzero (&amp;trimlist, <span class="enscript-keyword">sizeof</span>(trimlist));

	<span class="enscript-comment">/* 
	 * The scanning itself here is not tied to the presence of CONFIG_HFS_TRIM
	 * which is now enabled for most architectures.  Instead, any trim related 
	 * work should be tied to whether the underlying storage media supports 
	 * UNMAP, as any solid state device would on desktop or embedded.
	 * 
	 * We do this because we may want to scan the full bitmap on desktop
	 * for spinning media for the purposes of building up the 
	 * summary table. 
	 * 
	 * We also avoid sending TRIMs down to the underlying media if the mount is read-only.
	 */</span>

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_UNMAP) &amp;&amp; 
			((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0)) {
		<span class="enscript-comment">/* If the underlying device supports unmap and the mount is read-write, initialize */</span>
		<span class="enscript-type">int</span> alloc_count = PAGE_SIZE / <span class="enscript-keyword">sizeof</span>(dk_extent_t);
		<span class="enscript-type">void</span> *extents = kalloc (alloc_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		<span class="enscript-keyword">if</span> (extents == NULL) {
			<span class="enscript-keyword">return</span> ENOMEM;
		}
		trimlist.extents = (dk_extent_t*)extents;
		trimlist.allocated_count = alloc_count;
		trimlist.extent_count = 0;
	}

	<span class="enscript-keyword">while</span> ((blocks_scanned &lt; hfsmp-&gt;totalBlocks) &amp;&amp; (error == 0)){

		error = hfs_alloc_scan_range (hfsmp, blocks_scanned, &amp;blocks_scanned, &amp;trimlist);

		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;HFS: bitmap scan range error: %d on vol=%s\n&quot;</span>, error, hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_UNMAP) &amp;&amp; 
			((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0)) {
		<span class="enscript-keyword">if</span> (error == 0) {
			hfs_issue_unmap(hfsmp, &amp;trimlist);
		}
		<span class="enscript-keyword">if</span> (trimlist.extents) {
			kfree (trimlist.extents, (trimlist.allocated_count * <span class="enscript-keyword">sizeof</span>(dk_extent_t)));
		}
	}

	<span class="enscript-comment">/* 
	 * This is in an #if block because hfs_validate_summary prototype and function body
	 * will only show up if ALLOC_DEBUG is on, to save wired memory ever so slightly.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ALLOC_DEBUG</span>
	sanity_check_free_ext(hfsmp, 1);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-comment">/* Validate the summary table too! */</span>
		hfs_validate_summary(hfsmp);
		printf(<span class="enscript-string">&quot;HFS: Summary validation complete on %s\n&quot;</span>, hfsmp-&gt;vcbVN);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_UNMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_UNMAP_SCAN | DBG_FUNC_END, error, hfsmp-&gt;hfs_raw_dev, 0, 0, 0);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">add_to_reserved_list</span>(hfsmount_t *hfsmp, uint32_t start, 
								 uint32_t count, <span class="enscript-type">int</span> list, 
								 <span class="enscript-type">struct</span> rl_entry **reservation)
{
	<span class="enscript-type">struct</span> rl_entry *range, *next_range;

	<span class="enscript-keyword">if</span> (list == HFS_TENTATIVE_BLOCKS) {
		<span class="enscript-type">int</span> nranges = 0;
		<span class="enscript-comment">// Don't allow more than 4 tentative reservations
</span>		TAILQ_FOREACH_SAFE(range, &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_TENTATIVE_BLOCKS],
						   rl_link, next_range) {
			<span class="enscript-keyword">if</span> (++nranges &gt; 3)
				hfs_release_reserved(hfsmp, range, HFS_TENTATIVE_BLOCKS);
		}
	}

	MALLOC(range, <span class="enscript-type">struct</span> rl_entry *, <span class="enscript-keyword">sizeof</span>(*range), M_TEMP, M_WAITOK);
	range-&gt;rl_start = start;
	range-&gt;rl_end = start + count - 1;
	TAILQ_INSERT_HEAD(&amp;hfsmp-&gt;hfs_reserved_ranges[list], range, rl_link);
	*reservation = range;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_release_reserved</span>(hfsmount_t *hfsmp,
								 <span class="enscript-type">struct</span> rl_entry *range,
								 <span class="enscript-type">int</span> list)
{
	<span class="enscript-keyword">if</span> (range-&gt;rl_start == -1)
		<span class="enscript-keyword">return</span>;

	TAILQ_REMOVE(&amp;hfsmp-&gt;hfs_reserved_ranges[list], range, rl_link);

	<span class="enscript-keyword">if</span> (rl_len(range) &gt; 0) {
		<span class="enscript-keyword">if</span> (list == HFS_TENTATIVE_BLOCKS)
			hfsmp-&gt;tentativeBlocks -= rl_len(range);
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We don't need to unmap tentative blocks because we won't have
			 * written to them, but we might have written to reserved blocks.
			 * Nothing can refer to those blocks so this doesn't have to be
			 * via the journal. If this proves to be too expensive, we could
			 * consider not sending down the unmap or we could require this
			 * to always be called within a transaction and then we can use
			 * the journal.
			 */</span>
			dk_extent_t extent = {
				.offset = (hfs_blk_to_bytes(range-&gt;rl_start, hfsmp-&gt;blockSize)
						   + hfsmp-&gt;hfsPlusIOPosOffset),
				.length = hfs_blk_to_bytes(rl_len(range), hfsmp-&gt;blockSize)
			};
			dk_unmap_t unmap = {
				.extents = &amp;extent,
				.extentsCount = 1,
			};
			VNOP_IOCTL(hfsmp-&gt;hfs_devvp, DKIOCUNMAP, (caddr_t)&amp;unmap,
					   0, vfs_context_kernel());
			assert(hfsmp-&gt;lockedBlocks &gt;= rl_len(range));
			hfsmp-&gt;lockedBlocks -= rl_len(range);
		}
		hfs_release_summary(hfsmp, range-&gt;rl_start, rl_len(range));
		add_free_extent_cache(hfsmp, range-&gt;rl_start, rl_len(range));
	}

	range-&gt;rl_start = -1;
	range-&gt;rl_end   = -2;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_free_locked_internal</span>(hfsmount_t *hfsmp,
									   <span class="enscript-type">struct</span> rl_entry **reservation,
									   <span class="enscript-type">int</span> list)
{
	<span class="enscript-keyword">if</span> (*reservation) {
		hfs_release_reserved(hfsmp, *reservation, list);
		FREE(*reservation, M_TEMP);
		*reservation = NULL;
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_free_tentative</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> rl_entry **reservation)
{
	hfs_free_locked_internal(hfsmp, reservation, HFS_TENTATIVE_BLOCKS);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_free_locked</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> rl_entry **reservation)
{
	hfs_free_locked_internal(hfsmp, reservation, HFS_LOCKED_BLOCKS);
}

OSErr <span class="enscript-function-name">BlockAllocate</span> (
		 hfsmount_t		*hfsmp,				<span class="enscript-comment">/* which volume to allocate space on */</span>
		 u_int32_t		startingBlock,		<span class="enscript-comment">/* preferred starting block, or 0 for no preference */</span>
		 u_int32_t		minBlocks,		<span class="enscript-comment">/* desired number of blocks to allocate */</span>
		 u_int32_t		maxBlocks,		<span class="enscript-comment">/* maximum number of blocks to allocate */</span>
		 hfs_block_alloc_flags_t flags,			<span class="enscript-comment">/* option flags */</span>
		 u_int32_t		*actualStartBlock,	<span class="enscript-comment">/* actual first block of allocation */</span>
		 u_int32_t		*actualNumBlocks)
{
	hfs_alloc_extra_args_t extra_args = {
		.max_blocks = maxBlocks
	};

	HFSPlusExtentDescriptor extent = { startingBlock, minBlocks };

	OSErr err = hfs_block_alloc_int(hfsmp, &amp;extent, flags, &amp;extra_args);

	*actualStartBlock = extent.startBlock;
	*actualNumBlocks  = extent.blockCount;

	<span class="enscript-keyword">return</span> err;
}

errno_t <span class="enscript-function-name">hfs_block_alloc</span>(hfsmount_t *hfsmp,
						HFSPlusExtentDescriptor *extent,
						hfs_block_alloc_flags_t flags,
						hfs_alloc_extra_args_t *ap)
{
	<span class="enscript-keyword">return</span> MacToVFSError(hfs_block_alloc_int(hfsmp, extent, flags, ap));
}

<span class="enscript-comment">/*
 ;________________________________________________________________________________
 ;
 ; Routine:	   hfs_block_alloc_int
 ;
 ; Function:   Allocate space on a volume.	If contiguous allocation is requested,
 ;			   at least the requested number of bytes will be allocated or an
 ;			   error will be returned.	If contiguous allocation is not forced,
 ;			   the space will be allocated with the first largest extent available 
 ;			   at the requested starting allocation block.  If there is not enough
 ;			   room there, a block allocation of less than the requested size will be
 ;			   allocated.
 ;
 ;			   If the requested starting block is 0 (for new file allocations),
 ;			   the volume's allocation block pointer will be used as a starting
 ;			   point.
 ;
 ; Input Arguments:
 ;   hfsmp           - Pointer to the HFS mount structure.
 ;   extent          - startBlock indicates the block to start
 ;                     searching from and blockCount is the number of
 ;                     blocks required.  Depending on the flags used,
 ;                     more or less blocks may be returned.  The
 ;                     allocated extent is returned via this
 ;                     parameter.
 ;   flags           - Flags to specify options like contiguous, use
 ;                     metadata zone, skip free block check, etc.
 ;   ap              - Additional arguments used depending on flags.
 ;                     See hfs_alloc_extra_args_t and below.
 ;
 ; Output:
 ;   (result)        - Error code, zero for successful allocation
 ;   extent          - If successful, the allocated extent.
 ;
 ; Side effects:
 ;	 The volume bitmap is read and updated; the volume bitmap cache may be changed.
 ;
 ; HFS_ALLOC_TENTATIVE
 ; Blocks will be reserved but not marked allocated.  They can be
 ; stolen if free space is limited.  Tentative blocks can be used by
 ; passing HFS_ALLOC_USE_TENTATIVE and passing in the resevation.
 ; @ap-&gt;reservation_out is used to store the reservation.
 ;
 ; HFS_ALLOC_USE_TENTATIVE
 ; Use blocks previously returned with HFS_ALLOC_TENTATIVE.
 ; @ap-&gt;reservation_in should be set to whatever @ap-&gt;reservation_out
 ; was set to when HFS_ALLOC_TENTATIVE was used.  If the tentative
 ; reservation was stolen, a normal allocation will take place.
 ;
 ; HFS_ALLOC_LOCKED
 ; Blocks will be reserved but not marked allocated.  Unlike tentative
 ; reservations they cannot be stolen.  It is safe to write to these
 ; blocks.  @ap-&gt;reservation_out is used to store the reservation.
 ;
 ; HFS_ALLOC_COMMIT
 ; This will take blocks previously returned with HFS_ALLOC_LOCKED and
 ; mark them allocated on disk.  @ap-&gt;reservation_in is used.
 ;
 ; HFS_ALLOC_ROLL_BACK
 ; Take blocks that were just recently deallocated and mark them
 ; allocated.  This is for roll back situations.  Blocks got
 ; deallocated and then something went wrong and we need to roll back
 ; by marking the blocks allocated.
 ;
 ; HFS_ALLOC_FORCECONTIG
 ; It will not return fewer than @min_blocks.
 ;
 ; HFS_ALLOC_TRY_HARD
 ; We will perform an exhaustive search to try and find @max_blocks.
 ; It will not return fewer than @min_blocks.
 ;
 ;________________________________________________________________________________
 */</span>
OSErr <span class="enscript-function-name">hfs_block_alloc_int</span>(hfsmount_t *hfsmp,
						  HFSPlusExtentDescriptor *extent,
						  hfs_block_alloc_flags_t flags,
						  hfs_alloc_extra_args_t *ap)
{
	u_int32_t  freeBlocks;
	OSErr			err = 0;
	Boolean			updateAllocPtr = false;		<span class="enscript-comment">//	true if nextAllocation needs to be updated
</span>	Boolean useMetaZone;
	Boolean forceContiguous = false;
	Boolean forceFlush;

	uint32_t startingBlock = extent-&gt;startBlock;
	uint32_t minBlocks = extent-&gt;blockCount;
	uint32_t maxBlocks = (ap &amp;&amp; ap-&gt;max_blocks) ? ap-&gt;max_blocks : minBlocks;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_ALLOCATE | DBG_FUNC_START, startingBlock, minBlocks, maxBlocks, flags, 0);

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_COMMIT)) {
		extent-&gt;startBlock = (*ap-&gt;reservation_in)-&gt;rl_start;
		extent-&gt;blockCount = rl_len(*ap-&gt;reservation_in);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">mark_allocated</span>;
	}

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_ROLL_BACK))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">mark_allocated</span>;

	freeBlocks = hfs_freeblks(hfsmp, 0);

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_USE_TENTATIVE)) {
		<span class="enscript-type">struct</span> rl_entry *range = *ap-&gt;reservation_in;

		<span class="enscript-keyword">if</span> (range &amp;&amp; range-&gt;rl_start != -1) {
			<span class="enscript-comment">/*
			 * It's possible that we have a tentative reservation
			 * but there aren't enough free blocks due to loaned blocks
			 * or insufficient space in the backing store.
			 */</span>
			uint32_t count = min(min(maxBlocks, rl_len(range)), freeBlocks);

			<span class="enscript-keyword">if</span> (count &gt;= minBlocks) {
				extent-&gt;startBlock = range-&gt;rl_start;
				extent-&gt;blockCount = count;

				<span class="enscript-comment">// Should we go straight to commit?
</span>				<span class="enscript-keyword">if</span> (!ISSET(flags, HFS_ALLOC_LOCKED))
					SET(flags, HFS_ALLOC_COMMIT);

				<span class="enscript-keyword">goto</span> <span class="enscript-reference">mark_allocated</span>;
			}
		}

		<span class="enscript-comment">/*
		 * We can't use the tentative reservation so free it and allocate
		 * normally.
		 */</span>
		hfs_free_tentative(hfsmp, ap-&gt;reservation_in);
		CLR(flags, HFS_ALLOC_USE_TENTATIVE);
	}

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_FORCECONTIG | HFS_ALLOC_TRY_HARD))
		forceContiguous = true;

	<span class="enscript-keyword">if</span> (flags &amp; HFS_ALLOC_METAZONE) {
		useMetaZone = true;
	} <span class="enscript-keyword">else</span> {
		useMetaZone = false;
	}

	<span class="enscript-keyword">if</span> (flags &amp; HFS_ALLOC_FLUSHTXN) {
		forceFlush = true;
	}
	<span class="enscript-keyword">else</span> {
		forceFlush = false;
	}

	assert(hfsmp-&gt;freeBlocks &gt;= hfsmp-&gt;tentativeBlocks);

	<span class="enscript-comment">// See if we have to steal tentative blocks
</span>	<span class="enscript-keyword">if</span> (freeBlocks &lt; hfsmp-&gt;tentativeBlocks + minBlocks)
		SET(flags, HFS_ALLOC_IGNORE_TENTATIVE);

	<span class="enscript-comment">/* Skip free block check if blocks are being allocated for relocating 
	 * data during truncating a volume.
	 * 
	 * During hfs_truncatefs(), the volume free block count is updated 
	 * before relocating data to reflect the total number of free blocks 
	 * that will exist on the volume after resize is successful.  This 
	 * means that we have reserved allocation blocks required for relocating 
	 * the data and hence there is no need to check the free blocks.
	 * It will also prevent resize failure when the number of blocks in 
	 * an extent being relocated is more than the free blocks that will 
	 * exist after the volume is resized.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; HFS_ALLOC_SKIPFREEBLKS) == 0) {
		<span class="enscript-comment">//	If the disk is already full, don't bother.
</span>		<span class="enscript-keyword">if</span> (freeBlocks == 0) {
			err = dskFulErr;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-keyword">if</span> (forceContiguous &amp;&amp; freeBlocks &lt; minBlocks) {
			err = dskFulErr;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/*
		 * Clip if necessary so we don't over-subscribe the free blocks.
		 */</span>
		<span class="enscript-keyword">if</span> (minBlocks &gt; freeBlocks) {
			minBlocks = freeBlocks;
		}
		<span class="enscript-keyword">if</span> (maxBlocks &gt; freeBlocks) {
			maxBlocks = freeBlocks;
		}
	}

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TRY_HARD)) {
		err = hfs_alloc_try_hard(hfsmp, extent, maxBlocks, flags);
		<span class="enscript-keyword">if</span> (err)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">mark_allocated</span>;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	If caller didn't specify a starting block number, then use the volume's
</span>	<span class="enscript-comment">//	next block to allocate from.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (startingBlock == 0) {
		hfs_lock_mount (hfsmp);

		<span class="enscript-comment">/* Sparse Allocation and nextAllocation are both used even if the R/B Tree is on */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
			startingBlock = hfsmp-&gt;sparseAllocation;
		} 
		<span class="enscript-keyword">else</span> {
			startingBlock = hfsmp-&gt;nextAllocation;
		}
		hfs_unlock_mount(hfsmp);
		updateAllocPtr = true;
	}


	<span class="enscript-keyword">if</span> (startingBlock &gt;= hfsmp-&gt;allocLimit) {
		startingBlock = 0; <span class="enscript-comment">/* overflow so start at beginning */</span>
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	If the request must be contiguous, then find a sequence of free blocks
</span>	<span class="enscript-comment">//	that is long enough.  Otherwise, find the first free block.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (forceContiguous) {
		err = BlockFindContig(hfsmp, startingBlock, minBlocks, maxBlocks,
				flags, &amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount);
		<span class="enscript-comment">/*
		 * If we allocated from a new position then also update the roving allocator.  
		 * This will keep the roving allocation pointer up-to-date even 
		 * if we are using the new R/B tree allocator, since
		 * it doesn't matter to us here, how the underlying allocator found 
		 * the block to vend out.
		 */</span>
		<span class="enscript-keyword">if</span> ((err == noErr) &amp;&amp;
				(extent-&gt;startBlock &gt; startingBlock) &amp;&amp;
				((extent-&gt;startBlock &lt; hfsmp-&gt;hfs_metazone_start) ||
				 (extent-&gt;startBlock &gt; hfsmp-&gt;hfs_metazone_end))) {
			updateAllocPtr = true;
		}
	} <span class="enscript-keyword">else</span> {					
		<span class="enscript-comment">/*
		 * Scan the bitmap once, gather the N largest free extents, then
		 * allocate from these largest extents.  Repeat as needed until
		 * we get all the space we needed.  We could probably build up
		 * that list when the higher level caller tried (and failed) a
		 * contiguous allocation first.
		 *
		 * Note that the free-extent cache will be cease to be updated if
		 * we are using the red-black tree for allocations.  If we jettison 
		 * the tree, then we will reset the free-extent cache and start over.
		 */</span>

		<span class="enscript-comment">/* Disable HFS_ALLOC_FLUSHTXN if needed */</span>
		<span class="enscript-keyword">if</span> (forceFlush) {
			flags &amp;= ~HFS_ALLOC_FLUSHTXN;
		}

		<span class="enscript-comment">/* 
		 * BlockFindKnown only examines the free extent cache; anything in there will
		 * have been committed to stable storage already.
		 */</span>
		err = BlockFindKnown(hfsmp, maxBlocks, &amp;extent-&gt;startBlock,
							&amp;extent-&gt;blockCount);

		<span class="enscript-comment">/* dskFulErr out of BlockFindKnown indicates an empty Free Extent Cache */</span>

		<span class="enscript-keyword">if</span> (err == dskFulErr) {
			<span class="enscript-comment">/* 
			 * Now we have to do a bigger scan.  Start at startingBlock and go up until the
			 * allocation limit.  We 'trust' the summary bitmap in this call, if it tells us
			 * that it could not find any free space.
			 */</span>
			err = BlockFindAny(hfsmp, startingBlock, hfsmp-&gt;allocLimit,
					maxBlocks, flags, true, 
					&amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount);
		}
		<span class="enscript-keyword">if</span> (err == dskFulErr) {
			<span class="enscript-comment">/*
			 * Vary the behavior here if the summary table is on or off.  
			 * If it is on, then we don't trust it it if we get into this case and
			 * basically do a full scan for maximum coverage.
			 * If it is off, then we trust the above and go up until the startingBlock.
			 */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
				err = BlockFindAny(hfsmp, 1, hfsmp-&gt;allocLimit, maxBlocks,
						flags, false, 
						&amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount);
			}
			<span class="enscript-keyword">else</span> {
				err = BlockFindAny(hfsmp, 1, startingBlock, maxBlocks,
						flags, false, 
						&amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount);
			}	

			<span class="enscript-comment">/*
		     * Last Resort: Find/use blocks that may require a journal flush.
	 		 */</span>		 
			<span class="enscript-keyword">if</span> (err == dskFulErr &amp;&amp; forceFlush) {
				flags |= HFS_ALLOC_FLUSHTXN;
				err = BlockFindAny(hfsmp, 1, hfsmp-&gt;allocLimit, maxBlocks,
						flags, false, 
						&amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount);
			}
		}
	}

	<span class="enscript-keyword">if</span> (err)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

<span class="enscript-reference">mark_allocated</span>:

	<span class="enscript-comment">// Handle alignment
</span>	<span class="enscript-keyword">if</span> (ap &amp;&amp; ap-&gt;alignment &amp;&amp; extent-&gt;blockCount &lt; ap-&gt;max_blocks) {
		<span class="enscript-comment">/*
		 * See the comment in FileMgrInternal.h for alignment
		 * semantics.
		 */</span>
		uint32_t rounding = ((extent-&gt;blockCount + ap-&gt;alignment_offset)
							 % ap-&gt;alignment);

		<span class="enscript-comment">// @minBlocks is still the minimum
</span>		<span class="enscript-keyword">if</span> (extent-&gt;blockCount &gt;= minBlocks + rounding)
			extent-&gt;blockCount -= rounding;
	}

	err = BlockMarkAllocatedInternal(hfsmp, extent-&gt;startBlock,
									 extent-&gt;blockCount, flags);

	<span class="enscript-keyword">if</span> (err)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-keyword">if</span> (ISSET(hfsmp-&gt;hfs_flags, HFS_CS) &amp;&amp; extent-&gt;blockCount != 0
		&amp;&amp; !ISSET(flags, HFS_ALLOC_TENTATIVE)) {
		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_FAST_DEV)) {
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>        <span class="enscript-comment">/* need this guard because this file is compiled outside of the kernel */</span>
			hfs_pin_block_range(hfsmp, HFS_PIN_IT,
								extent-&gt;startBlock, extent-&gt;blockCount,
								vfs_context_kernel());
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			_dk_cs_map_t cm = {
				.cm_extent = {
					(hfs_blk_to_bytes(extent-&gt;startBlock, hfsmp-&gt;blockSize)
					 + hfsmp-&gt;hfsPlusIOPosOffset),
					hfs_blk_to_bytes(extent-&gt;blockCount, hfsmp-&gt;blockSize)
				}
			};

			errno_t err2 = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, _DKIOCCSMAP,
									  (caddr_t)&amp;cm, 0, vfs_context_current());

			<span class="enscript-comment">/*
			 * Ignore errors for now; we are fully provisioned so in
			 * theory CoreStorage should be able to handle this
			 * allocation.  Should we want to change this in future, then
			 * we should think carefully how we handle errors.  Allowing
			 * CoreStorage to truncate our allocation is problematic
			 * because we might have minimum and alignment requirements
			 * and backing out changes we have already made is
			 * non-trivial.
			 */</span>

			<span class="enscript-keyword">if</span> (err2 || cm.cm_bytes_mapped &lt; cm.cm_extent.length) {
				printf(<span class="enscript-string">&quot;hfs: _DKIOCCSMAP error: %d, bytes_mapped: %llu\n&quot;</span>,
					   err2, cm.cm_bytes_mapped);
			}
		}
	}

	<span class="enscript-comment">// if we actually allocated something then go update the
</span>	<span class="enscript-comment">// various bits of state that we maintain regardless of
</span>	<span class="enscript-comment">// whether there was an error (i.e. partial allocations
</span>	<span class="enscript-comment">// still need to update things like the free block count).
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (extent-&gt;blockCount != 0) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">//	If we used the volume's roving allocation pointer, then we need to update it.
</span>		<span class="enscript-comment">//	Adding in the length of the current allocation might reduce the next allocate
</span>		<span class="enscript-comment">//	call by avoiding a re-scan of the already allocated space.  However, the clump
</span>		<span class="enscript-comment">//	just allocated can quite conceivably end up being truncated or released when
</span>		<span class="enscript-comment">//	the file is closed or its EOF changed.  Leaving the allocation pointer at the
</span>		<span class="enscript-comment">//	start of the last allocation will avoid unnecessary fragmentation in this case.
</span>		<span class="enscript-comment">//
</span>		hfs_lock_mount (hfsmp);

		<span class="enscript-keyword">if</span> (!ISSET(flags, HFS_ALLOC_USE_TENTATIVE | HFS_ALLOC_COMMIT)) {
			lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);
			<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExtCnt == 0 &amp;&amp; hfsmp-&gt;hfs_freed_block_count == 0) {
				hfsmp-&gt;sparseAllocation = extent-&gt;startBlock;
			}
			lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);
			<span class="enscript-keyword">if</span> (extent-&gt;blockCount &lt; hfsmp-&gt;hfs_freed_block_count) {
				hfsmp-&gt;hfs_freed_block_count -= extent-&gt;blockCount;
			} <span class="enscript-keyword">else</span> {
				hfsmp-&gt;hfs_freed_block_count = 0;
			}

			<span class="enscript-keyword">if</span> (updateAllocPtr &amp;&amp;
				((extent-&gt;startBlock &lt; hfsmp-&gt;hfs_metazone_start) ||
				 (extent-&gt;startBlock &gt; hfsmp-&gt;hfs_metazone_end))) {
				HFS_UPDATE_NEXT_ALLOCATION(hfsmp, extent-&gt;startBlock);
			}

			(<span class="enscript-type">void</span>) remove_free_extent_cache(hfsmp, extent-&gt;startBlock, extent-&gt;blockCount);
		}

		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_USE_TENTATIVE)) {
			(*ap-&gt;reservation_in)-&gt;rl_start += extent-&gt;blockCount;
			hfsmp-&gt;tentativeBlocks -= extent-&gt;blockCount;
			<span class="enscript-keyword">if</span> (rl_len(*ap-&gt;reservation_in) &lt;= 0)
				hfs_free_tentative(hfsmp, ap-&gt;reservation_in);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_COMMIT)) {
			<span class="enscript-comment">// Handle committing locked extents
</span>			assert(hfsmp-&gt;lockedBlocks &gt;= extent-&gt;blockCount);
			(*ap-&gt;reservation_in)-&gt;rl_start += extent-&gt;blockCount;
			hfsmp-&gt;lockedBlocks -= extent-&gt;blockCount;
			hfs_free_locked(hfsmp, ap-&gt;reservation_in);
		}

		<span class="enscript-comment">/* 
		 * Update the number of free blocks on the volume 
		 *
		 * Skip updating the free blocks count if the block are 
		 * being allocated to relocate data as part of hfs_truncatefs()
		 */</span>

		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TENTATIVE)) {
			hfsmp-&gt;tentativeBlocks += extent-&gt;blockCount;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_LOCKED)) {
			hfsmp-&gt;lockedBlocks += extent-&gt;blockCount;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flags &amp; HFS_ALLOC_SKIPFREEBLKS) == 0) {
			hfsmp-&gt;freeBlocks -= extent-&gt;blockCount;
		}
		MarkVCBDirty(hfsmp);
		hfs_unlock_mount(hfsmp);

		hfs_generate_volume_notifications(hfsmp);

		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TENTATIVE)) {
			add_to_reserved_list(hfsmp, extent-&gt;startBlock, extent-&gt;blockCount, 
								 0, ap-&gt;reservation_out);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_LOCKED)) {
			add_to_reserved_list(hfsmp, extent-&gt;startBlock, extent-&gt;blockCount, 
								 1, ap-&gt;reservation_out);
		}

		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_IGNORE_TENTATIVE)) {
			<span class="enscript-comment">/*
			 * See if we used tentative blocks.  Note that we cannot
			 * free the reservations here because we don't have access
			 * to the external pointers.  All we can do is update the
			 * reservations and they'll be cleaned up when whatever is
			 * holding the pointers calls us back.
			 *
			 * We use the rangelist code to detect overlaps and
			 * constrain the tentative block allocation.  Note that
			 * @end is inclusive so that our rangelist code will
			 * resolve the various cases for us.  As a result, we need
			 * to ensure that we account for it properly when removing
			 * the blocks from the tentative count in the mount point
			 * and re-inserting the remainder (either head or tail)
			 */</span>
			<span class="enscript-type">struct</span> rl_entry *range, *next_range;
			<span class="enscript-type">struct</span> rl_head *ranges = &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_TENTATIVE_BLOCKS];
			<span class="enscript-type">const</span> uint32_t start = extent-&gt;startBlock;
			<span class="enscript-type">const</span> uint32_t end = start + extent-&gt;blockCount - 1;
			TAILQ_FOREACH_SAFE(range, ranges, rl_link, next_range) {
				<span class="enscript-keyword">switch</span> (rl_overlap(range, start, end)) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>:
						<span class="enscript-comment">// Keep the bigger part
</span>						<span class="enscript-keyword">if</span> (start - range-&gt;rl_start &gt; range-&gt;rl_end - end) {
							<span class="enscript-comment">// Discard the tail
</span>							hfsmp-&gt;tentativeBlocks -= range-&gt;rl_end + 1 - start;
							hfs_release_summary(hfsmp, end + 1, range-&gt;rl_end - end);
							<span class="enscript-type">const</span> uint32_t old_end = range-&gt;rl_end;
							range-&gt;rl_end = start - 1;
							add_free_extent_cache(hfsmp, end + 1, old_end - end);
						} <span class="enscript-keyword">else</span> {
							<span class="enscript-comment">// Discard the head
</span>							hfsmp-&gt;tentativeBlocks -= end + 1 - range-&gt;rl_start;
							hfs_release_summary(hfsmp, range-&gt;rl_start,
												start - range-&gt;rl_start);
							<span class="enscript-type">const</span> uint32_t old_start = range-&gt;rl_start;
							range-&gt;rl_start = end + 1;
							add_free_extent_cache(hfsmp, old_start,
												  start - old_start);
						}
						assert(range-&gt;rl_end &gt;= range-&gt;rl_start);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>:
						hfsmp-&gt;tentativeBlocks -= rl_len(range);
						range-&gt;rl_end = range-&gt;rl_start - 1;
						hfs_release_reserved(hfsmp, range, HFS_TENTATIVE_BLOCKS);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>:
						hfsmp-&gt;tentativeBlocks -= range-&gt;rl_end + 1 - start;
						range-&gt;rl_end = start - 1;
						assert(range-&gt;rl_end &gt;= range-&gt;rl_start);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>:
						hfsmp-&gt;tentativeBlocks -= end + 1 - range-&gt;rl_start;
						range-&gt;rl_start = end + 1;
						assert(range-&gt;rl_end &gt;= range-&gt;rl_start);
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_NOOVERLAP</span>:
						<span class="enscript-keyword">break</span>;
				}
			}
		}
	}

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		<span class="enscript-keyword">if</span> (err == noErr) {
			<span class="enscript-keyword">if</span> (extent-&gt;startBlock &gt;= hfsmp-&gt;totalBlocks) {
				panic (<span class="enscript-string">&quot;BlockAllocate: vending invalid blocks!&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (extent-&gt;startBlock &gt;= hfsmp-&gt;allocLimit) {
				panic (<span class="enscript-string">&quot;BlockAllocate: vending block past allocLimit!&quot;</span>);
			}

			<span class="enscript-keyword">if</span> ((extent-&gt;startBlock + extent-&gt;blockCount) &gt;= hfsmp-&gt;totalBlocks) {	
				panic (<span class="enscript-string">&quot;BlockAllocate: vending too many invalid blocks!&quot;</span>);
			}

			<span class="enscript-keyword">if</span> ((extent-&gt;startBlock + extent-&gt;blockCount) &gt;= hfsmp-&gt;allocLimit) {	
				panic (<span class="enscript-string">&quot;BlockAllocate: vending too many invalid blocks past allocLimit!&quot;</span>);
			}
		}
	}

	<span class="enscript-keyword">if</span> (err) {
		<span class="enscript-comment">// Just to be safe...
</span>		extent-&gt;startBlock = 0;
		extent-&gt;blockCount = 0;
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_ALLOCATE | DBG_FUNC_END, err, extent-&gt;startBlock, extent-&gt;blockCount, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
;________________________________________________________________________________
;
; Routine:	   BlockDeallocate
;
; Function:    Update the bitmap to deallocate a run of disk allocation blocks
;
; Input Arguments:
;	 vcb		- Pointer to ExtendedVCB for the volume to free space on
;	 firstBlock	- First allocation block to be freed
;	 numBlocks	- Number of allocation blocks to free up (must be &gt; 0!)
;
; Output:
;	 (result)	- Result code
;
; Side effects:
;	 The volume bitmap is read and updated; the volume bitmap cache may be changed.
;	 The Allocator's red-black trees may also be modified as a result.
;
;________________________________________________________________________________
*/</span>

OSErr <span class="enscript-function-name">BlockDeallocate</span> (
		ExtendedVCB		*vcb,			<span class="enscript-comment">//	Which volume to deallocate space on
</span>		u_int32_t		firstBlock,		<span class="enscript-comment">//	First block in range to deallocate
</span>		u_int32_t		numBlocks, 		<span class="enscript-comment">//	Number of contiguous blocks to deallocate
</span>		hfs_block_alloc_flags_t flags)
{
	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TENTATIVE | HFS_ALLOC_LOCKED))
		<span class="enscript-keyword">return</span> 0;

	OSErr			err;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_DEALLOCATE | DBG_FUNC_START, firstBlock, numBlocks, flags, 0, 0);

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	If no blocks to deallocate, then exit early
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (numBlocks == 0) {
		err = noErr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	}


	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		<span class="enscript-keyword">if</span> (firstBlock &gt;= hfsmp-&gt;totalBlocks) {
			panic (<span class="enscript-string">&quot;BlockDeallocate: freeing invalid blocks!&quot;</span>);
		}

		<span class="enscript-keyword">if</span> ((firstBlock + numBlocks) &gt;= hfsmp-&gt;totalBlocks) {	
			panic (<span class="enscript-string">&quot;BlockDeallocate: freeing too many invalid blocks!&quot;</span>);
		}			
	}

	<span class="enscript-comment">/*
	 * If we're using the summary bitmap, then try to mark the bits
	 * as potentially usable/free before actually deallocating them.
	 * It is better to be slightly speculative here for correctness.
	 */</span>

	(<span class="enscript-type">void</span>) hfs_release_summary (hfsmp, firstBlock, numBlocks);

	err = BlockMarkFreeInternal(vcb, firstBlock, numBlocks, true);

	<span class="enscript-keyword">if</span> (err) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Update the volume's free block count, and mark the VCB as dirty.
</span>	<span class="enscript-comment">//
</span>	hfs_lock_mount(hfsmp);
	<span class="enscript-comment">/* 
	 * Do not update the free block count.  This flags is specified 
	 * when a volume is being truncated.  
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; HFS_ALLOC_SKIPFREEBLKS) == 0) {
		vcb-&gt;freeBlocks += numBlocks;
	}

	vcb-&gt;hfs_freed_block_count += numBlocks;

	<span class="enscript-keyword">if</span> (vcb-&gt;nextAllocation == (firstBlock + numBlocks)) {
		HFS_UPDATE_NEXT_ALLOCATION(vcb, (vcb-&gt;nextAllocation - numBlocks));
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		<span class="enscript-comment">/*
		 * In the journal case, we'll add the free extent once the journal
		 * calls us back to tell us it wrote the transaction to disk.
		 */</span>
		(<span class="enscript-type">void</span>) add_free_extent_cache(vcb, firstBlock, numBlocks);

		<span class="enscript-comment">/*
		 * If the journal case, we'll only update sparseAllocation once the
		 * free extent cache becomes empty (when we remove the last entry
		 * from the cache).  Skipping it here means we're less likely to
		 * find a recently freed extent via the bitmap before it gets added
		 * to the free extent cache.
		 */</span>
		<span class="enscript-keyword">if</span> (firstBlock &lt; vcb-&gt;sparseAllocation) {
			vcb-&gt;sparseAllocation = firstBlock;
		}
	}

	MarkVCBDirty(vcb);
	hfs_unlock_mount(hfsmp);

	hfs_generate_volume_notifications(VCBTOHFS(vcb));
<span class="enscript-reference">Exit</span>:

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_DEALLOCATE | DBG_FUNC_END, err, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


u_int8_t freebitcount[16] = {
	4, 3, 3, 2, 3, 2, 2, 1,  <span class="enscript-comment">/* 0 1 2 3 4 5 6 7 */</span>
	3, 2, 2, 1, 2, 1, 1, 0,  <span class="enscript-comment">/* 8 9 A B C D E F */</span>
};

u_int32_t
<span class="enscript-function-name">MetaZoneFreeBlocks</span>(ExtendedVCB *vcb)
{
	u_int32_t freeblocks;
	u_int32_t *currCache;
	uintptr_t blockRef;
	u_int32_t bit;
	u_int32_t lastbit;
	<span class="enscript-type">int</span> bytesleft;
	<span class="enscript-type">int</span> bytesperblock;
	u_int8_t byte;
	u_int8_t *buffer;

	blockRef = 0;
	bytesleft = freeblocks = 0;
	buffer = NULL;
	bit = VCBTOHFS(vcb)-&gt;hfs_metazone_start;
	<span class="enscript-keyword">if</span> (bit == 1)
		bit = 0;

	lastbit = VCBTOHFS(vcb)-&gt;hfs_metazone_end;
	bytesperblock = vcb-&gt;vcbVBMIOSize;

	<span class="enscript-comment">/*
	 *  Count all the bits from bit to lastbit.
	 */</span>
	<span class="enscript-keyword">while</span> (bit &lt; lastbit) {
		<span class="enscript-comment">/*
		 *  Get next bitmap block.
		 */</span>
		<span class="enscript-keyword">if</span> (bytesleft == 0) {
			<span class="enscript-keyword">if</span> (blockRef) {
				(<span class="enscript-type">void</span>) ReleaseBitmapBlock(vcb, blockRef, false);
				blockRef = 0;
			}
			<span class="enscript-keyword">if</span> (ReadBitmapBlock(vcb, bit, &amp;currCache, &amp;blockRef, 
								HFS_ALLOC_IGNORE_TENTATIVE) != 0) {
				<span class="enscript-keyword">return</span> (0);
			}
			buffer = (u_int8_t *)currCache;
			bytesleft = bytesperblock;
		}
		byte = *buffer++;
		freeblocks += freebitcount[byte &amp; 0x0F];
		freeblocks += freebitcount[(byte &gt;&gt; 4) &amp; 0x0F];
		bit += kBitsPerByte;
		--bytesleft;
	}
	<span class="enscript-keyword">if</span> (blockRef)
		(<span class="enscript-type">void</span>) ReleaseBitmapBlock(vcb, blockRef, false);

	<span class="enscript-keyword">return</span> (freeblocks);
}


<span class="enscript-comment">/*
 * Obtain the next allocation block (bit) that's
 * outside the metadata allocation zone.
 */</span>
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">NextBitmapBlock</span>(
		ExtendedVCB		*vcb,
		u_int32_t		bit)
{
	<span class="enscript-type">struct</span>  hfsmount *hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) == 0)
		<span class="enscript-keyword">return</span> (bit);
	<span class="enscript-comment">/*
	 * Skip over metadata allocation zone.
	 */</span>
	<span class="enscript-keyword">if</span> ((bit &gt;= hfsmp-&gt;hfs_metazone_start) &amp;&amp;
			(bit &lt;= hfsmp-&gt;hfs_metazone_end)) {
		bit = hfsmp-&gt;hfs_metazone_end + 1;
	}
	<span class="enscript-keyword">return</span> (bit);
}


<span class="enscript-comment">// Assumes @bitmap is aligned to 8 bytes and multiple of 8 bytes.
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bits_set</span>(<span class="enscript-type">void</span> *bitmap, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end)
{
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> start_bit = start &amp; 63;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> end_bit   = end   &amp; 63;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">LEFT_MASK</span>(bit)	OSSwapHostToBigInt64(0xffffffffffffffffull &lt;&lt; (64 - bit))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RIGHT_MASK</span>(bit)	OSSwapHostToBigInt64(0xffffffffffffffffull &gt;&gt; bit)

	uint64_t *p = (uint64_t *)bitmap + start / 64;

	<span class="enscript-keyword">if</span> ((start &amp; ~63) == (end &amp; ~63)) {
		<span class="enscript-comment">// Start and end in same 64 bits
</span>		*p |= RIGHT_MASK(start_bit) &amp; LEFT_MASK(end_bit);
	} <span class="enscript-keyword">else</span> {
		*p++ |= RIGHT_MASK(start_bit);

		<span class="enscript-type">int</span> nquads = (end - end_bit - start - 1) / 64;

		<span class="enscript-keyword">while</span> (nquads--)
			*p++ = 0xffffffffffffffffull;

		<span class="enscript-keyword">if</span> (end_bit)
			*p |= LEFT_MASK(end_bit);
	}
}

<span class="enscript-comment">// Modifies the buffer and applies any reservations that we might have
</span><span class="enscript-type">static</span> buf_t <span class="enscript-function-name">process_reservations</span>(hfsmount_t *hfsmp, buf_t bp, off_t offset,
								  hfs_block_alloc_flags_t flags,
								  bool always_copy)
{
	bool taken_copy = false;
	<span class="enscript-type">void</span> *buffer = (<span class="enscript-type">void</span> *)buf_dataptr(bp);
	<span class="enscript-type">const</span> uint32_t nbytes = buf_count(bp);
	<span class="enscript-type">const</span> off_t end = offset + nbytes * 8 - 1;

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = (ISSET(flags, HFS_ALLOC_IGNORE_TENTATIVE)
				  ? HFS_LOCKED_BLOCKS : HFS_TENTATIVE_BLOCKS); i &lt; 2; ++i) {
		<span class="enscript-type">struct</span> rl_entry *entry;
		TAILQ_FOREACH(entry, &amp;hfsmp-&gt;hfs_reserved_ranges[i], rl_link) {
			uint32_t a, b;

			<span class="enscript-type">enum</span> rl_overlaptype overlap_type = rl_overlap(entry, offset, end);

			<span class="enscript-keyword">if</span> (overlap_type == RL_NOOVERLAP)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * If always_copy is false, we only take a copy if B_LOCKED is
			 * set because ReleaseScanBitmapRange doesn't invalidate the
			 * buffer in that case.
			 */</span>
			<span class="enscript-keyword">if</span> (!taken_copy &amp;&amp; (always_copy || ISSET(buf_flags(bp), B_LOCKED))) {
				buf_t new_bp = buf_create_shadow(bp, true, 0, NULL, NULL);
				buf_brelse(bp);
				bp = new_bp;
				buf_setflags(bp, B_NOCACHE);
				buffer = (<span class="enscript-type">void</span> *)buf_dataptr(bp);
				taken_copy = true;
			}

			<span class="enscript-keyword">switch</span> (overlap_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>:
				memset(buffer, 0xff, nbytes);
				<span class="enscript-keyword">return</span> bp;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>:
				a = entry-&gt;rl_start;
				b = entry-&gt;rl_end;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>:
				a = offset;
				b = entry-&gt;rl_end;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>:
				a = entry-&gt;rl_start;
				b = end;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_NOOVERLAP</span>:
				__builtin_unreachable();
			}

			a -= offset;
			b -= offset;

			assert(a &lt; buf_count(bp) * 8);
			assert(b &lt; buf_count(bp) * 8);
			assert(b &gt;= a);

			<span class="enscript-comment">// b is inclusive
</span>			bits_set(buffer, a, b + 1);
		}
	} <span class="enscript-comment">// for (;;)
</span>
	<span class="enscript-keyword">return</span> bp;
}

<span class="enscript-comment">/*
;_______________________________________________________________________
;
; Routine:	ReadBitmapBlock
;
; Function:	Read in a bitmap block corresponding to a given allocation
;			block (bit).  Return a pointer to the bitmap block.
;
; Inputs:
;	vcb			--	Pointer to ExtendedVCB
;	bit			--	Allocation block whose bitmap block is desired
;
; Outputs:
;	buffer		--	Pointer to bitmap block corresonding to &quot;block&quot;
;	blockRef
;_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReadBitmapBlock</span>(ExtendedVCB		*vcb,
							 u_int32_t		bit,
							 u_int32_t		**buffer,
							 uintptr_t		*blockRef,
							 hfs_block_alloc_flags_t flags)
{
	OSErr			err;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	<span class="enscript-type">struct</span> vnode *vp = NULL;
	daddr64_t block;
	u_int32_t blockSize;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_READ_BITMAP_BLOCK | DBG_FUNC_START, bit, 0, 0, 0, 0);

	<span class="enscript-comment">/*
	 * volume bitmap blocks are protected by the allocation file lock
	 */</span>
	REQUIRE_FILE_LOCK(vcb-&gt;hfs_allocation_vp, false);	

	blockSize = (u_int32_t)vcb-&gt;vcbVBMIOSize;
	block = (daddr64_t)(bit / (blockSize * kBitsPerByte));

	<span class="enscript-comment">/* HFS+ / HFSX */</span>
	<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord != kHFSSigWord) {
		vp = vcb-&gt;hfs_allocation_vp;	<span class="enscript-comment">/* use allocation file vnode */</span>
	} 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* HFS Standard */</span>	
		vp = VCBTOHFS(vcb)-&gt;hfs_devvp;	<span class="enscript-comment">/* use device I/O vnode */</span>
		block += vcb-&gt;vcbVBMSt;			<span class="enscript-comment">/* map to physical block */</span>
	}
#<span class="enscript-reference">endif</span>

	err = (<span class="enscript-type">int</span>)buf_meta_bread(vp, block, blockSize, NOCRED, &amp;bp);

	<span class="enscript-keyword">if</span> (bp) {
		<span class="enscript-keyword">if</span> (err) {
			buf_brelse(bp);
			*blockRef = 0;
			*buffer = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (!ISSET(flags, HFS_ALLOC_IGNORE_RESERVED)) {
				bp = process_reservations(vcb, bp, block * blockSize * 8,
										  flags, <span class="enscript-comment">/* always_copy: */</span> true);
			}

			buf_setfsprivate(bp, (<span class="enscript-type">void</span> *)(uintptr_t)flags);

			*blockRef = (uintptr_t)bp;
			*buffer = (u_int32_t *)buf_dataptr(bp);
		}
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_READ_BITMAP_BLOCK | DBG_FUNC_END, err, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
;_______________________________________________________________________
;
; Routine:	ReadBitmapRange
;
; Function:	Read in a range of the bitmap starting at the given offset. 
;			Use the supplied size to determine the amount of I/O to generate
;			against the bitmap file. Return a pointer to the bitmap block.
;
; Inputs:
;	hfsmp		--	Pointer to hfs mount
;	offset		--	byte offset into the bitmap file 
;	size		--  How much I/O to generate against the bitmap file.
;
; Outputs:
;	buffer		--	Pointer to bitmap block data corresonding to &quot;block&quot;
;	blockRef	--  struct 'buf' pointer which MUST be released in a subsequent call.
;_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReadBitmapRange</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t offset,
		uint32_t iosize, uint32_t **buffer, <span class="enscript-type">struct</span> buf **blockRef)
{

	OSErr			err;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	<span class="enscript-type">struct</span> vnode *vp = NULL;
	daddr64_t block;

	<span class="enscript-comment">/* This function isn't supported for HFS standard */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbSigWord != kHFSPlusSigWord) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_READ_BITMAP_RANGE | DBG_FUNC_START, offset, iosize, 0, 0, 0);
	}

	<span class="enscript-comment">/*
	 * volume bitmap blocks are protected by the allocation file lock
	 */</span>
	REQUIRE_FILE_LOCK(vcb-&gt;hfs_allocation_vp, false);	

	vp = hfsmp-&gt;hfs_allocation_vp;	<span class="enscript-comment">/* use allocation file vnode */</span>

	<span class="enscript-comment">/*
	 * The byte offset argument must be converted into bitmap-relative logical 
	 * block numbers before using it in buf_meta_bread.
	 * 
	 * buf_meta_bread (and the things it calls) will eventually try to
	 * reconstruct the byte offset into the file by multiplying the logical 
	 * block number passed in below by the vcbVBMIOSize field in the mount
	 * point.  So we prepare for that by converting the byte offset back into
	 * logical blocks in terms of VBMIOSize units.
	 * 
	 * The amount of I/O requested and the byte offset should be computed 
	 * based on the helper function in the frame that called us, so we can
	 * get away with just doing a simple divide here.
	 */</span>
	block = (daddr64_t)(offset / hfsmp-&gt;vcbVBMIOSize);

	err = (<span class="enscript-type">int</span>) buf_meta_bread(vp, block, iosize, NOCRED, &amp;bp);

	<span class="enscript-keyword">if</span> (bp) {
		<span class="enscript-keyword">if</span> (err) {
			buf_brelse(bp);
			*blockRef = 0;
			*buffer = NULL;
		} <span class="enscript-keyword">else</span> {
			bp = process_reservations(hfsmp, bp, (offset * 8), 0,
									  <span class="enscript-comment">/* always_copy: */</span> false);

			*blockRef = bp;
			*buffer = (u_int32_t *)buf_dataptr(bp);
		}
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_READ_BITMAP_RANGE | DBG_FUNC_END, err, 0, 0, 0, 0);
	}

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
;_______________________________________________________________________
;
; Routine:	ReleaseBitmapBlock
;
; Function:	Relase a bitmap block. 
;
; Inputs:
;	vcb
;	blockRef
;	dirty
;_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReleaseBitmapBlock</span>(
		ExtendedVCB		*vcb,
		uintptr_t		blockRef,
		Boolean			dirty)
{
	<span class="enscript-type">struct</span> buf *bp = (<span class="enscript-type">struct</span> buf *)blockRef;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_RELEASE_BITMAP_BLOCK | DBG_FUNC_START, dirty, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> (blockRef == 0) {
		<span class="enscript-keyword">if</span> (dirty)
			panic(<span class="enscript-string">&quot;hfs: ReleaseBitmapBlock: missing bp&quot;</span>);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (bp) {
		<span class="enscript-keyword">if</span> (dirty) {
			hfs_block_alloc_flags_t flags = (uintptr_t)buf_fsprivate(bp);

			<span class="enscript-keyword">if</span> (!ISSET(flags, HFS_ALLOC_IGNORE_RESERVED))
				panic(<span class="enscript-string">&quot;Modified read-only bitmap buffer!&quot;</span>);

			<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				journal_modify_block_end(hfsmp-&gt;jnl, bp, NULL, NULL);
			} <span class="enscript-keyword">else</span> {
				buf_bdwrite(bp);
			}
		} <span class="enscript-keyword">else</span> {
			buf_brelse(bp);
		}
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_RELEASE_BITMAP_BLOCK | DBG_FUNC_END, 0, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * ReleaseScanBitmapRange
 *
 * This is used to release struct bufs that were created for use by 
 * bitmap scanning code.  Because they may be of sizes different than the
 * typical runtime manipulation code, we want to force them to be purged out 
 * of the buffer cache ASAP, so we'll release them differently than in the 
 * ReleaseBitmapBlock case.  
 *
 * Additionally, because we know that we're only reading the blocks and that they
 * should have been clean prior to reading them, we will never 
 * issue a write to them (thus dirtying them).
 */</span>

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">ReleaseScanBitmapRange</span>(<span class="enscript-type">struct</span> buf *bp ) {

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_RELEASE_BITMAP_BLOCK | DBG_FUNC_START, 0, 0, 0, 0, 0);
	}

	<span class="enscript-keyword">if</span> (bp) {
		<span class="enscript-comment">/* Mark the buffer invalid if it isn't locked, then release it */</span>
		<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; B_LOCKED) == 0) {
			buf_markinvalid(bp);
		}
		buf_brelse(bp);
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED) {
		KERNEL_DEBUG_CONSTANT(HFSDBG_RELEASE_SCAN_BITMAP | DBG_FUNC_END, 0, 0, 0, 0, 0);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* 
 * @extent.startBlock, on input, contains a preferred block for the
 * allocation.  @extent.blockCount, on input, contains the minimum
 * number of blocks acceptable.  Upon success, the result is conveyed
 * in @extent.
 */</span>
<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">hfs_alloc_try_hard</span>(hfsmount_t *hfsmp,
								HFSPlusExtentDescriptor *extent,
								uint32_t max_blocks,
								hfs_block_alloc_flags_t flags)
{
	OSErr err = dskFulErr;

	<span class="enscript-type">const</span> uint32_t min_blocks = extent-&gt;blockCount;

	<span class="enscript-comment">// It's &gt; rather than &gt;= because the last block is always reserved
</span>	<span class="enscript-keyword">if</span> (extent-&gt;startBlock &gt; 0 &amp;&amp; extent-&gt;startBlock &lt; hfsmp-&gt;allocLimit
		&amp;&amp; hfsmp-&gt;allocLimit - extent-&gt;startBlock &gt; max_blocks) {
		<span class="enscript-comment">/*
		 * This is just checking to see if there's an extent starting
		 * at extent-&gt;startBlock that will suit.  We only check for
		 * @max_blocks here; @min_blocks is ignored.
		 */</span>

		err = BlockFindContiguous(hfsmp, extent-&gt;startBlock, extent-&gt;startBlock + max_blocks,
								  max_blocks, max_blocks, true, true,
								  &amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount, flags);

		<span class="enscript-keyword">if</span> (err != dskFulErr)
			<span class="enscript-keyword">return</span> err;
	}

	err = BlockFindKnown(hfsmp, max_blocks, &amp;extent-&gt;startBlock,
						&amp;extent-&gt;blockCount);

	<span class="enscript-keyword">if</span> (!err) {
		<span class="enscript-keyword">if</span> (extent-&gt;blockCount &gt;= max_blocks)
			<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err != dskFulErr)
		<span class="enscript-keyword">return</span> err;

	<span class="enscript-comment">// Try a more exhaustive search
</span>	<span class="enscript-keyword">return</span> BlockFindContiguous(hfsmp, 1, hfsmp-&gt;allocLimit,
							   min_blocks, max_blocks,
							   <span class="enscript-comment">/* useMetaZone: */</span> true,
							   <span class="enscript-comment">/* trustSummary: */</span> true,
							   &amp;extent-&gt;startBlock, &amp;extent-&gt;blockCount, flags);
}

<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockFindContig

Function:   Find a contiguous group of allocation blocks.  If the
			minimum cannot be satisfied, nothing is returned.  The
			caller guarantees that there are enough free blocks
			(though they may not be contiguous, in which case this
			call will fail).

Inputs:
	vcb				Pointer to volume where space is to be allocated
	startingBlock	Preferred first block for allocation
	minBlocks		Minimum number of contiguous blocks to allocate
	maxBlocks		Maximum number of contiguous blocks to allocate
	flags

Outputs:
	actualStartBlock	First block of range allocated, or 0 if error
	actualNumBlocks		Number of blocks allocated, or 0 if error
_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindContig</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		minBlocks,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks)
{
	OSErr retval = noErr;
	uint32_t currentStart = startingBlock;

	uint32_t foundStart = 0; <span class="enscript-comment">// values to emit to caller
</span>	uint32_t foundCount = 0;

	uint32_t collision_start = 0;  <span class="enscript-comment">// if we have to re-allocate a recently deleted extent, use this
</span>	uint32_t collision_count = 0;

	<span class="enscript-type">int</span> err;
	<span class="enscript-type">int</span> allowReuse = (flags &amp; HFS_ALLOC_FLUSHTXN);
	Boolean useMetaZone = (flags &amp; HFS_ALLOC_METAZONE);

	<span class="enscript-type">int</span> recently_deleted = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_FIND_CONTIG_BITMAP | DBG_FUNC_START, startingBlock, minBlocks, maxBlocks, useMetaZone, 0);

	<span class="enscript-keyword">while</span> ((retval == noErr) &amp;&amp; (foundStart == 0) &amp;&amp; (foundCount == 0)) {

		<span class="enscript-comment">/* Try and find something that works. */</span>

		<span class="enscript-comment">/*
		 * NOTE: If the only contiguous free extent of at least minBlocks
		 * crosses startingBlock (i.e. starts before, ends after), then we
		 * won't find it. Earlier versions *did* find this case by letting
		 * the second search look past startingBlock by minBlocks.  But
		 * with the free extent cache, this can lead to duplicate entries
		 * in the cache, causing the same blocks to be allocated twice.
		 */</span>
		retval = BlockFindContiguous(vcb, currentStart, vcb-&gt;allocLimit, minBlocks, 
				maxBlocks, useMetaZone, true, &amp;foundStart, &amp;foundCount, flags);

		<span class="enscript-keyword">if</span> (retval == dskFulErr &amp;&amp; currentStart != 0) {
			<span class="enscript-comment">/*
			 * We constrain the endingBlock so we don't bother looking for ranges
			 * that would overlap those found in the previous call, if the summary bitmap
			 * is not on for this volume.  If it is, then we assume that it was not trust
			 * -worthy and do a full scan.
			 */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
				retval = BlockFindContiguous(vcb, 1, vcb-&gt;allocLimit, minBlocks, 
						maxBlocks, useMetaZone, false, &amp;foundStart, &amp;foundCount, flags);
			}
			<span class="enscript-keyword">else</span> {
				retval = BlockFindContiguous(vcb, 1, currentStart, minBlocks,
						maxBlocks, useMetaZone, false, &amp;foundStart, &amp;foundCount, flags);
			}
		}

		<span class="enscript-keyword">if</span> (retval != noErr) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bailout</span>;
		}

		<span class="enscript-comment">/* Do we overlap with the recently found collision extent? */</span>
		<span class="enscript-keyword">if</span> (collision_start) {
			<span class="enscript-keyword">if</span> (extents_overlap (foundStart, foundCount, collision_start, collision_count)) {
				<span class="enscript-comment">/* 
				 * We've looped around, and the only thing we could use was the collision extent.
				 * Since we are allowed to use it, go ahead and do so now.
				 */</span>
				<span class="enscript-keyword">if</span>(allowReuse) {
					<span class="enscript-comment">/* 
					 * then we couldn't find anything except values which might have been 
					 * recently deallocated. just return our cached value if we are allowed to.
					 */</span>
					foundStart = collision_start;
					foundCount = collision_count;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bailout</span>;
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* Otherwise, we looped around and couldn't find anything that wouldn't require a journal flush. */</span>
					retval = dskFulErr;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bailout</span>;
				}	
			}
		}

		<span class="enscript-comment">/* OK, we know we must not have collided . See if this one is recently deleted */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			recently_deleted = 0;
			uint32_t nextStart;
			err = CheckUnmappedBytes (hfsmp, (uint64_t)foundStart,
					(uint64_t) foundCount, &amp;recently_deleted, &amp;nextStart);
			<span class="enscript-keyword">if</span> (err == 0) {
				<span class="enscript-keyword">if</span>(recently_deleted != 0) {
					<span class="enscript-comment">/* 
					 * these blocks were recently deleted/deallocated.  Cache the extent, but
					 * but keep searching to see if we can find one that won't collide here. 
					 */</span>
					<span class="enscript-keyword">if</span> (collision_start == 0) {
						collision_start = foundStart;
						collision_count = foundCount;
					}
					recently_deleted = 0;

					<span class="enscript-comment">/* 
					 * advance currentStart to the point just past the overlap we just found. Note that 
					 * we will automatically loop around to start of the bitmap as needed.
					 */</span>
					currentStart = nextStart;
					<span class="enscript-comment">/* Unset foundStart/Count to allow it to loop around again. */</span>
					foundStart = 0;
					foundCount = 0;
				}
			}
		} <span class="enscript-comment">// end jnl/deleted case
</span>
		<span class="enscript-comment">/* 
		 * If we found something good, we'd break out of the loop at the top; foundCount
		 * and foundStart should be set.
		 */</span>

	} <span class="enscript-comment">// end while loop. 
</span>
<span class="enscript-reference">bailout</span>:

	<span class="enscript-keyword">if</span> (retval == noErr) {
		*actualStartBlock = foundStart;
		*actualNumBlocks = foundCount;
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_FIND_CONTIG_BITMAP | DBG_FUNC_END, foundStart, foundCount, retval, 0, 0);

	<span class="enscript-keyword">return</span> retval;

}


<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockFindAny

Function: Find one or more allocation blocks and may return fewer than
          requested.  The caller guarantees that there is at least one
          free block.

Inputs:
	vcb				Pointer to volume where space is to be allocated
	startingBlock	Preferred first block for allocation
	endingBlock		Last block to check + 1
	maxBlocks		Maximum number of contiguous blocks to allocate
	useMetaZone

Outputs:
	actualStartBlock	First block of range allocated, or 0 if error
	actualNumBlocks		Number of blocks allocated, or 0 if error
_______________________________________________________________________
*/</span>

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindAny</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		<span class="enscript-type">register</span> u_int32_t	endingBlock,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		Boolean			trustSummary,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks)
{

	<span class="enscript-comment">/*
	 * If it is enabled, scan through the summary table to find the first free block.
	 *
	 * If it reports that there are not any free blocks, we could have a false
	 * positive, so in that case, use the input arguments as a pass through.
	 */</span>
	uint32_t start_blk  = startingBlock;
	uint32_t end_blk = endingBlock;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	OSErr err;

	hfsmp = (<span class="enscript-type">struct</span> hfsmount*)vcb;
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		uint32_t suggested_start;

		<span class="enscript-comment">/* 
		 * If the summary table is enabled, scan through it to find the first free 
		 * block.  If there was an error, or we couldn't find anything free in the
		 * summary table, then just leave the start_blk fields unmodified. We wouldn't
		 * have gotten to this point if the mount point made it look like there was possibly
		 * free space in the FS. 
		 */</span>
		err = hfs_find_summary_free (hfsmp, startingBlock, &amp;suggested_start);
		<span class="enscript-keyword">if</span> (err == 0) {
			start_blk = suggested_start;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Differentiate between ENOSPC and a more esoteric error in the above call. */</span>
			<span class="enscript-keyword">if</span> ((err == ENOSPC) &amp;&amp; (trustSummary)) {
				<span class="enscript-comment">/* 
				 * The 'trustSummary' argument is for doing a full scan if we really
				 * really, need the space and we think it's somewhere but can't find it in the
				 * summary table. If it's true, then we trust the summary table and return 
				 * dskFulErr if we couldn't find it above.
				 */</span>
				<span class="enscript-keyword">return</span> dskFulErr;
			}
			<span class="enscript-comment">/* 
			 * If either trustSummary was false or we got a different errno, then we
			 * want to fall through to the real bitmap single i/o code...
			 */</span> 
		}
	}

	err =  BlockFindAnyBitmap(vcb, start_blk, end_blk, maxBlocks,
			flags, actualStartBlock, actualNumBlocks);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * BlockFindAnyBitmap finds free ranges by scanning the bitmap to
 * figure out where the free allocation blocks are.  Inputs and
 * outputs are the same as for BlockFindAny.
 */</span>

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindAnyBitmap</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		<span class="enscript-type">register</span> u_int32_t	endingBlock,
		u_int32_t		maxBlocks,
		hfs_block_alloc_flags_t flags,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks)
{
	OSErr			err;
	<span class="enscript-type">register</span> u_int32_t	block = 0;		<span class="enscript-comment">//	current block number
</span>	<span class="enscript-type">register</span> u_int32_t	currentWord;	<span class="enscript-comment">//	Pointer to current word within bitmap block
</span>	<span class="enscript-type">register</span> u_int32_t	bitMask;		<span class="enscript-comment">//	Word with given bits already set (ready to OR in)
</span>	<span class="enscript-type">register</span> u_int32_t	wordsLeft;		<span class="enscript-comment">//	Number of words left in this bitmap block
</span>	u_int32_t  *buffer = NULL;
	u_int32_t  *currCache = NULL;
	uintptr_t  blockRef = 0;
	u_int32_t  bitsPerBlock;
	u_int32_t  wordsPerBlock;
	Boolean dirty = false;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);
	Boolean useMetaZone = (flags &amp; HFS_ALLOC_METAZONE);
	Boolean forceFlush = (flags &amp; HFS_ALLOC_FLUSHTXN);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ALLOC_ANY_BITMAP | DBG_FUNC_START, startingBlock, endingBlock, maxBlocks, useMetaZone, 0);

<span class="enscript-reference">restartSearchAny</span>:

	<span class="enscript-comment">/*
	 * When we're skipping the metadata zone and the start/end
	 * range overlaps with the metadata zone then adjust the 
	 * start to be outside of the metadata zone.  If the range
	 * is entirely inside the metadata zone then we can deny the
	 * request (dskFulErr).
	 */</span>
	<span class="enscript-keyword">if</span> (!useMetaZone &amp;&amp; (vcb-&gt;hfs_flags &amp; HFS_METADATA_ZONE)) {
		<span class="enscript-keyword">if</span> (startingBlock &lt;= vcb-&gt;hfs_metazone_end) {
			<span class="enscript-keyword">if</span> (endingBlock &gt; (vcb-&gt;hfs_metazone_end + 2))
				startingBlock = vcb-&gt;hfs_metazone_end + 1;
			<span class="enscript-keyword">else</span> {
				err = dskFulErr;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
			}
		}
	}

	<span class="enscript-comment">//	Since this routine doesn't wrap around
</span>	<span class="enscript-keyword">if</span> (maxBlocks &gt; (endingBlock - startingBlock)) {
		maxBlocks = endingBlock - startingBlock;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Pre-read the first bitmap block
</span>	<span class="enscript-comment">//
</span>	err = ReadBitmapBlock(vcb, startingBlock, &amp;currCache, &amp;blockRef, flags);
	<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	buffer = currCache;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Set up the current position within the block
</span>	<span class="enscript-comment">//
</span>	{
		u_int32_t wordIndexInBlock;

		bitsPerBlock  = vcb-&gt;vcbVBMIOSize * kBitsPerByte;
		wordsPerBlock = vcb-&gt;vcbVBMIOSize / kBytesPerWord;

		wordIndexInBlock = (startingBlock &amp; (bitsPerBlock-1)) / kBitsPerWord;
		buffer += wordIndexInBlock;
		wordsLeft = wordsPerBlock - wordIndexInBlock;
		currentWord = SWAP_BE32 (*buffer);
		bitMask = kHighBitInWordMask &gt;&gt; (startingBlock &amp; kBitsWithinWordMask);
	}

	<span class="enscript-comment">/*
	 * While loop 1:
	 *		Find the first unallocated block starting at 'block'
	 */</span>
	uint32_t summary_block_scan = 0;

	block=startingBlock;
	<span class="enscript-keyword">while</span> (block &lt; endingBlock) {
		<span class="enscript-keyword">if</span> ((currentWord &amp; bitMask) == 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">//	Next bit
</span>		++block;
		bitMask &gt;&gt;= 1;
		<span class="enscript-keyword">if</span> (bitMask == 0) {
			<span class="enscript-comment">//	Next word
</span>			bitMask = kHighBitInWordMask;
			++buffer;

			<span class="enscript-keyword">if</span> (--wordsLeft == 0) {
				<span class="enscript-comment">//	Next block
</span>				buffer = currCache = NULL;
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
					<span class="enscript-comment">/*
					 * If summary_block_scan is non-zero, then we must have
					 * pulled a bitmap file block into core, and scanned through
					 * the entire thing.  Because we're in this loop, we are 
					 * implicitly trusting that the bitmap didn't have any knowledge
					 * about this particular block.  As a result, update the bitmap
					 * (lazily, now that we've scanned it) with our findings that 
					 * this particular block is completely used up.
					 */</span>
					<span class="enscript-keyword">if</span> (summary_block_scan != 0) {
						uint32_t summary_bit;
						(<span class="enscript-type">void</span>) hfs_get_summary_index (hfsmp, summary_block_scan, &amp;summary_bit);
						hfs_set_summary (hfsmp, summary_bit, 1);
						summary_block_scan = 0;
					}
				}

				err = ReleaseBitmapBlock(vcb, blockRef, false);
				<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

				<span class="enscript-comment">/*
				 * Skip over metadata blocks.
				 */</span>
				<span class="enscript-keyword">if</span> (!useMetaZone) {
					block = NextBitmapBlock(vcb, block);
				}
				<span class="enscript-keyword">if</span> (block &gt;= endingBlock) {
					err = dskFulErr;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
				}

				err = ReadBitmapBlock(vcb, block, &amp;currCache, &amp;blockRef, flags);
				<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
				buffer = currCache;
				summary_block_scan = block;
				wordsLeft = wordsPerBlock;
			}
			currentWord = SWAP_BE32 (*buffer);
		}
	}

	<span class="enscript-comment">//	Did we get to the end of the bitmap before finding a free block?
</span>	<span class="enscript-comment">//	If so, then couldn't allocate anything.
</span>	<span class="enscript-keyword">if</span> (block &gt;= endingBlock) {
		err = dskFulErr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	}


	<span class="enscript-comment">/* 
	 * Don't move forward just yet.  Verify that either one of the following
	 * two conditions is true:
	 * 1) journaling is not enabled
	 * 2) block is not currently on any pending TRIM list. 
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl != NULL &amp;&amp; (forceFlush == false)) {
		<span class="enscript-type">int</span> recently_deleted = 0;
		uint32_t nextblk;
		err = CheckUnmappedBytes (hfsmp, (uint64_t) block, 1, &amp;recently_deleted, &amp;nextblk);
		<span class="enscript-keyword">if</span> ((err == 0) &amp;&amp; (recently_deleted)) {

			<span class="enscript-comment">/* release the bitmap block &amp; unset currCache.  we may jump past it. */</span>
			err = ReleaseBitmapBlock(vcb, blockRef, false);
			currCache = NULL;
			<span class="enscript-keyword">if</span> (err != noErr) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
			}
			<span class="enscript-comment">/* set our start to nextblk, and re-do the search. */</span>
			startingBlock = nextblk;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restartSearchAny</span>;
		}
	}


	<span class="enscript-comment">//	Return the first block in the allocated range
</span>	*actualStartBlock = block;
	dirty = true;

	<span class="enscript-comment">//	If we could get the desired number of blocks before hitting endingBlock,
</span>	<span class="enscript-comment">//	then adjust endingBlock so we won't keep looking.  Ideally, the comparison
</span>	<span class="enscript-comment">//	would be (block + maxBlocks) &lt; endingBlock, but that could overflow.  The
</span>	<span class="enscript-comment">//	comparison below yields identical results, but without overflow.
</span>	<span class="enscript-keyword">if</span> (block &lt; (endingBlock-maxBlocks)) {
		endingBlock = block + maxBlocks;	<span class="enscript-comment">//	if we get this far, we've found enough
</span>	}

	<span class="enscript-comment">/*
	 * While loop 2:
	 *		Scan the bitmap, starting at 'currentWord' in the current
	 *		bitmap block.  Continue iterating through the bitmap until
	 * 		either we hit an allocated block, or until we have accumuluated
	 *		maxBlocks worth of bitmap.
	 */</span>
	
	<span class="enscript-comment">/* Continue until we see an allocated block */</span>
	<span class="enscript-keyword">while</span> ((currentWord &amp; bitMask) == 0) {	
		<span class="enscript-comment">//	Move to the next block.  If no more, then exit.
</span>		++block;
		<span class="enscript-keyword">if</span> (block == endingBlock) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">//	Next bit
</span>		bitMask &gt;&gt;= 1;
		<span class="enscript-keyword">if</span> (bitMask == 0) {
			<span class="enscript-comment">//	Next word
</span>			bitMask = kHighBitInWordMask;
			++buffer;

			<span class="enscript-keyword">if</span> (--wordsLeft == 0) {
				<span class="enscript-comment">//	Next block
</span>				buffer = currCache = NULL;

				<span class="enscript-comment">/* We're only reading the bitmap here, so mark it as clean */</span>
				err = ReleaseBitmapBlock(vcb, blockRef, false);
				<span class="enscript-keyword">if</span> (err != noErr) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
				}

				<span class="enscript-comment">/*
				 * Skip over metadata blocks.
				 */</span>
				<span class="enscript-keyword">if</span> (!useMetaZone) {
					u_int32_t nextBlock;
					nextBlock = NextBitmapBlock(vcb, block);
					<span class="enscript-keyword">if</span> (nextBlock != block) {
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;  <span class="enscript-comment">/* allocation gap, so stop */</span>
					}
				}

				<span class="enscript-keyword">if</span> (block &gt;= endingBlock) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
				}

				err = ReadBitmapBlock(vcb, block, &amp;currCache, &amp;blockRef, flags);
				<span class="enscript-keyword">if</span> (err != noErr) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
				}
				buffer = currCache;
				wordsLeft = wordsPerBlock;
			}
			currentWord = SWAP_BE32 (*buffer);
		}
	}

<span class="enscript-reference">Exit</span>:
	<span class="enscript-keyword">if</span> (currCache) {
		<span class="enscript-comment">/* Release the bitmap reference prior to marking bits in-use */</span>
		(<span class="enscript-type">void</span>) ReleaseBitmapBlock(vcb, blockRef, false);
		currCache = NULL;
	}

	<span class="enscript-keyword">if</span> (err == noErr) {
		*actualNumBlocks = block - *actualStartBlock;
	
		<span class="enscript-comment">// sanity check
</span>		<span class="enscript-keyword">if</span> ((*actualStartBlock + *actualNumBlocks) &gt; vcb-&gt;allocLimit) {
			panic(<span class="enscript-string">&quot;hfs: BlockFindAnyBitmap: allocation overflow on \&quot;%s\&quot;&quot;</span>, vcb-&gt;vcbVN);
		}
	}
	<span class="enscript-keyword">else</span> {
		*actualStartBlock = 0;
		*actualNumBlocks = 0;
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ALLOC_ANY_BITMAP | DBG_FUNC_END, err, *actualStartBlock, *actualNumBlocks, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockFindKnown

Function:   Return a potential extent from the free extent cache.  The
		    returned extent *must* be marked allocated and removed
		    from the cache by the *caller*.

Inputs:
	vcb				Pointer to volume where space is to be allocated
	maxBlocks		Maximum number of contiguous blocks to allocate

Outputs:
	actualStartBlock	First block of range allocated, or 0 if error
	actualNumBlocks		Number of blocks allocated, or 0 if error

Returns:
	dskFulErr		Free extent cache is empty
_______________________________________________________________________
*/</span>

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindKnown</span>(
		ExtendedVCB		*vcb,
		u_int32_t		maxBlocks,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks)
{
	OSErr			err;	
	u_int32_t		foundBlocks;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ALLOC_FIND_KNOWN | DBG_FUNC_START, 0, 0, maxBlocks, 0, 0);

	hfs_lock_mount (hfsmp);
	lck_spin_lock(&amp;vcb-&gt;vcbFreeExtLock);
	<span class="enscript-keyword">if</span> ( vcb-&gt;vcbFreeExtCnt == 0 || 
			vcb-&gt;vcbFreeExt[0].blockCount == 0) {
		lck_spin_unlock(&amp;vcb-&gt;vcbFreeExtLock);
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
			KERNEL_DEBUG_CONSTANT(HFSDBG_ALLOC_FIND_KNOWN | DBG_FUNC_END, dskFulErr, *actualStartBlock, *actualNumBlocks, 0, 0);
		<span class="enscript-keyword">return</span> dskFulErr;
	}
	lck_spin_unlock(&amp;vcb-&gt;vcbFreeExtLock);
	hfs_unlock_mount(hfsmp);

	lck_spin_lock(&amp;vcb-&gt;vcbFreeExtLock);

	<span class="enscript-comment">//	Just grab up to maxBlocks of the first (largest) free exent.
</span>	*actualStartBlock = vcb-&gt;vcbFreeExt[0].startBlock;
	foundBlocks = vcb-&gt;vcbFreeExt[0].blockCount;
	<span class="enscript-keyword">if</span> (foundBlocks &gt; maxBlocks)
		foundBlocks = maxBlocks;
	*actualNumBlocks = foundBlocks;

	lck_spin_unlock(&amp;vcb-&gt;vcbFreeExtLock);

	<span class="enscript-comment">// sanity check
</span>	<span class="enscript-keyword">if</span> ((*actualStartBlock + *actualNumBlocks) &gt; vcb-&gt;allocLimit) 
	{
		printf (<span class="enscript-string">&quot;hfs: BlockAllocateKnown() found allocation overflow on \&quot;%s\&quot;&quot;</span>, vcb-&gt;vcbVN);
		hfs_mark_inconsistent(vcb, HFS_INCONSISTENCY_DETECTED);
		err = EIO;
	} <span class="enscript-keyword">else</span>
		err = 0;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ALLOC_FIND_KNOWN | DBG_FUNC_END, err, *actualStartBlock, *actualNumBlocks, 0, 0);

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/*
 * BlockMarkAllocated
 * 
 * This is a wrapper function around the internal calls which will actually mark the blocks
 * as in-use.  It will mark the blocks in the red-black tree if appropriate.  We need to do 
 * this logic here to avoid callers having to deal with whether or not the red-black tree
 * is enabled.
 */</span>

OSErr <span class="enscript-function-name">BlockMarkAllocated</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		<span class="enscript-type">register</span> u_int32_t	numBlocks)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;

	hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">return</span> BlockMarkAllocatedInternal(vcb, startingBlock, numBlocks, 0);

}


<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockMarkAllocatedInternal

Function:	Mark a contiguous group of blocks as allocated (set in the
			bitmap).  It assumes those bits are currently marked
			deallocated (clear in the bitmap).  Note that this function
			must be called regardless of whether or not the bitmap or
			tree-based allocator is used, as all allocations must correctly
			be marked on-disk.  If the tree-based approach is running, then
			this will be done before the node is removed from the tree.

Inputs:
	vcb				Pointer to volume where space is to be allocated
	startingBlock	First block number to mark as allocated
	numBlocks		Number of blocks to mark as allocated
_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> 
OSErr <span class="enscript-function-name">BlockMarkAllocatedInternal</span> (
								  ExtendedVCB		*vcb,
								  u_int32_t		startingBlock,
								  u_int32_t	numBlocks,
								  hfs_block_alloc_flags_t flags)
{
	OSErr			err;
	<span class="enscript-type">register</span> u_int32_t	*currentWord;	<span class="enscript-comment">//	Pointer to current word within bitmap block
</span>	<span class="enscript-type">register</span> u_int32_t	wordsLeft;		<span class="enscript-comment">//	Number of words left in this bitmap block
</span>	<span class="enscript-type">register</span> u_int32_t	bitMask;		<span class="enscript-comment">//	Word with given bits already set (ready to OR in)
</span>	u_int32_t		firstBit;		<span class="enscript-comment">//	Bit index within word of first bit to allocate
</span>	u_int32_t		numBits;		<span class="enscript-comment">//	Number of bits in word to allocate
</span>	u_int32_t		*buffer = NULL;
	uintptr_t  blockRef = 0;
	u_int32_t  bitsPerBlock;
	u_int32_t  wordsPerBlock;
	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_MARK_ALLOC_BITMAP | DBG_FUNC_START, startingBlock, numBlocks, flags, 0, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>

	<span class="enscript-type">struct</span> rl_entry *range;
	TAILQ_FOREACH(range, &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_LOCKED_BLOCKS], rl_link) {
		assert(rl_overlap(range, startingBlock,
						  startingBlock + numBlocks - 1) == RL_NOOVERLAP);
	}

#<span class="enscript-reference">endif</span>

	<span class="enscript-type">int</span> force_flush = 0;
	<span class="enscript-comment">/*
	 * Since we are about to mark these bits as in-use 
	 * in the bitmap, decide if we need to alert the caller
	 * that a journal flush might be appropriate. It's safe to 
	 * poke at the journal pointer here since we MUST have 
	 * called start_transaction by the time this function is invoked.  
	 * If the journal is enabled, then it will have taken the requisite 
	 * journal locks.  If it is not enabled, then we have taken 
	 * a shared lock on the global lock.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		uint32_t ignore;
		err = CheckUnmappedBytes (hfsmp, (uint64_t) startingBlock, (uint64_t)numBlocks, &amp;force_flush, &amp;ignore);
		<span class="enscript-keyword">if</span> ((err == 0) &amp;&amp; (force_flush)) {
			journal_request_immediate_flush (hfsmp-&gt;jnl);		
		}
	}

	hfs_unmap_alloc_extent(vcb, startingBlock, numBlocks);

	<span class="enscript-comment">/*
	 * Don't make changes to the disk if we're just reserving.  Note that
	 * we could do better in the tentative case because we could, in theory,
	 * avoid the journal flush above.  However, that would mean that we would
	 * need to catch the callback to stop it incorrectly addding the extent
	 * to our free cache.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_LOCKED | HFS_ALLOC_TENTATIVE)) {
		err = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Pre-read the bitmap block containing the first word of allocation
</span>	<span class="enscript-comment">//
</span>
	err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef,
						  HFS_ALLOC_IGNORE_RESERVED);
	<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Initialize currentWord, and wordsLeft.
</span>	<span class="enscript-comment">//
</span>	{
		u_int32_t wordIndexInBlock;

		bitsPerBlock  = vcb-&gt;vcbVBMIOSize * kBitsPerByte;
		wordsPerBlock = vcb-&gt;vcbVBMIOSize / kBytesPerWord;

		wordIndexInBlock = (startingBlock &amp; (bitsPerBlock-1)) / kBitsPerWord;
		currentWord = buffer + wordIndexInBlock;
		wordsLeft = wordsPerBlock - wordIndexInBlock;
	}

	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	If the first block to allocate doesn't start on a word
</span>	<span class="enscript-comment">//	boundary in the bitmap, then treat that first word
</span>	<span class="enscript-comment">//	specially.
</span>	<span class="enscript-comment">//
</span>
	firstBit = startingBlock % kBitsPerWord;
	<span class="enscript-keyword">if</span> (firstBit != 0) {
		bitMask = kAllBitsSetInWord &gt;&gt; firstBit;	<span class="enscript-comment">//	turn off all bits before firstBit
</span>		numBits = kBitsPerWord - firstBit;			<span class="enscript-comment">//	number of remaining bits in this word
</span>		<span class="enscript-keyword">if</span> (numBits &gt; numBlocks) {
			numBits = numBlocks;					<span class="enscript-comment">//	entire allocation is inside this one word
</span>			bitMask &amp;= ~(kAllBitsSetInWord &gt;&gt; (firstBit + numBits));	<span class="enscript-comment">//	turn off bits after last
</span>		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> ((*currentWord &amp; SWAP_BE32 (bitMask)) != 0) {
			panic(<span class="enscript-string">&quot;hfs: BlockMarkAllocatedInternal: blocks already allocated!&quot;</span>);
		}
#<span class="enscript-reference">endif</span>
		*currentWord |= SWAP_BE32 (bitMask);		<span class="enscript-comment">//	set the bits in the bitmap
</span>		numBlocks -= numBits;						<span class="enscript-comment">//	adjust number of blocks left to allocate
</span>
		++currentWord;								<span class="enscript-comment">//	move to next word
</span>		--wordsLeft;								<span class="enscript-comment">//	one less word left in this block
</span>	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Allocate whole words (32 blocks) at a time.
</span>	<span class="enscript-comment">//
</span>
	bitMask = kAllBitsSetInWord;					<span class="enscript-comment">//	put this in a register for 68K
</span>	<span class="enscript-keyword">while</span> (numBlocks &gt;= kBitsPerWord) {
		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">//	Read in the next bitmap block
</span>			startingBlock += bitsPerBlock;			<span class="enscript-comment">//	generate a block number in the next bitmap block
</span>
			buffer = NULL;
			err = ReleaseBitmapBlock(vcb, blockRef, true);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef,
								  HFS_ALLOC_IGNORE_RESERVED);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			<span class="enscript-comment">// XXXdbg
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
			}

			<span class="enscript-comment">//	Readjust currentWord and wordsLeft
</span>			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (*currentWord != 0) {
			panic(<span class="enscript-string">&quot;hfs: BlockMarkAllocatedInternal: blocks already allocated!&quot;</span>);
		}
#<span class="enscript-reference">endif</span>
		*currentWord = SWAP_BE32 (bitMask);
		numBlocks -= kBitsPerWord;

		++currentWord;								<span class="enscript-comment">//	move to next word
</span>		--wordsLeft;								<span class="enscript-comment">//	one less word left in this block
</span>	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Allocate any remaining blocks.
</span>	<span class="enscript-comment">//
</span>
	<span class="enscript-keyword">if</span> (numBlocks != 0) {
		bitMask = ~(kAllBitsSetInWord &gt;&gt; numBlocks);	<span class="enscript-comment">//	set first numBlocks bits
</span>		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">//	Read in the next bitmap block
</span>			startingBlock += bitsPerBlock;				<span class="enscript-comment">//	generate a block number in the next bitmap block
</span>
			buffer = NULL;
			err = ReleaseBitmapBlock(vcb, blockRef, true);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef,
								  HFS_ALLOC_IGNORE_RESERVED);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			<span class="enscript-comment">// XXXdbg
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
			}

			<span class="enscript-comment">//	Readjust currentWord and wordsLeft
</span>			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> ((*currentWord &amp; SWAP_BE32 (bitMask)) != 0) {
			panic(<span class="enscript-string">&quot;hfs: BlockMarkAllocatedInternal: blocks already allocated!&quot;</span>);
		}
#<span class="enscript-reference">endif</span>
		*currentWord |= SWAP_BE32 (bitMask);			<span class="enscript-comment">//	set the bits in the bitmap
</span>
		<span class="enscript-comment">//	No need to update currentWord or wordsLeft
</span>	}

<span class="enscript-reference">Exit</span>:

	<span class="enscript-keyword">if</span> (buffer)
		(<span class="enscript-type">void</span>)ReleaseBitmapBlock(vcb, blockRef, true);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_MARK_ALLOC_BITMAP | DBG_FUNC_END, err, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * BlockMarkFree
 * 
 * This is a wrapper function around the internal calls which will actually mark the blocks
 * as freed.  It will mark the blocks in the red-black tree if appropriate.  We need to do 
 * this logic here to avoid callers having to deal with whether or not the red-black tree
 * is enabled.
 *
 */</span>
OSErr <span class="enscript-function-name">BlockMarkFree</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		<span class="enscript-type">register</span> u_int32_t	numBlocks)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">return</span> BlockMarkFreeInternal(vcb, startingBlock, numBlocks, true);
}


<span class="enscript-comment">/*
 * BlockMarkFreeUnused
 * 
 * Scan the bitmap block beyond end of current file system for bits 
 * that are marked as used.  If any of the bits are marked as used,
 * this function marks them free.
 *
 * Note:  This was specifically written to mark all bits beyond 
 * end of current file system during hfs_extendfs(), which makes
 * sure that all the new blocks added to the file system are 
 * marked as free.   We expect that all the blocks beyond end of
 * current file system are always marked as free, but there might 
 * be cases where are marked as used.  This function assumes that 
 * the number of blocks marked as used incorrectly are relatively
 * small, otherwise this can overflow journal transaction size
 * on certain file system configurations (example, large unused 
 * bitmap with relatively small journal). 
 *
 * Input:
 * 	startingBlock: First block of the range to mark unused
 * 	numBlocks: Number of blocks in the range to mark unused
 *
 * Returns: zero on success, non-zero on error.
 */</span>
OSErr <span class="enscript-function-name">BlockMarkFreeUnused</span>(ExtendedVCB *vcb, u_int32_t startingBlock, <span class="enscript-type">register</span> u_int32_t	numBlocks)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);
	u_int32_t curNumBlocks;
	u_int32_t  bitsPerBlock;
	u_int32_t lastBit;

	<span class="enscript-comment">/* Use the optimal bitmap I/O size instead of bitmap block size */</span>
	bitsPerBlock  = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;

	<span class="enscript-comment">/* 
	 * First clear any non bitmap allocation block aligned bits
	 *
	 * Calculate the first bit in the bitmap block next to 
	 * the bitmap block containing the bit for startingBlock.
	 * Using this value, we calculate the total number of 
	 * bits to be marked unused from startingBlock to the 
	 * end of bitmap block containing startingBlock. 
	 */</span>
	lastBit = ((startingBlock + (bitsPerBlock - 1))/bitsPerBlock) * bitsPerBlock;
	curNumBlocks = lastBit - startingBlock;
	<span class="enscript-keyword">if</span> (curNumBlocks &gt; numBlocks) {
		curNumBlocks = numBlocks;
	}
	error = BlockMarkFreeInternal(vcb, startingBlock, curNumBlocks, false);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}
	startingBlock += curNumBlocks;
	numBlocks -= curNumBlocks;

	<span class="enscript-comment">/* 
	 * Check a full bitmap block for any 'used' bit.  If any bit is used,
	 * mark all the bits only in that bitmap block as free.  This ensures
	 * that we do not write unmodified bitmap blocks and do not 
	 * overwhelm the journal. 
	 *
	 * The code starts by checking full bitmap block at a time, and 
	 * marks entire bitmap block as free only if any bit in that bitmap 
	 * block is marked as used.  In the end, it handles the last bitmap 
	 * block which might be partially full by only checking till the 
	 * caller-specified last bit and if any bit is set, only mark that 
	 * range as free.
	 */</span>
	<span class="enscript-keyword">while</span> (numBlocks) {
		<span class="enscript-keyword">if</span> (numBlocks &gt;= bitsPerBlock) {
			curNumBlocks = bitsPerBlock;
		} <span class="enscript-keyword">else</span> {
			curNumBlocks = numBlocks;
		}
		<span class="enscript-keyword">if</span> (hfs_isallocated(hfsmp, startingBlock, curNumBlocks) == true) {
			error = BlockMarkFreeInternal(vcb, startingBlock, curNumBlocks, false);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">return</span> error;
			}
		}
		startingBlock += curNumBlocks;
		numBlocks -= curNumBlocks;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockMarkFreeInternal

Function:	Mark a contiguous group of blocks as free (clear in the
			bitmap).  It assumes those bits are currently marked
			allocated (set in the bitmap).

Inputs:
	vcb				Pointer to volume where space is to be freed
	startingBlock	First block number to mark as freed
	numBlocks		Number of blocks to mark as freed
	do_validate 	If true, validate that the blocks being 
					deallocated to check if they are within totalBlocks
					for current volume and whether they were allocated
					before they are marked free.
_______________________________________________________________________
*/</span>
<span class="enscript-type">static</span> 
OSErr <span class="enscript-function-name">BlockMarkFreeInternal</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock_in,
		<span class="enscript-type">register</span> u_int32_t	numBlocks_in,
		Boolean 		do_validate)
{
	OSErr		err;
	u_int32_t	startingBlock = startingBlock_in;
	u_int32_t	numBlocks = numBlocks_in;
	uint32_t	unmapStart = startingBlock_in;
	uint32_t	unmapCount = numBlocks_in;
	uint32_t	wordIndexInBlock;
	u_int32_t	*currentWord;	<span class="enscript-comment">//	Pointer to current word within bitmap block
</span>	u_int32_t	wordsLeft;		<span class="enscript-comment">//	Number of words left in this bitmap block
</span>	u_int32_t	bitMask;		<span class="enscript-comment">//	Word with given bits already set (ready to OR in)
</span>	u_int32_t	currentBit;		<span class="enscript-comment">//	Bit index within word of current bit to allocate
</span>	u_int32_t	numBits;		<span class="enscript-comment">//	Number of bits in word to allocate
</span>	u_int32_t	*buffer = NULL;
	uintptr_t	blockRef = 0;
	u_int32_t	bitsPerBlock;
	u_int32_t	wordsPerBlock;
	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-type">struct</span> hfsmount *hfsmp = VCBTOHFS(vcb);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_MARK_FREE_BITMAP | DBG_FUNC_START, startingBlock_in, numBlocks_in, do_validate, 0, 0);

	<span class="enscript-comment">/*
	 * NOTE: We use vcb-&gt;totalBlocks instead of vcb-&gt;allocLimit because we
	 * need to be able to free blocks being relocated during hfs_truncatefs.
	 */</span>
	<span class="enscript-keyword">if</span> ((do_validate == true) &amp;&amp; 
			(startingBlock + numBlocks &gt; vcb-&gt;totalBlocks)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ALLOC_DEBUG</span> || <span class="enscript-variable-name">DEBUG</span>
		panic (<span class="enscript-string">&quot;BlockMarkFreeInternal() free non-existent blocks at %u (numBlock=%u) on vol %s\n&quot;</span>, startingBlock, numBlocks, vcb-&gt;vcbVN);
		__builtin_unreachable();
#<span class="enscript-reference">else</span>
		printf (<span class="enscript-string">&quot;hfs: BlockMarkFreeInternal() trying to free non-existent blocks starting at %u (numBlock=%u) on volume %s\n&quot;</span>, startingBlock, numBlocks, vcb-&gt;vcbVN);
		hfs_mark_inconsistent(vcb, HFS_INCONSISTENCY_DETECTED);
		err = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Pre-read the bitmap block containing the first word of allocation
</span>	<span class="enscript-comment">//
</span>
	err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef, 
						  HFS_ALLOC_IGNORE_RESERVED);
	<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
	}

	uint32_t min_unmap = 0, max_unmap = UINT32_MAX;

	<span class="enscript-comment">// Work out the bounds of any unmap we can send down
</span>	<span class="enscript-type">struct</span> rl_entry *range;
	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; 2; ++i) {
		TAILQ_FOREACH(range, &amp;hfsmp-&gt;hfs_reserved_ranges[i], rl_link) {
			<span class="enscript-keyword">if</span> (range-&gt;rl_start &lt; startingBlock
				&amp;&amp; range-&gt;rl_end &gt;= min_unmap) {
				min_unmap = range-&gt;rl_end + 1;
			}
			<span class="enscript-keyword">if</span> (range-&gt;rl_end &gt;= startingBlock + numBlocks
				&amp;&amp; range-&gt;rl_start &lt; max_unmap) {
				max_unmap = range-&gt;rl_start;
			}
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Figure out how many bits and words per bitmap block.
</span>	<span class="enscript-comment">//
</span>	bitsPerBlock  = vcb-&gt;vcbVBMIOSize * kBitsPerByte;
	wordsPerBlock = vcb-&gt;vcbVBMIOSize / kBytesPerWord;
	wordIndexInBlock = (startingBlock &amp; (bitsPerBlock-1)) / kBitsPerWord;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Look for a range of free blocks immediately before startingBlock
</span>	<span class="enscript-comment">// (up to the start of the current bitmap block).  Set unmapStart to
</span>	<span class="enscript-comment">// the first free block.
</span>	<span class="enscript-comment">//
</span>	currentWord = buffer + wordIndexInBlock;
	currentBit = startingBlock % kBitsPerWord;
	bitMask = kHighBitInWordMask &gt;&gt; currentBit;
	<span class="enscript-keyword">while</span> (unmapStart &gt; min_unmap) {
		<span class="enscript-comment">// Move currentWord/bitMask back by one bit
</span>		bitMask &lt;&lt;= 1;
		<span class="enscript-keyword">if</span> (bitMask == 0) {
			<span class="enscript-keyword">if</span> (--currentWord &lt; buffer)
				<span class="enscript-keyword">break</span>;
			bitMask = kLowBitInWordMask;
		}

		<span class="enscript-keyword">if</span> (*currentWord &amp; SWAP_BE32(bitMask))
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">// Found an allocated block.  Stop searching.
</span>		--unmapStart;
		++unmapCount;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	If the first block to free doesn't start on a word
</span>	<span class="enscript-comment">//	boundary in the bitmap, then treat that first word
</span>	<span class="enscript-comment">//	specially.
</span>	<span class="enscript-comment">//
</span>
	currentWord = buffer + wordIndexInBlock;
	wordsLeft = wordsPerBlock - wordIndexInBlock;
	currentBit = startingBlock % kBitsPerWord;
	<span class="enscript-keyword">if</span> (currentBit != 0) {
		bitMask = kAllBitsSetInWord &gt;&gt; currentBit;	<span class="enscript-comment">//	turn off all bits before currentBit
</span>		numBits = kBitsPerWord - currentBit;		<span class="enscript-comment">//	number of remaining bits in this word
</span>		<span class="enscript-keyword">if</span> (numBits &gt; numBlocks) {
			numBits = numBlocks;					<span class="enscript-comment">//	entire allocation is inside this one word
</span>			bitMask &amp;= ~(kAllBitsSetInWord &gt;&gt; (currentBit + numBits));	<span class="enscript-comment">//	turn off bits after last
</span>		}
		<span class="enscript-keyword">if</span> ((do_validate == true) &amp;&amp; 
				(*currentWord &amp; SWAP_BE32 (bitMask)) != SWAP_BE32 (bitMask)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Corruption</span>;
		}
		*currentWord &amp;= SWAP_BE32 (~bitMask);		<span class="enscript-comment">//	clear the bits in the bitmap
</span>		numBlocks -= numBits;						<span class="enscript-comment">//	adjust number of blocks left to free
</span>
		++currentWord;								<span class="enscript-comment">//	move to next word
</span>		--wordsLeft;								<span class="enscript-comment">//	one less word left in this block
</span>	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Free whole words (32 blocks) at a time.
</span>	<span class="enscript-comment">//
</span>
	<span class="enscript-keyword">while</span> (numBlocks &gt;= kBitsPerWord) {
		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">//	Read in the next bitmap block
</span>			startingBlock += bitsPerBlock;			<span class="enscript-comment">//	generate a block number in the next bitmap block
</span>
			buffer = NULL;
			err = ReleaseBitmapBlock(vcb, blockRef, true);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef,
								  HFS_ALLOC_IGNORE_RESERVED);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			<span class="enscript-comment">// XXXdbg
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
			}

			<span class="enscript-comment">//	Readjust currentWord and wordsLeft
</span>			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
		<span class="enscript-keyword">if</span> ((do_validate == true) &amp;&amp; 
				(*currentWord != SWAP_BE32 (kAllBitsSetInWord))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Corruption</span>;
		}
		*currentWord = 0;							<span class="enscript-comment">//	clear the entire word
</span>		numBlocks -= kBitsPerWord;

		++currentWord;								<span class="enscript-comment">//	move to next word
</span>		--wordsLeft;									<span class="enscript-comment">//	one less word left in this block
</span>	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Free any remaining blocks.
</span>	<span class="enscript-comment">//
</span>
	<span class="enscript-keyword">if</span> (numBlocks != 0) {
		bitMask = ~(kAllBitsSetInWord &gt;&gt; numBlocks);	<span class="enscript-comment">//	set first numBlocks bits
</span>		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">//	Read in the next bitmap block
</span>			startingBlock += bitsPerBlock;				<span class="enscript-comment">//	generate a block number in the next bitmap block
</span>
			buffer = NULL;
			err = ReleaseBitmapBlock(vcb, blockRef, true);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			err = ReadBitmapBlock(vcb, startingBlock, &amp;buffer, &amp;blockRef, 
								  HFS_ALLOC_IGNORE_RESERVED);
			<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			<span class="enscript-comment">// XXXdbg
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				journal_modify_block_start(hfsmp-&gt;jnl, (<span class="enscript-type">struct</span> buf *)blockRef);
			}

			<span class="enscript-comment">//	Readjust currentWord and wordsLeft
</span>			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
		<span class="enscript-keyword">if</span> ((do_validate == true) &amp;&amp; 
				(*currentWord &amp; SWAP_BE32 (bitMask)) != SWAP_BE32 (bitMask)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Corruption</span>;
		}
		*currentWord &amp;= SWAP_BE32 (~bitMask);			<span class="enscript-comment">//	clear the bits in the bitmap
</span>
		<span class="enscript-comment">//	No need to update currentWord or wordsLeft
</span>	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Look for a range of free blocks immediately after the range we just freed
</span>	<span class="enscript-comment">// (up to the end of the current bitmap block).
</span>	<span class="enscript-comment">//
</span>	wordIndexInBlock = ((startingBlock_in + numBlocks_in - 1) &amp; (bitsPerBlock-1)) / kBitsPerWord;
	wordsLeft = wordsPerBlock - wordIndexInBlock;
	currentWord = buffer + wordIndexInBlock;
	currentBit = (startingBlock_in + numBlocks_in - 1) % kBitsPerWord;
	bitMask = kHighBitInWordMask &gt;&gt; currentBit;
	<span class="enscript-keyword">while</span> (unmapStart + unmapCount &lt; max_unmap) {
		<span class="enscript-comment">// Move currentWord/bitMask/wordsLeft forward one bit
</span>		bitMask &gt;&gt;= 1;
		<span class="enscript-keyword">if</span> (bitMask == 0) {
			<span class="enscript-keyword">if</span> (--wordsLeft == 0)
				<span class="enscript-keyword">break</span>;
			++currentWord;
			bitMask = kHighBitInWordMask;
		}

		<span class="enscript-keyword">if</span> (*currentWord &amp; SWAP_BE32(bitMask))
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">// Found an allocated block.  Stop searching.
</span>		++unmapCount;
	}

<span class="enscript-reference">Exit</span>:

	<span class="enscript-keyword">if</span> (buffer)
		(<span class="enscript-type">void</span>)ReleaseBitmapBlock(vcb, blockRef, true);

	<span class="enscript-keyword">if</span> (err == noErr) {
		hfs_unmap_free_extent(vcb, unmapStart, unmapCount);
	}

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_MARK_FREE_BITMAP | DBG_FUNC_END, err, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> err;

<span class="enscript-reference">Corruption</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	panic(<span class="enscript-string">&quot;hfs: BlockMarkFreeInternal: blocks not allocated!&quot;</span>);
	__builtin_unreachable();
#<span class="enscript-reference">else</span>
	printf (<span class="enscript-string">&quot;hfs: BlockMarkFreeInternal() trying to free unallocated blocks on volume %s &lt;%u, %u&gt;\n&quot;</span>,
			vcb-&gt;vcbVN, startingBlock_in, numBlocks_in);
	hfs_mark_inconsistent(vcb, HFS_INCONSISTENCY_DETECTED);
	err = EIO;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
_______________________________________________________________________

Routine:	BlockFindContiguous

Function:	Find a contiguous range of blocks that are free (bits
			clear in the bitmap).  If a contiguous range of the
			minimum size can't be found, an error will be returned.
			This is only needed to support the bitmap-scanning logic,
			as the red-black tree should be able to do this by internally
			searching its tree.

Inputs:
	vcb				Pointer to volume where space is to be allocated
	startingBlock	Preferred first block of range
	endingBlock		Last possible block in range + 1
	minBlocks		Minimum number of blocks needed.  Must be &gt; 0.
	maxBlocks		Maximum (ideal) number of blocks desired
	useMetaZone	OK to dip into metadata allocation zone

Outputs:
	actualStartBlock	First block of range found, or 0 if error
	actualNumBlocks		Number of blocks found, or 0 if error

Returns:
	noErr			Found at least minBlocks contiguous
	dskFulErr		No contiguous space found, or all less than minBlocks
_______________________________________________________________________
*/</span>

<span class="enscript-type">static</span> OSErr <span class="enscript-function-name">BlockFindContiguous</span>(
		ExtendedVCB		*vcb,
		u_int32_t		startingBlock,
		u_int32_t		endingBlock,
		u_int32_t		minBlocks,
		u_int32_t		maxBlocks,
		Boolean			useMetaZone,
		Boolean			trustSummary,
		u_int32_t		*actualStartBlock,
		u_int32_t		*actualNumBlocks,
		hfs_block_alloc_flags_t flags)
{
	OSErr			err;
	<span class="enscript-type">register</span> u_int32_t	currentBlock;		<span class="enscript-comment">//	Block we're currently looking at.
</span>	u_int32_t			firstBlock;			<span class="enscript-comment">//	First free block in current extent.
</span>	u_int32_t			stopBlock;			<span class="enscript-comment">//	If we get to this block, stop searching for first free block.
</span>	u_int32_t			foundBlocks;		<span class="enscript-comment">//	Number of contiguous free blocks in current extent.
</span>	u_int32_t			*buffer = NULL;
	<span class="enscript-type">register</span> u_int32_t	*currentWord;
	<span class="enscript-type">register</span> u_int32_t	bitMask;
	<span class="enscript-type">register</span> u_int32_t	wordsLeft;
	<span class="enscript-type">register</span> u_int32_t	tempWord;
	uintptr_t  blockRef = 0;
	u_int32_t  wordsPerBlock;
	u_int32_t  updated_free_extent = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = (<span class="enscript-type">struct</span> hfsmount*) vcb;
	HFSPlusExtentDescriptor best = { 0, 0 };

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_FIND_CONTIG | DBG_FUNC_START, startingBlock, endingBlock, minBlocks, maxBlocks, 0);

	<span class="enscript-comment">/*
	 * When we're skipping the metadata zone and the start/end
	 * range overlaps with the metadata zone then adjust the 
	 * start to be outside of the metadata zone.  If the range
	 * is entirely inside the metadata zone then we can deny the
	 * request (dskFulErr).
	 */</span>
	<span class="enscript-keyword">if</span> (!useMetaZone &amp;&amp; (vcb-&gt;hfs_flags &amp; HFS_METADATA_ZONE)) {
		<span class="enscript-keyword">if</span> (startingBlock &lt;= vcb-&gt;hfs_metazone_end) {
			<span class="enscript-keyword">if</span> (endingBlock &gt; (vcb-&gt;hfs_metazone_end + 2))
				startingBlock = vcb-&gt;hfs_metazone_end + 1;
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">DiskFull</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((endingBlock - startingBlock) &lt; minBlocks)
	{
		<span class="enscript-comment">//	The set of blocks we're checking is smaller than the minimum number
</span>		<span class="enscript-comment">//	of blocks, so we couldn't possibly find a good range.
</span>		<span class="enscript-keyword">goto</span> <span class="enscript-reference">DiskFull</span>;
	}

	stopBlock = endingBlock - minBlocks + 1;
	currentBlock = startingBlock;
	firstBlock = 0;

	<span class="enscript-comment">/*
	 * Skip over metadata blocks.
	 */</span>
	<span class="enscript-keyword">if</span> (!useMetaZone)
		currentBlock = NextBitmapBlock(vcb, currentBlock);

	<span class="enscript-comment">/*
	 * Use the summary table if we can.  Skip over any totally
	 * allocated blocks.  currentBlock should now point to the first
	 * block beyond the metadata zone if the metazone allocations are not
	 * allowed in this invocation.
	 */</span>
	<span class="enscript-keyword">if</span> ((trustSummary) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE)) {
		uint32_t suggestion;
		err = hfs_find_summary_free (hfsmp, currentBlock, &amp;suggestion);
		<span class="enscript-keyword">if</span> (err &amp;&amp; err != ENOSPC)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		<span class="enscript-keyword">if</span> (err == ENOSPC || suggestion &gt;= stopBlock)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">DiskFull</span>;
		currentBlock = suggestion;
	}


	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Pre-read the first bitmap block.
</span>	<span class="enscript-comment">//
</span>	err = ReadBitmapBlock(vcb, currentBlock, &amp;buffer, &amp;blockRef, flags);
	<span class="enscript-keyword">if</span> ( err != noErr ) <span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//	Figure out where currentBlock is within the buffer.
</span>	<span class="enscript-comment">//
</span>	wordsPerBlock = vcb-&gt;vcbVBMIOSize / kBytesPerWord;

	wordsLeft = (currentBlock / kBitsPerWord) &amp; (wordsPerBlock-1);	<span class="enscript-comment">// Current index into buffer
</span>	currentWord = buffer + wordsLeft;
	wordsLeft = wordsPerBlock - wordsLeft;

	uint32_t remaining = (hfsmp-&gt;freeBlocks - hfsmp-&gt;lockedBlocks
						  - (ISSET(flags, HFS_ALLOC_IGNORE_TENTATIVE)
							 ? 0 : hfsmp-&gt;tentativeBlocks));

	<span class="enscript-comment">/*
	 * This outer do-while loop is the main body of this function.  Its job is 
	 * to search through the blocks (until we hit 'stopBlock'), and iterate
	 * through swaths of allocated bitmap until it finds free regions.
	 */</span>

	<span class="enscript-keyword">do</span>
	{
		foundBlocks = 0;
		<span class="enscript-comment">/*
		 * We will try and update the summary table as we search
		 * below.  Note that we will never update the summary table
		 * for the first and last blocks that the summary table
		 * covers.  Ideally, we should, but the benefits probably
		 * aren't that significant so we leave things alone for now.
		 */</span>
		uint32_t summary_block_scan = 0;
		<span class="enscript-comment">/*
		 * Inner while loop 1:
		 *		Look for free blocks, skipping over allocated ones.
		 *
		 * Initialization starts with checking the initial partial word
		 * if applicable.
		 */</span>
		bitMask = currentBlock &amp; kBitsWithinWordMask;
		<span class="enscript-keyword">if</span> (bitMask)
		{			
			tempWord = SWAP_BE32(*currentWord);			<span class="enscript-comment">//	Fetch the current word only once
</span>			bitMask = kHighBitInWordMask &gt;&gt; bitMask;
			<span class="enscript-keyword">while</span> (tempWord &amp; bitMask)
			{
				bitMask &gt;&gt;= 1;
				++currentBlock;
			}

			<span class="enscript-comment">//	Did we find an unused bit (bitMask != 0), or run out of bits (bitMask == 0)? 
</span>			<span class="enscript-keyword">if</span> (bitMask)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">FoundUnused</span>;

			<span class="enscript-comment">//	Didn't find any unused bits, so we're done with this word.
</span>			++currentWord;
			--wordsLeft;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">//	Check whole words
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">while</span> (currentBlock &lt; stopBlock)
		{
			<span class="enscript-comment">//	See if it's time to read another block.
</span>			<span class="enscript-keyword">if</span> (wordsLeft == 0)
			{
				buffer = NULL;
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
					<span class="enscript-comment">/*
					 * If summary_block_scan is non-zero, then we must have
					 * pulled a bitmap file block into core, and scanned through
					 * the entire thing.  Because we're in this loop, we are 
					 * implicitly trusting that the bitmap didn't have any knowledge
					 * about this particular block.  As a result, update the bitmap
					 * (lazily, now that we've scanned it) with our findings that 
					 * this particular block is completely used up.
					 */</span>
					<span class="enscript-keyword">if</span> (summary_block_scan != 0) {
						uint32_t summary_bit;
						(<span class="enscript-type">void</span>) hfs_get_summary_index (hfsmp, summary_block_scan, &amp;summary_bit);
						hfs_set_summary (hfsmp, summary_bit, 1);
						summary_block_scan = 0;
					}
				}
				err = ReleaseBitmapBlock(vcb, blockRef, false);
				<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;

				<span class="enscript-comment">/*
				 * Skip over metadata blocks.
				 */</span>
				<span class="enscript-keyword">if</span> (!useMetaZone) {
					currentBlock = NextBitmapBlock(vcb, currentBlock);
					<span class="enscript-keyword">if</span> (currentBlock &gt;= stopBlock) {
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">LoopExit</span>;
					}
				}

				<span class="enscript-comment">/* Skip over fully allocated bitmap blocks if we can */</span>
				<span class="enscript-keyword">if</span> ((trustSummary) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE)) {
					uint32_t suggestion;
					err = hfs_find_summary_free (hfsmp, currentBlock, &amp;suggestion);
					<span class="enscript-keyword">if</span> (err &amp;&amp; err != ENOSPC)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
					<span class="enscript-keyword">if</span> (err == ENOSPC || suggestion &gt;= stopBlock)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">LoopExit</span>;
					currentBlock = suggestion;
				}

				err = ReadBitmapBlock(vcb, currentBlock, &amp;buffer, &amp;blockRef, flags);
				<span class="enscript-keyword">if</span> ( err != noErr ) <span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;

				<span class="enscript-comment">/*
				 * Set summary_block_scan to be the block we just read into the block cache.
				 *
				 * At this point, we've just read an allocation block worth of bitmap file
				 * into the buffer above, but we don't know if it is completely allocated or not.
				 * If we find that it is completely allocated/full then we will jump 
				 * through this loop again and set the appropriate summary bit as fully allocated.
				 */</span>	
				summary_block_scan = currentBlock;
				currentWord = buffer;
				wordsLeft = wordsPerBlock;
			}

			<span class="enscript-comment">//	See if any of the bits are clear
</span>			<span class="enscript-keyword">if</span> ((tempWord = SWAP_BE32(*currentWord)) + 1)	<span class="enscript-comment">//	non-zero if any bits were clear
</span>			{
				<span class="enscript-comment">//	Figure out which bit is clear
</span>				bitMask = kHighBitInWordMask;
				<span class="enscript-keyword">while</span> (tempWord &amp; bitMask)
				{
					bitMask &gt;&gt;= 1;
					++currentBlock;
				}

				<span class="enscript-keyword">break</span>;		<span class="enscript-comment">//	Found the free bit; break out to FoundUnused.
</span>			}

			<span class="enscript-comment">//	Keep looking at the next word
</span>			currentBlock += kBitsPerWord;
			++currentWord;
			--wordsLeft;
		}

<span class="enscript-reference">FoundUnused</span>:
		<span class="enscript-comment">//	Make sure the unused bit is early enough to use
</span>		<span class="enscript-keyword">if</span> (currentBlock &gt;= stopBlock)
		{
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">//	Remember the start of the extent
</span>		firstBlock = currentBlock;


		<span class="enscript-comment">/*
		 * Inner while loop 2:
		 *		We get here if we find a free block. Count the number
		 * 		of contiguous free blocks observed.
		 * 
		 * Initialization starts with checking the initial partial word
		 * if applicable.
		 */</span>
		bitMask = currentBlock &amp; kBitsWithinWordMask;
		<span class="enscript-keyword">if</span> (bitMask)
		{
			tempWord = SWAP_BE32(*currentWord);			<span class="enscript-comment">//	Fetch the current word only once
</span>			bitMask = kHighBitInWordMask &gt;&gt; bitMask;
			<span class="enscript-keyword">while</span> (bitMask &amp;&amp; !(tempWord &amp; bitMask))
			{
				bitMask &gt;&gt;= 1;
				++currentBlock;
			}

			<span class="enscript-comment">//	Did we find a used bit (bitMask != 0), or run out of bits (bitMask == 0)? 
</span>			<span class="enscript-keyword">if</span> (bitMask)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">FoundUsed</span>;

			<span class="enscript-comment">//	Didn't find any used bits, so we're done with this word.
</span>			++currentWord;
			--wordsLeft;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">//	Check whole words
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">while</span> (currentBlock &lt; endingBlock)
		{
			<span class="enscript-comment">//	See if it's time to read another block.
</span>			<span class="enscript-keyword">if</span> (wordsLeft == 0)
			{
				buffer = NULL;
				err = ReleaseBitmapBlock(vcb, blockRef, false);
				<span class="enscript-keyword">if</span> (err != noErr) <span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;

				<span class="enscript-comment">/*
				 * Skip over metadata blocks.
				 */</span>
				<span class="enscript-keyword">if</span> (!useMetaZone) {
					u_int32_t nextBlock;

					nextBlock = NextBitmapBlock(vcb, currentBlock);
					<span class="enscript-keyword">if</span> (nextBlock != currentBlock) {
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">LoopExit</span>;  <span class="enscript-comment">/* allocation gap, so stop */</span>
					}
				}

				err = ReadBitmapBlock(vcb, currentBlock, &amp;buffer, &amp;blockRef, flags);
				<span class="enscript-keyword">if</span> ( err != noErr ) <span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;

				currentWord = buffer;
				wordsLeft = wordsPerBlock;
			}

			<span class="enscript-comment">//	See if any of the bits are set
</span>			<span class="enscript-keyword">if</span> ((tempWord = SWAP_BE32(*currentWord)) != 0)
			{
				<span class="enscript-comment">//	Figure out which bit is set
</span>				bitMask = kHighBitInWordMask;
				<span class="enscript-keyword">while</span> (!(tempWord &amp; bitMask))
				{
					bitMask &gt;&gt;= 1;
					++currentBlock;
				}

				<span class="enscript-keyword">break</span>;		<span class="enscript-comment">//	Found the used bit; break out to FoundUsed.
</span>			}

			<span class="enscript-comment">//	Keep looking at the next word
</span>			currentBlock += kBitsPerWord;
			++currentWord;
			--wordsLeft;

			<span class="enscript-comment">//	If we found at least maxBlocks, we can quit early.
</span>			<span class="enscript-keyword">if</span> ((currentBlock - firstBlock) &gt;= maxBlocks)
				<span class="enscript-keyword">break</span>;
		}

<span class="enscript-reference">FoundUsed</span>:
		<span class="enscript-comment">//	Make sure we didn't run out of bitmap looking for a used block.
</span>		<span class="enscript-comment">//	If so, pin to the end of the bitmap.
</span>		<span class="enscript-keyword">if</span> (currentBlock &gt; endingBlock)
			currentBlock = endingBlock;

		<span class="enscript-comment">//	Figure out how many contiguous free blocks there were.
</span>		<span class="enscript-comment">//	Pin the answer to maxBlocks.
</span>		foundBlocks = currentBlock - firstBlock;
		<span class="enscript-keyword">if</span> (foundBlocks &gt; maxBlocks)
			foundBlocks = maxBlocks;

		<span class="enscript-keyword">if</span> (remaining) {
			<span class="enscript-keyword">if</span> (foundBlocks &gt; remaining) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
				printf(<span class="enscript-string">&quot;hfs: found more blocks than are indicated free!\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				remaining = UINT32_MAX;
			} <span class="enscript-keyword">else</span>
				remaining -= foundBlocks;
		}

		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TRY_HARD)) {
			<span class="enscript-keyword">if</span> (foundBlocks &gt; best.blockCount) {
				best.startBlock = firstBlock;
				best.blockCount = foundBlocks;
			}

			<span class="enscript-keyword">if</span> (foundBlocks &gt;= maxBlocks || best.blockCount &gt;= remaining)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * Note that we will go ahead and add this free extent to our
			 * cache below but that's OK because we'll remove it again if we
			 * decide to use this extent.
			 */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (foundBlocks &gt;= minBlocks)
			<span class="enscript-keyword">break</span>;		<span class="enscript-comment">//	Found what we needed!
</span>
		<span class="enscript-comment">/*
		 * We did not find the total blocks we were looking for, but
		 * add this free block run to our free extent cache list, if possible.
		 */</span>

		<span class="enscript-comment">// If we're ignoring tentative ranges, we need to account for them here
</span>		<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_IGNORE_TENTATIVE)) {
			<span class="enscript-type">struct</span> rl_entry free_extent = rl_make(firstBlock, firstBlock + foundBlocks - 1);
			<span class="enscript-type">struct</span> rl_entry *range;;
			TAILQ_FOREACH(range, &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_TENTATIVE_BLOCKS], rl_link) {
				rl_subtract(&amp;free_extent, range);
				<span class="enscript-keyword">if</span> (rl_len(range) == 0)
					<span class="enscript-keyword">break</span>;
			}
			firstBlock = free_extent.rl_start;
			foundBlocks = rl_len(&amp;free_extent);
		}

		<span class="enscript-keyword">if</span> (foundBlocks) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
				<span class="enscript-comment">/* If there is no journal, go ahead and add to the free ext cache. */</span>
				updated_free_extent = add_free_extent_cache(vcb, firstBlock, foundBlocks);
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * If journaled, only add to the free extent cache if this block is not
				 * waiting for a TRIM to complete; that implies that the transaction that freed it
				 * has not yet been committed to stable storage. 
				 */</span>
				<span class="enscript-type">int</span> recently_deleted = 0;
				uint32_t nextblock;
				err = CheckUnmappedBytes(hfsmp, (uint64_t)firstBlock, 
						(uint64_t)foundBlocks, &amp;recently_deleted, &amp;nextblock);
				<span class="enscript-keyword">if</span> ((err) || (recently_deleted == 0))  {
					<span class="enscript-comment">/* if we hit an error, or the blocks not recently freed, go ahead and insert it */</span>
					updated_free_extent = add_free_extent_cache(vcb, firstBlock, foundBlocks);
				}
				err = 0;
			}
		}
	} <span class="enscript-keyword">while</span> (currentBlock &lt; stopBlock);
<span class="enscript-reference">LoopExit</span>:

	<span class="enscript-keyword">if</span> (ISSET(flags, HFS_ALLOC_TRY_HARD)) {
		firstBlock = best.startBlock;
		foundBlocks = best.blockCount;
	}

	<span class="enscript-comment">//	Return the outputs.
</span>	<span class="enscript-keyword">if</span> (foundBlocks &lt; minBlocks)
	{
<span class="enscript-reference">DiskFull</span>:
		err = dskFulErr;
<span class="enscript-reference">ErrorExit</span>:
		*actualStartBlock = 0;
		*actualNumBlocks = 0;
	}
	<span class="enscript-keyword">else</span>
	{
		err = noErr;
		*actualStartBlock = firstBlock;
		*actualNumBlocks = foundBlocks;
		<span class="enscript-comment">/*
		 * Sanity check for overflow
		 */</span>
		<span class="enscript-keyword">if</span> ((firstBlock + foundBlocks) &gt; vcb-&gt;allocLimit) {
			panic(<span class="enscript-string">&quot;hfs: blk allocation overflow on \&quot;%s\&quot; sb:0x%08x eb:0x%08x cb:0x%08x fb:0x%08x stop:0x%08x min:0x%08x found:0x%08x&quot;</span>,
					vcb-&gt;vcbVN, startingBlock, endingBlock, currentBlock,
					firstBlock, stopBlock, minBlocks, foundBlocks);
		}
	}

	<span class="enscript-keyword">if</span> (updated_free_extent &amp;&amp; (vcb-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE)) {
		<span class="enscript-type">int</span> i;
		u_int32_t min_start = vcb-&gt;totalBlocks;

		<span class="enscript-comment">// set the nextAllocation pointer to the smallest free block number
</span>		<span class="enscript-comment">// we've seen so on the next mount we won't rescan unnecessarily
</span>		lck_spin_lock(&amp;vcb-&gt;vcbFreeExtLock);
		<span class="enscript-keyword">for</span>(i=0; i &lt; (<span class="enscript-type">int</span>)vcb-&gt;vcbFreeExtCnt; i++) {
			<span class="enscript-keyword">if</span> (vcb-&gt;vcbFreeExt[i].startBlock &lt; min_start) {
				min_start = vcb-&gt;vcbFreeExt[i].startBlock;
			}
		}
		lck_spin_unlock(&amp;vcb-&gt;vcbFreeExtLock);
		<span class="enscript-keyword">if</span> (min_start != vcb-&gt;totalBlocks) {
			<span class="enscript-keyword">if</span> (min_start &lt; vcb-&gt;nextAllocation) {
				vcb-&gt;nextAllocation = min_start;
			}
			<span class="enscript-keyword">if</span> (min_start &lt; vcb-&gt;sparseAllocation) {
				vcb-&gt;sparseAllocation = min_start;
			}
		}
	}

	<span class="enscript-keyword">if</span> (buffer)
		(<span class="enscript-type">void</span>) ReleaseBitmapBlock(vcb, blockRef, false);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_ALLOC_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_BLOCK_FIND_CONTIG | DBG_FUNC_END, err, *actualStartBlock, *actualNumBlocks, 0, 0);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/* 
 * Count number of bits set in the given 32-bit unsigned number 
 *
 * Returns:
 * 	Number of bits set
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">num_bits_set</span>(u_int32_t num) 
{
	<span class="enscript-type">int</span> count;

	<span class="enscript-keyword">for</span> (count = 0; num; count++) {
		num &amp;= num - 1;
	}

	<span class="enscript-keyword">return</span> count;
}

<span class="enscript-comment">/* 
 * For a given range of blocks, find the total number of blocks 
 * allocated.  If 'stop_on_first' is true, it stops as soon as it 
 * encounters the first allocated block.  This option is useful 
 * to determine if any block is allocated or not. 
 *
 * Inputs:
 * 	startingBlock	First allocation block number of the range to be scanned.
 * 	numBlocks	Total number of blocks that need to be scanned.
 * 	stop_on_first	Stop the search after the first allocated block is found.
 *
 * Output:
 * 	allocCount	Total number of allocation blocks allocated in the given range.
 *
 * 			On error, it is the number of allocated blocks found 
 * 			before the function got an error. 
 *
 * 			If 'stop_on_first' is set, 
 * 				allocCount = 1 if any allocated block was found.
 * 				allocCount = 0 if no allocated block was found.
 *
 * Returns:
 * 	0 on success, non-zero on failure. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_isallocated_internal</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, 
		u_int32_t numBlocks, Boolean stop_on_first, u_int32_t *allocCount)
{
	u_int32_t  *currentWord;   <span class="enscript-comment">// Pointer to current word within bitmap block
</span>	u_int32_t  wordsLeft;      <span class="enscript-comment">// Number of words left in this bitmap block
</span>	u_int32_t  bitMask;        <span class="enscript-comment">// Word with given bits already set (ready to test)
</span>	u_int32_t  firstBit;       <span class="enscript-comment">// Bit index within word of first bit to allocate
</span>	u_int32_t  numBits;        <span class="enscript-comment">// Number of bits in word to allocate
</span>	u_int32_t  *buffer = NULL;
	uintptr_t  blockRef;
	u_int32_t  bitsPerBlock;
	u_int32_t  wordsPerBlock;
	u_int32_t  blockCount = 0;
	<span class="enscript-type">int</span>  error;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_IS_ALLOCATED | DBG_FUNC_START, startingBlock, numBlocks, stop_on_first, 0, 0);

	<span class="enscript-comment">/*
	 * Pre-read the bitmap block containing the first word of allocation
	 */</span>
	error = ReadBitmapBlock(hfsmp, startingBlock, &amp;buffer, &amp;blockRef, 
							HFS_ALLOC_IGNORE_TENTATIVE);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">JustReturn</span>;

	<span class="enscript-comment">/*
	 * Initialize currentWord, and wordsLeft.
	 */</span>
	{
		u_int32_t wordIndexInBlock;

		bitsPerBlock  = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;
		wordsPerBlock = hfsmp-&gt;vcbVBMIOSize / kBytesPerWord;

		wordIndexInBlock = (startingBlock &amp; (bitsPerBlock-1)) / kBitsPerWord;
		currentWord = buffer + wordIndexInBlock;
		wordsLeft = wordsPerBlock - wordIndexInBlock;
	}

	<span class="enscript-comment">/*
	 * First test any non word aligned bits.
	 */</span>
	firstBit = startingBlock % kBitsPerWord;
	<span class="enscript-keyword">if</span> (firstBit != 0) {
		bitMask = kAllBitsSetInWord &gt;&gt; firstBit;
		numBits = kBitsPerWord - firstBit;
		<span class="enscript-keyword">if</span> (numBits &gt; numBlocks) {
			numBits = numBlocks;
			bitMask &amp;= ~(kAllBitsSetInWord &gt;&gt; (firstBit + numBits));
		}
		<span class="enscript-keyword">if</span> ((*currentWord &amp; SWAP_BE32 (bitMask)) != 0) {
			<span class="enscript-keyword">if</span> (stop_on_first) {
				blockCount = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
			}
			blockCount += num_bits_set(*currentWord &amp; SWAP_BE32 (bitMask));
		}
		numBlocks -= numBits;
		++currentWord;
		--wordsLeft;
	}

	<span class="enscript-comment">/*
	 * Test whole words (32 blocks) at a time.
	 */</span>
	<span class="enscript-keyword">while</span> (numBlocks &gt;= kBitsPerWord) {
		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">/* Read in the next bitmap block. */</span>
			startingBlock += bitsPerBlock;

			buffer = NULL;
			error = ReleaseBitmapBlock(hfsmp, blockRef, false);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			error = ReadBitmapBlock(hfsmp, startingBlock, &amp;buffer, &amp;blockRef, 
									HFS_ALLOC_IGNORE_TENTATIVE);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			<span class="enscript-comment">/* Readjust currentWord and wordsLeft. */</span>
			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
		<span class="enscript-keyword">if</span> (*currentWord != 0) {
			<span class="enscript-keyword">if</span> (stop_on_first) {
				blockCount = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
			} 
			blockCount += num_bits_set(*currentWord);
		}
		numBlocks -= kBitsPerWord;
		++currentWord;
		--wordsLeft;
	}

	<span class="enscript-comment">/*
	 * Test any remaining blocks.
	 */</span>
	<span class="enscript-keyword">if</span> (numBlocks != 0) {
		bitMask = ~(kAllBitsSetInWord &gt;&gt; numBlocks);
		<span class="enscript-keyword">if</span> (wordsLeft == 0) {
			<span class="enscript-comment">/* Read in the next bitmap block */</span>
			startingBlock += bitsPerBlock;

			buffer = NULL;
			error = ReleaseBitmapBlock(hfsmp, blockRef, false);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			error = ReadBitmapBlock(hfsmp, startingBlock, &amp;buffer, &amp;blockRef, 
									HFS_ALLOC_IGNORE_TENTATIVE);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;

			currentWord = buffer;
			wordsLeft = wordsPerBlock;
		}
		<span class="enscript-keyword">if</span> ((*currentWord &amp; SWAP_BE32 (bitMask)) != 0) {
			<span class="enscript-keyword">if</span> (stop_on_first) {
				blockCount = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
			}
			blockCount += num_bits_set(*currentWord &amp; SWAP_BE32 (bitMask));
		}
	}
<span class="enscript-reference">Exit</span>:
	<span class="enscript-keyword">if</span> (buffer) {
		(<span class="enscript-type">void</span>)ReleaseBitmapBlock(hfsmp, blockRef, false);
	}
	<span class="enscript-keyword">if</span> (allocCount) {
		*allocCount = blockCount;
	}

<span class="enscript-reference">JustReturn</span>:
	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_BITMAP_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_IS_ALLOCATED | DBG_FUNC_END, error, 0, blockCount, 0, 0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* 
 * Count total number of blocks that are allocated in the given 
 * range from the bitmap.  This is used to preflight total blocks 
 * that need to be relocated during volume resize.  
 *
 * The journal or allocation file lock must be held.
 *
 * Returns:
 * 	0 on success, non-zero on failure.  
 * 	On failure, allocCount is zero. 
 */</span>
	<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_count_allocated</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock,
		u_int32_t numBlocks, u_int32_t *allocCount)
{
	<span class="enscript-keyword">return</span> hfs_isallocated_internal(hfsmp, startBlock, numBlocks, false, allocCount);
}

<span class="enscript-comment">/*
 * Test to see if any blocks in a range are allocated.
 * 
 * Note:  On error, this function returns 1, which means that 
 * one or more blocks in the range are allocated.  This function 
 * is primarily used for volume resize and we do not want 
 * to report to the caller that the blocks are free when we 
 * were not able to deterministically find it out.  So on error, 
 * we always report that the blocks are allocated.  
 *
 * The journal or allocation file lock must be held.
 *
 * Returns 
 *	0 if all blocks in the range are free.
 *	1 if blocks in the range are allocated, or there was an error.
 */</span>
	<span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_isallocated</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, u_int32_t numBlocks)
{
	<span class="enscript-type">int</span> error; 
	u_int32_t allocCount;

	error = hfs_isallocated_internal(hfsmp, startingBlock, numBlocks, true, &amp;allocCount);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* On error, we always say that the blocks are allocated 
		 * so that volume resize does not return false success.
		 */</span>
		<span class="enscript-keyword">return</span> 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* The function was deterministically able to find out 
		 * if there was any block allocated or not.  In that case,
		 * the value in allocCount is good enough to be returned 
		 * back to the caller.
		 */</span>
		<span class="enscript-keyword">return</span> allocCount;
	}
} 

<span class="enscript-comment">/*
 * CONFIG_HFS_RBTREE
 * Check to see if the red-black tree is live.  Allocation file lock must be held
 * shared or exclusive to call this function. Note that we may call this even if
 * HFS is built without activating the red-black tree code.
 */</span>
__private_extern__
<span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_isrbtree_active</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp){

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">hfsmp</span>)

	<span class="enscript-comment">/* Just return 0 for now */</span>
	<span class="enscript-keyword">return</span> 0;
}



<span class="enscript-comment">/* Summary Table Functions */</span>
<span class="enscript-comment">/*
 * hfs_check_summary:
 * 
 * This function should be used to query the summary table to see if we can
 * bypass a bitmap block or not when we're trying to find a free allocation block.
 *
 *
 * Inputs:
 * 		allocblock - allocation block number. Will be used to infer the correct summary bit.
 * 		hfsmp -- filesystem in question.
 * 
 * Output Arg:
 *		*freeblocks - set to 1 if we believe at least one free blocks in this vcbVBMIOSize
 * 		page of bitmap file.
 * 
 *
 * Returns:
 * 		0 on success
 *		EINVAL on error
 * 	
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_check_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t allocblock, uint32_t *freeblocks) {

	<span class="enscript-type">int</span> err = EINVAL;
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbVBMIOSize) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
			uint32_t index;
			<span class="enscript-keyword">if</span> (hfs_get_summary_index (hfsmp, allocblock, &amp;index)) {
				*freeblocks = 0;
				<span class="enscript-keyword">return</span> EINVAL;
			}

			<span class="enscript-comment">/* Ok, now that we have the bit index into the array, what byte is it in ? */</span>
			uint32_t byteindex = index / kBitsPerByte;
			uint8_t current_byte = hfsmp-&gt;hfs_summary_table[byteindex];
			uint8_t bit_in_byte = index % kBitsPerByte;

			<span class="enscript-keyword">if</span> (current_byte &amp; (1 &lt;&lt; bit_in_byte)) {
				<span class="enscript-comment">/* 
				 * We do not believe there is anything free in the
				 * entire vcbVBMIOSize'd block.
				 */</span>
				*freeblocks = 0;
			}	
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Looks like there might be a free block here... */</span>
				*freeblocks = 1;
			}
		}
		err = 0;
	}

	<span class="enscript-keyword">return</span> err;
}


#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * hfs_get_next_summary
 *
 * From a given allocation block, jump to the allocation block at the start of the
 * next vcbVBMIOSize boundary.  This is useful when trying to quickly skip over
 * large swaths of bitmap once we have determined that the bitmap is relatively full. 
 *
 * Inputs: hfsmount, starting allocation block number
 * Output Arg: *newblock will contain the allocation block number to start
 * querying.
 * 
 * Returns:
 *		0 on success
 * 		EINVAL if the block argument is too large to be used, or the summary table not live.
 * 		EFBIG if there are no more summary bits to be queried
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_get_next_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block, uint32_t *newblock) {

	u_int32_t bits_per_iosize = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;
	u_int32_t start_offset;
	u_int32_t next_offset;
	<span class="enscript-type">int</span> err = EINVAL; 

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-keyword">if</span> ((err = hfs_get_summary_index(hfsmp, block, &amp;start_offset))) {
			<span class="enscript-keyword">return</span> err;
		}

		next_offset = start_offset++;	

		<span class="enscript-keyword">if</span> ((start_offset &gt;= hfsmp-&gt;hfs_summary_size) || (next_offset &gt;= hfsmp-&gt;hfs_summary_size)) {
			<span class="enscript-comment">/* Can't jump to the next summary bit. */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/* Otherwise, compute and return */</span>
		*newblock = next_offset * bits_per_iosize;
		<span class="enscript-keyword">if</span> (*newblock &gt;= hfsmp-&gt;totalBlocks) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		err = 0;
	}

	<span class="enscript-keyword">return</span> err;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * hfs_release_summary 
 * 
 * Given an extent that is about to be de-allocated on-disk, determine the number
 * of summary bitmap bits that need to be marked as 'potentially available'.
 * Then go ahead and mark them as free.
 *
 *	Inputs:
 * 		hfsmp 		- hfs mount
 * 		block 		- starting allocation block.
 * 		length		- length of the extent.
 * 
 * 	Returns:
 *		EINVAL upon any errors.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_release_summary</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t start_blk, uint32_t length) {
	<span class="enscript-type">int</span> err = EINVAL;
	uint32_t end_blk = (start_blk + length) - 1;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-comment">/* Figure out what the starting / ending block's summary bits are */</span>
		uint32_t start_bit;
		uint32_t end_bit;
		uint32_t current_bit;

		err = hfs_get_summary_index (hfsmp, start_blk, &amp;start_bit);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release_err</span>;
		}
		err = hfs_get_summary_index (hfsmp, end_blk, &amp;end_bit);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release_err</span>;
		}

		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			<span class="enscript-keyword">if</span> (start_bit &gt; end_bit) {
				panic (<span class="enscript-string">&quot;HFS: start &gt; end!, %d %d &quot;</span>, start_bit, end_bit);
			}
		}
		current_bit = start_bit;
		<span class="enscript-keyword">while</span> (current_bit &lt;= end_bit) {
			err = hfs_set_summary (hfsmp, current_bit, 0); 
			current_bit++;
		}
	}

<span class="enscript-reference">release_err</span>:
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/*
 * hfs_find_summary_free
 * 
 * Given a allocation block as input, returns an allocation block number as output as a 
 * suggestion for where to start scanning the bitmap in order to find free blocks.  It will
 * determine the vcbVBMIOsize of the input allocation block, convert that into a summary
 * bit, then keep iterating over the summary bits in order to find the first free one.
 * 
 * Inputs:
 *		hfsmp 		- hfs mount
 * 		block		- starting allocation block
 * 		newblock 	- output block as suggestion
 * 
 * Returns:
 * 		0 on success
 * 		ENOSPC if we could not find a free block 
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_find_summary_free</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block,  uint32_t *newblock) {

	<span class="enscript-type">int</span> err = ENOSPC;
	uint32_t bit_index = 0;
	uint32_t maybe_has_blocks = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		uint32_t byte_index;
		uint8_t curbyte;
		uint8_t bit_in_byte;
		uint32_t summary_cap;

		<span class="enscript-comment">/* 
		 * We generate a cap for the summary search because the summary table
		 * always represents a full summary of the bitmap FILE, which may
		 * be way more bits than are necessary for the actual filesystem 
		 * whose allocations are mapped by the bitmap.
		 * 
		 * Compute how much of hfs_summary_size is useable for the given number
		 * of allocation blocks eligible on this FS.
		 */</span>
		err = hfs_get_summary_index (hfsmp, hfsmp-&gt;allocLimit - 1, &amp;summary_cap);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">summary_exit</span>;
		}

		<span class="enscript-comment">/* Check the starting block first */</span>
		err = hfs_check_summary (hfsmp, block, &amp;maybe_has_blocks);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">summary_exit</span>;
		}

		<span class="enscript-keyword">if</span> (maybe_has_blocks) {
			<span class="enscript-comment">/* 
			 * It looks like the initial start block could have something.  
			 * Short-circuit and just use that.
			 */</span>
			*newblock = block;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">summary_exit</span>;
		}

		<span class="enscript-comment">/*
		 * OK, now we know that the first block was useless.  
		 * Get the starting summary bit, and find it in the array 
		 */</span>
		maybe_has_blocks = 0;
		err = hfs_get_summary_index (hfsmp, block, &amp;bit_index);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">summary_exit</span>;
		}

		<span class="enscript-comment">/* Iterate until we find something. */</span>
		<span class="enscript-keyword">while</span> (bit_index &lt;= summary_cap) {
			byte_index = bit_index / kBitsPerByte;
			curbyte = hfsmp-&gt;hfs_summary_table[byte_index];
			bit_in_byte = bit_index % kBitsPerByte;

			<span class="enscript-keyword">if</span> (curbyte &amp; (1 &lt;&lt; bit_in_byte)) {
				<span class="enscript-comment">/* nothing here.  increment and move on */</span>
				bit_index++;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * found something! convert bit_index back into 
				 * an allocation block for use. 'newblock' will now
				 * contain the proper allocation block # based on the bit
				 * index.
				 */</span>
				err = hfs_get_summary_allocblock (hfsmp, bit_index, newblock);	
				<span class="enscript-keyword">if</span> (err) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">summary_exit</span>;
				}
				maybe_has_blocks = 1;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">/* If our loop didn't find anything, set err to ENOSPC */</span>
		<span class="enscript-keyword">if</span> (maybe_has_blocks == 0) {
			err = ENOSPC;
		}
	}

	<span class="enscript-comment">/* If the summary table is not active for this mount, we'll just return ENOSPC */</span>
<span class="enscript-reference">summary_exit</span>:
	<span class="enscript-keyword">if</span> (maybe_has_blocks) {
		err = 0;
	}

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/*
 * hfs_get_summary_allocblock
 * 
 * Convert a summary bit into an allocation block number to use to start searching for free blocks.
 * 
 * Inputs:
 *		hfsmp 			- hfs mount
 * 		summarybit 		- summmary bit index 
 *		*alloc			- allocation block number in the bitmap file.
 *
 * Output:
 *		0 on success
 * 		EINVAL on failure
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_get_summary_allocblock</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t
		summarybit, uint32_t *alloc) {
	uint32_t bits_per_iosize = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;
	uint32_t allocblk;

	allocblk = summarybit * bits_per_iosize;

	<span class="enscript-keyword">if</span> (allocblk &gt;= hfsmp-&gt;totalBlocks) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">else</span> {
		*alloc = allocblk;
	}

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * hfs_set_summary:
 * 
 * This function should be used to manipulate the summary table 
 *
 * The argument 'inuse' will set the value of the bit in question to one or zero
 * depending on its value.
 *
 * Inputs:
 * 		hfsmp 		- hfs mount
 *		summarybit	- the bit index into the summary table to set/unset.
 * 		inuse		- the value to assign to the bit.
 *
 * Returns:
 * 		0 on success
 *		EINVAL on error
 * 	
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_set_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t summarybit, uint32_t inuse) {

	<span class="enscript-type">int</span> err = EINVAL;
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbVBMIOSize) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {	

			<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table == NULL) {
					panic (<span class="enscript-string">&quot;hfs_set_summary: no table for %p &quot;</span>, hfsmp);
				}
			}

			<span class="enscript-comment">/* Ok, now that we have the bit index into the array, what byte is it in ? */</span>
			uint32_t byte_index = summarybit / kBitsPerByte;
			uint8_t current_byte = hfsmp-&gt;hfs_summary_table[byte_index];
			uint8_t bit_in_byte = summarybit % kBitsPerByte;

			<span class="enscript-keyword">if</span> (inuse) {
				current_byte = (current_byte | (1 &lt;&lt; bit_in_byte));
			}
			<span class="enscript-keyword">else</span> {
				current_byte = (current_byte &amp; ~(1 &lt;&lt; bit_in_byte));
			}

			hfsmp-&gt;hfs_summary_table[byte_index] = current_byte;
		}
		err = 0;
	}

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * hfs_get_summary_index:
 *
 * This is a helper function which determines what summary bit represents the vcbVBMIOSize worth
 * of IO against the bitmap file.
 * 
 * Returns:
 *		0 on success
 * 		EINVAL on failure
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_get_summary_index</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t block, uint32_t* index) {
	uint32_t summary_bit;
	uint32_t bits_per_iosize;
	<span class="enscript-type">int</span> err = EINVAL;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-comment">/* Is the input block bigger than the total number of blocks? */</span>
		<span class="enscript-keyword">if</span> (block &gt;= hfsmp-&gt;totalBlocks) {
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/* Is there even a vbmIOSize set? */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbVBMIOSize == 0) {
			<span class="enscript-keyword">return</span> EINVAL;
		}

		bits_per_iosize = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;

		summary_bit = block / bits_per_iosize;

		*index = summary_bit;
		err = 0;
	}

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/*
 * hfs_init_summary
 * 
 * From a given mount structure, compute how big the summary table should be for the given
 * filesystem, then allocate and bzero the memory.
 *
 * Returns:
 * 0 on success
 * EINVAL on failure
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_init_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {

	uint32_t summary_size;	
	uint32_t summary_size_bytes;
	uint8_t *summary_table;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_cp == NULL) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs: summary table cannot progress without a bitmap cnode! \n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-comment">/* 
	 * The practical maximum size of the summary table is 16KB:  
	 *
	 *		(512MB maximum bitmap size / (4k -- min alloc block size)) / 8 bits/byte.
	 * 
	 * HFS+ will allow filesystems with allocation block sizes smaller than 4k, but
	 * the end result is that we'll start to issue I/O in 2k or 1k sized chunks, which makes
	 * supporting this much worse.  The math would instead look like this:
	 * (512MB / 2k) / 8 == 32k. 
	 * 
	 * So, we will disallow the summary table if the allocation block size is &lt; 4k.
	 */</span>

	<span class="enscript-keyword">if</span> (hfsmp-&gt;blockSize &lt; HFS_MIN_SUMMARY_BLOCKSIZE) {
		printf(<span class="enscript-string">&quot;hfs: summary table not allowed on FS with block size of %d\n&quot;</span>, hfsmp-&gt;blockSize);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	summary_size = hfsmp-&gt;hfs_allocation_cp-&gt;c_blocks;

	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		printf(<span class="enscript-string">&quot;HFS Summary Table Initialization: Bitmap %u blocks\n&quot;</span>, 
				hfsmp-&gt;hfs_allocation_cp-&gt;c_blocks);
	}

	<span class="enscript-comment">/*
	 * If the bitmap IO size is not the same as the allocation block size then
	 * then re-compute the number of summary bits necessary.  Note that above, the 
	 * the default size is the number of allocation blocks in the bitmap *FILE* 
	 * (not the number of bits in the bitmap itself).  If the allocation block size
	 * is large enough though, we may need to increase this. 
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;blockSize != hfsmp-&gt;vcbVBMIOSize) {
		uint64_t lrg_size = (uint64_t) hfsmp-&gt;hfs_allocation_cp-&gt;c_blocks * (uint64_t) hfsmp-&gt;blockSize;
		lrg_size = lrg_size / (uint64_t)hfsmp-&gt;vcbVBMIOSize;

		<span class="enscript-comment">/* With a full bitmap and 64k-capped iosize chunks, this would be 64k */</span>
		summary_size = (uint32_t) lrg_size;
	}

	<span class="enscript-comment">/* 
	 * If the block size is the same as the IO Size, then the total number of blocks
	 * is already equal to the number of IO units, which is our number of summary bits.
	 */</span>

	summary_size_bytes = summary_size / kBitsPerByte;
	<span class="enscript-comment">/* Always add one byte, just in case we have a dangling number of bits */</span>
	summary_size_bytes++;

	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		printf(<span class="enscript-string">&quot;HFS Summary Table: vcbVBMIOSize %d summary bits %d \n&quot;</span>, hfsmp-&gt;vcbVBMIOSize, summary_size); 
		printf(<span class="enscript-string">&quot;HFS Summary Table Size (in bytes) %d \n&quot;</span>, summary_size_bytes); 
	}

	<span class="enscript-comment">/* Store the field in the mount point, and then MALLOC/bzero the memory */</span>
	hfsmp-&gt;hfs_summary_size = summary_size;
	hfsmp-&gt;hfs_summary_bytes = summary_size_bytes;

	MALLOC (summary_table, uint8_t*, summary_size_bytes, M_TEMP, M_WAITOK);	
	<span class="enscript-keyword">if</span> (summary_table == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero (summary_table, summary_size_bytes);

	<span class="enscript-comment">/* enable the summary table */</span>
	hfsmp-&gt;hfs_flags |= HFS_SUMMARY_TABLE;
	hfsmp-&gt;hfs_summary_table = summary_table;

	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table == NULL) {
			panic (<span class="enscript-string">&quot;HFS Summary Init: no table for %p\n&quot;</span>, hfsmp);
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * hfs_rebuild_summary
 *
 * This function should be used to allocate a new hunk of memory for use as a summary
 * table, then copy the existing data into it.  We use it whenever the filesystem's size
 * changes.  When a resize is in progress, you can still use the extant summary
 * table if it is active.
 * 
 * Inputs:
 * 		hfsmp 		-- FS in question
 * 		newlength	-- new length of the FS in allocation blocks.
 *
 * Outputs: 
 *		0 on success, EINVAL on failure.  If this function fails,  the summary table
 * 		will be disabled for future use.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_rebuild_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {

	uint32_t new_summary_size;

	new_summary_size = hfsmp-&gt;hfs_allocation_cp-&gt;c_blocks;


	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		printf(<span class="enscript-string">&quot;HFS Summary Table Re-init: bitmap %u blocks\n&quot;</span>, new_summary_size);
	}

	<span class="enscript-comment">/* 
	 * If the bitmap IO size is not the same as the allocation block size, then re-compute
	 * the number of summary bits necessary.  Note that above, the default size is the number
	 * of allocation blocks in the bitmap *FILE* (not the number of bits that the bitmap manages).
	 * If the allocation block size is large enough though, we may need to increase this, as 
	 * bitmap IO is capped at 64k per IO
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;blockSize != hfsmp-&gt;vcbVBMIOSize) {
		uint64_t lrg_size = (uint64_t) hfsmp-&gt;hfs_allocation_cp-&gt;c_blocks * (uint64_t) hfsmp-&gt;blockSize;
		lrg_size = lrg_size / (uint64_t)hfsmp-&gt;vcbVBMIOSize;

		<span class="enscript-comment">/* With a full bitmap and 64k-capped iosize chunks, this would be 64k */</span>
		new_summary_size = (uint32_t) lrg_size;
	}

	<span class="enscript-comment">/* 
	 * Ok, we have the new summary bitmap theoretical max size.  See if it's the same as 
	 * what we've got already...
	 */</span>
	<span class="enscript-keyword">if</span> (new_summary_size != hfsmp-&gt;hfs_summary_size) {
		uint32_t summarybytes = new_summary_size / kBitsPerByte;
		uint32_t copysize;
		uint8_t *newtable;
		<span class="enscript-comment">/* Add one byte for slop */</span>
		summarybytes++;

		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			printf(<span class="enscript-string">&quot;HFS Summary Table: vcbVBMIOSize %d summary bits %d \n&quot;</span>, hfsmp-&gt;vcbVBMIOSize, new_summary_size);
			printf(<span class="enscript-string">&quot;HFS Summary Table Size (in bytes) %d \n&quot;</span>, summarybytes);
		}

		<span class="enscript-comment">/* Attempt to MALLOC the memory */</span>
		MALLOC (newtable, uint8_t*, summarybytes, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (newtable == NULL) {
			<span class="enscript-comment">/* 
			 * ERROR!  We need to disable the table now 
			 */</span>
			FREE (hfsmp-&gt;hfs_summary_table, M_TEMP);
			hfsmp-&gt;hfs_summary_table = NULL;
			hfsmp-&gt;hfs_flags &amp;= ~HFS_SUMMARY_TABLE;	
			<span class="enscript-keyword">return</span> EINVAL;
		}
		bzero (newtable, summarybytes);

		<span class="enscript-comment">/* 
		 * The new table may be smaller than the old one. If this is true, then
		 * we can't copy the full size of the existing summary table into the new
		 * one. 
		 * 
		 * The converse is not an issue since we bzeroed the table above. 
		 */</span> 
		copysize = hfsmp-&gt;hfs_summary_bytes;
		<span class="enscript-keyword">if</span> (summarybytes &lt; hfsmp-&gt;hfs_summary_bytes) {	
			copysize = summarybytes;
		}
		memcpy (newtable, hfsmp-&gt;hfs_summary_table, copysize); 

		<span class="enscript-comment">/* We're all good.  Destroy the old copy and update ptrs */</span>
		FREE (hfsmp-&gt;hfs_summary_table, M_TEMP);

		hfsmp-&gt;hfs_summary_table = newtable;
		hfsmp-&gt;hfs_summary_size = new_summary_size;	
		hfsmp-&gt;hfs_summary_bytes = summarybytes;
	}

	<span class="enscript-keyword">return</span> 0;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ALLOC_DEBUG</span>
<span class="enscript-comment">/* 
 * hfs_validate_summary
 * 
 * Validation routine for the summary table.  Debug-only function.
 * 
 * Bitmap lock must be held.
 *
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_validate_summary</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	uint32_t i;
	<span class="enscript-type">int</span> err;

	<span class="enscript-comment">/* 
	 * Iterate over all of the bits in the summary table, and verify if 
	 * there really are free blocks in the pages that we believe may
	 * may contain free blocks.
	 */</span>

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table == NULL) {
		panic (<span class="enscript-string">&quot;HFS Summary: No HFS summary table!&quot;</span>);
	}	

	<span class="enscript-comment">/* 131072 bits == 16384 bytes.  This is the theoretical max size of the summary table. we add 1 byte for slop */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_size == 0 || hfsmp-&gt;hfs_summary_size &gt; 131080) {
		panic(<span class="enscript-string">&quot;HFS Summary: Size is bad! %d&quot;</span>, hfsmp-&gt;hfs_summary_size);
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbVBMIOSize == 0) {
		panic(<span class="enscript-string">&quot;HFS Summary: no VCB VBM IO Size !&quot;</span>);
	}

	printf(<span class="enscript-string">&quot;hfs: summary validation beginning on %s\n&quot;</span>, hfsmp-&gt;vcbVN);
	printf(<span class="enscript-string">&quot;hfs: summary validation %d summary bits, %d summary blocks\n&quot;</span>, hfsmp-&gt;hfs_summary_size, hfsmp-&gt;totalBlocks);


	<span class="enscript-comment">/* iterate through all possible summary bits */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; hfsmp-&gt;hfs_summary_size ; i++) {

		uint32_t bits_per_iosize = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;
		uint32_t byte_offset = hfsmp-&gt;vcbVBMIOSize * i;

		<span class="enscript-comment">/* Compute the corresponding allocation block for the summary bit. */</span>
		uint32_t alloc_block = i * bits_per_iosize;

		<span class="enscript-comment">/* 
		 * We use a uint32_t pointer here because it will speed up 
		 * access to the real bitmap data on disk. 
		 */</span>
		uint32_t *block_data;
		<span class="enscript-type">struct</span> buf *bp;
		<span class="enscript-type">int</span> counter;
		<span class="enscript-type">int</span> counter_max;
		<span class="enscript-type">int</span> saw_free_bits = 0;

		<span class="enscript-comment">/* Get the block */</span>
		<span class="enscript-keyword">if</span> ((err = ReadBitmapRange (hfsmp, byte_offset, hfsmp-&gt;vcbVBMIOSize, &amp;block_data,  &amp;bp))) {
			panic (<span class="enscript-string">&quot;HFS Summary: error (%d) in ReadBitmapRange!&quot;</span>, err);
		}

		<span class="enscript-comment">/* Query the status of the bit and then make sure we match */</span>
		uint32_t maybe_has_free_blocks;
		err = hfs_check_summary (hfsmp, alloc_block, &amp;maybe_has_free_blocks);
		<span class="enscript-keyword">if</span> (err) {
			panic (<span class="enscript-string">&quot;HFS Summary: hfs_check_summary returned error (%d) &quot;</span>, err);
		}
		counter_max = hfsmp-&gt;vcbVBMIOSize / kBytesPerWord;

		<span class="enscript-keyword">for</span> (counter = 0; counter &lt; counter_max; counter++) {
			uint32_t word = block_data[counter];

			<span class="enscript-comment">/* We assume that we'll not find any free bits here. */</span>
			<span class="enscript-keyword">if</span> (word != kAllBitsSetInWord) {
				<span class="enscript-keyword">if</span> (maybe_has_free_blocks) {
					<span class="enscript-comment">/* All done */</span>
					saw_free_bits = 1;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">else</span> {
					panic (<span class="enscript-string">&quot;HFS Summary: hfs_check_summary saw free bits!&quot;</span>);
				}
			}
		}

		<span class="enscript-keyword">if</span> (maybe_has_free_blocks &amp;&amp; (saw_free_bits == 0)) {
			panic (<span class="enscript-string">&quot;HFS Summary: did not see free bits !&quot;</span>);	
		}

		<span class="enscript-comment">/* Release the block. */</span>
		<span class="enscript-keyword">if</span> ((err =  ReleaseScanBitmapRange (bp))) {
			panic (<span class="enscript-string">&quot;HFS Summary: Error (%d) in ReleaseScanBitmapRange&quot;</span>, err);
		}
	}

	printf(<span class="enscript-string">&quot;hfs: summary validation completed successfully on %s\n&quot;</span>, hfsmp-&gt;vcbVN);

	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * hfs_alloc_scan_range:
 *
 * This function should be used to scan large ranges of the allocation bitmap
 * at one time.  It makes two key assumptions:
 * 
 * 		1) Bitmap lock is held during the duration of the call (exclusive)
 * 		2) There are no pages in the buffer cache for any of the bitmap 
 * 		blocks that we may encounter.  It *MUST* be completely empty.
 * 
 * The expected use case is when we are scanning the bitmap in full while we are 
 * still mounting the filesystem in order to issue TRIMs or build up the summary 
 * table for the mount point. It should be done after any potential journal replays
 * are completed and their I/Os fully issued.
 * 
 * The key reason for assumption (2) above is that this function will try to issue 
 * I/O against the bitmap file in chunks as large a possible -- essentially as 
 * much as the buffer layer will handle (1MB).  Because the size of these I/Os 
 * is larger than what would be expected during normal runtime we must invalidate 
 * the buffers as soon as we are done with them so that they do not persist in 
 * the buffer cache for other threads to find, as they'll typically be doing 
 * allocation-block size I/Os instead.
 * 
 * Input Args:
 *		hfsmp 		- hfs mount data structure
 * 		startbit 	- allocation block # to start our scan. It must be aligned
 *					on a vcbVBMIOsize boundary.
 *		list		- journal trim list data structure for issuing TRIMs
 *
 * Output Args:
 *		bitToScan 	- Return the next bit to scan if this function is called again. 
 *					Caller will supply this into the next invocation
 *					of this call as 'startbit'. 	
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_alloc_scan_range</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startbit, 
		u_int32_t *bitToScan, <span class="enscript-type">struct</span> jnl_trim_list *list) {

	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> readwrite = 1;
	u_int32_t curAllocBlock;
	<span class="enscript-type">struct</span> buf *blockRef = NULL;
	u_int32_t *buffer = NULL;
	u_int32_t free_offset = 0; <span class="enscript-comment">//tracks the start of the current free range
</span>	u_int32_t size = 0; <span class="enscript-comment">// tracks the length of the current free range.
</span>	u_int32_t iosize = 0; <span class="enscript-comment">//how much io we should generate against the bitmap
</span>	u_int32_t byte_off; <span class="enscript-comment">// byte offset into the bitmap file.
</span>	u_int32_t completed_size; <span class="enscript-comment">// how much io was actually completed
</span>	u_int32_t last_bitmap_block;
	u_int32_t current_word;	
	u_int32_t word_index = 0;	

	<span class="enscript-comment">/* summary table building */</span>
	uint32_t summary_bit = 0;
	uint32_t saw_free_blocks = 0;
	uint32_t last_marked = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		readwrite = 0;
	}

	<span class="enscript-comment">/* 
	 * Compute how much I/O we should generate here.
	 * hfs_scan_range_size will validate that the start bit 
	 * converted into a byte offset into the bitmap file,
	 * is aligned on a VBMIOSize boundary. 
	 */</span>
	error = hfs_scan_range_size (hfsmp, startbit, &amp;iosize);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: hfs_scan_range_size error %d\n&quot;</span>, error);
		}
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">if</span> (iosize &lt; hfsmp-&gt;vcbVBMIOSize) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: iosize too small! (iosize %d)\n&quot;</span>, iosize);
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* hfs_scan_range_size should have verified startbit.  Convert it to bytes */</span>
	byte_off = startbit / kBitsPerByte;

	<span class="enscript-comment">/*
	 * When the journal replays blocks, it does so by writing directly to the disk
	 * device (bypassing any filesystem vnodes and such).  When it finishes its I/Os
	 * it also immediately re-reads and invalidates the range covered by the bp so
	 * it does not leave anything lingering in the cache (for iosize reasons).  
	 * 
	 * As such, it is safe to do large I/Os here with ReadBitmapRange. 
	 *
	 * NOTE: It is not recommended, but it is possible to call the function below
	 * on sections of the bitmap that may be in core already as long as the pages are not
	 * dirty.  In that case, we'd notice that something starting at that
	 * logical block of the bitmap exists in the metadata cache, and we'd check 
	 * if the iosize requested is the same as what was already allocated for it.  
	 * Odds are pretty good we're going to request something larger.  In that case, 
	 * we just free the existing memory associated with the buf and reallocate a 
	 * larger range. This function should immediately invalidate it as soon as we're 
	 * done scanning, so this shouldn't cause any coherency issues.
	 */</span>

	error = ReadBitmapRange(hfsmp, byte_off, iosize, &amp;buffer, &amp;blockRef);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: start %d iosize %d ReadBitmapRange error %d\n&quot;</span>, startbit, iosize, error);
		}
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* 
	 * At this point, we have a giant wired buffer that represents some portion of
	 * the bitmap file that we want to analyze.   We may not have gotten all 'iosize'
	 * bytes though, so clip our ending bit to what we actually read in.
	 */</span>
	completed_size = buf_count(blockRef);
	last_bitmap_block = completed_size * kBitsPerByte;
	last_bitmap_block = last_bitmap_block + startbit;

	<span class="enscript-comment">/* Cap the last block to the total number of blocks if required */</span>
	<span class="enscript-keyword">if</span> (last_bitmap_block &gt; hfsmp-&gt;totalBlocks) {
		last_bitmap_block = hfsmp-&gt;totalBlocks;
	}	

	<span class="enscript-comment">/* curAllocBlock represents the logical block we're analyzing. */</span>
	curAllocBlock = startbit;	
	word_index = 0;
	size = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-keyword">if</span> (hfs_get_summary_index (hfsmp, startbit, &amp;summary_bit)) {
			error = EINVAL;
			<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
				panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: Could not acquire summary index for %u&quot;</span>, startbit);
			}
			<span class="enscript-keyword">return</span> error;
		}
		<span class="enscript-comment">/* 
		 * summary_bit should now be set to the summary bit corresponding to
		 * the allocation block of the first bit that we're supposed to scan
		 */</span> 
	}
	saw_free_blocks = 0;

	<span class="enscript-keyword">while</span> (curAllocBlock &lt; last_bitmap_block) {
		u_int32_t bit;

		<span class="enscript-comment">/* Update the summary table as needed */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
			<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table == NULL) {
					panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: no summary table!&quot;</span>);
				}
			}	

			uint32_t temp_summary;
			error = hfs_get_summary_index (hfsmp, curAllocBlock, &amp;temp_summary);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
					panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: could not get summary index for %u&quot;</span>, curAllocBlock);
				}
				<span class="enscript-keyword">return</span> EINVAL;
			}

			<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
				<span class="enscript-keyword">if</span> (temp_summary &lt; summary_bit) {
					panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: backwards summary bit?\n&quot;</span>);
				}
			}

			<span class="enscript-comment">/* 
			 * If temp_summary is greater than summary_bit, then this
			 * means that the next allocation block crosses a vcbVBMIOSize boundary
			 * and we should treat this range of on-disk data as part of a new summary
			 * bit.
			 */</span> 
			<span class="enscript-keyword">if</span> (temp_summary &gt; summary_bit) {
				<span class="enscript-keyword">if</span> (saw_free_blocks == 0) {
					<span class="enscript-comment">/* Mark the bit as totally consumed in the summary table */</span>
					hfs_set_summary (hfsmp, summary_bit, 1);
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* Mark the bit as potentially free in summary table */</span>
					hfs_set_summary (hfsmp, summary_bit, 0);
				}
				last_marked = summary_bit;
				<span class="enscript-comment">/* 
				 * Any time we set the summary table, update our counter which tracks
				 * what the last bit that was fully marked in the summary table. 
				 *  
				 * Then reset our marker which says we haven't seen a free bit yet.
				 */</span>
				saw_free_blocks = 0;
				summary_bit = temp_summary;
			}
		} <span class="enscript-comment">/* End summary table conditions */</span>

		current_word = SWAP_BE32(buffer[word_index]);
		<span class="enscript-comment">/* Iterate through the word 1 bit at a time... */</span>
		<span class="enscript-keyword">for</span> (bit = 0 ; bit &lt; kBitsPerWord ; bit++, curAllocBlock++) {
			<span class="enscript-keyword">if</span> (curAllocBlock &gt;= last_bitmap_block) {
				<span class="enscript-keyword">break</span>;
			}
			u_int32_t allocated = (current_word &amp; (kHighBitInWordMask &gt;&gt; bit));

			<span class="enscript-keyword">if</span> (allocated) { 
				<span class="enscript-keyword">if</span> (size != 0) {
					<span class="enscript-keyword">if</span> (readwrite) {
						<span class="enscript-comment">/* Insert the previously tracked range of free blocks to the trim list */</span>
						hfs_track_unmap_blocks (hfsmp, free_offset, size, list);
					}
					add_free_extent_cache (hfsmp, free_offset, size);
					size = 0;
					free_offset = 0;
				}
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Not allocated */</span>
				size++;
				<span class="enscript-keyword">if</span> (free_offset == 0) {
					<span class="enscript-comment">/* Start a new run of free spcae at curAllocBlock */</span>
					free_offset = curAllocBlock;
				}
				<span class="enscript-keyword">if</span> (saw_free_blocks == 0) {
					saw_free_blocks = 1;
				}
			}
		} <span class="enscript-comment">/* end for loop iterating through the word */</span>

		<span class="enscript-keyword">if</span> (curAllocBlock &lt; last_bitmap_block) {
			word_index++;
		}

	} <span class="enscript-comment">/* End while loop (iterates through last_bitmap_block) */</span>


	<span class="enscript-comment">/* 
	 * We've (potentially) completed our pass through this region of bitmap, 
	 * but one thing we may not have done is updated that last summary bit for 
	 * the last page we scanned, because we would have never transitioned across 
	 * a vcbVBMIOSize boundary again.  Check for that and update the last bit
	 * as needed.
	 * 
	 * Note that 'last_bitmap_block' is *not* inclusive WRT the very last bit in the bitmap
	 * for the region of bitmap on-disk that we were scanning. (it is one greater).
	 */</span>
	<span class="enscript-keyword">if</span> ((curAllocBlock &gt;= last_bitmap_block) &amp;&amp; 
			(hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE)) { 
		uint32_t temp_summary;
		<span class="enscript-comment">/* temp_block should be INSIDE the region we just scanned, so subtract 1 */</span>
		uint32_t temp_block = last_bitmap_block - 1;
		error = hfs_get_summary_index (hfsmp, temp_block, &amp;temp_summary);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
				panic (<span class="enscript-string">&quot;hfs_alloc_scan_range: end bit curAllocBlock %u, last_bitmap_block %u&quot;</span>, curAllocBlock, last_bitmap_block);
			}
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/* Did we already update this in the table? */</span>
		<span class="enscript-keyword">if</span> (temp_summary &gt; last_marked) {
			<span class="enscript-keyword">if</span> (saw_free_blocks == 0) {
				hfs_set_summary (hfsmp, temp_summary, 1);
			}
			<span class="enscript-keyword">else</span> {
				hfs_set_summary (hfsmp, temp_summary, 0);
			}
		}
	}

	<span class="enscript-comment">/* 
	 * We may have been tracking a range of free blocks that hasn't been inserted yet. 
	 * Keep the logic for the TRIM and free extent separate from that of the summary 
	 * table management even though they are closely linked.
	 */</span>
	<span class="enscript-keyword">if</span> (size != 0) {
		<span class="enscript-keyword">if</span> (readwrite) {
			hfs_track_unmap_blocks (hfsmp, free_offset, size, list);
		}
		add_free_extent_cache (hfsmp, free_offset, size);
	}

	<span class="enscript-comment">/* 
	 * curAllocBlock represents the next block we need to scan when we return
	 * to this function. 
	 */</span>
	*bitToScan = curAllocBlock;
	ReleaseScanBitmapRange(blockRef);

	<span class="enscript-keyword">return</span> 0;

}



<span class="enscript-comment">/*
 * Compute the maximum I/O size to generate against the bitmap file
 * Will attempt to generate at LEAST VBMIOsize I/Os for interior ranges of the bitmap. 
 * 
 * Inputs:
 *		hfsmp		-- hfsmount to look at 
 *		bitmap_off 	-- bit offset into the bitmap file
 *	
 * Outputs:
 * 		iosize	-- iosize to generate.
 *
 * Returns:
 *		0 on success; EINVAL otherwise 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_scan_range_size</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t bitmap_st, uint32_t *iosize) {

	<span class="enscript-comment">/* 
	 * The maximum bitmap size is 512MB regardless of ABN size, so we can get away
	 * with 32 bit math in this function.
	 */</span>

	uint32_t bitmap_len;
	uint32_t remaining_bitmap;
	uint32_t target_iosize;
	uint32_t bitmap_off; 

	<span class="enscript-comment">/* Is this bit index not word aligned?  If so, immediately fail. */</span>
	<span class="enscript-keyword">if</span> (bitmap_st % kBitsPerWord) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_scan_range_size unaligned start bit! bitmap_st %d \n&quot;</span>, bitmap_st);
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* bitmap_off is in bytes, not allocation blocks/bits */</span>
	bitmap_off = bitmap_st / kBitsPerByte;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;totalBlocks &lt;= bitmap_st) || (bitmap_off &gt; (512 * 1024 * 1024))) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_scan_range_size: invalid start! bitmap_st %d, bitmap_off %d\n&quot;</span>, bitmap_st, bitmap_off);
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* 
	 * Also invalid if it's not at least aligned to HFS bitmap logical
	 * block boundaries.  We don't have to emit an iosize that's an 
	 * exact multiple of the VBMIOSize, but it must start on such 
	 * a boundary.
	 *
	 * The vcbVBMIOSize may be SMALLER than the allocation block size
	 * on a FS with giant allocation blocks, but it will never be
	 * greater than it, so it should be safe to start I/O
	 * aligned on a VBMIOsize boundary. 
	 */</span>
	<span class="enscript-keyword">if</span> (bitmap_off &amp; (hfsmp-&gt;vcbVBMIOSize - 1)) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
			panic (<span class="enscript-string">&quot;hfs_scan_range_size: unaligned start! bitmap_off %d\n&quot;</span>, bitmap_off);
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* 
	 * Generate the total bitmap file length in bytes, then round up
	 * that value to the end of the last allocation block, if needed (It 
	 * will probably be needed).  We won't scan past the last actual 
	 * allocation block.  
	 *
	 * Unless we're completing the bitmap scan (or bitmap &lt; 1MB), we
	 * have to complete the I/O on VBMIOSize boundaries, but we can only read
	 * up until the end of the bitmap file.
	 */</span>
	bitmap_len = roundup(hfsmp-&gt;totalBlocks, hfsmp-&gt;blockSize * 8) / 8;

	remaining_bitmap = bitmap_len - bitmap_off;

	<span class="enscript-comment">/* 
	 * io size is the MIN of the maximum I/O we can generate or the
	 * remaining amount of bitmap.
	 */</span>
	target_iosize = MIN((MAXBSIZE), remaining_bitmap);
	*iosize = target_iosize;

	<span class="enscript-keyword">return</span> 0;
}




<span class="enscript-comment">/*
 * This function is basically the same as hfs_isallocated, except it's designed for 
 * use with the red-black tree validation code.  It assumes we're only checking whether
 * one bit is active, and that we're going to pass in the buf to use, since GenerateTree
 * calls ReadBitmapBlock and will have that buf locked down for the duration of its operation.
 *
 * This should not be called in general purpose scanning code.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_isallocated_scan</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, u_int32_t *bp_buf) {

	u_int32_t  *currentWord;   <span class="enscript-comment">// Pointer to current word within bitmap block
</span>	u_int32_t  bitMask;        <span class="enscript-comment">// Word with given bits already set (ready to test)
</span>	u_int32_t  firstBit;       <span class="enscript-comment">// Bit index within word of first bit to allocate
</span>	u_int32_t  numBits;        <span class="enscript-comment">// Number of bits in word to allocate
</span>	u_int32_t  bitsPerBlock;
	uintptr_t  blockRef = 0;
	u_int32_t  wordsPerBlock;
	u_int32_t  numBlocks = 1;
	u_int32_t  *buffer = NULL;

	<span class="enscript-type">int</span>  inuse = 0;
	<span class="enscript-type">int</span> error;


	<span class="enscript-keyword">if</span> (bp_buf) {
		<span class="enscript-comment">/* just use passed-in buffer if avail. */</span>
		buffer = bp_buf;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Pre-read the bitmap block containing the first word of allocation
		 */</span>
		error = ReadBitmapBlock(hfsmp, startingBlock, &amp;buffer, &amp;blockRef,
								HFS_ALLOC_IGNORE_TENTATIVE);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * Initialize currentWord, and wordsLeft.
	 */</span>
	u_int32_t wordIndexInBlock;

	bitsPerBlock  = hfsmp-&gt;vcbVBMIOSize * kBitsPerByte;
	wordsPerBlock = hfsmp-&gt;vcbVBMIOSize / kBytesPerWord;

	wordIndexInBlock = (startingBlock &amp; (bitsPerBlock-1)) / kBitsPerWord;
	currentWord = buffer + wordIndexInBlock;

	<span class="enscript-comment">/*
	 * First test any non word aligned bits.
	 */</span>
	firstBit = startingBlock % kBitsPerWord;
	bitMask = kAllBitsSetInWord &gt;&gt; firstBit;
	numBits = kBitsPerWord - firstBit;
	<span class="enscript-keyword">if</span> (numBits &gt; numBlocks) {
		numBits = numBlocks;
		bitMask &amp;= ~(kAllBitsSetInWord &gt;&gt; (firstBit + numBits));
	}
	<span class="enscript-keyword">if</span> ((*currentWord &amp; SWAP_BE32 (bitMask)) != 0) {
		inuse = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Exit</span>;
	}
	numBlocks -= numBits;
	++currentWord;

<span class="enscript-reference">Exit</span>:
	<span class="enscript-keyword">if</span>(bp_buf == NULL) {
		<span class="enscript-keyword">if</span> (buffer) {
			(<span class="enscript-type">void</span>)ReleaseBitmapBlock(hfsmp, blockRef, false);
		}
	}
	<span class="enscript-keyword">return</span> (inuse);



}

<span class="enscript-comment">/*
 * This function resets all of the data structures relevant to the
 * free extent cache stored in the hfsmount struct.  
 * 
 * If we are using the red-black tree code then we need to account for the fact that 
 * we may encounter situations where we need to jettison the tree.  If that is the 
 * case, then we fail-over to the bitmap scanning logic, but we need to ensure that 
 * the free ext cache is zeroed before we start using it.  
 *
 * We also reset and disable the cache when allocLimit is updated... which 
 * is when a volume is being resized (via hfs_truncatefs() or hfs_extendfs()). 
 * It is independent of the type of allocator being used currently.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">ResetVCBFreeExtCache</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp) 
{
	<span class="enscript-type">int</span> bytes;
	<span class="enscript-type">void</span> *freeExt;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_RESET_EXTENT_CACHE | DBG_FUNC_START, 0, 0, 0, 0, 0);

	lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);

	<span class="enscript-comment">/* reset Free Extent Count */</span>
	hfsmp-&gt;vcbFreeExtCnt = 0;

	<span class="enscript-comment">/* reset the actual array */</span>
	bytes = kMaxFreeExtents * <span class="enscript-keyword">sizeof</span>(HFSPlusExtentDescriptor);
	freeExt = (<span class="enscript-type">void</span>*)(hfsmp-&gt;vcbFreeExt);

	bzero (freeExt, bytes);

	lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_RESET_EXTENT_CACHE | DBG_FUNC_END, 0, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * This function is used to inform the allocator if we have to effectively shrink
 * or grow the total number of allocation blocks via hfs_truncatefs or hfs_extendfs. 
 *
 * The bitmap lock must be held when calling this function.  This function also modifies the
 * allocLimit field in the hfs mount point structure in the general case. 
 * 
 * In the shrinking case, we'll have to remove all free extents from the red-black
 * tree past the specified offset new_end_block.  In the growth case, we'll have to force
 * a re-scan of the new allocation blocks from our current allocLimit to the new end block.
 * 
 * new_end_block represents the total number of blocks available for allocation in the resized
 * filesystem.  Block #new_end_block should not be allocatable in the resized filesystem since it
 * will be out of the (0, n-1) range that are indexable in the bitmap.
 *
 * Returns	0 on success
 *			errno on failure
 */</span>
__private_extern__
u_int32_t <span class="enscript-function-name">UpdateAllocLimit</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t new_end_block) {

	<span class="enscript-comment">/* 
	 * Update allocLimit to the argument specified
	 */</span>
	hfsmp-&gt;allocLimit = new_end_block;

	<span class="enscript-comment">/* Invalidate the free extent cache completely so that 
	 * it does not have any extents beyond end of current 
	 * volume.
	 */</span>
	ResetVCBFreeExtCache(hfsmp);

	<span class="enscript-comment">/* Force a rebuild of the summary table. */</span>
	(<span class="enscript-type">void</span>) hfs_rebuild_summary (hfsmp);

	<span class="enscript-comment">// Delete any tentative ranges that are in the area we're shrinking
</span>	<span class="enscript-type">struct</span> rl_entry *range, *next_range;
	TAILQ_FOREACH_SAFE(range, &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_TENTATIVE_BLOCKS],
					   rl_link, next_range) {
		<span class="enscript-keyword">if</span> (rl_overlap(range, new_end_block, RL_INFINITY) != RL_NOOVERLAP)
			hfs_release_reserved(hfsmp, range, HFS_TENTATIVE_BLOCKS);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Remove an extent from the list of free extents.
 *
 * This is a low-level routine.	 It does not handle overlaps or splitting;
 * that is the responsibility of the caller.  The input extent must exactly
 * match an extent already in the list; it will be removed, and any following
 * extents in the list will be shifted up.
 *
 * Inputs:
 *	startBlock - Start of extent to remove
 *	blockCount - Number of blocks in extent to remove
 *
 * Result:
 *	The index of the extent that was removed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">remove_free_extent_list</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> index)
{
	<span class="enscript-keyword">if</span> (index &lt; 0 || (uint32_t)index &gt;= hfsmp-&gt;vcbFreeExtCnt) {
		<span class="enscript-keyword">if</span> (ALLOC_DEBUG)
			panic(<span class="enscript-string">&quot;hfs: remove_free_extent_list: %p: index (%d) out of range (0, %u)&quot;</span>, hfsmp, index, hfsmp-&gt;vcbFreeExtCnt);
		<span class="enscript-keyword">else</span>
			printf(<span class="enscript-string">&quot;hfs: remove_free_extent_list: %p: index (%d) out of range (0, %u)&quot;</span>, hfsmp, index, hfsmp-&gt;vcbFreeExtCnt);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-type">int</span> shift_count = hfsmp-&gt;vcbFreeExtCnt - index - 1;
	<span class="enscript-keyword">if</span> (shift_count &gt; 0) {
		memmove(&amp;hfsmp-&gt;vcbFreeExt[index], &amp;hfsmp-&gt;vcbFreeExt[index+1], shift_count * <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;vcbFreeExt[0]));
	}
	hfsmp-&gt;vcbFreeExtCnt--;
}


<span class="enscript-comment">/*
 * Add an extent to the list of free extents.
 *
 * This is a low-level routine.	 It does not handle overlaps or coalescing;
 * that is the responsibility of the caller.  This routine *does* make
 * sure that the extent it is adding is inserted in the correct location.
 * If the list is full, this routine will handle either removing the last
 * extent in the list to make room for the new extent, or ignoring the
 * new extent if it is &quot;worse&quot; than the last extent in the list.
 *
 * Inputs:
 *	startBlock - Start of extent to add
 *	blockCount - Number of blocks in extent to add
 *
 * Result:
 *	The index where the extent that was inserted, or kMaxFreeExtents
 *	if the extent was not inserted (the list was full, and the extent
 *	being added was &quot;worse&quot; than everything in the list).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">add_free_extent_list</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, u_int32_t blockCount)
{
	uint32_t i;

	<span class="enscript-comment">/* ALLOC_DEBUG: Make sure no extents in the list overlap or are contiguous with the input extent. */</span>
	<span class="enscript-keyword">if</span> (ALLOC_DEBUG) {
		uint32_t endBlock = startBlock + blockCount;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; hfsmp-&gt;vcbFreeExtCnt; ++i) {
			<span class="enscript-keyword">if</span> (endBlock &lt; hfsmp-&gt;vcbFreeExt[i].startBlock ||
					startBlock &gt; (hfsmp-&gt;vcbFreeExt[i].startBlock + hfsmp-&gt;vcbFreeExt[i].blockCount)) {
				<span class="enscript-keyword">continue</span>;
			}
			panic(<span class="enscript-string">&quot;hfs: add_free_extent_list: %p: extent(%u %u) overlaps existing extent (%u %u) at index %d&quot;</span>,
					hfsmp, startBlock, blockCount, hfsmp-&gt;vcbFreeExt[i].startBlock, hfsmp-&gt;vcbFreeExt[i].blockCount, i);
		}
	}	 

	<span class="enscript-comment">/* Figure out what index the new extent should be inserted at. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; hfsmp-&gt;vcbFreeExtCnt; ++i) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
			<span class="enscript-comment">/* The list is sorted by increasing offset. */</span>
			<span class="enscript-keyword">if</span> (startBlock &lt; hfsmp-&gt;vcbFreeExt[i].startBlock) {
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* The list is sorted by decreasing size. */</span>
			<span class="enscript-keyword">if</span> (blockCount &gt; hfsmp-&gt;vcbFreeExt[i].blockCount) {
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	<span class="enscript-comment">/* When we get here, i is the index where the extent should be inserted. */</span>
	<span class="enscript-keyword">if</span> (i == kMaxFreeExtents) {
		<span class="enscript-comment">/*
		 * The new extent is worse than anything already in the list,
		 * and the list is full, so just ignore the extent to be added.
		 */</span>
		<span class="enscript-keyword">return</span> i;
	}

	<span class="enscript-comment">/*
	 * Grow the list (if possible) to make room for an insert.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExtCnt &lt; kMaxFreeExtents)
		hfsmp-&gt;vcbFreeExtCnt++;

	<span class="enscript-comment">/*
	 * If we'll be keeping any extents after the insert position, then shift them.
	 */</span>
	<span class="enscript-type">int</span> shift_count = hfsmp-&gt;vcbFreeExtCnt - i - 1;
	<span class="enscript-keyword">if</span> (shift_count &gt; 0) {
		memmove(&amp;hfsmp-&gt;vcbFreeExt[i+1], &amp;hfsmp-&gt;vcbFreeExt[i], shift_count * <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;vcbFreeExt[0]));
	}

	<span class="enscript-comment">/* Finally, store the new extent at its correct position. */</span>
	hfsmp-&gt;vcbFreeExt[i].startBlock = startBlock;
	hfsmp-&gt;vcbFreeExt[i].blockCount = blockCount;
	<span class="enscript-keyword">return</span> i;
}


<span class="enscript-comment">/*
 * Remove an entry from free extent cache after it has been allocated.
 *
 * This is a high-level routine.  It handles removing a portion of a
 * cached extent, potentially splitting it into two (if the cache was
 * already full, throwing away the extent that would sort last).  It
 * also handles removing an extent that overlaps multiple extents in
 * the cache.
 *
 * Inputs: 
 *	hfsmp		- mount point structure 
 *	startBlock	- starting block of the extent to be removed. 
 *	blockCount	- number of blocks of the extent to be removed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">remove_free_extent_cache</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, u_int32_t blockCount)
{
	u_int32_t i, insertedIndex;
	u_int32_t currentStart, currentEnd, endBlock;
	<span class="enscript-type">int</span> extentsRemoved = 0;

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_REMOVE_EXTENT_CACHE | DBG_FUNC_START, startBlock, blockCount, 0, 0, 0);

	endBlock = startBlock + blockCount;

	lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);

	<span class="enscript-comment">/*
	 * Iterate over all of the extents in the free extent cache, removing or
	 * updating any entries that overlap with the input extent.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; hfsmp-&gt;vcbFreeExtCnt; ++i) {
		currentStart = hfsmp-&gt;vcbFreeExt[i].startBlock;
		currentEnd = currentStart + hfsmp-&gt;vcbFreeExt[i].blockCount;

		<span class="enscript-comment">/*
		 * If the current extent is entirely before or entirely after the
		 * the extent to be removed, then we keep it as-is.
		 */</span>
		<span class="enscript-keyword">if</span> (currentEnd &lt;= startBlock || currentStart &gt;= endBlock) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If the extent being removed entirely contains the current extent,
		 * then remove the current extent.
		 */</span>
		<span class="enscript-keyword">if</span> (startBlock &lt;= currentStart &amp;&amp; endBlock &gt;= currentEnd) {
			remove_free_extent_list(hfsmp, i);

			<span class="enscript-comment">/*
			 * We just removed the extent at index i.  The extent at
			 * index i+1 just got shifted to index i.  So decrement i
			 * to undo the loop's &quot;++i&quot;, and the next iteration will
			 * examine index i again, which contains the next extent
			 * in the list.
			 */</span>
			--i;
			++extentsRemoved;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * If the extent being removed is strictly &quot;in the middle&quot; of the
		 * current extent, then we need to split the current extent into
		 * two discontiguous extents (the &quot;head&quot; and &quot;tail&quot;).  The good
		 * news is that we don't need to examine any other extents in
		 * the list.
		 */</span>
		<span class="enscript-keyword">if</span> (startBlock &gt; currentStart &amp;&amp; endBlock &lt; currentEnd) {
			remove_free_extent_list(hfsmp, i);
			add_free_extent_list(hfsmp, currentStart, startBlock - currentStart);
			add_free_extent_list(hfsmp, endBlock, currentEnd - endBlock);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * The only remaining possibility is that the extent to be removed
		 * overlaps the start or end (but not both!) of the current extent.
		 * So we need to replace the current extent with a shorter one.
		 *
		 * The only tricky part is that the updated extent might be at a
		 * different index than the original extent.  If the updated extent
		 * was inserted after the current extent, then we need to re-examine
		 * the entry at index i, since it now contains the extent that was
		 * previously at index i+1.	 If the updated extent was inserted
		 * before or at the same index as the removed extent, then the
		 * following extents haven't changed position.
		 */</span>
		remove_free_extent_list(hfsmp, i);
		<span class="enscript-keyword">if</span> (startBlock &gt; currentStart) {
			<span class="enscript-comment">/* Remove the tail of the current extent. */</span>
			insertedIndex = add_free_extent_list(hfsmp, currentStart, startBlock - currentStart);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Remove the head of the current extent. */</span>
			insertedIndex = add_free_extent_list(hfsmp, endBlock, currentEnd - endBlock);
		}
		<span class="enscript-keyword">if</span> (insertedIndex &gt; i) {
			--i;	<span class="enscript-comment">/* Undo the &quot;++i&quot; in the loop, so we examine the entry at index i again. */</span>
		}
	}

	lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);

	sanity_check_free_ext(hfsmp, 0);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_REMOVE_EXTENT_CACHE | DBG_FUNC_END, 0, 0, 0, extentsRemoved, 0);

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * Add an entry to free extent cache after it has been deallocated.	 
 *
 * This is a high-level routine.  It will merge overlapping or contiguous
 * extents into a single, larger extent.
 *
 * If the extent provided has blocks beyond current allocLimit, it is
 * clipped to allocLimit (so that we won't accidentally find and allocate
 * space beyond allocLimit).
 *
 * Inputs: 
 *	hfsmp		- mount point structure 
 *	startBlock	- starting block of the extent to be removed. 
 *	blockCount	- number of blocks of the extent to be removed.
 *
 * Returns:
 *	true		- if the extent was added successfully to the list
 *	false		- if the extent was not added to the list, maybe because 
 *			  the extent was beyond allocLimit, or is not best 
 *			  candidate to be put in the cache.
 */</span>
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">add_free_extent_cache</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, u_int32_t blockCount)
{
	Boolean retval = false;
	uint32_t endBlock;
	uint32_t currentEnd;
	uint32_t i; 

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ADD_EXTENT_CACHE | DBG_FUNC_START, startBlock, blockCount, 0, 0, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 2; ++i) {
		<span class="enscript-type">struct</span> rl_entry *range;
		TAILQ_FOREACH(range, &amp;hfsmp-&gt;hfs_reserved_ranges[i], rl_link) {
			assert(rl_overlap(range, startBlock,
							  startBlock + blockCount - 1) == RL_NOOVERLAP);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* No need to add extent that is beyond current allocLimit */</span>
	<span class="enscript-keyword">if</span> (startBlock &gt;= hfsmp-&gt;allocLimit) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_not_locked</span>;
	}

	<span class="enscript-comment">/* If end of the free extent is beyond current allocLimit, clip the extent */</span>
	<span class="enscript-keyword">if</span> ((startBlock + blockCount) &gt; hfsmp-&gt;allocLimit) {
		blockCount = hfsmp-&gt;allocLimit - startBlock;
	}

	lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);

	<span class="enscript-comment">/*
	 * Make a pass through the free extent cache, looking for known extents that
	 * overlap or are contiguous with the extent to be added.  We'll remove those
	 * extents from the cache, and incorporate them into the new extent to be added.
	 */</span>
	endBlock = startBlock + blockCount;
	<span class="enscript-keyword">for</span> (i=0; i &lt; hfsmp-&gt;vcbFreeExtCnt; ++i) {
		currentEnd = hfsmp-&gt;vcbFreeExt[i].startBlock + hfsmp-&gt;vcbFreeExt[i].blockCount;
		<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExt[i].startBlock &gt; endBlock || currentEnd &lt; startBlock) {
			<span class="enscript-comment">/* Extent i does not overlap and is not contiguous, so keep it. */</span>
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* We need to remove extent i and combine it with the input extent. */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExt[i].startBlock &lt; startBlock)
				startBlock = hfsmp-&gt;vcbFreeExt[i].startBlock;
			<span class="enscript-keyword">if</span> (currentEnd &gt; endBlock)
				endBlock = currentEnd;

			remove_free_extent_list(hfsmp, i);
			<span class="enscript-comment">/*
			 * We just removed the extent at index i.  The extent at
			 * index i+1 just got shifted to index i.  So decrement i
			 * to undo the loop's &quot;++i&quot;, and the next iteration will
			 * examine index i again, which contains the next extent
			 * in the list.
			 */</span>
			--i;
		}
	}
	add_free_extent_list(hfsmp, startBlock, endBlock - startBlock);

	lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);

<span class="enscript-reference">out_not_locked</span>:
	sanity_check_free_ext(hfsmp, 0);

	<span class="enscript-keyword">if</span> (hfs_kdebug_allocation &amp; HFSDBG_EXT_CACHE_ENABLED)
		KERNEL_DEBUG_CONSTANT(HFSDBG_ADD_EXTENT_CACHE | DBG_FUNC_END, 0, 0, 0, retval, 0);

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-comment">/* Debug function to check if the free extent cache is good or not */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sanity_check_free_ext</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> check_allocated)
{
	u_int32_t i, j;

	<span class="enscript-comment">/* Do not do anything if debug is not on */</span>
	<span class="enscript-keyword">if</span> (ALLOC_DEBUG == 0) {
		<span class="enscript-keyword">return</span>;
	}

	lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExtCnt &gt; kMaxFreeExtents)
		panic(<span class="enscript-string">&quot;hfs: %p: free extent count (%u) is too large&quot;</span>, hfsmp, hfsmp-&gt;vcbFreeExtCnt);

	<span class="enscript-comment">/* 
	 * Iterate the Free extent cache and ensure no entries are bogus or refer to
	 * allocated blocks.
	 */</span>
	<span class="enscript-keyword">for</span>(i=0; i &lt; hfsmp-&gt;vcbFreeExtCnt; i++) {
		u_int32_t start, nblocks;

		start   = hfsmp-&gt;vcbFreeExt[i].startBlock;
		nblocks = hfsmp-&gt;vcbFreeExt[i].blockCount;

		<span class="enscript-comment">/* Check if any of the blocks in free extent cache are allocated.  
		 * This should not be enabled always because it might take 
		 * very long for large extents that get added to the list.
		 *
		 * We have to drop vcbFreeExtLock while we call hfs_isallocated
		 * because it is going to do I/O.  Note that the free extent
		 * cache could change.  That's a risk we take when using this
		 * debugging code.  (Another alternative would be to try to
		 * detect when the free extent cache changed, and perhaps
		 * restart if the list changed while we dropped the lock.)
		 */</span>
		<span class="enscript-keyword">if</span> (check_allocated) {
			lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);
			<span class="enscript-keyword">if</span> (hfs_isallocated(hfsmp, start, nblocks)) {
				panic(<span class="enscript-string">&quot;hfs: %p: slot %d:(%u,%u) in the free extent array is allocated\n&quot;</span>,
						hfsmp, i, start, nblocks);
			}
			lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);
		}

		<span class="enscript-comment">/* Check if any part of the extent is beyond allocLimit */</span>
		<span class="enscript-keyword">if</span> ((start &gt; hfsmp-&gt;allocLimit) || ((start + nblocks) &gt; hfsmp-&gt;allocLimit)) {
			panic (<span class="enscript-string">&quot;hfs: %p: slot %d:(%u,%u) in the free extent array is beyond allocLimit=%u\n&quot;</span>,
					hfsmp, i, start, nblocks, hfsmp-&gt;allocLimit);
		}

		<span class="enscript-comment">/* Check if there are any duplicate start blocks */</span>
		<span class="enscript-keyword">for</span>(j=i+1; j &lt; hfsmp-&gt;vcbFreeExtCnt; j++) {
			<span class="enscript-keyword">if</span> (start == hfsmp-&gt;vcbFreeExt[j].startBlock) {
				panic(<span class="enscript-string">&quot;hfs: %p: slot %d:(%u,%u) and %d:(%u,%u) are duplicate\n&quot;</span>, 
						hfsmp, i, start, nblocks, j, hfsmp-&gt;vcbFreeExt[j].startBlock, 
						hfsmp-&gt;vcbFreeExt[j].blockCount);
			}
		}

		<span class="enscript-comment">/* Check if the entries are out of order */</span>
		<span class="enscript-keyword">if</span> ((i+1) != hfsmp-&gt;vcbFreeExtCnt) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
				<span class="enscript-comment">/* sparse devices are sorted by starting block number (ascending) */</span>
				<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExt[i].startBlock &gt; hfsmp-&gt;vcbFreeExt[i+1].startBlock) {
					panic (<span class="enscript-string">&quot;hfs: %p: SPARSE %d:(%u,%u) and %d:(%u,%u) are out of order\n&quot;</span>, 
							hfsmp, i, start, nblocks, i+1, hfsmp-&gt;vcbFreeExt[i+1].startBlock, 
							hfsmp-&gt;vcbFreeExt[i+1].blockCount);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* normally sorted by block count (descending) */</span>
				<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExt[i].blockCount &lt; hfsmp-&gt;vcbFreeExt[i+1].blockCount) {
					panic (<span class="enscript-string">&quot;hfs: %p: %d:(%u,%u) and %d:(%u,%u) are out of order\n&quot;</span>, 
							hfsmp, i, start, nblocks, i+1, hfsmp-&gt;vcbFreeExt[i+1].startBlock, 
							hfsmp-&gt;vcbFreeExt[i+1].blockCount);
				}
			}
		}
	}
	lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">BIT_RIGHT_MASK</span>(bit)	(0xffffffffffffffffull &gt;&gt; (bit))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHighBitInDoubleWordMask</span> 0x8000000000000000ull

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">clzll</span>(uint64_t x)
{
	<span class="enscript-keyword">if</span> (x == 0)
		<span class="enscript-keyword">return</span> 64;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> __builtin_clzll(x);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">get_more_bits</span>(bitmap_context_t *bitmap_ctx)
{
	uint32_t	start_bit;
	uint32_t	iosize = 0;
	uint32_t	byte_offset;
	uint32_t	last_bitmap_block;
	<span class="enscript-type">int</span>			error;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = bitmap_ctx-&gt;hfsmp;
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>
	uint64_t	lock_elapsed;
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">if</span> (bitmap_ctx-&gt;bp)
		ReleaseScanBitmapRange(bitmap_ctx-&gt;bp);
	
	<span class="enscript-keyword">if</span> (msleep(NULL, NULL, PINOD | PCATCH,
			   <span class="enscript-string">&quot;hfs_fsinfo&quot;</span>, NULL) == EINTR) {
		<span class="enscript-keyword">return</span> EINTR;
	}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>
	<span class="enscript-comment">/*
	 * Let someone else use the allocation map after we've processed over HFS_FSINFO_MAX_LOCKHELD_TIME .
	 * lock_start is initialized in hfs_find_free_extents().
	 */</span>
	absolutetime_to_nanoseconds(mach_absolute_time() - bitmap_ctx-&gt;lock_start, &amp;lock_elapsed);

	<span class="enscript-keyword">if</span> (lock_elapsed &gt;= HFS_FSINFO_MAX_LOCKHELD_TIME) {

		hfs_systemfile_unlock(hfsmp, bitmap_ctx-&gt;lockflags);
		
		<span class="enscript-comment">/* add tsleep here to force context switch and fairness */</span>
		tsleep((caddr_t)get_more_bits, PRIBIO, <span class="enscript-string">&quot;hfs_fsinfo&quot;</span>, 1);

		hfs_journal_lock(hfsmp);

		<span class="enscript-comment">/* Flush the journal and wait for all I/Os to finish up */</span>
		error = hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
		<span class="enscript-keyword">if</span> (error) {
			hfs_journal_unlock(hfsmp);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/*
		 * Take bitmap lock to ensure it is not being modified while journal is still held.
		 * Since we are reading larger than normal blocks from the bitmap, which
		 * might confuse other parts of the bitmap code using normal blocks, we
		 * take exclusive lock here.
		 */</span>
		bitmap_ctx-&gt;lockflags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);

		bitmap_ctx-&gt;lock_start = mach_absolute_time();

		<span class="enscript-comment">/* Release the journal lock */</span>
		hfs_journal_unlock(hfsmp);

		<span class="enscript-comment">/*
		 * Bitmap is read in large block size (up to 1MB),
		 * unlike the runtime which reads the bitmap in the
		 * 4K block size.  If the bitmap is read by both ways
		 * at the same time, it can result in multiple buf_t with
		 * different sizes and potentially case data corruption.
		 * To avoid this, we invalidate all the existing buffers
		 * associated with the bitmap vnode.
		 */</span>
		error = buf_invalidateblks(hfsmp-&gt;hfs_allocation_vp, 0, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* hfs_systemfile_unlock will be called in the caller */</span>
			<span class="enscript-keyword">return</span> error;
		}
	}
#<span class="enscript-reference">endif</span>

	start_bit = bitmap_ctx-&gt;run_offset;

	<span class="enscript-keyword">if</span> (start_bit &gt;= bitmap_ctx-&gt;hfsmp-&gt;totalBlocks) {
		bitmap_ctx-&gt;chunk_end = 0;
		bitmap_ctx-&gt;bp = NULL;
		bitmap_ctx-&gt;bitmap = NULL;
		<span class="enscript-keyword">return</span> 0;
	}

	assert(start_bit % 8 == 0);

	<span class="enscript-comment">/*
	 * Compute how much I/O we should generate here.
	 * hfs_scan_range_size will validate that the start bit
	 * converted into a byte offset into the bitmap file,
	 * is aligned on a VBMIOSize boundary.
	 */</span>
	error = hfs_scan_range_size (bitmap_ctx-&gt;hfsmp, start_bit, &amp;iosize);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	assert(iosize != 0);

	<span class="enscript-comment">/* hfs_scan_range_size should have verified startbit.  Convert it to bytes */</span>
	byte_offset = start_bit / kBitsPerByte;

	<span class="enscript-comment">/*
	 * When the journal replays blocks, it does so by writing directly to the disk
	 * device (bypassing any filesystem vnodes and such).  When it finishes its I/Os
	 * it also immediately re-reads and invalidates the range covered by the bp so
	 * it does not leave anything lingering in the cache (for iosize reasons).
	 *
	 * As such, it is safe to do large I/Os here with ReadBitmapRange.
	 *
	 * NOTE: It is not recommended, but it is possible to call the function below
	 * on sections of the bitmap that may be in core already as long as the pages are not
	 * dirty.  In that case, we'd notice that something starting at that
	 * logical block of the bitmap exists in the metadata cache, and we'd check
	 * if the iosize requested is the same as what was already allocated for it.
	 * Odds are pretty good we're going to request something larger.  In that case,
	 * we just free the existing memory associated with the buf and reallocate a
	 * larger range. This function should immediately invalidate it as soon as we're
	 * done scanning, so this shouldn't cause any coherency issues.
	 */</span>
	error = ReadBitmapRange(bitmap_ctx-&gt;hfsmp, byte_offset, iosize, (uint32_t **)&amp;bitmap_ctx-&gt;bitmap, &amp;bitmap_ctx-&gt;bp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * At this point, we have a giant wired buffer that represents some portion of
	 * the bitmap file that we want to analyze.   We may not have gotten all 'iosize'
	 * bytes though, so clip our ending bit to what we actually read in.
	 */</span>
	last_bitmap_block = start_bit + buf_count(bitmap_ctx-&gt;bp) * kBitsPerByte;

	<span class="enscript-comment">/* Cap the last block to the total number of blocks if required */</span>
	<span class="enscript-keyword">if</span> (last_bitmap_block &gt; bitmap_ctx-&gt;hfsmp-&gt;totalBlocks)
		last_bitmap_block = bitmap_ctx-&gt;hfsmp-&gt;totalBlocks;

	bitmap_ctx-&gt;chunk_current = 0;  <span class="enscript-comment">// new chunk of bitmap
</span>	bitmap_ctx-&gt;chunk_end = last_bitmap_block - start_bit;

	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>

<span class="enscript-comment">// Returns number of contiguous bits set at start
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bit_count_set</span>(<span class="enscript-type">void</span> *bitmap, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end)
{
	<span class="enscript-keyword">if</span> (start == end)
		<span class="enscript-keyword">return</span> 0;

	assert(end &gt; start);

	<span class="enscript-type">const</span> <span class="enscript-type">int</span> start_bit = start &amp; 63;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> end_bit   = end &amp; 63;

	uint64_t *p = (uint64_t *)bitmap + start / 64;
	uint64_t x = ~OSSwapBigToHostInt64(*p);

	<span class="enscript-keyword">if</span> ((start &amp; ~63) == (end &amp; ~63)) {
		<span class="enscript-comment">// Start and end in same 64 bits
</span>		x = (x &amp; BIT_RIGHT_MASK(start_bit)) | BIT_RIGHT_MASK(end_bit);
		<span class="enscript-keyword">return</span> clzll(x) - start_bit;
	}

	<span class="enscript-comment">// Deal with initial unaligned bit
</span>	x &amp;= BIT_RIGHT_MASK(start_bit);

	<span class="enscript-keyword">if</span> (x)
		<span class="enscript-keyword">return</span> clzll(x) - start_bit;

	<span class="enscript-comment">// Go fast
</span>	++p;
	<span class="enscript-type">int</span> count = 64 - start_bit;
	<span class="enscript-type">int</span> nquads = (end - end_bit - start - 1) / 64;

	<span class="enscript-keyword">while</span> (nquads--) {
		<span class="enscript-keyword">if</span> (*p != 0xffffffffffffffffull) {
			x = ~OSSwapBigToHostInt64(*p);
			<span class="enscript-keyword">return</span> count + clzll(x);
		}
		++p;
		count += 64;
	}

	<span class="enscript-keyword">if</span> (end_bit) {
		x = ~OSSwapBigToHostInt64(*p) | BIT_RIGHT_MASK(end_bit);
		count += clzll(x);
	}

	<span class="enscript-keyword">return</span> count;
}

<span class="enscript-comment">/* Returns the number of a run of cleared bits:
 *  bitmap is a single chunk of memory being examined
 *  start: the start bit relative to the current buffer to be examined; start is inclusive.
 *  end: the end bit relative to the current buffer to be examined; end is not inclusive.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bit_count_clr</span>(<span class="enscript-type">void</span> *bitmap, <span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end)
{
	<span class="enscript-keyword">if</span> (start == end)
		<span class="enscript-keyword">return</span> 0;

	assert(end &gt; start);

	<span class="enscript-type">const</span> <span class="enscript-type">int</span> start_bit = start &amp; 63;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> end_bit   = end &amp; 63;

	uint64_t *p = (uint64_t *)bitmap + start / 64;
	uint64_t x = OSSwapBigToHostInt64(*p);

	<span class="enscript-keyword">if</span> ((start &amp; ~63) == (end &amp; ~63)) {
		<span class="enscript-comment">// Start and end in same 64 bits
</span>		x = (x &amp; BIT_RIGHT_MASK(start_bit)) | BIT_RIGHT_MASK(end_bit);

		<span class="enscript-keyword">return</span> clzll(x) - start_bit;
	}

	<span class="enscript-comment">// Deal with initial unaligned bit
</span>	x &amp;= BIT_RIGHT_MASK(start_bit);

	<span class="enscript-keyword">if</span> (x)
		<span class="enscript-keyword">return</span> clzll(x) - start_bit;

	<span class="enscript-comment">// Go fast
</span>	++p;
	<span class="enscript-type">int</span> count = 64 - start_bit;
	<span class="enscript-type">int</span> nquads = (end - end_bit - start - 1) / 64;

	<span class="enscript-keyword">while</span> (nquads--) {
		<span class="enscript-keyword">if</span> (*p) {
			x = OSSwapBigToHostInt64(*p);
			<span class="enscript-keyword">return</span> count + clzll(x);
		}
		++p;
		count += 64;
	}

	<span class="enscript-keyword">if</span> (end_bit) {
		x = OSSwapBigToHostInt64(*p) | BIT_RIGHT_MASK(end_bit);

		count += clzll(x);
	}

	<span class="enscript-keyword">return</span> count;
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">update_summary_table</span>(bitmap_context_t *bitmap_ctx, uint32_t start, uint32_t count, bool set)
{
	uint32_t	end, start_summary_bit, end_summary_bit;
	errno_t		error = 0;

	<span class="enscript-keyword">if</span> (count == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (!ISSET(bitmap_ctx-&gt;hfsmp-&gt;hfs_flags, HFS_SUMMARY_TABLE))
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (hfs_get_summary_index (bitmap_ctx-&gt;hfsmp, start, &amp;start_summary_bit)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	end = start + count - 1;
	<span class="enscript-keyword">if</span> (hfs_get_summary_index (bitmap_ctx-&gt;hfsmp, end, &amp;end_summary_bit)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">// if summary table bit has been updated with free block previously, leave it.
</span>	<span class="enscript-keyword">if</span> ((start_summary_bit == bitmap_ctx-&gt;last_free_summary_bit) &amp;&amp; set)
		start_summary_bit++;

	<span class="enscript-keyword">for</span> (uint32_t summary_bit = start_summary_bit; summary_bit &lt;= end_summary_bit; summary_bit++)
		hfs_set_summary (bitmap_ctx-&gt;hfsmp, summary_bit, set);

	<span class="enscript-keyword">if</span> (!set)
		bitmap_ctx-&gt;last_free_summary_bit = end_summary_bit;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;

}
#<span class="enscript-reference">endif</span> //!<span class="enscript-variable-name">HFS_ALLOC_TEST</span>

<span class="enscript-comment">/*
 * Read in chunks of the bitmap into memory, and find a run of cleared/set bits;
 * the run can extend across chunk boundaries.
 * bit_count_clr can be passed to get a run of cleared bits.
 * bit_count_set can be passed to get a run of set bits.
 */</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count</span>(bitmap_context_t *bitmap_ctx, <span class="enscript-type">int</span> (*fn)(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span> ,<span class="enscript-type">int</span>), uint32_t *bit_count)
{
	<span class="enscript-type">int</span> count;
	errno_t error = 0;

	*bit_count = 0;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (bitmap_ctx-&gt;run_offset == 0 || bitmap_ctx-&gt;chunk_current == bitmap_ctx-&gt;chunk_end) {
			<span class="enscript-keyword">if</span> ((error = get_more_bits(bitmap_ctx)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (bitmap_ctx-&gt;chunk_end == 0)
			<span class="enscript-keyword">break</span>;

		count = fn(bitmap_ctx-&gt;bitmap, bitmap_ctx-&gt;chunk_current, bitmap_ctx-&gt;chunk_end);

		bitmap_ctx-&gt;run_offset += count;
		bitmap_ctx-&gt;chunk_current += count;
		*bit_count += count;

	} <span class="enscript-keyword">while</span> (bitmap_ctx-&gt;chunk_current &gt;= bitmap_ctx-&gt;chunk_end &amp;&amp; count);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;

}

<span class="enscript-comment">// Returns count of number of bits clear
</span><span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count_clr</span>(bitmap_context_t *bitmap_ctx, uint32_t *count)
{
	<span class="enscript-keyword">return</span> hfs_bit_count(bitmap_ctx, bit_count_clr, count);
}

<span class="enscript-comment">// Returns count of number of bits set
</span><span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_bit_count_set</span>(bitmap_context_t *bitmap_ctx, uint32_t *count)
{
	<span class="enscript-keyword">return</span> hfs_bit_count(bitmap_ctx, bit_count_set, count);
}

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">hfs_bit_offset</span>(bitmap_context_t *bitmap_ctx)
{
	<span class="enscript-keyword">return</span> bitmap_ctx-&gt;run_offset;
}

<span class="enscript-comment">/*
 * Perform a full scan of the bitmap file.
 * Note: during the scan of bitmap file, it may drop and reacquire the
 * bitmap lock to let someone else use the bitmap for fairness.
 * Currently it is used by HFS_GET_FSINFO statistic gathing, which
 * is run while other processes might perform HFS operations.
 */</span>

errno_t <span class="enscript-function-name">hfs_find_free_extents</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp,
							  <span class="enscript-type">void</span> (*callback)(<span class="enscript-type">void</span> *data, off_t free_extent_size), <span class="enscript-type">void</span> *callback_arg)
{
	<span class="enscript-type">struct</span> bitmap_context bitmap_ctx;
	uint32_t count;
	errno_t error = 0;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) == 0) {
		error = hfs_init_summary(hfsmp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
	}

	bzero(&amp;bitmap_ctx, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bitmap_context));

	<span class="enscript-comment">/*
	 * The journal maintains list of recently deallocated blocks to
	 * issue DKIOCUNMAPs when the corresponding journal transaction is
	 * flushed to the disk.  To avoid any race conditions, we only
	 * want one active trim list.  Therefore we make sure that the
	 * journal trim list is sync'ed, empty, and not modifiable for
	 * the duration of our scan.
	 *
	 * Take the journal lock before flushing the journal to the disk.
	 * We will keep on holding the journal lock till we don't get the
	 * bitmap lock to make sure that no new journal transactions can
	 * start.  This will make sure that the journal trim list is not
	 * modified after the journal flush and before getting bitmap lock.
	 * We can release the journal lock after we acquire the bitmap
	 * lock as it will prevent any further block deallocations.
	 */</span>
	hfs_journal_lock(hfsmp);

	<span class="enscript-comment">/* Flush the journal and wait for all I/Os to finish up */</span>
	error = hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
	<span class="enscript-keyword">if</span> (error) {
		hfs_journal_unlock(hfsmp);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/*
	 * Take bitmap lock to ensure it is not being modified.
	 * Since we are reading larger than normal blocks from the bitmap, which
	 * might confuse other parts of the bitmap code using normal blocks, we
	 * take exclusive lock here.
	 */</span>
	bitmap_ctx.lockflags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_ALLOC_TEST</span>
	bitmap_ctx.lock_start = mach_absolute_time();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Release the journal lock */</span>
	hfs_journal_unlock(hfsmp);

	<span class="enscript-comment">/*
	 * Bitmap is read in large block size (up to 1MB),
	 * unlike the runtime which reads the bitmap in the
	 * 4K block size.  If the bitmap is read by both ways
	 * at the same time, it can result in multiple buf_t with
	 * different sizes and potentially case data corruption.
	 * To avoid this, we invalidate all the existing buffers
	 * associated with the bitmap vnode.
	 */</span>
	error = buf_invalidateblks(hfsmp-&gt;hfs_allocation_vp, 0, 0, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Get the list of all free extent ranges.  hfs_alloc_scan_range()
	 * will call hfs_fsinfo_data_add() to account for all the free
	 * extent ranges found during scan.
	 */</span>
	bitmap_ctx.hfsmp = hfsmp;
	bitmap_ctx.run_offset = 0;

	<span class="enscript-keyword">while</span> (bitmap_ctx.run_offset &lt; hfsmp-&gt;totalBlocks) {

		uint32_t start = hfs_bit_offset(&amp;bitmap_ctx);

		<span class="enscript-keyword">if</span> ((error = hfs_bit_count_clr(&amp;bitmap_ctx, &amp;count)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> (count)
			callback(callback_arg, hfs_blk_to_bytes(count, hfsmp-&gt;blockSize));

		<span class="enscript-keyword">if</span> ((error = update_summary_table(&amp;bitmap_ctx, start, count, false)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		start = hfs_bit_offset(&amp;bitmap_ctx);

		<span class="enscript-keyword">if</span> ((error = hfs_bit_count_set(&amp;bitmap_ctx, &amp;count)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> ((error = update_summary_table(&amp;bitmap_ctx, start, count, true)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (bitmap_ctx.lockflags) {
		hfs_systemfile_unlock(hfsmp, bitmap_ctx.lockflags);
	}

	<span class="enscript-keyword">return</span> error;
}

</pre>
<hr />
</body></html>