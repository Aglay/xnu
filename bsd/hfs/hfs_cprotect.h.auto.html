<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_cprotect.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_cprotect.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">HFS_CPROTECT_H_</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFS_CPROTECT_H_</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KERNEL_PRIVATE</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/content_protection.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;crypto/aes.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_fsctl.h&quot;</span>

__BEGIN_DECLS

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_IV_KEYSIZE</span>             16	<span class="enscript-comment">/* 16x8 = 128 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_MAX_KEYSIZE</span>			  32	<span class="enscript-comment">/* 8x4 = 32, 32x8 = 256 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_MAX_CACHEBUFLEN</span>        64	<span class="enscript-comment">/* Maximum size of cp cache buffer/array */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_INITIAL_WRAPPEDKEYSIZE</span> 40
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_V2_WRAPPEDKEYSIZE</span>      40	<span class="enscript-comment">/* Size of the wrapped key in a v2 EA */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_V4_RESERVEDBYTES</span>       16	<span class="enscript-comment">/* Number of reserved bytes in EA still present */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_LOCKED_KEYCHAIN</span>        0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_UNLOCKED_KEYCHAIN</span>      1

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONTENT_PROTECTION_XATTR_NAME</span>	<span class="enscript-string">&quot;com.apple.system.cprotect&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CONTENT_PROTECTION_XATTR_NAME_CHARS</span>				\
	{ <span class="enscript-string">'c'</span>, <span class="enscript-string">'o'</span>, <span class="enscript-string">'m'</span>, <span class="enscript-string">'.'</span>, <span class="enscript-string">'a'</span>, <span class="enscript-string">'p'</span>, <span class="enscript-string">'p'</span>, <span class="enscript-string">'l'</span>, <span class="enscript-string">'e'</span>,		\
	<span class="enscript-string">'.'</span>, <span class="enscript-string">'s'</span>, <span class="enscript-string">'y'</span>, <span class="enscript-string">'s'</span>, <span class="enscript-string">'t'</span>, <span class="enscript-string">'e'</span>, <span class="enscript-string">'m'</span>,					\
	<span class="enscript-string">'.'</span>, <span class="enscript-string">'c'</span>, <span class="enscript-string">'p'</span>, <span class="enscript-string">'r'</span>, <span class="enscript-string">'o'</span>, <span class="enscript-string">'t'</span>, <span class="enscript-string">'e'</span>, <span class="enscript-string">'c'</span>, <span class="enscript-string">'t'</span> }
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_CURRENT_VERS</span>			CP_VERS_5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_VERS_5</span>				5		// iOS 8.1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_VERS_4</span>				4		// iOS 5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_VERS_2</span>				2		// iOS 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_MINOR_VERS</span>           0

<span class="enscript-comment">/* the class occupies the lowest 5 bits, so there are 32 values (0-31) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_EFFECTIVE_CLASSMASK</span> 0x0000001f

<span class="enscript-type">typedef</span> uint32_t cp_key_class_t;
<span class="enscript-type">typedef</span> uint32_t cp_key_os_version_t;

<span class="enscript-comment">/* macros for quick access/typing to mask out the classmask */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CP_CLASS</span>(x) ((cp_key_class_t)(CP_EFFECTIVE_CLASSMASK &amp; (x)))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_CRYPTO_G1</span>	0x00000020

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cp_xattr *cp_xattr_t;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cnode * cnode_ptr_t;
<span class="enscript-comment">//forward declare the struct.
</span><span class="enscript-type">struct</span> hfsmount;

<span class="enscript-comment">/* 
 * Flags for Key Generation Behavior 
 *
 * These are passed to cp_generate_keys() and cp_new() in the 
 * flags arguments
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CP_KEYWRAP_DIFFCLASS</span>    0x00000001 <span class="enscript-comment">/* wrapping with a different class bag is OK */</span>

<span class="enscript-comment">/*
 * off_rsrc_t: this structure represents an offset and whether or not it's
 * the resource fork.  It's done this way so that we can easily do comparisons
 * i.e.
 *
 *   { 0, data-fork } &lt; { 100, rsrc-fork }
 */</span>

<span class="enscript-type">enum</span> {
	OFF_RSRC_BIT = 0x4000000000000000,
};

<span class="enscript-type">typedef</span> int64_t off_rsrc_t;

<span class="enscript-type">static</span> inline bool <span class="enscript-function-name">off_rsrc_is_rsrc</span>(off_rsrc_t off_rsrc)
{
	<span class="enscript-keyword">return</span> off_rsrc &amp; OFF_RSRC_BIT;
}

<span class="enscript-type">static</span> inline off_t <span class="enscript-function-name">off_rsrc_get_off</span>(off_rsrc_t off_rsrc)
{
	<span class="enscript-keyword">return</span> off_rsrc &amp; (OFF_RSRC_BIT - 1);
}

<span class="enscript-type">static</span> inline off_rsrc_t <span class="enscript-function-name">off_rsrc_make</span>(off_t offset, bool is_rsrc)
{
	<span class="enscript-keyword">return</span> offset | (is_rsrc ? OFF_RSRC_BIT : 0);
}

<span class="enscript-comment">// -- struct cpx --
</span>
<span class="enscript-comment">/*
 * This structure contains the unwrapped key and is passed to the lower layers.
 * It is private so users must use the accessors declared in sys/cprotect.h
 * to read/write it.
 */</span>

<span class="enscript-comment">// cpx_flags
</span><span class="enscript-type">typedef</span> uint32_t cpx_flags_t;
<span class="enscript-type">enum</span> {
	CPX_SEP_WRAPPEDKEY			= 0x01,
	CPX_IV_AES_CTX_INITIALIZED	= 0x02,
	CPX_USE_OFFSET_FOR_IV		= 0x04,

	<span class="enscript-comment">// Using AES IV context generated from key
</span>	CPX_IV_AES_CTX_HFS			= 0x08,
};

<span class="enscript-type">struct</span> cpx {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	uint32_t		cpx_magic1;
#<span class="enscript-reference">endif</span>
	cpx_flags_t		cpx_flags;
	uint16_t		cpx_max_key_len;
	uint16_t		cpx_key_len;
	aes_encrypt_ctx cpx_iv_aes_ctx;		<span class="enscript-comment">// Context used for generating the IV
</span>	uint8_t			cpx_cached_key[];
} __attribute__((packed));

<span class="enscript-comment">// -- struct cp_key_pair --
</span>
<span class="enscript-comment">/*
 * This structure maintains the pair of keys; the persistent, wrapped key that
 * is written to disk, and the unwrapped key (cpx_t) that we pass to lower
 * layers.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cp_key_pair {
	uint16_t	cpkp_max_pers_key_len;
	uint16_t	cpkp_pers_key_len;
	<span class="enscript-type">struct</span> cpx	cpkp_cpx;

	<span class="enscript-comment">// cpkp_cpx is variable length so the location of the persistent key varies
</span>	<span class="enscript-comment">// uint8_t cpkp_persistent_key[];
</span>} cp_key_pair_t;

<span class="enscript-comment">// -- struct cprotect --
</span>
<span class="enscript-comment">/*
 * Runtime-only structure containing the content protection status for
 * the given file.  This is referenced by the cnode.  It has the
 * variable length key pair at the end.
 */</span>

<span class="enscript-type">typedef</span> uint32_t cp_flags_t;
<span class="enscript-type">enum</span> {
	CP_NO_XATTR				= 0x01,	<span class="enscript-comment">/* Key info has not been saved as EA to the FS */</span>
	CP_RELOCATION_INFLIGHT	= 0x02,	<span class="enscript-comment">/* File with offset IVs is in the process of being relocated. */</span>

	CP_HAS_A_KEY            = 0x08, <span class="enscript-comment">/* File has a non-zero length key */</span>
};

<span class="enscript-type">struct</span> cprotect {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	uint32_t						cp_magic1;
#<span class="enscript-reference">endif</span>
	cp_flags_t						cp_flags;
	cp_key_class_t					cp_pclass;  <span class="enscript-comment">/* persistent class stored on-disk */</span>
	<span class="enscript-type">void</span>*							cp_backing_cnode;
	cp_key_os_version_t				cp_key_os_version;
	cp_key_revision_t				cp_key_revision;
	uint16_t						cp_raw_open_count;
	cp_key_pair_t					cp_keys;	<span class="enscript-comment">// Variable length
</span>};

<span class="enscript-comment">// -- On-Disk Structures --
</span>
<span class="enscript-type">typedef</span> uint32_t cp_xattr_flags_t;
<span class="enscript-type">enum</span> {
	<span class="enscript-comment">/* 
	 * Be careful about using flags 0x02 to 0x20.  Older code used to write
	 * flags that were used for in-memory purposes to disk and therefore
	 * they might be used in V4 structures.  Here's what they were:
	 *
	 *	  CP_KEY_FLUSHED			0x02	Should never have made it to disk
	 *    CP_NO_XATTR				0x04	Should never have made it to disk
	 *	  CP_OFF_IV_ENABLED			0x08	Probably made it to disk
	 *	  CP_RELOCATION_INFLIGHT	0x10	Should never have made it to disk
	 *	  CP_SEP_WRAPPEDKEY			0x20	Probably made it to disk
	 *
	 */</span>

	CP_XAF_NEEDS_KEYS			= 0x0001,	<span class="enscript-comment">/* V4 only: file needs persistent keys */</span>

};

<span class="enscript-comment">/*
 * V2 structure written as the per-file EA payload
 * All on-disk multi-byte fields for the CP XATTR must be stored
 * little-endian on-disk.  This means they must be endian swapped to
 * L.E on getxattr() and converted to LE on setxattr().
 *
 * This structure is a fixed length and is tightly packed.
 * 56 bytes total.
 */</span>
<span class="enscript-type">struct</span> cp_xattr_v2 {
	u_int16_t xattr_major_version;
	u_int16_t xattr_minor_version;
	cp_xattr_flags_t flags;
	u_int32_t persistent_class;
	u_int32_t key_size;
	uint8_t   persistent_key[CP_V2_WRAPPEDKEYSIZE];
} __attribute__((aligned(2), packed));


<span class="enscript-comment">/*
 * V4 Content Protection EA On-Disk Layout.
 *
 * This structure must be tightly packed, but the *size can vary*
 * depending on the length of the key.  At MOST, the key length will be
 * CP_MAX_WRAPPEDKEYSIZE, but the length is defined by the key_size field.
 *
 * Either way, the packing must be applied to ensure that the key data is
 * retrievable in the right location relative to the start of the struct.
 *
 * Fully packed, this structure can range from :
 * 		MIN: 36 bytes (no key -- used with directories)
 *		MAX: 164 bytes (with 128 byte key)
 *
 * During runtime we always allocate with the full 128 byte key, but only
 * use as much of the key buffer as needed. It must be tightly packed, though.
 */</span>

<span class="enscript-type">struct</span> cp_xattr_v4 {
	u_int16_t			xattr_major_version;
	u_int16_t			xattr_minor_version;
	cp_xattr_flags_t	flags;
	cp_key_class_t		persistent_class;
	u_int32_t			key_size;
	<span class="enscript-comment">// This field will be zero on older systems
</span>	cp_key_os_version_t	key_os_version;
	<span class="enscript-comment">/* CP V4 Reserved Bytes == 16 */</span>
	u_int8_t			reserved[CP_V4_RESERVEDBYTES];
	<span class="enscript-comment">/* All above fields are fixed regardless of key length (36 bytes) */</span>
	<span class="enscript-comment">/* Max Wrapped Size == 128 */</span>
	uint8_t				persistent_key[CP_MAX_WRAPPEDKEYSIZE];
} __attribute__((aligned(2), packed));

<span class="enscript-comment">// -- Version 5 --
</span>

<span class="enscript-type">struct</span> cp_xattr_v5 {
	uint16_t			xattr_major_version;
	uint16_t			xattr_minor_version;
	cp_xattr_flags_t	flags;
	cp_key_class_t		persistent_class;
	cp_key_os_version_t	key_os_version;
	cp_key_revision_t	key_revision;
	uint16_t			key_len;

	<span class="enscript-comment">// 20 bytes to here
</span>
	<span class="enscript-comment">// Variable length from here
</span>	uint8_t				persistent_key[CP_MAX_WRAPPEDKEYSIZE];


	<span class="enscript-comment">// Wouldn't be necessary if xattr routines returned just what we ask for
</span>	uint8_t				spare[512];
} __attribute__((aligned(2), packed));

<span class="enscript-type">enum</span> {
	CP_XATTR_MIN_LEN = 20,			<span class="enscript-comment">// Minimum length for all versions
</span>};

<span class="enscript-comment">/*
 * The Root Directory's EA (fileid 1) is special; it defines information about
 * what capabilities the filesystem is using.
 *
 * The data is still stored little endian.
 */</span>
<span class="enscript-type">struct</span> cp_root_xattr {
 	u_int16_t major_version;
 	u_int16_t minor_version;
 	u_int64_t flags;
} __attribute__((aligned(2), packed));

<span class="enscript-type">enum</span> {
	CP_ROOT_XATTR_MIN_LEN = 12,
};


<span class="enscript-comment">// -- Function Prototypes --
</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_entry_init</span>(cnode_ptr_t, <span class="enscript-type">struct</span> mount *);
<span class="enscript-type">int</span> <span class="enscript-function-name">cpx_gentempkeys</span>(cpx_t *pcpx, <span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">void</span> <span class="enscript-function-name">cp_entry_destroy</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cprotect *entry_ptr);
<span class="enscript-type">void</span> <span class="enscript-function-name">cp_replace_entry</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cprotect *newentry);
cnode_ptr_t <span class="enscript-function-name">cp_get_protected_cnode</span>(vnode_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_fs_protected</span> (mount_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_getrootxattr</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cp_root_xattr *outxattr);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_setrootxattr</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cp_root_xattr *newxattr);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_generate_keys</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp,
					  cp_key_class_t targetclass, uint32_t flags,
					  <span class="enscript-type">struct</span> cprotect **newentry);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_setup_newentry</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *dcp,
					   cp_key_class_t suppliedclass, mode_t cmode,
					   <span class="enscript-type">struct</span> cprotect **tmpentry);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_is_valid_class</span> (<span class="enscript-type">int</span> isdir, int32_t protectionclass);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_set_trimmed</span>(<span class="enscript-type">struct</span> hfsmount*);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_set_rewrapped</span>(<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_flop_generation</span> (<span class="enscript-type">struct</span> hfsmount*);
bool <span class="enscript-function-name">cp_is_supported_version</span>(uint16_t version);


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cp_io_params {
	<span class="enscript-comment">// The key to use
</span>	cpx_t	cpx;

	<span class="enscript-comment">/*
	 * The physical offset for this I/O or -1 if unknown (i.e. caller must
	 * do a regular look up).
	 */</span>
	off_t	phys_offset;

	<span class="enscript-comment">// The maximum length allowed for this I/O
</span>	off_t	max_len;
} cp_io_params_t;

<span class="enscript-comment">// Return the I/O parameters for this I/O
</span><span class="enscript-type">void</span> <span class="enscript-function-name">cp_io_params</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cprotect_t cpr, off_rsrc_t off_rsrc,
				  <span class="enscript-type">int</span> direction, cp_io_params_t *io_params);

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_setxattr</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cprotect *entry, <span class="enscript-type">struct</span> hfsmount *hfsmp,
				uint32_t fileid, <span class="enscript-type">int</span> xattr_opts);

<span class="enscript-type">typedef</span> <span class="enscript-type">void</span> * (* cp_new_alloc_fn)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *old, uint16_t pers_key_len,
								   uint16_t cached_key_len,
								   cp_key_pair_t **pcpkp);

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_new</span>(cp_key_class_t *newclass_eff, <span class="enscript-type">struct</span> hfsmount *hfsmp,
		   <span class="enscript-type">struct</span> cnode *cp, mode_t cmode, int32_t keyflags,
		   cp_key_revision_t key_revision,
		   cp_new_alloc_fn alloc_fn, <span class="enscript-type">void</span> **pholder);

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_rewrap</span>(<span class="enscript-type">struct</span> cnode *cp, __unused <span class="enscript-type">struct</span> hfsmount *hfsmp,
			  cp_key_class_t *newclass, cp_key_pair_t *cpkp, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *old_holder,
			  cp_new_alloc_fn alloc_fn, <span class="enscript-type">void</span> **pholder);

cprotect_t <span class="enscript-function-name">cp_entry_alloc</span>(cprotect_t old, uint16_t pers_keylen,
						  uint16_t cached_key_len, cp_key_pair_t **pcpkp);

cp_key_os_version_t <span class="enscript-function-name">cp_os_version</span>(<span class="enscript-type">void</span>);

cp_key_revision_t <span class="enscript-function-name">cp_next_key_revision</span>(cp_key_revision_t rev);

<span class="enscript-type">typedef</span> uint32_t cp_getxattr_options_t;
<span class="enscript-type">enum</span> {
	<span class="enscript-comment">// Return just basic information (not the key)
</span>	CP_GET_XATTR_BASIC_INFO     = 1,
};

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_read_xattr_v5</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cp_xattr_v5 *xattr,
					 size_t xattr_len, cprotect_t *pcpr, cp_getxattr_options_t options);


errno_t <span class="enscript-function-name">cp_handle_strategy</span>(buf_t bp);

<span class="enscript-comment">// -- cp_key_pair_t functions --
</span>
size_t <span class="enscript-function-name">cpkp_size</span>(uint16_t pers_key_len, uint16_t cached_key_len);
size_t <span class="enscript-function-name">cpkp_sizex</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp);
<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_init</span>(cp_key_pair_t *cpkp, uint16_t max_pers_key_len,
			   uint16_t max_cached_key_len);
<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_flush</span>(cp_key_pair_t *cpkp);
<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_copy</span>(<span class="enscript-type">const</span> cp_key_pair_t *src, cp_key_pair_t *dst);
uint16_t <span class="enscript-function-name">cpkp_max_pers_key_len</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp);
uint16_t <span class="enscript-function-name">cpkp_pers_key_len</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp);
bool <span class="enscript-function-name">cpkp_can_copy</span>(<span class="enscript-type">const</span> cp_key_pair_t *src, <span class="enscript-type">const</span> cp_key_pair_t *dst);

<span class="enscript-comment">// -- Private cpx functions --
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_init</span>(cpx_t, size_t key_len);
bool <span class="enscript-function-name">cpx_has_key</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx);
uint16_t <span class="enscript-function-name">cpx_max_key_len</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx);
cpx_t <span class="enscript-function-name">cpkp_cpx</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp);
<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_copy</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *src, cpx_t dst);

<span class="enscript-comment">// -- Helper Functions --
</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">cp_get_crypto_generation</span> (cp_key_class_t protclass) {
	<span class="enscript-keyword">if</span> (protclass &amp; CP_CRYPTO_G1) {
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> 0;
}

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL_PRIVATE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !HFS_CPROTECT_H_ */</span>
</pre>
<hr />
</body></html>