<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_vfsops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_vfsops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      hfs_vfsops.c
 *  derived from	@(#)ufs_vfsops.c	8.8 (Berkeley) 5/20/95
 *
 *      (c) Copyright 1997-2002 Apple Computer, Inc. All rights reserved.
 *
 *      hfs_vfsops.c -- VFS layer for loadable HFS file system.
 *
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/paths.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>

<span class="enscript-comment">/* for parsing boot-args */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_journal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_mount.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/md5.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;uuid/uuid.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_dbg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_hotfiles.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_quota.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_btreeio.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_kdebug.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cprotect.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/FileMgrInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesInternal.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MOUNT_DEBUG</span> 1

#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">HFS_DIAGNOSTIC</span>
<span class="enscript-type">int</span> hfs_dbg_all = 0;
<span class="enscript-type">int</span> hfs_dbg_err = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Enable/disable debugging code for live volume resizing, defined in hfs_resize.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> hfs_resize_debug;

lck_grp_attr_t *  hfs_group_attr;
lck_attr_t *  hfs_lock_attr;
lck_grp_t *  hfs_mutex_group;
lck_grp_t *  hfs_rwlock_group;
lck_grp_t *  hfs_spinlock_group;

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeopv_desc hfs_vnodeop_opv_desc;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnodeopv_desc hfs_std_vnodeop_opv_desc;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_flushMDB</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> waitfor, <span class="enscript-type">int</span> altflush);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* not static so we can re-use in hfs_readwrite.c for build_path calls */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vfs_vget</span>(<span class="enscript-type">struct</span> mount *mp, ino64_t ino, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_changefs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> hfs_mount_args *args);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_fhtovp</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> fhlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_flushfiles</span>(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getmountpoint</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> hfsmount **hfsmpp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_init</span>(<span class="enscript-type">struct</span> vfsconf *vfsp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_locks_destroy</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vfs_root</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_quotactl</span>(<span class="enscript-type">struct</span> mount *, <span class="enscript-type">int</span>, uid_t, caddr_t, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_start</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vptofh</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *fhlenp, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_journal_replay</span>(vnode_t devvp, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_free</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_initialize_allocator</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_teardown_allocator</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_mount</span>(<span class="enscript-type">struct</span> mount *mp, vnode_t  devvp, user_addr_t data, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_mountfs</span>(<span class="enscript-type">struct</span> vnode *devvp, <span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> hfs_mount_args *args, <span class="enscript-type">int</span> journal_replay_only, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_reload</span>(<span class="enscript-type">struct</span> mount *mp);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_statfs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> vfsstatfs *sbp, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_sync</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> waitfor, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_sysctl</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t oldp, size_t *oldlenp, 
                      user_addr_t newp, size_t newlen, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_unmount</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> mntflags, vfs_context_t context);

<span class="enscript-comment">/*
 * Called by vfs_mountroot when mounting HFS Plus as root.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_mountroot</span>(mount_t mp, vnode_t rvp, vfs_context_t context)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> vfsstatfs *vfsp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = hfs_mountfs(rvp, mp, NULL, 0, context))) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mountroot: hfs_mountfs returned %d, rvp (%p) name (%s) \n&quot;</span>, 
					error, rvp, (rvp-&gt;v_name ? rvp-&gt;v_name : <span class="enscript-string">&quot;unknown device&quot;</span>));
		}
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Init hfsmp */</span>
	hfsmp = VFSTOHFS(mp);

	hfsmp-&gt;hfs_uid = UNKNOWNUID;
	hfsmp-&gt;hfs_gid = UNKNOWNGID;
	hfsmp-&gt;hfs_dir_mask = (S_IRWXU | S_IRGRP|S_IXGRP | S_IROTH|S_IXOTH); <span class="enscript-comment">/* 0755 */</span>
	hfsmp-&gt;hfs_file_mask = (S_IRWXU | S_IRGRP|S_IXGRP | S_IROTH|S_IXOTH); <span class="enscript-comment">/* 0755 */</span>

	<span class="enscript-comment">/* Establish the free block reserve. */</span>
	vcb = HFSTOVCB(hfsmp);
	vcb-&gt;reserveBlocks = ((u_int64_t)vcb-&gt;totalBlocks * HFS_MINFREE) / 100;
	vcb-&gt;reserveBlocks = MIN(vcb-&gt;reserveBlocks, HFS_MAXRESERVE / vcb-&gt;blockSize);

	vfsp = vfs_statfs(mp);
	(<span class="enscript-type">void</span>)hfs_statfs(mp, vfsp, NULL);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * VFS Operations.
 *
 * mount system call
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_mount</span>(<span class="enscript-type">struct</span> mount *mp, vnode_t devvp, user_addr_t data, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;
	<span class="enscript-type">struct</span> hfs_mount_args args;
	<span class="enscript-type">int</span> retval = E_NONE;
	u_int32_t cmdflags;

	<span class="enscript-keyword">if</span> ((retval = copyin(data, (caddr_t)&amp;args, <span class="enscript-keyword">sizeof</span>(args)))) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mount: copyin returned %d for fs\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">return</span> (retval);
	}
	cmdflags = (u_int32_t)vfs_flags(mp) &amp; MNT_CMDFLAGS;
	<span class="enscript-keyword">if</span> (cmdflags &amp; MNT_UPDATE) {
		hfsmp = VFSTOHFS(mp);

		<span class="enscript-comment">/* Reload incore data after an fsck. */</span>
		<span class="enscript-keyword">if</span> (cmdflags &amp; MNT_RELOAD) {
			<span class="enscript-keyword">if</span> (vfs_isrdonly(mp)) {
				<span class="enscript-type">int</span> error = hfs_reload(mp);
				<span class="enscript-keyword">if</span> (error &amp;&amp; HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: hfs_reload returned %d on %s \n&quot;</span>, error, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">return</span> error;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: MNT_RELOAD not supported on rdwr filesystem %s\n&quot;</span>, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">return</span> (EINVAL);
			}
		}

		<span class="enscript-comment">/* Change to a read-only file system. */</span>
		<span class="enscript-keyword">if</span> (((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0) &amp;&amp;
		    vfs_isrdonly(mp)) {
			<span class="enscript-type">int</span> flags;

			<span class="enscript-comment">/* Set flag to indicate that a downgrade to read-only
			 * is in progress and therefore block any further 
			 * modifications to the file system.
			 */</span>
			hfs_lock_global (hfsmp, HFS_EXCLUSIVE_LOCK);
			hfsmp-&gt;hfs_flags |= HFS_RDONLY_DOWNGRADE;
			hfsmp-&gt;hfs_downgrading_thread = current_thread();
			hfs_unlock_global (hfsmp);
			hfs_syncer_free(hfsmp);
            
			<span class="enscript-comment">/* use VFS_SYNC to push out System (btree) files */</span>
			retval = VFS_SYNC(mp, MNT_WAIT, context);
			<span class="enscript-keyword">if</span> (retval &amp;&amp; ((cmdflags &amp; MNT_FORCE) == 0)) {
				hfsmp-&gt;hfs_flags &amp;= ~HFS_RDONLY_DOWNGRADE;
				hfsmp-&gt;hfs_downgrading_thread = NULL;
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: VFS_SYNC returned %d during b-tree sync of %s \n&quot;</span>, retval, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		
			flags = WRITECLOSE;
			<span class="enscript-keyword">if</span> (cmdflags &amp; MNT_FORCE)
				flags |= FORCECLOSE;
				
			<span class="enscript-keyword">if</span> ((retval = hfs_flushfiles(mp, flags, p))) {
				hfsmp-&gt;hfs_flags &amp;= ~HFS_RDONLY_DOWNGRADE;
				hfsmp-&gt;hfs_downgrading_thread = NULL;
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: hfs_flushfiles returned %d on %s \n&quot;</span>, retval, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* mark the volume cleanly unmounted */</span>
			hfsmp-&gt;vcbAtrb |= kHFSVolumeUnmountedMask;
			retval = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
			hfsmp-&gt;hfs_flags |= HFS_READ_ONLY;

			<span class="enscript-comment">/*
			 * Close down the journal. 
			 *
			 * NOTE: It is critically important to close down the journal
			 * and have it issue all pending I/O prior to calling VNOP_FSYNC below.
			 * In a journaled environment it is expected that the journal be
			 * the only actor permitted to issue I/O for metadata blocks in HFS.
			 * If we were to call VNOP_FSYNC prior to closing down the journal,
			 * we would inadvertantly issue (and wait for) the I/O we just 
			 * initiated above as part of the flushvolumeheader call.
			 * 
			 * To avoid this, we follow the same order of operations as in
			 * unmount and issue the journal_close prior to calling VNOP_FSYNC.
			 */</span>
	
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				hfs_lock_global (hfsmp, HFS_EXCLUSIVE_LOCK);

			    journal_close(hfsmp-&gt;jnl);
			    hfsmp-&gt;jnl = NULL;

			    <span class="enscript-comment">// Note: we explicitly don't want to shutdown
</span>			    <span class="enscript-comment">//       access to the jvp because we may need
</span>			    <span class="enscript-comment">//       it later if we go back to being read-write.
</span>
				hfs_unlock_global (hfsmp);

                vfs_clearflags(hfsmp-&gt;hfs_mp, MNT_JOURNALED);
			}

			<span class="enscript-comment">/*
			 * Write out any pending I/O still outstanding against the device node
			 * now that the journal has been closed.
			 */</span>
			<span class="enscript-keyword">if</span> (retval == 0) {
				vnode_get(hfsmp-&gt;hfs_devvp);
				retval = VNOP_FSYNC(hfsmp-&gt;hfs_devvp, MNT_WAIT, context);
				vnode_put(hfsmp-&gt;hfs_devvp);
			}

			<span class="enscript-keyword">if</span> (retval) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: FSYNC on devvp returned %d for fs %s\n&quot;</span>, retval, hfsmp-&gt;vcbVN);
				}
				hfsmp-&gt;hfs_flags &amp;= ~HFS_RDONLY_DOWNGRADE;
				hfsmp-&gt;hfs_downgrading_thread = NULL;
				hfsmp-&gt;hfs_flags &amp;= ~HFS_READ_ONLY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table) {
					<span class="enscript-type">int</span> err = 0;
					<span class="enscript-comment">/* 
					 * Take the bitmap lock to serialize against a concurrent bitmap scan still in progress 
					 */</span>
					<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_vp) {
						err = hfs_lock (VTOC(hfsmp-&gt;hfs_allocation_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
					}
					FREE (hfsmp-&gt;hfs_summary_table, M_TEMP);
					hfsmp-&gt;hfs_summary_table = NULL;
					hfsmp-&gt;hfs_flags &amp;= ~HFS_SUMMARY_TABLE;
					<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; hfsmp-&gt;hfs_allocation_vp){
						hfs_unlock (VTOC(hfsmp-&gt;hfs_allocation_vp));
					}
				}
			}

			hfsmp-&gt;hfs_downgrading_thread = NULL;
		}

		<span class="enscript-comment">/* Change to a writable file system. */</span>
		<span class="enscript-keyword">if</span> (vfs_iswriteupgrade(mp)) {
			<span class="enscript-comment">/*
			 * On inconsistent disks, do not allow read-write mount
			 * unless it is the boot volume being mounted.
			 */</span>
			<span class="enscript-keyword">if</span> (!(vfs_flags(mp) &amp; MNT_ROOTFS) &amp;&amp;
					(hfsmp-&gt;vcbAtrb &amp; kHFSVolumeInconsistentMask)) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: attempting to mount inconsistent non-root volume %s\n&quot;</span>,  (hfsmp-&gt;vcbVN));
				}
				retval = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">// If the journal was shut-down previously because we were
</span>			<span class="enscript-comment">// asked to be read-only, let's start it back up again now
</span>			
			<span class="enscript-keyword">if</span> (   (HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask)
			    &amp;&amp; hfsmp-&gt;jnl == NULL
			    &amp;&amp; hfsmp-&gt;jvp != NULL) {
			    <span class="enscript-type">int</span> jflags;

			    <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_NEED_JNL_RESET) {
					jflags = JOURNAL_RESET;
				} <span class="enscript-keyword">else</span> {
					jflags = 0;
				}

				hfs_lock_global (hfsmp, HFS_EXCLUSIVE_LOCK);

				<span class="enscript-comment">/* We provide the mount point twice here: The first is used as
				 * an opaque argument to be passed back when hfs_sync_metadata
				 * is called.  The second is provided to the throttling code to
				 * indicate which mount's device should be used when accounting
				 * for metadata writes.
				 */</span>
				hfsmp-&gt;jnl = journal_open(hfsmp-&gt;jvp,
						hfs_blk_to_bytes(hfsmp-&gt;jnl_start, HFSTOVCB(hfsmp)-&gt;blockSize) + (off_t)HFSTOVCB(hfsmp)-&gt;hfsPlusIOPosOffset,
						hfsmp-&gt;jnl_size,
						hfsmp-&gt;hfs_devvp,
						hfsmp-&gt;hfs_logical_block_size,
						jflags,
						0,
						hfs_sync_metadata, hfsmp-&gt;hfs_mp,
						hfsmp-&gt;hfs_mp);
				
				<span class="enscript-comment">/*
				 * Set up the trim callback function so that we can add
				 * recently freed extents to the free extent cache once
				 * the transaction that freed them is written to the
				 * journal on disk.
				 */</span>
				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
					journal_trim_set_callback(hfsmp-&gt;jnl, hfs_trim_callback, hfsmp);
				
				hfs_unlock_global (hfsmp);

				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
						printf(<span class="enscript-string">&quot;hfs_mount: journal_open == NULL; couldn't be opened on %s \n&quot;</span>, (hfsmp-&gt;vcbVN));
					}
					retval = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				} <span class="enscript-keyword">else</span> {
					hfsmp-&gt;hfs_flags &amp;= ~HFS_NEED_JNL_RESET;
                    vfs_setflags(hfsmp-&gt;hfs_mp, MNT_JOURNALED);
				}
			}

			<span class="enscript-comment">/* See if we need to erase unused Catalog nodes due to &lt;rdar://problem/6947811&gt;. */</span>
			retval = hfs_erase_unused_nodes(hfsmp);
			<span class="enscript-keyword">if</span> (retval != E_NONE) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: hfs_erase_unused_nodes returned %d for fs %s\n&quot;</span>, retval, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* If this mount point was downgraded from read-write 
			 * to read-only, clear that information as we are now 
			 * moving back to read-write.
			 */</span>
			hfsmp-&gt;hfs_flags &amp;= ~HFS_RDONLY_DOWNGRADE;
			hfsmp-&gt;hfs_downgrading_thread = NULL;

			<span class="enscript-comment">/* mark the volume dirty (clear clean unmount bit) */</span>
			hfsmp-&gt;vcbAtrb &amp;= ~kHFSVolumeUnmountedMask;

			retval = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
			<span class="enscript-keyword">if</span> (retval != E_NONE) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mount: hfs_flushvolumeheader returned %d for fs %s\n&quot;</span>, retval, hfsmp-&gt;vcbVN);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		
			<span class="enscript-comment">/* Only clear HFS_READ_ONLY after a successful write */</span>
			hfsmp-&gt;hfs_flags &amp;= ~HFS_READ_ONLY;


			<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; (HFS_READ_ONLY | HFS_STANDARD))) {
				<span class="enscript-comment">/* Setup private/hidden directories for hardlinks. */</span>
				hfs_privatedir_init(hfsmp, FILE_HARDLINKS);
				hfs_privatedir_init(hfsmp, DIR_HARDLINKS);

				hfs_remove_orphans(hfsmp);

				<span class="enscript-comment">/*
				 * Since we're upgrading to a read-write mount, allow
				 * hot file clustering if conditions allow.
				 *
				 * Note: this normally only would happen if you booted
				 *       single-user and upgraded the mount to read-write
				 *
				 * Note: at this point we are not allowed to fail the
				 *       mount operation because the HotFile init code
				 *       in hfs_recording_init() will lookup vnodes with
				 *       VNOP_LOOKUP() which hangs vnodes off the mount
				 *       (and if we were to fail, VFS is not prepared to
				 *       clean that up at this point.  Since HotFiles are
				 *       optional, this is not a big deal.
				 */</span>
				<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) &amp;&amp; 
				    (((hfsmp-&gt;hfs_mp-&gt;mnt_kern_flag &amp; MNTK_SSD) == 0) || (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) ) {
					(<span class="enscript-type">void</span>) hfs_recording_init(hfsmp);
				}					
				<span class="enscript-comment">/* Force ACLs on HFS+ file systems. */</span>
				<span class="enscript-keyword">if</span> (vfs_extendedsecurity(HFSTOVFS(hfsmp)) == 0) {
					vfs_setextendedsecurity(HFSTOVFS(hfsmp));
				}
			}
		}

		<span class="enscript-comment">/* Update file system parameters. */</span>
		retval = hfs_changefs(mp, &amp;args);
		<span class="enscript-keyword">if</span> (retval &amp;&amp;  HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mount: hfs_changefs returned %d for %s\n&quot;</span>, retval, hfsmp-&gt;vcbVN);
		}

	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* not an update request */</span> {

		<span class="enscript-comment">/* Set the mount flag to indicate that we support volfs  */</span>
		vfs_setflags(mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_DOVOLFS));

		retval = hfs_mountfs(devvp, mp, &amp;args, 0, context);
		<span class="enscript-keyword">if</span> (retval) { 
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = vnode_getname(devvp);
			printf(<span class="enscript-string">&quot;hfs_mount: hfs_mountfs returned error=%d for device %s\n&quot;</span>, retval, (name ? name : <span class="enscript-string">&quot;unknown-dev&quot;</span>));
			<span class="enscript-keyword">if</span> (name) {
				vnode_putname(name);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* After hfs_mountfs succeeds, we should have valid hfsmp */</span>
		hfsmp = VFSTOHFS(mp);

	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (retval == 0) {
		(<span class="enscript-type">void</span>)hfs_statfs(mp, vfs_statfs(mp), context);
	}
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">struct</span> hfs_changefs_cargs {
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
        <span class="enscript-type">int</span>		namefix;
        <span class="enscript-type">int</span>		permfix;
        <span class="enscript-type">int</span>		permswitch;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_changefs_callback</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *cargs)
{
	ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr cnattr;
	<span class="enscript-type">struct</span> hfs_changefs_cargs *args;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error;

	args = (<span class="enscript-type">struct</span> hfs_changefs_cargs *)cargs;

	cp = VTOC(vp);
	vcb = HFSTOVCB(args-&gt;hfsmp);

	lockflags = hfs_systemfile_lock(args-&gt;hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
	error = cat_lookup(args-&gt;hfsmp, &amp;cp-&gt;c_desc, 0, 0, &amp;cndesc, &amp;cnattr, NULL, NULL);
	hfs_systemfile_unlock(args-&gt;hfsmp, lockflags);
	<span class="enscript-keyword">if</span> (error) {
	        <span class="enscript-comment">/*
		 * If we couldn't find this guy skip to the next one
		 */</span>
	        <span class="enscript-keyword">if</span> (args-&gt;namefix)
		        cache_purge(vp);

		<span class="enscript-keyword">return</span> (VNODE_RETURNED);
	}
	<span class="enscript-comment">/*
	 * Get the real uid/gid and perm mask from disk.
	 */</span>
	<span class="enscript-keyword">if</span> (args-&gt;permswitch || args-&gt;permfix) {
	        cp-&gt;c_uid = cnattr.ca_uid;
		cp-&gt;c_gid = cnattr.ca_gid;
		cp-&gt;c_mode = cnattr.ca_mode;
	}
	<span class="enscript-comment">/*
	 * If we're switching name converters then...
	 *   Remove the existing entry from the namei cache.
	 *   Update name to one based on new encoder.
	 */</span>
	<span class="enscript-keyword">if</span> (args-&gt;namefix) {
	        cache_purge(vp);
		replace_desc(cp, &amp;cndesc);

		<span class="enscript-keyword">if</span> (cndesc.cd_cnid == kHFSRootFolderID) {
		        strlcpy((<span class="enscript-type">char</span> *)vcb-&gt;vcbVN, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr, NAME_MAX+1);
			cp-&gt;c_desc.cd_encoding = args-&gt;hfsmp-&gt;hfs_encoding;
		}
	} <span class="enscript-keyword">else</span> {
	        cat_releasedesc(&amp;cndesc);
	}
	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}

<span class="enscript-comment">/* Change fs mount parameters */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_changefs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> hfs_mount_args *args)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> namefix, permfix, permswitch;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> hfs_changefs_cargs cargs;
	u_int32_t mount_flags;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	u_int32_t old_encoding = 0;
	hfs_to_unicode_func_t	get_unicode_func;
	unicode_to_hfs_func_t	get_hfsname_func;
#<span class="enscript-reference">endif</span>

	hfsmp = VFSTOHFS(mp);
	vcb = HFSTOVCB(hfsmp);
	mount_flags = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(mp);

	hfsmp-&gt;hfs_flags |= HFS_IN_CHANGEFS;
	
	permswitch = (((hfsmp-&gt;hfs_flags &amp; HFS_UNKNOWN_PERMS) &amp;&amp;
	               ((mount_flags &amp; MNT_UNKNOWNPERMISSIONS) == 0)) ||
	              (((hfsmp-&gt;hfs_flags &amp; HFS_UNKNOWN_PERMS) == 0) &amp;&amp;
	               (mount_flags &amp; MNT_UNKNOWNPERMISSIONS)));

	<span class="enscript-comment">/* The root filesystem must operate with actual permissions: */</span>
	<span class="enscript-keyword">if</span> (permswitch &amp;&amp; (mount_flags &amp; MNT_ROOTFS) &amp;&amp; (mount_flags &amp; MNT_UNKNOWNPERMISSIONS)) {
		vfs_clearflags(mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_UNKNOWNPERMISSIONS));	<span class="enscript-comment">/* Just say &quot;No&quot;. */</span>
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-keyword">if</span> (mount_flags &amp; MNT_UNKNOWNPERMISSIONS)
		hfsmp-&gt;hfs_flags |= HFS_UNKNOWN_PERMS;
	<span class="enscript-keyword">else</span>
		hfsmp-&gt;hfs_flags &amp;= ~HFS_UNKNOWN_PERMS;

	namefix = permfix = 0;

	<span class="enscript-comment">/*
	 * Tracking of hot files requires up-to-date access times.  So if
	 * access time updates are disabled, we must also disable hot files.
	 */</span>
	<span class="enscript-keyword">if</span> (mount_flags &amp; MNT_NOATIME) {
		(<span class="enscript-type">void</span>) hfs_recording_suspend(hfsmp);
	}
	
	<span class="enscript-comment">/* Change the timezone (Note: this affects all hfs volumes and hfs+ volume create dates) */</span>
	<span class="enscript-keyword">if</span> (args-&gt;hfs_timezone.tz_minuteswest != VNOVAL) {
		gTimeZone = args-&gt;hfs_timezone;
	}

	<span class="enscript-comment">/* Change the default uid, gid and/or mask */</span>
	<span class="enscript-keyword">if</span> ((args-&gt;hfs_uid != (uid_t)VNOVAL) &amp;&amp; (hfsmp-&gt;hfs_uid != args-&gt;hfs_uid)) {
		hfsmp-&gt;hfs_uid = args-&gt;hfs_uid;
		<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord == kHFSPlusSigWord)
			++permfix;
	}
	<span class="enscript-keyword">if</span> ((args-&gt;hfs_gid != (gid_t)VNOVAL) &amp;&amp; (hfsmp-&gt;hfs_gid != args-&gt;hfs_gid)) {
		hfsmp-&gt;hfs_gid = args-&gt;hfs_gid;
		<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord == kHFSPlusSigWord)
			++permfix;
	}
	<span class="enscript-keyword">if</span> (args-&gt;hfs_mask != (mode_t)VNOVAL) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_dir_mask != (args-&gt;hfs_mask &amp; ALLPERMS)) {
			hfsmp-&gt;hfs_dir_mask = args-&gt;hfs_mask &amp; ALLPERMS;
			hfsmp-&gt;hfs_file_mask = args-&gt;hfs_mask &amp; ALLPERMS;
			<span class="enscript-keyword">if</span> ((args-&gt;flags != VNOVAL) &amp;&amp; (args-&gt;flags &amp; HFSFSMNT_NOXONFILES))
				hfsmp-&gt;hfs_file_mask = (args-&gt;hfs_mask &amp; DEFFILEMODE);
			<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord == kHFSPlusSigWord)
				++permfix;
		}
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-comment">/* Change the hfs encoding value (hfs only) */</span>
	<span class="enscript-keyword">if</span> ((vcb-&gt;vcbSigWord == kHFSSigWord)	&amp;&amp;
	    (args-&gt;hfs_encoding != (u_int32_t)VNOVAL)              &amp;&amp;
	    (hfsmp-&gt;hfs_encoding != args-&gt;hfs_encoding)) {

		retval = hfs_getconverter(args-&gt;hfs_encoding, &amp;get_unicode_func, &amp;get_hfsname_func);
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/*
		 * Connect the new hfs_get_unicode converter but leave
		 * the old hfs_get_hfsname converter in place so that
		 * we can lookup existing vnodes to get their correctly
		 * encoded names.
		 *
		 * When we're all finished, we can then connect the new
		 * hfs_get_hfsname converter and release our interest
		 * in the old converters.
		 */</span>
		hfsmp-&gt;hfs_get_unicode = get_unicode_func;
		old_encoding = hfsmp-&gt;hfs_encoding;
		hfsmp-&gt;hfs_encoding = args-&gt;hfs_encoding;
		++namefix;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!(namefix || permfix || permswitch))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* XXX 3762912 hack to support HFS filesystem 'owner' */</span>
	<span class="enscript-keyword">if</span> (permfix)
		vfs_setowner(mp,
		    hfsmp-&gt;hfs_uid == UNKNOWNUID ? KAUTH_UID_NONE : hfsmp-&gt;hfs_uid,
		    hfsmp-&gt;hfs_gid == UNKNOWNGID ? KAUTH_GID_NONE : hfsmp-&gt;hfs_gid);
	
	<span class="enscript-comment">/*
	 * For each active vnode fix things that changed
	 *
	 * Note that we can visit a vnode more than once
	 * and we can race with fsync.
	 *
	 * hfs_changefs_callback will be called for each vnode
	 * hung off of this mount point
	 *
	 * The vnode will be properly referenced and unreferenced 
	 * around the callback
	 */</span>
	cargs.hfsmp = hfsmp;
	cargs.namefix = namefix;
	cargs.permfix = permfix;
	cargs.permswitch = permswitch;

	vnode_iterate(mp, 0, hfs_changefs_callback, (<span class="enscript-type">void</span> *)&amp;cargs);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-comment">/*
	 * If we're switching name converters we can now
	 * connect the new hfs_get_hfsname converter and
	 * release our interest in the old converters.
	 */</span>
	<span class="enscript-keyword">if</span> (namefix) {
		<span class="enscript-comment">/* HFS standard only */</span>
		hfsmp-&gt;hfs_get_hfsname = get_hfsname_func;
		vcb-&gt;volumeNameEncodingHint = args-&gt;hfs_encoding;
		(<span class="enscript-type">void</span>) hfs_relconverter(old_encoding);
	}
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">exit</span>:
	hfsmp-&gt;hfs_flags &amp;= ~HFS_IN_CHANGEFS;
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">struct</span> hfs_reload_cargs {
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
        <span class="enscript-type">int</span>		error;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reload_callback</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *cargs)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> hfs_reload_cargs *args;
	<span class="enscript-type">int</span> lockflags;

	args = (<span class="enscript-type">struct</span> hfs_reload_cargs *)cargs;
	<span class="enscript-comment">/*
	 * flush all the buffers associated with this node
	 */</span>
	(<span class="enscript-type">void</span>) buf_invalidateblks(vp, 0, 0, 0);

	cp = VTOC(vp);
	<span class="enscript-comment">/* 
	 * Remove any directory hints
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp))
	        hfs_reldirhints(cp, 0);

	<span class="enscript-comment">/*
	 * Re-read cnode data for all active vnodes (non-metadata files).
	 */</span>
	<span class="enscript-keyword">if</span> (!vnode_issystem(vp) &amp;&amp; !VNODE_IS_RSRC(vp) &amp;&amp; (cp-&gt;c_fileid &gt;= kHFSFirstUserCatalogNodeID)) {
	        <span class="enscript-type">struct</span> cat_fork *datafork;
		<span class="enscript-type">struct</span> cat_desc desc;

		datafork = cp-&gt;c_datafork ? &amp;cp-&gt;c_datafork-&gt;ff_data : NULL;

		<span class="enscript-comment">/* lookup by fileID since name could have changed */</span>
		lockflags = hfs_systemfile_lock(args-&gt;hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
		args-&gt;error = cat_idlookup(args-&gt;hfsmp, cp-&gt;c_fileid, 0, 0, &amp;desc, &amp;cp-&gt;c_attr, datafork);
		hfs_systemfile_unlock(args-&gt;hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (args-&gt;error) {
		        <span class="enscript-keyword">return</span> (VNODE_RETURNED_DONE);
		}

		<span class="enscript-comment">/* update cnode's catalog descriptor */</span>
		(<span class="enscript-type">void</span>) replace_desc(cp, &amp;desc);
	}
	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}

<span class="enscript-comment">/*
 * Reload all incore data for a filesystem (used after running fsck on
 * the root filesystem and finding things to fix). The filesystem must
 * be mounted read-only.
 *
 * Things to do to update the mount:
 *	invalidate all cached meta-data.
 *	invalidate all inactive vnodes.
 *	invalidate all cached file data.
 *	re-read volume header from disk.
 *	re-load meta-file info (extents, file size).
 *	re-load B-tree header data.
 *	re-read cnode data for all active vnodes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reload</span>(<span class="enscript-type">struct</span> mount *mountp)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> vnode *devvp;
	<span class="enscript-type">struct</span> buf *bp;
	<span class="enscript-type">int</span> error, i;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> HFSPlusVolumeHeader *vhp;
	ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> filefork *forkp;
    	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> hfs_reload_cargs args;
	daddr64_t priIDSector;

    	hfsmp = VFSTOHFS(mountp);
	vcb = HFSTOVCB(hfsmp);

	<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord == kHFSSigWord)
		<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* rooting from HFS is not supported! */</span>

	<span class="enscript-comment">/*
	 * Invalidate all cached meta-data.
	 */</span>
	devvp = hfsmp-&gt;hfs_devvp;
	<span class="enscript-keyword">if</span> (buf_invalidateblks(devvp, 0, 0, 0))
		panic(<span class="enscript-string">&quot;hfs_reload: dirty1&quot;</span>);

	args.hfsmp = hfsmp;
	args.error = 0;
	<span class="enscript-comment">/*
	 * hfs_reload_callback will be called for each vnode
	 * hung off of this mount point that can't be recycled...
	 * vnode_iterate will recycle those that it can (the VNODE_RELOAD option)
	 * the vnode will be in an 'unbusy' state (VNODE_WAIT) and 
	 * properly referenced and unreferenced around the callback
	 */</span>
	vnode_iterate(mountp, VNODE_RELOAD | VNODE_WAIT, hfs_reload_callback, (<span class="enscript-type">void</span> *)&amp;args);

	<span class="enscript-keyword">if</span> (args.error)
	        <span class="enscript-keyword">return</span> (args.error);

	<span class="enscript-comment">/*
	 * Re-read VolumeHeader from disk.
	 */</span>
	priIDSector = (daddr64_t)((vcb-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) + 
			HFS_PRI_SECTOR(hfsmp-&gt;hfs_logical_block_size));

	error = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp,
			HFS_PHYSBLK_ROUNDDOWN(priIDSector, hfsmp-&gt;hfs_log_per_phys),
			hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp);
	<span class="enscript-keyword">if</span> (error) {
        	<span class="enscript-keyword">if</span> (bp != NULL)
        		buf_brelse(bp);
		<span class="enscript-keyword">return</span> (error);
	}

	vhp = (HFSPlusVolumeHeader *) (buf_dataptr(bp) + HFS_PRI_OFFSET(hfsmp-&gt;hfs_physical_block_size));

	<span class="enscript-comment">/* Do a quick sanity check */</span>
	<span class="enscript-keyword">if</span> ((SWAP_BE16(vhp-&gt;signature) != kHFSPlusSigWord &amp;&amp;
	     SWAP_BE16(vhp-&gt;signature) != kHFSXSigWord) ||
	    (SWAP_BE16(vhp-&gt;version) != kHFSPlusVersion &amp;&amp;
	     SWAP_BE16(vhp-&gt;version) != kHFSXVersion) ||
	    SWAP_BE32(vhp-&gt;blockSize) != vcb-&gt;blockSize) {
		buf_brelse(bp);
		<span class="enscript-keyword">return</span> (EIO);
	}

	vcb-&gt;vcbLsMod		= to_bsd_time(SWAP_BE32(vhp-&gt;modifyDate));
	vcb-&gt;vcbAtrb		= SWAP_BE32 (vhp-&gt;attributes);
	vcb-&gt;vcbJinfoBlock  = SWAP_BE32(vhp-&gt;journalInfoBlock);
	vcb-&gt;vcbClpSiz		= SWAP_BE32 (vhp-&gt;rsrcClumpSize);
	vcb-&gt;vcbNxtCNID		= SWAP_BE32 (vhp-&gt;nextCatalogID);
	vcb-&gt;vcbVolBkUp		= to_bsd_time(SWAP_BE32(vhp-&gt;backupDate));
	vcb-&gt;vcbWrCnt		= SWAP_BE32 (vhp-&gt;writeCount);
	vcb-&gt;vcbFilCnt		= SWAP_BE32 (vhp-&gt;fileCount);
	vcb-&gt;vcbDirCnt		= SWAP_BE32 (vhp-&gt;folderCount);
	HFS_UPDATE_NEXT_ALLOCATION(vcb, SWAP_BE32 (vhp-&gt;nextAllocation));
	vcb-&gt;totalBlocks	= SWAP_BE32 (vhp-&gt;totalBlocks);
	vcb-&gt;freeBlocks		= SWAP_BE32 (vhp-&gt;freeBlocks);
	vcb-&gt;encodingsBitmap	= SWAP_BE64 (vhp-&gt;encodingsBitmap);
	bcopy(vhp-&gt;finderInfo, vcb-&gt;vcbFndrInfo, <span class="enscript-keyword">sizeof</span>(vhp-&gt;finderInfo));    
	vcb-&gt;localCreateDate	= SWAP_BE32 (vhp-&gt;createDate); <span class="enscript-comment">/* hfs+ create date is in local time */</span> 

	<span class="enscript-comment">/*
	 * Re-load meta-file vnode data (extent info, file size, etc).
	 */</span>
	forkp = VTOF((<span class="enscript-type">struct</span> vnode *)vcb-&gt;extentsRefNum);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		forkp-&gt;ff_extents[i].startBlock =
			SWAP_BE32 (vhp-&gt;extentsFile.extents[i].startBlock);
		forkp-&gt;ff_extents[i].blockCount =
			SWAP_BE32 (vhp-&gt;extentsFile.extents[i].blockCount);
	}
	forkp-&gt;ff_size      = SWAP_BE64 (vhp-&gt;extentsFile.logicalSize);
	forkp-&gt;ff_blocks    = SWAP_BE32 (vhp-&gt;extentsFile.totalBlocks);
	forkp-&gt;ff_clumpsize = SWAP_BE32 (vhp-&gt;extentsFile.clumpSize);


	forkp = VTOF((<span class="enscript-type">struct</span> vnode *)vcb-&gt;catalogRefNum);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		forkp-&gt;ff_extents[i].startBlock	=
			SWAP_BE32 (vhp-&gt;catalogFile.extents[i].startBlock);
		forkp-&gt;ff_extents[i].blockCount	=
			SWAP_BE32 (vhp-&gt;catalogFile.extents[i].blockCount);
	}
	forkp-&gt;ff_size      = SWAP_BE64 (vhp-&gt;catalogFile.logicalSize);
	forkp-&gt;ff_blocks    = SWAP_BE32 (vhp-&gt;catalogFile.totalBlocks);
	forkp-&gt;ff_clumpsize = SWAP_BE32 (vhp-&gt;catalogFile.clumpSize);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
		forkp = VTOF(hfsmp-&gt;hfs_attribute_vp);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			forkp-&gt;ff_extents[i].startBlock	=
				SWAP_BE32 (vhp-&gt;attributesFile.extents[i].startBlock);
			forkp-&gt;ff_extents[i].blockCount	=
				SWAP_BE32 (vhp-&gt;attributesFile.extents[i].blockCount);
		}
		forkp-&gt;ff_size      = SWAP_BE64 (vhp-&gt;attributesFile.logicalSize);
		forkp-&gt;ff_blocks    = SWAP_BE32 (vhp-&gt;attributesFile.totalBlocks);
		forkp-&gt;ff_clumpsize = SWAP_BE32 (vhp-&gt;attributesFile.clumpSize);
	}

	forkp = VTOF((<span class="enscript-type">struct</span> vnode *)vcb-&gt;allocationsRefNum);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		forkp-&gt;ff_extents[i].startBlock	=
			SWAP_BE32 (vhp-&gt;allocationFile.extents[i].startBlock);
		forkp-&gt;ff_extents[i].blockCount	=
			SWAP_BE32 (vhp-&gt;allocationFile.extents[i].blockCount);
	}
	forkp-&gt;ff_size      = SWAP_BE64 (vhp-&gt;allocationFile.logicalSize);
	forkp-&gt;ff_blocks    = SWAP_BE32 (vhp-&gt;allocationFile.totalBlocks);
	forkp-&gt;ff_clumpsize = SWAP_BE32 (vhp-&gt;allocationFile.clumpSize);

	buf_brelse(bp);
	vhp = NULL;

	<span class="enscript-comment">/*
	 * Re-load B-tree header data
	 */</span>
	forkp = VTOF((<span class="enscript-type">struct</span> vnode *)vcb-&gt;extentsRefNum);
	<span class="enscript-keyword">if</span> ( (error = MacToVFSError( BTReloadData((FCB*)forkp) )) )
		<span class="enscript-keyword">return</span> (error);

	forkp = VTOF((<span class="enscript-type">struct</span> vnode *)vcb-&gt;catalogRefNum);
	<span class="enscript-keyword">if</span> ( (error = MacToVFSError( BTReloadData((FCB*)forkp) )) )
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
		forkp = VTOF(hfsmp-&gt;hfs_attribute_vp);
		<span class="enscript-keyword">if</span> ( (error = MacToVFSError( BTReloadData((FCB*)forkp) )) )
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Reload the volume name */</span>
	<span class="enscript-keyword">if</span> ((error = cat_idlookup(hfsmp, kHFSRootFolderID, 0, 0, &amp;cndesc, NULL, NULL)))
		<span class="enscript-keyword">return</span> (error);
	vcb-&gt;volumeNameEncodingHint = cndesc.cd_encoding;
	bcopy(cndesc.cd_nameptr, vcb-&gt;vcbVN, min(255, cndesc.cd_namelen));
	cat_releasedesc(&amp;cndesc);

	<span class="enscript-comment">/* Re-establish private/hidden directories. */</span>
	hfs_privatedir_init(hfsmp, FILE_HARDLINKS);
	hfs_privatedir_init(hfsmp, DIR_HARDLINKS);

	<span class="enscript-comment">/* In case any volume information changed to trigger a notification */</span>
	hfs_generate_volume_notifications(hfsmp);
    
	<span class="enscript-keyword">return</span> (0);
}

__unused
<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">tv_to_usecs</span>(<span class="enscript-type">struct</span> timeval *tv)
{
	<span class="enscript-keyword">return</span> tv-&gt;tv_sec * 1000000ULL + tv-&gt;tv_usec;
}

<span class="enscript-comment">// Returns TRUE if b - a &gt;= usecs
</span><span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">hfs_has_elapsed</span> (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *a, 
                                  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *b,
                                  uint64_t usecs)
{
    <span class="enscript-type">struct</span> timeval diff;
    timersub(b, a, &amp;diff);
    <span class="enscript-keyword">return</span> diff.tv_sec * 1000000ULL + diff.tv_usec &gt;= usecs;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_syncer</span>(<span class="enscript-type">void</span> *arg0, __unused <span class="enscript-type">void</span> *unused)
{
    <span class="enscript-type">struct</span> hfsmount *hfsmp = arg0;
    <span class="enscript-type">struct</span> timeval   now;

    microuptime(&amp;now);

    KERNEL_DEBUG_CONSTANT(HFSDBG_SYNCER | DBG_FUNC_START, hfsmp, 
                          tv_to_usecs(&amp;now),
                          tv_to_usecs(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_completed_timestamp), 
                          hfsmp-&gt;hfs_mp-&gt;mnt_pending_write_size, 0);

    hfs_syncer_lock(hfsmp);

    <span class="enscript-keyword">if</span> (!hfsmp-&gt;hfs_syncer) {
        <span class="enscript-comment">// hfs_unmount is waiting for us leave now and let it do the sync
</span>        hfsmp-&gt;hfs_sync_incomplete = FALSE;
        hfs_syncer_unlock(hfsmp);
        hfs_syncer_wakeup(hfsmp);
        <span class="enscript-keyword">return</span>;
    }

    <span class="enscript-comment">/* Check to see whether we should flush now: either the oldest is
       &gt; HFS_MAX_META_DELAY or HFS_META_DELAY has elapsed since the
       request and there are no pending writes. */</span>

    boolean_t flush_now = FALSE;

    <span class="enscript-keyword">if</span> (hfs_has_elapsed(&amp;hfsmp-&gt;hfs_sync_req_oldest, &amp;now, HFS_MAX_META_DELAY))
        flush_now = TRUE;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!hfsmp-&gt;hfs_mp-&gt;mnt_pending_write_size) {
        <span class="enscript-comment">/* N.B. accessing mnt_last_write_completed_timestamp is not thread safe, but
           it won't matter for what we're using it for. */</span>
        <span class="enscript-keyword">if</span> (hfs_has_elapsed(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_completed_timestamp,
                            &amp;now,
                            HFS_META_DELAY)) {
            flush_now = TRUE;
        }
    }

    <span class="enscript-keyword">if</span> (!flush_now) {
        thread_call_t syncer = hfsmp-&gt;hfs_syncer;

        hfs_syncer_unlock(hfsmp);

        hfs_syncer_queue(syncer);

        <span class="enscript-keyword">return</span>;
    }

    timerclear(&amp;hfsmp-&gt;hfs_sync_req_oldest);

    hfs_syncer_unlock(hfsmp);

    KERNEL_DEBUG_CONSTANT(HFSDBG_SYNCER_TIMED | DBG_FUNC_START, 
                          tv_to_usecs(&amp;now),
                          tv_to_usecs(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_completed_timestamp),
                          tv_to_usecs(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_issued_timestamp), 
                          hfsmp-&gt;hfs_mp-&gt;mnt_pending_write_size, 0);

    <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_syncer_thread) {
        printf(<span class="enscript-string">&quot;hfs: syncer already running!\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

    hfsmp-&gt;hfs_syncer_thread = current_thread();

    <span class="enscript-comment">/*
     * We intentionally do a synchronous flush (of the journal or entire volume) here.
     * For journaled volumes, this means we wait until the metadata blocks are written
     * to both the journal and their final locations (in the B-trees, etc.).
     *
     * This tends to avoid interleaving the metadata writes with other writes (for
     * example, user data, or to the journal when a later transaction notices that
     * an earlier transaction has finished its async writes, and then updates the
     * journal start in the journal header).  Avoiding interleaving of writes is
     * very good for performance on simple flash devices like SD cards, thumb drives;
     * and on devices like floppies.  Since removable devices tend to be this kind of
     * simple device, doing a synchronous flush actually improves performance in
     * practice.
     *
     * NOTE: For non-journaled volumes, the call to hfs_sync will also cause dirty
     * user data to be written.
     */</span>
    <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
        hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
    } <span class="enscript-keyword">else</span> {
        hfs_sync(hfsmp-&gt;hfs_mp, MNT_WAIT, vfs_context_kernel());
    }

    KERNEL_DEBUG_CONSTANT(HFSDBG_SYNCER_TIMED | DBG_FUNC_END, 
                          (microuptime(&amp;now), tv_to_usecs(&amp;now)),
                          tv_to_usecs(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_completed_timestamp), 
                          tv_to_usecs(&amp;hfsmp-&gt;hfs_mp-&gt;mnt_last_write_issued_timestamp), 
                          hfsmp-&gt;hfs_mp-&gt;mnt_pending_write_size, 0);

    hfsmp-&gt;hfs_syncer_thread = NULL;

    hfs_syncer_lock(hfsmp);

    <span class="enscript-comment">// If hfs_unmount lets us and we missed a sync, schedule again
</span>    <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_syncer &amp;&amp; timerisset(&amp;hfsmp-&gt;hfs_sync_req_oldest)) {
        thread_call_t syncer = hfsmp-&gt;hfs_syncer;

        hfs_syncer_unlock(hfsmp);

        hfs_syncer_queue(syncer);
    } <span class="enscript-keyword">else</span> {
        hfsmp-&gt;hfs_sync_incomplete = FALSE;
        hfs_syncer_unlock(hfsmp);
        hfs_syncer_wakeup(hfsmp);
    }

    <span class="enscript-comment">/* BE CAREFUL WHAT YOU ADD HERE: at this point hfs_unmount is free
       to continue and therefore hfsmp might be invalid. */</span>

    KERNEL_DEBUG_CONSTANT(HFSDBG_SYNCER | DBG_FUNC_END, 0, 0, 0, 0, 0);
}


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">IOBSDIsMediaEjectable</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> *cdev_name );

<span class="enscript-comment">/*
 * Call into the allocator code and perform a full scan of the bitmap file.
 * 
 * This allows us to TRIM unallocated ranges if needed, and also to build up
 * an in-memory summary table of the state of the allocated blocks.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_scan_blocks</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	<span class="enscript-comment">/*
	 * Take the allocation file lock.  Journal transactions will block until
	 * we're done here. 
	 */</span>
	
	<span class="enscript-type">int</span> flags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	
	<span class="enscript-comment">/* 
	 * We serialize here with the HFS mount lock as we're mounting.
	 * 
	 * The mount can only proceed once this thread has acquired the bitmap 
	 * lock, since we absolutely do not want someone else racing in and 
	 * getting the bitmap lock, doing a read/write of the bitmap file, 
	 * then us getting the bitmap lock.
	 * 
	 * To prevent this, the mount thread takes the HFS mount mutex, starts us 
	 * up, then immediately msleeps on the scan_var variable in the mount 
	 * point as a condition variable.  This serialization is safe since 
	 * if we race in and try to proceed while they're still holding the lock, 
	 * we'll block trying to acquire the global lock.  Since the mount thread 
	 * acquires the HFS mutex before starting this function in a new thread, 
	 * any lock acquisition on our part must be linearizably AFTER the mount thread's. 
	 *
	 * Note that the HFS mount mutex is always taken last, and always for only
	 * a short time.  In this case, we just take it long enough to mark the
	 * scan-in-flight bit.
	 */</span>
	(<span class="enscript-type">void</span>) hfs_lock_mount (hfsmp);
	hfsmp-&gt;scan_var |= HFS_ALLOCATOR_SCAN_INFLIGHT;
	wakeup((caddr_t) &amp;hfsmp-&gt;scan_var);
	hfs_unlock_mount (hfsmp);

	<span class="enscript-comment">/* Initialize the summary table */</span>
	<span class="enscript-keyword">if</span> (hfs_init_summary (hfsmp)) {
		printf(<span class="enscript-string">&quot;hfs: could not initialize summary table for %s\n&quot;</span>, hfsmp-&gt;vcbVN);
	}	

	<span class="enscript-comment">/*
	 * ScanUnmapBlocks assumes that the bitmap lock is held when you 
	 * call the function. We don't care if there were any errors issuing unmaps.
	 *
	 * It will also attempt to build up the summary table for subsequent
	 * allocator use, as configured.
	 */</span>
	(<span class="enscript-type">void</span>) ScanUnmapBlocks(hfsmp);

	(<span class="enscript-type">void</span>) hfs_lock_mount (hfsmp);
	hfsmp-&gt;scan_var &amp;= ~HFS_ALLOCATOR_SCAN_INFLIGHT;
	hfsmp-&gt;scan_var |= HFS_ALLOCATOR_SCAN_COMPLETED;
	wakeup((caddr_t) &amp;hfsmp-&gt;scan_var);
	hfs_unlock_mount (hfsmp);

	buf_invalidateblks(hfsmp-&gt;hfs_allocation_vp, 0, 0, 0);
	
	hfs_systemfile_unlock(hfsmp, flags);

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> hfs_root_unmounted_cleanly = 0;

<span class="enscript-function-name">SYSCTL_DECL</span>(_vfs_generic);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic, OID_AUTO, root_unmounted_cleanly, CTLFLAG_RD, &amp;hfs_root_unmounted_cleanly, 0, <span class="enscript-string">&quot;Root filesystem was unmounted cleanly&quot;</span>);

<span class="enscript-comment">/*
 * Common code for mount and mountroot
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_mountfs</span>(<span class="enscript-type">struct</span> vnode *devvp, <span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> hfs_mount_args *args,
            <span class="enscript-type">int</span> journal_replay_only, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">int</span> retval = E_NONE;
	<span class="enscript-type">struct</span> hfsmount	*hfsmp = NULL;
	<span class="enscript-type">struct</span> buf *bp;
	dev_t dev;
	HFSMasterDirectoryBlock *mdbp = NULL;
	<span class="enscript-type">int</span> ronly;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> i;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> mntwrapper;
	kauth_cred_t cred;
	u_int64_t disksize;
	daddr64_t log_blkcnt;
	u_int32_t log_blksize;
	u_int32_t phys_blksize;
	u_int32_t minblksize;
	u_int32_t iswritable;
	daddr64_t mdb_offset;
	<span class="enscript-type">int</span> isvirtual = 0;
	<span class="enscript-type">int</span> isroot = 0;
	u_int32_t device_features = 0;
	<span class="enscript-type">int</span> isssd;
	
	<span class="enscript-keyword">if</span> (args == NULL) {
		<span class="enscript-comment">/* only hfs_mountroot passes us NULL as the 'args' argument */</span>
		isroot = 1;
	}

	ronly = vfs_isrdonly(mp);
	dev = vnode_specrdev(devvp);
	cred = p ? vfs_context_ucred(context) : NOCRED;
	mntwrapper = 0;

	bp = NULL;
	hfsmp = NULL;
	mdbp = NULL;
	minblksize = kHFSBlockSize;

	<span class="enscript-comment">/* Advisory locking should be handled at the VFS layer */</span>
	vfs_setlocklocal(mp);

	<span class="enscript-comment">/* Get the logical block size (treated as physical block size everywhere) */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;log_blksize, 0, context)) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETBLOCKSIZE failed\n&quot;</span>);
		}
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	<span class="enscript-keyword">if</span> (log_blksize == 0 || log_blksize &gt; 1024*1024*1024) {
		printf(<span class="enscript-string">&quot;hfs: logical block size 0x%x looks bad.  Not mounting.\n&quot;</span>, log_blksize);
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	
	<span class="enscript-comment">/* Get the physical block size. */</span>
	retval = VNOP_IOCTL(devvp, DKIOCGETPHYSICALBLOCKSIZE, (caddr_t)&amp;phys_blksize, 0, context);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> ((retval != ENOTSUP) &amp;&amp; (retval != ENOTTY)) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETPHYSICALBLOCKSIZE failed\n&quot;</span>);
			}
			retval = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}
		<span class="enscript-comment">/* If device does not support this ioctl, assume that physical 
		 * block size is same as logical block size 
		 */</span>
		phys_blksize = log_blksize;
	}
	<span class="enscript-keyword">if</span> (phys_blksize == 0 || phys_blksize &gt; MAXBSIZE) {
		printf(<span class="enscript-string">&quot;hfs: physical block size 0x%x looks bad.  Not mounting.\n&quot;</span>, phys_blksize);
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	<span class="enscript-comment">/* Switch to 512 byte sectors (temporarily) */</span>
	<span class="enscript-keyword">if</span> (log_blksize &gt; 512) {
		u_int32_t size512 = 512;

		<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;size512, FWRITE, context)) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCSETBLOCKSIZE failed \n&quot;</span>);
			}
			retval = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}
	}
	<span class="enscript-comment">/* Get the number of 512 byte physical blocks. */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT, (caddr_t)&amp;log_blkcnt, 0, context)) {
		<span class="enscript-comment">/* resetting block size may fail if getting block count did */</span>
		(<span class="enscript-type">void</span>)VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;log_blksize, FWRITE, context);
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETBLOCKCOUNT failed\n&quot;</span>);
		}
		retval = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	<span class="enscript-comment">/* Compute an accurate disk size (i.e. within 512 bytes) */</span>
	disksize = (u_int64_t)log_blkcnt * (u_int64_t)512;

	<span class="enscript-comment">/*
	 * On Tiger it is not necessary to switch the device 
	 * block size to be 4k if there are more than 31-bits
	 * worth of blocks but to insure compatibility with
	 * pre-Tiger systems we have to do it.
	 *
	 * If the device size is not a multiple of 4K (8 * 512), then
	 * switching the logical block size isn't going to help because
	 * we will be unable to write the alternate volume header.
	 * In this case, just leave the logical block size unchanged.
	 */</span>
	<span class="enscript-keyword">if</span> (log_blkcnt &gt; 0x000000007fffffff &amp;&amp; (log_blkcnt &amp; 7) == 0) {
		minblksize = log_blksize = 4096;
		<span class="enscript-keyword">if</span> (phys_blksize &lt; log_blksize)
			phys_blksize = log_blksize;
	}
	
	<span class="enscript-comment">/*
	 * The cluster layer is not currently prepared to deal with a logical
	 * block size larger than the system's page size.  (It can handle 
	 * blocks per page, but not multiple pages per block.)  So limit the
	 * logical block size to the page size.
	 */</span>
	<span class="enscript-keyword">if</span> (log_blksize &gt; PAGE_SIZE) {
		log_blksize = PAGE_SIZE;
	}

	<span class="enscript-comment">/* Now switch to our preferred physical block size. */</span>
	<span class="enscript-keyword">if</span> (log_blksize &gt; 512) {
		<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;log_blksize, FWRITE, context)) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
				printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCSETBLOCKSIZE (2) failed\n&quot;</span>);
			}
			retval = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}
		<span class="enscript-comment">/* Get the count of physical blocks. */</span>
		<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT, (caddr_t)&amp;log_blkcnt, 0, context)) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
				printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETBLOCKCOUNT (2) failed\n&quot;</span>);
			}
			retval = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}
	}
	<span class="enscript-comment">/*
	 * At this point:
	 *   minblksize is the minimum physical block size
	 *   log_blksize has our preferred physical block size
	 *   log_blkcnt has the total number of physical blocks
	 */</span>

	mdb_offset = (daddr64_t)HFS_PRI_SECTOR(log_blksize);
	<span class="enscript-keyword">if</span> ((retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp, 
				HFS_PHYSBLK_ROUNDDOWN(mdb_offset, (phys_blksize/log_blksize)), 
				phys_blksize, cred, &amp;bp))) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mountfs: buf_meta_bread failed with %d\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	MALLOC(mdbp, HFSMasterDirectoryBlock *, kMDBSize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (mdbp == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
			printf(<span class="enscript-string">&quot;hfs_mountfs: MALLOC failed\n&quot;</span>);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	bcopy((<span class="enscript-type">char</span> *)buf_dataptr(bp) + HFS_PRI_OFFSET(phys_blksize), mdbp, kMDBSize);
	buf_brelse(bp);
	bp = NULL;

	MALLOC(hfsmp, <span class="enscript-type">struct</span> hfsmount *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsmount), M_HFSMNT, M_WAITOK);
	<span class="enscript-keyword">if</span> (hfsmp == NULL) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
			printf(<span class="enscript-string">&quot;hfs_mountfs: MALLOC (2) failed\n&quot;</span>);
		}
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}
	bzero(hfsmp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsmount));
	
	hfs_chashinit_finish(hfsmp);
	
	<span class="enscript-comment">/* Init the ID lookup hashtable */</span>
	hfs_idhash_init (hfsmp);

	<span class="enscript-comment">/*
	 * See if the disk supports unmap (trim).
	 *
	 * NOTE: vfs_init_io_attributes has not been called yet, so we can't use the io_flags field
	 * returned by vfs_ioattr.  We need to call VNOP_IOCTL ourselves.
	 */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETFEATURES, (caddr_t)&amp;device_features, 0, context) == 0) {
		<span class="enscript-keyword">if</span> (device_features &amp; DK_FEATURE_UNMAP) {
			hfsmp-&gt;hfs_flags |= HFS_UNMAP;
		}

		<span class="enscript-keyword">if</span>(device_features &amp; DK_FEATURE_BARRIER)
			hfsmp-&gt;hfs_flags |= HFS_FEATURE_BARRIER;
	}

	<span class="enscript-comment">/* 
	 * See if the disk is a solid state device, too.  We need this to decide what to do about 
	 * hotfiles.
	 */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCISSOLIDSTATE, (caddr_t)&amp;isssd, 0, context) == 0) {
		<span class="enscript-keyword">if</span> (isssd) {
			hfsmp-&gt;hfs_flags |= HFS_SSD;
		}
	}

	<span class="enscript-comment">/* See if the underlying device is Core Storage or not */</span>
	dk_corestorage_info_t cs_info;
	memset(&amp;cs_info, 0, <span class="enscript-keyword">sizeof</span>(dk_corestorage_info_t));
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCCORESTORAGE, (caddr_t)&amp;cs_info, 0, context) == 0) {
		hfsmp-&gt;hfs_flags |= HFS_CS;
		<span class="enscript-keyword">if</span> (isroot &amp;&amp; (cs_info.flags &amp; DK_CORESTORAGE_PIN_YOUR_METADATA)) {
			hfsmp-&gt;hfs_flags |= HFS_CS_METADATA_PIN;
		}
		<span class="enscript-keyword">if</span> (isroot &amp;&amp; (cs_info.flags &amp; DK_CORESTORAGE_ENABLE_HOTFILES)) {
			hfsmp-&gt;hfs_flags |= HFS_CS_HOTFILE_PIN;
			hfsmp-&gt;hfs_cs_hotfile_size = cs_info.hotfile_size;
		}
		<span class="enscript-keyword">if</span> ((cs_info.flags &amp; DK_CORESTORAGE_PIN_YOUR_SWAPFILE)) {
			hfsmp-&gt;hfs_flags |= HFS_CS_SWAPFILE_PIN;

			mp-&gt;mnt_ioflags |= MNT_IOFLAGS_SWAPPIN_SUPPORTED;
			mp-&gt;mnt_max_swappin_available = cs_info.swapfile_pinning;
		}
	}

	<span class="enscript-comment">/*
	 *  Init the volume information structure
	 */</span>
	
	lck_mtx_init(&amp;hfsmp-&gt;hfs_mutex, hfs_mutex_group, hfs_lock_attr);
	lck_mtx_init(&amp;hfsmp-&gt;hfc_mutex, hfs_mutex_group, hfs_lock_attr);
	lck_rw_init(&amp;hfsmp-&gt;hfs_global_lock, hfs_rwlock_group, hfs_lock_attr);
	lck_spin_init(&amp;hfsmp-&gt;vcbFreeExtLock, hfs_spinlock_group, hfs_lock_attr);
	
	vfs_setfsprivate(mp, hfsmp);
	hfsmp-&gt;hfs_mp = mp;			<span class="enscript-comment">/* Make VFSTOHFS work */</span>
	hfsmp-&gt;hfs_raw_dev = vnode_specrdev(devvp);
	hfsmp-&gt;hfs_devvp = devvp;
	vnode_ref(devvp);  <span class="enscript-comment">/* Hold a ref on the device, dropped when hfsmp is freed. */</span>
	hfsmp-&gt;hfs_logical_block_size = log_blksize;
	hfsmp-&gt;hfs_logical_block_count = log_blkcnt;
	hfsmp-&gt;hfs_logical_bytes = (uint64_t) log_blksize * (uint64_t) log_blkcnt;
	hfsmp-&gt;hfs_physical_block_size = phys_blksize;
	hfsmp-&gt;hfs_log_per_phys = (phys_blksize / log_blksize);
	hfsmp-&gt;hfs_flags |= HFS_WRITEABLE_MEDIA;
	<span class="enscript-keyword">if</span> (ronly)
		hfsmp-&gt;hfs_flags |= HFS_READ_ONLY;
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(mp)) &amp; MNT_UNKNOWNPERMISSIONS)
		hfsmp-&gt;hfs_flags |= HFS_UNKNOWN_PERMS;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++)
		dqfileinit(&amp;hfsmp-&gt;hfs_qfiles[i]);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (args) {
		hfsmp-&gt;hfs_uid = (args-&gt;hfs_uid == (uid_t)VNOVAL) ? UNKNOWNUID : args-&gt;hfs_uid;
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_uid == 0xfffffffd) hfsmp-&gt;hfs_uid = UNKNOWNUID;
		hfsmp-&gt;hfs_gid = (args-&gt;hfs_gid == (gid_t)VNOVAL) ? UNKNOWNGID : args-&gt;hfs_gid;
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_gid == 0xfffffffd) hfsmp-&gt;hfs_gid = UNKNOWNGID;
		vfs_setowner(mp, hfsmp-&gt;hfs_uid, hfsmp-&gt;hfs_gid);				<span class="enscript-comment">/* tell the VFS */</span>
		<span class="enscript-keyword">if</span> (args-&gt;hfs_mask != (mode_t)VNOVAL) {
			hfsmp-&gt;hfs_dir_mask = args-&gt;hfs_mask &amp; ALLPERMS;
			<span class="enscript-keyword">if</span> (args-&gt;flags &amp; HFSFSMNT_NOXONFILES) {
				hfsmp-&gt;hfs_file_mask = (args-&gt;hfs_mask &amp; DEFFILEMODE);
			} <span class="enscript-keyword">else</span> {
				hfsmp-&gt;hfs_file_mask = args-&gt;hfs_mask &amp; ALLPERMS;
			}
		} <span class="enscript-keyword">else</span> {
			hfsmp-&gt;hfs_dir_mask = UNKNOWNPERMISSIONS &amp; ALLPERMS;		<span class="enscript-comment">/* 0777: rwx---rwx */</span>
			hfsmp-&gt;hfs_file_mask = UNKNOWNPERMISSIONS &amp; DEFFILEMODE;	<span class="enscript-comment">/* 0666: no --x by default? */</span>
		}
		<span class="enscript-keyword">if</span> ((args-&gt;flags != (<span class="enscript-type">int</span>)VNOVAL) &amp;&amp; (args-&gt;flags &amp; HFSFSMNT_WRAPPER))
			mntwrapper = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Even w/o explicit mount arguments, MNT_UNKNOWNPERMISSIONS requires setting up uid, gid, and mask: */</span>
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(mp)) &amp; MNT_UNKNOWNPERMISSIONS) {
			hfsmp-&gt;hfs_uid = UNKNOWNUID;
			hfsmp-&gt;hfs_gid = UNKNOWNGID;
			vfs_setowner(mp, hfsmp-&gt;hfs_uid, hfsmp-&gt;hfs_gid);			<span class="enscript-comment">/* tell the VFS */</span>
			hfsmp-&gt;hfs_dir_mask = UNKNOWNPERMISSIONS &amp; ALLPERMS;		<span class="enscript-comment">/* 0777: rwx---rwx */</span>
			hfsmp-&gt;hfs_file_mask = UNKNOWNPERMISSIONS &amp; DEFFILEMODE;	<span class="enscript-comment">/* 0666: no --x by default? */</span>
		}
	}

	<span class="enscript-comment">/* Find out if disk media is writable. */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCISWRITABLE, (caddr_t)&amp;iswritable, 0, context) == 0) {
		<span class="enscript-keyword">if</span> (iswritable)
			hfsmp-&gt;hfs_flags |= HFS_WRITEABLE_MEDIA;
		<span class="enscript-keyword">else</span>
			hfsmp-&gt;hfs_flags &amp;= ~HFS_WRITEABLE_MEDIA;
	}

	<span class="enscript-comment">// Reservations
</span>	rl_init(&amp;hfsmp-&gt;hfs_reserved_ranges[0]);
	rl_init(&amp;hfsmp-&gt;hfs_reserved_ranges[1]);

	<span class="enscript-comment">// record the current time at which we're mounting this volume
</span>	<span class="enscript-type">struct</span> timeval tv;
	microtime(&amp;tv);
	hfsmp-&gt;hfs_mount_time = tv.tv_sec;

	<span class="enscript-comment">/* Mount a standard HFS disk */</span>
	<span class="enscript-keyword">if</span> ((SWAP_BE16(mdbp-&gt;drSigWord) == kHFSSigWord) &amp;&amp;
	    (mntwrapper || (SWAP_BE16(mdbp-&gt;drEmbedSigWord) != kHFSPlusSigWord))) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span> 
		<span class="enscript-comment">/* On 10.6 and beyond, non read-only mounts for HFS standard vols get rejected */</span>
		<span class="enscript-keyword">if</span> (vfs_isrdwr(mp)) {
			retval = EROFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}

		printf(<span class="enscript-string">&quot;hfs_mountfs: Mounting HFS Standard volumes was deprecated in Mac OS 10.7 \n&quot;</span>);

		<span class="enscript-comment">/* Treat it as if it's read-only and not writeable */</span>
		hfsmp-&gt;hfs_flags |= HFS_READ_ONLY;
		hfsmp-&gt;hfs_flags &amp;= ~HFS_WRITEABLE_MEDIA;

	   	<span class="enscript-comment">/* If only journal replay is requested, exit immediately */</span>
		<span class="enscript-keyword">if</span> (journal_replay_only) {
			retval = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}

	        <span class="enscript-keyword">if</span> ((vfs_flags(mp) &amp; MNT_ROOTFS)) {	
			retval = EINVAL;  <span class="enscript-comment">/* Cannot root from HFS standard disks */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}
		<span class="enscript-comment">/* HFS disks can only use 512 byte physical blocks */</span>
		<span class="enscript-keyword">if</span> (log_blksize &gt; kHFSBlockSize) {
			log_blksize = kHFSBlockSize;
			<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;log_blksize, FWRITE, context)) {
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
			}
			<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT, (caddr_t)&amp;log_blkcnt, 0, context)) {
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
			}
			hfsmp-&gt;hfs_logical_block_size = log_blksize;
			hfsmp-&gt;hfs_logical_block_count = log_blkcnt;
			hfsmp-&gt;hfs_logical_bytes = (uint64_t) log_blksize * (uint64_t) log_blkcnt;
			hfsmp-&gt;hfs_physical_block_size = log_blksize;
			hfsmp-&gt;hfs_log_per_phys = 1;
		}
		<span class="enscript-keyword">if</span> (args) {
			hfsmp-&gt;hfs_encoding = args-&gt;hfs_encoding;
			HFSTOVCB(hfsmp)-&gt;volumeNameEncodingHint = args-&gt;hfs_encoding;

			<span class="enscript-comment">/* establish the timezone */</span>
			gTimeZone = args-&gt;hfs_timezone;
		}

		retval = hfs_getconverter(hfsmp-&gt;hfs_encoding, &amp;hfsmp-&gt;hfs_get_unicode,
					&amp;hfsmp-&gt;hfs_get_hfsname);
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;

		retval = hfs_MountHFSVolume(hfsmp, mdbp, p);
		<span class="enscript-keyword">if</span> (retval)
			(<span class="enscript-type">void</span>) hfs_relconverter(hfsmp-&gt;hfs_encoding);
#<span class="enscript-reference">else</span>
		<span class="enscript-comment">/* On platforms where HFS Standard is not supported, deny the mount altogether */</span>
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
#<span class="enscript-reference">endif</span>

	} 
	<span class="enscript-keyword">else</span> { <span class="enscript-comment">/* Mount an HFS Plus disk */</span>
		HFSPlusVolumeHeader *vhp;
		off_t embeddedOffset;
		<span class="enscript-type">int</span>   jnl_disable = 0;
	
		<span class="enscript-comment">/* Get the embedded Volume Header */</span>
		<span class="enscript-keyword">if</span> (SWAP_BE16(mdbp-&gt;drEmbedSigWord) == kHFSPlusSigWord) {
			embeddedOffset = SWAP_BE16(mdbp-&gt;drAlBlSt) * kHFSBlockSize;
			embeddedOffset += (u_int64_t)SWAP_BE16(mdbp-&gt;drEmbedExtent.startBlock) *
			                  (u_int64_t)SWAP_BE32(mdbp-&gt;drAlBlkSiz);

			<span class="enscript-comment">/* 
			 * Cooperative Fusion is not allowed on embedded HFS+ 
			 * filesystems (HFS+ inside HFS standard wrapper)
			 */</span>
			hfsmp-&gt;hfs_flags &amp;= ~HFS_CS_METADATA_PIN;

			<span class="enscript-comment">/*
			 * If the embedded volume doesn't start on a block
			 * boundary, then switch the device to a 512-byte
			 * block size so everything will line up on a block
			 * boundary.
			 */</span>
			<span class="enscript-keyword">if</span> ((embeddedOffset % log_blksize) != 0) {
				printf(<span class="enscript-string">&quot;hfs_mountfs: embedded volume offset not&quot;</span>
				    <span class="enscript-string">&quot; a multiple of physical block size (%d);&quot;</span>
				    <span class="enscript-string">&quot; switching to 512\n&quot;</span>, log_blksize);
				log_blksize = 512;
				<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE,
				    (caddr_t)&amp;log_blksize, FWRITE, context)) {

					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
						printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCSETBLOCKSIZE (3) failed\n&quot;</span>);
					}				
					retval = ENXIO;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
				}
				<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT,
				    (caddr_t)&amp;log_blkcnt, 0, context)) {
					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
						printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETBLOCKCOUNT (3) failed\n&quot;</span>);
					}
					retval = ENXIO;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
				}
				<span class="enscript-comment">/* Note: relative block count adjustment */</span>
				hfsmp-&gt;hfs_logical_block_count *=
				    hfsmp-&gt;hfs_logical_block_size / log_blksize;
				
				<span class="enscript-comment">/* Update logical /physical block size */</span>
				hfsmp-&gt;hfs_logical_block_size = log_blksize;
				hfsmp-&gt;hfs_physical_block_size = log_blksize;
				
				phys_blksize = log_blksize;
				hfsmp-&gt;hfs_log_per_phys = 1;
			}

			disksize = (u_int64_t)SWAP_BE16(mdbp-&gt;drEmbedExtent.blockCount) *
			           (u_int64_t)SWAP_BE32(mdbp-&gt;drAlBlkSiz);

			hfsmp-&gt;hfs_logical_block_count = disksize / log_blksize;
	
			hfsmp-&gt;hfs_logical_bytes = (uint64_t) hfsmp-&gt;hfs_logical_block_count * (uint64_t) hfsmp-&gt;hfs_logical_block_size;
			
			mdb_offset = (daddr64_t)((embeddedOffset / log_blksize) + HFS_PRI_SECTOR(log_blksize));

			<span class="enscript-keyword">if</span> (bp) {
				buf_markinvalid(bp);
				buf_brelse(bp);
				bp = NULL;
			}
			retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp, HFS_PHYSBLK_ROUNDDOWN(mdb_offset, hfsmp-&gt;hfs_log_per_phys),
					phys_blksize, cred, &amp;bp);
			<span class="enscript-keyword">if</span> (retval) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
					printf(<span class="enscript-string">&quot;hfs_mountfs: buf_meta_bread (2) failed with %d\n&quot;</span>, retval);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
			}
			bcopy((<span class="enscript-type">char</span> *)buf_dataptr(bp) + HFS_PRI_OFFSET(phys_blksize), mdbp, 512);
			buf_brelse(bp);
			bp = NULL;
			vhp = (HFSPlusVolumeHeader*) mdbp;

		} 
		<span class="enscript-keyword">else</span> { <span class="enscript-comment">/* pure HFS+ */</span> 
			embeddedOffset = 0;
			vhp = (HFSPlusVolumeHeader*) mdbp;
		}

		retval = hfs_ValidateHFSPlusVolumeHeader(hfsmp, vhp);
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;

		<span class="enscript-comment">/*
		 * If allocation block size is less than the physical block size,
		 * invalidate the buffer read in using native physical block size
		 * to ensure data consistency.
		 *
		 * HFS Plus reserves one allocation block for the Volume Header.
		 * If the physical size is larger, then when we read the volume header,
		 * we will also end up reading in the next allocation block(s).
		 * If those other allocation block(s) is/are modified, and then the volume
		 * header is modified, the write of the volume header's buffer will write
		 * out the old contents of the other allocation blocks.
		 *
		 * We assume that the physical block size is same as logical block size.
		 * The physical block size value is used to round down the offsets for
		 * reading and writing the primary and alternate volume headers.
		 *
		 * The same logic is also in hfs_MountHFSPlusVolume to ensure that
		 * hfs_mountfs, hfs_MountHFSPlusVolume and later are doing the I/Os
		 * using same block size.
		 */</span>
		<span class="enscript-keyword">if</span> (SWAP_BE32(vhp-&gt;blockSize) &lt; hfsmp-&gt;hfs_physical_block_size) {
			phys_blksize = hfsmp-&gt;hfs_logical_block_size;
			hfsmp-&gt;hfs_physical_block_size = hfsmp-&gt;hfs_logical_block_size;
			hfsmp-&gt;hfs_log_per_phys = 1;
			<span class="enscript-comment">// There should be one bp associated with devvp in buffer cache.
</span>			retval = buf_invalidateblks(devvp, 0, 0, 0);
			<span class="enscript-keyword">if</span> (retval)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}

		<span class="enscript-keyword">if</span> (isroot) {
			hfs_root_unmounted_cleanly = ((SWAP_BE32(vhp-&gt;attributes) &amp; kHFSVolumeUnmountedMask) != 0);
		}

		<span class="enscript-comment">/*
		 * On inconsistent disks, do not allow read-write mount
		 * unless it is the boot volume being mounted.  We also
		 * always want to replay the journal if the journal_replay_only
		 * flag is set because that will (most likely) get the
		 * disk into a consistent state before fsck_hfs starts
		 * looking at it.
		 */</span>
		<span class="enscript-keyword">if</span> (  !(vfs_flags(mp) &amp; MNT_ROOTFS)
		   &amp;&amp; (SWAP_BE32(vhp-&gt;attributes) &amp; kHFSVolumeInconsistentMask)
		   &amp;&amp; !journal_replay_only
		   &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY)) {
			
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
				printf(<span class="enscript-string">&quot;hfs_mountfs: failed to mount non-root inconsistent disk\n&quot;</span>);
			}
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}


		<span class="enscript-comment">// XXXdbg
</span>		<span class="enscript-comment">//
</span>		hfsmp-&gt;jnl = NULL;
		hfsmp-&gt;jvp = NULL;
		<span class="enscript-keyword">if</span> (args != NULL &amp;&amp; (args-&gt;flags &amp; HFSFSMNT_EXTENDED_ARGS) &amp;&amp; 
		    args-&gt;journal_disable) {
		    jnl_disable = 1;
		}
				
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// We only initialize the journal here if the last person
</span>		<span class="enscript-comment">// to mount this volume was journaling aware.  Otherwise
</span>		<span class="enscript-comment">// we delay journal initialization until later at the end
</span>		<span class="enscript-comment">// of hfs_MountHFSPlusVolume() because the last person who
</span>		<span class="enscript-comment">// mounted it could have messed things up behind our back
</span>		<span class="enscript-comment">// (so we need to go find the .journal file, make sure it's
</span>		<span class="enscript-comment">// the right size, re-sync up if it was moved, etc).
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (   (SWAP_BE32(vhp-&gt;lastMountedVersion) == kHFSJMountVersion)
			&amp;&amp; (SWAP_BE32(vhp-&gt;attributes) &amp; kHFSVolumeJournaledMask)
			&amp;&amp; !jnl_disable) {
			
			<span class="enscript-comment">// if we're able to init the journal, mark the mount
</span>			<span class="enscript-comment">// point as journaled.
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">if</span> ((retval = hfs_early_journal_init(hfsmp, vhp, args, embeddedOffset, mdb_offset, mdbp, cred)) == 0) {
				vfs_setflags(mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (retval == EROFS) {
					<span class="enscript-comment">// EROFS is a special error code that means the volume has an external
</span>					<span class="enscript-comment">// journal which we couldn't find.  in that case we do not want to
</span>					<span class="enscript-comment">// rewrite the volume header - we'll just refuse to mount the volume.
</span>					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
						printf(<span class="enscript-string">&quot;hfs_mountfs: hfs_early_journal_init indicated external jnl \n&quot;</span>);
					}
					retval = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
				}

				<span class="enscript-comment">// if the journal failed to open, then set the lastMountedVersion
</span>				<span class="enscript-comment">// to be &quot;FSK!&quot; which fsck_hfs will see and force the fsck instead
</span>				<span class="enscript-comment">// of just bailing out because the volume is journaled.
</span>				<span class="enscript-keyword">if</span> (!ronly) {
					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
						printf(<span class="enscript-string">&quot;hfs_mountfs: hfs_early_journal_init failed, setting to FSK \n&quot;</span>);
					}

					HFSPlusVolumeHeader *jvhp;

				    hfsmp-&gt;hfs_flags |= HFS_NEED_JNL_RESET;
				    
				    <span class="enscript-keyword">if</span> (mdb_offset == 0) {
					mdb_offset = (daddr64_t)((embeddedOffset / log_blksize) + HFS_PRI_SECTOR(log_blksize));
				    }

				    bp = NULL;
				    retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp, 
						    HFS_PHYSBLK_ROUNDDOWN(mdb_offset, hfsmp-&gt;hfs_log_per_phys), 
						    phys_blksize, cred, &amp;bp);
				    <span class="enscript-keyword">if</span> (retval == 0) {
					jvhp = (HFSPlusVolumeHeader *)(buf_dataptr(bp) + HFS_PRI_OFFSET(phys_blksize));
					    
					<span class="enscript-keyword">if</span> (SWAP_BE16(jvhp-&gt;signature) == kHFSPlusSigWord || SWAP_BE16(jvhp-&gt;signature) == kHFSXSigWord) {
						printf (<span class="enscript-string">&quot;hfs(1): Journal replay fail.  Writing lastMountVersion as FSK!\n&quot;</span>);
					    jvhp-&gt;lastMountedVersion = SWAP_BE32(kFSKMountVersion);
					    buf_bwrite(bp);
					} <span class="enscript-keyword">else</span> {
					    buf_brelse(bp);
					}
					bp = NULL;
				    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
					buf_brelse(bp);
					<span class="enscript-comment">// clear this so the error exit path won't try to use it
</span>					bp = NULL;
				    }
				}

				<span class="enscript-comment">// if this isn't the root device just bail out.
</span>				<span class="enscript-comment">// If it is the root device we just continue on
</span>				<span class="enscript-comment">// in the hopes that fsck_hfs will be able to
</span>				<span class="enscript-comment">// fix any damage that exists on the volume.
</span>				<span class="enscript-keyword">if</span> ( !(vfs_flags(mp) &amp; MNT_ROOTFS)) {
					<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
						printf(<span class="enscript-string">&quot;hfs_mountfs: hfs_early_journal_init failed, erroring out \n&quot;</span>);
					}
				    retval = EINVAL;
				    <span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
				}
			}
		}
		<span class="enscript-comment">// XXXdbg
</span>	
		<span class="enscript-comment">/* Either the journal is replayed successfully, or there 
		 * was nothing to replay, or no journal exists.  In any case,
		 * return success.
		 */</span>
		<span class="enscript-keyword">if</span> (journal_replay_only) {
			retval = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
		}

		(<span class="enscript-type">void</span>) hfs_getconverter(0, &amp;hfsmp-&gt;hfs_get_unicode, &amp;hfsmp-&gt;hfs_get_hfsname);

		retval = hfs_MountHFSPlusVolume(hfsmp, vhp, embeddedOffset, disksize, p, args, cred);
		<span class="enscript-comment">/*
		 * If the backend didn't like our physical blocksize
		 * then retry with physical blocksize of 512.
		 */</span>
		<span class="enscript-keyword">if</span> ((retval == ENXIO) &amp;&amp; (log_blksize &gt; 512) &amp;&amp; (log_blksize != minblksize)) {
			printf(<span class="enscript-string">&quot;hfs_mountfs: could not use physical block size &quot;</span>
					<span class="enscript-string">&quot;(%d) switching to 512\n&quot;</span>, log_blksize);
			log_blksize = 512;
			<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCSETBLOCKSIZE, (caddr_t)&amp;log_blksize, FWRITE, context)) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
					printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCSETBLOCKSIZE (4) failed \n&quot;</span>);
				}
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
			}
			<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT, (caddr_t)&amp;log_blkcnt, 0, context)) {
				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
					printf(<span class="enscript-string">&quot;hfs_mountfs: DKIOCGETBLOCKCOUNT (4) failed \n&quot;</span>);
				}
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
			}
			devvp-&gt;v_specsize = log_blksize;
			<span class="enscript-comment">/* Note: relative block count adjustment (in case this is an embedded volume). */</span>
			hfsmp-&gt;hfs_logical_block_count *= hfsmp-&gt;hfs_logical_block_size / log_blksize;
			hfsmp-&gt;hfs_logical_block_size = log_blksize;
			hfsmp-&gt;hfs_log_per_phys = hfsmp-&gt;hfs_physical_block_size / log_blksize;
	
			hfsmp-&gt;hfs_logical_bytes = (uint64_t) hfsmp-&gt;hfs_logical_block_count * (uint64_t) hfsmp-&gt;hfs_logical_block_size;

			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; hfsmp-&gt;jvp == devvp) {
			    <span class="enscript-comment">// close and re-open this with the new block size
</span>			    journal_close(hfsmp-&gt;jnl);
			    hfsmp-&gt;jnl = NULL;
			    <span class="enscript-keyword">if</span> (hfs_early_journal_init(hfsmp, vhp, args, embeddedOffset, mdb_offset, mdbp, cred) == 0) {
					vfs_setflags(mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// if the journal failed to open, then set the lastMountedVersion
</span>					<span class="enscript-comment">// to be &quot;FSK!&quot; which fsck_hfs will see and force the fsck instead
</span>					<span class="enscript-comment">// of just bailing out because the volume is journaled.
</span>					<span class="enscript-keyword">if</span> (!ronly) {
						<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
							printf(<span class="enscript-string">&quot;hfs_mountfs: hfs_early_journal_init (2) resetting.. \n&quot;</span>);
						}
				    	HFSPlusVolumeHeader *jvhp;

				    	hfsmp-&gt;hfs_flags |= HFS_NEED_JNL_RESET;
				    
				    	<span class="enscript-keyword">if</span> (mdb_offset == 0) {
							mdb_offset = (daddr64_t)((embeddedOffset / log_blksize) + HFS_PRI_SECTOR(log_blksize));
				    	}

				   	 	bp = NULL;
				    	retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp, HFS_PHYSBLK_ROUNDDOWN(mdb_offset, hfsmp-&gt;hfs_log_per_phys), 
							phys_blksize, cred, &amp;bp);
				    	<span class="enscript-keyword">if</span> (retval == 0) {
							jvhp = (HFSPlusVolumeHeader *)(buf_dataptr(bp) + HFS_PRI_OFFSET(phys_blksize));
					    
							<span class="enscript-keyword">if</span> (SWAP_BE16(jvhp-&gt;signature) == kHFSPlusSigWord || SWAP_BE16(jvhp-&gt;signature) == kHFSXSigWord) {
								printf (<span class="enscript-string">&quot;hfs(2): Journal replay fail.  Writing lastMountVersion as FSK!\n&quot;</span>);
					    		jvhp-&gt;lastMountedVersion = SWAP_BE32(kFSKMountVersion);
					    		buf_bwrite(bp);
							} <span class="enscript-keyword">else</span> {
					    		buf_brelse(bp);
							}
							bp = NULL;
				    	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
							buf_brelse(bp);
							<span class="enscript-comment">// clear this so the error exit path won't try to use it
</span>							bp = NULL;
				    	}
					}

					<span class="enscript-comment">// if this isn't the root device just bail out.
</span>					<span class="enscript-comment">// If it is the root device we just continue on
</span>					<span class="enscript-comment">// in the hopes that fsck_hfs will be able to
</span>					<span class="enscript-comment">// fix any damage that exists on the volume.
</span>					<span class="enscript-keyword">if</span> ( !(vfs_flags(mp) &amp; MNT_ROOTFS)) {
						<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
							printf(<span class="enscript-string">&quot;hfs_mountfs: hfs_early_journal_init (2) failed \n&quot;</span>);
						}
				    	retval = EINVAL;
				    	<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
					}
				}
			}

			<span class="enscript-comment">/* Try again with a smaller block size... */</span>
			retval = hfs_MountHFSPlusVolume(hfsmp, vhp, embeddedOffset, disksize, p, args, cred);
			<span class="enscript-keyword">if</span> (retval &amp;&amp; HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_MountHFSPlusVolume (late) returned %d\n&quot;</span>,retval); 
			}
		}
		<span class="enscript-keyword">if</span> (retval)
			(<span class="enscript-type">void</span>) hfs_relconverter(0);
	}

	<span class="enscript-comment">// save off a snapshot of the mtime from the previous mount
</span>	<span class="enscript-comment">// (for matador).
</span>	hfsmp-&gt;hfs_last_mounted_mtime = hfsmp-&gt;hfs_mtime;

	<span class="enscript-keyword">if</span> ( retval ) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) { 
			printf(<span class="enscript-string">&quot;hfs_mountfs: encountered failure %d \n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_exit</span>;
	}

	mp-&gt;mnt_vfsstat.f_fsid.val[0] = dev;
	mp-&gt;mnt_vfsstat.f_fsid.val[1] = vfs_typenum(mp);
	vfs_setmaxsymlen(mp, 0);

	mp-&gt;mnt_vtable-&gt;vfc_vfsflags |= VFC_VFSNATIVEXATTR;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	mp-&gt;mnt_kern_flag |= MNTK_NAMED_STREAMS;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0 ) {
		<span class="enscript-comment">/* Tell VFS that we support directory hard links. */</span>
		mp-&gt;mnt_vtable-&gt;vfc_vfsflags |= VFC_VFSDIRLINKS;
	} 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* HFS standard doesn't support extended readdir! */</span>
		mount_set_noreaddirext (mp);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (args) {
		<span class="enscript-comment">/*
		 * Set the free space warning levels for a non-root volume:
		 *
		 * Set the &quot;danger&quot; limit to 1% of the volume size or 100MB, whichever
		 * is less.  Set the &quot;warning&quot; limit to 2% of the volume size or 150MB,
		 * whichever is less.  And last, set the &quot;desired&quot; freespace level to
		 * to 3% of the volume size or 200MB, whichever is less.
		 */</span>
		hfsmp-&gt;hfs_freespace_notify_dangerlimit =
			MIN(HFS_VERYLOWDISKTRIGGERLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_VERYLOWDISKTRIGGERFRACTION);
		hfsmp-&gt;hfs_freespace_notify_warninglimit =
			MIN(HFS_LOWDISKTRIGGERLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_LOWDISKTRIGGERFRACTION);
		hfsmp-&gt;hfs_freespace_notify_desiredlevel =
			MIN(HFS_LOWDISKSHUTOFFLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_LOWDISKSHUTOFFFRACTION);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Set the free space warning levels for the root volume:
		 *
		 * Set the &quot;danger&quot; limit to 5% of the volume size or 512MB, whichever
		 * is less.  Set the &quot;warning&quot; limit to 10% of the volume size or 1GB,
		 * whichever is less.  And last, set the &quot;desired&quot; freespace level to
		 * to 11% of the volume size or 1.25GB, whichever is less.
		 */</span>
		hfsmp-&gt;hfs_freespace_notify_dangerlimit =
			MIN(HFS_ROOTVERYLOWDISKTRIGGERLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_ROOTVERYLOWDISKTRIGGERFRACTION);
		hfsmp-&gt;hfs_freespace_notify_warninglimit =
			MIN(HFS_ROOTLOWDISKTRIGGERLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_ROOTLOWDISKTRIGGERFRACTION);
		hfsmp-&gt;hfs_freespace_notify_desiredlevel =
			MIN(HFS_ROOTLOWDISKSHUTOFFLEVEL / HFSTOVCB(hfsmp)-&gt;blockSize,
				(HFSTOVCB(hfsmp)-&gt;totalBlocks / 100) * HFS_ROOTLOWDISKSHUTOFFFRACTION);
	};
	
	<span class="enscript-comment">/* Check if the file system exists on virtual device, like disk image */</span>
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCISVIRTUAL, (caddr_t)&amp;isvirtual, 0, context) == 0) {
		<span class="enscript-keyword">if</span> (isvirtual) {
			hfsmp-&gt;hfs_flags |= HFS_VIRTUAL_DEVICE;
		}
	}

	<span class="enscript-comment">/* do not allow ejectability checks on the root device */</span>
	<span class="enscript-keyword">if</span> (isroot == 0) {
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_VIRTUAL_DEVICE) == 0 &amp;&amp; 
				IOBSDIsMediaEjectable(mp-&gt;mnt_vfsstat.f_mntfromname)) {
			hfsmp-&gt;hfs_syncer = thread_call_allocate(hfs_syncer, hfsmp);
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_syncer == NULL) {
				printf(<span class="enscript-string">&quot;hfs: failed to allocate syncer thread callback for %s (%s)\n&quot;</span>,
						mp-&gt;mnt_vfsstat.f_mntfromname, mp-&gt;mnt_vfsstat.f_mntonname);
			}
		}
	}

	printf(<span class="enscript-string">&quot;hfs: mounted %s on device %s\n&quot;</span>, (hfsmp-&gt;vcbVN ? (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) hfsmp-&gt;vcbVN : <span class="enscript-string">&quot;unknown&quot;</span>),
            (devvp-&gt;v_name ? devvp-&gt;v_name : (isroot ? <span class="enscript-string">&quot;root_device&quot;</span>: <span class="enscript-string">&quot;unknown device&quot;</span>)));

	<span class="enscript-comment">/*
	 * Start looking for free space to drop below this level and generate a
	 * warning immediately if needed:
	 */</span>
	hfsmp-&gt;hfs_notification_conditions = 0;
	hfs_generate_volume_notifications(hfsmp);

	<span class="enscript-keyword">if</span> (ronly == 0) {
		(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
	}
	FREE(mdbp, M_TEMP);
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">error_exit</span>:
	<span class="enscript-keyword">if</span> (bp)
		buf_brelse(bp);
	<span class="enscript-keyword">if</span> (mdbp)
		FREE(mdbp, M_TEMP);

	<span class="enscript-keyword">if</span> (hfsmp &amp;&amp; hfsmp-&gt;jvp &amp;&amp; hfsmp-&gt;jvp != hfsmp-&gt;hfs_devvp) {
		vnode_clearmountedon(hfsmp-&gt;jvp);
		(<span class="enscript-type">void</span>)VNOP_CLOSE(hfsmp-&gt;jvp, ronly ? FREAD : FREAD|FWRITE, vfs_context_kernel());
		hfsmp-&gt;jvp = NULL;
	}
	<span class="enscript-keyword">if</span> (hfsmp) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_devvp) {
			vnode_rele(hfsmp-&gt;hfs_devvp);
		}
		hfs_locks_destroy(hfsmp);
		hfs_delete_chash(hfsmp);
		hfs_idhash_destroy (hfsmp);

		FREE(hfsmp, M_HFSMNT);
		vfs_setfsprivate(mp, NULL);
	}
        <span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-comment">/*
 * Make a filesystem operational.
 * Nothing to do at the moment.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_start</span>(__unused <span class="enscript-type">struct</span> mount *mp, __unused <span class="enscript-type">int</span> flags, __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * unmount system call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_unmount</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> mntflags, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VFSTOHFS(mp);
	<span class="enscript-type">int</span> retval = E_NONE;
	<span class="enscript-type">int</span> flags;
	<span class="enscript-type">int</span> force;
	<span class="enscript-type">int</span> started_tr = 0;

	flags = 0;
	force = 0;
	<span class="enscript-keyword">if</span> (mntflags &amp; MNT_FORCE) {
		flags |= FORCECLOSE;
		force = 1;
	}

	printf(<span class="enscript-string">&quot;hfs: unmount initiated on %s on device %s\n&quot;</span>, 
			(hfsmp-&gt;vcbVN ? (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) hfsmp-&gt;vcbVN : <span class="enscript-string">&quot;unknown&quot;</span>),
			(hfsmp-&gt;hfs_devvp ? ((hfsmp-&gt;hfs_devvp-&gt;v_name ? hfsmp-&gt;hfs_devvp-&gt;v_name : <span class="enscript-string">&quot;unknown device&quot;</span>)) : <span class="enscript-string">&quot;unknown device&quot;</span>));

	<span class="enscript-keyword">if</span> ((retval = hfs_flushfiles(mp, flags, p)) &amp;&amp; !force)
 		<span class="enscript-keyword">return</span> (retval);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE)
		(<span class="enscript-type">void</span>) hfs_recording_suspend(hfsmp);
    
	hfs_syncer_free(hfsmp);
    
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_summary_table) {
			<span class="enscript-type">int</span> err = 0;
			<span class="enscript-comment">/* 
		 	 * Take the bitmap lock to serialize against a concurrent bitmap scan still in progress 
			 */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_vp) {
				err = hfs_lock (VTOC(hfsmp-&gt;hfs_allocation_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			}
			FREE (hfsmp-&gt;hfs_summary_table, M_TEMP);
			hfsmp-&gt;hfs_summary_table = NULL;
			hfsmp-&gt;hfs_flags &amp;= ~HFS_SUMMARY_TABLE;
			
			<span class="enscript-keyword">if</span> (err == 0 &amp;&amp; hfsmp-&gt;hfs_allocation_vp){
				hfs_unlock (VTOC(hfsmp-&gt;hfs_allocation_vp));
			}

		}
	}
	
	<span class="enscript-comment">/*
	 * Flush out the b-trees, volume bitmap and Volume Header
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0) {
		retval = hfs_start_transaction(hfsmp);
		<span class="enscript-keyword">if</span> (retval == 0) {
		    started_tr = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!force) {
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_vp) {
			(<span class="enscript-type">void</span>) hfs_lock(VTOC(hfsmp-&gt;hfs_startup_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			retval = hfs_fsync(hfsmp-&gt;hfs_startup_vp, MNT_WAIT, 0, p);
			hfs_unlock(VTOC(hfsmp-&gt;hfs_startup_vp));
			<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
			(<span class="enscript-type">void</span>) hfs_lock(VTOC(hfsmp-&gt;hfs_attribute_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			retval = hfs_fsync(hfsmp-&gt;hfs_attribute_vp, MNT_WAIT, 0, p);
			hfs_unlock(VTOC(hfsmp-&gt;hfs_attribute_vp));
			<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}

		(<span class="enscript-type">void</span>) hfs_lock(VTOC(hfsmp-&gt;hfs_catalog_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		retval = hfs_fsync(hfsmp-&gt;hfs_catalog_vp, MNT_WAIT, 0, p);
		hfs_unlock(VTOC(hfsmp-&gt;hfs_catalog_vp));
		<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		
		(<span class="enscript-type">void</span>) hfs_lock(VTOC(hfsmp-&gt;hfs_extents_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		retval = hfs_fsync(hfsmp-&gt;hfs_extents_vp, MNT_WAIT, 0, p);
		hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
		<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
			
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_vp) {
			(<span class="enscript-type">void</span>) hfs_lock(VTOC(hfsmp-&gt;hfs_allocation_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			retval = hfs_fsync(hfsmp-&gt;hfs_allocation_vp, MNT_WAIT, 0, p);
			hfs_unlock(VTOC(hfsmp-&gt;hfs_allocation_vp));
			<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp &amp;&amp; vnode_issystem(hfsmp-&gt;hfc_filevp)) {
			retval = hfs_fsync(hfsmp-&gt;hfc_filevp, MNT_WAIT, 0, p);
			<span class="enscript-keyword">if</span> (retval &amp;&amp; !force)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}

		<span class="enscript-comment">/* If runtime corruption was detected, indicate that the volume
		 * was not unmounted cleanly.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbAtrb &amp; kHFSVolumeInconsistentMask) {
			HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp;= ~kHFSVolumeUnmountedMask;
		} <span class="enscript-keyword">else</span> {
			HFSTOVCB(hfsmp)-&gt;vcbAtrb |= kHFSVolumeUnmountedMask;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
			<span class="enscript-type">int</span> i;
			u_int32_t min_start = hfsmp-&gt;totalBlocks;
			
			<span class="enscript-comment">// set the nextAllocation pointer to the smallest free block number
</span>			<span class="enscript-comment">// we've seen so on the next mount we won't rescan unnecessarily
</span>			lck_spin_lock(&amp;hfsmp-&gt;vcbFreeExtLock);
			<span class="enscript-keyword">for</span>(i=0; i &lt; (<span class="enscript-type">int</span>)hfsmp-&gt;vcbFreeExtCnt; i++) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbFreeExt[i].startBlock &lt; min_start) {
					min_start = hfsmp-&gt;vcbFreeExt[i].startBlock;
				}
			}
			lck_spin_unlock(&amp;hfsmp-&gt;vcbFreeExtLock);
			<span class="enscript-keyword">if</span> (min_start &lt; hfsmp-&gt;nextAllocation) {
				hfsmp-&gt;nextAllocation = min_start;
			}
		}

		retval = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
		<span class="enscript-keyword">if</span> (retval) {
			HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp;= ~kHFSVolumeUnmountedMask;
			<span class="enscript-keyword">if</span> (!force)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;	<span class="enscript-comment">/* could not flush everything */</span>
		}

		<span class="enscript-keyword">if</span> (started_tr) {
		    hfs_end_transaction(hfsmp);
		    started_tr = 0;
		}
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		hfs_flush(hfsmp, HFS_FLUSH_FULL);
	}
	
	<span class="enscript-comment">/*
	 *	Invalidate our caches and release metadata vnodes
	 */</span>
	(<span class="enscript-type">void</span>) hfsUnmount(hfsmp, p);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord) {
		(<span class="enscript-type">void</span>) hfs_relconverter(hfsmp-&gt;hfs_encoding);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
	    journal_close(hfsmp-&gt;jnl);
	    hfsmp-&gt;jnl = NULL;
	}

	VNOP_FSYNC(hfsmp-&gt;hfs_devvp, MNT_WAIT, context);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jvp &amp;&amp; hfsmp-&gt;jvp != hfsmp-&gt;hfs_devvp) {
	    vnode_clearmountedon(hfsmp-&gt;jvp);
	    retval = VNOP_CLOSE(hfsmp-&gt;jvp,
	                       hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY ? FREAD : FREAD|FWRITE,
			       vfs_context_kernel());
	    vnode_put(hfsmp-&gt;jvp);
	    hfsmp-&gt;jvp = NULL;
	}
	<span class="enscript-comment">// XXXdbg
</span>
	<span class="enscript-comment">/*
	 * Last chance to dump unreferenced system files.
	 */</span>
	(<span class="enscript-type">void</span>) vflush(mp, NULLVP, FORCECLOSE);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
	<span class="enscript-comment">/* Drop our reference on the backing fs (if any). */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) &amp;&amp; hfsmp-&gt;hfs_backingfs_rootvp) {
		<span class="enscript-type">struct</span> vnode * tmpvp;

		hfsmp-&gt;hfs_flags &amp;= ~HFS_HAS_SPARSE_DEVICE;
		tmpvp = hfsmp-&gt;hfs_backingfs_rootvp;
		hfsmp-&gt;hfs_backingfs_rootvp = NULLVP;
		vnode_rele(tmpvp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_SPARSE_DEV */</span>

	vnode_rele(hfsmp-&gt;hfs_devvp);

	hfs_locks_destroy(hfsmp);
	hfs_delete_chash(hfsmp);
	hfs_idhash_destroy(hfsmp);

	assert(TAILQ_EMPTY(&amp;hfsmp-&gt;hfs_reserved_ranges[HFS_TENTATIVE_BLOCKS])
		   &amp;&amp; TAILQ_EMPTY(&amp;hfsmp-&gt;hfs_reserved_ranges[HFS_LOCKED_BLOCKS]));
	assert(!hfsmp-&gt;lockedBlocks);

	FREE(hfsmp, M_HFSMNT);

	<span class="enscript-keyword">return</span> (0);

  <span class="enscript-reference">err_exit</span>:
	<span class="enscript-keyword">if</span> (started_tr) {
		hfs_end_transaction(hfsmp);
	}
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">/*
 * Return the root of a filesystem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vfs_root</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode **vpp, __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> hfs_vget(VFSTOHFS(mp), (cnid_t)kHFSRootFolderID, vpp, 1, 0);
}


<span class="enscript-comment">/*
 * Do operations associated with quotas
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">QUOTA</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_quotactl</span>(__unused <span class="enscript-type">struct</span> mount *mp, __unused <span class="enscript-type">int</span> cmds, __unused uid_t uid, __unused caddr_t datap, __unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_quotactl</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> cmds, uid_t uid, caddr_t datap, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">int</span> cmd, type, error;

	<span class="enscript-keyword">if</span> (uid == ~0U)
		uid = kauth_cred_getuid(vfs_context_ucred(context));
	cmd = cmds &gt;&gt; SUBCMDSHIFT;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SYNC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTASTAT</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_GETQUOTA</span>:
		<span class="enscript-keyword">if</span> (uid == kauth_cred_getuid(vfs_context_ucred(context)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* fall through */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> ( (error = vfs_context_suser(context)) )
			<span class="enscript-keyword">return</span> (error);
	}

	type = cmds &amp; SUBCMDMASK;
	<span class="enscript-keyword">if</span> ((u_int)type &gt;= MAXQUOTAS)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAON</span>:
		error = hfs_quotaon(p, mp, type, datap);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAOFF</span>:
		error = hfs_quotaoff(p, mp, type);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETQUOTA</span>:
		error = hfs_setquota(mp, uid, type, datap);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETUSE</span>:
		error = hfs_setuse(mp, uid, type, datap);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_GETQUOTA</span>:
		error = hfs_getquota(mp, uid, type, datap);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SYNC</span>:
		error = hfs_qsync(mp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTASTAT</span>:
		error = hfs_quotastat(mp, type, datap);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	vfs_unbusy(mp);

	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

<span class="enscript-comment">/* Subtype is composite of bits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SUBTYPE_JOURNALED</span>      0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SUBTYPE_CASESENSITIVE</span>  0x02
<span class="enscript-comment">/* bits 2 - 6 reserved */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SUBTYPE_STANDARDHFS</span>    0x80

<span class="enscript-comment">/*
 * Get file system statistics.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_statfs</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> vfsstatfs *sbp, __unused vfs_context_t context)
{
	ExtendedVCB *vcb = VFSTOVCB(mp);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VFSTOHFS(mp);
	u_int32_t freeCNIDs;
	u_int16_t subtype = 0;

	freeCNIDs = (u_int32_t)0xFFFFFFFF - (u_int32_t)vcb-&gt;vcbNxtCNID;

	sbp-&gt;f_bsize = (u_int32_t)vcb-&gt;blockSize;
	sbp-&gt;f_iosize = (size_t)cluster_max_io_size(mp, 0);
	sbp-&gt;f_blocks = (u_int64_t)((u_int32_t)vcb-&gt;totalBlocks);
	sbp-&gt;f_bfree = (u_int64_t)((u_int32_t )hfs_freeblks(hfsmp, 0));
	sbp-&gt;f_bavail = (u_int64_t)((u_int32_t )hfs_freeblks(hfsmp, 1));
	sbp-&gt;f_files = (u_int64_t)((u_int32_t )(vcb-&gt;totalBlocks - 2));  <span class="enscript-comment">/* max files is constrained by total blocks */</span>
	sbp-&gt;f_ffree = (u_int64_t)((u_int32_t )(MIN(freeCNIDs, sbp-&gt;f_bavail)));

	<span class="enscript-comment">/*
	 * Subtypes (flavors) for HFS
	 *   0:   Mac OS Extended
	 *   1:   Mac OS Extended (Journaled) 
	 *   2:   Mac OS Extended (Case Sensitive) 
	 *   3:   Mac OS Extended (Case Sensitive, Journaled) 
	 *   4 - 127:   Reserved
	 * 128:   Mac OS Standard
	 * 
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
		<span class="enscript-comment">/* HFS+ &amp; variants */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			subtype |= HFS_SUBTYPE_JOURNALED;
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE) {
			subtype |= HFS_SUBTYPE_CASESENSITIVE;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* HFS standard */</span>
		subtype = HFS_SUBTYPE_STANDARDHFS;
	} 
#<span class="enscript-reference">endif</span>
	sbp-&gt;f_fssubtype = subtype;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// XXXdbg -- this is a callback to be used by the journal to
</span><span class="enscript-comment">//           get meta data blocks flushed out to disk.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// XXXdbg -- be smarter and don't flush *every* block on each
</span><span class="enscript-comment">//           call.  try to only flush some so we don't wind up
</span><span class="enscript-comment">//           being too synchronous.
</span><span class="enscript-comment">//
</span>__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_sync_metadata</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> mount *mp = (<span class="enscript-type">struct</span> mount *)arg;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	ExtendedVCB *vcb;
	buf_t	bp;
	<span class="enscript-type">int</span>  retval;
	daddr64_t priIDSector;
	hfsmp = VFSTOHFS(mp);
	vcb = HFSTOVCB(hfsmp);

	<span class="enscript-comment">// now make sure the super block is flushed
</span>	priIDSector = (daddr64_t)((vcb-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) +
				  HFS_PRI_SECTOR(hfsmp-&gt;hfs_logical_block_size));

	retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
			HFS_PHYSBLK_ROUNDDOWN(priIDSector, hfsmp-&gt;hfs_log_per_phys),
			hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp);
	<span class="enscript-keyword">if</span> ((retval != 0 ) &amp;&amp; (retval != ENXIO)) {
		printf(<span class="enscript-string">&quot;hfs_sync_metadata: can't read volume header at %d! (retval 0x%x)\n&quot;</span>,
		       (<span class="enscript-type">int</span>)priIDSector, retval);
	}

	<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; ((buf_flags(bp) &amp; (B_DELWRI | B_LOCKED)) == B_DELWRI)) {
	    buf_bwrite(bp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
	    buf_brelse(bp);
	}
	
	<span class="enscript-comment">/* Note that these I/Os bypass the journal (no calls to journal_start_modify_block) */</span>

	<span class="enscript-comment">// the alternate super block...
</span>	<span class="enscript-comment">// XXXdbg - we probably don't need to do this each and every time.
</span>	<span class="enscript-comment">//          hfs_btreeio.c:FlushAlternate() should flag when it was
</span>	<span class="enscript-comment">//          written...
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_partition_avh_sector) {
		retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
				HFS_PHYSBLK_ROUNDDOWN(hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_log_per_phys),
				hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp);
		<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; ((buf_flags(bp) &amp; (B_DELWRI | B_LOCKED)) == B_DELWRI)) {
		    <span class="enscript-comment">/* 
			 * note this I/O can fail if the partition shrank behind our backs! 
			 * So failure should be OK here.
			 */</span>
			buf_bwrite(bp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
		    buf_brelse(bp);
		}
	}

	<span class="enscript-comment">/* Is the FS's idea of the AVH different than the partition ? */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_fs_avh_sector) &amp;&amp; (hfsmp-&gt;hfs_partition_avh_sector != hfsmp-&gt;hfs_fs_avh_sector)) {
		retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
				HFS_PHYSBLK_ROUNDDOWN(hfsmp-&gt;hfs_fs_avh_sector, hfsmp-&gt;hfs_log_per_phys),
				hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp);
		<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; ((buf_flags(bp) &amp; (B_DELWRI | B_LOCKED)) == B_DELWRI)) {
		    buf_bwrite(bp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
		    buf_brelse(bp);
		}
	}

}


<span class="enscript-type">struct</span> hfs_sync_cargs {
	kauth_cred_t  cred;
	<span class="enscript-type">struct</span> proc	 *p;
	<span class="enscript-type">int</span>			  waitfor;
	<span class="enscript-type">int</span>			  error;
	<span class="enscript-type">int</span>			  atime_only_syncs;
	time_t		  sync_start_time;
};


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_sync_callback</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *cargs)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> hfs_sync_cargs *args;
	<span class="enscript-type">int</span> error;

	args = (<span class="enscript-type">struct</span> hfs_sync_cargs *)cargs;

	<span class="enscript-keyword">if</span> (hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		<span class="enscript-keyword">return</span> (VNODE_RETURNED);
	}

	hfs_dirty_t dirty_state = hfs_is_dirty(cp);

	bool sync = dirty_state == HFS_DIRTY || vnode_hasdirtyblks(vp);

	<span class="enscript-keyword">if</span> (!sync &amp;&amp; dirty_state == HFS_DIRTY_ATIME
		&amp;&amp; args-&gt;atime_only_syncs &lt; 256) {
		<span class="enscript-comment">// We only update if the atime changed more than 60s ago
</span>		<span class="enscript-keyword">if</span> (args-&gt;sync_start_time - cp-&gt;c_attr.ca_atime &gt; 60) {
			sync = true;
			++args-&gt;atime_only_syncs;
		}
	}

	<span class="enscript-keyword">if</span> (sync) {
		error = hfs_fsync(vp, args-&gt;waitfor, 0, args-&gt;p);

		<span class="enscript-keyword">if</span> (error)
		        args-&gt;error = error;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime)
		hfs_touchtimes(VTOHFS(vp), cp);

	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}



<span class="enscript-comment">/*
 * Go through the disk queues to initiate sandbagged IO;
 * go through the inodes to write those that have been modified;
 * initiate the writing of the super block if it has been modified.
 *
 * Note: we are always called with the filesystem marked `MPBUSY'.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_sync</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> waitfor, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> vnode *meta_vp[4];
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> error, allerror = 0;
	<span class="enscript-type">struct</span> hfs_sync_cargs args;

	hfsmp = VFSTOHFS(mp);

	<span class="enscript-comment">// Back off if hfs_changefs or a freeze is underway
</span>	hfs_lock_mount(hfsmp);
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_IN_CHANGEFS)
	    || hfsmp-&gt;hfs_freeze_state != HFS_THAWED) {
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> (EROFS);
	}

	++hfsmp-&gt;hfs_syncers;
	hfs_unlock_mount(hfsmp);

	args.cred = kauth_cred_get();
	args.waitfor = waitfor;
	args.p = p;
	args.error = 0;
	args.atime_only_syncs = 0;

	<span class="enscript-type">struct</span> timeval tv;
	microtime(&amp;tv);

	args.sync_start_time = tv.tv_sec;

	<span class="enscript-comment">/*
	 * hfs_sync_callback will be called for each vnode
	 * hung off of this mount point... the vnode will be
	 * properly referenced and unreferenced around the callback
	 */</span>
	vnode_iterate(mp, 0, hfs_sync_callback, (<span class="enscript-type">void</span> *)&amp;args);

	<span class="enscript-keyword">if</span> (args.error)
	        allerror = args.error;

	vcb = HFSTOVCB(hfsmp);

	meta_vp[0] = vcb-&gt;extentsRefNum;
	meta_vp[1] = vcb-&gt;catalogRefNum;
	meta_vp[2] = vcb-&gt;allocationsRefNum;  <span class="enscript-comment">/* This is NULL for standard HFS */</span>
	meta_vp[3] = hfsmp-&gt;hfs_attribute_vp; <span class="enscript-comment">/* Optional file */</span>

	<span class="enscript-comment">/* Now sync our three metadata files */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; ++i) {
		<span class="enscript-type">struct</span> vnode *btvp;

		btvp = meta_vp[i];;
		<span class="enscript-keyword">if</span> ((btvp==0) || (vnode_mount(btvp) != mp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* XXX use hfs_systemfile_lock instead ? */</span>
		(<span class="enscript-type">void</span>) hfs_lock(VTOC(btvp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		cp = VTOC(btvp);

		<span class="enscript-keyword">if</span> (!hfs_is_dirty(cp) &amp;&amp; !vnode_hasdirtyblks(btvp)) {
			hfs_unlock(VTOC(btvp));
			<span class="enscript-keyword">continue</span>;
		}
		error = vnode_get(btvp);
		<span class="enscript-keyword">if</span> (error) {
			hfs_unlock(VTOC(btvp));
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((error = hfs_fsync(btvp, waitfor, 0, p)))
			allerror = error;

		hfs_unlock(cp);
		vnode_put(btvp);
	};


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-comment">/*
	 * Force stale file system control information to be flushed.
	 */</span>
	<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord == kHFSSigWord) {
		<span class="enscript-keyword">if</span> ((error = VNOP_FSYNC(hfsmp-&gt;hfs_devvp, waitfor, context))) {
			allerror = error;
		}
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	hfs_qsync(mp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	hfs_hotfilesync(hfsmp, vfs_context_kernel());

	<span class="enscript-comment">/*
	 * Write back modified superblock.
	 */</span>
	<span class="enscript-keyword">if</span> (IsVCBDirty(vcb)) {
		error = hfs_flushvolumeheader(hfsmp, waitfor == MNT_WAIT ? HFS_FVH_WAIT : 0);
		<span class="enscript-keyword">if</span> (error)
			allerror = error;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
	    hfs_flush(hfsmp, HFS_FLUSH_JOURNAL);
	}

	hfs_lock_mount(hfsmp);
	boolean_t wake = (!--hfsmp-&gt;hfs_syncers
					  &amp;&amp; hfsmp-&gt;hfs_freeze_state == HFS_WANT_TO_FREEZE);
	hfs_unlock_mount(hfsmp);
	<span class="enscript-keyword">if</span> (wake)
		wakeup(&amp;hfsmp-&gt;hfs_freeze_state);

	<span class="enscript-keyword">return</span> (allerror);
}


<span class="enscript-comment">/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles:
 * - check that the cnode id is valid
 * - call hfs_vget() to get the locked cnode
 * - check for an unallocated cnode (i_mode == 0)
 * - check that the given client host has export rights and return
 *   those rights via. exflagsp and credanonp
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_fhtovp</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> fhlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, <span class="enscript-type">struct</span> vnode **vpp, __unused vfs_context_t context)
{
	<span class="enscript-type">struct</span> hfsfid *hfsfhp;
	<span class="enscript-type">struct</span> vnode *nvp;
	<span class="enscript-type">int</span> result;

	*vpp = NULL;
	hfsfhp = (<span class="enscript-type">struct</span> hfsfid *)fhp;

	<span class="enscript-keyword">if</span> (fhlen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsfid))
		<span class="enscript-keyword">return</span> (EINVAL);

	result = hfs_vget(VFSTOHFS(mp), ntohl(hfsfhp-&gt;hfsfid_cnid), &amp;nvp, 0, 0);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (result == ENOENT)
			result = ESTALE;
		<span class="enscript-keyword">return</span> result;
	}

	<span class="enscript-comment">/* 
	 * We used to use the create time as the gen id of the file handle,
	 * but it is not static enough because it can change at any point 
	 * via system calls.  We still don't have another volume ID or other
	 * unique identifier to use for a generation ID across reboots that
	 * persists until the file is removed.  Using only the CNID exposes
	 * us to the potential wrap-around case, but as of 2/2008, it would take
	 * over 2 months to wrap around if the machine did nothing but allocate
	 * CNIDs.  Using some kind of wrap counter would only be effective if
	 * each file had the wrap counter associated with it.  For now, 
	 * we use only the CNID to identify the file as it's good enough.
	 */</span>	 

	*vpp = nvp;

	hfs_unlock(VTOC(nvp));
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Vnode pointer to File handle
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vptofh</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *fhlenp, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp, __unused vfs_context_t context)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> hfsfid *hfsfhp;

	<span class="enscript-keyword">if</span> (ISHFS(VTOVCB(vp)))
		<span class="enscript-keyword">return</span> (ENOTSUP);	<span class="enscript-comment">/* hfs standard is not exportable */</span>

	<span class="enscript-keyword">if</span> (*fhlenp &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsfid))
		<span class="enscript-keyword">return</span> (EOVERFLOW);

	cp = VTOC(vp);
	hfsfhp = (<span class="enscript-type">struct</span> hfsfid *)fhp;
	<span class="enscript-comment">/* only the CNID is used to identify the file now */</span>
	hfsfhp-&gt;hfsfid_cnid = htonl(cp-&gt;c_fileid);
	hfsfhp-&gt;hfsfid_gen = htonl(cp-&gt;c_fileid);
	*fhlenp = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsfid);
	
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Initialize HFS filesystems, done only once per boot.
 *
 * HFS is not a kext-based file system.  This makes it difficult to find 
 * out when the last HFS file system was unmounted and call hfs_uninit() 
 * to deallocate data structures allocated in hfs_init().  Therefore we 
 * never deallocate memory allocated by lock attribute and group initializations 
 * in this function.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_init</span>(__unused <span class="enscript-type">struct</span> vfsconf *vfsp)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> done = 0;

	<span class="enscript-keyword">if</span> (done)
		<span class="enscript-keyword">return</span> (0);
	done = 1;
	hfs_chashinit();
	hfs_converterinit();

	BTReserveSetup();
	
	hfs_lock_attr    = lck_attr_alloc_init();
	hfs_group_attr   = lck_grp_attr_alloc_init();
	hfs_mutex_group  = lck_grp_alloc_init(<span class="enscript-string">&quot;hfs-mutex&quot;</span>, hfs_group_attr);
	hfs_rwlock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;hfs-rwlock&quot;</span>, hfs_group_attr);
	hfs_spinlock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;hfs-spinlock&quot;</span>, hfs_group_attr);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	decmpfs_init();
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Destroy all locks, mutexes and spinlocks in hfsmp on unmount or failed mount
 */</span> 
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">hfs_locks_destroy</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{

	lck_mtx_destroy(&amp;hfsmp-&gt;hfs_mutex, hfs_mutex_group);
	lck_mtx_destroy(&amp;hfsmp-&gt;hfc_mutex, hfs_mutex_group);
	lck_rw_destroy(&amp;hfsmp-&gt;hfs_global_lock, hfs_rwlock_group);
	lck_spin_destroy(&amp;hfsmp-&gt;vcbFreeExtLock, hfs_spinlock_group);

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_getmountpoint</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> hfsmount **hfsmpp)
{
	<span class="enscript-type">struct</span> hfsmount * hfsmp;
	<span class="enscript-type">char</span> fstypename[MFSNAMELEN];

	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	
	<span class="enscript-keyword">if</span> (!vnode_isvroot(vp))
		<span class="enscript-keyword">return</span> (EINVAL);

	vnode_vfsname(vp, fstypename);
	<span class="enscript-keyword">if</span> (strncmp(fstypename, <span class="enscript-string">&quot;hfs&quot;</span>, <span class="enscript-keyword">sizeof</span>(fstypename)) != 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord)
		<span class="enscript-keyword">return</span> (EINVAL);

	*hfsmpp = hfsmp;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">// XXXdbg
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>

<span class="enscript-comment">/*
 * HFS filesystem related variables.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_sysctl</span>(<span class="enscript-type">int</span> *name, __unused u_int namelen, user_addr_t oldp, size_t *oldlenp, 
			user_addr_t newp, size_t newlen, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;

	<span class="enscript-comment">/* all sysctl names at this level are terminal */</span>

	<span class="enscript-keyword">if</span> (name[0] == HFS_ENCODINGBIAS) {
		<span class="enscript-type">int</span> bias;

		bias = hfs_getencodingbias();
		error = sysctl_int(oldp, oldlenp, newp, newlen, &amp;bias);
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; newp)
			hfs_setencodingbias(bias);
		<span class="enscript-keyword">return</span> (error);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_EXTEND_FS) {
		u_int64_t  newsize = 0;
		vnode_t vp = vfs_context_cwd(context);

		<span class="enscript-keyword">if</span> (newp == USER_ADDR_NULL || vp == NULLVP)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((error = hfs_getmountpoint(vp, &amp;hfsmp)))
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-comment">/* Start with the 'size' set to the current number of bytes in the filesystem */</span>
		newsize = ((uint64_t)hfsmp-&gt;totalBlocks) * ((uint64_t)hfsmp-&gt;blockSize);

		<span class="enscript-comment">/* now get the new size from userland and over-write our stored value */</span>
		error = sysctl_quad(oldp, oldlenp, newp, newlen, (quad_t *)&amp;newsize);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	
		error = hfs_extendfs(hfsmp, newsize, context);		
		<span class="enscript-keyword">return</span> (error);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_ENCODINGHINT) {
		size_t bufsize;
		size_t bytes;
		u_int32_t hint;
		u_int16_t *unicode_name = NULL;
		<span class="enscript-type">char</span> *filename = NULL;

		<span class="enscript-keyword">if</span> ((newlen &lt;= 0) || (newlen &gt; MAXPATHLEN)) 
			<span class="enscript-keyword">return</span> (EINVAL);

		bufsize = MAX(newlen * 3, MAXPATHLEN);
		MALLOC(filename, <span class="enscript-type">char</span> *, newlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (filename == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">encodinghint_exit</span>;
		}
		MALLOC(unicode_name, u_int16_t *, bufsize, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (unicode_name == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">encodinghint_exit</span>;
		}

		error = copyin(newp, (caddr_t)filename, newlen);
		<span class="enscript-keyword">if</span> (error == 0) {
			error = utf8_decodestr((u_int8_t *)filename, newlen - 1, unicode_name,
			                       &amp;bytes, bufsize, 0, UTF_DECOMPOSED);
			<span class="enscript-keyword">if</span> (error == 0) {
				hint = hfs_pickencoding(unicode_name, bytes / 2);
				error = sysctl_int(oldp, oldlenp, USER_ADDR_NULL, 0, (int32_t *)&amp;hint);
			}
		}

<span class="enscript-reference">encodinghint_exit</span>:
		<span class="enscript-keyword">if</span> (unicode_name)
			FREE(unicode_name, M_TEMP);
		<span class="enscript-keyword">if</span> (filename)
			FREE(filename, M_TEMP);
		<span class="enscript-keyword">return</span> (error);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_ENABLE_JOURNALING) {
		<span class="enscript-comment">// make the file system journaled...
</span>		vnode_t vp = vfs_context_cwd(context);
		vnode_t jvp;
		ExtendedVCB *vcb;
		<span class="enscript-type">struct</span> cat_attr jnl_attr;
	    <span class="enscript-type">struct</span> cat_attr	jinfo_attr;
		<span class="enscript-type">struct</span> cat_fork jnl_fork;
		<span class="enscript-type">struct</span> cat_fork jinfo_fork;
		buf_t jib_buf;
		uint64_t jib_blkno;
		uint32_t tmpblkno;
		uint64_t journal_byte_offset;
		uint64_t journal_size;
		vnode_t jib_vp = NULLVP;
		<span class="enscript-type">struct</span> JournalInfoBlock local_jib;
		<span class="enscript-type">int</span> err = 0;
		<span class="enscript-type">void</span> *jnl = NULL;
		<span class="enscript-type">int</span> lockflags;

		<span class="enscript-comment">/* Only root can enable journaling */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> (EPERM);
		}
		<span class="enscript-keyword">if</span> (vp == NULLVP)
		        <span class="enscript-keyword">return</span> EINVAL;

		hfsmp = VTOHFS(vp);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> EROFS;
		}
		<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord) {
			printf(<span class="enscript-string">&quot;hfs: can't make a plain hfs volume journaled.\n&quot;</span>);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		    printf(<span class="enscript-string">&quot;hfs: volume @ mp %p is already journaled!\n&quot;</span>, vnode_mount(vp));
		    <span class="enscript-keyword">return</span> EAGAIN;
		}
		vcb = HFSTOVCB(hfsmp);

		<span class="enscript-comment">/* Set up local copies of the initialization info */</span>
		tmpblkno = (uint32_t) name[1];
		jib_blkno = (uint64_t) tmpblkno;
		journal_byte_offset = (uint64_t) name[2];
		journal_byte_offset *= hfsmp-&gt;blockSize;
		journal_byte_offset += hfsmp-&gt;hfsPlusIOPosOffset;
		journal_size = (uint64_t)((<span class="enscript-type">unsigned</span>)name[3]);

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_EXTENTS, HFS_EXCLUSIVE_LOCK);
		<span class="enscript-keyword">if</span> (BTHasContiguousNodes(VTOF(vcb-&gt;catalogRefNum)) == 0 ||
			BTHasContiguousNodes(VTOF(vcb-&gt;extentsRefNum)) == 0) {

			printf(<span class="enscript-string">&quot;hfs: volume has a btree w/non-contiguous nodes.  can not enable journaling.\n&quot;</span>);
			hfs_systemfile_unlock(hfsmp, lockflags);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		hfs_systemfile_unlock(hfsmp, lockflags);

		<span class="enscript-comment">// make sure these both exist!
</span>		<span class="enscript-keyword">if</span> (   GetFileInfo(vcb, kHFSRootFolderID, <span class="enscript-string">&quot;.journal_info_block&quot;</span>, &amp;jinfo_attr, &amp;jinfo_fork) == 0
			|| GetFileInfo(vcb, kHFSRootFolderID, <span class="enscript-string">&quot;.journal&quot;</span>, &amp;jnl_attr, &amp;jnl_fork) == 0) {

			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/*
		 * At this point, we have a copy of the metadata that lives in the catalog for the
		 * journal info block.  Compare that the journal info block's single extent matches
		 * that which was passed into this sysctl.  
		 *
		 * If it is different, deny the journal enable call.
		 */</span>
		<span class="enscript-keyword">if</span> (jinfo_fork.cf_blocks &gt; 1) {
			<span class="enscript-comment">/* too many blocks */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (jinfo_fork.cf_extents[0].startBlock != jib_blkno) {
			<span class="enscript-comment">/* Wrong block */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/*   
		 * We want to immediately purge the vnode for the JIB.
		 * 
		 * Because it was written to from userland, there's probably 
		 * a vnode somewhere in the vnode cache (possibly with UBC backed blocks). 
		 * So we bring the vnode into core, then immediately do whatever 
		 * we can to flush/vclean it out.  This is because those blocks will be 
		 * interpreted as user data, which may be treated separately on some platforms
		 * than metadata.  If the vnode is gone, then there cannot be backing blocks
		 * in the UBC.
		 */</span>
		<span class="enscript-keyword">if</span> (hfs_vget (hfsmp, jinfo_attr.ca_fileid, &amp;jib_vp, 1, 0)) {
			<span class="enscript-keyword">return</span> EINVAL;
		} 
		<span class="enscript-comment">/*
		 * Now we have a vnode for the JIB. recycle it. Because we hold an iocount
		 * on the vnode, we'll just mark it for termination when the last iocount
		 * (hopefully ours), is dropped.
		 */</span>
		vnode_recycle (jib_vp);
		err = vnode_put (jib_vp);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">return</span> EINVAL;	
		}

		<span class="enscript-comment">/* Initialize the local copy of the JIB (just like hfs.util) */</span>
		memset (&amp;local_jib, <span class="enscript-string">'Z'</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> JournalInfoBlock));
		local_jib.flags = SWAP_BE32(kJIJournalInFSMask);
		<span class="enscript-comment">/* Note that the JIB's offset is in bytes */</span>
		local_jib.offset = SWAP_BE64(journal_byte_offset);
		local_jib.size = SWAP_BE64(journal_size);  

		<span class="enscript-comment">/* 
		 * Now write out the local JIB.  This essentially overwrites the userland
		 * copy of the JIB.  Read it as BLK_META to treat it as a metadata read/write.
		 */</span>
		jib_buf = buf_getblk (hfsmp-&gt;hfs_devvp, 
				jib_blkno * (hfsmp-&gt;blockSize / hfsmp-&gt;hfs_logical_block_size), 
				hfsmp-&gt;blockSize, 0, 0, BLK_META);
		<span class="enscript-type">char</span>* buf_ptr = (<span class="enscript-type">char</span>*) buf_dataptr (jib_buf);

		<span class="enscript-comment">/* Zero out the portion of the block that won't contain JIB data */</span>
		memset (buf_ptr, 0, hfsmp-&gt;blockSize);

		bcopy(&amp;local_jib, buf_ptr, <span class="enscript-keyword">sizeof</span>(local_jib));
		<span class="enscript-keyword">if</span> (buf_bwrite (jib_buf)) {
			<span class="enscript-keyword">return</span> EIO;
		}

		<span class="enscript-comment">/* Force a flush track cache */</span>
		hfs_flush(hfsmp, HFS_FLUSH_CACHE);

		<span class="enscript-comment">/* Now proceed with full volume sync */</span>
		hfs_sync(hfsmp-&gt;hfs_mp, MNT_WAIT, context);

		printf(<span class="enscript-string">&quot;hfs: Initializing the journal (joffset 0x%llx sz 0x%llx)...\n&quot;</span>,
			   (off_t)name[2], (off_t)name[3]);

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// XXXdbg - note that currently (Sept, 08) hfs_util does not support
</span>		<span class="enscript-comment">//          enabling the journal on a separate device so it is safe
</span>		<span class="enscript-comment">//          to just copy hfs_devvp here.  If hfs_util gets the ability
</span>		<span class="enscript-comment">//          to dynamically enable the journal on a separate device then
</span>		<span class="enscript-comment">//          we will have to do the same thing as hfs_early_journal_init()
</span>		<span class="enscript-comment">//          to locate and open the journal device.
</span>		<span class="enscript-comment">//
</span>		jvp = hfsmp-&gt;hfs_devvp;
		jnl = journal_create(jvp, journal_byte_offset, journal_size, 
							 hfsmp-&gt;hfs_devvp,
							 hfsmp-&gt;hfs_logical_block_size,
							 0,
							 0,
							 hfs_sync_metadata, hfsmp-&gt;hfs_mp,
							 hfsmp-&gt;hfs_mp);

		<span class="enscript-comment">/*
		 * Set up the trim callback function so that we can add
		 * recently freed extents to the free extent cache once
		 * the transaction that freed them is written to the
		 * journal on disk.
		 */</span>
		<span class="enscript-keyword">if</span> (jnl)
			journal_trim_set_callback(jnl, hfs_trim_callback, hfsmp);

		<span class="enscript-keyword">if</span> (jnl == NULL) {
			printf(<span class="enscript-string">&quot;hfs: FAILED to create the journal!\n&quot;</span>);
			<span class="enscript-keyword">if</span> (jvp &amp;&amp; jvp != hfsmp-&gt;hfs_devvp) {
				vnode_clearmountedon(jvp);
				VNOP_CLOSE(jvp, hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY ? FREAD : FREAD|FWRITE, vfs_context_kernel());
			}
			jvp = NULL;

			<span class="enscript-keyword">return</span> EINVAL;
		} 

		hfs_lock_global (hfsmp, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">/*
		 * Flush all dirty metadata buffers.
		 */</span>
		buf_flushdirtyblks(hfsmp-&gt;hfs_devvp, TRUE, 0, <span class="enscript-string">&quot;hfs_sysctl&quot;</span>);
		buf_flushdirtyblks(hfsmp-&gt;hfs_extents_vp, TRUE, 0, <span class="enscript-string">&quot;hfs_sysctl&quot;</span>);
		buf_flushdirtyblks(hfsmp-&gt;hfs_catalog_vp, TRUE, 0, <span class="enscript-string">&quot;hfs_sysctl&quot;</span>);
		buf_flushdirtyblks(hfsmp-&gt;hfs_allocation_vp, TRUE, 0, <span class="enscript-string">&quot;hfs_sysctl&quot;</span>);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp)
			buf_flushdirtyblks(hfsmp-&gt;hfs_attribute_vp, TRUE, 0, <span class="enscript-string">&quot;hfs_sysctl&quot;</span>);

		HFSTOVCB(hfsmp)-&gt;vcbJinfoBlock = name[1];
		HFSTOVCB(hfsmp)-&gt;vcbAtrb |= kHFSVolumeJournaledMask;
		hfsmp-&gt;jvp = jvp;
		hfsmp-&gt;jnl = jnl;

		<span class="enscript-comment">// save this off for the hack-y check in hfs_remove()
</span>		hfsmp-&gt;jnl_start        = (u_int32_t)name[2];
		hfsmp-&gt;jnl_size         = (off_t)((<span class="enscript-type">unsigned</span>)name[3]);
		hfsmp-&gt;hfs_jnlinfoblkid = jinfo_attr.ca_fileid;
		hfsmp-&gt;hfs_jnlfileid    = jnl_attr.ca_fileid;

		vfs_setflags(hfsmp-&gt;hfs_mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));

		hfs_unlock_global (hfsmp);
		hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);

		{
			fsid_t fsid;
		
			fsid.val[0] = (int32_t)hfsmp-&gt;hfs_raw_dev;
			fsid.val[1] = (int32_t)vfs_typenum(HFSTOVFS(hfsmp));
			vfs_event_signal(&amp;fsid, VQ_UPDATE, (intptr_t)NULL);
		}
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_DISABLE_JOURNALING) {
		<span class="enscript-comment">// clear the journaling bit 
</span>		vnode_t vp = vfs_context_cwd(context);
		
		<span class="enscript-comment">/* Only root can disable journaling */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> (EPERM);
		}
		<span class="enscript-keyword">if</span> (vp == NULLVP)
		        <span class="enscript-keyword">return</span> EINVAL;

		hfsmp = VTOHFS(vp);

		<span class="enscript-comment">/* 
		 * Disabling journaling is disallowed on volumes with directory hard links
		 * because we have not tested the relevant code path.
		 */</span>  
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_private_attr[DIR_HARDLINKS].ca_entries != 0){
			printf(<span class="enscript-string">&quot;hfs: cannot disable journaling on volumes with directory hardlinks\n&quot;</span>);
			<span class="enscript-keyword">return</span> EPERM;
		}

		printf(<span class="enscript-string">&quot;hfs: disabling journaling for mount @ %p\n&quot;</span>, vnode_mount(vp));

		hfs_lock_global (hfsmp, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">// Lights out for you buddy!
</span>		journal_close(hfsmp-&gt;jnl);
		hfsmp-&gt;jnl = NULL;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;jvp &amp;&amp; hfsmp-&gt;jvp != hfsmp-&gt;hfs_devvp) {
			vnode_clearmountedon(hfsmp-&gt;jvp);
			VNOP_CLOSE(hfsmp-&gt;jvp, hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY ? FREAD : FREAD|FWRITE, vfs_context_kernel());
			vnode_put(hfsmp-&gt;jvp);
		}
		hfsmp-&gt;jvp = NULL;
		vfs_clearflags(hfsmp-&gt;hfs_mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));
		hfsmp-&gt;jnl_start        = 0;
		hfsmp-&gt;hfs_jnlinfoblkid = 0;
		hfsmp-&gt;hfs_jnlfileid    = 0;
		
		HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp;= ~kHFSVolumeJournaledMask;
		
		hfs_unlock_global (hfsmp);

		hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);

		{
			fsid_t fsid;
		
			fsid.val[0] = (int32_t)hfsmp-&gt;hfs_raw_dev;
			fsid.val[1] = (int32_t)vfs_typenum(HFSTOVFS(hfsmp));
			vfs_event_signal(&amp;fsid, VQ_UPDATE, (intptr_t)NULL);
		}
		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_GET_JOURNAL_INFO) {
		vnode_t vp = vfs_context_cwd(context);
		off_t jnl_start, jnl_size;

		<span class="enscript-keyword">if</span> (vp == NULLVP)
		        <span class="enscript-keyword">return</span> EINVAL;

		<span class="enscript-comment">/* 64-bit processes won't work with this sysctl -- can't fit a pointer into an int! */</span>
		<span class="enscript-keyword">if</span> (proc_is64bit(current_proc()))
			<span class="enscript-keyword">return</span> EINVAL;

		hfsmp = VTOHFS(vp);
	    <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
			jnl_start = 0;
			jnl_size  = 0;
	    } <span class="enscript-keyword">else</span> {
			jnl_start = hfs_blk_to_bytes(hfsmp-&gt;jnl_start, HFSTOVCB(hfsmp)-&gt;blockSize) + HFSTOVCB(hfsmp)-&gt;hfsPlusIOPosOffset;
			jnl_size  = hfsmp-&gt;jnl_size;
	    }

	    <span class="enscript-keyword">if</span> ((error = copyout((caddr_t)&amp;jnl_start, CAST_USER_ADDR_T(name[1]), <span class="enscript-keyword">sizeof</span>(off_t))) != 0) {
			<span class="enscript-keyword">return</span> error;
		}
	    <span class="enscript-keyword">if</span> ((error = copyout((caddr_t)&amp;jnl_size, CAST_USER_ADDR_T(name[2]), <span class="enscript-keyword">sizeof</span>(off_t))) != 0) {
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_SET_PKG_EXTENSIONS) {

	    <span class="enscript-keyword">return</span> set_package_extensions_table((user_addr_t)((<span class="enscript-type">unsigned</span>)name[1]), name[2], name[3]);
	    
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == VFS_CTL_QUERY) {
    	<span class="enscript-type">struct</span> sysctl_req *req;
    	<span class="enscript-type">union</span> union_vfsidctl vc;
    	<span class="enscript-type">struct</span> mount *mp;
 	    <span class="enscript-type">struct</span> vfsquery vq;
	
		req = CAST_DOWN(<span class="enscript-type">struct</span> sysctl_req *, oldp);	<span class="enscript-comment">/* we're new style vfs sysctl. */</span>
		<span class="enscript-keyword">if</span> (req == NULL) {
			<span class="enscript-keyword">return</span> EFAULT;
		}
        
        error = SYSCTL_IN(req, &amp;vc, proc_is64bit(p)? <span class="enscript-keyword">sizeof</span>(vc.vc64):<span class="enscript-keyword">sizeof</span>(vc.vc32));
		<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">return</span> (error);

		mp = vfs_getvfs(&amp;vc.vc32.vc_fsid); <span class="enscript-comment">/* works for 32 and 64 */</span>
        <span class="enscript-keyword">if</span> (mp == NULL) <span class="enscript-keyword">return</span> (ENOENT);
        
		hfsmp = VFSTOHFS(mp);
		bzero(&amp;vq, <span class="enscript-keyword">sizeof</span>(vq));
		vq.vq_flags = hfsmp-&gt;hfs_notification_conditions;
		<span class="enscript-keyword">return</span> SYSCTL_OUT(req, &amp;vq, <span class="enscript-keyword">sizeof</span>(vq));;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_REPLAY_JOURNAL) {
		vnode_t devvp = NULL;
		<span class="enscript-type">int</span> device_fd;
		<span class="enscript-keyword">if</span> (namelen != 2) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		device_fd = name[1];
		error = file_vnode(device_fd, &amp;devvp);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> error;
		}
		error = vnode_getwithref(devvp);
		<span class="enscript-keyword">if</span> (error) {
			file_drop(device_fd);
			<span class="enscript-keyword">return</span> error;
		}
		error = hfs_journal_replay(devvp, context);
		file_drop(device_fd);
		vnode_put(devvp);
		<span class="enscript-keyword">return</span> error;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (name[0] == HFS_ENABLE_RESIZE_DEBUG) {
		hfs_resize_debug = 1;
		printf (<span class="enscript-string">&quot;hfs_sysctl: Enabled volume resize debugging.\n&quot;</span>);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/* 
 * hfs_vfs_vget is not static since it is used in hfs_readwrite.c to support
 * the build_path ioctl.  We use it to leverage the code below that updates
 * the origin list cache if necessary
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vfs_vget</span>(<span class="enscript-type">struct</span> mount *mp, ino64_t ino, <span class="enscript-type">struct</span> vnode **vpp, __unused vfs_context_t context)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;

	hfsmp = VFSTOHFS(mp);

	error = hfs_vget(hfsmp, (cnid_t)ino, vpp, 1, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * If the look-up was via the object ID (rather than the link ID),
	 * then we make sure there's a parent here.  We can't leave this
	 * until hfs_vnop_getattr because if there's a problem getting the
	 * parent at that point, all the caller will do is call
	 * hfs_vfs_vget again and we'll end up in an infinite loop.
	 */</span>

	cnode_t *cp = VTOC(*vpp);

	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_HARDLINK) &amp;&amp; ino == cp-&gt;c_fileid) {
		hfs_lock_always(cp, HFS_SHARED_LOCK);

		<span class="enscript-keyword">if</span> (!hfs_haslinkorigin(cp)) {
			<span class="enscript-keyword">if</span> (!hfs_lock_upgrade(cp))
				hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);

			<span class="enscript-keyword">if</span> (cp-&gt;c_cnid == cp-&gt;c_fileid) {
				<span class="enscript-comment">/*
				 * Descriptor is stale, so we need to refresh it.  We
				 * pick the first link.
				 */</span>
				cnid_t link_id;

				error = hfs_first_link(hfsmp, cp, &amp;link_id);

				<span class="enscript-keyword">if</span> (!error) {
					lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
					error = cat_findname(hfsmp, link_id, &amp;cp-&gt;c_desc);
					hfs_systemfile_unlock(hfsmp, lockflags);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// We'll use whatever link the descriptor happens to have
</span>				error = 0;
			}
			<span class="enscript-keyword">if</span> (!error)
				hfs_savelinkorigin(cp, cp-&gt;c_parentcnid);
		}

		hfs_unlock(cp);

		<span class="enscript-keyword">if</span> (error) {
			vnode_put(*vpp);
			*vpp = NULL;
		}
	}

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Look up an HFS object by ID.
 *
 * The object is returned with an iocount reference and the cnode locked.
 *
 * If the object is a file then it will represent the data fork.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vget</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">int</span> skiplock, <span class="enscript-type">int</span> allow_deleted)
{
	<span class="enscript-type">struct</span> vnode *vp = NULLVP;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr cnattr;
	<span class="enscript-type">struct</span> cat_fork cnfork;
	u_int32_t linkref = 0;
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-comment">/* Check for cnids that should't be exported. */</span>
	<span class="enscript-keyword">if</span> ((cnid &lt; kHFSFirstUserCatalogNodeID) &amp;&amp;
	    (cnid != kHFSRootFolderID &amp;&amp; cnid != kHFSRootParentID)) {
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	<span class="enscript-comment">/* Don't export our private directories. */</span>
	<span class="enscript-keyword">if</span> (cnid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
	    cnid == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	<span class="enscript-comment">/*
	 * Check the hash first
	 */</span>
	vp = hfs_chash_getvnode(hfsmp, cnid, 0, skiplock, allow_deleted);
	<span class="enscript-keyword">if</span> (vp) {
		*vpp = vp;
		<span class="enscript-keyword">return</span>(0);
	}

	bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
	bzero(&amp;cnattr, <span class="enscript-keyword">sizeof</span>(cnattr));
	bzero(&amp;cnfork, <span class="enscript-keyword">sizeof</span>(cnfork));

	<span class="enscript-comment">/*
	 * Not in hash, lookup in catalog
	 */</span>
	<span class="enscript-keyword">if</span> (cnid == kHFSRootParentID) {
		<span class="enscript-type">static</span> <span class="enscript-type">char</span> hfs_rootname[] = <span class="enscript-string">&quot;/&quot;</span>;

		cndesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)&amp;hfs_rootname[0];
		cndesc.cd_namelen = 1;
		cndesc.cd_parentcnid = kHFSRootParentID;
		cndesc.cd_cnid = kHFSRootFolderID;
		cndesc.cd_flags = CD_ISDIR;

		cnattr.ca_fileid = kHFSRootFolderID;
		cnattr.ca_linkcount = 1;
		cnattr.ca_entries = 1;
		cnattr.ca_dircount = 1;
		cnattr.ca_mode = (S_IFDIR | S_IRWXU | S_IRWXG | S_IRWXO);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> lockflags;
		cnid_t pid;
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *nameptr;

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
		error = cat_idlookup(hfsmp, cnid, 0, 0, &amp;cndesc, &amp;cnattr, &amp;cnfork);
		hfs_systemfile_unlock(hfsmp, lockflags);

		<span class="enscript-keyword">if</span> (error) {
			*vpp = NULL;
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/*
		 * Check for a raw hardlink inode and save its linkref.
		 */</span>
		pid = cndesc.cd_parentcnid;
		nameptr = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cndesc.cd_nameptr;

		<span class="enscript-keyword">if</span> ((pid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) &amp;&amp;
		    (bcmp(nameptr, HFS_INODE_PREFIX, HFS_INODE_PREFIX_LEN) == 0)) {
			linkref = strtoul(&amp;nameptr[HFS_INODE_PREFIX_LEN], NULL, 10);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pid == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) &amp;&amp;
		           (bcmp(nameptr, HFS_DIRINODE_PREFIX, HFS_DIRINODE_PREFIX_LEN) == 0)) {
			linkref = strtoul(&amp;nameptr[HFS_DIRINODE_PREFIX_LEN], NULL, 10);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) &amp;&amp;
		           (bcmp(nameptr, HFS_DELETE_PREFIX, HFS_DELETE_PREFIX_LEN) == 0)) {
			*vpp = NULL;
			cat_releasedesc(&amp;cndesc);
			<span class="enscript-keyword">return</span> (ENOENT);  <span class="enscript-comment">/* open unlinked file */</span>
		}
	}

	<span class="enscript-comment">/*
	 * Finish initializing cnode descriptor for hardlinks.
	 *
	 * We need a valid name and parent for reverse lookups.
	 */</span>
	<span class="enscript-keyword">if</span> (linkref) {
		cnid_t lastid;
		<span class="enscript-type">struct</span> cat_desc linkdesc;
		<span class="enscript-type">int</span> linkerr = 0;
		
		cnattr.ca_linkref = linkref;
		bzero (&amp;linkdesc, <span class="enscript-keyword">sizeof</span> (linkdesc));

		<span class="enscript-comment">/* 
		 * If the caller supplied the raw inode value, then we don't know exactly
		 * which hardlink they wanted. It's likely that they acquired the raw inode
		 * value BEFORE the item became a hardlink, in which case, they probably
		 * want the oldest link.  So request the oldest link from the catalog.
		 * 
		 * Unfortunately, this requires that we iterate through all N hardlinks. On the plus
		 * side, since we know that we want the last linkID, we can also have this one
		 * call give us back the name of the last ID, since it's going to have it in-hand...
		 */</span>
		linkerr = hfs_lookup_lastlink (hfsmp, linkref, &amp;lastid, &amp;linkdesc);
		<span class="enscript-keyword">if</span> ((linkerr == 0) &amp;&amp; (lastid != 0)) {
			<span class="enscript-comment">/* 
			 * Release any lingering buffers attached to our local descriptor.
			 * Then copy the name and other business into the cndesc 
			 */</span>
			cat_releasedesc (&amp;cndesc);
			bcopy (&amp;linkdesc, &amp;cndesc, <span class="enscript-keyword">sizeof</span>(linkdesc));	
		}	
		<span class="enscript-comment">/* If it failed, the linkref code will just use whatever it had in-hand below. */</span>
	}

	<span class="enscript-keyword">if</span> (linkref) {
		<span class="enscript-type">int</span> newvnode_flags = 0;
		
		error = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr,
								&amp;cnfork, &amp;vp, &amp;newvnode_flags);
		<span class="enscript-keyword">if</span> (error == 0) {
			VTOC(vp)-&gt;c_flag |= C_HARDLINK;
			vnode_setmultipath(vp);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> componentname cn;
		<span class="enscript-type">int</span> newvnode_flags = 0;

		<span class="enscript-comment">/* Supply hfs_getnewvnode with a component name. */</span>
		MALLOC_ZONE(cn.cn_pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
		cn.cn_nameiop = LOOKUP;
		cn.cn_flags = ISLASTCN | HASBUF;
		cn.cn_context = NULL;
		cn.cn_pnlen = MAXPATHLEN;
		cn.cn_nameptr = cn.cn_pnbuf;
		cn.cn_namelen = cndesc.cd_namelen;
		cn.cn_hash = 0;
		cn.cn_consume = 0;
		bcopy(cndesc.cd_nameptr, cn.cn_nameptr, cndesc.cd_namelen + 1);
	
		error = hfs_getnewvnode(hfsmp, NULLVP, &amp;cn, &amp;cndesc, 0, &amp;cnattr, 
								&amp;cnfork, &amp;vp, &amp;newvnode_flags);

		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (VTOC(vp)-&gt;c_flag &amp; C_HARDLINK)) {
			hfs_savelinkorigin(VTOC(vp), cndesc.cd_parentcnid);
		}
		FREE_ZONE(cn.cn_pnbuf, cn.cn_pnlen, M_NAMEI);
	}
	cat_releasedesc(&amp;cndesc);

	*vpp = vp;
	<span class="enscript-keyword">if</span> (vp &amp;&amp; skiplock) {
		hfs_unlock(VTOC(vp));
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Flush out all the files in a filesystem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
<span class="enscript-function-name">hfs_flushfiles</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> proc *p)
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">hfs_flushfiles</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">struct</span> proc *p)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> vnode *skipvp = NULLVP;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> accounted_root_usecounts;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> i;
#<span class="enscript-reference">endif</span>

	hfsmp = VFSTOHFS(mp);

	accounted_root_usecounts = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-comment">/*
	 * The open quota files have an indirect reference on
	 * the root directory vnode.  We must account for this
	 * extra reference when doing the intial vflush.
	 */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(mp)) &amp; MNT_QUOTA) {
		<span class="enscript-comment">/* Find out how many quota files we have open. */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_qfiles[i].qf_vp != NULLVP)
				++accounted_root_usecounts;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-keyword">if</span> (accounted_root_usecounts &gt; 0) {
		<span class="enscript-comment">/* Obtain the root vnode so we can skip over it. */</span>
		skipvp = hfs_chash_getvnode(hfsmp, kHFSRootFolderID, 0, 0, 0);
	}

	error = vflush(mp, skipvp, SKIPSYSTEM | SKIPSWAP | flags);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span>(error);

	error = vflush(mp, skipvp, SKIPSYSTEM | flags);

	<span class="enscript-keyword">if</span> (skipvp) {
		<span class="enscript-comment">/*
		 * See if there are additional references on the
		 * root vp besides the ones obtained from the open
		 * quota files and CoreStorage.
		 */</span>
		<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp;
		    (vnode_isinuse(skipvp,  accounted_root_usecounts))) {
			error = EBUSY;  <span class="enscript-comment">/* root directory is still open */</span>
		}
		hfs_unlock(VTOC(skipvp));
		<span class="enscript-comment">/* release the iocount from the hfs_chash_getvnode call above. */</span>
		vnode_put(skipvp);
	}
	<span class="enscript-keyword">if</span> (error &amp;&amp; (flags &amp; FORCECLOSE) == 0)
		<span class="enscript-keyword">return</span> (error);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(mp)) &amp; MNT_QUOTA) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_qfiles[i].qf_vp == NULLVP)
				<span class="enscript-keyword">continue</span>;
			hfs_quotaoff(p, mp, i);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-keyword">if</span> (skipvp) {
		error = vflush(mp, NULLVP, SKIPSYSTEM | flags);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Update volume encoding bitmap (HFS Plus only)
 * 
 * Mark a legacy text encoding as in-use (as needed)
 * in the volume header of this HFS+ filesystem.
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_setencodingbits</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t encoding)
{
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">kIndexMacUkrainian</span>	48  <span class="enscript-comment">/* MacUkrainian encoding is 152 */</span>
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">kIndexMacFarsi</span>		49  <span class="enscript-comment">/* MacFarsi encoding is 140 */</span>

	u_int32_t	index;

	<span class="enscript-keyword">switch</span> (encoding) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kTextEncodingMacUkrainian</span>:
		index = kIndexMacUkrainian;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kTextEncodingMacFarsi</span>:
		index = kIndexMacFarsi;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		index = encoding;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Only mark the encoding as in-use if it wasn't already set */</span>
	<span class="enscript-keyword">if</span> (index &lt; 64 &amp;&amp; (hfsmp-&gt;encodingsBitmap &amp; (u_int64_t)(1ULL &lt;&lt; index)) == 0) {
		hfs_lock_mount (hfsmp);
		hfsmp-&gt;encodingsBitmap |= (u_int64_t)(1ULL &lt;&lt; index);
		MarkVCBDirty(hfsmp);
		hfs_unlock_mount(hfsmp);
	}
}

<span class="enscript-comment">/*
 * Update volume stats
 *
 * On journal volumes this will cause a volume header flush
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_volupdate</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">enum</span> volop op, <span class="enscript-type">int</span> inroot)
{
	<span class="enscript-type">struct</span> timeval tv;

	microtime(&amp;tv);

	hfs_lock_mount (hfsmp);

	MarkVCBDirty(hfsmp);
	hfsmp-&gt;hfs_mtime = tv.tv_sec;

	<span class="enscript-keyword">switch</span> (op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VOL_UPDATE</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VOL_MKDIR</span>:
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_dircount != 0xFFFFFFFF)
			++hfsmp-&gt;hfs_dircount;
		<span class="enscript-keyword">if</span> (inroot &amp;&amp; hfsmp-&gt;vcbNmRtDirs != 0xFFFF)
			++hfsmp-&gt;vcbNmRtDirs;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VOL_RMDIR</span>:
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_dircount != 0)
			--hfsmp-&gt;hfs_dircount;
		<span class="enscript-keyword">if</span> (inroot &amp;&amp; hfsmp-&gt;vcbNmRtDirs != 0xFFFF)
			--hfsmp-&gt;vcbNmRtDirs;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VOL_MKFILE</span>:
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_filecount != 0xFFFFFFFF)
			++hfsmp-&gt;hfs_filecount;
		<span class="enscript-keyword">if</span> (inroot &amp;&amp; hfsmp-&gt;vcbNmFls != 0xFFFF)
			++hfsmp-&gt;vcbNmFls;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VOL_RMFILE</span>:
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_filecount != 0)
			--hfsmp-&gt;hfs_filecount;
		<span class="enscript-keyword">if</span> (inroot &amp;&amp; hfsmp-&gt;vcbNmFls != 0xFFFF)
			--hfsmp-&gt;vcbNmFls;
		<span class="enscript-keyword">break</span>;
	}

	hfs_unlock_mount (hfsmp);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		hfs_flushvolumeheader(hfsmp, 0);
	}

	<span class="enscript-keyword">return</span> (0);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-comment">/* HFS Standard MDB flush */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_flushMDB</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> waitfor, <span class="enscript-type">int</span> altflush)
{
	ExtendedVCB *vcb = HFSTOVCB(hfsmp);
	<span class="enscript-type">struct</span> filefork *fp;
	HFSMasterDirectoryBlock	*mdb;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	<span class="enscript-type">int</span> retval;
	<span class="enscript-type">int</span> sector_size;
	ByteCount namelen;

	sector_size = hfsmp-&gt;hfs_logical_block_size;
	retval = (<span class="enscript-type">int</span>)buf_bread(hfsmp-&gt;hfs_devvp, (daddr64_t)HFS_PRI_SECTOR(sector_size), sector_size, NOCRED, &amp;bp);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (bp)
			buf_brelse(bp);
		<span class="enscript-keyword">return</span> retval;
	}

	hfs_lock_mount (hfsmp);

	mdb = (HFSMasterDirectoryBlock *)(buf_dataptr(bp) + HFS_PRI_OFFSET(sector_size));
    
	mdb-&gt;drCrDate	= SWAP_BE32 (UTCToLocal(to_hfs_time(vcb-&gt;hfs_itime)));
	mdb-&gt;drLsMod	= SWAP_BE32 (UTCToLocal(to_hfs_time(vcb-&gt;vcbLsMod)));
	mdb-&gt;drAtrb	= SWAP_BE16 (vcb-&gt;vcbAtrb);
	mdb-&gt;drNmFls	= SWAP_BE16 (vcb-&gt;vcbNmFls);
	mdb-&gt;drAllocPtr	= SWAP_BE16 (vcb-&gt;nextAllocation);
	mdb-&gt;drClpSiz	= SWAP_BE32 (vcb-&gt;vcbClpSiz);
	mdb-&gt;drNxtCNID	= SWAP_BE32 (vcb-&gt;vcbNxtCNID);
	mdb-&gt;drFreeBks	= SWAP_BE16 (vcb-&gt;freeBlocks);

	namelen = strlen((<span class="enscript-type">char</span> *)vcb-&gt;vcbVN);
	retval = utf8_to_hfs(vcb, namelen, vcb-&gt;vcbVN, mdb-&gt;drVN);
	<span class="enscript-comment">/* Retry with MacRoman in case that's how it was exported. */</span>
	<span class="enscript-keyword">if</span> (retval)
		retval = utf8_to_mac_roman(namelen, vcb-&gt;vcbVN, mdb-&gt;drVN);
	
	mdb-&gt;drVolBkUp	= SWAP_BE32 (UTCToLocal(to_hfs_time(vcb-&gt;vcbVolBkUp)));
	mdb-&gt;drWrCnt	= SWAP_BE32 (vcb-&gt;vcbWrCnt);
	mdb-&gt;drNmRtDirs	= SWAP_BE16 (vcb-&gt;vcbNmRtDirs);
	mdb-&gt;drFilCnt	= SWAP_BE32 (vcb-&gt;vcbFilCnt);
	mdb-&gt;drDirCnt	= SWAP_BE32 (vcb-&gt;vcbDirCnt);
	
	bcopy(vcb-&gt;vcbFndrInfo, mdb-&gt;drFndrInfo, <span class="enscript-keyword">sizeof</span>(mdb-&gt;drFndrInfo));

	fp = VTOF(vcb-&gt;extentsRefNum);
	mdb-&gt;drXTExtRec[0].startBlock = SWAP_BE16 (fp-&gt;ff_extents[0].startBlock);
	mdb-&gt;drXTExtRec[0].blockCount = SWAP_BE16 (fp-&gt;ff_extents[0].blockCount);
	mdb-&gt;drXTExtRec[1].startBlock = SWAP_BE16 (fp-&gt;ff_extents[1].startBlock);
	mdb-&gt;drXTExtRec[1].blockCount = SWAP_BE16 (fp-&gt;ff_extents[1].blockCount);
	mdb-&gt;drXTExtRec[2].startBlock = SWAP_BE16 (fp-&gt;ff_extents[2].startBlock);
	mdb-&gt;drXTExtRec[2].blockCount = SWAP_BE16 (fp-&gt;ff_extents[2].blockCount);
	mdb-&gt;drXTFlSize	= SWAP_BE32 (fp-&gt;ff_blocks * vcb-&gt;blockSize);
	mdb-&gt;drXTClpSiz	= SWAP_BE32 (fp-&gt;ff_clumpsize);
	FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
	
	fp = VTOF(vcb-&gt;catalogRefNum);
	mdb-&gt;drCTExtRec[0].startBlock = SWAP_BE16 (fp-&gt;ff_extents[0].startBlock);
	mdb-&gt;drCTExtRec[0].blockCount = SWAP_BE16 (fp-&gt;ff_extents[0].blockCount);
	mdb-&gt;drCTExtRec[1].startBlock = SWAP_BE16 (fp-&gt;ff_extents[1].startBlock);
	mdb-&gt;drCTExtRec[1].blockCount = SWAP_BE16 (fp-&gt;ff_extents[1].blockCount);
	mdb-&gt;drCTExtRec[2].startBlock = SWAP_BE16 (fp-&gt;ff_extents[2].startBlock);
	mdb-&gt;drCTExtRec[2].blockCount = SWAP_BE16 (fp-&gt;ff_extents[2].blockCount);
	mdb-&gt;drCTFlSize	= SWAP_BE32 (fp-&gt;ff_blocks * vcb-&gt;blockSize);
	mdb-&gt;drCTClpSiz	= SWAP_BE32 (fp-&gt;ff_clumpsize);
	FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;

	MarkVCBClean( vcb );

	hfs_unlock_mount (hfsmp);

	<span class="enscript-comment">/* If requested, flush out the alternate MDB */</span>
	<span class="enscript-keyword">if</span> (altflush) {
		<span class="enscript-type">struct</span> buf *alt_bp = NULL;

		<span class="enscript-keyword">if</span> (buf_meta_bread(hfsmp-&gt;hfs_devvp, hfsmp-&gt;hfs_partition_avh_sector, sector_size, NOCRED, &amp;alt_bp) == 0) {
			bcopy(mdb, (<span class="enscript-type">char</span> *)buf_dataptr(alt_bp) + HFS_ALT_OFFSET(sector_size), kMDBSize);

			(<span class="enscript-type">void</span>) VNOP_BWRITE(alt_bp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (alt_bp)
			buf_brelse(alt_bp);
	}

	<span class="enscript-keyword">if</span> (waitfor != MNT_WAIT)
		buf_bawrite(bp);
	<span class="enscript-keyword">else</span> 
		retval = VNOP_BWRITE(bp);

	<span class="enscript-keyword">return</span> (retval);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *  Flush any dirty in-memory mount data to the on-disk
 *  volume header.
 *
 *  Note: the on-disk volume signature is intentionally
 *  not flushed since the on-disk &quot;H+&quot; and &quot;HX&quot; signatures
 *  are always stored in-memory as &quot;H+&quot;.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_flushvolumeheader</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, 
					  hfs_flush_volume_header_options_t options)
{
	ExtendedVCB *vcb = HFSTOVCB(hfsmp);
	<span class="enscript-type">struct</span> filefork *fp;
	HFSPlusVolumeHeader *volumeHeader, *altVH;
	<span class="enscript-type">int</span> retval;
	<span class="enscript-type">struct</span> buf *bp, *alt_bp;
	<span class="enscript-type">int</span> i;
	daddr64_t priIDSector;
	bool critical = false;
	u_int16_t  signature;
	u_int16_t  hfsversion;
	daddr64_t avh_sector;
	bool altflush = ISSET(options, HFS_FVH_WRITE_ALT);

	<span class="enscript-keyword">if</span> (ISSET(options, HFS_FVH_FLUSH_IF_DIRTY)
		&amp;&amp; !hfs_header_needs_flushing(hfsmp)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		<span class="enscript-keyword">return</span>(0);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) {
		<span class="enscript-keyword">return</span> hfs_flushMDB(hfsmp, ISSET(options, HFS_FVH_WAIT) ? MNT_WAIT : 0, altflush);
	}
#<span class="enscript-reference">endif</span>
	priIDSector = (daddr64_t)((vcb-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) +
				  HFS_PRI_SECTOR(hfsmp-&gt;hfs_logical_block_size));

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    <span class="enscript-keyword">return</span> EINVAL;
	}

	bp = NULL;
	alt_bp = NULL;

	retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
			HFS_PHYSBLK_ROUNDDOWN(priIDSector, hfsmp-&gt;hfs_log_per_phys),
			hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp);
	<span class="enscript-keyword">if</span> (retval) {
		printf(<span class="enscript-string">&quot;hfs: err %d reading VH blk (vol=%s)\n&quot;</span>, retval, vcb-&gt;vcbVN);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
	}

	volumeHeader = (HFSPlusVolumeHeader *)((<span class="enscript-type">char</span> *)buf_dataptr(bp) + 
			HFS_PRI_OFFSET(hfsmp-&gt;hfs_physical_block_size));

	<span class="enscript-comment">/*
	 * Sanity check what we just read.  If it's bad, try the alternate
	 * instead.
	 */</span>
	signature = SWAP_BE16 (volumeHeader-&gt;signature);
	hfsversion   = SWAP_BE16 (volumeHeader-&gt;version);
	<span class="enscript-keyword">if</span> ((signature != kHFSPlusSigWord &amp;&amp; signature != kHFSXSigWord) ||
	    (hfsversion &lt; kHFSPlusVersion) || (hfsversion &gt; 100) ||
	    (SWAP_BE32 (volumeHeader-&gt;blockSize) != vcb-&gt;blockSize)) {
		printf(<span class="enscript-string">&quot;hfs: corrupt VH on %s, sig 0x%04x, ver %d, blksize %d\n&quot;</span>,
			       	vcb-&gt;vcbVN, signature, hfsversion, 
				SWAP_BE32 (volumeHeader-&gt;blockSize));
		hfs_mark_inconsistent(hfsmp, HFS_INCONSISTENCY_DETECTED);

		<span class="enscript-comment">/* Almost always we read AVH relative to the partition size */</span>
		avh_sector = hfsmp-&gt;hfs_partition_avh_sector;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_partition_avh_sector != hfsmp-&gt;hfs_fs_avh_sector) {
			<span class="enscript-comment">/* 
			 * The two altVH offsets do not match --- which means that a smaller file 
			 * system exists in a larger partition.  Verify that we have the correct 
			 * alternate volume header sector as per the current parititon size.  
			 * The GPT device that we are mounted on top could have changed sizes 
			 * without us knowing. 
			 *
			 * We're in a transaction, so it's safe to modify the partition_avh_sector 
			 * field if necessary.
			 */</span>

			uint64_t sector_count;

			<span class="enscript-comment">/* Get underlying device block count */</span>
			<span class="enscript-keyword">if</span> ((retval = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, DKIOCGETBLOCKCOUNT, 
							(caddr_t)&amp;sector_count, 0, vfs_context_current()))) {
				printf(<span class="enscript-string">&quot;hfs_flushVH: err %d getting block count (%s) \n&quot;</span>, retval, vcb-&gt;vcbVN);
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
			}
			
			<span class="enscript-comment">/* Partition size was changed without our knowledge */</span>
			<span class="enscript-keyword">if</span> (sector_count != (uint64_t)hfsmp-&gt;hfs_logical_block_count) {
				hfsmp-&gt;hfs_partition_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) + 
					HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size, sector_count);
				<span class="enscript-comment">/* Note: hfs_fs_avh_sector will remain unchanged */</span>
				printf (<span class="enscript-string">&quot;hfs_flushVH: partition size changed, partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>,
						hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);

				<span class="enscript-comment">/* 
				 * We just updated the offset for AVH relative to 
				 * the partition size, so the content of that AVH
				 * will be invalid.  But since we are also maintaining 
				 * a valid AVH relative to the file system size, we 
				 * can read it since primary VH and partition AVH 
				 * are not valid. 
				 */</span>
				avh_sector = hfsmp-&gt;hfs_fs_avh_sector;
			}
		}

		printf (<span class="enscript-string">&quot;hfs: trying alternate (for %s) avh_sector=%qu\n&quot;</span>, 
				(avh_sector == hfsmp-&gt;hfs_fs_avh_sector) ? <span class="enscript-string">&quot;file system&quot;</span> : <span class="enscript-string">&quot;partition&quot;</span>, avh_sector);

		<span class="enscript-keyword">if</span> (avh_sector) {
			retval = buf_meta_bread(hfsmp-&gt;hfs_devvp, 
			    HFS_PHYSBLK_ROUNDDOWN(avh_sector, hfsmp-&gt;hfs_log_per_phys),
			    hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;alt_bp);
			<span class="enscript-keyword">if</span> (retval) {
				printf(<span class="enscript-string">&quot;hfs: err %d reading alternate VH (%s)\n&quot;</span>, retval, vcb-&gt;vcbVN);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
			}
			
			altVH = (HFSPlusVolumeHeader *)((<span class="enscript-type">char</span> *)buf_dataptr(alt_bp) + 
				HFS_ALT_OFFSET(hfsmp-&gt;hfs_physical_block_size));
			signature = SWAP_BE16(altVH-&gt;signature);
			hfsversion = SWAP_BE16(altVH-&gt;version);
			
			<span class="enscript-keyword">if</span> ((signature != kHFSPlusSigWord &amp;&amp; signature != kHFSXSigWord) ||
			    (hfsversion &lt; kHFSPlusVersion) || (kHFSPlusVersion &gt; 100) ||
			    (SWAP_BE32(altVH-&gt;blockSize) != vcb-&gt;blockSize)) {
				printf(<span class="enscript-string">&quot;hfs: corrupt alternate VH on %s, sig 0x%04x, ver %d, blksize %d\n&quot;</span>,
				    vcb-&gt;vcbVN, signature, hfsversion,
				    SWAP_BE32(altVH-&gt;blockSize));
				retval = EIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
			}
			
			<span class="enscript-comment">/* The alternate is plausible, so use it. */</span>
			bcopy(altVH, volumeHeader, kMDBSize);
			buf_brelse(alt_bp);
			alt_bp = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* No alternate VH, nothing more we can do. */</span>
			retval = EIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
		}
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_start(hfsmp-&gt;jnl, bp);
	}

	<span class="enscript-comment">/*
	 * For embedded HFS+ volumes, update create date if it changed
	 * (ie from a setattrlist call)
	 */</span>
	<span class="enscript-keyword">if</span> ((vcb-&gt;hfsPlusIOPosOffset != 0) &amp;&amp;
	    (SWAP_BE32 (volumeHeader-&gt;createDate) != vcb-&gt;localCreateDate)) {
		<span class="enscript-type">struct</span> buf *bp2;
		HFSMasterDirectoryBlock	*mdb;

		retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
				HFS_PHYSBLK_ROUNDDOWN(HFS_PRI_SECTOR(hfsmp-&gt;hfs_logical_block_size), hfsmp-&gt;hfs_log_per_phys),
				hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp2);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (bp2)
				buf_brelse(bp2);
			retval = 0;
		} <span class="enscript-keyword">else</span> {
			mdb = (HFSMasterDirectoryBlock *)(buf_dataptr(bp2) +
				HFS_PRI_OFFSET(hfsmp-&gt;hfs_physical_block_size));

			<span class="enscript-keyword">if</span> ( SWAP_BE32 (mdb-&gt;drCrDate) != vcb-&gt;localCreateDate )
			  {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				    journal_modify_block_start(hfsmp-&gt;jnl, bp2);
				}

				mdb-&gt;drCrDate = SWAP_BE32 (vcb-&gt;localCreateDate);	<span class="enscript-comment">/* pick up the new create date */</span>

				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
					journal_modify_block_end(hfsmp-&gt;jnl, bp2, NULL, NULL);
				} <span class="enscript-keyword">else</span> {
					(<span class="enscript-type">void</span>) VNOP_BWRITE(bp2);		<span class="enscript-comment">/* write out the changes */</span>
				}
			  }
			<span class="enscript-keyword">else</span>
			  {
				buf_brelse(bp2);						<span class="enscript-comment">/* just release it */</span>
			  }
		  }	
	}

	hfs_lock_mount (hfsmp);

	<span class="enscript-comment">/* Note: only update the lower 16 bits worth of attributes */</span>
	volumeHeader-&gt;attributes       = SWAP_BE32 (vcb-&gt;vcbAtrb);
	volumeHeader-&gt;journalInfoBlock = SWAP_BE32 (vcb-&gt;vcbJinfoBlock);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		volumeHeader-&gt;lastMountedVersion = SWAP_BE32 (kHFSJMountVersion);
	} <span class="enscript-keyword">else</span> {
		volumeHeader-&gt;lastMountedVersion = SWAP_BE32 (kHFSPlusMountVersion);
	}
	volumeHeader-&gt;createDate	= SWAP_BE32 (vcb-&gt;localCreateDate);  <span class="enscript-comment">/* volume create date is in local time */</span>
	volumeHeader-&gt;modifyDate	= SWAP_BE32 (to_hfs_time(vcb-&gt;vcbLsMod));
	volumeHeader-&gt;backupDate	= SWAP_BE32 (to_hfs_time(vcb-&gt;vcbVolBkUp));
	volumeHeader-&gt;fileCount		= SWAP_BE32 (vcb-&gt;vcbFilCnt);
	volumeHeader-&gt;folderCount	= SWAP_BE32 (vcb-&gt;vcbDirCnt);
	volumeHeader-&gt;totalBlocks	= SWAP_BE32 (vcb-&gt;totalBlocks);
	volumeHeader-&gt;freeBlocks	= SWAP_BE32 (vcb-&gt;freeBlocks + vcb-&gt;reclaimBlocks);
	volumeHeader-&gt;nextAllocation	= SWAP_BE32 (vcb-&gt;nextAllocation);
	volumeHeader-&gt;rsrcClumpSize	= SWAP_BE32 (vcb-&gt;vcbClpSiz);
	volumeHeader-&gt;dataClumpSize	= SWAP_BE32 (vcb-&gt;vcbClpSiz);
	volumeHeader-&gt;nextCatalogID	= SWAP_BE32 (vcb-&gt;vcbNxtCNID);
	volumeHeader-&gt;writeCount	= SWAP_BE32 (vcb-&gt;vcbWrCnt);
	volumeHeader-&gt;encodingsBitmap	= SWAP_BE64 (vcb-&gt;encodingsBitmap);

	<span class="enscript-keyword">if</span> (bcmp(vcb-&gt;vcbFndrInfo, volumeHeader-&gt;finderInfo, <span class="enscript-keyword">sizeof</span>(volumeHeader-&gt;finderInfo)) != 0) {
		bcopy(vcb-&gt;vcbFndrInfo, volumeHeader-&gt;finderInfo, <span class="enscript-keyword">sizeof</span>(volumeHeader-&gt;finderInfo));
		critical = true;
	}

	<span class="enscript-keyword">if</span> (!altflush &amp;&amp; !ISSET(options, HFS_FVH_FLUSH_IF_DIRTY)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Sync Extents over-flow file meta data */</span>
	fp = VTOF(vcb-&gt;extentsRefNum);
	<span class="enscript-keyword">if</span> (FTOC(fp)-&gt;c_flag &amp; C_MODIFIED) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			volumeHeader-&gt;extentsFile.extents[i].startBlock	=
				SWAP_BE32 (fp-&gt;ff_extents[i].startBlock);
			volumeHeader-&gt;extentsFile.extents[i].blockCount	=
				SWAP_BE32 (fp-&gt;ff_extents[i].blockCount);
		}
		volumeHeader-&gt;extentsFile.logicalSize = SWAP_BE64 (fp-&gt;ff_size);
		volumeHeader-&gt;extentsFile.totalBlocks = SWAP_BE32 (fp-&gt;ff_blocks);
		volumeHeader-&gt;extentsFile.clumpSize   = SWAP_BE32 (fp-&gt;ff_clumpsize);
		FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
		altflush = true;
	}

	<span class="enscript-comment">/* Sync Catalog file meta data */</span>
	fp = VTOF(vcb-&gt;catalogRefNum);
	<span class="enscript-keyword">if</span> (FTOC(fp)-&gt;c_flag &amp; C_MODIFIED) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			volumeHeader-&gt;catalogFile.extents[i].startBlock	=
				SWAP_BE32 (fp-&gt;ff_extents[i].startBlock);
			volumeHeader-&gt;catalogFile.extents[i].blockCount	=
				SWAP_BE32 (fp-&gt;ff_extents[i].blockCount);
		}
		volumeHeader-&gt;catalogFile.logicalSize = SWAP_BE64 (fp-&gt;ff_size);
		volumeHeader-&gt;catalogFile.totalBlocks = SWAP_BE32 (fp-&gt;ff_blocks);
		volumeHeader-&gt;catalogFile.clumpSize   = SWAP_BE32 (fp-&gt;ff_clumpsize);
		FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
		altflush = true;
	}

	<span class="enscript-comment">/* Sync Allocation file meta data */</span>
	fp = VTOF(vcb-&gt;allocationsRefNum);
	<span class="enscript-keyword">if</span> (FTOC(fp)-&gt;c_flag &amp; C_MODIFIED) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			volumeHeader-&gt;allocationFile.extents[i].startBlock =
				SWAP_BE32 (fp-&gt;ff_extents[i].startBlock);
			volumeHeader-&gt;allocationFile.extents[i].blockCount =
				SWAP_BE32 (fp-&gt;ff_extents[i].blockCount);
		}
		volumeHeader-&gt;allocationFile.logicalSize = SWAP_BE64 (fp-&gt;ff_size);
		volumeHeader-&gt;allocationFile.totalBlocks = SWAP_BE32 (fp-&gt;ff_blocks);
		volumeHeader-&gt;allocationFile.clumpSize   = SWAP_BE32 (fp-&gt;ff_clumpsize);
		FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
		altflush = true;
	}

	<span class="enscript-comment">/* Sync Attribute file meta data */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
		fp = VTOF(hfsmp-&gt;hfs_attribute_vp);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			volumeHeader-&gt;attributesFile.extents[i].startBlock =
				SWAP_BE32 (fp-&gt;ff_extents[i].startBlock);
			volumeHeader-&gt;attributesFile.extents[i].blockCount =
				SWAP_BE32 (fp-&gt;ff_extents[i].blockCount);
		}
		<span class="enscript-keyword">if</span> (ISSET(FTOC(fp)-&gt;c_flag, C_MODIFIED)) {
			FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
			altflush = true;
		}
		volumeHeader-&gt;attributesFile.logicalSize = SWAP_BE64 (fp-&gt;ff_size);
		volumeHeader-&gt;attributesFile.totalBlocks = SWAP_BE32 (fp-&gt;ff_blocks);
		volumeHeader-&gt;attributesFile.clumpSize   = SWAP_BE32 (fp-&gt;ff_clumpsize);
	}

	<span class="enscript-comment">/* Sync Startup file meta data */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_vp) {
		fp = VTOF(hfsmp-&gt;hfs_startup_vp);
		<span class="enscript-keyword">if</span> (FTOC(fp)-&gt;c_flag &amp; C_MODIFIED) {
			<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
				volumeHeader-&gt;startupFile.extents[i].startBlock =
					SWAP_BE32 (fp-&gt;ff_extents[i].startBlock);
				volumeHeader-&gt;startupFile.extents[i].blockCount =
					SWAP_BE32 (fp-&gt;ff_extents[i].blockCount);
			}
			volumeHeader-&gt;startupFile.logicalSize = SWAP_BE64 (fp-&gt;ff_size);
			volumeHeader-&gt;startupFile.totalBlocks = SWAP_BE32 (fp-&gt;ff_blocks);
			volumeHeader-&gt;startupFile.clumpSize   = SWAP_BE32 (fp-&gt;ff_clumpsize);
			FTOC(fp)-&gt;c_flag &amp;= ~C_MODIFIED;
			altflush = true;
		}
	}

	<span class="enscript-keyword">if</span> (altflush)
		critical = true;
 
<span class="enscript-reference">done</span>:
	MarkVCBClean(hfsmp);
	hfs_unlock_mount (hfsmp);

	<span class="enscript-comment">/* If requested, flush out the alternate volume header */</span>
	<span class="enscript-keyword">if</span> (altflush) {
		<span class="enscript-comment">/* 
		 * The two altVH offsets do not match --- which means that a smaller file 
		 * system exists in a larger partition.  Verify that we have the correct 
		 * alternate volume header sector as per the current parititon size.  
		 * The GPT device that we are mounted on top could have changed sizes 
		 * without us knowning. 
		 *
		 * We're in a transaction, so it's safe to modify the partition_avh_sector 
		 * field if necessary.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_partition_avh_sector != hfsmp-&gt;hfs_fs_avh_sector) {
			uint64_t sector_count;

			<span class="enscript-comment">/* Get underlying device block count */</span>
			<span class="enscript-keyword">if</span> ((retval = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, DKIOCGETBLOCKCOUNT, 
							(caddr_t)&amp;sector_count, 0, vfs_context_current()))) {
				printf(<span class="enscript-string">&quot;hfs_flushVH: err %d getting block count (%s) \n&quot;</span>, retval, vcb-&gt;vcbVN);
				retval = ENXIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit</span>;
			}
			
			<span class="enscript-comment">/* Partition size was changed without our knowledge */</span>
			<span class="enscript-keyword">if</span> (sector_count != (uint64_t)hfsmp-&gt;hfs_logical_block_count) {
				hfsmp-&gt;hfs_partition_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) + 
					HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size, sector_count);
				<span class="enscript-comment">/* Note: hfs_fs_avh_sector will remain unchanged */</span>
				printf (<span class="enscript-string">&quot;hfs_flushVH: altflush: partition size changed, partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>,
						hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
			}
		}

		<span class="enscript-comment">/*
		 * First see if we need to write I/O to the &quot;secondary&quot; AVH 
		 * located at FS Size - 1024 bytes, because this one will 
		 * always go into the journal.  We put this AVH into the journal
		 * because even if the filesystem size has shrunk, this LBA should be 
		 * reachable after the partition-size modification has occurred.  
		 * The one where we need to be careful is partitionsize-1024, since the
		 * partition size should hopefully shrink. 
		 *
		 * Most of the time this block will not execute.
		 */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_fs_avh_sector) &amp;&amp; 
				(hfsmp-&gt;hfs_partition_avh_sector != hfsmp-&gt;hfs_fs_avh_sector)) {
			<span class="enscript-keyword">if</span> (buf_meta_bread(hfsmp-&gt;hfs_devvp, 
						HFS_PHYSBLK_ROUNDDOWN(hfsmp-&gt;hfs_fs_avh_sector, hfsmp-&gt;hfs_log_per_phys),
						hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;alt_bp) == 0) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
					journal_modify_block_start(hfsmp-&gt;jnl, alt_bp);
				}

				bcopy(volumeHeader, (<span class="enscript-type">char</span> *)buf_dataptr(alt_bp) + 
						HFS_ALT_OFFSET(hfsmp-&gt;hfs_physical_block_size), 
						kMDBSize);

				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
					journal_modify_block_end(hfsmp-&gt;jnl, alt_bp, NULL, NULL);
				} <span class="enscript-keyword">else</span> {
					(<span class="enscript-type">void</span>) VNOP_BWRITE(alt_bp);
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (alt_bp) {
				buf_brelse(alt_bp);
			}
		}
		
		<span class="enscript-comment">/* 
		 * Flush out alternate volume header located at 1024 bytes before
		 * end of the partition as part of journal transaction.  In 
		 * most cases, this will be the only alternate volume header 
		 * that we need to worry about because the file system size is 
		 * same as the partition size, therefore hfs_fs_avh_sector is 
		 * same as hfs_partition_avh_sector. This is the &quot;priority&quot; AVH. 
		 *
		 * However, do not always put this I/O into the journal.  If we skipped the
		 * FS-Size AVH write above, then we will put this I/O into the journal as 
		 * that indicates the two were in sync.  However, if the FS size is
		 * not the same as the partition size, we are tracking two.  We don't
		 * put it in the journal in that case, since if the partition
		 * size changes between uptimes, and we need to replay the journal,
		 * this I/O could generate an EIO if during replay it is now trying 
		 * to access blocks beyond the device EOF.  
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_partition_avh_sector) {
			<span class="enscript-keyword">if</span> (buf_meta_bread(hfsmp-&gt;hfs_devvp, 
						HFS_PHYSBLK_ROUNDDOWN(hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_log_per_phys),
						hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;alt_bp) == 0) {

				<span class="enscript-comment">/* only one AVH, put this I/O in the journal. */</span>
				<span class="enscript-keyword">if</span> ((hfsmp-&gt;jnl) &amp;&amp; (hfsmp-&gt;hfs_partition_avh_sector == hfsmp-&gt;hfs_fs_avh_sector)) {
					journal_modify_block_start(hfsmp-&gt;jnl, alt_bp);
				}

				bcopy(volumeHeader, (<span class="enscript-type">char</span> *)buf_dataptr(alt_bp) + 
						HFS_ALT_OFFSET(hfsmp-&gt;hfs_physical_block_size), 
						kMDBSize);

				<span class="enscript-comment">/* If journaled and we only have one AVH to track */</span>
				<span class="enscript-keyword">if</span> ((hfsmp-&gt;jnl) &amp;&amp; (hfsmp-&gt;hfs_partition_avh_sector == hfsmp-&gt;hfs_fs_avh_sector)) {
					journal_modify_block_end (hfsmp-&gt;jnl, alt_bp, NULL, NULL);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* 
					 * If we don't have a journal or there are two AVH's at the
					 * moment, then this one doesn't go in the journal.  Note that 
					 * this one may generate I/O errors, since the partition
					 * can be resized behind our backs at any moment and this I/O 
					 * may now appear to be beyond the device EOF.
					 */</span>
					(<span class="enscript-type">void</span>) VNOP_BWRITE(alt_bp);
					hfs_flush(hfsmp, HFS_FLUSH_CACHE);
				}		
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (alt_bp) {
				buf_brelse(alt_bp);
			}
		}
	}

	<span class="enscript-comment">/* Finish modifying the block for the primary VH */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_end(hfsmp-&gt;jnl, bp, NULL, NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!ISSET(options, HFS_FVH_WAIT)) {
			buf_bawrite(bp);
		} <span class="enscript-keyword">else</span> {
			retval = VNOP_BWRITE(bp);
			<span class="enscript-comment">/* When critical data changes, flush the device cache */</span>
			<span class="enscript-keyword">if</span> (critical &amp;&amp; (retval == 0)) {
				hfs_flush(hfsmp, HFS_FLUSH_CACHE);
			}
		}
	}
	hfs_end_transaction(hfsmp);
 
	<span class="enscript-keyword">return</span> (retval);

<span class="enscript-reference">err_exit</span>:
	<span class="enscript-keyword">if</span> (alt_bp)
		buf_brelse(alt_bp);
	<span class="enscript-keyword">if</span> (bp)
		buf_brelse(bp);
	hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">/*
 * Creates a UUID from a unique &quot;name&quot; in the HFS UUID Name space.
 * See version 3 UUID.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_getvoluuid</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uuid_t result)
{
	MD5_CTX  md5c;
	uint8_t  rawUUID[8];

	((uint32_t *)rawUUID)[0] = hfsmp-&gt;vcbFndrInfo[6];
	((uint32_t *)rawUUID)[1] = hfsmp-&gt;vcbFndrInfo[7];

	MD5Init( &amp;md5c );
	MD5Update( &amp;md5c, HFS_UUID_NAMESPACE_ID, <span class="enscript-keyword">sizeof</span>( uuid_t ) );
	MD5Update( &amp;md5c, rawUUID, <span class="enscript-keyword">sizeof</span> (rawUUID) );
	MD5Final( result, &amp;md5c );

	result[6] = 0x30 | ( result[6] &amp; 0x0F );
	result[8] = 0x80 | ( result[8] &amp; 0x3F );
}

<span class="enscript-comment">/*
 * Get file system attributes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vfs_getattr</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfs_attr *fsap, __unused vfs_context_t context)
{
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ATTR_CMN_VALIDMASK</span> ATTR_CMN_VALIDMASK
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ATTR_FILE_VALIDMASK</span> (ATTR_FILE_VALIDMASK &amp; ~(ATTR_FILE_FILETYPE | ATTR_FILE_FORKCOUNT | ATTR_FILE_FORKLIST))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ATTR_CMN_VOL_VALIDMASK</span> (ATTR_CMN_VALIDMASK &amp; ~(ATTR_CMN_ACCTIME))

	ExtendedVCB *vcb = VFSTOVCB(mp);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VFSTOHFS(mp);
	u_int32_t freeCNIDs;

	<span class="enscript-type">int</span> searchfs_on = 0;
	<span class="enscript-type">int</span> exchangedata_on = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SEARCHFS</span>
	searchfs_on = 1;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected(mp)) {
		exchangedata_on = 0;
	}
#<span class="enscript-reference">endif</span>

	freeCNIDs = (u_int32_t)0xFFFFFFFF - (u_int32_t)hfsmp-&gt;vcbNxtCNID;

	VFSATTR_RETURN(fsap, f_objcount, (u_int64_t)hfsmp-&gt;vcbFilCnt + (u_int64_t)hfsmp-&gt;vcbDirCnt);
	VFSATTR_RETURN(fsap, f_filecount, (u_int64_t)hfsmp-&gt;vcbFilCnt);
	VFSATTR_RETURN(fsap, f_dircount, (u_int64_t)hfsmp-&gt;vcbDirCnt);
	VFSATTR_RETURN(fsap, f_maxobjcount, (u_int64_t)0xFFFFFFFF);
	VFSATTR_RETURN(fsap, f_iosize, (size_t)cluster_max_io_size(mp, 0));
	VFSATTR_RETURN(fsap, f_blocks, (u_int64_t)hfsmp-&gt;totalBlocks);
	VFSATTR_RETURN(fsap, f_bfree, (u_int64_t)hfs_freeblks(hfsmp, 0));
	VFSATTR_RETURN(fsap, f_bavail, (u_int64_t)hfs_freeblks(hfsmp, 1));
	VFSATTR_RETURN(fsap, f_bsize, (u_int32_t)vcb-&gt;blockSize);
	<span class="enscript-comment">/* XXX needs clarification */</span>
	VFSATTR_RETURN(fsap, f_bused, hfsmp-&gt;totalBlocks - hfs_freeblks(hfsmp, 1));
	<span class="enscript-comment">/* Maximum files is constrained by total blocks. */</span>
	VFSATTR_RETURN(fsap, f_files, (u_int64_t)(hfsmp-&gt;totalBlocks - 2));
	VFSATTR_RETURN(fsap, f_ffree, MIN((u_int64_t)freeCNIDs, (u_int64_t)hfs_freeblks(hfsmp, 1)));

	fsap-&gt;f_fsid.val[0] = hfsmp-&gt;hfs_raw_dev;
	fsap-&gt;f_fsid.val[1] = vfs_typenum(mp);
	VFSATTR_SET_SUPPORTED(fsap, f_fsid);

	VFSATTR_RETURN(fsap, f_signature, vcb-&gt;vcbSigWord);
	VFSATTR_RETURN(fsap, f_carbon_fsid, 0);

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_capabilities)) {
		vol_capabilities_attr_t *cap;
	
		cap = &amp;fsap-&gt;f_capabilities;

		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
			<span class="enscript-comment">/* HFS+ &amp; variants */</span>
			cap-&gt;capabilities[VOL_CAPABILITIES_FORMAT] =
				VOL_CAP_FMT_PERSISTENTOBJECTIDS |
				VOL_CAP_FMT_SYMBOLICLINKS |
				VOL_CAP_FMT_HARDLINKS |
				VOL_CAP_FMT_JOURNAL |
				VOL_CAP_FMT_ZERO_RUNS |
				(hfsmp-&gt;jnl ? VOL_CAP_FMT_JOURNAL_ACTIVE : 0) |
				(hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE ? VOL_CAP_FMT_CASE_SENSITIVE : 0) |
				VOL_CAP_FMT_CASE_PRESERVING |
				VOL_CAP_FMT_FAST_STATFS | 
				VOL_CAP_FMT_2TB_FILESIZE |
				VOL_CAP_FMT_HIDDEN_FILES |
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
				VOL_CAP_FMT_PATH_FROM_ID |
				VOL_CAP_FMT_DECMPFS_COMPRESSION;
#<span class="enscript-reference">else</span>
				VOL_CAP_FMT_PATH_FROM_ID;
#<span class="enscript-reference">endif</span>
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* HFS standard */</span>
			cap-&gt;capabilities[VOL_CAPABILITIES_FORMAT] =
				VOL_CAP_FMT_PERSISTENTOBJECTIDS |
				VOL_CAP_FMT_CASE_PRESERVING |
				VOL_CAP_FMT_FAST_STATFS |
				VOL_CAP_FMT_HIDDEN_FILES |
				VOL_CAP_FMT_PATH_FROM_ID;
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * The capabilities word in 'cap' tell you whether or not 
		 * this particular filesystem instance has feature X enabled.
		 */</span>

		cap-&gt;capabilities[VOL_CAPABILITIES_INTERFACES] =
			VOL_CAP_INT_ATTRLIST |
			VOL_CAP_INT_NFSEXPORT |
			VOL_CAP_INT_READDIRATTR |
			VOL_CAP_INT_ALLOCATE |
			VOL_CAP_INT_VOL_RENAME |
			VOL_CAP_INT_ADVLOCK |
			VOL_CAP_INT_FLOCK |
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
			VOL_CAP_INT_EXTENDED_ATTR |
			VOL_CAP_INT_NAMEDSTREAMS;
#<span class="enscript-reference">else</span>
			VOL_CAP_INT_EXTENDED_ATTR;
#<span class="enscript-reference">endif</span>
		
		<span class="enscript-comment">/* HFS may conditionally support searchfs and exchangedata depending on the runtime */</span>

		<span class="enscript-keyword">if</span> (searchfs_on) {
			cap-&gt;capabilities[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_SEARCHFS;
		}
		<span class="enscript-keyword">if</span> (exchangedata_on) {
			cap-&gt;capabilities[VOL_CAPABILITIES_INTERFACES] |= VOL_CAP_INT_EXCHANGEDATA;
		}

		cap-&gt;capabilities[VOL_CAPABILITIES_RESERVED1] = 0;
		cap-&gt;capabilities[VOL_CAPABILITIES_RESERVED2] = 0;

		cap-&gt;valid[VOL_CAPABILITIES_FORMAT] =
			VOL_CAP_FMT_PERSISTENTOBJECTIDS |
			VOL_CAP_FMT_SYMBOLICLINKS |
			VOL_CAP_FMT_HARDLINKS |
			VOL_CAP_FMT_JOURNAL |
			VOL_CAP_FMT_JOURNAL_ACTIVE |
			VOL_CAP_FMT_NO_ROOT_TIMES |
			VOL_CAP_FMT_SPARSE_FILES |
			VOL_CAP_FMT_ZERO_RUNS |
			VOL_CAP_FMT_CASE_SENSITIVE |
			VOL_CAP_FMT_CASE_PRESERVING |
			VOL_CAP_FMT_FAST_STATFS |
			VOL_CAP_FMT_2TB_FILESIZE |
			VOL_CAP_FMT_OPENDENYMODES |
			VOL_CAP_FMT_HIDDEN_FILES |
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
			VOL_CAP_FMT_PATH_FROM_ID |
			VOL_CAP_FMT_DECMPFS_COMPRESSION;
#<span class="enscript-reference">else</span>
			VOL_CAP_FMT_PATH_FROM_ID;
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * Bits in the &quot;valid&quot; field tell you whether or not the on-disk
		 * format supports feature X.
		 */</span>

		cap-&gt;valid[VOL_CAPABILITIES_INTERFACES] =
			VOL_CAP_INT_ATTRLIST |
			VOL_CAP_INT_NFSEXPORT |
			VOL_CAP_INT_READDIRATTR |
			VOL_CAP_INT_COPYFILE |
			VOL_CAP_INT_ALLOCATE |
			VOL_CAP_INT_VOL_RENAME |
			VOL_CAP_INT_ADVLOCK |
			VOL_CAP_INT_FLOCK |
			VOL_CAP_INT_MANLOCK |
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
			VOL_CAP_INT_EXTENDED_ATTR |
			VOL_CAP_INT_NAMEDSTREAMS;
#<span class="enscript-reference">else</span>
			VOL_CAP_INT_EXTENDED_ATTR;
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* HFS always supports exchangedata and searchfs in the on-disk format natively */</span>
		cap-&gt;valid[VOL_CAPABILITIES_INTERFACES] |= (VOL_CAP_INT_SEARCHFS | VOL_CAP_INT_EXCHANGEDATA);


		cap-&gt;valid[VOL_CAPABILITIES_RESERVED1] = 0;
		cap-&gt;valid[VOL_CAPABILITIES_RESERVED2] = 0;
		VFSATTR_SET_SUPPORTED(fsap, f_capabilities);
	}
	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_attributes)) {
		vol_attributes_attr_t *attrp = &amp;fsap-&gt;f_attributes;

        	attrp-&gt;validattr.commonattr = HFS_ATTR_CMN_VOL_VALIDMASK;
        	attrp-&gt;validattr.volattr = ATTR_VOL_VALIDMASK &amp; ~ATTR_VOL_INFO;
        	attrp-&gt;validattr.dirattr = ATTR_DIR_VALIDMASK;
        	attrp-&gt;validattr.fileattr = HFS_ATTR_FILE_VALIDMASK;
        	attrp-&gt;validattr.forkattr = 0;

        	attrp-&gt;nativeattr.commonattr = HFS_ATTR_CMN_VOL_VALIDMASK;
        	attrp-&gt;nativeattr.volattr = ATTR_VOL_VALIDMASK &amp; ~ATTR_VOL_INFO;
        	attrp-&gt;nativeattr.dirattr = ATTR_DIR_VALIDMASK;
        	attrp-&gt;nativeattr.fileattr = HFS_ATTR_FILE_VALIDMASK;
        	attrp-&gt;nativeattr.forkattr = 0;
		VFSATTR_SET_SUPPORTED(fsap, f_attributes);
	}	
	fsap-&gt;f_create_time.tv_sec = hfsmp-&gt;hfs_itime;
	fsap-&gt;f_create_time.tv_nsec = 0;
	VFSATTR_SET_SUPPORTED(fsap, f_create_time);
	fsap-&gt;f_modify_time.tv_sec = hfsmp-&gt;vcbLsMod;
	fsap-&gt;f_modify_time.tv_nsec = 0;
	VFSATTR_SET_SUPPORTED(fsap, f_modify_time);

	fsap-&gt;f_backup_time.tv_sec = hfsmp-&gt;vcbVolBkUp;
	fsap-&gt;f_backup_time.tv_nsec = 0;
	VFSATTR_SET_SUPPORTED(fsap, f_backup_time);
	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_fssubtype)) {
		u_int16_t subtype = 0;

		<span class="enscript-comment">/*
		 * Subtypes (flavors) for HFS
		 *   0:   Mac OS Extended
		 *   1:   Mac OS Extended (Journaled) 
		 *   2:   Mac OS Extended (Case Sensitive) 
		 *   3:   Mac OS Extended (Case Sensitive, Journaled) 
		 *   4 - 127:   Reserved
		 * 128:   Mac OS Standard
		 * 
		 */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				subtype |= HFS_SUBTYPE_JOURNALED;
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE) {
				subtype |= HFS_SUBTYPE_CASESENSITIVE;
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			subtype = HFS_SUBTYPE_STANDARDHFS;
		} 
#<span class="enscript-reference">endif</span>
		fsap-&gt;f_fssubtype = subtype;
		VFSATTR_SET_SUPPORTED(fsap, f_fssubtype);
	}

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_vol_name)) {
		strlcpy(fsap-&gt;f_vol_name, (<span class="enscript-type">char</span> *) hfsmp-&gt;vcbVN, MAXPATHLEN);
		VFSATTR_SET_SUPPORTED(fsap, f_vol_name);
	}
	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_uuid)) {
		hfs_getvoluuid(hfsmp, fsap-&gt;f_uuid);
		VFSATTR_SET_SUPPORTED(fsap, f_uuid);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Perform a volume rename.  Requires the FS' root vp.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_rename_volume</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, proc_t p)
{
	ExtendedVCB *vcb = VTOVCB(vp);
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">struct</span> cat_desc to_desc;
	<span class="enscript-type">struct</span> cat_desc todir_desc;
	<span class="enscript-type">struct</span> cat_desc new_desc;
	cat_cookie_t cookie;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> converted_volname[256];
	size_t volname_length = 0;
	size_t conv_volname_length = 0;
	

	<span class="enscript-comment">/*
	 * Ignore attempts to rename a volume to a zero-length name.
	 */</span>
	<span class="enscript-keyword">if</span> (name[0] == 0)
		<span class="enscript-keyword">return</span>(0);

	bzero(&amp;to_desc, <span class="enscript-keyword">sizeof</span>(to_desc));
	bzero(&amp;todir_desc, <span class="enscript-keyword">sizeof</span>(todir_desc));
	bzero(&amp;new_desc, <span class="enscript-keyword">sizeof</span>(new_desc));
	bzero(&amp;cookie, <span class="enscript-keyword">sizeof</span>(cookie));

	todir_desc.cd_parentcnid = kHFSRootParentID;
	todir_desc.cd_cnid = kHFSRootFolderID;
	todir_desc.cd_flags = CD_ISDIR;

	to_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)name;
	to_desc.cd_namelen = strlen(name);
	to_desc.cd_parentcnid = kHFSRootParentID;
	to_desc.cd_cnid = cp-&gt;c_cnid;
	to_desc.cd_flags = CD_ISDIR;

	<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)) == 0) {
		<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) == 0) {
			<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_RENAME, &amp;cookie, p)) == 0) {
				lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

				error = cat_rename(hfsmp, &amp;cp-&gt;c_desc, &amp;todir_desc, &amp;to_desc, &amp;new_desc);

				<span class="enscript-comment">/*
				 * If successful, update the name in the VCB, ensure it's terminated.
				 */</span>
				<span class="enscript-keyword">if</span> (error == 0) {
					strlcpy((<span class="enscript-type">char</span> *)vcb-&gt;vcbVN, name, <span class="enscript-keyword">sizeof</span>(vcb-&gt;vcbVN));

					volname_length = strlen ((<span class="enscript-type">const</span> <span class="enscript-type">char</span>*)vcb-&gt;vcbVN);
					<span class="enscript-comment">/* Send the volume name down to CoreStorage if necessary */</span>	
					error = utf8_normalizestr(vcb-&gt;vcbVN, volname_length, (u_int8_t*)converted_volname, &amp;conv_volname_length, 256, UTF_PRECOMPOSED);
					<span class="enscript-keyword">if</span> (error == 0) {
						(<span class="enscript-type">void</span>) VNOP_IOCTL (hfsmp-&gt;hfs_devvp, _DKIOCCSSETLVNAME, converted_volname, 0, vfs_context_current());
					}
					error = 0;
				}
				
				hfs_systemfile_unlock(hfsmp, lockflags);
				cat_postflight(hfsmp, &amp;cookie, p);
			
				<span class="enscript-keyword">if</span> (error)
					MarkVCBDirty(vcb);
				(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
			}
			hfs_end_transaction(hfsmp);
		}			
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* Release old allocated name buffer */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_flags &amp; CD_HASBUF) {
				<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tmp_name = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr;
		
				cp-&gt;c_desc.cd_nameptr = 0;
				cp-&gt;c_desc.cd_namelen = 0;
				cp-&gt;c_desc.cd_flags &amp;= ~CD_HASBUF;
				vfs_removename(tmp_name);
			}			
			<span class="enscript-comment">/* Update cnode's catalog descriptor */</span>
			replace_desc(cp, &amp;new_desc);
			vcb-&gt;volumeNameEncodingHint = new_desc.cd_encoding;
			cp-&gt;c_touch_chgtime = TRUE;
		}

		hfs_unlock(cp);
	}
	
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Get file system attributes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vfs_setattr</span>(<span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vfs_attr *fsap, __unused vfs_context_t context)
{
	kauth_cred_t cred = vfs_context_ucred(context);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/*
	 * Must be superuser or owner of filesystem to change volume attributes
	 */</span>
	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(cred) &amp;&amp; (kauth_cred_getuid(cred) != vfs_statfs(mp)-&gt;f_owner))
		<span class="enscript-keyword">return</span>(EACCES);

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_vol_name)) {
		vnode_t root_vp;
		
		error = hfs_vfs_root(mp, &amp;root_vp, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		error = hfs_rename_volume(root_vp, fsap-&gt;f_vol_name, vfs_context_proc(context));
		(<span class="enscript-type">void</span>) vnode_put(root_vp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		VFSATTR_SET_SUPPORTED(fsap, f_vol_name);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* If a runtime corruption is detected, set the volume inconsistent 
 * bit in the volume attributes.  The volume inconsistent bit is a persistent
 * bit which represents that the volume is corrupt and needs repair.  
 * The volume inconsistent bit can be set from the kernel when it detects
 * runtime corruption or from file system repair utilities like fsck_hfs when
 * a repair operation fails.  The bit should be cleared only from file system 
 * verify/repair utility like fsck_hfs when a verify/repair succeeds.
 */</span>
__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_mark_inconsistent</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp,
								  hfs_inconsistency_reason_t reason)
{
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;vcbAtrb &amp; kHFSVolumeInconsistentMask) == 0) {
		hfsmp-&gt;vcbAtrb |= kHFSVolumeInconsistentMask;
		MarkVCBDirty(hfsmp);
	}
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY)==0) {
		<span class="enscript-keyword">switch</span> (reason) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_INCONSISTENCY_DETECTED</span>:
			printf(<span class="enscript-string">&quot;hfs_mark_inconsistent: Runtime corruption detected on %s, fsck will be forced on next mount.\n&quot;</span>, 
				   hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_ROLLBACK_FAILED</span>:
			printf(<span class="enscript-string">&quot;hfs_mark_inconsistent: Failed to roll back; volume `%s' might be inconsistent; fsck will be forced on next mount.\n&quot;</span>, 
				   hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_OP_INCOMPLETE</span>:
			printf(<span class="enscript-string">&quot;hfs_mark_inconsistent: Failed to complete operation; volume `%s' might be inconsistent; fsck will be forced on next mount.\n&quot;</span>, 
				   hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCK_FORCED</span>:
			printf(<span class="enscript-string">&quot;hfs_mark_inconsistent: fsck requested for `%s'; fsck will be forced on next mount.\n&quot;</span>,
				   hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">break</span>;	
		}
	}
	hfs_unlock_mount (hfsmp);
}

<span class="enscript-comment">/* Replay the journal on the device node provided.  Returns zero if 
 * journal replay succeeded or no journal was supposed to be replayed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_journal_replay</span>(vnode_t devvp, vfs_context_t context)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mount *mp = NULL;
	<span class="enscript-type">struct</span> hfs_mount_args *args = NULL;

	<span class="enscript-comment">/* Replay allowed only on raw devices */</span>
	<span class="enscript-keyword">if</span> (!vnode_ischr(devvp) &amp;&amp; !vnode_isblk(devvp)) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Create dummy mount structures */</span>
	MALLOC(mp, <span class="enscript-type">struct</span> mount *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (mp == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));
	mount_lock_init(mp);

	MALLOC(args, <span class="enscript-type">struct</span> hfs_mount_args *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_mount_args), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (args == NULL) {
		retval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(args, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_mount_args));

	retval = hfs_mountfs(devvp, mp, args, 1, context);
	buf_flushdirtyblks(devvp, TRUE, 0, <span class="enscript-string">&quot;hfs_journal_replay&quot;</span>);
	
	<span class="enscript-comment">/* FSYNC the devnode to be sure all data has been flushed */</span>
	error = VNOP_FSYNC(devvp, MNT_WAIT, context);
	<span class="enscript-keyword">if</span> (error) {
		retval = error;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (mp) {
		mount_lock_destroy(mp);
		FREE(mp, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (args) {
		FREE(args, M_TEMP);
	}
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">/* 
 * Cancel the syncer
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_syncer_free</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    <span class="enscript-keyword">if</span> (hfsmp &amp;&amp; hfsmp-&gt;hfs_syncer) {
        hfs_syncer_lock(hfsmp);
		
        <span class="enscript-comment">/*
         * First, make sure everything else knows we don't want any more
         * requests queued.
         */</span>
        thread_call_t syncer = hfsmp-&gt;hfs_syncer;
        hfsmp-&gt;hfs_syncer = NULL;

        hfs_syncer_unlock(hfsmp);

        <span class="enscript-comment">// Now deal with requests that are outstanding
</span>        <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_sync_incomplete) {
            <span class="enscript-keyword">if</span> (thread_call_cancel(syncer)) {
                <span class="enscript-comment">// We managed to cancel the timer so we're done
</span>                hfsmp-&gt;hfs_sync_incomplete = FALSE;
            } <span class="enscript-keyword">else</span> {
                <span class="enscript-comment">// Syncer must be running right now so we have to wait
</span>                hfs_syncer_lock(hfsmp);
                <span class="enscript-keyword">while</span> (hfsmp-&gt;hfs_sync_incomplete)
                    hfs_syncer_wait(hfsmp);
                hfs_syncer_unlock(hfsmp);
            }
        }

        <span class="enscript-comment">// Now we're safe to free the syncer
</span>        thread_call_free(syncer);
    }
}

<span class="enscript-comment">/*
 * hfs vfs operations.
 */</span>
<span class="enscript-type">struct</span> vfsops hfs_vfsops = {
	hfs_mount,
	hfs_start,
	hfs_unmount,
	hfs_vfs_root,
	hfs_quotactl,
	hfs_vfs_getattr, 	<span class="enscript-comment">/* was hfs_statfs */</span>
	hfs_sync,
	hfs_vfs_vget,
	hfs_fhtovp,
	hfs_vptofh,
	hfs_init,
	hfs_sysctl,
	hfs_vfs_setattr,
	{NULL}
};
</pre>
<hr />
</body></html>