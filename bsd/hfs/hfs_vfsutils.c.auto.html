<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_vfsutils.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_vfsutils.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*	@(#)hfs_vfsutils.c	4.0
*
*	(c) 1997-2002 Apple Computer, Inc.  All Rights Reserved
*
*	hfs_vfsutils.c -- Routines that go between the HFS layer and the VFS.
*
*/</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

<span class="enscript-comment">/* for parsing boot-args */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_dbg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_mount.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_fsctl.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cprotect.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/FileMgrInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/HFSUnicodeWrappers.h&quot;</span>

<span class="enscript-comment">/* Enable/disable debugging code for live volume resizing, defined in hfs_resize.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> hfs_resize_debug;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseMetaFileVNode</span>(<span class="enscript-type">struct</span> vnode *vp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_late_journal_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp, <span class="enscript-type">void</span> *_args);

<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">hfs_hotfile_freeblocks</span>(<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_thaw_locked</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MOUNT_DEBUG</span> 1


<span class="enscript-comment">//*******************************************************************************
</span><span class="enscript-comment">// Note: Finder information in the HFS/HFS+ metadata are considered opaque and
</span><span class="enscript-comment">//       hence are not in the right byte order on little endian machines. It is
</span><span class="enscript-comment">//       the responsibility of the finder and other clients to swap the data.
</span><span class="enscript-comment">//*******************************************************************************
</span>
<span class="enscript-comment">//*******************************************************************************
</span><span class="enscript-comment">//	Routine:	hfs_MountHFSVolume
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*******************************************************************************
</span><span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hfs_catname[] = <span class="enscript-string">&quot;Catalog B-tree&quot;</span>;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hfs_extname[] = <span class="enscript-string">&quot;Extents B-tree&quot;</span>;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hfs_vbmname[] = <span class="enscript-string">&quot;Volume Bitmap&quot;</span>;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hfs_attrname[] = <span class="enscript-string">&quot;Attribute B-tree&quot;</span>;
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hfs_startupname[] = <span class="enscript-string">&quot;Startup File&quot;</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
OSErr <span class="enscript-function-name">hfs_MountHFSVolume</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSMasterDirectoryBlock *mdb,
		__unused <span class="enscript-type">struct</span> proc *p)
{
	ExtendedVCB *vcb = HFSTOVCB(hfsmp);
	<span class="enscript-type">int</span> error;
	ByteCount utf8chars;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr cnattr;
	<span class="enscript-type">struct</span> cat_fork fork;
	<span class="enscript-type">int</span> newvnode_flags = 0;

	<span class="enscript-comment">/* Block size must be a multiple of 512 */</span>
	<span class="enscript-keyword">if</span> (SWAP_BE32(mdb-&gt;drAlBlkSiz) == 0 ||
	    (SWAP_BE32(mdb-&gt;drAlBlkSiz) &amp; 0x01FF) != 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* don't mount a writeable volume if its dirty, it must be cleaned by fsck_hfs */</span>
	<span class="enscript-keyword">if</span> (((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0) &amp;&amp;
	    ((SWAP_BE16(mdb-&gt;drAtrb) &amp; kHFSVolumeUnmountedMask) == 0)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	hfsmp-&gt;hfs_flags |= HFS_STANDARD;
	<span class="enscript-comment">/*
	 * The MDB seems OK: transfer info from it into VCB
	 * Note - the VCB starts out clear (all zeros)
	 *
	 */</span>
	vcb-&gt;vcbSigWord		= SWAP_BE16 (mdb-&gt;drSigWord);
	vcb-&gt;hfs_itime		= to_bsd_time(LocalToUTC(SWAP_BE32(mdb-&gt;drCrDate)));
	vcb-&gt;localCreateDate	= SWAP_BE32 (mdb-&gt;drCrDate);
	vcb-&gt;vcbLsMod		= to_bsd_time(LocalToUTC(SWAP_BE32(mdb-&gt;drLsMod)));
	vcb-&gt;vcbAtrb		= SWAP_BE16 (mdb-&gt;drAtrb);
	vcb-&gt;vcbNmFls		= SWAP_BE16 (mdb-&gt;drNmFls);
	vcb-&gt;vcbVBMSt		= SWAP_BE16 (mdb-&gt;drVBMSt);
	vcb-&gt;nextAllocation	= SWAP_BE16 (mdb-&gt;drAllocPtr);
	vcb-&gt;totalBlocks	= SWAP_BE16 (mdb-&gt;drNmAlBlks);
	vcb-&gt;allocLimit		= vcb-&gt;totalBlocks;
	vcb-&gt;blockSize		= SWAP_BE32 (mdb-&gt;drAlBlkSiz);
	vcb-&gt;vcbClpSiz		= SWAP_BE32 (mdb-&gt;drClpSiz);
	vcb-&gt;vcbAlBlSt		= SWAP_BE16 (mdb-&gt;drAlBlSt);
	vcb-&gt;vcbNxtCNID		= SWAP_BE32 (mdb-&gt;drNxtCNID);
	vcb-&gt;freeBlocks		= SWAP_BE16 (mdb-&gt;drFreeBks);
	vcb-&gt;vcbVolBkUp		= to_bsd_time(LocalToUTC(SWAP_BE32(mdb-&gt;drVolBkUp)));
	vcb-&gt;vcbWrCnt		= SWAP_BE32 (mdb-&gt;drWrCnt);
	vcb-&gt;vcbNmRtDirs	= SWAP_BE16 (mdb-&gt;drNmRtDirs);
	vcb-&gt;vcbFilCnt		= SWAP_BE32 (mdb-&gt;drFilCnt);
	vcb-&gt;vcbDirCnt		= SWAP_BE32 (mdb-&gt;drDirCnt);
	bcopy(mdb-&gt;drFndrInfo, vcb-&gt;vcbFndrInfo, <span class="enscript-keyword">sizeof</span>(vcb-&gt;vcbFndrInfo));
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0)
		vcb-&gt;vcbWrCnt++;	<span class="enscript-comment">/* Compensate for write of MDB on last flush */</span>

	<span class="enscript-comment">/* convert hfs encoded name into UTF-8 string */</span>
	error = hfs_to_utf8(vcb, mdb-&gt;drVN, NAME_MAX, &amp;utf8chars, vcb-&gt;vcbVN);
	<span class="enscript-comment">/*
	 * When an HFS name cannot be encoded with the current
	 * volume encoding we use MacRoman as a fallback.
	 */</span>
	<span class="enscript-keyword">if</span> (error || (utf8chars == 0)) {
		error = mac_roman_to_utf8(mdb-&gt;drVN, NAME_MAX, &amp;utf8chars, vcb-&gt;vcbVN);
		<span class="enscript-comment">/* If we fail to encode to UTF8 from Mac Roman, the name is bad.  Deny the mount */</span>
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
		}
	}

	hfsmp-&gt;hfs_logBlockSize = BestBlockSizeFit(vcb-&gt;blockSize, MAXBSIZE, hfsmp-&gt;hfs_logical_block_size);
	vcb-&gt;vcbVBMIOSize = kHFSBlockSize;

	<span class="enscript-comment">/* Generate the partition-based AVH location */</span>
	hfsmp-&gt;hfs_partition_avh_sector = HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size,
	                                          hfsmp-&gt;hfs_logical_block_count);
	
	<span class="enscript-comment">/* HFS standard is read-only, so just stuff the FS location in here, too */</span>
	hfsmp-&gt;hfs_fs_avh_sector = hfsmp-&gt;hfs_partition_avh_sector;	

	bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
	cndesc.cd_parentcnid = kHFSRootParentID;
	cndesc.cd_flags |= CD_ISMETA;
	bzero(&amp;cnattr, <span class="enscript-keyword">sizeof</span>(cnattr));
	cnattr.ca_linkcount = 1;
	cnattr.ca_mode = S_IFREG;
	bzero(&amp;fork, <span class="enscript-keyword">sizeof</span>(fork));

	<span class="enscript-comment">/*
	 * Set up Extents B-tree vnode
	 */</span>
	cndesc.cd_nameptr = hfs_extname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_extname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSExtentsFileID;
	fork.cf_size = SWAP_BE32(mdb-&gt;drXTFlSize);
	fork.cf_blocks = fork.cf_size / vcb-&gt;blockSize;
	fork.cf_clump = SWAP_BE32(mdb-&gt;drXTClpSiz);
	fork.cf_vblocks = 0;
	fork.cf_extents[0].startBlock = SWAP_BE16(mdb-&gt;drXTExtRec[0].startBlock);
	fork.cf_extents[0].blockCount = SWAP_BE16(mdb-&gt;drXTExtRec[0].blockCount);
	fork.cf_extents[1].startBlock = SWAP_BE16(mdb-&gt;drXTExtRec[1].startBlock);
	fork.cf_extents[1].blockCount = SWAP_BE16(mdb-&gt;drXTExtRec[1].blockCount);
	fork.cf_extents[2].startBlock = SWAP_BE16(mdb-&gt;drXTExtRec[2].startBlock);
	fork.cf_extents[2].blockCount = SWAP_BE16(mdb-&gt;drXTExtRec[2].blockCount);
	cnattr.ca_blocks = fork.cf_blocks;

	error = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;fork,
	                        &amp;hfsmp-&gt;hfs_extents_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error creating Ext Vnode (%d) \n&quot;</span>, error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
	}
	error = MacToVFSError(BTOpenPath(VTOF(hfsmp-&gt;hfs_extents_vp),
	                                 (KeyCompareProcPtr)CompareExtentKeys));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error opening Ext Vnode (%d) \n&quot;</span>, error);
		}
		hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
	}
	hfsmp-&gt;hfs_extents_cp = VTOC(hfsmp-&gt;hfs_extents_vp);

	<span class="enscript-comment">/*
	 * Set up Catalog B-tree vnode...
	 */</span> 
	cndesc.cd_nameptr = hfs_catname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_catname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSCatalogFileID;
	fork.cf_size = SWAP_BE32(mdb-&gt;drCTFlSize);
	fork.cf_blocks = fork.cf_size / vcb-&gt;blockSize;
	fork.cf_clump = SWAP_BE32(mdb-&gt;drCTClpSiz);
	fork.cf_vblocks = 0;
	fork.cf_extents[0].startBlock = SWAP_BE16(mdb-&gt;drCTExtRec[0].startBlock);
	fork.cf_extents[0].blockCount = SWAP_BE16(mdb-&gt;drCTExtRec[0].blockCount);
	fork.cf_extents[1].startBlock = SWAP_BE16(mdb-&gt;drCTExtRec[1].startBlock);
	fork.cf_extents[1].blockCount = SWAP_BE16(mdb-&gt;drCTExtRec[1].blockCount);
	fork.cf_extents[2].startBlock = SWAP_BE16(mdb-&gt;drCTExtRec[2].startBlock);
	fork.cf_extents[2].blockCount = SWAP_BE16(mdb-&gt;drCTExtRec[2].blockCount);
	cnattr.ca_blocks = fork.cf_blocks;

	error = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;fork,
	                        &amp;hfsmp-&gt;hfs_catalog_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error creating catalog Vnode (%d) \n&quot;</span>, error);
		}
		hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
	}
	error = MacToVFSError(BTOpenPath(VTOF(hfsmp-&gt;hfs_catalog_vp),
	                                 (KeyCompareProcPtr)CompareCatalogKeys));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error opening catalog Vnode (%d) \n&quot;</span>, error);
		}
		hfs_unlock(VTOC(hfsmp-&gt;hfs_catalog_vp));
		hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
	}
	hfsmp-&gt;hfs_catalog_cp = VTOC(hfsmp-&gt;hfs_catalog_vp);

	<span class="enscript-comment">/*
	 * Set up dummy Allocation file vnode (used only for locking bitmap)
	 */</span>  
	cndesc.cd_nameptr = hfs_vbmname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_vbmname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSAllocationFileID;
	bzero(&amp;fork, <span class="enscript-keyword">sizeof</span>(fork));
	cnattr.ca_blocks = 0;

	error = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;fork,
	                         &amp;hfsmp-&gt;hfs_allocation_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error creating bitmap Vnode (%d) \n&quot;</span>, error);
		}
		hfs_unlock(VTOC(hfsmp-&gt;hfs_catalog_vp));
		hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">MtVolErr</span>;
	}
	hfsmp-&gt;hfs_allocation_cp = VTOC(hfsmp-&gt;hfs_allocation_vp);

      	<span class="enscript-comment">/* mark the volume dirty (clear clean unmount bit) */</span>
	vcb-&gt;vcbAtrb &amp;=	~kHFSVolumeUnmountedMask;

    <span class="enscript-keyword">if</span> (error == noErr) {
		error = cat_idlookup(hfsmp, kHFSRootFolderID, 0, 0, NULL, NULL, NULL);
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfs (std): error looking up root folder (%d) \n&quot;</span>, error);
		}
	}
	
    <span class="enscript-keyword">if</span> (error == noErr) {
		<span class="enscript-comment">/* If the disk isn't write protected.. */</span>
        <span class="enscript-keyword">if</span> ( !(vcb-&gt;vcbAtrb &amp; kHFSVolumeHardwareLockMask)) {
            MarkVCBDirty (vcb); <span class="enscript-comment">//	mark VCB dirty so it will be written
</span>		}
	}
	
	<span class="enscript-comment">/*
	 * all done with system files so we can unlock now...
	 */</span>
	hfs_unlock(VTOC(hfsmp-&gt;hfs_allocation_vp));
	hfs_unlock(VTOC(hfsmp-&gt;hfs_catalog_vp));
	hfs_unlock(VTOC(hfsmp-&gt;hfs_extents_vp));
	
	<span class="enscript-keyword">if</span> (error == noErr) {
		<span class="enscript-comment">/* If successful, then we can just return once we've unlocked the cnodes */</span>
		<span class="enscript-keyword">return</span> error;
	}

    <span class="enscript-comment">//--	Release any resources allocated so far before exiting with an error:
</span><span class="enscript-reference">MtVolErr</span>:
	hfsUnmount(hfsmp, NULL);

    <span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">//*******************************************************************************
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Sanity check Volume Header Block:
</span><span class="enscript-comment">//		Input argument *vhp is a pointer to a HFSPlusVolumeHeader block that has
</span><span class="enscript-comment">//		not been endian-swapped and represents the on-disk contents of this sector.
</span><span class="enscript-comment">//		This routine will not change the endianness of vhp block.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*******************************************************************************
</span>OSErr <span class="enscript-function-name">hfs_ValidateHFSPlusVolumeHeader</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp)
{
	u_int16_t signature;
	u_int16_t hfs_version;
	u_int32_t blockSize;

	signature = SWAP_BE16(vhp-&gt;signature);
	hfs_version = SWAP_BE16(vhp-&gt;version);

	<span class="enscript-keyword">if</span> (signature == kHFSPlusSigWord) {
		<span class="enscript-keyword">if</span> (hfs_version != kHFSPlusVersion) {
			printf(<span class="enscript-string">&quot;hfs_ValidateHFSPlusVolumeHeader: invalid HFS+ version: %x\n&quot;</span>, hfs_version);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (signature == kHFSXSigWord) {
		<span class="enscript-keyword">if</span> (hfs_version != kHFSXVersion) {
			printf(<span class="enscript-string">&quot;hfs_ValidateHFSPlusVolumeHeader: invalid HFSX version: %x\n&quot;</span>, hfs_version);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Removed printf for invalid HFS+ signature because it gives
		 * false error for UFS root volume
		 */</span>
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_ValidateHFSPlusVolumeHeader: unknown Volume Signature : %x\n&quot;</span>, signature);
		}
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/* Block size must be at least 512 and a power of 2 */</span>
	blockSize = SWAP_BE32(vhp-&gt;blockSize);
	<span class="enscript-keyword">if</span> (blockSize &lt; 512 || !powerof2(blockSize)) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_ValidateHFSPlusVolumeHeader: invalid blocksize (%d) \n&quot;</span>, blockSize);
		}
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (blockSize &lt; hfsmp-&gt;hfs_logical_block_size) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_ValidateHFSPlusVolumeHeader: invalid physical blocksize (%d), hfs_logical_blocksize (%d) \n&quot;</span>,
					blockSize, hfsmp-&gt;hfs_logical_block_size);
		}
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">//*******************************************************************************
</span><span class="enscript-comment">//	Routine:	hfs_MountHFSPlusVolume
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//
</span><span class="enscript-comment">//*******************************************************************************
</span>
OSErr <span class="enscript-function-name">hfs_MountHFSPlusVolume</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp,
	off_t embeddedOffset, u_int64_t disksize, __unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">void</span> *args, kauth_cred_t cred)
{
	<span class="enscript-type">register</span> ExtendedVCB *vcb;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr cnattr;
	<span class="enscript-type">struct</span> cat_fork cfork;
	u_int32_t blockSize;
	daddr64_t spare_sectors;
	<span class="enscript-type">struct</span> BTreeInfoRec btinfo;
	u_int16_t  signature;
	u_int16_t  hfs_version;
	<span class="enscript-type">int</span> newvnode_flags = 0;
	<span class="enscript-type">int</span>  i;
	OSErr retval;
	<span class="enscript-type">char</span> converted_volname[256];
	size_t volname_length = 0;
	size_t conv_volname_length = 0;

	signature = SWAP_BE16(vhp-&gt;signature);
	hfs_version = SWAP_BE16(vhp-&gt;version);

	retval = hfs_ValidateHFSPlusVolumeHeader(hfsmp, vhp);
	<span class="enscript-keyword">if</span> (retval)
		<span class="enscript-keyword">return</span> retval;

	<span class="enscript-keyword">if</span> (signature == kHFSXSigWord) {
		<span class="enscript-comment">/* The in-memory signature is always 'H+'. */</span>
		signature = kHFSPlusSigWord;
		hfsmp-&gt;hfs_flags |= HFS_X;
	}

	blockSize = SWAP_BE32(vhp-&gt;blockSize);
	<span class="enscript-comment">/* don't mount a writable volume if its dirty, it must be cleaned by fsck_hfs */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0 &amp;&amp; hfsmp-&gt;jnl == NULL &amp;&amp;
	    (SWAP_BE32(vhp-&gt;attributes) &amp; kHFSVolumeUnmountedMask) == 0) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: cannot mount dirty non-journaled volumes\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/* Make sure we can live with the physical block size. */</span>
	<span class="enscript-keyword">if</span> ((disksize &amp; (hfsmp-&gt;hfs_logical_block_size - 1)) ||
	    (embeddedOffset &amp; (hfsmp-&gt;hfs_logical_block_size - 1))) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_logical_blocksize (%d) \n&quot;</span>,
					hfsmp-&gt;hfs_logical_block_size);
		}
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	<span class="enscript-comment">/*
	 * If allocation block size is less than the physical block size,
	 * same data could be cached in two places and leads to corruption.
	 *
	 * HFS Plus reserves one allocation block for the Volume Header.
	 * If the physical size is larger, then when we read the volume header,
	 * we will also end up reading in the next allocation block(s).
	 * If those other allocation block(s) is/are modified, and then the volume
	 * header is modified, the write of the volume header's buffer will write
	 * out the old contents of the other allocation blocks.
	 *
	 * We assume that the physical block size is same as logical block size.
	 * The physical block size value is used to round down the offsets for
	 * reading and writing the primary and alternate volume headers.
	 *
	 * The same logic to ensure good hfs_physical_block_size is also in
	 * hfs_mountfs so that hfs_mountfs, hfs_MountHFSPlusVolume and
	 * later are doing the I/Os using same block size.
	 */</span>
	<span class="enscript-keyword">if</span> (blockSize &lt; hfsmp-&gt;hfs_physical_block_size) {
		hfsmp-&gt;hfs_physical_block_size = hfsmp-&gt;hfs_logical_block_size;
		hfsmp-&gt;hfs_log_per_phys = 1;
	}

	<span class="enscript-comment">/*
	 * The VolumeHeader seems OK: transfer info from it into VCB
	 * Note - the VCB starts out clear (all zeros)
	 */</span>
	vcb = HFSTOVCB(hfsmp);

	vcb-&gt;vcbSigWord	= signature;
	vcb-&gt;vcbJinfoBlock = SWAP_BE32(vhp-&gt;journalInfoBlock);
	vcb-&gt;vcbLsMod	= to_bsd_time(SWAP_BE32(vhp-&gt;modifyDate));
	vcb-&gt;vcbAtrb	= SWAP_BE32(vhp-&gt;attributes);
	vcb-&gt;vcbClpSiz	= SWAP_BE32(vhp-&gt;rsrcClumpSize);
	vcb-&gt;vcbNxtCNID	= SWAP_BE32(vhp-&gt;nextCatalogID);
	vcb-&gt;vcbVolBkUp	= to_bsd_time(SWAP_BE32(vhp-&gt;backupDate));
	vcb-&gt;vcbWrCnt	= SWAP_BE32(vhp-&gt;writeCount);
	vcb-&gt;vcbFilCnt	= SWAP_BE32(vhp-&gt;fileCount);
	vcb-&gt;vcbDirCnt	= SWAP_BE32(vhp-&gt;folderCount);
	
	<span class="enscript-comment">/* copy 32 bytes of Finder info */</span>
	bcopy(vhp-&gt;finderInfo, vcb-&gt;vcbFndrInfo, <span class="enscript-keyword">sizeof</span>(vhp-&gt;finderInfo));    

	vcb-&gt;vcbAlBlSt = 0;		<span class="enscript-comment">/* hfs+ allocation blocks start at first block of volume */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0)
		vcb-&gt;vcbWrCnt++;	<span class="enscript-comment">/* compensate for write of Volume Header on last flush */</span>

	<span class="enscript-comment">/* Now fill in the Extended VCB info */</span>
	vcb-&gt;nextAllocation	= SWAP_BE32(vhp-&gt;nextAllocation);
	vcb-&gt;totalBlocks	= SWAP_BE32(vhp-&gt;totalBlocks);
	vcb-&gt;allocLimit		= vcb-&gt;totalBlocks;
	vcb-&gt;freeBlocks		= SWAP_BE32(vhp-&gt;freeBlocks);
	vcb-&gt;blockSize		= blockSize;
	vcb-&gt;encodingsBitmap	= SWAP_BE64(vhp-&gt;encodingsBitmap);
	vcb-&gt;localCreateDate	= SWAP_BE32(vhp-&gt;createDate);
	
	vcb-&gt;hfsPlusIOPosOffset	= embeddedOffset;

	<span class="enscript-comment">/* Default to no free block reserve */</span>
	vcb-&gt;reserveBlocks = 0;

	<span class="enscript-comment">/*
	 * Update the logical block size in the mount struct
	 * (currently set up from the wrapper MDB) using the
	 * new blocksize value:
	 */</span>
	hfsmp-&gt;hfs_logBlockSize = BestBlockSizeFit(vcb-&gt;blockSize, MAXBSIZE, hfsmp-&gt;hfs_logical_block_size);
	vcb-&gt;vcbVBMIOSize = min(vcb-&gt;blockSize, MAXPHYSIO);

	<span class="enscript-comment">/*
	 * Validate and initialize the location of the alternate volume header.
	 *
	 * Note that there may be spare sectors beyond the end of the filesystem that still 
	 * belong to our partition. 
	 */</span>

	spare_sectors = hfsmp-&gt;hfs_logical_block_count -
	                (((daddr64_t)vcb-&gt;totalBlocks * blockSize) /
	                   hfsmp-&gt;hfs_logical_block_size);

	<span class="enscript-comment">/*
	 * Differentiate between &quot;innocuous&quot; spare sectors and the more unusual
	 * degenerate case:
	 * 
	 * *** Innocuous spare sectors exist if:
	 * 
	 * A) the number of bytes assigned to the partition (by multiplying logical 
	 * block size * logical block count) is greater than the filesystem size 
	 * (by multiplying allocation block count and allocation block size)
	 * 
	 * and
	 * 
	 * B) the remainder is less than the size of a full allocation block's worth of bytes.
	 * 
	 * This handles the normal case where there may be a few extra sectors, but the two
	 * are fundamentally in sync.
	 *
	 * *** Degenerate spare sectors exist if:
	 * A) The number of bytes assigned to the partition (by multiplying logical
	 * block size * logical block count) is greater than the filesystem size 
	 * (by multiplying allocation block count and block size).
	 * 
	 * and
	 *
	 * B) the remainder is greater than a full allocation's block worth of bytes.
	 * In this case,  a smaller file system exists in a larger partition.  
	 * This can happen in various ways, including when volume is resized but the 
	 * partition is yet to be resized.  Under this condition, we have to assume that
	 * a partition management software may resize the partition to match 
	 * the file system size in the future.  Therefore we should update 
	 * alternate volume header at two locations on the disk, 
	 *   a. 1024 bytes before end of the partition
	 *   b. 1024 bytes before end of the file system 
	 */</span>

	<span class="enscript-keyword">if</span> (spare_sectors &gt; (daddr64_t)(blockSize / hfsmp-&gt;hfs_logical_block_size)) {
		<span class="enscript-comment">/* 
		 * Handle the degenerate case above. FS &lt; partition size.
		 * AVH located at 1024 bytes from the end of the partition
		 */</span>
		hfsmp-&gt;hfs_partition_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) +
					   HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size, hfsmp-&gt;hfs_logical_block_count);

		<span class="enscript-comment">/* AVH located at 1024 bytes from the end of the filesystem */</span>
		hfsmp-&gt;hfs_fs_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) +
					   HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size,
						(((daddr64_t)vcb-&gt;totalBlocks * blockSize) / hfsmp-&gt;hfs_logical_block_size));
	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Innocuous spare sectors; Partition &amp; FS notion are in sync */</span>
		hfsmp-&gt;hfs_partition_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size) +
					   HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size, hfsmp-&gt;hfs_logical_block_count);

		hfsmp-&gt;hfs_fs_avh_sector = hfsmp-&gt;hfs_partition_avh_sector;
	}
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_MountHFSPlusVolume: partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>, 
				hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
	}

	bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
	cndesc.cd_parentcnid = kHFSRootParentID;
	cndesc.cd_flags |= CD_ISMETA;
	bzero(&amp;cnattr, <span class="enscript-keyword">sizeof</span>(cnattr));
	cnattr.ca_linkcount = 1;
	cnattr.ca_mode = S_IFREG;

	<span class="enscript-comment">/*
	 * Set up Extents B-tree vnode
	 */</span>
	cndesc.cd_nameptr = hfs_extname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_extname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSExtentsFileID;

	cfork.cf_size    = SWAP_BE64 (vhp-&gt;extentsFile.logicalSize);
	cfork.cf_new_size= 0;
	cfork.cf_clump   = SWAP_BE32 (vhp-&gt;extentsFile.clumpSize);
	cfork.cf_blocks  = SWAP_BE32 (vhp-&gt;extentsFile.totalBlocks);
	cfork.cf_vblocks = 0;
	cnattr.ca_blocks = cfork.cf_blocks;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		cfork.cf_extents[i].startBlock =
				SWAP_BE32 (vhp-&gt;extentsFile.extents[i].startBlock);
		cfork.cf_extents[i].blockCount =
				SWAP_BE32 (vhp-&gt;extentsFile.extents[i].blockCount);
	}
	retval = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;cfork,
	                         &amp;hfsmp-&gt;hfs_extents_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (retval)
	{
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_getnewvnode returned (%d) getting extentoverflow BT\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}

	hfsmp-&gt;hfs_extents_cp = VTOC(hfsmp-&gt;hfs_extents_vp);
	hfs_unlock(hfsmp-&gt;hfs_extents_cp);

	retval = MacToVFSError(BTOpenPath(VTOF(hfsmp-&gt;hfs_extents_vp),
	                                  (KeyCompareProcPtr) CompareExtentKeysPlus));
	<span class="enscript-keyword">if</span> (retval)
	{
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: BTOpenPath returned (%d) getting extentoverflow BT\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	<span class="enscript-comment">/*
	 * Set up Catalog B-tree vnode
	 */</span> 
	cndesc.cd_nameptr = hfs_catname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_catname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSCatalogFileID;

	cfork.cf_size    = SWAP_BE64 (vhp-&gt;catalogFile.logicalSize);
	cfork.cf_clump   = SWAP_BE32 (vhp-&gt;catalogFile.clumpSize);
	cfork.cf_blocks  = SWAP_BE32 (vhp-&gt;catalogFile.totalBlocks);
	cfork.cf_vblocks = 0;
	cnattr.ca_blocks = cfork.cf_blocks;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		cfork.cf_extents[i].startBlock =
				SWAP_BE32 (vhp-&gt;catalogFile.extents[i].startBlock);
		cfork.cf_extents[i].blockCount =
				SWAP_BE32 (vhp-&gt;catalogFile.extents[i].blockCount);
	}
	retval = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;cfork,
	                         &amp;hfsmp-&gt;hfs_catalog_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_getnewvnode returned (%d) getting catalog BT\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	hfsmp-&gt;hfs_catalog_cp = VTOC(hfsmp-&gt;hfs_catalog_vp);
	hfs_unlock(hfsmp-&gt;hfs_catalog_cp);

	retval = MacToVFSError(BTOpenPath(VTOF(hfsmp-&gt;hfs_catalog_vp),
	                                  (KeyCompareProcPtr) CompareExtendedCatalogKeys));
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: BTOpenPath returned (%d) getting catalog BT\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_X) &amp;&amp;
	    BTGetInformation(VTOF(hfsmp-&gt;hfs_catalog_vp), 0, &amp;btinfo) == 0) {
		<span class="enscript-keyword">if</span> (btinfo.keyCompareType == kHFSBinaryCompare) {
			hfsmp-&gt;hfs_flags |= HFS_CASE_SENSITIVE;
			<span class="enscript-comment">/* Install a case-sensitive key compare */</span>
			(<span class="enscript-type">void</span>) BTOpenPath(VTOF(hfsmp-&gt;hfs_catalog_vp),
			                  (KeyCompareProcPtr)cat_binarykeycompare);
		}
	}

	<span class="enscript-comment">/*
	 * Set up Allocation file vnode
	 */</span>  
	cndesc.cd_nameptr = hfs_vbmname;
	cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_vbmname);
	cndesc.cd_cnid = cnattr.ca_fileid = kHFSAllocationFileID;

	cfork.cf_size    = SWAP_BE64 (vhp-&gt;allocationFile.logicalSize);
	cfork.cf_clump   = SWAP_BE32 (vhp-&gt;allocationFile.clumpSize);
	cfork.cf_blocks  = SWAP_BE32 (vhp-&gt;allocationFile.totalBlocks);
	cfork.cf_vblocks = 0;
	cnattr.ca_blocks = cfork.cf_blocks;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		cfork.cf_extents[i].startBlock =
				SWAP_BE32 (vhp-&gt;allocationFile.extents[i].startBlock);
		cfork.cf_extents[i].blockCount =
				SWAP_BE32 (vhp-&gt;allocationFile.extents[i].blockCount);
	}
	retval = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;cfork,
	                         &amp;hfsmp-&gt;hfs_allocation_vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_getnewvnode returned (%d) getting bitmap\n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	hfsmp-&gt;hfs_allocation_cp = VTOC(hfsmp-&gt;hfs_allocation_vp);
	hfs_unlock(hfsmp-&gt;hfs_allocation_cp);

	<span class="enscript-comment">/*
	 * Set up Attribute B-tree vnode
	 */</span>
	<span class="enscript-keyword">if</span> (vhp-&gt;attributesFile.totalBlocks != 0) {
		cndesc.cd_nameptr = hfs_attrname;
		cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_attrname);
		cndesc.cd_cnid = cnattr.ca_fileid = kHFSAttributesFileID;
	
		cfork.cf_size    = SWAP_BE64 (vhp-&gt;attributesFile.logicalSize);
		cfork.cf_clump   = SWAP_BE32 (vhp-&gt;attributesFile.clumpSize);
		cfork.cf_blocks  = SWAP_BE32 (vhp-&gt;attributesFile.totalBlocks);
		cfork.cf_vblocks = 0;
		cnattr.ca_blocks = cfork.cf_blocks;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			cfork.cf_extents[i].startBlock =
					SWAP_BE32 (vhp-&gt;attributesFile.extents[i].startBlock);
			cfork.cf_extents[i].blockCount =
					SWAP_BE32 (vhp-&gt;attributesFile.extents[i].blockCount);
		}
		retval = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;cfork,
					 &amp;hfsmp-&gt;hfs_attribute_vp, &amp;newvnode_flags);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_getnewvnode returned (%d) getting EA BT\n&quot;</span>, retval);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		hfsmp-&gt;hfs_attribute_cp = VTOC(hfsmp-&gt;hfs_attribute_vp);
		hfs_unlock(hfsmp-&gt;hfs_attribute_cp);
		retval = MacToVFSError(BTOpenPath(VTOF(hfsmp-&gt;hfs_attribute_vp),
						  (KeyCompareProcPtr) hfs_attrkeycompare));
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: BTOpenPath returned (%d) getting EA BT\n&quot;</span>, retval);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}

		<span class="enscript-comment">/* Initialize vnode for virtual attribute data file that spans the 
		 * entire file system space for performing I/O to attribute btree
		 * We hold iocount on the attrdata vnode for the entire duration 
		 * of mount (similar to btree vnodes)
		 */</span>
		retval = init_attrdata_vnode(hfsmp);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: init_attrdata_vnode returned (%d) for virtual EA file\n&quot;</span>, retval);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Set up Startup file vnode
	 */</span>
	<span class="enscript-keyword">if</span> (vhp-&gt;startupFile.totalBlocks != 0) {
		cndesc.cd_nameptr = hfs_startupname;
		cndesc.cd_namelen = strlen((<span class="enscript-type">char</span> *)hfs_startupname);
		cndesc.cd_cnid = cnattr.ca_fileid = kHFSStartupFileID;
	
		cfork.cf_size    = SWAP_BE64 (vhp-&gt;startupFile.logicalSize);
		cfork.cf_clump   = SWAP_BE32 (vhp-&gt;startupFile.clumpSize);
		cfork.cf_blocks  = SWAP_BE32 (vhp-&gt;startupFile.totalBlocks);
		cfork.cf_vblocks = 0;
		cnattr.ca_blocks = cfork.cf_blocks;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			cfork.cf_extents[i].startBlock =
					SWAP_BE32 (vhp-&gt;startupFile.extents[i].startBlock);
			cfork.cf_extents[i].blockCount =
					SWAP_BE32 (vhp-&gt;startupFile.extents[i].blockCount);
		}
		retval = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, &amp;cfork,
					 &amp;hfsmp-&gt;hfs_startup_vp, &amp;newvnode_flags);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_getnewvnode returned (%d) getting startup file\n&quot;</span>, retval);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
		hfsmp-&gt;hfs_startup_cp = VTOC(hfsmp-&gt;hfs_startup_vp);
		hfs_unlock(hfsmp-&gt;hfs_startup_cp);
	}
	
	<span class="enscript-comment">/* 
	 * Pick up volume name and create date 
	 *
	 * Acquiring the volume name should not manipulate the bitmap, only the catalog
	 * btree and possibly the extents overflow b-tree.
	 */</span>
	retval = cat_idlookup(hfsmp, kHFSRootFolderID, 0, 0, &amp;cndesc, &amp;cnattr, NULL);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
			printf(<span class="enscript-string">&quot;hfs_mounthfsplus: cat_idlookup returned (%d) getting rootfolder \n&quot;</span>, retval);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
	}
	vcb-&gt;hfs_itime = cnattr.ca_itime;
	vcb-&gt;volumeNameEncodingHint = cndesc.cd_encoding;
	bcopy(cndesc.cd_nameptr, vcb-&gt;vcbVN, min(255, cndesc.cd_namelen));
	volname_length = strlen ((<span class="enscript-type">const</span> <span class="enscript-type">char</span>*)vcb-&gt;vcbVN);
	cat_releasedesc(&amp;cndesc);
	
	<span class="enscript-comment">/* Send the volume name down to CoreStorage if necessary */</span>	
	retval = utf8_normalizestr(vcb-&gt;vcbVN, volname_length, (u_int8_t*)converted_volname, &amp;conv_volname_length, 256, UTF_PRECOMPOSED);
	<span class="enscript-keyword">if</span> (retval == 0) {
		(<span class="enscript-type">void</span>) VNOP_IOCTL (hfsmp-&gt;hfs_devvp, _DKIOCCSSETLVNAME, converted_volname, 0, vfs_context_current());
	}	
	
	<span class="enscript-comment">/* reset retval == 0. we don't care about errors in volname conversion */</span>
	retval = 0;

	
	<span class="enscript-comment">/* 
	 * We now always initiate a full bitmap scan even if the volume is read-only because this is 
	 * our only shot to do I/Os of dramaticallly different sizes than what the buffer cache ordinarily
	 * expects. TRIMs will not be delivered to the underlying media if the volume is not 
	 * read-write though.  
	 */</span>
	thread_t allocator_scanner;
	hfsmp-&gt;scan_var = 0;

	<span class="enscript-comment">/* Take the HFS mount mutex and wait on scan_var */</span>
	hfs_lock_mount (hfsmp);

	kernel_thread_start ((thread_continue_t) hfs_scan_blocks, hfsmp, &amp;allocator_scanner);
	<span class="enscript-comment">/* Wait until it registers that it's got the appropriate locks (or that it is finished) */</span>
	<span class="enscript-keyword">while</span> ((hfsmp-&gt;scan_var &amp; (HFS_ALLOCATOR_SCAN_INFLIGHT|HFS_ALLOCATOR_SCAN_COMPLETED)) == 0) {
		msleep (&amp;hfsmp-&gt;scan_var, &amp;hfsmp-&gt;hfs_mutex, PINOD, <span class="enscript-string">&quot;hfs_scan_blocks&quot;</span>, 0);
	}

	hfs_unlock_mount(hfsmp);

	thread_deallocate (allocator_scanner);

	<span class="enscript-comment">/* mark the volume dirty (clear clean unmount bit) */</span>
	vcb-&gt;vcbAtrb &amp;=	~kHFSVolumeUnmountedMask;
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0) {
		hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
	}

	<span class="enscript-comment">/* kHFSHasFolderCount is only supported/updated on HFSX volumes */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_X) != 0) {
		hfsmp-&gt;hfs_flags |= HFS_FOLDERCOUNT;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Check if we need to do late journal initialization.  This only
</span>	<span class="enscript-comment">// happens if a previous version of MacOS X (or 9) touched the disk.
</span>	<span class="enscript-comment">// In that case hfs_late_journal_init() will go re-locate the journal 
</span>	<span class="enscript-comment">// and journal_info_block files and validate that they're still kosher.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (   (vcb-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask)
		&amp;&amp; (SWAP_BE32(vhp-&gt;lastMountedVersion) != kHFSJMountVersion)
		&amp;&amp; (hfsmp-&gt;jnl == NULL)) {

		retval = hfs_late_journal_init(hfsmp, vhp, args);
		<span class="enscript-keyword">if</span> (retval != 0) {
			<span class="enscript-keyword">if</span> (retval == EROFS) {
				<span class="enscript-comment">// EROFS is a special error code that means the volume has an external
</span>				<span class="enscript-comment">// journal which we couldn't find.  in that case we do not want to
</span>				<span class="enscript-comment">// rewrite the volume header - we'll just refuse to mount the volume.
</span>				<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
					printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_late_journal_init returned (%d), maybe an external jnl?\n&quot;</span>, retval);
				}
				retval = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
			}

			hfsmp-&gt;jnl = NULL;
			
			<span class="enscript-comment">// if the journal failed to open, then set the lastMountedVersion
</span>			<span class="enscript-comment">// to be &quot;FSK!&quot; which fsck_hfs will see and force the fsck instead
</span>			<span class="enscript-comment">// of just bailing out because the volume is journaled.
</span>			<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY)) {
				HFSPlusVolumeHeader *jvhp;
				daddr64_t mdb_offset;
				<span class="enscript-type">struct</span> buf *bp = NULL;
				
				hfsmp-&gt;hfs_flags |= HFS_NEED_JNL_RESET;
				    
				mdb_offset = (daddr64_t)((embeddedOffset / blockSize) + HFS_PRI_SECTOR(blockSize));

				bp = NULL;
				retval = (<span class="enscript-type">int</span>)buf_meta_bread(hfsmp-&gt;hfs_devvp, 
						HFS_PHYSBLK_ROUNDDOWN(mdb_offset, hfsmp-&gt;hfs_log_per_phys),
						hfsmp-&gt;hfs_physical_block_size, cred, &amp;bp);
				<span class="enscript-keyword">if</span> (retval == 0) {
					jvhp = (HFSPlusVolumeHeader *)(buf_dataptr(bp) + HFS_PRI_OFFSET(hfsmp-&gt;hfs_physical_block_size));
					    
					<span class="enscript-keyword">if</span> (SWAP_BE16(jvhp-&gt;signature) == kHFSPlusSigWord || SWAP_BE16(jvhp-&gt;signature) == kHFSXSigWord) {
						printf (<span class="enscript-string">&quot;hfs(3): Journal replay fail.  Writing lastMountVersion as FSK!\n&quot;</span>);
						jvhp-&gt;lastMountedVersion = SWAP_BE32(kFSKMountVersion);
					   	buf_bwrite(bp);
					} <span class="enscript-keyword">else</span> {
						buf_brelse(bp);
					}
					bp = NULL;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
					buf_brelse(bp);
					<span class="enscript-comment">// clear this so the error exit path won't try to use it
</span>					bp = NULL;
			    }
			}
			
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_late_journal_init returned (%d)\n&quot;</span>, retval);
			}
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			vfs_setflags(hfsmp-&gt;hfs_mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl || ((vcb-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY))) {
		<span class="enscript-type">struct</span> cat_attr jinfo_attr, jnl_attr;
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		    vcb-&gt;vcbAtrb &amp;= ~kHFSVolumeJournaledMask;
		}

		<span class="enscript-comment">// if we're here we need to fill in the fileid's for the
</span>		<span class="enscript-comment">// journal and journal_info_block.
</span>		hfsmp-&gt;hfs_jnlinfoblkid = GetFileInfo(vcb, kRootDirID, <span class="enscript-string">&quot;.journal_info_block&quot;</span>, &amp;jinfo_attr, NULL);
		hfsmp-&gt;hfs_jnlfileid    = GetFileInfo(vcb, kRootDirID, <span class="enscript-string">&quot;.journal&quot;</span>, &amp;jnl_attr, NULL);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_jnlinfoblkid == 0 || hfsmp-&gt;hfs_jnlfileid == 0) {
			printf(<span class="enscript-string">&quot;hfs: danger! couldn't find the file-id's for the journal or journal_info_block\n&quot;</span>);
			printf(<span class="enscript-string">&quot;hfs: jnlfileid %d, jnlinfoblkid %d\n&quot;</span>, hfsmp-&gt;hfs_jnlfileid, hfsmp-&gt;hfs_jnlinfoblkid);
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		    vcb-&gt;vcbAtrb |= kHFSVolumeJournaledMask;
		}

		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		    vfs_clearflags(hfsmp-&gt;hfs_mp, (u_int64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)MNT_JOURNALED));
		}
	}

	<span class="enscript-keyword">if</span> ( !(vcb-&gt;vcbAtrb &amp; kHFSVolumeHardwareLockMask) )	<span class="enscript-comment">// if the disk is not write protected
</span>	{
		MarkVCBDirty( vcb );	<span class="enscript-comment">// mark VCB dirty so it will be written
</span>	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_METADATA_PIN) {
		hfs_pin_fs_metadata(hfsmp);
	}
	<span class="enscript-comment">/*
	 * Distinguish 3 potential cases involving content protection:
	 * 1. mount point bit set; vcbAtrb does not support it. Fail.
	 * 2. mount point bit set; vcbattrb supports it. we're good.
	 * 3. mount point bit not set; vcbatrb supports it, turn bit on, then good.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_CPROTECT) {
		<span class="enscript-comment">/* Does the mount point support it ? */</span>
		<span class="enscript-keyword">if</span> ((vcb-&gt;vcbAtrb &amp; kHFSContentProtectionMask) == 0) {
			<span class="enscript-comment">/* Case 1 above */</span>
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* not requested in the mount point. Is it in FS? */</span>
		<span class="enscript-keyword">if</span> (vcb-&gt;vcbAtrb &amp; kHFSContentProtectionMask) {
			<span class="enscript-comment">/* Case 3 above */</span>
			vfs_setflags (hfsmp-&gt;hfs_mp, MNT_CPROTECT);
		}
	}

	<span class="enscript-comment">/* At this point, if the mount point flag is set, we can enable it. */</span>
	<span class="enscript-keyword">if</span> (vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_CPROTECT) {
		<span class="enscript-comment">/* Cases 2+3 above */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">/* Get the EAs as needed. */</span>
		<span class="enscript-type">int</span> cperr = 0;
		<span class="enscript-type">struct</span> cp_root_xattr *xattr = NULL;
		MALLOC (xattr, <span class="enscript-type">struct</span> cp_root_xattr*, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_root_xattr), M_TEMP, M_WAITOK);

		<span class="enscript-comment">/* go get the EA to get the version information */</span>
		cperr = cp_getrootxattr (hfsmp, xattr);
		<span class="enscript-comment">/* 
		 * If there was no EA there, then write one out. 
		 * Assuming EA is not present on the root means 
		 * this is an erase install or a very old FS
		 */</span>

		<span class="enscript-keyword">if</span> (cperr == 0) {
			<span class="enscript-comment">/* Have to run a valid CP version. */</span>
			<span class="enscript-keyword">if</span> (!cp_is_supported_version(xattr-&gt;major_version)) {
				cperr = EINVAL;
			}
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cperr == ENOATTR) {
			printf(<span class="enscript-string">&quot;No root EA set, creating new EA with new version: %d\n&quot;</span>, CP_CURRENT_VERS);
			bzero(xattr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_root_xattr));
			xattr-&gt;major_version = CP_CURRENT_VERS;
			xattr-&gt;minor_version = CP_MINOR_VERS;
			cperr = cp_setrootxattr (hfsmp, xattr);
		}

		<span class="enscript-keyword">if</span> (cperr) {
			FREE(xattr, M_TEMP);
			retval = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}

		<span class="enscript-comment">/* If we got here, then the CP version is valid. Set it in the mount point */</span>
		hfsmp-&gt;hfs_running_cp_major_vers = xattr-&gt;major_version;
		printf(<span class="enscript-string">&quot;Running with CP root xattr: %d.%d\n&quot;</span>, xattr-&gt;major_version, xattr-&gt;minor_version);
		hfsmp-&gt;cproot_flags = xattr-&gt;flags;
		hfsmp-&gt;cp_crypto_generation = ISSET(xattr-&gt;flags, CP_ROOT_CRYPTOG1) ? 1 : 0;

		FREE(xattr, M_TEMP);

		<span class="enscript-comment">/*
		 * Acquire the boot-arg for the AKS default key; if invalid, obtain from the device tree.
		 * Ensure that the boot-arg's value is valid for FILES (not directories),
		 * since only files are actually protected for now.
		 */</span>

		PE_parse_boot_argn(<span class="enscript-string">&quot;aks_default_class&quot;</span>, &amp;hfsmp-&gt;default_cp_class, <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;default_cp_class));

		<span class="enscript-keyword">if</span> (cp_is_valid_class(0, hfsmp-&gt;default_cp_class) == 0) {
			PE_get_default(<span class="enscript-string">&quot;kern.default_cp_class&quot;</span>, &amp;hfsmp-&gt;default_cp_class, <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;default_cp_class));
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_TMPDBG</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
		PE_parse_boot_argn(<span class="enscript-string">&quot;aks_verbose&quot;</span>, &amp;hfsmp-&gt;hfs_cp_verbose, <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;hfs_cp_verbose));
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (cp_is_valid_class(0, hfsmp-&gt;default_cp_class) == 0) {
			hfsmp-&gt;default_cp_class = PROTECTION_CLASS_C;
		}

#<span class="enscript-reference">else</span>
		<span class="enscript-comment">/* If CONFIG_PROTECT not built, ignore CP */</span>
		vfs_clearflags(hfsmp-&gt;hfs_mp, MNT_CPROTECT);	
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/*
	 * Establish a metadata allocation zone.
	 */</span>
	hfs_metadatazone_init(hfsmp, false);

	<span class="enscript-comment">/*
	 * Make any metadata zone adjustments.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) {
		<span class="enscript-comment">/* Keep the roving allocator out of the metadata zone. */</span>
		<span class="enscript-keyword">if</span> (vcb-&gt;nextAllocation &gt;= hfsmp-&gt;hfs_metazone_start &amp;&amp;
		    vcb-&gt;nextAllocation &lt;= hfsmp-&gt;hfs_metazone_end) {	    
			HFS_UPDATE_NEXT_ALLOCATION(hfsmp, hfsmp-&gt;hfs_metazone_end + 1);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (vcb-&gt;nextAllocation &lt;= 1) {
			vcb-&gt;nextAllocation = hfsmp-&gt;hfs_min_alloc_start;
		}
	}
	vcb-&gt;sparseAllocation = hfsmp-&gt;hfs_min_alloc_start;

	<span class="enscript-comment">/* Setup private/hidden directories for hardlinks. */</span>
	hfs_privatedir_init(hfsmp, FILE_HARDLINKS);
	hfs_privatedir_init(hfsmp, DIR_HARDLINKS);

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0) 
		hfs_remove_orphans(hfsmp);

	<span class="enscript-comment">/* See if we need to erase unused Catalog nodes due to &lt;rdar://problem/6947811&gt;. */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) == 0)
	{
		retval = hfs_erase_unused_nodes(hfsmp);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
				printf(<span class="enscript-string">&quot;hfs_mounthfsplus: hfs_erase_unused_nodes returned (%d) for %s \n&quot;</span>, retval, hfsmp-&gt;vcbVN);
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ErrorExit</span>;
		}
	}
		
	<span class="enscript-comment">/*
	 * Allow hot file clustering if conditions allow.
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE)  &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) &amp;&amp;
	    ((hfsmp-&gt;hfs_flags &amp; HFS_SSD) == 0 || (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN))) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// Wait until the bitmap scan completes before we initializes the
</span>		<span class="enscript-comment">// hotfile area so that we do not run into any issues with the
</span>		<span class="enscript-comment">// bitmap being read while hotfiles is initializing itself.  On
</span>		<span class="enscript-comment">// some older/slower machines, without this interlock, the bitmap
</span>		<span class="enscript-comment">// would sometimes get corrupted at boot time.
</span>		<span class="enscript-comment">//
</span>		hfs_lock_mount(hfsmp);
		<span class="enscript-keyword">while</span>(!(hfsmp-&gt;scan_var &amp; HFS_ALLOCATOR_SCAN_COMPLETED)) {
			(<span class="enscript-type">void</span>) msleep (&amp;hfsmp-&gt;scan_var, &amp;hfsmp-&gt;hfs_mutex, PINOD, <span class="enscript-string">&quot;hfs_hotfile_bitmap_interlock&quot;</span>, 0);
		}
		hfs_unlock_mount(hfsmp);
		
		<span class="enscript-comment">/*
		 * Note: at this point we are not allowed to fail the
		 *       mount operation because the HotFile init code
		 *       in hfs_recording_init() will lookup vnodes with
		 *       VNOP_LOOKUP() which hangs vnodes off the mount
		 *       (and if we were to fail, VFS is not prepared to
		 *       clean that up at this point.  Since HotFiles are
		 *       optional, this is not a big deal.
		 */</span>
		(<span class="enscript-type">void</span>) hfs_recording_init(hfsmp);
	}

	<span class="enscript-comment">/* Force ACLs on HFS+ file systems. */</span>
	vfs_setextendedsecurity(HFSTOVFS(hfsmp));

	<span class="enscript-comment">/* Enable extent-based extended attributes by default */</span>
	hfsmp-&gt;hfs_flags |= HFS_XATTR_EXTENTS;

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">ErrorExit</span>:
	<span class="enscript-comment">/*
	 * A fatal error occurred and the volume cannot be mounted, so 
	 * release any resources that we acquired...
	 */</span>
	hfsUnmount(hfsmp, NULL);
		
	<span class="enscript-keyword">if</span> (HFS_MOUNT_DEBUG) {
		printf(<span class="enscript-string">&quot;hfs_mounthfsplus: encountered error (%d)\n&quot;</span>, retval);
	}
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">_pin_metafile</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, vnode_t vp)
{
	<span class="enscript-type">int</span> err;

	err = hfs_lock(VTOC(vp), HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (err == 0) {
		err = hfs_pin_vnode(hfsmp, vp, HFS_PIN_IT, NULL, vfs_context_kernel());
		hfs_unlock(VTOC(vp));
	}

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_pin_fs_metadata</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	ExtendedVCB *vcb;
	<span class="enscript-type">int</span> err;
	
	vcb = HFSTOVCB(hfsmp);

	err = _pin_metafile(hfsmp, hfsmp-&gt;hfs_extents_vp);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;hfs: failed to pin extents overflow file %d\n&quot;</span>, err);
	}				
	err = _pin_metafile(hfsmp, hfsmp-&gt;hfs_catalog_vp);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;hfs: failed to pin catalog file %d\n&quot;</span>, err);
	}				
	err = _pin_metafile(hfsmp, hfsmp-&gt;hfs_allocation_vp);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;hfs: failed to pin bitmap file %d\n&quot;</span>, err);
	}				
	err = _pin_metafile(hfsmp, hfsmp-&gt;hfs_attribute_vp);
	<span class="enscript-keyword">if</span> (err != 0) {
		printf(<span class="enscript-string">&quot;hfs: failed to pin extended attr file %d\n&quot;</span>, err);
	}				
	
	hfs_pin_block_range(hfsmp, HFS_PIN_IT, 0, 1, vfs_context_kernel());
	hfs_pin_block_range(hfsmp, HFS_PIN_IT, vcb-&gt;totalBlocks-1, 1, vfs_context_kernel());
			
	<span class="enscript-keyword">if</span> (vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_JOURNALED) {
		<span class="enscript-comment">// and hey, if we've got a journal, let's pin that too!
</span>		hfs_pin_block_range(hfsmp, HFS_PIN_IT, hfsmp-&gt;jnl_start, howmany(hfsmp-&gt;jnl_size, vcb-&gt;blockSize), vfs_context_kernel());
	}
}

<span class="enscript-comment">/*
 * ReleaseMetaFileVNode
 *
 * vp	L - -
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ReleaseMetaFileVNode</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-type">struct</span> filefork *fp;

	<span class="enscript-keyword">if</span> (vp &amp;&amp; (fp = VTOF(vp))) {
		<span class="enscript-keyword">if</span> (fp-&gt;fcbBTCBPtr != NULL) {
			(<span class="enscript-type">void</span>)hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			(<span class="enscript-type">void</span>) BTClosePath(fp);
			hfs_unlock(VTOC(vp));
		}

		<span class="enscript-comment">/* release the node even if BTClosePath fails */</span>
		vnode_recycle(vp);
		vnode_put(vp);
	}
}


<span class="enscript-comment">/*************************************************************
*
* Unmounts a hfs volume.
*	At this point vflush() has been called (to dump all non-metadata files)
*
*************************************************************/</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsUnmount</span>( <span class="enscript-type">register</span> <span class="enscript-type">struct</span> hfsmount *hfsmp, __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-comment">/* Get rid of our attribute data vnode (if any).  This is done 
	 * after the vflush() during mount, so we don't need to worry 
	 * about any locks.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attrdata_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_attrdata_vp);
		hfsmp-&gt;hfs_attrdata_vp = NULLVP;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_startup_vp);
		hfsmp-&gt;hfs_startup_cp = NULL;
		hfsmp-&gt;hfs_startup_vp = NULL;
	}
	
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_attribute_vp);
		hfsmp-&gt;hfs_attribute_cp = NULL;
		hfsmp-&gt;hfs_attribute_vp = NULL;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_catalog_vp);
		hfsmp-&gt;hfs_catalog_cp = NULL;
		hfsmp-&gt;hfs_catalog_vp = NULL;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_extents_vp);
		hfsmp-&gt;hfs_extents_cp = NULL;
		hfsmp-&gt;hfs_extents_vp = NULL;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_vp) {
		ReleaseMetaFileVNode(hfsmp-&gt;hfs_allocation_vp);
		hfsmp-&gt;hfs_allocation_cp = NULL;
		hfsmp-&gt;hfs_allocation_vp = NULL;
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Test if fork has overflow extents.
 *
 * Returns: 
 * 	non-zero - overflow extents exist
 * 	zero     - overflow extents do not exist 
 */</span>
__private_extern__
bool <span class="enscript-function-name">overflow_extents</span>(<span class="enscript-type">struct</span> filefork *fp)
{
	u_int32_t blocks;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If the vnode pointer is NULL then we're being called
</span>	<span class="enscript-comment">// from hfs_remove_orphans() with a faked-up filefork
</span>	<span class="enscript-comment">// and therefore it has to be an HFS+ volume.  Otherwise
</span>	<span class="enscript-comment">// we check through the volume header to see what type
</span>	<span class="enscript-comment">// of volume we're on.
</span>	<span class="enscript-comment">//
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (FTOV(fp) &amp;&amp; VTOVCB(FTOV(fp))-&gt;vcbSigWord == kHFSSigWord) {
		<span class="enscript-keyword">if</span> (fp-&gt;ff_extents[2].blockCount == 0)
			<span class="enscript-keyword">return</span> false;

		blocks = fp-&gt;ff_extents[0].blockCount +
			fp-&gt;ff_extents[1].blockCount +
			fp-&gt;ff_extents[2].blockCount;	

		<span class="enscript-keyword">return</span> fp-&gt;ff_blocks &gt; blocks;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (fp-&gt;ff_extents[7].blockCount == 0)
		<span class="enscript-keyword">return</span> false;

	blocks = fp-&gt;ff_extents[0].blockCount +
		fp-&gt;ff_extents[1].blockCount +
		fp-&gt;ff_extents[2].blockCount +
		fp-&gt;ff_extents[3].blockCount +
		fp-&gt;ff_extents[4].blockCount +
		fp-&gt;ff_extents[5].blockCount +
		fp-&gt;ff_extents[6].blockCount +
		fp-&gt;ff_extents[7].blockCount;	

	<span class="enscript-keyword">return</span> fp-&gt;ff_blocks &gt; blocks;
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((pure))
boolean_t <span class="enscript-function-name">hfs_is_frozen</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-keyword">return</span> (hfsmp-&gt;hfs_freeze_state == HFS_FROZEN
			|| (hfsmp-&gt;hfs_freeze_state == HFS_FREEZING
				&amp;&amp; current_thread() != hfsmp-&gt;hfs_freezing_thread));
}

<span class="enscript-comment">/*
 * Lock the HFS global journal lock 
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_lock_global</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">enum</span> hfs_locktype locktype) 
{
	thread_t thread = current_thread();

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_global_lockowner == thread) {
		panic (<span class="enscript-string">&quot;hfs_lock_global: locking against myself!&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * This check isn't really necessary but this stops us taking
	 * the mount lock in most cases.  The essential check is below.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_is_frozen(hfsmp)) {
		<span class="enscript-comment">/*
		 * Unfortunately, there is no easy way of getting a notification
		 * for when a process is exiting and it's possible for the exiting 
		 * process to get blocked somewhere else.  To catch this, we
		 * periodically monitor the frozen process here and thaw if
		 * we spot that it's exiting.
		 */</span>
<span class="enscript-reference">frozen</span>:
		hfs_lock_mount(hfsmp);

		<span class="enscript-type">struct</span> timespec ts = { 0, 500 * NSEC_PER_MSEC };

		<span class="enscript-keyword">while</span> (hfs_is_frozen(hfsmp)) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_freeze_state == HFS_FROZEN
				&amp;&amp; proc_exiting(hfsmp-&gt;hfs_freezing_proc)) {
				hfs_thaw_locked(hfsmp);
				<span class="enscript-keyword">break</span>;
			}

			msleep(&amp;hfsmp-&gt;hfs_freeze_state, &amp;hfsmp-&gt;hfs_mutex,
			       PWAIT, <span class="enscript-string">&quot;hfs_lock_global (frozen)&quot;</span>, &amp;ts);
		}
		hfs_unlock_mount(hfsmp);
	}

	<span class="enscript-comment">/* HFS_SHARED_LOCK */</span>
	<span class="enscript-keyword">if</span> (locktype == HFS_SHARED_LOCK) {
		lck_rw_lock_shared (&amp;hfsmp-&gt;hfs_global_lock);
		hfsmp-&gt;hfs_global_lockowner = HFS_SHARED_OWNER;
	}
	<span class="enscript-comment">/* HFS_EXCLUSIVE_LOCK */</span>
	<span class="enscript-keyword">else</span> {
		lck_rw_lock_exclusive (&amp;hfsmp-&gt;hfs_global_lock);
		hfsmp-&gt;hfs_global_lockowner = thread;
	}

	<span class="enscript-comment">/* 
	 * We have to check if we're frozen again because of the time
	 * between when we checked and when we took the global lock.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_is_frozen(hfsmp)) {
		hfs_unlock_global(hfsmp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">frozen</span>;
	}

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * Unlock the HFS global journal lock
 */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">hfs_unlock_global</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) 
{	
	thread_t thread = current_thread();

	<span class="enscript-comment">/* HFS_LOCK_EXCLUSIVE */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_global_lockowner == thread) {
		hfsmp-&gt;hfs_global_lockowner = NULL;
		lck_rw_unlock_exclusive (&amp;hfsmp-&gt;hfs_global_lock);
	}
	<span class="enscript-comment">/* HFS_LOCK_SHARED */</span>
	<span class="enscript-keyword">else</span> {
		lck_rw_unlock_shared (&amp;hfsmp-&gt;hfs_global_lock);
	}
}

<span class="enscript-comment">/*
 * Lock the HFS mount lock
 * 
 * Note: this is a mutex, not a rw lock! 
 */</span>
inline 
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_lock_mount</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	lck_mtx_lock (&amp;(hfsmp-&gt;hfs_mutex)); 
}

<span class="enscript-comment">/*
 * Unlock the HFS mount lock
 *
 * Note: this is a mutex, not a rw lock! 
 */</span>
inline
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlock_mount</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	lck_mtx_unlock (&amp;(hfsmp-&gt;hfs_mutex));
}

<span class="enscript-comment">/*
 * Lock HFS system file(s).
 *
 * This function accepts a @flags parameter which indicates which
 * system file locks are required.  The value it returns should be
 * used in a subsequent call to hfs_systemfile_unlock.  The caller
 * should treat this value as opaque; it may or may not have a
 * relation to the @flags field that is passed in.  The *only*
 * guarantee that we make is that a value of zero means that no locks
 * were taken and that there is no need to call hfs_systemfile_unlock
 * (although it is harmless to do so).  Recursion is supported but
 * care must still be taken to ensure correct lock ordering.  Note
 * that requests for certain locks may cause other locks to also be
 * taken, including locks that are not possible to ask for via the
 * @flags parameter.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_systemfile_lock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> flags, <span class="enscript-type">enum</span> hfs_locktype locktype)
{
	<span class="enscript-comment">/*
	 * Locking order is Catalog file, Attributes file, Startup file, Bitmap file, Extents file
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; SFL_CATALOG) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_cp
			&amp;&amp; hfsmp-&gt;hfs_catalog_cp-&gt;c_lockowner != current_thread()) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_cp &amp;&amp; hfsmp-&gt;hfs_attribute_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Attributes before Catalog)&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_cp &amp;&amp; hfsmp-&gt;hfs_startup_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Startup before Catalog)&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt; hfs_extents_cp &amp;&amp; hfsmp-&gt;hfs_extents_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Extents before Catalog)&quot;</span>);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>

			(<span class="enscript-type">void</span>) hfs_lock(hfsmp-&gt;hfs_catalog_cp, locktype, HFS_LOCK_DEFAULT);
			<span class="enscript-comment">/*
			 * When the catalog file has overflow extents then
			 * also acquire the extents b-tree lock if its not
			 * already requested.
			 */</span>
			<span class="enscript-keyword">if</span> (((flags &amp; SFL_EXTENTS) == 0) &amp;&amp;
			    (hfsmp-&gt;hfs_catalog_vp != NULL) &amp;&amp; 
			    (overflow_extents(VTOF(hfsmp-&gt;hfs_catalog_vp)))) {
				flags |= SFL_EXTENTS;
			}
		} <span class="enscript-keyword">else</span> {
			flags &amp;= ~SFL_CATALOG;
		}
	}

	<span class="enscript-keyword">if</span> (flags &amp; SFL_ATTRIBUTE) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_cp
			&amp;&amp; hfsmp-&gt;hfs_attribute_cp-&gt;c_lockowner != current_thread()) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_cp &amp;&amp; hfsmp-&gt;hfs_startup_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Startup before Attributes)&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_cp &amp;&amp; hfsmp-&gt;hfs_extents_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Extents before Attributes)&quot;</span>);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>
			
			(<span class="enscript-type">void</span>) hfs_lock(hfsmp-&gt;hfs_attribute_cp, locktype, HFS_LOCK_DEFAULT);
			<span class="enscript-comment">/*
			 * When the attribute file has overflow extents then
			 * also acquire the extents b-tree lock if its not
			 * already requested.
			 */</span>
			<span class="enscript-keyword">if</span> (((flags &amp; SFL_EXTENTS) == 0) &amp;&amp;
			    (hfsmp-&gt;hfs_attribute_vp != NULL) &amp;&amp;
			    (overflow_extents(VTOF(hfsmp-&gt;hfs_attribute_vp)))) {
				flags |= SFL_EXTENTS;
			}
		} <span class="enscript-keyword">else</span> {
			flags &amp;= ~SFL_ATTRIBUTE;
		}
	}

	<span class="enscript-keyword">if</span> (flags &amp; SFL_STARTUP) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_startup_cp
			&amp;&amp; hfsmp-&gt;hfs_startup_cp-&gt;c_lockowner != current_thread()) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt; hfs_extents_cp &amp;&amp; hfsmp-&gt;hfs_extents_cp-&gt;c_lockowner == current_thread()) {
				panic(<span class="enscript-string">&quot;hfs_systemfile_lock: bad lock order (Extents before Startup)&quot;</span>);
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>

			(<span class="enscript-type">void</span>) hfs_lock(hfsmp-&gt;hfs_startup_cp, locktype, HFS_LOCK_DEFAULT);
			<span class="enscript-comment">/*
			 * When the startup file has overflow extents then
			 * also acquire the extents b-tree lock if its not
			 * already requested.
			 */</span>
			<span class="enscript-keyword">if</span> (((flags &amp; SFL_EXTENTS) == 0) &amp;&amp;
			    (hfsmp-&gt;hfs_startup_vp != NULL) &amp;&amp;
			    (overflow_extents(VTOF(hfsmp-&gt;hfs_startup_vp)))) {
				flags |= SFL_EXTENTS;
			}
		} <span class="enscript-keyword">else</span> {
			flags &amp;= ~SFL_STARTUP;
		}
	}

	<span class="enscript-comment">/* 
	 * To prevent locks being taken in the wrong order, the extent lock
	 * gets a bitmap lock as well.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; (SFL_BITMAP | SFL_EXTENTS)) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_allocation_cp) {
			(<span class="enscript-type">void</span>) hfs_lock(hfsmp-&gt;hfs_allocation_cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			<span class="enscript-comment">/* 
			 * The bitmap lock is also grabbed when only extent lock 
			 * was requested. Set the bitmap lock bit in the lock
			 * flags which callers will use during unlock.
			 */</span>
			flags |= SFL_BITMAP;
		} <span class="enscript-keyword">else</span> {
			flags &amp;= ~SFL_BITMAP;
		}
	}

	<span class="enscript-keyword">if</span> (flags &amp; SFL_EXTENTS) {
		<span class="enscript-comment">/*
		 * Since the extents btree lock is recursive we always
		 * need exclusive access.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_cp) {
			(<span class="enscript-type">void</span>) hfs_lock(hfsmp-&gt;hfs_extents_cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_mp-&gt;mnt_kern_flag &amp; MNTK_SWAP_MOUNT) {
				<span class="enscript-comment">/*
				 * because we may need this lock on the pageout path (if a swapfile allocation
				 * spills into the extents overflow tree), we will grant the holder of this
				 * lock the privilege of dipping into the reserve free pool in order to prevent
				 * a deadlock from occurring if we need those pageouts to complete before we
				 * will make any new pages available on the free list... the deadlock can occur
				 * if this thread needs to allocate memory while this lock is held
				 */</span>
				<span class="enscript-keyword">if</span> (set_vm_privilege(TRUE) == FALSE) {
					<span class="enscript-comment">/*
					 * indicate that we need to drop vm_privilege 
					 * when we unlock
					 */</span>
					flags |= SFL_VM_PRIV;
				}
			}
		} <span class="enscript-keyword">else</span> {
			flags &amp;= ~SFL_EXTENTS;
		}
	}

	<span class="enscript-keyword">return</span> (flags);
}

<span class="enscript-comment">/*
 * unlock HFS system file(s).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_systemfile_unlock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-keyword">if</span> (!flags)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-type">struct</span> timeval tv;
	u_int32_t lastfsync;
	<span class="enscript-type">int</span> numOfLockedBuffs;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		microuptime(&amp;tv);
		lastfsync = tv.tv_sec;
	}
	<span class="enscript-keyword">if</span> (flags &amp; SFL_STARTUP &amp;&amp; hfsmp-&gt;hfs_startup_cp) {
		hfs_unlock(hfsmp-&gt;hfs_startup_cp);
	}
	<span class="enscript-keyword">if</span> (flags &amp; SFL_ATTRIBUTE &amp;&amp; hfsmp-&gt;hfs_attribute_cp) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
			BTGetLastSync((FCB*)VTOF(hfsmp-&gt;hfs_attribute_vp), &amp;lastfsync);
			numOfLockedBuffs = count_lock_queue();
			<span class="enscript-keyword">if</span> ((numOfLockedBuffs &gt; kMaxLockedMetaBuffers) ||
			    ((numOfLockedBuffs &gt; 1) &amp;&amp; ((tv.tv_sec - lastfsync) &gt;
			      kMaxSecsForFsync))) {
				hfs_btsync(hfsmp-&gt;hfs_attribute_vp, HFS_SYNCTRANS);
			}
		}
		hfs_unlock(hfsmp-&gt;hfs_attribute_cp);
	}
	<span class="enscript-keyword">if</span> (flags &amp; SFL_CATALOG &amp;&amp; hfsmp-&gt;hfs_catalog_cp) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
			BTGetLastSync((FCB*)VTOF(hfsmp-&gt;hfs_catalog_vp), &amp;lastfsync);
			numOfLockedBuffs = count_lock_queue();
			<span class="enscript-keyword">if</span> ((numOfLockedBuffs &gt; kMaxLockedMetaBuffers) ||
			    ((numOfLockedBuffs &gt; 1) &amp;&amp; ((tv.tv_sec - lastfsync) &gt;
			      kMaxSecsForFsync))) {
				hfs_btsync(hfsmp-&gt;hfs_catalog_vp, HFS_SYNCTRANS);
			}
		}
		hfs_unlock(hfsmp-&gt;hfs_catalog_cp);
	}
	<span class="enscript-keyword">if</span> (flags &amp; SFL_BITMAP &amp;&amp; hfsmp-&gt;hfs_allocation_cp) {
		hfs_unlock(hfsmp-&gt;hfs_allocation_cp);
	}
	<span class="enscript-keyword">if</span> (flags &amp; SFL_EXTENTS &amp;&amp; hfsmp-&gt;hfs_extents_cp) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
			BTGetLastSync((FCB*)VTOF(hfsmp-&gt;hfs_extents_vp), &amp;lastfsync);
			numOfLockedBuffs = count_lock_queue();
			<span class="enscript-keyword">if</span> ((numOfLockedBuffs &gt; kMaxLockedMetaBuffers) ||
			    ((numOfLockedBuffs &gt; 1) &amp;&amp; ((tv.tv_sec - lastfsync) &gt;
			      kMaxSecsForFsync))) {
				hfs_btsync(hfsmp-&gt;hfs_extents_vp, HFS_SYNCTRANS);
			}
		}
		hfs_unlock(hfsmp-&gt;hfs_extents_cp);

		<span class="enscript-keyword">if</span> (flags &amp; SFL_VM_PRIV) {
			<span class="enscript-comment">/*
			 * revoke the vm_privilege we granted this thread
			 * now that we have unlocked the overflow extents
			 */</span>
			set_vm_privilege(FALSE);
		}
	}
}


<span class="enscript-comment">/*
 * RequireFileLock
 *
 * Check to see if a vnode is locked in the current context
 * This is to be used for debugging purposes only!!
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_DIAGNOSTIC</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">RequireFileLock</span>(FileReference vp, <span class="enscript-type">int</span> shareable)
{
	<span class="enscript-type">int</span> locked;

	<span class="enscript-comment">/* The extents btree and allocation bitmap are always exclusive. */</span>
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_fileid == kHFSExtentsFileID ||
	    VTOC(vp)-&gt;c_fileid == kHFSAllocationFileID) {
		shareable = 0;
	}
	
	locked = VTOC(vp)-&gt;c_lockowner == current_thread();
	
	<span class="enscript-keyword">if</span> (!locked &amp;&amp; !shareable) {
		<span class="enscript-keyword">switch</span> (VTOC(vp)-&gt;c_fileid) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSExtentsFileID</span>:
			panic(<span class="enscript-string">&quot;hfs: extents btree not locked! v: 0x%08X\n #\n&quot;</span>, (u_int)vp);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSCatalogFileID</span>:
			panic(<span class="enscript-string">&quot;hfs: catalog btree not locked! v: 0x%08X\n #\n&quot;</span>, (u_int)vp);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSAllocationFileID</span>:
			<span class="enscript-comment">/* The allocation file can hide behind the jornal lock. */</span>
			<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;jnl == NULL)
				panic(<span class="enscript-string">&quot;hfs: allocation file not locked! v: 0x%08X\n #\n&quot;</span>, (u_int)vp);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSStartupFileID</span>:
			panic(<span class="enscript-string">&quot;hfs: startup file not locked! v: 0x%08X\n #\n&quot;</span>, (u_int)vp);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSAttributesFileID</span>:
			panic(<span class="enscript-string">&quot;hfs: attributes btree not locked! v: 0x%08X\n #\n&quot;</span>, (u_int)vp);
			<span class="enscript-keyword">break</span>;
		}
	}
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * There are three ways to qualify for ownership rights on an object:
 *
 * 1. (a) Your UID matches the cnode's UID.
 *    (b) The object in question is owned by &quot;unknown&quot;
 * 2. (a) Permissions on the filesystem are being ignored and
 *        your UID matches the replacement UID.
 *    (b) Permissions on the filesystem are being ignored and
 *        the replacement UID is &quot;unknown&quot;.
 * 3. You are root.
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_owner_rights</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uid_t cnode_uid, kauth_cred_t cred,
		__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> invokesuperuserstatus)
{
	<span class="enscript-keyword">if</span> ((kauth_cred_getuid(cred) == cnode_uid) ||                                    <span class="enscript-comment">/* [1a] */</span>
	    (cnode_uid == UNKNOWNUID) ||  									  <span class="enscript-comment">/* [1b] */</span>
	    ((((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(HFSTOVFS(hfsmp))) &amp; MNT_UNKNOWNPERMISSIONS) &amp;&amp;          <span class="enscript-comment">/* [2] */</span>
	      ((kauth_cred_getuid(cred) == hfsmp-&gt;hfs_uid) ||                            <span class="enscript-comment">/* [2a] */</span>
	        (hfsmp-&gt;hfs_uid == UNKNOWNUID))) ||                           <span class="enscript-comment">/* [2b] */</span>
	    (invokesuperuserstatus &amp;&amp; (suser(cred, 0) == 0))) {    <span class="enscript-comment">/* [3] */</span>
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {	
		<span class="enscript-keyword">return</span> (EPERM);
	}
}


u_int32_t <span class="enscript-function-name">BestBlockSizeFit</span>(u_int32_t allocationBlockSize,
                               u_int32_t blockSizeLimit,
                               u_int32_t baseMultiple) {
    <span class="enscript-comment">/*
       Compute the optimal (largest) block size (no larger than allocationBlockSize) that is less than the
       specified limit but still an even multiple of the baseMultiple.
     */</span>
    <span class="enscript-type">int</span> baseBlockCount, blockCount;
    u_int32_t trialBlockSize;

    <span class="enscript-keyword">if</span> (allocationBlockSize % baseMultiple != 0) {
        <span class="enscript-comment">/*
           Whoops: the allocation blocks aren't even multiples of the specified base:
           no amount of dividing them into even parts will be a multiple, either then!
        */</span>
        <span class="enscript-keyword">return</span> 512;		<span class="enscript-comment">/* Hope for the best */</span>
    };

    <span class="enscript-comment">/* Try the obvious winner first, to prevent 12K allocation blocks, for instance,
       from being handled as two 6K logical blocks instead of 3 4K logical blocks.
       Even though the former (the result of the loop below) is the larger allocation
       block size, the latter is more efficient: */</span>
    <span class="enscript-keyword">if</span> (allocationBlockSize % PAGE_SIZE == 0) <span class="enscript-keyword">return</span> PAGE_SIZE;

    <span class="enscript-comment">/* No clear winner exists: pick the largest even fraction &lt;= MAXBSIZE: */</span>
    baseBlockCount = allocationBlockSize / baseMultiple;				<span class="enscript-comment">/* Now guaranteed to be an even multiple */</span>

    <span class="enscript-keyword">for</span> (blockCount = baseBlockCount; blockCount &gt; 0; --blockCount) {
        trialBlockSize = blockCount * baseMultiple;
        <span class="enscript-keyword">if</span> (allocationBlockSize % trialBlockSize == 0) {				<span class="enscript-comment">/* An even multiple? */</span>
            <span class="enscript-keyword">if</span> ((trialBlockSize &lt;= blockSizeLimit) &amp;&amp;
                (trialBlockSize % baseMultiple == 0)) {
                <span class="enscript-keyword">return</span> trialBlockSize;
            };
        };
    };

    <span class="enscript-comment">/* Note: we should never get here, since blockCount = 1 should always work,
       but this is nice and safe and makes the compiler happy, too ... */</span>
    <span class="enscript-keyword">return</span> 512;
}


u_int32_t
<span class="enscript-function-name">GetFileInfo</span>(ExtendedVCB *vcb, __unused u_int32_t dirid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
			<span class="enscript-type">struct</span> cat_attr *fattr, <span class="enscript-type">struct</span> cat_fork *forkinfo)
{
	<span class="enscript-type">struct</span> hfsmount * hfsmp;
	<span class="enscript-type">struct</span> cat_desc jdesc;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-keyword">if</span> (vcb-&gt;vcbSigWord != kHFSPlusSigWord)
		<span class="enscript-keyword">return</span> (0);

	hfsmp = VCBTOHFS(vcb);

	memset(&amp;jdesc, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));
	jdesc.cd_parentcnid = kRootDirID;
	jdesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)name;
	jdesc.cd_namelen = strlen(name);

	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
	error = cat_lookup(hfsmp, &amp;jdesc, 0, 0, NULL, fattr, forkinfo, NULL);
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">return</span> (fattr-&gt;ca_fileid);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* XXX what callers expect on an error */</span>
}


<span class="enscript-comment">/*
 * On HFS Plus Volumes, there can be orphaned files or directories
 * These are files or directories that were unlinked while busy. 
 * If the volume was not cleanly unmounted then some of these may
 * have persisted and need to be removed.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_remove_orphans</span>(<span class="enscript-type">struct</span> hfsmount * hfsmp)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator = NULL;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	<span class="enscript-type">struct</span> HFSPlusCatalogFile filerec;
	<span class="enscript-type">struct</span> HFSPlusCatalogKey * keyp;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	FCB *fcb;
	ExtendedVCB *vcb;
	<span class="enscript-type">char</span> filename[32];
	<span class="enscript-type">char</span> tempname[32];
	size_t namelen;
	cat_cookie_t cookie;
	<span class="enscript-type">int</span> catlock = 0;
	<span class="enscript-type">int</span> catreserve = 0;
	bool started_tr = false;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> orphaned_files = 0;
	<span class="enscript-type">int</span> orphaned_dirs = 0;

	bzero(&amp;cookie, <span class="enscript-keyword">sizeof</span>(cookie));

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CLEANED_ORPHANS)
		<span class="enscript-keyword">return</span>;

	vcb = HFSTOVCB(hfsmp);
	fcb = VTOF(hfsmp-&gt;hfs_catalog_vp);

	btdata.bufferAddress = &amp;filerec;
	btdata.itemSize = <span class="enscript-keyword">sizeof</span>(filerec);
	btdata.itemCount = 1;

	MALLOC(iterator, <span class="enscript-type">struct</span> BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	
	<span class="enscript-comment">/* Build a key to &quot;temp&quot; */</span>
	keyp = (HFSPlusCatalogKey*)&amp;iterator-&gt;key;
	keyp-&gt;parentID = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
	keyp-&gt;nodeName.length = 4;  <span class="enscript-comment">/* &quot;temp&quot; */</span>
	keyp-&gt;keyLength = kHFSPlusCatalogKeyMinimumLength + keyp-&gt;nodeName.length * 2;
	keyp-&gt;nodeName.unicode[0] = <span class="enscript-string">'t'</span>;
	keyp-&gt;nodeName.unicode[1] = <span class="enscript-string">'e'</span>;
	keyp-&gt;nodeName.unicode[2] = <span class="enscript-string">'m'</span>;
	keyp-&gt;nodeName.unicode[3] = <span class="enscript-string">'p'</span>;

	<span class="enscript-comment">/*
	 * Position the iterator just before the first real temp file/dir.
	 */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
	(<span class="enscript-type">void</span>) BTSearchRecord(fcb, iterator, NULL, NULL, iterator);
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-comment">/* Visit all the temp files/dirs in the HFS+ private directory. */</span>
	<span class="enscript-keyword">for</span> (;;) {
		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
		result = BTIterateRecord(fcb, kBTreeNextRecord, iterator, &amp;btdata, NULL);
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (keyp-&gt;parentID != hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid)
			<span class="enscript-keyword">break</span>;
		
		(<span class="enscript-type">void</span>) utf8_encodestr(keyp-&gt;nodeName.unicode, keyp-&gt;nodeName.length * 2,
		                      (u_int8_t *)filename, &amp;namelen, <span class="enscript-keyword">sizeof</span>(filename), 0, 0);
		
		(<span class="enscript-type">void</span>) snprintf(tempname, <span class="enscript-keyword">sizeof</span>(tempname), <span class="enscript-string">&quot;%s%d&quot;</span>,
				HFS_DELETE_PREFIX, filerec.fileID);
		
		<span class="enscript-comment">/*
		 * Delete all files (and directories) named &quot;tempxxx&quot;, 
		 * where xxx is the file's cnid in decimal.
		 *
		 */</span>
		<span class="enscript-keyword">if</span> (bcmp(tempname, filename, namelen) != 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-type">struct</span> filefork dfork;
		<span class="enscript-type">struct</span> filefork rfork;
		<span class="enscript-type">struct</span> cnode cnode;
		<span class="enscript-type">int</span> mode = 0;

		bzero(&amp;dfork, <span class="enscript-keyword">sizeof</span>(dfork));
		bzero(&amp;rfork, <span class="enscript-keyword">sizeof</span>(rfork));
		bzero(&amp;cnode, <span class="enscript-keyword">sizeof</span>(cnode));
			
		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			printf(<span class="enscript-string">&quot;hfs_remove_orphans: failed to start transaction\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		started_tr = true;
		
		<span class="enscript-comment">/*
		 * Reserve some space in the Catalog file.
		 */</span>
		<span class="enscript-keyword">if</span> (cat_preflight(hfsmp, CAT_DELETE, &amp;cookie, p) != 0) {
			printf(<span class="enscript-string">&quot;hfs_remove_orphans: cat_preflight failed\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		catreserve = 1;

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE | SFL_EXTENTS | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
		catlock = 1;

		<span class="enscript-comment">/* Build a fake cnode */</span>
		cat_convertattr(hfsmp, (CatalogRecord *)&amp;filerec, &amp;cnode.c_attr,
						&amp;dfork.ff_data, &amp;rfork.ff_data);
		cnode.c_desc.cd_parentcnid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
		cnode.c_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)filename;
		cnode.c_desc.cd_namelen = namelen;
		cnode.c_desc.cd_cnid = cnode.c_attr.ca_fileid;
		cnode.c_blocks = dfork.ff_blocks + rfork.ff_blocks;

		<span class="enscript-comment">/* Position iterator at previous entry */</span>
		<span class="enscript-keyword">if</span> (BTIterateRecord(fcb, kBTreePrevRecord, iterator,
							NULL, NULL) != 0) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Truncate the file to zero (both forks) */</span>
		<span class="enscript-keyword">if</span> (dfork.ff_blocks &gt; 0) {
			u_int64_t fsize;
				
			dfork.ff_cp = &amp;cnode;
			cnode.c_datafork = &amp;dfork;
			cnode.c_rsrcfork = NULL;
			fsize = (u_int64_t)dfork.ff_blocks * (u_int64_t)HFSTOVCB(hfsmp)-&gt;blockSize;
			<span class="enscript-keyword">while</span> (fsize &gt; 0) {
				<span class="enscript-keyword">if</span> (fsize &gt; HFS_BIGFILE_SIZE) {
					fsize -= HFS_BIGFILE_SIZE;
				} <span class="enscript-keyword">else</span> {
					fsize = 0;
				}

				<span class="enscript-keyword">if</span> (TruncateFileC(vcb, (FCB*)&amp;dfork, fsize, 1, 0, 
								  cnode.c_attr.ca_fileid, false) != 0) {
					printf(<span class="enscript-string">&quot;hfs: error truncating data fork!\n&quot;</span>);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-comment">//
</span>				<span class="enscript-comment">// if we're iteratively truncating this file down,
</span>				<span class="enscript-comment">// then end the transaction and start a new one so
</span>				<span class="enscript-comment">// that no one transaction gets too big.
</span>				<span class="enscript-comment">//
</span>				<span class="enscript-keyword">if</span> (fsize &gt; 0) {
					<span class="enscript-comment">/* Drop system file locks before starting 
					 * another transaction to preserve lock order.
					 */</span>
					hfs_systemfile_unlock(hfsmp, lockflags);
					catlock = 0;
					hfs_end_transaction(hfsmp);

					<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
						started_tr = false;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
					}
					lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE | SFL_EXTENTS | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
					catlock = 1;
				}
			}
		}

		<span class="enscript-keyword">if</span> (rfork.ff_blocks &gt; 0) {
			rfork.ff_cp = &amp;cnode;
			cnode.c_datafork = NULL;
			cnode.c_rsrcfork = &amp;rfork;
			<span class="enscript-keyword">if</span> (TruncateFileC(vcb, (FCB*)&amp;rfork, 0, 1, 1, cnode.c_attr.ca_fileid, false) != 0) {
				printf(<span class="enscript-string">&quot;hfs: error truncating rsrc fork!\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">// Deal with extended attributes
</span>		<span class="enscript-keyword">if</span> (ISSET(cnode.c_attr.ca_recflags, kHFSHasAttributesMask)) {
			<span class="enscript-comment">// hfs_removeallattr uses its own transactions
</span>			hfs_systemfile_unlock(hfsmp, lockflags);
			catlock = false;
			hfs_end_transaction(hfsmp);

			hfs_removeallattr(hfsmp, cnode.c_attr.ca_fileid, &amp;started_tr);

			<span class="enscript-keyword">if</span> (!started_tr) {
				<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
					printf(<span class="enscript-string">&quot;hfs_remove_orphans: failed to start transaction\n&quot;</span>);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
				}
				started_tr = true;
			}

			lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE | SFL_EXTENTS | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
			catlock = 1;
		}

		<span class="enscript-comment">/* Remove the file or folder record from the Catalog */</span>	
		<span class="enscript-keyword">if</span> (cat_delete(hfsmp, &amp;cnode.c_desc, &amp;cnode.c_attr) != 0) {
			printf(<span class="enscript-string">&quot;hfs_remove_orphans: error deleting cat rec for id %d!\n&quot;</span>, cnode.c_desc.cd_cnid);
			hfs_systemfile_unlock(hfsmp, lockflags);
			catlock = 0;
			hfs_volupdate(hfsmp, VOL_UPDATE, 0);
			<span class="enscript-keyword">break</span>;
		}

		mode = cnode.c_attr.ca_mode &amp; S_IFMT;

		<span class="enscript-keyword">if</span> (mode == S_IFDIR) {
			orphaned_dirs++;
		}
		<span class="enscript-keyword">else</span> {
			orphaned_files++;
		}

		<span class="enscript-comment">/* Update parent and volume counts */</span>	
		hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS].ca_entries--;
		<span class="enscript-keyword">if</span> (mode == S_IFDIR) {
			DEC_FOLDERCOUNT(hfsmp, hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS]);
		}

		(<span class="enscript-type">void</span>)cat_update(hfsmp, &amp;hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS],
						 &amp;hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS], NULL, NULL);

		<span class="enscript-comment">/* Drop locks and end the transaction */</span>
		hfs_systemfile_unlock(hfsmp, lockflags);
		cat_postflight(hfsmp, &amp;cookie, p);
		catlock = catreserve = 0;

		<span class="enscript-comment">/* 
		   Now that Catalog is unlocked, update the volume info, making
		   sure to differentiate between files and directories
		*/</span>
		<span class="enscript-keyword">if</span> (mode == S_IFDIR) {
			hfs_volupdate(hfsmp, VOL_RMDIR, 0);
		}
		<span class="enscript-keyword">else</span>{
			hfs_volupdate(hfsmp, VOL_RMFILE, 0);
		}

		hfs_end_transaction(hfsmp);
		started_tr = false;
	} <span class="enscript-comment">/* end for */</span>

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">if</span> (orphaned_files &gt; 0 || orphaned_dirs &gt; 0)
		printf(<span class="enscript-string">&quot;hfs: Removed %d orphaned / unlinked files and %d directories \n&quot;</span>, orphaned_files, orphaned_dirs);
	<span class="enscript-keyword">if</span> (catlock) {
		hfs_systemfile_unlock(hfsmp, lockflags);
	}
	<span class="enscript-keyword">if</span> (catreserve) {
		cat_postflight(hfsmp, &amp;cookie, p);
	}
	<span class="enscript-keyword">if</span> (started_tr) {
		hfs_end_transaction(hfsmp);
	}

	FREE(iterator, M_TEMP);
	hfsmp-&gt;hfs_flags |= HFS_CLEANED_ORPHANS;
}


<span class="enscript-comment">/*
 * This will return the correct logical block size for a given vnode.
 * For most files, it is the allocation block size, for meta data like
 * BTrees, this is kept as part of the BTree private nodeSize
 */</span>
u_int32_t
<span class="enscript-function-name">GetLogicalBlockSize</span>(<span class="enscript-type">struct</span> vnode *vp)
{
u_int32_t logBlockSize;
	
	DBG_ASSERT(vp != NULL);

	<span class="enscript-comment">/* start with default */</span>
	logBlockSize = VTOHFS(vp)-&gt;hfs_logBlockSize;

	<span class="enscript-keyword">if</span> (vnode_issystem(vp)) {
		<span class="enscript-keyword">if</span> (VTOF(vp)-&gt;fcbBTCBPtr != NULL) {
			BTreeInfoRec			bTreeInfo;
	
			<span class="enscript-comment">/*
			 * We do not lock the BTrees, because if we are getting block..then the tree
			 * should be locked in the first place.
			 * We just want the nodeSize wich will NEVER change..so even if the world
			 * is changing..the nodeSize should remain the same. Which argues why lock
			 * it in the first place??
			 */</span>
			
			(<span class="enscript-type">void</span>) BTGetInformation	(VTOF(vp), kBTreeInfoVersion, &amp;bTreeInfo);
					
			logBlockSize = bTreeInfo.nodeSize;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_fileid == kHFSAllocationFileID) {
				logBlockSize = VTOVCB(vp)-&gt;vcbVBMIOSize;
		}
	}

	DBG_ASSERT(logBlockSize &gt; 0);
	
	<span class="enscript-keyword">return</span> logBlockSize;	
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
<span class="enscript-type">static</span> bool <span class="enscript-function-name">hfs_get_backing_free_blks</span>(hfsmount_t *hfsmp, uint64_t *pfree_blks)
{
	<span class="enscript-type">struct</span> vfsstatfs *vfsp;  <span class="enscript-comment">/* 272 bytes */</span>
	uint64_t vfreeblks;
	<span class="enscript-type">struct</span> timeval now;

	hfs_lock_mount(hfsmp);

	vnode_t backing_vp = hfsmp-&gt;hfs_backingfs_rootvp;
	<span class="enscript-keyword">if</span> (!backing_vp) {
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> false;
	}

	<span class="enscript-comment">// usecount is not enough; we need iocount
</span>	<span class="enscript-keyword">if</span> (vnode_get(backing_vp)) {
		hfs_unlock_mount(hfsmp);
		*pfree_blks = 0;
		<span class="enscript-keyword">return</span> true;
	}

	uint32_t loanedblks = hfsmp-&gt;loanedBlocks + hfsmp-&gt;lockedBlocks;
	uint32_t bandblks	= hfsmp-&gt;hfs_sparsebandblks;
	uint64_t maxblks	= hfsmp-&gt;hfs_backingfs_maxblocks;

	hfs_unlock_mount(hfsmp);

	mount_t backingfs_mp = vnode_mount(backing_vp);

	microtime(&amp;now);
	<span class="enscript-keyword">if</span> ((now.tv_sec - hfsmp-&gt;hfs_last_backingstatfs) &gt;= 1) {
		vfs_update_vfsstat(backingfs_mp, vfs_context_kernel(), VFS_KERNEL_EVENT);
		hfsmp-&gt;hfs_last_backingstatfs = now.tv_sec;
	}

	<span class="enscript-keyword">if</span> (!(vfsp = vfs_statfs(backingfs_mp))) {
		vnode_put(backing_vp);
		<span class="enscript-keyword">return</span> false;
	}

	vfreeblks = vfsp-&gt;f_bavail;
	<span class="enscript-comment">/* Normalize block count if needed. */</span>
	<span class="enscript-keyword">if</span> (vfsp-&gt;f_bsize != hfsmp-&gt;blockSize)
		vfreeblks = vfreeblks * vfsp-&gt;f_bsize / hfsmp-&gt;blockSize;
	<span class="enscript-keyword">if</span> (vfreeblks &gt; bandblks)
		vfreeblks -= bandblks;
	<span class="enscript-keyword">else</span>
		vfreeblks = 0;

	<span class="enscript-comment">/* 
	 * Take into account any delayed allocations.  It is not
	 * certain what the original reason for the &quot;2 *&quot; is.  Most
	 * likely it is to allow for additional requirements in the
	 * host file system and metadata required by disk images.  The
	 * number of loaned blocks is likely to be small and we will
	 * stop using them as we get close to the limit.
	 */</span>
	loanedblks = 2 * loanedblks;
	<span class="enscript-keyword">if</span> (vfreeblks &gt; loanedblks)
		vfreeblks -= loanedblks;
	<span class="enscript-keyword">else</span>
		vfreeblks = 0;

	<span class="enscript-keyword">if</span> (maxblks)
		vfreeblks = MIN(vfreeblks, maxblks);

	vnode_put(backing_vp);

	*pfree_blks = vfreeblks;

	<span class="enscript-keyword">return</span> true;
}
#<span class="enscript-reference">endif</span>

u_int32_t
<span class="enscript-function-name">hfs_freeblks</span>(<span class="enscript-type">struct</span> hfsmount * hfsmp, <span class="enscript-type">int</span> wantreserve)
{
	u_int32_t freeblks;
	u_int32_t rsrvblks;
	u_int32_t loanblks;

	<span class="enscript-comment">/*
	 * We don't bother taking the mount lock
	 * to look at these values since the values
	 * themselves are each updated atomically
	 * on aligned addresses.
	 */</span>
	freeblks = hfsmp-&gt;freeBlocks;
	rsrvblks = hfsmp-&gt;reserveBlocks;
	loanblks = hfsmp-&gt;loanedBlocks + hfsmp-&gt;lockedBlocks;
	<span class="enscript-keyword">if</span> (wantreserve) {
		<span class="enscript-keyword">if</span> (freeblks &gt; rsrvblks)
			freeblks -= rsrvblks;
		<span class="enscript-keyword">else</span>
			freeblks = 0;
	}
	<span class="enscript-keyword">if</span> (freeblks &gt; loanblks)
		freeblks -= loanblks;
	<span class="enscript-keyword">else</span>
		freeblks = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
	<span class="enscript-comment">/* 
	 * When the underlying device is sparse, check the
	 * available space on the backing store volume.
	 */</span>
	uint64_t vfreeblks;
	<span class="enscript-keyword">if</span> (hfs_get_backing_free_blks(hfsmp, &amp;vfreeblks))
		freeblks = MIN(freeblks, vfreeblks);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_SPARSE_DEV */</span>

	<span class="enscript-keyword">return</span> (freeblks);
}

<span class="enscript-comment">/*
 * Map HFS Common errors (negative) to BSD error codes (positive).
 * Positive errors (ie BSD errors) are passed through unchanged.
 */</span>
<span class="enscript-type">short</span> <span class="enscript-function-name">MacToVFSError</span>(OSErr err)
{
	<span class="enscript-keyword">if</span> (err &gt;= 0)
        	<span class="enscript-keyword">return</span> err;

	<span class="enscript-comment">/* BSD/VFS internal errnos */</span>
	<span class="enscript-keyword">switch</span> (err) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ERESERVEDNAME</span>: <span class="enscript-comment">/* -8 */</span>
			<span class="enscript-keyword">return</span> err;
	}

	<span class="enscript-keyword">switch</span> (err) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">dskFulErr</span>:			<span class="enscript-comment">/*    -34 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">btNoSpaceAvail</span>:		<span class="enscript-comment">/* -32733 */</span>
		<span class="enscript-keyword">return</span> ENOSPC;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">fxOvFlErr</span>:			<span class="enscript-comment">/* -32750 */</span>
		<span class="enscript-keyword">return</span> EOVERFLOW;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">btBadNode</span>:			<span class="enscript-comment">/* -32731 */</span>
		<span class="enscript-keyword">return</span> EIO;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">memFullErr</span>:		<span class="enscript-comment">/*  -108 */</span>
		<span class="enscript-keyword">return</span> ENOMEM;		<span class="enscript-comment">/*   +12 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">cmExists</span>:			<span class="enscript-comment">/* -32718 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">btExists</span>:			<span class="enscript-comment">/* -32734 */</span>
		<span class="enscript-keyword">return</span> EEXIST;		<span class="enscript-comment">/*    +17 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">cmNotFound</span>:		<span class="enscript-comment">/* -32719 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">btNotFound</span>:		<span class="enscript-comment">/* -32735 */</span>	
		<span class="enscript-keyword">return</span> ENOENT;		<span class="enscript-comment">/*     28 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">cmNotEmpty</span>:		<span class="enscript-comment">/* -32717 */</span>
		<span class="enscript-keyword">return</span> ENOTEMPTY;	<span class="enscript-comment">/*     66 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">cmFThdDirErr</span>:		<span class="enscript-comment">/* -32714 */</span>
		<span class="enscript-keyword">return</span> EISDIR;		<span class="enscript-comment">/*     21 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">fxRangeErr</span>:		<span class="enscript-comment">/* -32751 */</span>
		<span class="enscript-keyword">return</span> ERANGE;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">bdNamErr</span>:			<span class="enscript-comment">/*   -37 */</span>
		<span class="enscript-keyword">return</span> ENAMETOOLONG;	<span class="enscript-comment">/*    63 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">paramErr</span>:			<span class="enscript-comment">/*   -50 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">fileBoundsErr</span>:		<span class="enscript-comment">/* -1309 */</span>
		<span class="enscript-keyword">return</span> EINVAL;		<span class="enscript-comment">/*   +22 */</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">fsBTBadNodeSize</span>:
		<span class="enscript-keyword">return</span> ENXIO;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EIO;		<span class="enscript-comment">/*   +5 */</span>
	}
}


<span class="enscript-comment">/*
 * Find the current thread's directory hint for a given index.
 *
 * Requires an exclusive lock on directory cnode.
 *
 * Use detach if the cnode lock must be dropped while the hint is still active.
 */</span>
__private_extern__
directoryhint_t *
<span class="enscript-function-name">hfs_getdirhint</span>(<span class="enscript-type">struct</span> cnode *dcp, <span class="enscript-type">int</span> index, <span class="enscript-type">int</span> detach)
{
	<span class="enscript-type">struct</span> timeval tv;
	directoryhint_t *hint;
	boolean_t need_remove, need_init;
	<span class="enscript-type">const</span> u_int8_t * name;

	microuptime(&amp;tv);

	<span class="enscript-comment">/*
	 *  Look for an existing hint first.  If not found, create a new one (when
	 *  the list is not full) or recycle the oldest hint.  Since new hints are
	 *  always added to the head of the list, the last hint is always the
	 *  oldest.
	 */</span>
	TAILQ_FOREACH(hint, &amp;dcp-&gt;c_hintlist, dh_link) {
		<span class="enscript-keyword">if</span> (hint-&gt;dh_index == index)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (hint != NULL) { <span class="enscript-comment">/* found an existing hint */</span>
		need_init = false;
		need_remove = true;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* cannot find an existing hint */</span>
		need_init = true;
		<span class="enscript-keyword">if</span> (dcp-&gt;c_dirhintcnt &lt; HFS_MAXDIRHINTS) { <span class="enscript-comment">/* we don't need recycling */</span>
			<span class="enscript-comment">/* Create a default directory hint */</span>
			MALLOC_ZONE(hint, directoryhint_t *, <span class="enscript-keyword">sizeof</span>(directoryhint_t), M_HFSDIRHINT, M_WAITOK);
			++dcp-&gt;c_dirhintcnt;
			need_remove = false;
		} <span class="enscript-keyword">else</span> {				<span class="enscript-comment">/* recycle the last (i.e., the oldest) hint */</span>
			hint = TAILQ_LAST(&amp;dcp-&gt;c_hintlist, hfs_hinthead);
			<span class="enscript-keyword">if</span> ((hint-&gt;dh_desc.cd_flags &amp; CD_HASBUF) &amp;&amp;
			    (name = hint-&gt;dh_desc.cd_nameptr)) {
				hint-&gt;dh_desc.cd_nameptr = NULL;
				hint-&gt;dh_desc.cd_namelen = 0;
				hint-&gt;dh_desc.cd_flags &amp;= ~CD_HASBUF;				
				vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)name);
			}
			need_remove = true;
		}
	}

	<span class="enscript-keyword">if</span> (need_remove)
		TAILQ_REMOVE(&amp;dcp-&gt;c_hintlist, hint, dh_link);

	<span class="enscript-keyword">if</span> (detach)
		--dcp-&gt;c_dirhintcnt;
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_HEAD(&amp;dcp-&gt;c_hintlist, hint, dh_link);

	<span class="enscript-keyword">if</span> (need_init) {
		hint-&gt;dh_index = index;
		hint-&gt;dh_desc.cd_flags = 0;
		hint-&gt;dh_desc.cd_encoding = 0;
		hint-&gt;dh_desc.cd_namelen = 0;
		hint-&gt;dh_desc.cd_nameptr = NULL;
		hint-&gt;dh_desc.cd_parentcnid = dcp-&gt;c_fileid;
		hint-&gt;dh_desc.cd_hint = dcp-&gt;c_childhint;
		hint-&gt;dh_desc.cd_cnid = 0;
	}
	hint-&gt;dh_time = tv.tv_sec;
	<span class="enscript-keyword">return</span> (hint);
}

<span class="enscript-comment">/*
 * Release a single directory hint.
 *
 * Requires an exclusive lock on directory cnode.
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_reldirhint</span>(<span class="enscript-type">struct</span> cnode *dcp, directoryhint_t * relhint)
{
	<span class="enscript-type">const</span> u_int8_t * name;
	directoryhint_t *hint;

	<span class="enscript-comment">/* Check if item is on list (could be detached) */</span>
	TAILQ_FOREACH(hint, &amp;dcp-&gt;c_hintlist, dh_link) {
		<span class="enscript-keyword">if</span> (hint == relhint) {
			TAILQ_REMOVE(&amp;dcp-&gt;c_hintlist, relhint, dh_link);
			--dcp-&gt;c_dirhintcnt;
			<span class="enscript-keyword">break</span>;
		}
	}
	name = relhint-&gt;dh_desc.cd_nameptr;
	<span class="enscript-keyword">if</span> ((relhint-&gt;dh_desc.cd_flags &amp; CD_HASBUF) &amp;&amp; (name != NULL)) {
		relhint-&gt;dh_desc.cd_nameptr = NULL;
		relhint-&gt;dh_desc.cd_namelen = 0;
		relhint-&gt;dh_desc.cd_flags &amp;= ~CD_HASBUF;
		vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)name);
	}
	FREE_ZONE(relhint, <span class="enscript-keyword">sizeof</span>(directoryhint_t), M_HFSDIRHINT);
}

<span class="enscript-comment">/*
 * Release directory hints for given directory
 *
 * Requires an exclusive lock on directory cnode.
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_reldirhints</span>(<span class="enscript-type">struct</span> cnode *dcp, <span class="enscript-type">int</span> stale_hints_only)
{
	<span class="enscript-type">struct</span> timeval tv;
	directoryhint_t *hint, *prev;
	<span class="enscript-type">const</span> u_int8_t * name;

	<span class="enscript-keyword">if</span> (stale_hints_only)
		microuptime(&amp;tv);

	<span class="enscript-comment">/* searching from the oldest to the newest, so we can stop early when releasing stale hints only */</span>
	<span class="enscript-keyword">for</span> (hint = TAILQ_LAST(&amp;dcp-&gt;c_hintlist, hfs_hinthead); hint != NULL; hint = prev) {
		<span class="enscript-keyword">if</span> (stale_hints_only &amp;&amp; (tv.tv_sec - hint-&gt;dh_time) &lt; HFS_DIRHINT_TTL)
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* stop here if this entry is too new */</span>
		name = hint-&gt;dh_desc.cd_nameptr;
		<span class="enscript-keyword">if</span> ((hint-&gt;dh_desc.cd_flags &amp; CD_HASBUF) &amp;&amp; (name != NULL)) {
			hint-&gt;dh_desc.cd_nameptr = NULL;
			hint-&gt;dh_desc.cd_namelen = 0;
			hint-&gt;dh_desc.cd_flags &amp;= ~CD_HASBUF;
			vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)name);
		}
		prev = TAILQ_PREV(hint, hfs_hinthead, dh_link); <span class="enscript-comment">/* must save this pointer before calling FREE_ZONE on this node */</span>
		TAILQ_REMOVE(&amp;dcp-&gt;c_hintlist, hint, dh_link);
		FREE_ZONE(hint, <span class="enscript-keyword">sizeof</span>(directoryhint_t), M_HFSDIRHINT);
		--dcp-&gt;c_dirhintcnt;
	}
}

<span class="enscript-comment">/*
 * Insert a detached directory hint back into the list of dirhints.
 *
 * Requires an exclusive lock on directory cnode.
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_insertdirhint</span>(<span class="enscript-type">struct</span> cnode *dcp, directoryhint_t * hint)
{
	directoryhint_t *test;

	TAILQ_FOREACH(test, &amp;dcp-&gt;c_hintlist, dh_link) {
		<span class="enscript-keyword">if</span> (test == hint)
			panic(<span class="enscript-string">&quot;hfs_insertdirhint: hint %p already on list!&quot;</span>, hint);
	}

	TAILQ_INSERT_HEAD(&amp;dcp-&gt;c_hintlist, hint, dh_link);
	++dcp-&gt;c_dirhintcnt;
}

<span class="enscript-comment">/*
 * Perform a case-insensitive compare of two UTF-8 filenames.
 *
 * Returns 0 if the strings match.
 */</span>
__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_namecmp</span>(<span class="enscript-type">const</span> u_int8_t *str1, size_t len1, <span class="enscript-type">const</span> u_int8_t *str2, size_t len2)
{
	u_int16_t *ustr1, *ustr2;
	size_t ulen1, ulen2;
	size_t maxbytes;
	<span class="enscript-type">int</span> cmp = -1;

	<span class="enscript-keyword">if</span> (len1 != len2)
		<span class="enscript-keyword">return</span> (cmp);

	maxbytes = kHFSPlusMaxFileNameChars &lt;&lt; 1;
	MALLOC(ustr1, u_int16_t *, maxbytes &lt;&lt; 1, M_TEMP, M_WAITOK);
	ustr2 = ustr1 + (maxbytes &gt;&gt; 1);

	<span class="enscript-keyword">if</span> (utf8_decodestr(str1, len1, ustr1, &amp;ulen1, maxbytes, <span class="enscript-string">':'</span>, 0) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (utf8_decodestr(str2, len2, ustr2, &amp;ulen2, maxbytes, <span class="enscript-string">':'</span>, 0) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	cmp = FastUnicodeCompare(ustr1, ulen1&gt;&gt;1, ustr2, ulen2&gt;&gt;1);
<span class="enscript-reference">out</span>:
	FREE(ustr1, M_TEMP);
	<span class="enscript-keyword">return</span> (cmp);
}


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> jopen_cb_info {
	off_t   jsize;
	<span class="enscript-type">char</span>   *desired_uuid;
        <span class="enscript-type">struct</span>  vnode *jvp;
	size_t  blksize;
	<span class="enscript-type">int</span>     need_clean;
	<span class="enscript-type">int</span>     need_init;
} jopen_cb_info;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">journal_open_cb</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *bsd_dev_name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *uuid_str, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> nameidata nd;
	jopen_cb_info *ji = (jopen_cb_info *)arg;
	<span class="enscript-type">char</span> bsd_name[256];
	<span class="enscript-type">int</span> error;
	
	strlcpy(&amp;bsd_name[0], <span class="enscript-string">&quot;/dev/&quot;</span>, <span class="enscript-keyword">sizeof</span>(bsd_name));
	strlcpy(&amp;bsd_name[5], bsd_dev_name, <span class="enscript-keyword">sizeof</span>(bsd_name)-5);

	<span class="enscript-keyword">if</span> (ji-&gt;desired_uuid &amp;&amp; ji-&gt;desired_uuid[0] &amp;&amp; strcmp(uuid_str, ji-&gt;desired_uuid) != 0) {
		<span class="enscript-keyword">return</span> 1;   <span class="enscript-comment">// keep iterating
</span>	}

	<span class="enscript-comment">// if we're here, either the desired uuid matched or there was no
</span>	<span class="enscript-comment">// desired uuid so let's try to open the device for writing and
</span>	<span class="enscript-comment">// see if it works.  if it does, we'll use it.
</span>	
	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, LOCKLEAF, UIO_SYSSPACE32, CAST_USER_ADDR_T(bsd_name), vfs_context_kernel());
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		printf(<span class="enscript-string">&quot;hfs: journal open cb: error %d looking up device %s (dev uuid %s)\n&quot;</span>, error, bsd_name, uuid_str);
		<span class="enscript-keyword">return</span> 1;   <span class="enscript-comment">// keep iterating
</span>	}

	ji-&gt;jvp = nd.ni_vp;
	nameidone(&amp;nd);

	<span class="enscript-keyword">if</span> (ji-&gt;jvp == NULL) {
		printf(<span class="enscript-string">&quot;hfs: journal open cb: did not find %s (error %d)\n&quot;</span>, bsd_name, error);
	} <span class="enscript-keyword">else</span> {
		error = VNOP_OPEN(ji-&gt;jvp, FREAD|FWRITE, vfs_context_kernel());
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">// if the journal is dirty and we didn't specify a desired
</span>			<span class="enscript-comment">// journal device uuid, then do not use the journal.  but
</span>			<span class="enscript-comment">// if the journal is just invalid (e.g. it hasn't been
</span>			<span class="enscript-comment">// initialized) then just set the need_init flag.
</span>			<span class="enscript-keyword">if</span> (ji-&gt;need_clean &amp;&amp; ji-&gt;desired_uuid &amp;&amp; ji-&gt;desired_uuid[0] == <span class="enscript-string">'\0'</span>) {
				error = journal_is_clean(ji-&gt;jvp, 0, ji-&gt;jsize, (<span class="enscript-type">void</span> *)1, ji-&gt;blksize);
				<span class="enscript-keyword">if</span> (error == EBUSY) {
					VNOP_CLOSE(ji-&gt;jvp, FREAD|FWRITE, vfs_context_kernel());
					vnode_put(ji-&gt;jvp);
					ji-&gt;jvp = NULL;
					<span class="enscript-keyword">return</span> 1;    <span class="enscript-comment">// keep iterating
</span>				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EINVAL) {
					ji-&gt;need_init = 1;
				}
			}

			<span class="enscript-keyword">if</span> (ji-&gt;desired_uuid &amp;&amp; ji-&gt;desired_uuid[0] == <span class="enscript-string">'\0'</span>) {
				strlcpy(ji-&gt;desired_uuid, uuid_str, 128);
			}
			vnode_setmountedon(ji-&gt;jvp);
			<span class="enscript-keyword">return</span> 0;   <span class="enscript-comment">// stop iterating
</span>		} <span class="enscript-keyword">else</span> {
			vnode_put(ji-&gt;jvp);
			ji-&gt;jvp = NULL;
		}
	}

	<span class="enscript-keyword">return</span> 1;   <span class="enscript-comment">// keep iterating
</span>}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOBSDIterateMediaWithContent</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *uuid_cstring, <span class="enscript-type">int</span> (*func)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *bsd_dev_name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *uuid_str, <span class="enscript-type">void</span> *arg), <span class="enscript-type">void</span> *arg);
kern_return_t <span class="enscript-function-name">IOBSDGetPlatformSerialNumber</span>(<span class="enscript-type">char</span> *serial_number_str, u_int32_t len);


<span class="enscript-type">static</span> vnode_t
<span class="enscript-function-name">open_journal_dev</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vol_device,
		 <span class="enscript-type">int</span> need_clean,
		 <span class="enscript-type">char</span> *uuid_str,
		 <span class="enscript-type">char</span> *machine_serial_num,
		 off_t jsize,
		 size_t blksize,
		 <span class="enscript-type">int</span> *need_init)
{
    <span class="enscript-type">int</span> retry_counter=0;
    jopen_cb_info ji;

    ji.jsize        = jsize;
    ji.desired_uuid = uuid_str;
    ji.jvp          = NULL;
    ji.blksize      = blksize;
    ji.need_clean   = need_clean;
    ji.need_init    = 0;

<span class="enscript-comment">//    if (uuid_str[0] == '\0') {
</span><span class="enscript-comment">//	    printf(&quot;hfs: open journal dev: %s: locating any available non-dirty external journal partition\n&quot;, vol_device);
</span><span class="enscript-comment">//    } else {
</span><span class="enscript-comment">//	    printf(&quot;hfs: open journal dev: %s: trying to find the external journal partition w/uuid %s\n&quot;, vol_device, uuid_str);
</span><span class="enscript-comment">//    }
</span>    <span class="enscript-keyword">while</span> (ji.jvp == NULL &amp;&amp; retry_counter++ &lt; 4) {
	    <span class="enscript-keyword">if</span> (retry_counter &gt; 1) {
		    <span class="enscript-keyword">if</span> (uuid_str[0]) {
			    printf(<span class="enscript-string">&quot;hfs: open_journal_dev: uuid %s not found.  waiting 10sec.\n&quot;</span>, uuid_str);
		    } <span class="enscript-keyword">else</span> {
			    printf(<span class="enscript-string">&quot;hfs: open_journal_dev: no available external journal partition found.  waiting 10sec.\n&quot;</span>);
		    }
		    delay_for_interval(10* 1000000, NSEC_PER_USEC);    <span class="enscript-comment">// wait for ten seconds and then try again
</span>	    }

	    IOBSDIterateMediaWithContent(EXTJNL_CONTENT_TYPE_UUID, journal_open_cb, &amp;ji);
    }

    <span class="enscript-keyword">if</span> (ji.jvp == NULL) {
	    printf(<span class="enscript-string">&quot;hfs: volume: %s: did not find jnl device uuid: %s from machine serial number: %s\n&quot;</span>,
		   vol_device, uuid_str, machine_serial_num);
    }

    *need_init = ji.need_init;

    <span class="enscript-keyword">return</span> ji.jvp;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_early_journal_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp,
					   <span class="enscript-type">void</span> *_args, off_t embeddedOffset, daddr64_t mdb_offset,
					   HFSMasterDirectoryBlock *mdbp, kauth_cred_t cred)
{
	JournalInfoBlock *jibp;
	<span class="enscript-type">struct</span> buf       *jinfo_bp, *bp;
	<span class="enscript-type">int</span>               sectors_per_fsblock, arg_flags=0, arg_tbufsz=0;
	<span class="enscript-type">int</span>               retval, write_jibp = 0;
	uint32_t		  blksize = hfsmp-&gt;hfs_logical_block_size;
	<span class="enscript-type">struct</span> vnode     *devvp;
	<span class="enscript-type">struct</span> hfs_mount_args *args = _args;
	u_int32_t	  jib_flags;
	u_int64_t	  jib_offset;
	u_int64_t	  jib_size;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dev_name;
	
	devvp = hfsmp-&gt;hfs_devvp;
	dev_name = vnode_getname_printable(devvp);

	<span class="enscript-keyword">if</span> (args != NULL &amp;&amp; (args-&gt;flags &amp; HFSFSMNT_EXTENDED_ARGS)) {
		arg_flags  = args-&gt;journal_flags;
		arg_tbufsz = args-&gt;journal_tbuffer_size;
	}

	sectors_per_fsblock = SWAP_BE32(vhp-&gt;blockSize) / blksize;
				
	jinfo_bp = NULL;
	retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp,
						(daddr64_t)((embeddedOffset/blksize) + 
						((u_int64_t)SWAP_BE32(vhp-&gt;journalInfoBlock)*sectors_per_fsblock)),
						hfsmp-&gt;hfs_physical_block_size, cred, &amp;jinfo_bp);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (jinfo_bp) {
			buf_brelse(jinfo_bp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_dev_name</span>;
	}
	
	jibp = (JournalInfoBlock *)buf_dataptr(jinfo_bp);
	jib_flags  = SWAP_BE32(jibp-&gt;flags);
	jib_size   = SWAP_BE64(jibp-&gt;size);

	<span class="enscript-keyword">if</span> (jib_flags &amp; kJIJournalInFSMask) {
		hfsmp-&gt;jvp = hfsmp-&gt;hfs_devvp;
		jib_offset = SWAP_BE64(jibp-&gt;offset);
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-type">int</span> need_init=0;
	
	    <span class="enscript-comment">// if the volume was unmounted cleanly then we'll pick any
</span>	    <span class="enscript-comment">// available external journal partition
</span>	    <span class="enscript-comment">//
</span>	    <span class="enscript-keyword">if</span> (SWAP_BE32(vhp-&gt;attributes) &amp; kHFSVolumeUnmountedMask) {
		    *((<span class="enscript-type">char</span> *)&amp;jibp-&gt;ext_jnl_uuid[0]) = <span class="enscript-string">'\0'</span>;
	    }

	    hfsmp-&gt;jvp = open_journal_dev(dev_name,
					  !(jib_flags &amp; kJIJournalNeedInitMask),
					  (<span class="enscript-type">char</span> *)&amp;jibp-&gt;ext_jnl_uuid[0],
					  (<span class="enscript-type">char</span> *)&amp;jibp-&gt;machine_serial_num[0],
					  jib_size,
					  hfsmp-&gt;hfs_logical_block_size,
					  &amp;need_init);
	    <span class="enscript-keyword">if</span> (hfsmp-&gt;jvp == NULL) {
		    buf_brelse(jinfo_bp);
		    retval = EROFS;
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_dev_name</span>;
	    } <span class="enscript-keyword">else</span> {
		    <span class="enscript-keyword">if</span> (IOBSDGetPlatformSerialNumber(&amp;jibp-&gt;machine_serial_num[0], <span class="enscript-keyword">sizeof</span>(jibp-&gt;machine_serial_num)) != KERN_SUCCESS) {
			    strlcpy(&amp;jibp-&gt;machine_serial_num[0], <span class="enscript-string">&quot;unknown-machine-uuid&quot;</span>, <span class="enscript-keyword">sizeof</span>(jibp-&gt;machine_serial_num));
		    }
	    }

	    jib_offset = 0;
	    write_jibp = 1;
	    <span class="enscript-keyword">if</span> (need_init) {
		    jib_flags |= kJIJournalNeedInitMask;
	    }
	}

	<span class="enscript-comment">// save this off for the hack-y check in hfs_remove()
</span>	hfsmp-&gt;jnl_start = jib_offset / SWAP_BE32(vhp-&gt;blockSize);
	hfsmp-&gt;jnl_size  = jib_size;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) &amp;&amp; (vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_ROOTFS) == 0) {
	    <span class="enscript-comment">// if the file system is read-only, check if the journal is empty.
</span>	    <span class="enscript-comment">// if it is, then we can allow the mount.  otherwise we have to
</span>	    <span class="enscript-comment">// return failure.
</span>	    retval = journal_is_clean(hfsmp-&gt;jvp,
				      jib_offset + embeddedOffset,
				      jib_size,
				      devvp,
				      hfsmp-&gt;hfs_logical_block_size);

	    hfsmp-&gt;jnl = NULL;

	    buf_brelse(jinfo_bp);

	    <span class="enscript-keyword">if</span> (retval) {
		    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = vnode_getname_printable(devvp);
		    printf(<span class="enscript-string">&quot;hfs: early journal init: volume on %s is read-only and journal is dirty.  Can not mount volume.\n&quot;</span>,
		    name);
		    vnode_putname_printable(name);
	    }

	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_dev_name</span>;
	}

	<span class="enscript-keyword">if</span> (jib_flags &amp; kJIJournalNeedInitMask) {
		printf(<span class="enscript-string">&quot;hfs: Initializing the journal (joffset 0x%llx sz 0x%llx)...\n&quot;</span>,
			   jib_offset + embeddedOffset, jib_size);
		hfsmp-&gt;jnl = journal_create(hfsmp-&gt;jvp,
									jib_offset + embeddedOffset,
									jib_size,
									devvp,
									blksize,
									arg_flags,
									arg_tbufsz,
									hfs_sync_metadata, hfsmp-&gt;hfs_mp,
									hfsmp-&gt;hfs_mp);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
			journal_trim_set_callback(hfsmp-&gt;jnl, hfs_trim_callback, hfsmp);

		<span class="enscript-comment">// no need to start a transaction here... if this were to fail
</span>		<span class="enscript-comment">// we'd just re-init it on the next mount.
</span>		jib_flags &amp;= ~kJIJournalNeedInitMask;
		jibp-&gt;flags  = SWAP_BE32(jib_flags);
		buf_bwrite(jinfo_bp);
		jinfo_bp = NULL;
		jibp     = NULL;
	} <span class="enscript-keyword">else</span> { 
		<span class="enscript-comment">//printf(&quot;hfs: Opening the journal (joffset 0x%llx sz 0x%llx vhp_blksize %d)...\n&quot;,
</span>		<span class="enscript-comment">//	   jib_offset + embeddedOffset,
</span>		<span class="enscript-comment">//	   jib_size, SWAP_BE32(vhp-&gt;blockSize));
</span>				
		hfsmp-&gt;jnl = journal_open(hfsmp-&gt;jvp,
								  jib_offset + embeddedOffset,
								  jib_size,
								  devvp,
								  blksize,
								  arg_flags,
								  arg_tbufsz,
								  hfs_sync_metadata, hfsmp-&gt;hfs_mp,
								  hfsmp-&gt;hfs_mp);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
			journal_trim_set_callback(hfsmp-&gt;jnl, hfs_trim_callback, hfsmp);

		<span class="enscript-keyword">if</span> (write_jibp) {
			buf_bwrite(jinfo_bp);
		} <span class="enscript-keyword">else</span> {
			buf_brelse(jinfo_bp);
		}
		jinfo_bp = NULL;
		jibp     = NULL;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; mdbp) {
			<span class="enscript-comment">// reload the mdb because it could have changed
</span>			<span class="enscript-comment">// if the journal had to be replayed.
</span>			<span class="enscript-keyword">if</span> (mdb_offset == 0) {
				mdb_offset = (daddr64_t)((embeddedOffset / blksize) + HFS_PRI_SECTOR(blksize));
			}
			bp = NULL;
			retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp, 
					HFS_PHYSBLK_ROUNDDOWN(mdb_offset, hfsmp-&gt;hfs_log_per_phys),
					hfsmp-&gt;hfs_physical_block_size, cred, &amp;bp);
			<span class="enscript-keyword">if</span> (retval) {
				<span class="enscript-keyword">if</span> (bp) {
					buf_brelse(bp);
				}
				printf(<span class="enscript-string">&quot;hfs: failed to reload the mdb after opening the journal (retval %d)!\n&quot;</span>,
					   retval);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_dev_name</span>;
			}
			bcopy((<span class="enscript-type">char</span> *)buf_dataptr(bp) + HFS_PRI_OFFSET(hfsmp-&gt;hfs_physical_block_size), mdbp, 512);
			buf_brelse(bp);
			bp = NULL;
		}
	}

	<span class="enscript-comment">// if we expected the journal to be there and we couldn't
</span>	<span class="enscript-comment">// create it or open it then we have to bail out.
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		printf(<span class="enscript-string">&quot;hfs: early jnl init: failed to open/create the journal (retval %d).\n&quot;</span>, retval);
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup_dev_name</span>;
	}

	retval = 0;
	
<span class="enscript-reference">cleanup_dev_name</span>:
	vnode_putname_printable(dev_name);
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// This function will go and re-locate the .journal_info_block and
</span><span class="enscript-comment">// the .journal files in case they moved (which can happen if you
</span><span class="enscript-comment">// run Norton SpeedDisk).  If we fail to find either file we just
</span><span class="enscript-comment">// disable journaling for this volume and return.  We turn off the
</span><span class="enscript-comment">// journaling bit in the vcb and assume it will get written to disk
</span><span class="enscript-comment">// later (if it doesn't on the next mount we'd do the same thing
</span><span class="enscript-comment">// again which is harmless).  If we disable journaling we don't
</span><span class="enscript-comment">// return an error so that the volume is still mountable.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If the info we find for the .journal_info_block and .journal files
</span><span class="enscript-comment">// isn't what we had stored, we re-set our cached info and proceed
</span><span class="enscript-comment">// with opening the journal normally.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_late_journal_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp, <span class="enscript-type">void</span> *_args)
{
	JournalInfoBlock *jibp;
	<span class="enscript-type">struct</span> buf       *jinfo_bp;
	<span class="enscript-type">int</span>               sectors_per_fsblock, arg_flags=0, arg_tbufsz=0;
	<span class="enscript-type">int</span>               retval, write_jibp = 0, recreate_journal = 0;
	<span class="enscript-type">struct</span> vnode     *devvp;
	<span class="enscript-type">struct</span> cat_attr   jib_attr, jattr;
	<span class="enscript-type">struct</span> cat_fork   jib_fork, jfork;
	ExtendedVCB      *vcb;
	u_int32_t            fid;
	<span class="enscript-type">struct</span> hfs_mount_args *args = _args;
	u_int32_t	  jib_flags;
	u_int64_t	  jib_offset;
	u_int64_t	  jib_size;
	
	devvp = hfsmp-&gt;hfs_devvp;
	vcb = HFSTOVCB(hfsmp);
	
	<span class="enscript-keyword">if</span> (args != NULL &amp;&amp; (args-&gt;flags &amp; HFSFSMNT_EXTENDED_ARGS)) {
		<span class="enscript-keyword">if</span> (args-&gt;journal_disable) {
			<span class="enscript-keyword">return</span> 0;
		}

		arg_flags  = args-&gt;journal_flags;
		arg_tbufsz = args-&gt;journal_tbuffer_size;
	}

	fid = GetFileInfo(vcb, kRootDirID, <span class="enscript-string">&quot;.journal_info_block&quot;</span>, &amp;jib_attr, &amp;jib_fork);
	<span class="enscript-keyword">if</span> (fid == 0 || jib_fork.cf_extents[0].startBlock == 0 || jib_fork.cf_size == 0) {
		printf(<span class="enscript-string">&quot;hfs: can't find the .journal_info_block! disabling journaling (start: %d).\n&quot;</span>,
			   jib_fork.cf_extents[0].startBlock);
		vcb-&gt;vcbAtrb &amp;= ~kHFSVolumeJournaledMask;
		<span class="enscript-keyword">return</span> 0;
	}
	hfsmp-&gt;hfs_jnlinfoblkid = fid;

	<span class="enscript-comment">// make sure the journal_info_block begins where we think it should.
</span>	<span class="enscript-keyword">if</span> (SWAP_BE32(vhp-&gt;journalInfoBlock) != jib_fork.cf_extents[0].startBlock) {
		printf(<span class="enscript-string">&quot;hfs: The journal_info_block moved (was: %d; is: %d).  Fixing up\n&quot;</span>,
			   SWAP_BE32(vhp-&gt;journalInfoBlock), jib_fork.cf_extents[0].startBlock);

		vcb-&gt;vcbJinfoBlock    = jib_fork.cf_extents[0].startBlock;
		vhp-&gt;journalInfoBlock = SWAP_BE32(jib_fork.cf_extents[0].startBlock);
		recreate_journal = 1;
	}


	sectors_per_fsblock = SWAP_BE32(vhp-&gt;blockSize) / hfsmp-&gt;hfs_logical_block_size;
	jinfo_bp = NULL;
	retval = (<span class="enscript-type">int</span>)buf_meta_bread(devvp,
						(vcb-&gt;hfsPlusIOPosOffset / hfsmp-&gt;hfs_logical_block_size + 
						((u_int64_t)SWAP_BE32(vhp-&gt;journalInfoBlock)*sectors_per_fsblock)),
						hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;jinfo_bp);
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (jinfo_bp) {
			buf_brelse(jinfo_bp);
		}
		printf(<span class="enscript-string">&quot;hfs: can't read journal info block. disabling journaling.\n&quot;</span>);
		vcb-&gt;vcbAtrb &amp;= ~kHFSVolumeJournaledMask;
		<span class="enscript-keyword">return</span> 0;
	}

	jibp = (JournalInfoBlock *)buf_dataptr(jinfo_bp);
	jib_flags  = SWAP_BE32(jibp-&gt;flags);
	jib_offset = SWAP_BE64(jibp-&gt;offset);
	jib_size   = SWAP_BE64(jibp-&gt;size);

	fid = GetFileInfo(vcb, kRootDirID, <span class="enscript-string">&quot;.journal&quot;</span>, &amp;jattr, &amp;jfork);
	<span class="enscript-keyword">if</span> (fid == 0 || jfork.cf_extents[0].startBlock == 0 || jfork.cf_size == 0) {
		printf(<span class="enscript-string">&quot;hfs: can't find the journal file! disabling journaling (start: %d)\n&quot;</span>,
			   jfork.cf_extents[0].startBlock);
		buf_brelse(jinfo_bp);
		vcb-&gt;vcbAtrb &amp;= ~kHFSVolumeJournaledMask;
		<span class="enscript-keyword">return</span> 0;
	}
	hfsmp-&gt;hfs_jnlfileid = fid;

	<span class="enscript-comment">// make sure the journal file begins where we think it should.
</span>	<span class="enscript-keyword">if</span> ((jib_flags &amp; kJIJournalInFSMask) &amp;&amp; (jib_offset / (u_int64_t)vcb-&gt;blockSize) != jfork.cf_extents[0].startBlock) {
		printf(<span class="enscript-string">&quot;hfs: The journal file moved (was: %lld; is: %d).  Fixing up\n&quot;</span>,
			   (jib_offset / (u_int64_t)vcb-&gt;blockSize), jfork.cf_extents[0].startBlock);

		jib_offset = (u_int64_t)jfork.cf_extents[0].startBlock * (u_int64_t)vcb-&gt;blockSize;
		write_jibp   = 1;
		recreate_journal = 1;
	}

	<span class="enscript-comment">// check the size of the journal file.
</span>	<span class="enscript-keyword">if</span> (jib_size != (u_int64_t)jfork.cf_extents[0].blockCount*vcb-&gt;blockSize) {
		printf(<span class="enscript-string">&quot;hfs: The journal file changed size! (was %lld; is %lld).  Fixing up.\n&quot;</span>,
			   jib_size, (u_int64_t)jfork.cf_extents[0].blockCount*vcb-&gt;blockSize);
		
		jib_size = (u_int64_t)jfork.cf_extents[0].blockCount * vcb-&gt;blockSize;
		write_jibp = 1;
		recreate_journal = 1;
	}
	
	<span class="enscript-keyword">if</span> (jib_flags &amp; kJIJournalInFSMask) {
		hfsmp-&gt;jvp = hfsmp-&gt;hfs_devvp;
		jib_offset += (off_t)vcb-&gt;hfsPlusIOPosOffset;
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dev_name;
	    <span class="enscript-type">int</span> need_init = 0;
	
	    dev_name = vnode_getname_printable(devvp);

            <span class="enscript-comment">// since the journal is empty, just use any available external journal
</span>	    *((<span class="enscript-type">char</span> *)&amp;jibp-&gt;ext_jnl_uuid[0]) = <span class="enscript-string">'\0'</span>;

	    <span class="enscript-comment">// this fills in the uuid of the device we actually get
</span>	    hfsmp-&gt;jvp = open_journal_dev(dev_name,
					  !(jib_flags &amp; kJIJournalNeedInitMask),
					  (<span class="enscript-type">char</span> *)&amp;jibp-&gt;ext_jnl_uuid[0],
					  (<span class="enscript-type">char</span> *)&amp;jibp-&gt;machine_serial_num[0],
					  jib_size,
					  hfsmp-&gt;hfs_logical_block_size,
					  &amp;need_init);
	    <span class="enscript-keyword">if</span> (hfsmp-&gt;jvp == NULL) {
		    buf_brelse(jinfo_bp);
		    vnode_putname_printable(dev_name);
		    <span class="enscript-keyword">return</span> EROFS;
	    } <span class="enscript-keyword">else</span> {
		    <span class="enscript-keyword">if</span> (IOBSDGetPlatformSerialNumber(&amp;jibp-&gt;machine_serial_num[0], <span class="enscript-keyword">sizeof</span>(jibp-&gt;machine_serial_num)) != KERN_SUCCESS) {
			    strlcpy(&amp;jibp-&gt;machine_serial_num[0], <span class="enscript-string">&quot;unknown-machine-serial-num&quot;</span>, <span class="enscript-keyword">sizeof</span>(jibp-&gt;machine_serial_num));
		    }
	    }
	    jib_offset = 0;
	    recreate_journal = 1;
	    write_jibp = 1;
	    <span class="enscript-keyword">if</span> (need_init) {
		    jib_flags |= kJIJournalNeedInitMask;
	    }
	    vnode_putname_printable(dev_name);
	}

	<span class="enscript-comment">// save this off for the hack-y check in hfs_remove()
</span>	hfsmp-&gt;jnl_start = jib_offset / SWAP_BE32(vhp-&gt;blockSize);
	hfsmp-&gt;jnl_size  = jib_size;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) &amp;&amp; (vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_ROOTFS) == 0) {
	    <span class="enscript-comment">// if the file system is read-only, check if the journal is empty.
</span>	    <span class="enscript-comment">// if it is, then we can allow the mount.  otherwise we have to
</span>	    <span class="enscript-comment">// return failure.
</span>	    retval = journal_is_clean(hfsmp-&gt;jvp,
				      jib_offset,
				      jib_size,
				      devvp,
		                      hfsmp-&gt;hfs_logical_block_size);

	    hfsmp-&gt;jnl = NULL;

	    buf_brelse(jinfo_bp);

	    <span class="enscript-keyword">if</span> (retval) {
		    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = vnode_getname_printable(devvp);
		    printf(<span class="enscript-string">&quot;hfs: late journal init: volume on %s is read-only and journal is dirty.  Can not mount volume.\n&quot;</span>, 
		    name);
		    vnode_putname_printable(name);
	    }

	    <span class="enscript-keyword">return</span> retval;
	}

	<span class="enscript-keyword">if</span> ((jib_flags &amp; kJIJournalNeedInitMask) || recreate_journal) {
		printf(<span class="enscript-string">&quot;hfs: Initializing the journal (joffset 0x%llx sz 0x%llx)...\n&quot;</span>,
			   jib_offset, jib_size);
		hfsmp-&gt;jnl = journal_create(hfsmp-&gt;jvp,
									jib_offset,
									jib_size,
									devvp,
									hfsmp-&gt;hfs_logical_block_size,
									arg_flags,
									arg_tbufsz,
									hfs_sync_metadata, hfsmp-&gt;hfs_mp,
									hfsmp-&gt;hfs_mp);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
			journal_trim_set_callback(hfsmp-&gt;jnl, hfs_trim_callback, hfsmp);

		<span class="enscript-comment">// no need to start a transaction here... if this were to fail
</span>		<span class="enscript-comment">// we'd just re-init it on the next mount.
</span>		jib_flags &amp;= ~kJIJournalNeedInitMask;
		write_jibp   = 1;

	} <span class="enscript-keyword">else</span> { 
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// if we weren't the last person to mount this volume
</span>		<span class="enscript-comment">// then we need to throw away the journal because it
</span>		<span class="enscript-comment">// is likely that someone else mucked with the disk.
</span>		<span class="enscript-comment">// if the journal is empty this is no big deal.  if the
</span>		<span class="enscript-comment">// disk is dirty this prevents us from replaying the
</span>		<span class="enscript-comment">// journal over top of changes that someone else made.
</span>		<span class="enscript-comment">//
</span>		arg_flags |= JOURNAL_RESET;
		
		<span class="enscript-comment">//printf(&quot;hfs: Opening the journal (joffset 0x%llx sz 0x%llx vhp_blksize %d)...\n&quot;,
</span>		<span class="enscript-comment">//	   jib_offset,
</span>		<span class="enscript-comment">//	   jib_size, SWAP_BE32(vhp-&gt;blockSize));
</span>				
		hfsmp-&gt;jnl = journal_open(hfsmp-&gt;jvp,
								  jib_offset,
								  jib_size,
								  devvp,
								  hfsmp-&gt;hfs_logical_block_size,
								  arg_flags,
								  arg_tbufsz,
								  hfs_sync_metadata, hfsmp-&gt;hfs_mp,
								  hfsmp-&gt;hfs_mp);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
			journal_trim_set_callback(hfsmp-&gt;jnl, hfs_trim_callback, hfsmp);
	}
			

	<span class="enscript-keyword">if</span> (write_jibp) {
		jibp-&gt;flags  = SWAP_BE32(jib_flags);
		jibp-&gt;offset = SWAP_BE64(jib_offset);
		jibp-&gt;size   = SWAP_BE64(jib_size);

		buf_bwrite(jinfo_bp);
	} <span class="enscript-keyword">else</span> {
		buf_brelse(jinfo_bp);
	} 
	jinfo_bp = NULL;
	jibp     = NULL;

	<span class="enscript-comment">// if we expected the journal to be there and we couldn't
</span>	<span class="enscript-comment">// create it or open it then we have to bail out.
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		printf(<span class="enscript-string">&quot;hfs: late jnl init: failed to open/create the journal (retval %d).\n&quot;</span>, retval);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Calculate the allocation zone for metadata.
 *
 * This zone includes the following:
 *	Allocation Bitmap file
 *	Overflow Extents file
 *	Journal file
 *	Quota files
 *	Clustered Hot files
 *	Catalog file
 *
 *                          METADATA ALLOCATION ZONE
 * ____________________________________________________________________________
 * |    |    |     |               |                              |           |
 * | BM | JF | OEF |    CATALOG    |---&gt;                          | HOT FILES |
 * |____|____|_____|_______________|______________________________|___________|
 *
 * &lt;------------------------------- N * 128 MB -------------------------------&gt;
 *
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GIGABYTE</span>  (u_int64_t)(1024*1024*1024)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OVERFLOW_DEFAULT_SIZE</span> (4*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OVERFLOW_MAXIMUM_SIZE</span> (128*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JOURNAL_DEFAULT_SIZE</span>  (8*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JOURNAL_MAXIMUM_SIZE</span>  (512*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HOTBAND_MINIMUM_SIZE</span>  (10*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HOTBAND_MAXIMUM_SIZE</span>  (512*1024*1024)

<span class="enscript-comment">/* Initialize the metadata zone.
 *
 * If the size of  the volume is less than the minimum size for
 * metadata zone, metadata zone is disabled.
 *
 * If disable is true, disable metadata zone unconditionally.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_metadatazone_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> disable)
{
	ExtendedVCB  *vcb;
	u_int64_t  fs_size;
	u_int64_t  zonesize;
	u_int64_t  temp;
	u_int64_t  filesize;
	u_int32_t  blk;
	<span class="enscript-type">int</span>  items, really_do_it=1;

	vcb = HFSTOVCB(hfsmp);
	fs_size = (u_int64_t)vcb-&gt;blockSize * (u_int64_t)vcb-&gt;allocLimit;

	<span class="enscript-comment">/*
	 * For volumes less than 10 GB, don't bother.
	 */</span>
	<span class="enscript-keyword">if</span> (fs_size &lt; ((u_int64_t)10 * GIGABYTE)) {
		really_do_it = 0;
	}
	
	<span class="enscript-comment">/*
	 * Skip non-journaled volumes as well.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		really_do_it = 0;
	}

	<span class="enscript-comment">/* If caller wants to disable metadata zone, do it */</span>
	<span class="enscript-keyword">if</span> (disable == true) {
		really_do_it = 0;
	}

	<span class="enscript-comment">/*
	 * Start with space for the boot blocks and Volume Header.
	 * 1536 = byte offset from start of volume to end of volume header:
	 * 1024 bytes is the offset from the start of the volume to the
	 * start of the volume header (defined by the volume format)
	 * + 512 bytes (the size of the volume header).
	 */</span>
	zonesize = roundup(1536, hfsmp-&gt;blockSize);
	
	<span class="enscript-comment">/*
	 * Add the on-disk size of allocation bitmap.
	 */</span>
	zonesize += hfsmp-&gt;hfs_allocation_cp-&gt;c_datafork-&gt;ff_blocks * hfsmp-&gt;blockSize;
	
	<span class="enscript-comment">/* 
	 * Add space for the Journal Info Block and Journal (if they're in
	 * this file system).
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; hfsmp-&gt;jvp == hfsmp-&gt;hfs_devvp) {
		zonesize += hfsmp-&gt;blockSize + hfsmp-&gt;jnl_size;
	}
	
	<span class="enscript-comment">/*
	 * Add the existing size of the Extents Overflow B-tree.
	 * (It rarely grows, so don't bother reserving additional room for it.)
	 */</span>
	zonesize += hfs_blk_to_bytes(hfsmp-&gt;hfs_extents_cp-&gt;c_datafork-&gt;ff_blocks, hfsmp-&gt;blockSize);
	
	<span class="enscript-comment">/*
	 * If there is an Attributes B-tree, leave room for 11 clumps worth.
	 * newfs_hfs allocates one clump, and leaves a gap of 10 clumps.
	 * When installing a full OS install onto a 20GB volume, we use
	 * 7 to 8 clumps worth of space (depending on packages), so that leaves
	 * us with another 3 or 4 clumps worth before we need another extent.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_cp) {
		zonesize += 11 * hfsmp-&gt;hfs_attribute_cp-&gt;c_datafork-&gt;ff_clumpsize;
	}
	
	<span class="enscript-comment">/*
	 * Leave room for 11 clumps of the Catalog B-tree.
	 * Again, newfs_hfs allocates one clump plus a gap of 10 clumps.
	 * When installing a full OS install onto a 20GB volume, we use
	 * 7 to 8 clumps worth of space (depending on packages), so that leaves
	 * us with another 3 or 4 clumps worth before we need another extent.
	 */</span>
	zonesize += 11 * hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork-&gt;ff_clumpsize;
	
	<span class="enscript-comment">/*
	 * Add space for hot file region.
	 *
	 * ...for now, use 5 MB per 1 GB (0.5 %)
	 */</span>
	filesize = (fs_size / 1024) * 5;
	<span class="enscript-keyword">if</span> (filesize &gt; HOTBAND_MAXIMUM_SIZE)
		filesize = HOTBAND_MAXIMUM_SIZE;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filesize &lt; HOTBAND_MINIMUM_SIZE)
		filesize = HOTBAND_MINIMUM_SIZE;
	<span class="enscript-comment">/*
	 * Calculate user quota file requirements.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS) {
		items = QF_USERS_PER_GB * (fs_size / GIGABYTE);
		<span class="enscript-keyword">if</span> (items &lt; QF_MIN_USERS)
			items = QF_MIN_USERS;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (items &gt; QF_MAX_USERS)
			items = QF_MAX_USERS;
		<span class="enscript-keyword">if</span> (!powerof2(items)) {
			<span class="enscript-type">int</span> x = items;
			items = 4;
			<span class="enscript-keyword">while</span> (x&gt;&gt;1 != 1) {
				x = x &gt;&gt; 1;
				items = items &lt;&lt; 1;
			}
		}
		filesize += (items + 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dqblk);
		<span class="enscript-comment">/*
		 * Calculate group quota file requirements.
		 *
		 */</span>
		items = QF_GROUPS_PER_GB * (fs_size / GIGABYTE);
		<span class="enscript-keyword">if</span> (items &lt; QF_MIN_GROUPS)
			items = QF_MIN_GROUPS;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (items &gt; QF_MAX_GROUPS)
			items = QF_MAX_GROUPS;
		<span class="enscript-keyword">if</span> (!powerof2(items)) {
			<span class="enscript-type">int</span> x = items;
			items = 4;
			<span class="enscript-keyword">while</span> (x&gt;&gt;1 != 1) {
				x = x &gt;&gt; 1;
				items = items &lt;&lt; 1;
			}
		}
		filesize += (items + 1) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dqblk);
	}
	zonesize += filesize;

	<span class="enscript-comment">/*
	 * Round up entire zone to a bitmap block's worth.
	 * The extra space goes to the catalog file and hot file area.
	 */</span>
	temp = zonesize;
	zonesize = roundup(zonesize, (u_int64_t)vcb-&gt;vcbVBMIOSize * 8 * vcb-&gt;blockSize);
	hfsmp-&gt;hfs_min_alloc_start = zonesize / vcb-&gt;blockSize;
	<span class="enscript-comment">/*
	 * If doing the round up for hfs_min_alloc_start would push us past
	 * allocLimit, then just reset it back to 0.  Though using a value 
	 * bigger than allocLimit would not cause damage in the block allocator
	 * code, this value could get stored in the volume header and make it out 
	 * to disk, making the volume header technically corrupt.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_min_alloc_start &gt;= hfsmp-&gt;allocLimit) {
		hfsmp-&gt;hfs_min_alloc_start = 0;
	}

	<span class="enscript-keyword">if</span> (really_do_it == 0) {
		<span class="enscript-comment">/* If metadata zone needs to be disabled because the 
		 * volume was truncated, clear the bit and zero out 
		 * the values that are no longer needed.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) {
			<span class="enscript-comment">/* Disable metadata zone */</span>
			hfsmp-&gt;hfs_flags &amp;= ~HFS_METADATA_ZONE;
			
			<span class="enscript-comment">/* Zero out mount point values that are not required */</span>
			hfsmp-&gt;hfs_catalog_maxblks = 0;
			hfsmp-&gt;hfs_hotfile_maxblks = 0;
			hfsmp-&gt;hfs_hotfile_start = 0;
			hfsmp-&gt;hfs_hotfile_end = 0;
			hfsmp-&gt;hfs_hotfile_freeblks = 0;
			hfsmp-&gt;hfs_metazone_start = 0;
			hfsmp-&gt;hfs_metazone_end = 0;
		}
		
		<span class="enscript-keyword">return</span>;
	}
	
	temp = zonesize - temp;  <span class="enscript-comment">/* temp has extra space */</span>
	filesize += temp / 3;
	hfsmp-&gt;hfs_catalog_maxblks += (temp - (temp / 3)) / vcb-&gt;blockSize;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		hfsmp-&gt;hfs_hotfile_maxblks = (uint32_t) (hfsmp-&gt;hfs_cs_hotfile_size / HFSTOVCB(hfsmp)-&gt;blockSize);
	} <span class="enscript-keyword">else</span> {
		hfsmp-&gt;hfs_hotfile_maxblks = filesize / vcb-&gt;blockSize;
	}

	<span class="enscript-comment">/* Convert to allocation blocks. */</span>
	blk = zonesize / vcb-&gt;blockSize;

	<span class="enscript-comment">/* The default metadata zone location is at the start of volume. */</span>
	hfsmp-&gt;hfs_metazone_start = 1;
	hfsmp-&gt;hfs_metazone_end = blk - 1;
	
	<span class="enscript-comment">/* The default hotfile area is at the end of the zone. */</span>
	<span class="enscript-keyword">if</span> (vfs_flags(HFSTOVFS(hfsmp)) &amp; MNT_ROOTFS) {
		hfsmp-&gt;hfs_hotfile_start = blk - (filesize / vcb-&gt;blockSize);
		hfsmp-&gt;hfs_hotfile_end = hfsmp-&gt;hfs_metazone_end;
		hfsmp-&gt;hfs_hotfile_freeblks = hfs_hotfile_freeblocks(hfsmp);
	}
	<span class="enscript-keyword">else</span> {
		hfsmp-&gt;hfs_hotfile_start = 0;
		hfsmp-&gt;hfs_hotfile_end = 0;
		hfsmp-&gt;hfs_hotfile_freeblks = 0;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	printf(<span class="enscript-string">&quot;hfs:%s: metadata zone is %d to %d\n&quot;</span>, hfsmp-&gt;vcbVN, hfsmp-&gt;hfs_metazone_start, hfsmp-&gt;hfs_metazone_end);
	printf(<span class="enscript-string">&quot;hfs:%s: hot file band is %d to %d\n&quot;</span>, hfsmp-&gt;vcbVN, hfsmp-&gt;hfs_hotfile_start, hfsmp-&gt;hfs_hotfile_end);
	printf(<span class="enscript-string">&quot;hfs:%s: hot file band free blocks = %d\n&quot;</span>, hfsmp-&gt;vcbVN, hfsmp-&gt;hfs_hotfile_freeblks);
#<span class="enscript-reference">endif</span>

	hfsmp-&gt;hfs_flags |= HFS_METADATA_ZONE;
}


<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">hfs_hotfile_freeblocks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	ExtendedVCB  *vcb = HFSTOVCB(hfsmp);
	<span class="enscript-type">int</span>  lockflags;
	<span class="enscript-type">int</span>  freeblocks;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// This is only used at initialization time and on an ssd
</span>		<span class="enscript-comment">// we'll get the real info from the hotfile btree user
</span>		<span class="enscript-comment">// info
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">return</span> 0;
	}

	lockflags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	freeblocks = MetaZoneFreeBlocks(vcb);
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-comment">/* Minus Extents overflow file reserve. */</span>
	<span class="enscript-keyword">if</span> ((uint32_t)hfsmp-&gt;hfs_overflow_maxblks &gt;= VTOF(hfsmp-&gt;hfs_extents_vp)-&gt;ff_blocks) {
		freeblocks -= hfsmp-&gt;hfs_overflow_maxblks - VTOF(hfsmp-&gt;hfs_extents_vp)-&gt;ff_blocks;
	}

	<span class="enscript-comment">/* Minus catalog file reserve. */</span>
	<span class="enscript-keyword">if</span> ((uint32_t)hfsmp-&gt;hfs_catalog_maxblks &gt;= VTOF(hfsmp-&gt;hfs_catalog_vp)-&gt;ff_blocks) {
		freeblocks -= hfsmp-&gt;hfs_catalog_maxblks - VTOF(hfsmp-&gt;hfs_catalog_vp)-&gt;ff_blocks;
	}
	
	<span class="enscript-keyword">if</span> (freeblocks &lt; 0)
		freeblocks = 0;

	<span class="enscript-comment">// printf(&quot;hfs: hotfile_freeblocks: MIN(%d, %d) = %d\n&quot;, freeblocks, hfsmp-&gt;hfs_hotfile_maxblks, MIN(freeblocks, hfsmp-&gt;hfs_hotfile_maxblks));
</span>	<span class="enscript-keyword">return</span> MIN(freeblocks, hfsmp-&gt;hfs_hotfile_maxblks);
}

<span class="enscript-comment">/*
 * Determine if a file is a &quot;virtual&quot; metadata file.
 * This includes journal and quota files.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_virtualmetafile</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * filename;


	<span class="enscript-keyword">if</span> (cp-&gt;c_parentcnid != kHFSRootFolderID)
		<span class="enscript-keyword">return</span> (0);

	filename = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr;
	<span class="enscript-keyword">if</span> (filename == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((strncmp(filename, <span class="enscript-string">&quot;.journal&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;.journal&quot;</span>)) == 0) ||
	    (strncmp(filename, <span class="enscript-string">&quot;.journal_info_block&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;.journal_info_block&quot;</span>)) == 0) ||
	    (strncmp(filename, <span class="enscript-string">&quot;.quota.user&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;.quota.user&quot;</span>)) == 0) ||
	    (strncmp(filename, <span class="enscript-string">&quot;.quota.group&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;.quota.group&quot;</span>)) == 0) ||
	    (strncmp(filename, <span class="enscript-string">&quot;.hotfiles.btree&quot;</span>, <span class="enscript-keyword">sizeof</span>(<span class="enscript-string">&quot;.hotfiles.btree&quot;</span>)) == 0))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_lock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    hfs_lock_mount(hfsmp);
}

__private_extern__ 
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_unlock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    hfs_unlock_mount(hfsmp);
}

__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_wait</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    msleep(&amp;hfsmp-&gt;hfs_sync_incomplete, &amp;hfsmp-&gt;hfs_mutex, PWAIT, 
           <span class="enscript-string">&quot;hfs_syncer_wait&quot;</span>, NULL);
}

__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_wakeup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    wakeup(&amp;hfsmp-&gt;hfs_sync_incomplete);
}

__private_extern__
uint64_t <span class="enscript-function-name">hfs_usecs_to_deadline</span>(uint64_t usecs)
{
    uint64_t deadline;
    clock_interval_to_deadline(usecs, NSEC_PER_USEC, &amp;deadline);
    <span class="enscript-keyword">return</span> deadline;
}

__private_extern__
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_queue</span>(thread_call_t syncer)
{
    <span class="enscript-keyword">if</span> (thread_call_enter_delayed_with_leeway(syncer,
                                              NULL,
                                              hfs_usecs_to_deadline(HFS_META_DELAY),
                                              0,
                                              THREAD_CALL_DELAY_SYS_BACKGROUND)) {
		printf(<span class="enscript-string">&quot;hfs: syncer already scheduled!\n&quot;</span>);
    }
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Fire off a timed callback to sync the disk if the
</span><span class="enscript-comment">// volume is on ejectable media.
</span><span class="enscript-comment">//
</span> __private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_sync_ejectable</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    <span class="enscript-comment">// If we don't have a syncer or we get called by the syncer, just return
</span>    <span class="enscript-keyword">if</span> (!hfsmp-&gt;hfs_syncer || current_thread() == hfsmp-&gt;hfs_syncer_thread)
        <span class="enscript-keyword">return</span>;

    hfs_syncer_lock(hfsmp);

    <span class="enscript-keyword">if</span> (!timerisset(&amp;hfsmp-&gt;hfs_sync_req_oldest))
        microuptime(&amp;hfsmp-&gt;hfs_sync_req_oldest);

    <span class="enscript-comment">/* If hfs_unmount is running, it will set hfs_syncer to NULL. Also we
       don't want to queue again if there is a sync outstanding. */</span>
    <span class="enscript-keyword">if</span> (!hfsmp-&gt;hfs_syncer || hfsmp-&gt;hfs_sync_incomplete) {
        hfs_syncer_unlock(hfsmp);
        <span class="enscript-keyword">return</span>;
    }

    hfsmp-&gt;hfs_sync_incomplete = TRUE;

    thread_call_t syncer = hfsmp-&gt;hfs_syncer;

    hfs_syncer_unlock(hfsmp);

    hfs_syncer_queue(syncer);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_start_transaction</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">int</span> ret = 0, unlock_on_err = 0;
	thread_t thread = current_thread();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
	<span class="enscript-comment">/*
	 * You cannot start a transaction while holding a system
	 * file lock. (unless the transaction is nested.)
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; journal_owner(hfsmp-&gt;jnl) != thread) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_cp &amp;&amp; hfsmp-&gt;hfs_catalog_cp-&gt;c_lockowner == thread) {
			panic(<span class="enscript-string">&quot;hfs_start_transaction: bad lock order (cat before jnl)\n&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_cp &amp;&amp; hfsmp-&gt;hfs_attribute_cp-&gt;c_lockowner == thread) {
			panic(<span class="enscript-string">&quot;hfs_start_transaction: bad lock order (attr before jnl)\n&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_cp &amp;&amp; hfsmp-&gt;hfs_extents_cp-&gt;c_lockowner == thread) {
			panic(<span class="enscript-string">&quot;hfs_start_transaction: bad lock order (ext before jnl)\n&quot;</span>);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>

<span class="enscript-reference">again</span>:

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		<span class="enscript-keyword">if</span> (journal_owner(hfsmp-&gt;jnl) != thread) {
			<span class="enscript-comment">/*
			 * The global lock should be held shared if journal is 
			 * active to prevent disabling.  If we're not the owner 
			 * of the journal lock, verify that we're not already
			 * holding the global lock exclusive before moving on.	 
			 */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_global_lockowner == thread) {
				ret = EBUSY;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			hfs_lock_global (hfsmp, HFS_SHARED_LOCK);

			<span class="enscript-comment">// Things could have changed
</span>			<span class="enscript-keyword">if</span> (!hfsmp-&gt;jnl) {
				hfs_unlock_global(hfsmp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}

			OSAddAtomic(1, (SInt32 *)&amp;hfsmp-&gt;hfs_active_threads);
			unlock_on_err = 1;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// No journal
</span>		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_global_lockowner != thread) {
			hfs_lock_global(hfsmp, HFS_EXCLUSIVE_LOCK);

			<span class="enscript-comment">// Things could have changed
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				hfs_unlock_global(hfsmp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}

			OSAddAtomic(1, (SInt32 *)&amp;hfsmp-&gt;hfs_active_threads);
			unlock_on_err = 1;
		}
	}

	<span class="enscript-comment">/* If a downgrade to read-only mount is in progress, no other
	 * thread than the downgrade thread is allowed to modify 
	 * the file system.
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_RDONLY_DOWNGRADE) &amp;&amp; 
	    hfsmp-&gt;hfs_downgrading_thread != thread) {
		ret = EROFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		ret = journal_start_transaction(hfsmp-&gt;jnl);
	} <span class="enscript-keyword">else</span> {
		ret = 0;
	}

	<span class="enscript-keyword">if</span> (ret == 0)
		++hfsmp-&gt;hfs_transaction_nesting;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (ret != 0 &amp;&amp; unlock_on_err) {
		hfs_unlock_global (hfsmp);
		OSAddAtomic(-1, (SInt32 *)&amp;hfsmp-&gt;hfs_active_threads);
	}

    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_end_transaction</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
    <span class="enscript-type">int</span> ret;

	assert(!hfsmp-&gt;jnl || journal_owner(hfsmp-&gt;jnl) == current_thread());
	assert(hfsmp-&gt;hfs_transaction_nesting &gt; 0);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; hfsmp-&gt;hfs_transaction_nesting == 1)
		hfs_flushvolumeheader(hfsmp, HFS_FVH_FLUSH_IF_DIRTY);

	bool need_unlock = !--hfsmp-&gt;hfs_transaction_nesting;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		ret = journal_end_transaction(hfsmp-&gt;jnl);
	} <span class="enscript-keyword">else</span> {
		ret = 0;
	}

	<span class="enscript-keyword">if</span> (need_unlock) {
		OSAddAtomic(-1, (SInt32 *)&amp;hfsmp-&gt;hfs_active_threads);
		hfs_unlock_global (hfsmp);
		hfs_sync_ejectable(hfsmp);
	}

    <span class="enscript-keyword">return</span> ret;
}


<span class="enscript-type">void</span> 
<span class="enscript-function-name">hfs_journal_lock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp) 
{
	<span class="enscript-comment">/* Only peek at hfsmp-&gt;jnl while holding the global lock */</span>
	hfs_lock_global (hfsmp, HFS_SHARED_LOCK);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_lock(hfsmp-&gt;jnl);
	}
	hfs_unlock_global (hfsmp);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">hfs_journal_unlock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp) 
{
	<span class="enscript-comment">/* Only peek at hfsmp-&gt;jnl while holding the global lock */</span>
	hfs_lock_global (hfsmp, HFS_SHARED_LOCK);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_unlock(hfsmp-&gt;jnl);
	}
	hfs_unlock_global (hfsmp);
}

<span class="enscript-comment">/*
 * Flush the contents of the journal to the disk.
 *
 *  - HFS_FLUSH_JOURNAL
 *      Wait to write in-memory journal to the disk consistently.
 *      This means that the journal still contains uncommitted
 *      transactions and the file system metadata blocks in
 *      the journal transactions might be written asynchronously
 *      to the disk.  But there is no guarantee that they are
 *      written to the disk before returning to the caller.
 *      Note that this option is sufficient for file system
 *      data integrity as it guarantees consistent journal
 *      content on the disk.
 *
 *  - HFS_FLUSH_JOURNAL_META
 *      Wait to write in-memory journal to the disk
 *      consistently, and also wait to write all asynchronous
 *      metadata blocks to its corresponding locations
 *      consistently on the disk. This is overkill in normal
 *      scenarios but is useful whenever the metadata blocks
 *      are required to be consistent on-disk instead of
 *      just the journalbeing consistent; like before live
 *      verification and live volume resizing.  The update of the
 *      metadata doesn't include a barrier of track cache flush.
 *
 *  - HFS_FLUSH_FULL
 *      HFS_FLUSH_JOURNAL + force a track cache flush to media
 *
 *  - HFS_FLUSH_CACHE
 *      Force a track cache flush to media.
 *
 *  - HFS_FLUSH_BARRIER
 *      Barrier-only flush to ensure write order
 *
 */</span>
errno_t <span class="enscript-function-name">hfs_flush</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, hfs_flush_mode_t mode)
{
	errno_t error = 0;
	journal_flush_options_t options = 0;
	dk_synchronize_t sync_req = { .options = DK_SYNCHRONIZE_OPTION_BARRIER };

	<span class="enscript-keyword">switch</span> (mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_JOURNAL_META</span>:
			<span class="enscript-comment">// wait for journal, metadata blocks and previous async flush to finish
</span>			SET(options, JOURNAL_WAIT_FOR_IO);

			<span class="enscript-comment">// no break
</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_JOURNAL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_JOURNAL_BARRIER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_FULL</span>:

			<span class="enscript-keyword">if</span> (mode == HFS_FLUSH_JOURNAL_BARRIER &amp;&amp;
			    !(hfsmp-&gt;hfs_flags &amp; HFS_FEATURE_BARRIER))
				mode = HFS_FLUSH_FULL;

			<span class="enscript-keyword">if</span> (mode == HFS_FLUSH_FULL)
				SET(options, JOURNAL_FLUSH_FULL);

			<span class="enscript-comment">/* Only peek at hfsmp-&gt;jnl while holding the global lock */</span>
			hfs_lock_global (hfsmp, HFS_SHARED_LOCK);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
				error = journal_flush(hfsmp-&gt;jnl, options);

			hfs_unlock_global (hfsmp);

			<span class="enscript-comment">/*
			 * This may result in a double barrier as
			 * journal_flush may have issued a barrier itself
			 */</span>
			<span class="enscript-keyword">if</span> (mode == HFS_FLUSH_JOURNAL_BARRIER)
				error = VNOP_IOCTL(hfsmp-&gt;hfs_devvp,
				    DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_req,
				    FWRITE, vfs_context_kernel());

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_CACHE</span>:
			<span class="enscript-comment">// Do a full sync
</span>			sync_req.options = 0;

			<span class="enscript-comment">// no break
</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FLUSH_BARRIER</span>:
			<span class="enscript-comment">// If barrier only flush doesn't support, fall back to use full flush.
</span>			<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_FEATURE_BARRIER))
				sync_req.options = 0;

			error = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, DKIOCSYNCHRONIZE, (caddr_t)&amp;sync_req,
					   FWRITE, vfs_context_kernel());
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * hfs_erase_unused_nodes
 *
 * Check wheter a volume may suffer from unused Catalog B-tree nodes that
 * are not zeroed (due to &lt;rdar://problem/6947811&gt;).  If so, just write
 * zeroes to the unused nodes.
 *
 * How do we detect when a volume needs this repair?  We can't always be
 * certain.  If a volume was created after a certain date, then it may have
 * been created with the faulty newfs_hfs.  Since newfs_hfs only created one
 * clump, we can assume that if a Catalog B-tree is larger than its clump size,
 * that means that the entire first clump must have been written to, which means
 * there shouldn't be unused and unwritten nodes in that first clump, and this
 * repair is not needed.
 *
 * We have defined a bit in the Volume Header's attributes to indicate when the
 * unused nodes have been repaired.  A newer newfs_hfs will set this bit.
 * As will fsck_hfs when it repairs the unused nodes.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_erase_unused_nodes</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">int</span> result; 
	<span class="enscript-type">struct</span> filefork *catalog;
	<span class="enscript-type">int</span> lockflags;
	
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbAtrb &amp; kHFSUnusedNodeFixMask)
	{
		<span class="enscript-comment">/* This volume has already been checked and repaired. */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;localCreateDate &lt; kHFSUnusedNodesFixDate))
	{
		<span class="enscript-comment">/* This volume is too old to have had the problem. */</span>
		hfsmp-&gt;vcbAtrb |= kHFSUnusedNodeFixMask;
		<span class="enscript-keyword">return</span> 0;
	}

	catalog = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	<span class="enscript-keyword">if</span> (catalog-&gt;ff_size &gt; catalog-&gt;ff_clumpsize)
	{
		<span class="enscript-comment">/* The entire first clump must have been in use at some point. */</span>
		hfsmp-&gt;vcbAtrb |= kHFSUnusedNodeFixMask;
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/*
	 * If we get here, we need to zero out those unused nodes.
	 *
	 * We start a transaction and lock the catalog since we're going to be
	 * making on-disk changes.  But note that BTZeroUnusedNodes doens't actually
	 * do its writing via the journal, because that would be too much I/O
	 * to fit in a transaction, and it's a pain to break it up into multiple
	 * transactions.  (It behaves more like growing a B-tree would.)
	 */</span>
	printf(<span class="enscript-string">&quot;hfs_erase_unused_nodes: updating volume %s.\n&quot;</span>, hfsmp-&gt;vcbVN);
	result = hfs_start_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
	result = BTZeroUnusedNodes(catalog);
	vnode_waitforwrites(hfsmp-&gt;hfs_catalog_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_erase_unused_nodes&quot;</span>);
	hfs_systemfile_unlock(hfsmp, lockflags);
	hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (result == 0)
		hfsmp-&gt;vcbAtrb |= kHFSUnusedNodeFixMask;
	printf(<span class="enscript-string">&quot;hfs_erase_unused_nodes: done updating volume %s.\n&quot;</span>, hfsmp-&gt;vcbVN);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">extern</span> time_t snapshot_timestamp;

<span class="enscript-type">int</span>
<span class="enscript-function-name">check_for_tracked_file</span>(<span class="enscript-type">struct</span> vnode *vp, time_t ctime, uint64_t op_type, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span> snapshot_error = 0;
	
	<span class="enscript-keyword">if</span> (vp == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* Swap files are special; skip them */</span>
	<span class="enscript-keyword">if</span> (vnode_isswap(vp)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (ctime != 0 &amp;&amp; snapshot_timestamp != 0 &amp;&amp; (ctime &lt;= snapshot_timestamp || vnode_needssnapshots(vp))) {
		<span class="enscript-comment">// the change time is within this epoch
</span>		<span class="enscript-type">int</span> error;
		
		error = resolve_nspace_item_ext(vp, op_type | NAMESPACE_HANDLER_SNAPSHOT_EVENT, arg);
		<span class="enscript-keyword">if</span> (error == EDEADLK) {
			snapshot_error = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == EAGAIN) {
				printf(<span class="enscript-string">&quot;hfs: cow-snapshot: timed out waiting for namespace handler...\n&quot;</span>);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EINTR) {
				<span class="enscript-comment">// printf(&quot;hfs: cow-snapshot: got a signal while waiting for namespace handler...\n&quot;);
</span>				snapshot_error = EINTR;
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (snapshot_error) <span class="enscript-keyword">return</span> snapshot_error;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">check_for_dataless_file</span>(<span class="enscript-type">struct</span> vnode *vp, uint64_t op_type)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (vp == NULL || (VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED) == 0 || VTOCMP(vp) == NULL || VTOCMP(vp)-&gt;cmp_type != DATALESS_CMPFS_TYPE) {
		<span class="enscript-comment">// there's nothing to do, it's not dataless
</span>		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* Swap files are special; ignore them */</span>
	<span class="enscript-keyword">if</span> (vnode_isswap(vp)) {
		<span class="enscript-keyword">return</span> 0;	
	}

	<span class="enscript-comment">// printf(&quot;hfs: dataless: encountered a file with the dataless bit set! (vp %p)\n&quot;, vp);
</span>	error = resolve_nspace_item(vp, op_type | NAMESPACE_HANDLER_NSPACE_EVENT);
	<span class="enscript-keyword">if</span> (error == EDEADLK &amp;&amp; op_type == NAMESPACE_HANDLER_WRITE_OP) {
		error = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == EAGAIN) {
			printf(<span class="enscript-string">&quot;hfs: dataless: timed out waiting for namespace handler...\n&quot;</span>);
			<span class="enscript-comment">// XXXdbg - return the fabled ENOTPRESENT (i.e. EJUKEBOX)?
</span>			<span class="enscript-keyword">return</span> 0;				
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EINTR) {
			<span class="enscript-comment">// printf(&quot;hfs: dataless: got a signal while waiting for namespace handler...\n&quot;);
</span>			<span class="enscript-keyword">return</span> EINTR;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// if we're here, the dataless bit is still set on the file 
</span>		<span class="enscript-comment">// which means it didn't get handled.  we return an error
</span>		<span class="enscript-comment">// but it's presently ignored by all callers of this function.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// XXXdbg - EDATANOTPRESENT is what we really need...
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">return</span> EBADF;
	}				

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// NOTE: this function takes care of starting a transaction and
</span><span class="enscript-comment">//       acquiring the systemfile lock so that it can call
</span><span class="enscript-comment">//       cat_update().
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// NOTE: do NOT hold and cnode locks while calling this function
</span><span class="enscript-comment">//       to avoid deadlocks (because we take a lock on the root
</span><span class="enscript-comment">//       cnode)
</span><span class="enscript-comment">//
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_generate_document_id</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t *docid)
{
	<span class="enscript-type">struct</span> vnode *rvp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">int</span> error;
	
	error = VFS_ROOT(HFSTOVFS(hfsmp), &amp;rvp, vfs_context_kernel());
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	cp = VTOC(rvp);
	<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)) != 0) {
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-type">struct</span> FndrExtendedDirInfo *extinfo = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16));
	
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		<span class="enscript-keyword">return</span> error;
	}
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
					
	<span class="enscript-keyword">if</span> (extinfo-&gt;document_id == 0) {
		<span class="enscript-comment">// initialize this to start at 3 (one greater than the root-dir id)
</span>		extinfo-&gt;document_id = 3;
	}

	*docid = extinfo-&gt;document_id++;

	<span class="enscript-comment">// mark the root cnode dirty
</span>	cp-&gt;c_flag |= C_MODIFIED;
	hfs_update(cp-&gt;c_vp, 0);

	hfs_systemfile_unlock (hfsmp, lockflags);
	(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);
		
	(<span class="enscript-type">void</span>) hfs_unlock(cp);

	vnode_put(rvp);
	rvp = NULL;

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/* 
 * Return information about number of file system allocation blocks 
 * taken by metadata on a volume.  
 *  
 * This function populates struct hfsinfo_metadata with allocation blocks 
 * used by extents overflow btree, catalog btree, bitmap, attribute btree, 
 * journal file, and sum of all of the above.  
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_getinfo_metadata_blocks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> hfsinfo_metadata *hinfo)
{
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">int</span> ret_lockflags = 0;

	<span class="enscript-comment">/* Zero out the output buffer */</span>
	bzero(hinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfsinfo_metadata));

	<span class="enscript-comment">/* 
	 * Getting number of allocation blocks for all btrees 
	 * should be a quick operation, so we grab locks for 
	 * all of them at the same time
	 */</span>
	lockflags = SFL_CATALOG | SFL_EXTENTS | SFL_BITMAP | SFL_ATTRIBUTE;
	ret_lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
	<span class="enscript-comment">/* 
	 * Make sure that we were able to acquire all locks requested 
	 * to protect us against conditions like unmount in progress.
	 */</span>
	<span class="enscript-keyword">if</span> ((lockflags &amp; ret_lockflags) != lockflags) {
		<span class="enscript-comment">/* Release any locks that were acquired */</span>
		hfs_systemfile_unlock(hfsmp, ret_lockflags);
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">/* Get information about all the btrees */</span>
	hinfo-&gt;extents = hfsmp-&gt;hfs_extents_cp-&gt;c_datafork-&gt;ff_blocks;
	hinfo-&gt;catalog = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork-&gt;ff_blocks;
	hinfo-&gt;allocation = hfsmp-&gt;hfs_allocation_cp-&gt;c_datafork-&gt;ff_blocks;
	hinfo-&gt;attribute = hfsmp-&gt;hfs_attribute_cp-&gt;c_datafork-&gt;ff_blocks;

	<span class="enscript-comment">/* Done with btrees, give up the locks */</span>
	hfs_systemfile_unlock(hfsmp, ret_lockflags);

	<span class="enscript-comment">/* Get information about journal file */</span>
	hinfo-&gt;journal = howmany(hfsmp-&gt;jnl_size, hfsmp-&gt;blockSize);

	<span class="enscript-comment">/* Calculate total number of metadata blocks */</span>
	hinfo-&gt;total = hinfo-&gt;extents + hinfo-&gt;catalog + 
			hinfo-&gt;allocation + hinfo-&gt;attribute +
			hinfo-&gt;journal;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_freezewrite_callback</span>(<span class="enscript-type">struct</span> vnode *vp, __unused <span class="enscript-type">void</span> *cargs)
{
	vnode_waitforwrites(vp, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 8&quot;</span>);

	<span class="enscript-keyword">return</span> 0;
}

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_freeze</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-comment">// First make sure some other process isn't freezing
</span>	hfs_lock_mount(hfsmp);
	<span class="enscript-keyword">while</span> (hfsmp-&gt;hfs_freeze_state != HFS_THAWED) {
		<span class="enscript-keyword">if</span> (msleep(&amp;hfsmp-&gt;hfs_freeze_state, &amp;hfsmp-&gt;hfs_mutex,
				   PWAIT | PCATCH, <span class="enscript-string">&quot;hfs freeze 1&quot;</span>, NULL) == EINTR) {
			hfs_unlock_mount(hfsmp);
			<span class="enscript-keyword">return</span> EINTR;
		}
	}

	<span class="enscript-comment">// Stop new syncers from starting
</span>	hfsmp-&gt;hfs_freeze_state = HFS_WANT_TO_FREEZE;

	<span class="enscript-comment">// Now wait for all syncers to finish
</span>	<span class="enscript-keyword">while</span> (hfsmp-&gt;hfs_syncers) {
		<span class="enscript-keyword">if</span> (msleep(&amp;hfsmp-&gt;hfs_freeze_state, &amp;hfsmp-&gt;hfs_mutex,
			   PWAIT | PCATCH, <span class="enscript-string">&quot;hfs freeze 2&quot;</span>, NULL) == EINTR) {
			hfs_thaw_locked(hfsmp);
			hfs_unlock_mount(hfsmp);
			<span class="enscript-keyword">return</span> EINTR;				
		}
	}
	hfs_unlock_mount(hfsmp);

	<span class="enscript-comment">// flush things before we get started to try and prevent
</span>	<span class="enscript-comment">// dirty data from being paged out while we're frozen.
</span>	<span class="enscript-comment">// note: we can't do this once we're in the freezing state because
</span>	<span class="enscript-comment">// other threads will need to take the global lock
</span>	vnode_iterate(hfsmp-&gt;hfs_mp, 0, hfs_freezewrite_callback, NULL);

	<span class="enscript-comment">// Block everything in hfs_lock_global now
</span>	hfs_lock_mount(hfsmp);
	hfsmp-&gt;hfs_freeze_state = HFS_FREEZING;
	hfsmp-&gt;hfs_freezing_thread = current_thread();
	hfs_unlock_mount(hfsmp);

	<span class="enscript-comment">/* Take the exclusive lock to flush out anything else that
	   might have the global lock at the moment and also so we
	   can flush the journal. */</span>
	hfs_lock_global(hfsmp, HFS_EXCLUSIVE_LOCK);
	journal_flush(hfsmp-&gt;jnl, JOURNAL_WAIT_FOR_IO);
	hfs_unlock_global(hfsmp);

	<span class="enscript-comment">// don't need to iterate on all vnodes, we just need to
</span>	<span class="enscript-comment">// wait for writes to the system files and the device vnode
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Now that journal flush waits for all metadata blocks to 
</span>	<span class="enscript-comment">// be written out, waiting for btree writes is probably no
</span>	<span class="enscript-comment">// longer required.
</span>	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;extentsRefNum)
		vnode_waitforwrites(HFSTOVCB(hfsmp)-&gt;extentsRefNum, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 3&quot;</span>);
	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;catalogRefNum)
		vnode_waitforwrites(HFSTOVCB(hfsmp)-&gt;catalogRefNum, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 4&quot;</span>);
	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;allocationsRefNum)
		vnode_waitforwrites(HFSTOVCB(hfsmp)-&gt;allocationsRefNum, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 5&quot;</span>);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp)
		vnode_waitforwrites(hfsmp-&gt;hfs_attribute_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 6&quot;</span>);
	vnode_waitforwrites(hfsmp-&gt;hfs_devvp, 0, 0, 0, <span class="enscript-string">&quot;hfs freeze 7&quot;</span>);

	<span class="enscript-comment">// We're done, mark frozen
</span>	hfs_lock_mount(hfsmp);
	hfsmp-&gt;hfs_freeze_state  = HFS_FROZEN;
	hfsmp-&gt;hfs_freezing_proc = current_proc();
	hfs_unlock_mount(hfsmp);

	<span class="enscript-keyword">return</span> 0;
}

__private_extern__
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_thaw</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> proc *process)
{
	hfs_lock_mount(hfsmp);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_freeze_state != HFS_FROZEN) {
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (process &amp;&amp; hfsmp-&gt;hfs_freezing_proc != process) {
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> EPERM;
	}

	hfs_thaw_locked(hfsmp);

	hfs_unlock_mount(hfsmp);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_thaw_locked</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	hfsmp-&gt;hfs_freezing_proc = NULL;
	hfsmp-&gt;hfs_freeze_state = HFS_THAWED;

	wakeup(&amp;hfsmp-&gt;hfs_freeze_state);
}
</pre>
<hr />
</body></html>