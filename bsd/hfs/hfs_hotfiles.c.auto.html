<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_hotfiles.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_hotfiles.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_format.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_hotfiles.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreeScanner.h&quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFC_DEBUG</span>  0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFC_VERBOSE</span> 0


<span class="enscript-comment">/*
 * Minimum post Tiger base time.
 * Thu Mar 31 17:00:00 2005
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFC_MIN_BASE_TIME</span>   0x424c8f00L

<span class="enscript-comment">/*
 * Hot File List (runtime).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hotfileinfo {
	u_int32_t  hf_fileid;
	u_int32_t  hf_temperature;
	u_int32_t  hf_blocks;
} hotfileinfo_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hotfilelist {
	u_int32_t     hfl_magic;
	u_int32_t     hfl_version;
	time_t        hfl_duration;    <span class="enscript-comment">/* duration of sample period */</span>
	<span class="enscript-type">int</span>           hfl_count;       <span class="enscript-comment">/* count of hot files recorded */</span>
	<span class="enscript-type">int</span>           hfl_next;        <span class="enscript-comment">/* next file to move */</span>
	<span class="enscript-type">int</span>           hfl_totalblocks; <span class="enscript-comment">/* total hot file blocks */</span>
	<span class="enscript-type">int</span>           hfl_reclaimblks; <span class="enscript-comment">/* blocks to reclaim in HFV */</span>
	u_int32_t     hfl_spare[2];
	hotfileinfo_t hfl_hotfile[1];  <span class="enscript-comment">/* array of hot files */</span>
} hotfilelist_t;


<span class="enscript-comment">/*
 * Hot File Entry (runtime).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hotfile_entry {
	<span class="enscript-type">struct</span>  hotfile_entry  *left;
	<span class="enscript-type">struct</span>  hotfile_entry  *right;
	u_int32_t  fileid;
	u_int32_t  temperature;
	u_int32_t  blocks;
} hotfile_entry_t;


<span class="enscript-comment">//
</span><span class="enscript-comment">// We cap the max temperature for non-system files to &quot;MAX_NORMAL_TEMP&quot;
</span><span class="enscript-comment">// so that they will always have a lower temperature than system (aka 
</span><span class="enscript-comment">// &quot;auto-cached&quot;) files.  System files have MAX_NORMAL_TEMP added to
</span><span class="enscript-comment">// their temperature which produces two bands of files (all non-system
</span><span class="enscript-comment">// files will have a temp less than MAX_NORMAL_TEMP and all system
</span><span class="enscript-comment">// files will have a temp greatern than MAX_NORMAL_TEMP).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// This puts non-system files on the left side of the hotfile btree 
</span><span class="enscript-comment">// (and we start evicting from the left-side of the tree).  The idea is 
</span><span class="enscript-comment">// that we will evict non-system files more aggressively since their
</span><span class="enscript-comment">// working set changes much more dynamically than system files (which 
</span><span class="enscript-comment">// are for the most part, static).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// NOTE: these values have to fit into a 32-bit int.  We use a
</span><span class="enscript-comment">//       value of 1-billion which gives a pretty broad range
</span><span class="enscript-comment">//       and yet should not run afoul of any sign issues.
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_NORMAL_TEMP</span>    1000000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HF_TEMP_RANGE</span>      MAX_NORMAL_TEMP


<span class="enscript-comment">//
</span><span class="enscript-comment">// These used to be defines of the hard coded values.  But if
</span><span class="enscript-comment">// we're on an cooperative fusion (CF) system we need to change 
</span><span class="enscript-comment">// the values (which happens in hfs_recording_init()
</span><span class="enscript-comment">// 
</span>uint32_t hfc_default_file_count = 1000;
uint32_t hfc_default_duration   = (3600 * 60);
uint32_t hfc_max_file_count     = 5000;
uint64_t hfc_max_file_size      = (10 * 1024 * 1024);


<span class="enscript-comment">/*
 * Hot File Recording Data (runtime).
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hotfile_data {
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">long</span>             refcount;
	u_int32_t	 activefiles;  <span class="enscript-comment">/* active number of hot files */</span>
	u_int32_t	 threshold;
	u_int32_t	 maxblocks;
	hotfile_entry_t	*rootentry;
	hotfile_entry_t	*freelist;
	hotfile_entry_t	*coldest;
	hotfile_entry_t	 entries[1];
} hotfile_data_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_recording_start</span> (<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_recording_stop</span> (<span class="enscript-type">struct</span> hfsmount *);

<span class="enscript-comment">/* Hotfiles pinning routines */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getvnode_and_pin</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileid, uint32_t *pinned);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_extent_record</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusExtentRecord extents, uint32_t *pinned);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_catalog_rec</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusCatalogFile *cfp, <span class="enscript-type">int</span> rsrc);

<span class="enscript-comment">/*
 * Hot File Data recording functions (in-memory binary tree).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>               <span class="enscript-function-name">hf_insert</span> (hotfile_data_t *, hotfile_entry_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>              <span class="enscript-function-name">hf_delete</span> (hotfile_data_t *, u_int32_t, u_int32_t);
<span class="enscript-type">static</span> hotfile_entry_t * <span class="enscript-function-name">hf_coldest</span> (hotfile_data_t *);
<span class="enscript-type">static</span> hotfile_entry_t * <span class="enscript-function-name">hf_getnewentry</span> (hotfile_data_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>              <span class="enscript-function-name">hf_getsortedlist</span> (hotfile_data_t *, hotfilelist_t *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_DEBUG</span>
<span class="enscript-type">static</span> hotfile_entry_t * <span class="enscript-function-name">hf_lookup</span> (hotfile_data_t *, u_int32_t, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hf_maxdepth</span>(hotfile_entry_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hf_printtree</span> (hotfile_entry_t *);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Hot File misc support functions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotfiles_collect</span> (<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotfiles_age</span> (<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotfiles_adopt</span> (<span class="enscript-type">struct</span> hfsmount *, vfs_context_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotfiles_evict</span> (<span class="enscript-type">struct</span> hfsmount *, vfs_context_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotfiles_refine</span> (<span class="enscript-type">struct</span> hfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hotextents</span>(<span class="enscript-type">struct</span> hfsmount *, HFSPlusExtentDescriptor *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_addhotfile_internal</span>(<span class="enscript-type">struct</span> vnode *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_hotfile_cur_freeblks</span>(hfsmount_t *hfsmp);


<span class="enscript-comment">/*
 * Hot File Cluster B-tree (on disk) functions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_create</span> (<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_open</span> (<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">struct</span> vnode **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_open_ext</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">int</span> ignore_btree_errs);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_close</span> (<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">struct</span> vnode *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_delete_record</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, BTreeIterator *iterator, HotFileKey *key);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_btree_delete</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfc_comparekeys</span> (HotFileKey *, HotFileKey *);


<span class="enscript-type">char</span> hfc_tag[] = <span class="enscript-string">&quot;CLUSTERED HOT FILES B-TREE     &quot;</span>;


<span class="enscript-comment">/*
 *========================================================================
 *                       HOT FILE INTERFACE ROUTINES
 *========================================================================
 */</span>

<span class="enscript-comment">/*
 * Start recording the hottest files on a file system.
 *
 * Requires that the hfc_mutex be held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_recording_start</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	hotfile_data_t *hotdata;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> maxentries;
	size_t size;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) ||
	    (hfsmp-&gt;jnl == NULL) ||
	    (hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) == 0) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;freeBlocks &lt; (2 * (u_int32_t)hfsmp-&gt;hfs_hotfile_maxblks)) {
		<span class="enscript-keyword">return</span> (ENOSPC);
	}
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_IDLE) {
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	hfsmp-&gt;hfc_stage = HFC_BUSY;

	<span class="enscript-comment">/*
	 * Dump previous recording data.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_recdata) {
		<span class="enscript-type">void</span> * tmp;

		tmp = hfsmp-&gt;hfc_recdata;
		hfsmp-&gt;hfc_recdata = NULL;
		FREE(tmp, M_TEMP);
	}

	microtime(&amp;tv);  <span class="enscript-comment">/* Times are base on GMT time. */</span>

	<span class="enscript-comment">/*
	 * On first startup check for suspended recording.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_timebase == 0 &amp;&amp;
	    hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp) == 0) {
		HotFilesInfo hotfileinfo;

		<span class="enscript-keyword">if</span> ((BTGetUserData(VTOF(hfsmp-&gt;hfc_filevp), &amp;hotfileinfo,
		                   <span class="enscript-keyword">sizeof</span>(hotfileinfo)) == 0) &amp;&amp;
		    (SWAP_BE32 (hotfileinfo.magic) == HFC_MAGIC) &amp;&amp;
		    (SWAP_BE32 (hotfileinfo.timeleft) &gt; 0) &amp;&amp;
		    (SWAP_BE32 (hotfileinfo.timebase) &gt; 0)) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_hotfile_freeblks == 0) {
					hfsmp-&gt;hfs_hotfile_freeblks = hfsmp-&gt;hfs_hotfile_maxblks - SWAP_BE32 (hotfileinfo.usedblocks);
				}
				hfsmp-&gt;hfc_maxfiles = 0x7fffffff;
				printf(<span class="enscript-string">&quot;hfs: %s: %s: hotfile freeblocks: %d, max: %d\n&quot;</span>, hfsmp-&gt;vcbVN, __FUNCTION__,
				       hfsmp-&gt;hfs_hotfile_freeblks, hfsmp-&gt;hfs_hotfile_maxblks);
			} <span class="enscript-keyword">else</span> {
				hfsmp-&gt;hfc_maxfiles = SWAP_BE32 (hotfileinfo.maxfilecnt);
			}
			hfsmp-&gt;hfc_timebase = SWAP_BE32 (hotfileinfo.timebase);
			<span class="enscript-type">int</span> timeleft = (<span class="enscript-type">int</span>)SWAP_BE32(hotfileinfo.timeleft);
			<span class="enscript-keyword">if</span> (timeleft &lt; 0 || timeleft &gt; (<span class="enscript-type">int</span>)(HFC_DEFAULT_DURATION*2)) {
				<span class="enscript-comment">// in case this field got botched, don't let it screw things up
</span>				<span class="enscript-comment">// printf(&quot;hfs: hotfiles: bogus looking timeleft: %d\n&quot;, timeleft);
</span>				timeleft = HFC_DEFAULT_DURATION;
			}
			hfsmp-&gt;hfc_timeout = timeleft + tv.tv_sec ;
			<span class="enscript-comment">/* Fix up any bogus timebase values. */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_timebase &lt; HFC_MIN_BASE_TIME) {
				hfsmp-&gt;hfc_timebase = hfsmp-&gt;hfc_timeout - HFC_DEFAULT_DURATION;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: Resume recording hot files on %s (%d secs left (%d); timeout %ld)\n&quot;</span>,
			       hfsmp-&gt;vcbVN, SWAP_BE32 (hotfileinfo.timeleft), timeleft, hfsmp-&gt;hfc_timeout - tv.tv_sec);
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			hfsmp-&gt;hfc_maxfiles = HFC_DEFAULT_FILE_COUNT;
			hfsmp-&gt;hfc_timebase = tv.tv_sec + 1;
			hfsmp-&gt;hfc_timeout = hfsmp-&gt;hfc_timebase + HFC_DEFAULT_DURATION;
		}
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> cat_attr cattr;
		u_int32_t cnid;

		<span class="enscript-comment">/*
		 * Make sure a btree file exists.
		 */</span>
		cnid = GetFileInfo(HFSTOVCB(hfsmp), kRootDirID, HFC_FILENAME, &amp;cattr, NULL);
		<span class="enscript-keyword">if</span> ((cnid == 0) &amp;&amp;
		    !S_ISREG(cattr.ca_mode) &amp;&amp;
		    (error = hfc_btree_create(hfsmp, HFSTOVCB(hfsmp)-&gt;blockSize, HFC_DEFAULT_FILE_COUNT))) {
			hfsmp-&gt;hfc_stage = HFC_IDLE;
			wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
			<span class="enscript-keyword">return</span> (error);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: begin recording hot files on %s (hotfile start/end block: %d - %d; max/free: %d/%d; maxfiles: %d)\n&quot;</span>,
		       hfsmp-&gt;vcbVN,
		       hfsmp-&gt;hfs_hotfile_start, hfsmp-&gt;hfs_hotfile_end,
		       hfsmp-&gt;hfs_hotfile_maxblks, hfsmp-&gt;hfs_hotfile_freeblks, hfsmp-&gt;hfc_maxfiles);
#<span class="enscript-reference">endif</span>
		hfsmp-&gt;hfc_maxfiles = HFC_DEFAULT_FILE_COUNT;
		hfsmp-&gt;hfc_timeout = tv.tv_sec + HFC_DEFAULT_DURATION;

		<span class="enscript-comment">/* Reset time base.  */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_timebase == 0) {
			hfsmp-&gt;hfc_timebase = tv.tv_sec + 1;
		} <span class="enscript-keyword">else</span> {
			time_t cumulativebase;

			cumulativebase = hfsmp-&gt;hfc_timeout - (HFC_CUMULATIVE_CYCLES * HFC_DEFAULT_DURATION);
			hfsmp-&gt;hfc_timebase = MAX(hfsmp-&gt;hfc_timebase, cumulativebase);
		}
	}

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfc_maxfiles == 0) ||
	    (hfsmp-&gt;hfc_maxfiles &gt; HFC_MAXIMUM_FILE_COUNT)) {
		hfsmp-&gt;hfc_maxfiles = HFC_DEFAULT_FILE_COUNT;
	}
	maxentries = hfsmp-&gt;hfc_maxfiles;

	size = <span class="enscript-keyword">sizeof</span>(hotfile_data_t) + (maxentries * <span class="enscript-keyword">sizeof</span>(hotfile_entry_t));
	MALLOC(hotdata, hotfile_data_t *, size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (hotdata == NULL) {
		hfsmp-&gt;hfc_recdata = NULL;
		hfsmp-&gt;hfc_stage = HFC_IDLE;
		wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
		<span class="enscript-keyword">return</span>(ENOMEM);
	}

	bzero(hotdata, size);

	<span class="enscript-keyword">for</span> (i = 1; i &lt; maxentries ; i++)
		hotdata-&gt;entries[i-1].right = &amp;hotdata-&gt;entries[i];
	
	hotdata-&gt;freelist = &amp;hotdata-&gt;entries[0];
	<span class="enscript-comment">/* 
	 * Establish minimum temperature and maximum file size.
	 */</span>
	hotdata-&gt;threshold = HFC_MINIMUM_TEMPERATURE;
	hotdata-&gt;maxblocks = HFC_MAXIMUM_FILESIZE / HFSTOVCB(hfsmp)-&gt;blockSize;
	hotdata-&gt;hfsmp = hfsmp;
	
	hfsmp-&gt;hfc_recdata = hotdata;
	hfsmp-&gt;hfc_stage = HFC_RECORDING;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Stop recording the hotest files on a file system.
 *
 * Requires that the hfc_mutex be held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_recording_stop</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	hotfile_data_t *hotdata;
	hotfilelist_t  *listp;
	<span class="enscript-type">struct</span> timeval tv;
	size_t  size;
	<span class="enscript-type">enum</span> hfc_stage newstage = HFC_IDLE;
	<span class="enscript-type">int</span>  error;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_RECORDING)
		<span class="enscript-keyword">return</span> (EPERM);

	hfsmp-&gt;hfc_stage = HFC_BUSY;

	hotfiles_collect(hfsmp);


	<span class="enscript-comment">/*
	 * Convert hot file data into a simple file id list....
	 *
	 * then dump the sample data
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: end of hot file recording on %s\n&quot;</span>, hfsmp-&gt;vcbVN);
#<span class="enscript-reference">endif</span>
	hotdata = (hotfile_data_t *)hfsmp-&gt;hfc_recdata;
	<span class="enscript-keyword">if</span> (hotdata == NULL)
		<span class="enscript-keyword">return</span> (0);
	hfsmp-&gt;hfc_recdata = NULL;
	hfsmp-&gt;hfc_stage = HFC_EVALUATION;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs:   curentries: %d\n&quot;</span>, hotdata-&gt;activefiles);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * If no hot files recorded then we're done.
	 */</span>
	<span class="enscript-keyword">if</span> (hotdata-&gt;rootentry == NULL) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Open the B-tree file for writing... */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp)
		panic(<span class="enscript-string">&quot;hfs_recording_stop: hfc_filevp exists (vp = %p)&quot;</span>, hfsmp-&gt;hfc_filevp);

	error = hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Age the previous set of clustered hot files.
	 */</span>
	error = hotfiles_age(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Create a sorted list of hotest files.
	 */</span>
	size = <span class="enscript-keyword">sizeof</span>(hotfilelist_t);
	size += <span class="enscript-keyword">sizeof</span>(hotfileinfo_t) * (hotdata-&gt;activefiles - 1);
	MALLOC(listp, hotfilelist_t *, size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (listp == NULL) {
		error = ENOMEM;
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	bzero(listp, size);

	hf_getsortedlist(hotdata, listp);	<span class="enscript-comment">/* NOTE: destroys hot file tree! */</span>
	microtime(&amp;tv);
	listp-&gt;hfl_duration = tv.tv_sec - hfsmp-&gt;hfc_timebase;
	hfsmp-&gt;hfc_recdata = listp;

	<span class="enscript-comment">/*
	 * Account for duplicates.
	 */</span>
	error = hotfiles_refine(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Compute the amount of space to reclaim...
	 */</span>
	<span class="enscript-keyword">if</span> (listp-&gt;hfl_totalblocks &gt; hfs_hotfile_cur_freeblks(hfsmp)) {
		listp-&gt;hfl_reclaimblks =
			MIN(listp-&gt;hfl_totalblocks, hfsmp-&gt;hfs_hotfile_maxblks) -
			hfsmp-&gt;hfs_hotfile_freeblks;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs_recording_stop: need to reclaim %d blocks\n&quot;</span>, listp-&gt;hfl_reclaimblks);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_reclaimblks)
			newstage = HFC_EVICTION;
		<span class="enscript-keyword">else</span>
			newstage = HFC_ADOPTION;
	} <span class="enscript-keyword">else</span> {
		newstage = HFC_ADOPTION;
	}
	
	<span class="enscript-keyword">if</span> (newstage == HFC_ADOPTION &amp;&amp; listp-&gt;hfl_totalblocks == 0) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
		newstage = HFC_IDLE;
	}
<span class="enscript-reference">out</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	<span class="enscript-keyword">if</span> (newstage == HFC_EVICTION)
		printf(<span class="enscript-string">&quot;hfs: evicting coldest files\n&quot;</span>);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newstage == HFC_ADOPTION)
		printf(<span class="enscript-string">&quot;hfs: adopting hotest files\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	FREE(hotdata, M_TEMP);

	hfsmp-&gt;hfc_stage = newstage;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">save_btree_user_info</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	HotFilesInfo hotfileinfo;
	<span class="enscript-type">struct</span> timeval tv;

	microtime(&amp;tv);
	hotfileinfo.magic       = SWAP_BE32 (HFC_MAGIC);
	hotfileinfo.version     = SWAP_BE32 (HFC_VERSION);
	hotfileinfo.duration    = SWAP_BE32 (HFC_DEFAULT_DURATION);
	hotfileinfo.timebase    = SWAP_BE32 (hfsmp-&gt;hfc_timebase);
	hotfileinfo.timeleft    = SWAP_BE32 (hfsmp-&gt;hfc_timeout - tv.tv_sec);
	hotfileinfo.threshold   = SWAP_BE32 (HFC_MINIMUM_TEMPERATURE);
	hotfileinfo.maxfileblks = SWAP_BE32 (HFC_MAXIMUM_FILESIZE / HFSTOVCB(hfsmp)-&gt;blockSize);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		hotfileinfo.usedblocks = SWAP_BE32 (hfsmp-&gt;hfs_hotfile_maxblks - hfs_hotfile_cur_freeblks(hfsmp));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: %s: saving usedblocks = %d (timeleft: %d; timeout %ld)\n&quot;</span>, hfsmp-&gt;vcbVN, (hfsmp-&gt;hfs_hotfile_maxblks - hfsmp-&gt;hfs_hotfile_freeblks),
		       SWAP_BE32(hotfileinfo.timeleft), hfsmp-&gt;hfc_timeout);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
		hotfileinfo.maxfilecnt  = SWAP_BE32 (HFC_DEFAULT_FILE_COUNT);
	}
	strlcpy((<span class="enscript-type">char</span> *)hotfileinfo.tag, hfc_tag, <span class="enscript-keyword">sizeof</span> hotfileinfo.tag);
	(<span class="enscript-type">void</span>) BTSetUserData(VTOF(hfsmp-&gt;hfc_filevp), &amp;hotfileinfo, <span class="enscript-keyword">sizeof</span>(hotfileinfo));
}

<span class="enscript-comment">/*
 * Suspend recording the hotest files on a file system.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_recording_suspend</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	hotfile_data_t *hotdata = NULL;
	<span class="enscript-type">int</span>  error;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_DISABLED)
		<span class="enscript-keyword">return</span> (0);

	lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);

	<span class="enscript-comment">/*
	 * XXX NOTE
	 * A suspend can occur during eval/evict/adopt stage.
	 * In that case we would need to write out info and
	 * flush our HFBT vnode. Currently we just bail.
	 */</span>

	hotdata = (hotfile_data_t *)hfsmp-&gt;hfc_recdata;
	<span class="enscript-keyword">if</span> (hotdata == NULL || hfsmp-&gt;hfc_stage != HFC_RECORDING) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	hfsmp-&gt;hfc_stage = HFC_BUSY;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: suspend hot file recording on %s\n&quot;</span>, hfsmp-&gt;vcbVN);
#<span class="enscript-reference">endif</span>
	error = hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_recording_suspend: err %d opening btree\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end_transaction</span>;
	}

	save_btree_user_info(hfsmp);

	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

<span class="enscript-reference">end_transaction</span>:
	hfs_end_transaction(hfsmp);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	}
	<span class="enscript-keyword">if</span> (hotdata) {
		FREE(hotdata, M_TEMP);
		hfsmp-&gt;hfc_recdata = NULL;
	}
	hfsmp-&gt;hfc_stage = HFC_DISABLED;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);

	lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">reset_file_ids</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t *fileid_table, <span class="enscript-type">int</span> num_ids)
{
	<span class="enscript-type">int</span> i, error;

	<span class="enscript-keyword">for</span>(i=0; i &lt; num_ids; i++) {
		<span class="enscript-type">struct</span> vnode *vp;

		error = hfs_vget(hfsmp, fileid_table[i], &amp;vp, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ENOENT) {
				error = 0;
				<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
			}
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">// hfs_vget returns a locked cnode so no need to lock here
</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; (VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask)) {
			error = hfs_pin_vnode(hfsmp, vp, HFS_UNPIN_IT, NULL, vfs_context_kernel());
		}

		<span class="enscript-comment">/*
		 * The updates to the catalog must be journaled
		 */</span>
		hfs_start_transaction(hfsmp);

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// turn off _all_ the hotfile related bits since we're resetting state
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevCandidateMask) {
			vnode_clearfastdevicecandidate(vp);
		}

		VTOC(vp)-&gt;c_attr.ca_recflags &amp;= ~(kHFSFastDevPinnedMask|kHFSDoNotFastDevPinMask|kHFSFastDevCandidateMask|kHFSAutoCandidateMask);
		VTOC(vp)-&gt;c_flag |= C_MODIFIED;

		hfs_update(vp, 0);

		hfs_end_transaction(hfsmp);
		
		hfs_unlock(VTOC(vp));
		vnode_put(vp);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">flag_hotfile</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *filename)
{
	<span class="enscript-type">struct</span> vnode *dvp = NULL, *fvp = NULL;
	vfs_context_t ctx = vfs_context_kernel();
	<span class="enscript-type">struct</span> componentname cname;
	<span class="enscript-type">int</span>  error=0;
	size_t fname_len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *orig_fname = filename;
	
	<span class="enscript-keyword">if</span> (filename == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	fname_len = strlen(filename);    <span class="enscript-comment">// do NOT include the trailing '\0' so that we break out of the loop below
</span>	
	error = VFS_ROOT(HFSTOVFS(hfsmp), &amp;dvp, ctx);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* At this point, 'dvp' must be considered iocounted */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ptr;
	ptr = filename;

	<span class="enscript-keyword">while</span> (ptr &lt; (orig_fname + fname_len - 1)) {
		<span class="enscript-keyword">for</span>(; ptr &lt; (orig_fname + fname_len) &amp;&amp; *ptr &amp;&amp; *ptr != <span class="enscript-string">'/'</span>; ptr++) {
			<span class="enscript-comment">/* just keep advancing till we reach the end of the string or a slash */</span>
		}

		cname.cn_nameiop = LOOKUP;
		cname.cn_flags = ISLASTCN;
		cname.cn_context = ctx;
		cname.cn_ndp = NULL;
		cname.cn_pnbuf = __DECONST(<span class="enscript-type">char</span> *, orig_fname);
        cname.cn_nameptr = __DECONST(<span class="enscript-type">char</span> *, filename);
		cname.cn_pnlen = fname_len;
		cname.cn_namelen = ptr - filename;
		cname.cn_hash = 0;
		cname.cn_consume = 0;

		error = VNOP_LOOKUP(dvp, &amp;fvp, &amp;cname, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/*
			 * If 'dvp' is non-NULL, then it has an iocount.  Make sure to release it
			 * before bailing out.  VNOP_LOOKUP could legitimately return ENOENT
			 * if the item didn't exist or if we raced with a delete.
			 */</span>
			<span class="enscript-keyword">if</span> (dvp) {
				vnode_put(dvp);
				dvp = NULL;
			}
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-keyword">if</span> (ptr &lt; orig_fname + fname_len - 1) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// we've got a multi-part pathname so drop the ref on the dir,
</span>			<span class="enscript-comment">// make dvp become what we just looked up, and advance over
</span>			<span class="enscript-comment">// the slash character in the pathname to get to the next part
</span>			<span class="enscript-comment">// of the component
</span>			<span class="enscript-comment">//
</span>			vnode_put(dvp);
			dvp = fvp;
			fvp = NULL;

			filename = ++ptr;   <span class="enscript-comment">// skip the slash character
</span>		}
	}
	
	<span class="enscript-keyword">if</span> (fvp == NULL) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-type">struct</span> cnode *cp = VTOC(fvp);
	<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	hfs_start_transaction(hfsmp);
	
	cp-&gt;c_attr.ca_recflags |= (kHFSFastDevCandidateMask|kHFSAutoCandidateMask);
	cp-&gt;c_flag |= C_MODIFIED;

	hfs_update(fvp, 0);

	hfs_end_transaction(hfsmp);

	hfs_unlock(cp);
	<span class="enscript-comment">//printf(&quot;hfs: flagged /%s with the fast-dev-candidate|auto-candidate flags\n&quot;, filename);
</span>

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (fvp) {
		vnode_put(fvp);
		fvp = NULL;
	}

	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
		dvp = NULL;
	}

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_setup_default_cf_hotfiles</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *system_default_hotfiles[] = {
		<span class="enscript-string">&quot;usr&quot;</span>,
		<span class="enscript-string">&quot;System&quot;</span>,
		<span class="enscript-string">&quot;Applications&quot;</span>,
		<span class="enscript-string">&quot;private/var/db/dyld&quot;</span>
	};
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span>(i=0; i &lt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(system_default_hotfiles)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span> *)); i++) {
		flag_hotfile(hfsmp, system_default_hotfiles[i]);
	}
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUM_FILE_RESET_IDS</span>   4096    // so we allocate 16k to hold file-ids

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_hotfile_reset</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	CatalogKey * keyp;
	CatalogRecord * datap;
	u_int32_t  dataSize;
	BTScanState scanstate;
	BTreeIterator * iterator = NULL;
	FSBufferDescriptor  record;
	u_int32_t  data;
	u_int32_t  cnid;
	<span class="enscript-type">int</span> error = 0;
	uint32_t *fileids=NULL;
	<span class="enscript-type">int</span> cur_id_index = 0;

	<span class="enscript-type">int</span> cleared = 0;  <span class="enscript-comment">/* debug variables */</span>
	<span class="enscript-type">int</span> filecount = 0;
	<span class="enscript-type">int</span> dircount = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: %s: %s\n&quot;</span>, hfsmp-&gt;vcbVN, __FUNCTION__);
#<span class="enscript-reference">endif</span>

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));

	MALLOC(fileids, uint32_t *, NUM_FILE_RESET_IDS * <span class="enscript-keyword">sizeof</span>(uint32_t), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (fileids == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(u_int32_t);
	record.itemCount = 1;

	<span class="enscript-comment">/*
	 * Get ready to scan the Catalog file.
	 */</span>
	error = BTScanInitialize(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), 0, 0, 0,
	                       kCatSearchBufferSize, &amp;scanstate);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_hotfile_reset: err %d BTScanInit\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Visit all the catalog btree leaf records, clearing any that have the
	 * HotFileCached bit set.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		error = BTScanNextRecord(&amp;scanstate, 0, (<span class="enscript-type">void</span> **)&amp;keyp, (<span class="enscript-type">void</span> **)&amp;datap, &amp;dataSize);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == btNotFound)
				error = 0;
			<span class="enscript-keyword">else</span>
				printf(<span class="enscript-string">&quot;hfs_hotfile_reset: err %d BTScanNext\n&quot;</span>, error);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (datap-&gt;recordType == kHFSPlusFolderRecord &amp;&amp; (dataSize == <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogFolder))) {
			HFSPlusCatalogFolder *dirp = (HFSPlusCatalogFolder *)datap;

			dircount++;
		
			<span class="enscript-keyword">if</span> ((dirp-&gt;flags &amp; (kHFSFastDevPinnedMask|kHFSDoNotFastDevPinMask|kHFSFastDevCandidateMask|kHFSAutoCandidateMask)) == 0) {
				<span class="enscript-keyword">continue</span>;
			}

			cnid = dirp-&gt;folderID;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((datap-&gt;recordType == kHFSPlusFileRecord) &amp;&amp; (dataSize == <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogFile))) {
			HFSPlusCatalogFile *filep = (HFSPlusCatalogFile *)datap;   

			filecount++;

			<span class="enscript-comment">/*
			 * If the file doesn't have any of the HotFileCached bits set, ignore it.
			 */</span>
			<span class="enscript-keyword">if</span> ((filep-&gt;flags &amp; (kHFSFastDevPinnedMask|kHFSDoNotFastDevPinMask|kHFSFastDevCandidateMask|kHFSAutoCandidateMask)) == 0) {
				<span class="enscript-keyword">continue</span>;
			}

			cnid = filep-&gt;fileID;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Skip over journal files. */</span>
		<span class="enscript-keyword">if</span> (cnid == hfsmp-&gt;hfs_jnlfileid || cnid == hfsmp-&gt;hfs_jnlinfoblkid) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// Just record the cnid of the file for now.  We will modify it separately
</span>		<span class="enscript-comment">// because we can't modify the catalog while we're scanning it.
</span>		<span class="enscript-comment">//
</span>		fileids[cur_id_index++] = cnid;
		<span class="enscript-keyword">if</span> (cur_id_index &gt;= NUM_FILE_RESET_IDS) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// We're over the limit of file-ids so we have to terminate this
</span>			<span class="enscript-comment">// scan, go modify all the catalog records, then restart the scan.
</span>			<span class="enscript-comment">// This is required because it's not permissible to modify the
</span>			<span class="enscript-comment">// catalog while scanning it.
</span>			<span class="enscript-comment">//
</span>			(<span class="enscript-type">void</span>) BTScanTerminate(&amp;scanstate, &amp;data, &amp;data, &amp;data);

			reset_file_ids(hfsmp, fileids, cur_id_index);
			cleared += cur_id_index;
			cur_id_index = 0;

			<span class="enscript-comment">// restart the scan
</span>			error = BTScanInitialize(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), 0, 0, 0,
						 kCatSearchBufferSize, &amp;scanstate);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;hfs_hotfile_reset: err %d BTScanInit\n&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">continue</span>;
		}
	}

	<span class="enscript-keyword">if</span> (cur_id_index) {
		reset_file_ids(hfsmp, fileids, cur_id_index);
		cleared += cur_id_index;
		cur_id_index = 0;
	}

	printf(<span class="enscript-string">&quot;hfs: cleared HotFileCache related bits on %d files out of %d (dircount %d)\n&quot;</span>, cleared, filecount, dircount);

	(<span class="enscript-type">void</span>) BTScanTerminate(&amp;scanstate, &amp;data, &amp;data, &amp;data);

<span class="enscript-reference">out</span>:	
	<span class="enscript-keyword">if</span> (fileids)
		FREE(fileids, M_TEMP);
	
	<span class="enscript-keyword">if</span> (iterator)
		FREE(iterator, M_TEMP);

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If the hotfile btree exists, delete it.  We need to open
</span>	<span class="enscript-comment">// it to be able to delete it because we need the hfc_filevp
</span>	<span class="enscript-comment">// for deletion.
</span>	<span class="enscript-comment">//
</span>	error = hfc_btree_open_ext(hfsmp, &amp;hfsmp-&gt;hfc_filevp, 1);
	<span class="enscript-keyword">if</span> (!error) {
		printf(<span class="enscript-string">&quot;hfs: hotfile_reset: deleting existing hotfile btree\n&quot;</span>);
		hfc_btree_delete(hfsmp);
	}
	
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	}

	hfsmp-&gt;hfs_hotfile_blk_adjust = 0;
	hfsmp-&gt;hfs_hotfile_freeblks = hfsmp-&gt;hfs_hotfile_maxblks;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// This should ONLY be called by hfs_recording_init() and the special fsctl.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// We assume that the hotfile btree is already opened.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hotfile_repin_files</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	BTreeIterator * iterator = NULL;
	HotFileKey * key;
	filefork_t * filefork;
	<span class="enscript-type">int</span>  error = 0;
	<span class="enscript-type">int</span>  bt_op;
	<span class="enscript-type">enum</span> hfc_stage stage;
	uint32_t pinned_blocks;
	uint32_t num_files=0, nrsrc=0;
	uint32_t total_pinned=0;

	<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) || !hfsmp-&gt;hfc_filevp) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// this is only meaningful if we're pinning hotfiles
</span>		<span class="enscript-comment">// (as opposed to the regular form of hotfiles that
</span>		<span class="enscript-comment">// get relocated to the hotfile zone)
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">return</span> 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: %s: %s\n&quot;</span>, hfsmp-&gt;vcbVN, __FUNCTION__);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		<span class="enscript-keyword">return</span> (EPERM);
	}


	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	stage = hfsmp-&gt;hfc_stage;
	hfsmp-&gt;hfc_stage = HFC_BUSY;

	bt_op = kBTreeFirstRecord;

	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;

	filefork = VTOF(hfsmp-&gt;hfc_filevp);
	<span class="enscript-type">int</span> lockflags;

	<span class="enscript-keyword">while</span> (1) {

		lockflags = 0;
		<span class="enscript-comment">/*
		 * Obtain the first record (ie the coldest one).
		 */</span>
		<span class="enscript-keyword">if</span> (BTIterateRecord(filefork, bt_op, iterator, NULL, NULL) != 0) {
			<span class="enscript-comment">// no more records
</span>			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (key-&gt;keyLength != HFC_KEYLENGTH) {
			<span class="enscript-comment">// printf(&quot;hfs: hotfiles_repin_files: invalid key length %d\n&quot;, key-&gt;keyLength);
</span>			error = EFTYPE;
			<span class="enscript-keyword">break</span>;
		}		
		<span class="enscript-keyword">if</span> (key-&gt;temperature == HFC_LOOKUPTAG) {
			<span class="enscript-comment">// ran into thread records in the hotfile btree
</span>			error = 0;
			<span class="enscript-keyword">break</span>;
		}

        <span class="enscript-comment">//
</span>		<span class="enscript-comment">// Just lookup the records in the catalog and pin the direct
</span>		<span class="enscript-comment">// mapped extents.  Faster than instantiating full vnodes
</span>		<span class="enscript-comment">// (and thereby thrashing the system vnode cache).
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-type">struct</span> cat_desc fdesc;
		<span class="enscript-type">struct</span> cat_attr attr;
		<span class="enscript-type">struct</span> cat_fork fork;
        uint8_t forktype = 0;

		lockflags = hfs_systemfile_lock(hfsmp, (SFL_CATALOG | SFL_EXTENTS), HFS_SHARED_LOCK);
        <span class="enscript-comment">/*
         * Snoop the cnode hash to find out if the item we want is in-core already.
         *
         * We largely expect this function to fail (the items we want are probably not in the hash).
         * we use the special variant which bails out as soon as it finds a vnode (even if it is
         * marked as open-unlinked or actually removed on-disk.  If we find a vnode, then we
         * release the systemfile locks and go through the pin-vnode path instead.
         */</span>
        <span class="enscript-keyword">if</span> (hfs_chash_snoop (hfsmp, key-&gt;fileID, 1, NULL, NULL) == 0) {
            pinned_blocks = 0;

            <span class="enscript-comment">/* unlock immediately and go through the in-core path */</span>
            hfs_systemfile_unlock(hfsmp, lockflags);
			lockflags = 0;

            error = hfs_getvnode_and_pin (hfsmp, key-&gt;fileID, &amp;pinned_blocks);
            <span class="enscript-keyword">if</span> (error) {
                <span class="enscript-comment">/* if ENOENT, then it was deleted in the catalog. Remove from our hotfiles tracking */</span>
                <span class="enscript-keyword">if</span> (error == ENOENT) {
                    hfc_btree_delete_record(hfsmp, iterator, key);
                }
                <span class="enscript-comment">/* other errors, just ignore and move on with life */</span>
            }
            <span class="enscript-keyword">else</span> { <span class="enscript-comment">//!error
</span>                total_pinned += pinned_blocks;
                num_files++;
            }

            <span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
        }

        <span class="enscript-comment">/* If we get here, we're still holding the systemfile locks */</span>
		error = cat_idlookup(hfsmp, key-&gt;fileID, 1, 0, &amp;fdesc, &amp;attr, &amp;fork);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// this file system could have been mounted while booted from a
</span>			<span class="enscript-comment">// different partition and thus the hotfile btree would not have
</span>			<span class="enscript-comment">// been maintained.  thus a file that was hotfile cached could
</span>			<span class="enscript-comment">// have been deleted while booted from a different partition which
</span>			<span class="enscript-comment">// means we need to delete it from the hotfile btree.
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// block accounting is taken care of at the end: we re-assign
</span>			<span class="enscript-comment">// hfsmp-&gt;hfs_hotfile_freeblks based on how many blocks we actually
</span>			<span class="enscript-comment">// pinned.
</span>			<span class="enscript-comment">//
</span>			hfc_btree_delete_record(hfsmp, iterator, key);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}

		<span class="enscript-keyword">if</span> (fork.cf_size == 0) {
			<span class="enscript-comment">// hmmm, the data is probably in the resource fork (aka a compressed file)
</span>			error = cat_idlookup(hfsmp, key-&gt;fileID, 1, 1, &amp;fdesc, &amp;attr, &amp;fork);
			<span class="enscript-keyword">if</span> (error) {
				hfc_btree_delete_record(hfsmp, iterator, key);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
            forktype = 0xff;
			nrsrc++;
		}

		pinned_blocks = 0;

        <span class="enscript-comment">/* Can't release the catalog /extents lock yet, we may need to go find the overflow blocks */</span>
        error = hfs_pin_extent_record (hfsmp, fork.cf_extents, &amp;pinned_blocks);
        <span class="enscript-keyword">if</span> (error) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;  <span class="enscript-comment">//skip to next
</span>        }
		<span class="enscript-comment">/* add in the blocks from the inline 8 */</span>
        total_pinned += pinned_blocks;
        pinned_blocks = 0;

        <span class="enscript-comment">/* Could this file have overflow extents? */</span>
        <span class="enscript-keyword">if</span> (fork.cf_extents[kHFSPlusExtentDensity-1].startBlock) {
            <span class="enscript-comment">/* better pin them, too */</span>
            error = hfs_pin_overflow_extents (hfsmp, key-&gt;fileID, forktype, &amp;pinned_blocks);
            <span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/* If we fail to pin all of the overflow extents, then just skip to the next file */</span>
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
            }
        }

		num_files++;
        <span class="enscript-keyword">if</span> (pinned_blocks) {
            <span class="enscript-comment">/* now add in any overflow also */</span>
            total_pinned += pinned_blocks;
        }

	<span class="enscript-reference">next</span>:
		<span class="enscript-keyword">if</span> (lockflags) {
			hfs_systemfile_unlock(hfsmp, lockflags);
			lockflags = 0;
		}
		bt_op = kBTreeNextRecord;

	} <span class="enscript-comment">/* end while */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: hotfiles_repin_files: re-pinned %d files (nrsrc %d, total pinned %d blks; freeblock %d, maxblocks %d, calculated free: %d)\n&quot;</span>,
	       num_files, nrsrc, total_pinned, hfsmp-&gt;hfs_hotfile_freeblks, hfsmp-&gt;hfs_hotfile_maxblks,
	      hfsmp-&gt;hfs_hotfile_maxblks - total_pinned);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// make sure this is accurate based on how many blocks we actually pinned
</span>	<span class="enscript-comment">//
</span>	hfsmp-&gt;hfs_hotfile_freeblks = hfsmp-&gt;hfs_hotfile_maxblks - total_pinned;

	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

	FREE(iterator, M_TEMP);	
	hfsmp-&gt;hfc_stage = stage;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_repin_hotfiles</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">int</span> error, need_close;
	
	lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp == NULL) {
		error = hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp);
		<span class="enscript-keyword">if</span> (!error) {
			need_close = 1;
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;hfs: failed to open the btree err=%d.  Unable to re-pin hotfiles.\n&quot;</span>, error);
			lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span> {
		need_close = 0;
	}

	hfs_pin_vnode(hfsmp, hfsmp-&gt;hfc_filevp, HFS_PIN_IT, NULL, vfs_context_kernel());
			
	hfs_hotfile_repin_files(hfsmp);

	<span class="enscript-keyword">if</span> (need_close) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	}

	lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
}

<span class="enscript-comment">/*
 * For a given file ID, find and pin all of its overflow extents to the underlying CS
 * device.  Assumes that the extents overflow b-tree is locked for the duration of this call.
 *
 * Emit the number of blocks pinned in output argument 'pinned'
 *
 * Return success or failure (errno) in return value.
 *
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_overflow_extents</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileid,
                                     uint8_t forktype, uint32_t *pinned) {

    <span class="enscript-type">struct</span> BTreeIterator *ext_iter = NULL;
    ExtentKey *ext_key_ptr = NULL;
    ExtentRecord ext_data;
    FSBufferDescriptor btRecord;
    uint16_t btRecordSize;
    <span class="enscript-type">int</span> error = 0;

    uint32_t pinned_blocks = 0;


    MALLOC (ext_iter, <span class="enscript-type">struct</span> BTreeIterator*, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> BTreeIterator), M_TEMP, M_WAITOK);
    <span class="enscript-keyword">if</span> (ext_iter == NULL) {
        <span class="enscript-keyword">return</span> ENOMEM;
    }
    bzero (ext_iter, <span class="enscript-keyword">sizeof</span>(*ext_iter));

    BTInvalidateHint (ext_iter);
    ext_key_ptr = (ExtentKey*)&amp;ext_iter-&gt;key;
    btRecord.bufferAddress = &amp;ext_data;
    btRecord.itemCount = 1;

    <span class="enscript-comment">/*
     * This is like when you delete a file; we don't actually need most of the search machinery because
     * we are going to need all of the extent records that belong to this file (for a given fork type),
     * so we might as well use a straight-up iterator.
     *
     * Position the B-Tree iterator at the first record with this file ID
     */</span>
    btRecord.itemSize = <span class="enscript-keyword">sizeof</span> (HFSPlusExtentRecord);
    ext_key_ptr-&gt;hfsPlus.keyLength = kHFSPlusExtentKeyMaximumLength;
    ext_key_ptr-&gt;hfsPlus.forkType = forktype;
    ext_key_ptr-&gt;hfsPlus.pad = 0;
    ext_key_ptr-&gt;hfsPlus.fileID = fileid;
    ext_key_ptr-&gt;hfsPlus.startBlock = 0;

    error = BTSearchRecord (VTOF(hfsmp-&gt;hfs_extents_vp), ext_iter, &amp;btRecord, &amp;btRecordSize, ext_iter);
    <span class="enscript-keyword">if</span> (error ==  btNotFound) {
        <span class="enscript-comment">/* empty b-tree, so that's ok. we'll fall out during error check below. */</span>
        error = 0;
    }

    <span class="enscript-keyword">while</span> (1) {
        uint32_t found_fileid;
        uint32_t pblocks;

        error = BTIterateRecord (VTOF(hfsmp-&gt;hfs_extents_vp), kBTreeNextRecord, ext_iter, &amp;btRecord, &amp;btRecordSize);
        <span class="enscript-keyword">if</span> (error) {
            <span class="enscript-comment">/* swallow it if it's btNotFound, otherwise just bail out */</span>
            <span class="enscript-keyword">if</span> (error == btNotFound)
                error = 0;
            <span class="enscript-keyword">break</span>;
        }

        found_fileid = ext_key_ptr-&gt;hfsPlus.fileID;
        <span class="enscript-comment">/*
         * We only do one fork type at a time. So if either the fork-type doesn't
         * match what we are looking for (resource or data), OR the file id doesn't match
         * which indicates that there's nothing more with this file ID as the key, then bail out
         */</span>
        <span class="enscript-keyword">if</span> ((found_fileid != fileid) || (ext_key_ptr-&gt;hfsPlus.forkType != forktype))  {
            error = 0;
            <span class="enscript-keyword">break</span>;
        }

        <span class="enscript-comment">/* Otherwise, we now have an extent record. Process and pin all of the file extents. */</span>
        pblocks = 0;
        error = hfs_pin_extent_record (hfsmp, ext_data.hfsPlus, &amp;pblocks);

        <span class="enscript-keyword">if</span> (error) {
            <span class="enscript-keyword">break</span>;
        }
        pinned_blocks += pblocks;

        <span class="enscript-comment">/* if 8th extent is empty, then bail out */</span>
        <span class="enscript-keyword">if</span> (ext_data.hfsPlus[kHFSPlusExtentDensity-1].startBlock == 0) {
            error = 0;
            <span class="enscript-keyword">break</span>;
        }

    } <span class="enscript-comment">// end extent-getting loop
</span>
    <span class="enscript-comment">/* dump the iterator */</span>
    FREE (ext_iter, M_TEMP);

    <span class="enscript-keyword">if</span> (error == 0) {
        <span class="enscript-comment">/*
         * In the event that the file has no overflow extents, pinned_blocks
         * will never be updated, so we'll properly export 0 pinned blocks to caller
         */</span>
        *pinned = pinned_blocks;
    }

    <span class="enscript-keyword">return</span> error;

}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_getvnode_and_pin</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileid, uint32_t *pinned) {
    <span class="enscript-type">struct</span> vnode *vp;
    <span class="enscript-type">int</span> error = 0;
    *pinned = 0;
    uint32_t pblocks;

    <span class="enscript-comment">/*
     * Acquire the vnode for this file.  This returns a locked cnode on success
     */</span>
    error = hfs_vget(hfsmp, fileid, &amp;vp, 0, 0);
    <span class="enscript-keyword">if</span> (error) {
        <span class="enscript-comment">/* It's possible the file was open-unlinked. In this case, we'll get ENOENT back. */</span>
        <span class="enscript-keyword">return</span> error;
    }

    <span class="enscript-comment">/*
     * Symlinks that may have been inserted into the hotfile zone during a previous OS are now stuck
     * here.  We do not want to move them.
     */</span>
    <span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
        hfs_unlock(VTOC(vp));
        vnode_put(vp);
        <span class="enscript-keyword">return</span> EPERM;
    }

    <span class="enscript-keyword">if</span> (!(VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask)) {
        hfs_unlock(VTOC(vp));
        vnode_put(vp);
        <span class="enscript-keyword">return</span> EINVAL;
    }

    error = hfs_pin_vnode(hfsmp, vp, HFS_PIN_IT, &amp;pblocks, vfs_context_kernel());
    <span class="enscript-keyword">if</span> (error == 0) {
        *pinned = pblocks;
    }

    hfs_unlock(VTOC(vp));
    vnode_put(vp);

    <span class="enscript-keyword">return</span> error;

}

<span class="enscript-comment">/*
 * Pins an HFS Extent record to the underlying CoreStorage.  Assumes that Catalog &amp; Extents overflow
 * B-trees are held locked, as needed.
 *
 * Returns the number of blocks pinned in the output argument 'pinned'
 *
 * Returns error status (0 || errno) in return value.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_extent_record</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusExtentRecord extents, uint32_t *pinned) {
    uint32_t pb = 0;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (pinned == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
    *pinned = 0;



	<span class="enscript-comment">/* iterate through the extents */</span>
	<span class="enscript-keyword">for</span> ( i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		<span class="enscript-keyword">if</span> (extents[i].startBlock == 0) {
			<span class="enscript-keyword">break</span>;
		}

		error = hfs_pin_block_range (hfsmp, HFS_PIN_IT, extents[i].startBlock,
				extents[i].blockCount, vfs_context_kernel());

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		pb += extents[i].blockCount;
	}

    *pinned = pb;

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Consume an HFS Plus on-disk catalog record and pin its blocks
 * to the underlying CS devnode.
 *
 * NOTE: This is an important distinction!
 * This function takes in an HFSPlusCatalogFile* which is the actual
 * 200-some-odd-byte on-disk representation in the Catalog B-Tree (not
 * one of the run-time structs that we normally use.
 *
 * This assumes that the catalog and extents-overflow btrees
 * are locked, at least in shared mode
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_catalog_rec</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusCatalogFile *cfp, <span class="enscript-type">int</span> rsrc) {
	uint32_t pinned_blocks = 0;
	HFSPlusForkData *forkdata;
	<span class="enscript-type">int</span> error = 0;
	uint8_t forktype = 0;

	<span class="enscript-keyword">if</span> (rsrc) {
        forkdata = &amp;cfp-&gt;resourceFork;
		forktype = 0xff;
	}
	<span class="enscript-keyword">else</span> {
		forkdata = &amp;cfp-&gt;dataFork;
	}

	uint32_t pblocks = 0;

	<span class="enscript-comment">/* iterate through the inline extents */</span>
	error = hfs_pin_extent_record (hfsmp, forkdata-&gt;extents, &amp;pblocks);
	<span class="enscript-keyword">if</span> (error) {
        <span class="enscript-keyword">return</span> error;
	}

	pinned_blocks += pblocks;
    pblocks = 0;

	<span class="enscript-comment">/* it may have overflow extents */</span>
	<span class="enscript-keyword">if</span> (forkdata-&gt;extents[kHFSPlusExtentDensity-1].startBlock != 0) {
        error = hfs_pin_overflow_extents (hfsmp, cfp-&gt;fileID, forktype, &amp;pblocks);
	}
    pinned_blocks += pblocks;

	hfsmp-&gt;hfs_hotfile_freeblks -= pinned_blocks;

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_recording_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	CatalogKey * keyp;
	CatalogRecord * datap;
	u_int32_t  dataSize;
	HFSPlusCatalogFile *filep;
	BTScanState scanstate;
	BTreeIterator * iterator = NULL;
	FSBufferDescriptor  record;
	HotFileKey * key;
	filefork_t * filefork;
	u_int32_t  data;
	<span class="enscript-type">struct</span> cat_attr cattr;
	u_int32_t  cnid;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">long</span> starting_temp;

	<span class="enscript-type">int</span> started_tr = 0;
	<span class="enscript-type">int</span> started_scan = 0;

	<span class="enscript-type">int</span> inserted = 0;  <span class="enscript-comment">/* debug variables */</span>
	<span class="enscript-type">int</span> filecount = 0;
	<span class="enscript-type">int</span> uncacheable = 0;

	<span class="enscript-comment">/*
	 * For now, only the boot volume is supported.
	 */</span>
	<span class="enscript-keyword">if</span> ((vfs_flags(HFSTOVFS(hfsmp)) &amp; MNT_ROOTFS) == 0) {
		hfsmp-&gt;hfc_stage = HFC_DISABLED;
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">/* We grab the HFC mutex even though we're not fully mounted yet, just for orderliness */</span>
	lck_mtx_lock (&amp;hfsmp-&gt;hfc_mutex);

	<span class="enscript-comment">/*
	 * Tracking of hot files requires up-to-date access times.
	 * So if access time updates are disabled, then we disable
	 * hot files, too.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_flags(HFSTOVFS(hfsmp)) &amp; MNT_NOATIME) {
		hfsmp-&gt;hfc_stage = HFC_DISABLED;
		lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);
		<span class="enscript-keyword">return</span> EPERM;
	}
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Check if we've been asked to suspend operation
</span>	<span class="enscript-comment">//
</span>	cnid = GetFileInfo(HFSTOVCB(hfsmp), kRootDirID, <span class="enscript-string">&quot;.hotfile-suspend&quot;</span>, &amp;cattr, NULL);
	<span class="enscript-keyword">if</span> (cnid != 0) {
		printf(<span class="enscript-string">&quot;hfs: %s: %s: hotfiles explicitly disabled!  remove /.hotfiles-suspend to re-enable\n&quot;</span>, hfsmp-&gt;vcbVN, __FUNCTION__);
		hfsmp-&gt;hfc_stage = HFC_DISABLED;
		lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Check if we've been asked to reset our state.
</span>	<span class="enscript-comment">//
</span>	cnid = GetFileInfo(HFSTOVCB(hfsmp), kRootDirID, <span class="enscript-string">&quot;.hotfile-reset&quot;</span>, &amp;cattr, NULL);
	<span class="enscript-keyword">if</span> (cnid != 0) {
		hfs_hotfile_reset(hfsmp);
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// Cooperative Fusion (CF) systems use different constants 
</span>		<span class="enscript-comment">// than traditional hotfile systems.  These were picked after a bit of
</span>		<span class="enscript-comment">// experimentation - we can cache many more files on the
</span>		<span class="enscript-comment">// ssd in an CF system and we can do so more rapidly
</span>		<span class="enscript-comment">// so bump the limits considerably (and turn down the
</span>		<span class="enscript-comment">// duration so that it doesn't take weeks to adopt all
</span>		<span class="enscript-comment">// the files).
</span>		<span class="enscript-comment">//
</span>		hfc_default_file_count = 20000;
		hfc_default_duration   = 300;    <span class="enscript-comment">// 5min
</span>		hfc_max_file_count     = 50000;
		hfc_max_file_size      = (512ULL * 1024ULL * 1024ULL);
	}

	<span class="enscript-comment">/*
	 * If the Hot File btree exists then metadata zone is ready.
	 */</span>
	cnid = GetFileInfo(HFSTOVCB(hfsmp), kRootDirID, HFC_FILENAME, &amp;cattr, NULL);
	<span class="enscript-keyword">if</span> (cnid != 0 &amp;&amp; S_ISREG(cattr.ca_mode)) {
		<span class="enscript-type">int</span> recreate = 0;
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_DISABLED)
			hfsmp-&gt;hfc_stage = HFC_IDLE;
		hfsmp-&gt;hfs_hotfile_freeblks = 0;

		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; cattr.ca_blocks &gt; 0) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// make sure the hotfile btree is pinned
</span>			<span class="enscript-comment">//
</span>			error = hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp);
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">/* XXX: must fix hfs_pin_vnode too */</span>
				hfs_pin_vnode(hfsmp, hfsmp-&gt;hfc_filevp, HFS_PIN_IT, NULL, vfs_context_kernel());
				
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;hfs: failed to open the btree err=%d.  Recreating hotfile btree.\n&quot;</span>, error);
				recreate = 1;
			}
			
			hfs_hotfile_repin_files(hfsmp);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp) {
				(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
				hfsmp-&gt;hfc_filevp = NULL;
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-comment">// hmmm, the hotfile btree is zero bytes long?  how odd.  let's recreate it.
</span>			printf(<span class="enscript-string">&quot;hfs: hotfile btree is zero bytes long?!  recreating it.\n&quot;</span>);
			recreate = 1;
		}

		<span class="enscript-keyword">if</span> (!recreate) {
			<span class="enscript-comment">/* don't forget to unlock the mutex */</span>
			lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);
			<span class="enscript-keyword">return</span> (0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// open the hotfile btree file ignoring errors because
</span>			<span class="enscript-comment">// we need the vnode pointer for hfc_btree_delete() to
</span>			<span class="enscript-comment">// be able to do its work
</span>			<span class="enscript-comment">//
</span>			error = hfc_btree_open_ext(hfsmp, &amp;hfsmp-&gt;hfc_filevp, 1);
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">// and delete it!
</span>				error = hfc_btree_delete(hfsmp);
				(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
				hfsmp-&gt;hfc_filevp = NULL;
			}
		}
	}

	printf(<span class="enscript-string">&quot;hfs: %s: %s: creating the hotfile btree\n&quot;</span>, hfsmp-&gt;vcbVN, __FUNCTION__);
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* B-tree creation must be journaled */</span>
	started_tr = 1;

	error = hfc_btree_create(hfsmp, HFSTOVCB(hfsmp)-&gt;blockSize, HFC_DEFAULT_FILE_COUNT);
	<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: Error %d creating hot file b-tree on %s \n&quot;</span>, error, hfsmp-&gt;vcbVN);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">recording_init_out</span>;
	}

	hfs_end_transaction (hfsmp);
	started_tr = 0;
	<span class="enscript-comment">/*
	 * Do a journal flush + flush track cache. We have to ensure that the async I/Os have been issued to the media
	 * before proceeding.
	 */</span>
	hfs_flush (hfsmp, HFS_FLUSH_FULL);

	<span class="enscript-comment">/* now re-start a new transaction */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction (hfsmp) != 0) {
		lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	started_tr = 1;

	<span class="enscript-comment">/*
	 * Open the Hot File B-tree file for writing.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp)
		panic(<span class="enscript-string">&quot;hfs_recording_init: hfc_filevp exists (vp = %p)&quot;</span>, hfsmp-&gt;hfc_filevp);

	error = hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp);
	<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: Error %d opening hot file b-tree on %s \n&quot;</span>, error, hfsmp-&gt;vcbVN);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">recording_init_out</span>;
	}

	<span class="enscript-comment">/*
	 * This function performs work similar to namei; we must NOT hold the catalog lock while
	 * calling it. This will decorate catalog records as being pinning candidates. (no hotfiles work)
	 */</span>
	hfs_setup_default_cf_hotfiles(hfsmp);

	<span class="enscript-comment">/*
	 * now grab the hotfiles b-tree vnode/cnode lock first, as it is not classified as a systemfile.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		error = EPERM;
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		<span class="enscript-comment">/* zero it out to avoid pinning later on */</span>
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">recording_init_out</span>;
	}

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		error = ENOMEM;
		hfs_unlock (VTOC(hfsmp-&gt;hfc_filevp));
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		<span class="enscript-comment">/* zero it out to avoid pinning */</span>
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">recording_init_out</span>;
	}

	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;
	key-&gt;keyLength = HFC_KEYLENGTH;

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(u_int32_t);
	record.itemCount = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: Evaluating space for \&quot;%s\&quot; metadata zone... (freeblks %d)\n&quot;</span>, HFSTOVCB(hfsmp)-&gt;vcbVN,
	       hfsmp-&gt;hfs_hotfile_freeblks);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Get ready to scan the Catalog file. We explicitly do NOT grab the catalog lock because
	 * we're fully single-threaded at the moment (by virtue of being called during mount()),
	 * and if we have to grow the hotfile btree, then we would need to grab the catalog lock
	 * and if we take a shared lock here, it would deadlock (see &lt;rdar://problem/21486585&gt;)
	 *
	 * We already started a transaction so we should already be holding the journal lock at this point.
	 * Note that we have to hold the journal lock / start a txn BEFORE the systemfile locks.
	 */</span>

	error = BTScanInitialize(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), 0, 0, 0,
	                       kCatSearchBufferSize, &amp;scanstate);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_recording_init: err %d BTScanInit\n&quot;</span>, error);

		<span class="enscript-comment">/* drop the systemfile locks */</span>
		hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);

		<span class="enscript-comment">/* zero it out to avoid pinning */</span>
		hfsmp-&gt;hfc_filevp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">recording_init_out</span>;
	}

	started_scan = 1;

	filefork = VTOF(hfsmp-&gt;hfc_filevp);

	starting_temp = random() % HF_TEMP_RANGE;

	<span class="enscript-comment">/*
	 * Visit all the catalog btree leaf records. We have to hold the catalog lock to do this.
	 *
	 * NOTE: The B-Tree scanner reads from the media itself. Under normal circumstances it would be
	 * fine to simply use b-tree routines to read blocks that correspond to b-tree nodes, because the
	 * block cache is going to ensure you always get the cached copy of a block (even if a journal
	 * txn has modified one of those blocks).  That is NOT true when
	 * using the scanner.  In particular, it will always read whatever is on-disk. So we have to ensure
	 * that the journal has flushed and that the async I/Os to the metadata files have been issued.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		error = BTScanNextRecord(&amp;scanstate, 0, (<span class="enscript-type">void</span> **)&amp;keyp, (<span class="enscript-type">void</span> **)&amp;datap, &amp;dataSize);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == btNotFound)
				error = 0;
			<span class="enscript-keyword">else</span>
				printf(<span class="enscript-string">&quot;hfs_recording_init: err %d BTScanNext\n&quot;</span>, error);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((datap-&gt;recordType != kHFSPlusFileRecord) ||
		    (dataSize != <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogFile))) {
			<span class="enscript-keyword">continue</span>;
		}
		filep = (HFSPlusCatalogFile *)datap;
		filecount++;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-keyword">if</span> (filep-&gt;flags &amp; kHFSDoNotFastDevPinMask) {
				uncacheable++;
			}

			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// If the file does not have the FastDevPinnedMask set, we
</span>			<span class="enscript-comment">// can ignore it and just go to the next record.
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">if</span> ((filep-&gt;flags &amp; kHFSFastDevPinnedMask) == 0) {
				<span class="enscript-keyword">continue</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filep-&gt;dataFork.totalBlocks == 0) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * On a regular hdd, any file that has blocks inside
		 * the hot file space is recorded for later eviction.
		 *
		 * For now, resource forks are ignored.
		 *
		 * We don't do this on CF systems as there is no real
		 * hotfile area - we just pin/unpin blocks belonging to
		 * interesting files.
		 */</span>
		<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; !hotextents(hfsmp, &amp;filep-&gt;dataFork.extents[0])) {
			<span class="enscript-keyword">continue</span>;
		}
		cnid = filep-&gt;fileID;

		<span class="enscript-comment">/* Skip over journal files. */</span>
		<span class="enscript-keyword">if</span> (cnid == hfsmp-&gt;hfs_jnlfileid || cnid == hfsmp-&gt;hfs_jnlinfoblkid) {
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * XXX - need to skip quota files as well.
		 */</span>

		uint32_t temp;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-type">int</span> rsrc = 0;

			temp = (uint32_t)starting_temp++;
			<span class="enscript-keyword">if</span> (filep-&gt;flags &amp; kHFSAutoCandidateMask) {
				temp += MAX_NORMAL_TEMP;
			}

			<span class="enscript-comment">/* use the data fork by default */</span>
			<span class="enscript-keyword">if</span> (filep-&gt;dataFork.totalBlocks == 0) {
				<span class="enscript-comment">/*
                 * but if empty, switch to rsrc as its likely
                 * a compressed file
                 */</span>
				rsrc = 1;
			}

			error =  hfs_pin_catalog_rec (hfsmp, filep, rsrc);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

		} <span class="enscript-keyword">else</span> {
			temp = HFC_MINIMUM_TEMPERATURE;
		}

		<span class="enscript-comment">/* Insert a hot file entry. */</span>
		key-&gt;keyLength   = HFC_KEYLENGTH;
		key-&gt;temperature = temp;
		key-&gt;fileID      = cnid;
		key-&gt;forkType    = 0;
		data = 0x3f3f3f3f;
		error = BTInsertRecord(filefork, iterator, &amp;record, record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_recording_init: BTInsertRecord failed %d (fileid %d)\n&quot;</span>, error, key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Insert the corresponding thread record. */</span>
		key-&gt;keyLength = HFC_KEYLENGTH;
		key-&gt;temperature = HFC_LOOKUPTAG;
		key-&gt;fileID = cnid;
		key-&gt;forkType = 0;
		data = temp;
		error = BTInsertRecord(filefork, iterator, &amp;record, record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_recording_init: BTInsertRecord failed %d (fileid %d)\n&quot;</span>, error, key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		inserted++;
	} <span class="enscript-comment">// end catalog iteration loop
</span>
	save_btree_user_info(hfsmp);
	(<span class="enscript-type">void</span>) BTFlushPath(filefork);

<span class="enscript-reference">recording_init_out</span>:

	<span class="enscript-comment">/* Unlock first, then pin after releasing everything else */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp) {
		hfs_unlock (VTOC(hfsmp-&gt;hfc_filevp));
	}

	<span class="enscript-keyword">if</span> (started_scan) {
		(<span class="enscript-type">void</span>) BTScanTerminate (&amp;scanstate, &amp;data, &amp;data, &amp;data);
	}

	<span class="enscript-keyword">if</span> (started_tr) {
		hfs_end_transaction(hfsmp);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: %d files identified out of %d (freeblocks is now: %d)\n&quot;</span>, inserted, filecount, hfsmp-&gt;hfs_hotfile_freeblks);
	<span class="enscript-keyword">if</span> (uncacheable) {
		printf(<span class="enscript-string">&quot;hfs: %d files were marked as uncacheable\n&quot;</span>, uncacheable);
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">if</span> (iterator)
		FREE(iterator, M_TEMP);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp) {
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			hfs_pin_vnode(hfsmp, hfsmp-&gt;hfc_filevp, HFS_PIN_IT, NULL, vfs_context_kernel());
		}
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	}

	<span class="enscript-keyword">if</span> (error == 0)
		hfsmp-&gt;hfc_stage = HFC_IDLE;

	<span class="enscript-comment">/* Finally, unlock the HFC mutex */</span>
	lck_mtx_unlock (&amp;hfsmp-&gt;hfc_mutex);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Use sync to perform ocassional background work.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hotfilesync</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage) {
		<span class="enscript-type">struct</span> timeval tv;

		lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);

		<span class="enscript-keyword">switch</span> (hfsmp-&gt;hfc_stage) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFC_IDLE</span>:
			(<span class="enscript-type">void</span>) hfs_recording_start(hfsmp);
			<span class="enscript-keyword">break</span>;
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFC_RECORDING</span>:
			microtime(&amp;tv);
			<span class="enscript-keyword">if</span> (tv.tv_sec &gt; hfsmp-&gt;hfc_timeout)
				(<span class="enscript-type">void</span>) hfs_recording_stop(hfsmp);
			<span class="enscript-keyword">break</span>;
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFC_EVICTION</span>:
			(<span class="enscript-type">void</span>) hotfiles_evict(hfsmp, ctx);
			<span class="enscript-keyword">break</span>;
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">HFC_ADOPTION</span>:
			(<span class="enscript-type">void</span>) hotfiles_adopt(hfsmp, ctx);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}

		lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Add a hot file to the recording list.
 *
 * This can happen when a hot file gets reclaimed or at the
 * end of the recording period for any active hot file.
 *
 * NOTE: Since both the data and resource fork can  be hot,
 * there can be two entries for the same file id.
 *
 * Note: the cnode is locked on entry.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_addhotfile</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	hfsmount_t *hfsmp;
	<span class="enscript-type">int</span> error;

	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_RECORDING)
		<span class="enscript-keyword">return</span> (0);

	lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);
	error = hfs_addhotfile_internal(vp);
	lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hf_ignore_process</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *pname, size_t maxlen)
{
	<span class="enscript-keyword">if</span> (   strncmp(pname, <span class="enscript-string">&quot;mds&quot;</span>, maxlen) == 0
	    || strncmp(pname, <span class="enscript-string">&quot;mdworker&quot;</span>, maxlen) == 0
	    || strncmp(pname, <span class="enscript-string">&quot;mds_stores&quot;</span>, maxlen) == 0
	    || strncmp(pname, <span class="enscript-string">&quot;makewhatis&quot;</span>, maxlen) == 0) {
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">return</span> 0;
	
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_addhotfile_internal</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	hotfile_data_t *hotdata;
	hotfile_entry_t *entry;
	hfsmount_t *hfsmp;
	cnode_t *cp;
	filefork_t *ffp;
	u_int32_t temperature;

	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_RECORDING)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* 
	 * Only regular files are eligible for hotfiles addition. 
	 * 
	 * Symlinks were previously added to the list and may exist in 
	 * extant hotfiles regions, but no new ones will be added, and no
	 * symlinks will now be relocated/evicted from the hotfiles region.
	 */</span>
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp) || vnode_issystem(vp)) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* Skip resource forks for now. */</span>
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> ((hotdata = (hotfile_data_t *)hfsmp-&gt;hfc_recdata) == NULL) {
		<span class="enscript-keyword">return</span> (0);
	}
	ffp = VTOF(vp);
	cp = VTOC(vp);

	<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_recflags &amp; (kHFSFastDevPinnedMask|kHFSDoNotFastDevPinMask)) {
		<span class="enscript-comment">// it's already a hotfile or can't be a hotfile...
</span>		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (vnode_isdir(vp) || vnode_issystem(vp) || (cp-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS))) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; vnode_isfastdevicecandidate(vp)) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// On cooperative fusion (CF) systems we have different criteria for whether something
</span>		<span class="enscript-comment">// can be pinned to the ssd.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; (C_DELETED|C_NOEXISTS)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// dead files are definitely not worth caching
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">return</span> 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ffp-&gt;ff_blocks == 0 &amp;&amp; !(cp-&gt;c_bsdflags &amp; UF_COMPRESSED) &amp;&amp; !(cp-&gt;c_attr.ca_recflags &amp; kHFSFastDevCandidateMask)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// empty files aren't worth caching but compressed ones might be, as are 
</span>			<span class="enscript-comment">// newly created files that live in WorthCaching directories... 
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-type">char</span> pname[256];
		pname[0] = <span class="enscript-string">'\0'</span>;
		proc_selfname(pname, <span class="enscript-keyword">sizeof</span>(pname));
		<span class="enscript-keyword">if</span> (hf_ignore_process(pname, <span class="enscript-keyword">sizeof</span>(pname))) {
			<span class="enscript-comment">// ignore i/o's from certain system daemons 
</span>			<span class="enscript-keyword">return</span> 0;
		}

		temperature = cp-&gt;c_fileid;        <span class="enscript-comment">// in memory we just keep it sorted by file-id
</span>	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">// the normal hard drive based hotfile checks
</span>		<span class="enscript-keyword">if</span> ((ffp-&gt;ff_bytesread == 0) ||
		    (ffp-&gt;ff_blocks == 0) ||
		    (ffp-&gt;ff_size == 0) ||
		    (ffp-&gt;ff_blocks &gt; hotdata-&gt;maxblocks) ||
		    (cp-&gt;c_bsdflags &amp; (UF_NODUMP | UF_COMPRESSED)) ||
		    (cp-&gt;c_atime &lt; hfsmp-&gt;hfc_timebase)) {
			<span class="enscript-keyword">return</span> (0);
		}

		temperature = ffp-&gt;ff_bytesread / ffp-&gt;ff_size;
		<span class="enscript-keyword">if</span> (temperature &lt; hotdata-&gt;threshold) {
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-comment">/*
	 * If there is room or this file is hotter than
	 * the coldest one then add it to the list.
	 *
	 */</span>
	<span class="enscript-keyword">if</span> ((hotdata-&gt;activefiles &lt; hfsmp-&gt;hfc_maxfiles) ||
	    (hotdata-&gt;coldest == NULL) ||
	    (temperature &gt;= hotdata-&gt;coldest-&gt;temperature)) {
		++hotdata-&gt;refcount;
		entry = hf_getnewentry(hotdata);
		entry-&gt;temperature = temperature;
		entry-&gt;fileid = cp-&gt;c_fileid;
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// if ffp-&gt;ff_blocks is zero, it might be compressed so make sure we record
</span>		<span class="enscript-comment">// that there's at least one block.
</span>		<span class="enscript-comment">//
</span>		entry-&gt;blocks = ffp-&gt;ff_blocks ? ffp-&gt;ff_blocks : 1;   
		<span class="enscript-keyword">if</span> (hf_insert(hotdata, entry) == EEXIST) {
			<span class="enscript-comment">// entry is already present, don't need to add it again
</span>			entry-&gt;right = hotdata-&gt;freelist;
			hotdata-&gt;freelist = entry;
		}
		--hotdata-&gt;refcount;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Remove a hot file from the recording list.
 *
 * This can happen when a hot file becomes
 * an active vnode (active hot files are
 * not kept in the recording list until the
 * end of the recording period).
 *
 * Note: the cnode is locked on entry.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_removehotfile</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	hotfile_data_t *hotdata;
	hfsmount_t *hfsmp;
	cnode_t *cp;
	filefork_t *ffp;
	u_int32_t temperature;

	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_RECORDING)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((!vnode_isreg(vp)) || vnode_issystem(vp)) {
		<span class="enscript-keyword">return</span> (0);
	}

	ffp = VTOF(vp);
	cp = VTOC(vp);

	<span class="enscript-keyword">if</span> ((ffp-&gt;ff_bytesread == 0) || (ffp-&gt;ff_blocks == 0) ||
	    (ffp-&gt;ff_size == 0) || (cp-&gt;c_atime &lt; hfsmp-&gt;hfc_timebase)) {
		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_RECORDING)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((hotdata = (hotfile_data_t *)hfsmp-&gt;hfc_recdata) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	temperature = ffp-&gt;ff_bytesread / ffp-&gt;ff_size;
	<span class="enscript-keyword">if</span> (temperature &lt; hotdata-&gt;threshold)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (hotdata-&gt;coldest &amp;&amp; (temperature &gt;= hotdata-&gt;coldest-&gt;temperature)) {
		++hotdata-&gt;refcount;
		hf_delete(hotdata, VTOC(vp)-&gt;c_fileid, temperature);
		--hotdata-&gt;refcount;
	}
<span class="enscript-reference">out</span>:
	lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hotfile_deleted</span>(__unused <span class="enscript-type">struct</span> vnode *vp)
{
#<span class="enscript-reference">if</span> 1
	<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">else</span>	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// XXXdbg - this code, while it would work, would introduce a huge inefficiency
</span>	<span class="enscript-comment">//          to deleting files as the way it's written would require us to open
</span>	<span class="enscript-comment">//          the hotfile btree on every open, delete two records in it and then
</span>	<span class="enscript-comment">//          close the hotfile btree (which involves more writes).
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//          We actually can be lazy about deleting hotfile records for files
</span>	<span class="enscript-comment">//          that get deleted.  When it's time to evict things, if we encounter
</span>	<span class="enscript-comment">//          a record that references a dead file (i.e. a fileid which no
</span>	<span class="enscript-comment">//          longer exists), the eviction code will remove the records.  Likewise
</span>	<span class="enscript-comment">//          the code that scans the HotFile B-Tree at boot time to re-pin files
</span>	<span class="enscript-comment">//          will remove dead records.
</span>	<span class="enscript-comment">//
</span>
	hotfile_data_t *hotdata;
	hfsmount_t *hfsmp;
	cnode_t *cp;
	filefork_t *filefork;
	u_int32_t temperature;
	BTreeIterator * iterator = NULL;
	FSBufferDescriptor record;
	HotFileKey *key;
	u_int32_t data;
	<span class="enscript-type">int</span> error=0;

	cp = VTOC(vp);
	<span class="enscript-keyword">if</span> (cp == NULL || !(cp-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask)) {
		<span class="enscript-keyword">return</span> 0;
	}

	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-keyword">if</span> (hfc_btree_open(hfsmp, &amp;hfsmp-&gt;hfc_filevp) != 0 || hfsmp-&gt;hfc_filevp == NULL) {
		<span class="enscript-comment">// either there is no hotfile info or it's damaged
</span>		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	filefork = VTOF(hfsmp-&gt;hfc_filevp);
	<span class="enscript-keyword">if</span> (filefork == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}	
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(u_int32_t);
	record.itemCount = 1;

	key-&gt;keyLength = HFC_KEYLENGTH;
	key-&gt;temperature = HFC_LOOKUPTAG;
	key-&gt;fileID = cp-&gt;c_fileid;
	key-&gt;forkType = 0;

	lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);
	(<span class="enscript-type">void</span>) BTInvalidateHint(iterator);
	<span class="enscript-keyword">if</span> (BTSearchRecord(filefork, iterator, &amp;record, NULL, iterator) == 0) {
		temperature = key-&gt;temperature;
		hfc_btree_delete_record(hfsmp, iterator, key);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">//printf(&quot;hfs: hotfile_deleted: did not find fileid %d\n&quot;, cp-&gt;c_fileid);
</span>		error = ENOENT;
	}

	<span class="enscript-keyword">if</span> ((hotdata = (hotfile_data_t *)hfsmp-&gt;hfc_recdata) != NULL) {
		<span class="enscript-comment">// just in case, also make sure it's removed from the in-memory list as well
</span>		++hotdata-&gt;refcount;
		hf_delete(hotdata, cp-&gt;c_fileid, cp-&gt;c_fileid);
		--hotdata-&gt;refcount;
	}

	lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
	FREE(iterator, M_TEMP);

	hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
	
	<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hotfile_adjust_blocks</span>(<span class="enscript-type">struct</span> vnode *vp, int64_t num_blocks)
{
	hfsmount_t *hfsmp;
	
	<span class="enscript-keyword">if</span> (vp == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) || num_blocks == 0 || vp == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if file is not HotFileCached or it has the CanNotHotFile cache
</span>	<span class="enscript-comment">// bit set then there is nothing to do
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (!(VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask) || (VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSDoNotFastDevPinMask)) {
		<span class="enscript-comment">// it's not a hot file or can't be one so don't bother tracking
</span>		<span class="enscript-keyword">return</span> 0;
	}
	
	OSAddAtomic(num_blocks, &amp;hfsmp-&gt;hfs_hotfile_blk_adjust);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Assumes hfsmp-&gt;hfc_mutex is LOCKED
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hotfile_cur_freeblks</span>(hfsmount_t *hfsmp)
{
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage &lt; HFC_IDLE) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-type">int</span> cur_blk_adjust = hfsmp-&gt;hfs_hotfile_blk_adjust;   <span class="enscript-comment">// snap a copy of this value
</span>
	<span class="enscript-keyword">if</span> (cur_blk_adjust) {
		OSAddAtomic(-cur_blk_adjust, &amp;hfsmp-&gt;hfs_hotfile_blk_adjust);
		hfsmp-&gt;hfs_hotfile_freeblks += cur_blk_adjust;
	}

	<span class="enscript-keyword">return</span> hfsmp-&gt;hfs_hotfile_freeblks;
}


<span class="enscript-comment">/*
 *========================================================================
 *                     HOT FILE MAINTENANCE ROUTINES
 *========================================================================
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_collect_callback</span>(<span class="enscript-type">struct</span> vnode *vp, __unused <span class="enscript-type">void</span> *cargs)
{
        <span class="enscript-keyword">if</span> ((vnode_isreg(vp)) &amp;&amp; !vnode_issystem(vp))
	        (<span class="enscript-type">void</span>) hfs_addhotfile_internal(vp);

	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}

<span class="enscript-comment">/*
 * Add all active hot files to the recording list.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_collect</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">struct</span> mount *mp = HFSTOVFS(hfsmp);

	<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * hotfiles_collect_callback will be called for each vnode
	 * hung off of this mount point
	 * the vnode will be
	 * properly referenced and unreferenced around the callback
	 */</span>
	vnode_iterate(mp, 0, hotfiles_collect_callback, (<span class="enscript-type">void</span> *)NULL);

	vfs_unbusy(mp);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Update the data of a btree record
 * This is called from within BTUpdateRecord.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">update_callback</span>(<span class="enscript-type">const</span> HotFileKey *key, u_int32_t *data, u_int32_t *state)
{
	<span class="enscript-keyword">if</span> (key-&gt;temperature == HFC_LOOKUPTAG)
		*data = *state;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Identify files already in hot area.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_refine</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	BTreeIterator * iterator = NULL;
	<span class="enscript-type">struct</span> mount *mp;
	filefork_t * filefork;
	hotfilelist_t  *listp;
	FSBufferDescriptor  record;
	HotFileKey * key;
	u_int32_t  data;
	<span class="enscript-type">int</span>  i;
	<span class="enscript-type">int</span>  error = 0;

	<span class="enscript-keyword">if</span> ((listp = (hotfilelist_t  *)hfsmp-&gt;hfc_recdata) == NULL)
		<span class="enscript-keyword">return</span> (0);	

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		<span class="enscript-comment">// on ssd's we don't refine the temperature since the
</span>		<span class="enscript-comment">// replacement algorithm is simply random
</span>		<span class="enscript-keyword">return</span> 0;
	}

	mp = HFSTOVFS(hfsmp);

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(u_int32_t);
	record.itemCount = 1;

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	filefork = VTOF(hfsmp-&gt;hfc_filevp);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; listp-&gt;hfl_count; ++i) {
		<span class="enscript-comment">/*
		 * Check if entry (thread) is already in hot area.
		 */</span>
		key-&gt;keyLength = HFC_KEYLENGTH;
		key-&gt;temperature = HFC_LOOKUPTAG;
		key-&gt;fileID = listp-&gt;hfl_hotfile[i].hf_fileid;
		key-&gt;forkType = 0;
		(<span class="enscript-type">void</span>) BTInvalidateHint(iterator);
		<span class="enscript-keyword">if</span> (BTSearchRecord(filefork, iterator, &amp;record, NULL, iterator) != 0) {
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* not in hot area, so skip */</span>
		}

		<span class="enscript-comment">/*
		 * Update thread entry with latest temperature.
		 */</span>
		error = BTUpdateRecord(filefork, iterator,
				       (IterateCallBackProcPtr)update_callback,
				      &amp;listp-&gt;hfl_hotfile[i].hf_temperature);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs: hotfiles_refine: BTUpdateRecord failed %d (file %d)\n&quot;</span>, error, key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-comment">//	break;
</span>		}
		<span class="enscript-comment">/*
		 * Re-key entry with latest temperature.
		 */</span>
		key-&gt;keyLength = HFC_KEYLENGTH;
		key-&gt;temperature = data;
		key-&gt;fileID = listp-&gt;hfl_hotfile[i].hf_fileid;
		key-&gt;forkType = 0;
		<span class="enscript-comment">/* Pick up record data. */</span>
		(<span class="enscript-type">void</span>) BTInvalidateHint(iterator);
		(<span class="enscript-type">void</span>) BTSearchRecord(filefork, iterator, &amp;record, NULL, iterator);
		error = BTDeleteRecord(filefork, iterator);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs: hotfiles_refine: BTDeleteRecord failed %d (file %d)\n&quot;</span>, error, key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		key-&gt;keyLength = HFC_KEYLENGTH;
		key-&gt;temperature = listp-&gt;hfl_hotfile[i].hf_temperature;
		key-&gt;fileID = listp-&gt;hfl_hotfile[i].hf_fileid;
		key-&gt;forkType = 0;
		error = BTInsertRecord(filefork, iterator, &amp;record, record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs: hotfiles_refine: BTInsertRecord failed %d (file %d)\n&quot;</span>, error, key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Invalidate this entry in the list.
		 */</span>
		listp-&gt;hfl_hotfile[i].hf_temperature = 0;
		listp-&gt;hfl_totalblocks -= listp-&gt;hfl_hotfile[i].hf_blocks;
		
	} <span class="enscript-comment">/* end for */</span>

	(<span class="enscript-type">void</span>) BTFlushPath(filefork);
	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

<span class="enscript-reference">out1</span>:
	hfs_end_transaction(hfsmp);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (iterator)
		FREE(iterator, M_TEMP);	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Move new hot files into hot area.
 *
 * Requires that the hfc_mutex be held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_adopt</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, vfs_context_t ctx)
{
	BTreeIterator * iterator = NULL;
	<span class="enscript-type">struct</span> vnode *vp;
	filefork_t * filefork;
	hotfilelist_t  *listp;
	FSBufferDescriptor  record;
	HotFileKey * key;
	u_int32_t  data;
	<span class="enscript-type">enum</span> hfc_stage stage;
	<span class="enscript-type">int</span>  fileblocks;
	<span class="enscript-type">int</span>  blksmoved;
	<span class="enscript-type">int</span>  i;
	<span class="enscript-type">int</span>  last;
	<span class="enscript-type">int</span>  error = 0;
	<span class="enscript-type">int</span>  startedtrans = 0;
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// all files in a given adoption phase have a temperature
</span>	<span class="enscript-comment">// that starts at a random value and then increases linearly.
</span>	<span class="enscript-comment">// the idea is that during eviction, files that were adopted
</span>	<span class="enscript-comment">// together will be evicted together
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-type">long</span> starting_temp = random() % HF_TEMP_RANGE;
	<span class="enscript-type">long</span> temp_adjust = 0;

	<span class="enscript-keyword">if</span> ((listp = (hotfilelist_t  *)hfsmp-&gt;hfc_recdata) == NULL)
		<span class="enscript-keyword">return</span> (0);	

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_ADOPTION) {
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs:%s: hotfiles_adopt: (hfl_next: %d, hotfile start/end block: %d - %d; max/free: %d/%d; maxfiles: %d)\n&quot;</span>,
		       hfsmp-&gt;vcbVN,
		       listp-&gt;hfl_next,
		       hfsmp-&gt;hfs_hotfile_start, hfsmp-&gt;hfs_hotfile_end,
		       hfsmp-&gt;hfs_hotfile_maxblks, hfsmp-&gt;hfs_hotfile_freeblks, hfsmp-&gt;hfc_maxfiles);
#<span class="enscript-reference">endif</span>

	stage = hfsmp-&gt;hfc_stage;
	hfsmp-&gt;hfc_stage = HFC_BUSY;

	blksmoved = 0;
	last = listp-&gt;hfl_next + HFC_FILESPERSYNC;
	<span class="enscript-keyword">if</span> (last &gt; listp-&gt;hfl_count)
		last = listp-&gt;hfl_count;

	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;
	key-&gt;keyLength = HFC_KEYLENGTH;

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(u_int32_t);
	record.itemCount = 1;

	filefork = VTOF(hfsmp-&gt;hfc_filevp);

	<span class="enscript-keyword">for</span> (i = listp-&gt;hfl_next; (i &lt; last) &amp;&amp; (blksmoved &lt; HFC_BLKSPERSYNC); ++i) {
		<span class="enscript-comment">/*
		 * Skip entries that aren't going to work.
		 */</span>
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_hotfile[i].hf_temperature == 0) {
			<span class="enscript-comment">//printf(&quot;hfs: zero temp on file-id %d\n&quot;, listp-&gt;hfl_hotfile[i].hf_fileid);
</span>			listp-&gt;hfl_next++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_hotfile[i].hf_fileid == VTOC(hfsmp-&gt;hfc_filevp)-&gt;c_fileid) {
			<span class="enscript-comment">//printf(&quot;hfs: cannot adopt the hotfile b-tree itself! (file-id %d)\n&quot;, listp-&gt;hfl_hotfile[i].hf_fileid);
</span>			listp-&gt;hfl_next++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_hotfile[i].hf_fileid &lt; kHFSFirstUserCatalogNodeID) {
			<span class="enscript-comment">//printf(&quot;hfs: cannot adopt system files (file-id %d)\n&quot;, listp-&gt;hfl_hotfile[i].hf_fileid);
</span>			listp-&gt;hfl_next++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Acquire a vnode for this file.
		 */</span>
		error = hfs_vget(hfsmp, listp-&gt;hfl_hotfile[i].hf_fileid, &amp;vp, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">//printf(&quot;failed to get fileid %d (err %d)\n&quot;, listp-&gt;hfl_hotfile[i].hf_fileid, error);
</span>			<span class="enscript-keyword">if</span> (error == ENOENT) {
				error = 0;
				listp-&gt;hfl_next++;
				<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">//printf(&quot;hfs: examining hotfile entry w/fileid %d, temp %d, blocks %d (HotFileCached: %s)\n&quot;,
</span>		<span class="enscript-comment">//       listp-&gt;hfl_hotfile[i].hf_fileid, listp-&gt;hfl_hotfile[i].hf_temperature,
</span>		<span class="enscript-comment">//       listp-&gt;hfl_hotfile[i].hf_blocks,
</span>		<span class="enscript-comment">//       (VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask) ? &quot;YES&quot; : &quot;NO&quot;);
</span>
		<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
			<span class="enscript-comment">/* Symlinks are ineligible for adoption into the hotfile zone.  */</span>
			<span class="enscript-comment">//printf(&quot;hfs: hotfiles_adopt: huh, not a file %d (%d)\n&quot;, listp-&gt;hfl_hotfile[i].hf_fileid, VTOC(vp)-&gt;c_cnid);
</span>			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			listp-&gt;hfl_hotfile[i].hf_temperature = 0;
			listp-&gt;hfl_next++;
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
		}
		<span class="enscript-keyword">if</span> (   (VTOC(vp)-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS))
		    || (!(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; hotextents(hfsmp, &amp;VTOF(vp)-&gt;ff_extents[0]))
		    || (VTOC(vp)-&gt;c_attr.ca_recflags &amp; (kHFSFastDevPinnedMask|kHFSDoNotFastDevPinMask))) {
			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			listp-&gt;hfl_hotfile[i].hf_temperature = 0;
			listp-&gt;hfl_next++;
			listp-&gt;hfl_totalblocks -= listp-&gt;hfl_hotfile[i].hf_blocks;
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
		}

		fileblocks = VTOF(vp)-&gt;ff_blocks;

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// for CF, if the file is empty (and not compressed) or it is too large,
</span>		<span class="enscript-comment">// do not try to pin it.  (note: if fileblocks == 0 but the file is marked
</span>		<span class="enscript-comment">// as compressed, we may still be able to cache it).
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp;
		    ((fileblocks == 0 &amp;&amp; !(VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED)) ||
		     (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)fileblocks &gt; (HFC_MAXIMUM_FILESIZE / (uint64_t)HFSTOVCB(hfsmp)-&gt;blockSize))) {
			<span class="enscript-comment">// don't try to cache something too large or that's zero-bytes
</span>
			vnode_clearfastdevicecandidate(vp);    <span class="enscript-comment">// turn off the fast-dev-candidate flag so we don't keep trying to cache it.
</span>
			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			listp-&gt;hfl_hotfile[i].hf_temperature = 0;
			listp-&gt;hfl_next++;
			listp-&gt;hfl_totalblocks -= listp-&gt;hfl_hotfile[i].hf_blocks;
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* entry is too big, just carry on with the next guy */</span>
		}

		<span class="enscript-keyword">if</span> (fileblocks &gt; hfs_hotfile_cur_freeblks(hfsmp)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// No room for this file.  Although eviction should have made space
</span>			<span class="enscript-comment">// it's best that we check here as well since writes to existing
</span>			<span class="enscript-comment">// hotfiles may have eaten up space since we performed eviction
</span>			<span class="enscript-comment">//
</span>			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			listp-&gt;hfl_next++;
			listp-&gt;hfl_totalblocks -= fileblocks;
			<span class="enscript-keyword">continue</span>;  <span class="enscript-comment">/* entry too big, go to next */</span>
		}
		
		<span class="enscript-keyword">if</span> ((blksmoved &gt; 0) &amp;&amp;
		    (blksmoved + fileblocks) &gt; HFC_BLKSPERSYNC) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// we've done enough work, let's be nice to the system and
</span>			<span class="enscript-comment">// stop until the next iteration
</span>			<span class="enscript-comment">//
</span>			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* adopt this entry the next time around */</span>
		}
		<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_desc.cd_nameptr)
			data = *(<span class="enscript-type">const</span> u_int32_t *)(VTOC(vp)-&gt;c_desc.cd_nameptr);
		<span class="enscript-keyword">else</span>
			data = 0x3f3f3f3f;


		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// For CF we pin the blocks belonging to the file
</span>			<span class="enscript-comment">// to the &quot;fast&quot; (aka ssd) media
</span>			<span class="enscript-comment">//
</span>			uint32_t pinned_blocks;

			<span class="enscript-keyword">if</span> (vnode_isautocandidate(vp)) {
				VTOC(vp)-&gt;c_attr.ca_recflags |= kHFSAutoCandidateMask;
			}
			<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSAutoCandidateMask) {
				<span class="enscript-comment">//
</span>				<span class="enscript-comment">// this moves auto-cached files to the higher tier 
</span>				<span class="enscript-comment">// of &quot;temperatures&quot; which means they are less likely
</span>				<span class="enscript-comment">// to get evicted (user selected hotfiles will get
</span>				<span class="enscript-comment">// evicted first in the theory that they change more
</span>				<span class="enscript-comment">// frequently compared to system files)
</span>				<span class="enscript-comment">//
</span>				temp_adjust = MAX_NORMAL_TEMP;
			} <span class="enscript-keyword">else</span> {
				temp_adjust = 0;
			}

			hfs_unlock(VTOC(vp));  <span class="enscript-comment">// don't need an exclusive lock for this
</span>			hfs_lock(VTOC(vp), HFS_SHARED_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

			error = hfs_pin_vnode(hfsmp, vp, HFS_PIN_IT, &amp;pinned_blocks, ctx);

			fileblocks = pinned_blocks;

			<span class="enscript-comment">// go back to an exclusive lock since we're going to modify the cnode again
</span>			hfs_unlock(VTOC(vp));
			hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// Old style hotfiles moves the data to the center (aka &quot;hot&quot;)
</span>			<span class="enscript-comment">// region of the disk
</span>			<span class="enscript-comment">//
</span>			error = hfs_relocate(vp, hfsmp-&gt;hfs_hotfile_start, kauth_cred_get(), current_proc());
		}

		<span class="enscript-keyword">if</span> (!error) {
			VTOC(vp)-&gt;c_attr.ca_recflags |= kHFSFastDevPinnedMask;
			VTOC(vp)-&gt;c_flag |= C_MODIFIED;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; error == EALREADY) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// If hfs_pin_vnode() returned EALREADY then this file is not
</span>			<span class="enscript-comment">// ever able to be hotfile cached the normal way.  This can
</span>			<span class="enscript-comment">// happen with compressed files which have their data stored
</span>			<span class="enscript-comment">// in an extended attribute.  We flag them so that we won't
</span>			<span class="enscript-comment">// bother to try and hotfile cache them again the next time
</span>			<span class="enscript-comment">// they're read.
</span>			<span class="enscript-comment">//
</span>			VTOC(vp)-&gt;c_attr.ca_recflags |= kHFSDoNotFastDevPinMask;
			VTOC(vp)-&gt;c_flag |= C_MODIFIED;
		}

		hfs_unlock(VTOC(vp));
		vnode_put(vp);
		<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			<span class="enscript-keyword">if</span> (error != EALREADY) {
				printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt: could not relocate file %d (err %d)\n&quot;</span>, listp-&gt;hfl_hotfile[i].hf_fileid, error);
			}
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (last &lt; listp-&gt;hfl_count) {
				last++;
			}
			<span class="enscript-comment">/* Move on to next item. */</span>
			listp-&gt;hfl_next++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* Keep hot file free space current. */</span>
		hfsmp-&gt;hfs_hotfile_freeblks -= fileblocks;
		listp-&gt;hfl_totalblocks -= fileblocks;
		
		<span class="enscript-comment">/* Insert hot file entry */</span>
		key-&gt;keyLength   = HFC_KEYLENGTH;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// The &quot;temperature&quot; for a CF hotfile is simply a random
</span>			<span class="enscript-comment">// number that we sequentially increment for each file in
</span>			<span class="enscript-comment">// the set of files we're currently adopting.  This has the
</span>			<span class="enscript-comment">// nice property that all of the files we pin to the ssd
</span>			<span class="enscript-comment">// in the current phase will sort together in the hotfile
</span>			<span class="enscript-comment">// btree.  When eviction time comes we will evict them
</span>			<span class="enscript-comment">// together as well.  This gives the eviction phase temporal
</span>			<span class="enscript-comment">// locality - things written together get evicted together
</span>			<span class="enscript-comment">// which is what ssd's like.
</span>			<span class="enscript-comment">//
</span>			listp-&gt;hfl_hotfile[i].hf_temperature = (uint32_t)temp_adjust + starting_temp++;
		}

		key-&gt;temperature = listp-&gt;hfl_hotfile[i].hf_temperature;
		key-&gt;fileID      = listp-&gt;hfl_hotfile[i].hf_fileid;
		key-&gt;forkType    = 0;

		<span class="enscript-comment">/* Start a new transaction before calling BTree code. */</span>
		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		    error = EINVAL;
		    <span class="enscript-keyword">break</span>;
		}
		startedtrans = 1;

		error = BTInsertRecord(filefork, iterator, &amp;record, record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-type">int</span> orig_error = error;
			error = MacToVFSError(error);
			printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt:1: BTInsertRecord failed %d/%d (fileid %d)\n&quot;</span>, error, orig_error, key-&gt;fileID);
			stage = HFC_IDLE;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Insert thread record */</span>
		key-&gt;keyLength = HFC_KEYLENGTH;
		key-&gt;temperature = HFC_LOOKUPTAG;
		key-&gt;fileID = listp-&gt;hfl_hotfile[i].hf_fileid;
		key-&gt;forkType = 0;
		data = listp-&gt;hfl_hotfile[i].hf_temperature;
		error = BTInsertRecord(filefork, iterator, &amp;record, record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-type">int</span> orig_error = error;
			error = MacToVFSError(error);
			printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt:2: BTInsertRecord failed %d/%d (fileid %d)\n&quot;</span>, error, orig_error, key-&gt;fileID);
			stage = HFC_IDLE;
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			(<span class="enscript-type">void</span>) BTFlushPath(filefork);
			blksmoved += fileblocks;
		}

		listp-&gt;hfl_next++;
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_next &gt;= listp-&gt;hfl_count) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Transaction complete. */</span>
		<span class="enscript-keyword">if</span> (startedtrans) {
		    hfs_end_transaction(hfsmp);
		    startedtrans = 0;
		}

		<span class="enscript-keyword">if</span> (hfs_hotfile_cur_freeblks(hfsmp) &lt;= 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt: free space exhausted (%d)\n&quot;</span>, hfsmp-&gt;hfs_hotfile_freeblks);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-comment">/* end for */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt: [%d] adopted %d blocks (%d files left)\n&quot;</span>, listp-&gt;hfl_next, blksmoved, listp-&gt;hfl_count - i);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (!startedtrans) {
		<span class="enscript-comment">// start a txn so we'll save the btree summary info
</span>		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) == 0) {
			startedtrans = 1;
		}
	}		

	<span class="enscript-comment">/* Finish any outstanding transactions. */</span>
	<span class="enscript-keyword">if</span> (startedtrans) {
		save_btree_user_info(hfsmp);

		(<span class="enscript-type">void</span>) BTFlushPath(filefork);
		hfs_end_transaction(hfsmp);
		startedtrans = 0;
	}
	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

	<span class="enscript-keyword">if</span> ((listp-&gt;hfl_next &gt;= listp-&gt;hfl_count) || (hfsmp-&gt;hfs_hotfile_freeblks &lt;= 0)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt: all done relocating %d files\n&quot;</span>, listp-&gt;hfl_count);
		printf(<span class="enscript-string">&quot;hfs: hotfiles_adopt: %d blocks free in hot file band\n&quot;</span>, hfsmp-&gt;hfs_hotfile_freeblks);
#<span class="enscript-reference">endif</span>
		stage = HFC_IDLE;
	}
	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">if</span> (stage != HFC_ADOPTION &amp;&amp; hfsmp-&gt;hfc_filevp) {
		(<span class="enscript-type">void</span>) hfc_btree_close(hfsmp, hfsmp-&gt;hfc_filevp);
		hfsmp-&gt;hfc_filevp = NULL;
	}
	hfsmp-&gt;hfc_stage = stage;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Reclaim space by evicting the coldest files.
 *
 * Requires that the hfc_mutex be held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_evict</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, vfs_context_t ctx)
{
	BTreeIterator * iterator = NULL;
	<span class="enscript-type">struct</span> vnode *vp;
	HotFileKey * key;
	filefork_t * filefork;
	hotfilelist_t  *listp;
	<span class="enscript-type">enum</span> hfc_stage stage;
	u_int32_t savedtemp;
	<span class="enscript-type">int</span>  blksmoved;
	<span class="enscript-type">int</span>  filesmoved;
	<span class="enscript-type">int</span>  fileblocks;
	<span class="enscript-type">int</span>  error = 0;
	<span class="enscript-type">int</span>  startedtrans = 0;
	<span class="enscript-type">int</span>  bt_op;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage != HFC_EVICTION) {
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-keyword">if</span> ((listp = (hotfilelist_t  *)hfsmp-&gt;hfc_recdata) == NULL)
		<span class="enscript-keyword">return</span> (0);	

	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs:%s: hotfiles_evict (hotfile start/end block: %d - %d; max/free: %d/%d; maxfiles: %d)\n&quot;</span>,
		       hfsmp-&gt;vcbVN,
		       hfsmp-&gt;hfs_hotfile_start, hfsmp-&gt;hfs_hotfile_end,
		       hfsmp-&gt;hfs_hotfile_maxblks, hfsmp-&gt;hfs_hotfile_freeblks, hfsmp-&gt;hfc_maxfiles);
#<span class="enscript-reference">endif</span>

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	stage = hfsmp-&gt;hfc_stage;
	hfsmp-&gt;hfc_stage = HFC_BUSY;

	filesmoved = blksmoved = 0;
	bt_op = kBTreeFirstRecord;

	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;

	filefork = VTOF(hfsmp-&gt;hfc_filevp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: reclaim blks %d\n&quot;</span>, listp-&gt;hfl_reclaimblks);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">while</span> (listp-&gt;hfl_reclaimblks &gt; 0 &amp;&amp;
	       blksmoved &lt; HFC_BLKSPERSYNC &amp;&amp;
	       filesmoved &lt; HFC_FILESPERSYNC) {

		<span class="enscript-comment">/*
		 * Obtain the first record (ie the coldest one).
		 */</span>
		<span class="enscript-keyword">if</span> (BTIterateRecord(filefork, bt_op, iterator, NULL, NULL) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: no more records\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			error = 0;
			stage = HFC_ADOPTION;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (key-&gt;keyLength != HFC_KEYLENGTH) {
			printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: invalid key length %d\n&quot;</span>, key-&gt;keyLength);
			error = EFTYPE;
			<span class="enscript-keyword">break</span>;
		}		
		<span class="enscript-keyword">if</span> (key-&gt;temperature == HFC_LOOKUPTAG) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: ran into thread records\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			error = 0;
			stage = HFC_ADOPTION;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Aquire the vnode for this file.
		 */</span>
		error = hfs_vget(hfsmp, key-&gt;fileID, &amp;vp, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ENOENT) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">delete</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: err %d getting file %d\n&quot;</span>,
				       error, key-&gt;fileID);
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* 
		 * Symlinks that may have been inserted into the hotfile zone during a previous OS are now stuck 
		 * here.  We do not want to move them. 
		 */</span>
		<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
			<span class="enscript-comment">//printf(&quot;hfs: hotfiles_evict: huh, not a file %d\n&quot;, key-&gt;fileID);
</span>			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">delete</span>;  <span class="enscript-comment">/* invalid entry, go to next */</span>
		}

		fileblocks = VTOF(vp)-&gt;ff_blocks;
		<span class="enscript-keyword">if</span> ((blksmoved &gt; 0) &amp;&amp;
		    (blksmoved + fileblocks) &gt; HFC_BLKSPERSYNC) {
			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Make sure file is in the hot area.
		 */</span>
		<span class="enscript-keyword">if</span> (!hotextents(hfsmp, &amp;VTOF(vp)-&gt;ff_extents[0]) &amp;&amp; !(VTOC(vp)-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: file %d isn't hot!\n&quot;</span>, key-&gt;fileID);
#<span class="enscript-reference">endif</span>
			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">delete</span>;  <span class="enscript-comment">/* stale entry, go to next */</span>
		}
		
		<span class="enscript-comment">/*
		 * Relocate file out of hot area.  On cooperative fusion (CF) that just 
		 * means un-pinning the data from the ssd.  For traditional hotfiles that means moving
		 * the file data out of the hot region of the disk.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			uint32_t pinned_blocks;
			
			hfs_unlock(VTOC(vp));  <span class="enscript-comment">// don't need an exclusive lock for this
</span>			hfs_lock(VTOC(vp), HFS_SHARED_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

			error = hfs_pin_vnode(hfsmp, vp, HFS_UNPIN_IT, &amp;pinned_blocks, ctx);
			fileblocks = pinned_blocks;

			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">// go back to an exclusive lock since we're going to modify the cnode again
</span>				hfs_unlock(VTOC(vp));
				hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
			}
		} <span class="enscript-keyword">else</span> {
			error = hfs_relocate(vp, HFSTOVCB(hfsmp)-&gt;nextAllocation, vfs_context_ucred(ctx), vfs_context_proc(ctx));
		}
		<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
			printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: err %d relocating file %d\n&quot;</span>, error, key-&gt;fileID);
#<span class="enscript-reference">endif</span>
			hfs_unlock(VTOC(vp));
			vnode_put(vp);
			bt_op = kBTreeNextRecord;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;  <span class="enscript-comment">/* go to next */</span>
		} <span class="enscript-keyword">else</span> {
			VTOC(vp)-&gt;c_attr.ca_recflags &amp;= ~kHFSFastDevPinnedMask;
			VTOC(vp)-&gt;c_flag |= C_MODIFIED;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// We do not believe that this call to hfs_fsync() is
</span>		<span class="enscript-comment">// necessary and it causes a journal transaction
</span>		<span class="enscript-comment">// deadlock so we are removing it.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// (void) hfs_fsync(vp, MNT_WAIT, 0, p);
</span>
		hfs_unlock(VTOC(vp));
		vnode_put(vp);

		hfsmp-&gt;hfs_hotfile_freeblks += fileblocks;
		listp-&gt;hfl_reclaimblks -= fileblocks;
		<span class="enscript-keyword">if</span> (listp-&gt;hfl_reclaimblks &lt; 0)
			listp-&gt;hfl_reclaimblks = 0;
		blksmoved += fileblocks;
		filesmoved++;
<span class="enscript-reference">delete</span>:
		<span class="enscript-comment">/* Start a new transaction before calling BTree code. */</span>
		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		    error = EINVAL;
		    <span class="enscript-keyword">break</span>;
		}
		startedtrans = 1;

		error = BTDeleteRecord(filefork, iterator);
		<span class="enscript-keyword">if</span> (error) {
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		savedtemp = key-&gt;temperature;
		key-&gt;temperature = HFC_LOOKUPTAG;
		error = BTDeleteRecord(filefork, iterator);
		<span class="enscript-keyword">if</span> (error) {
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		key-&gt;temperature = savedtemp;
<span class="enscript-reference">next</span>:
		(<span class="enscript-type">void</span>) BTFlushPath(filefork);

		<span class="enscript-comment">/* Transaction complete. */</span>
		<span class="enscript-keyword">if</span> (startedtrans) {
			hfs_end_transaction(hfsmp);
			startedtrans = 0;
		}

	} <span class="enscript-comment">/* end while */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: moved %d files (%d blks, %d to go)\n&quot;</span>, filesmoved, blksmoved, listp-&gt;hfl_reclaimblks);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Finish any outstanding transactions. */</span>
	<span class="enscript-keyword">if</span> (startedtrans) {
		save_btree_user_info(hfsmp);

		(<span class="enscript-type">void</span>) BTFlushPath(filefork);
		hfs_end_transaction(hfsmp);
		startedtrans = 0;
	}
	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));

	<span class="enscript-comment">/*
	 * Move to next stage when finished.
	 */</span>
	<span class="enscript-keyword">if</span> (listp-&gt;hfl_reclaimblks &lt;= 0) {
		stage = HFC_ADOPTION;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: hotfiles_evict: %d blocks free in hot file band\n&quot;</span>, hfsmp-&gt;hfs_hotfile_freeblks);
#<span class="enscript-reference">endif</span>
	}
	FREE(iterator, M_TEMP);	
	hfsmp-&gt;hfc_stage = stage;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfc_stage);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Age the existing records in the hot files b-tree.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotfiles_age</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	BTreeInfoRec  btinfo;
	BTreeIterator * iterator = NULL;
	BTreeIterator * prev_iterator;
	FSBufferDescriptor  record;
	FSBufferDescriptor  prev_record;
	HotFileKey * key;
	HotFileKey * prev_key;
	filefork_t * filefork;
	u_int32_t  data;
	u_int32_t  prev_data;
	u_int32_t  newtemp;
	<span class="enscript-type">int</span>  error;
	<span class="enscript-type">int</span>  i;
	<span class="enscript-type">int</span>  numrecs;
	<span class="enscript-type">int</span>  aged = 0;
	u_int16_t  reclen;


	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// hotfiles don't age on CF
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">return</span> 0;
	}

	MALLOC(iterator, BTreeIterator *, 2 * <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	}
	bzero(iterator, 2 * <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HotFileKey*) &amp;iterator-&gt;key;

	prev_iterator = &amp;iterator[1];
	prev_key = (HotFileKey*) &amp;prev_iterator-&gt;key;

	record.bufferAddress = &amp;data;
	record.itemSize = <span class="enscript-keyword">sizeof</span>(data);
	record.itemCount = 1;
	prev_record.bufferAddress = &amp;prev_data;
	prev_record.itemSize = <span class="enscript-keyword">sizeof</span>(prev_data);
	prev_record.itemCount = 1;

	<span class="enscript-comment">/*
	 * Capture b-tree changes inside a transaction
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out2</span>;
	} 
	<span class="enscript-keyword">if</span> (hfs_lock(VTOC(hfsmp-&gt;hfc_filevp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	filefork = VTOF(hfsmp-&gt;hfc_filevp);

	error = BTGetInformation(filefork, 0, &amp;btinfo);
	<span class="enscript-keyword">if</span> (error) {
		error = MacToVFSError(error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (btinfo.numRecords &lt; 2) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/* Only want 1st half of leaf records */</span>
	numrecs = (btinfo.numRecords /= 2) - 1;

	error = BTIterateRecord(filefork, kBTreeFirstRecord, iterator, &amp;record, &amp;reclen);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_agehotfiles: BTIterateRecord: %d\n&quot;</span>, error);
		error = MacToVFSError(error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bcopy(iterator, prev_iterator, <span class="enscript-keyword">sizeof</span>(BTreeIterator));
	prev_data = data;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; numrecs; ++i) {
		error = BTIterateRecord(filefork, kBTreeNextRecord, iterator, &amp;record, &amp;reclen);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (key-&gt;temperature &lt; prev_key-&gt;temperature) {
				printf(<span class="enscript-string">&quot;hfs_agehotfiles: out of order keys!\n&quot;</span>);
				error = EFTYPE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (reclen != <span class="enscript-keyword">sizeof</span>(data)) {
				printf(<span class="enscript-string">&quot;hfs_agehotfiles: invalid record length %d\n&quot;</span>, reclen);
				error = EFTYPE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (key-&gt;keyLength != HFC_KEYLENGTH) {
				printf(<span class="enscript-string">&quot;hfs_agehotfiles: invalid key length %d\n&quot;</span>, key-&gt;keyLength);
				error = EFTYPE;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error == fsBTEndOfIterationErr || error == fsBTRecordNotFoundErr) &amp;&amp;
		    (i == (numrecs - 1))) {
			error = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_agehotfiles: %d of %d BTIterateRecord: %d\n&quot;</span>, i, numrecs, error);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (prev_key-&gt;temperature == HFC_LOOKUPTAG) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>	
			printf(<span class="enscript-string">&quot;hfs_agehotfiles: ran into thread record\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		error = BTDeleteRecord(filefork, prev_iterator);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_agehotfiles: BTDeleteRecord failed %d (file %d)\n&quot;</span>, error, prev_key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* Age by halving the temperature (floor = 4) */</span>
		newtemp = MAX(prev_key-&gt;temperature &gt;&gt; 1, 4);
		prev_key-&gt;temperature = newtemp;
	
		error = BTInsertRecord(filefork, prev_iterator, &amp;prev_record, prev_record.itemSize);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_agehotfiles: BTInsertRecord failed %d (file %d)\n&quot;</span>, error, prev_key-&gt;fileID);
			error = MacToVFSError(error);
			<span class="enscript-keyword">break</span>;
		}
		++aged;
		<span class="enscript-comment">/*
		 * Update thread entry with latest temperature.
		 */</span>
		prev_key-&gt;temperature = HFC_LOOKUPTAG;
		error = BTUpdateRecord(filefork, prev_iterator,
				(IterateCallBackProcPtr)update_callback,
				&amp;newtemp);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_agehotfiles: %d of %d BTUpdateRecord failed %d (file %d, %d)\n&quot;</span>,
				i, numrecs, error, prev_key-&gt;fileID, newtemp);
			error = MacToVFSError(error);
		<span class="enscript-comment">//	break;
</span>		}

		bcopy(iterator, prev_iterator, <span class="enscript-keyword">sizeof</span>(BTreeIterator));
		prev_data = data;

	} <span class="enscript-comment">/* end for */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>	
	<span class="enscript-keyword">if</span> (error == 0)
		printf(<span class="enscript-string">&quot;hfs_agehotfiles: aged %d records out of %d\n&quot;</span>, aged, btinfo.numRecords);
#<span class="enscript-reference">endif</span>
	(<span class="enscript-type">void</span>) BTFlushPath(filefork);
<span class="enscript-reference">out</span>:
	hfs_unlock(VTOC(hfsmp-&gt;hfc_filevp));
<span class="enscript-reference">out1</span>:
	hfs_end_transaction(hfsmp);
<span class="enscript-reference">out2</span>:
	<span class="enscript-keyword">if</span> (iterator)
		FREE(iterator, M_TEMP);	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return true if any blocks (or all blocks if all is true)
 * are contained in the hot file region.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hotextents</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusExtentDescriptor * extents)
{
	u_int32_t  b1, b2;
	<span class="enscript-type">int</span>  i;
	<span class="enscript-type">int</span>  inside = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
		b1 = extents[i].startBlock;
		<span class="enscript-keyword">if</span> (b1 == 0)
			<span class="enscript-keyword">break</span>;
		b2 = b1 + extents[i].blockCount - 1;
		<span class="enscript-keyword">if</span> ((b1 &gt;= hfsmp-&gt;hfs_hotfile_start &amp;&amp;
		     b2 &lt;= hfsmp-&gt;hfs_hotfile_end) ||
		    (b1 &lt; hfsmp-&gt;hfs_hotfile_end &amp;&amp; 
		     b2 &gt; hfsmp-&gt;hfs_hotfile_end)) {
			inside = 1;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> (inside);
}


<span class="enscript-comment">/*
 *========================================================================
 *                       HOT FILE B-TREE ROUTINES
 *========================================================================
 */</span>

<span class="enscript-comment">/*
 * Open the hot files b-tree for writing.
 *
 * On successful exit the vnode has a reference but not an iocount.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_open</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode **vpp)
{
	<span class="enscript-keyword">return</span> hfc_btree_open_ext(hfsmp, vpp, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_open_ext</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">int</span> ignore_btree_errs)
{
	proc_t p;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> cat_desc  cdesc;
	<span class="enscript-type">struct</span> cat_attr  cattr;
	<span class="enscript-type">struct</span> cat_fork  cfork;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> filename[] = HFC_FILENAME;
	<span class="enscript-type">int</span>  error;
	<span class="enscript-type">int</span>  retry = 0;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> newvnode_flags = 0;

	*vpp = NULL;
	p = current_proc();

	bzero(&amp;cdesc, <span class="enscript-keyword">sizeof</span>(cdesc));
	cdesc.cd_parentcnid = kRootDirID;
	cdesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)filename;
	cdesc.cd_namelen = strlen(filename);

	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

	error = cat_lookup(hfsmp, &amp;cdesc, 0, 0, &amp;cdesc, &amp;cattr, &amp;cfork, NULL);

	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs: hfc_btree_open: cat_lookup error %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> (error);
	}
<span class="enscript-reference">again</span>:
	cdesc.cd_flags |= CD_ISMETA;
	error = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cdesc, 0, &amp;cattr, 
							&amp;cfork, &amp;vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs: hfc_btree_open: hfs_getnewvnode error %d\n&quot;</span>, error);
		cat_releasedesc(&amp;cdesc);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (!vnode_issystem(vp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
		printf(<span class="enscript-string">&quot;hfs: hfc_btree_open: file has UBC, try again\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		hfs_unlock(VTOC(vp));
		vnode_recycle(vp);
		vnode_put(vp);
		<span class="enscript-keyword">if</span> (retry++ == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-comment">/* Open the B-tree file for writing... */</span>
	error = BTOpenPath(VTOF(vp), (KeyCompareProcPtr) hfc_comparekeys);	
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (!ignore_btree_errs) {
			printf(<span class="enscript-string">&quot;hfs: hfc_btree_open: BTOpenPath error %d; filesize %lld\n&quot;</span>, error, VTOF(vp)-&gt;ff_size);
			error = MacToVFSError(error);
		} <span class="enscript-keyword">else</span> {
			error = 0;
		}
	}

	hfs_unlock(VTOC(vp));
	<span class="enscript-keyword">if</span> (error == 0) {
		*vpp = vp;
		vnode_ref(vp);  <span class="enscript-comment">/* keep a reference while its open */</span>
	}
	vnode_put(vp);

	<span class="enscript-keyword">if</span> (!vnode_issystem(vp))
		panic(<span class="enscript-string">&quot;hfs: hfc_btree_open: not a system file (vp = %p)&quot;</span>, vp);

	HotFilesInfo hotfileinfo;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) {
		<span class="enscript-keyword">if</span> ((BTGetUserData(VTOF(vp), &amp;hotfileinfo, <span class="enscript-keyword">sizeof</span>(hotfileinfo)) == 0) &amp;&amp; (SWAP_BE32 (hotfileinfo.magic) == HFC_MAGIC)) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_hotfile_freeblks == 0) {
				hfsmp-&gt;hfs_hotfile_freeblks = hfsmp-&gt;hfs_hotfile_maxblks - SWAP_BE32 (hotfileinfo.usedblocks);
			}

			hfs_hotfile_cur_freeblks(hfsmp);        <span class="enscript-comment">// factors in any adjustments that happened at run-time
</span>		}
	}
	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Close the hot files b-tree.
 *
 * On entry the vnode has a reference.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_close</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp)
{
	proc_t p = current_proc();
	<span class="enscript-type">int</span>  error = 0;


	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
	    hfs_flush(hfsmp, HFS_FLUSH_JOURNAL);
	}

	<span class="enscript-keyword">if</span> (vnode_get(vp) == 0) {
		error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			(<span class="enscript-type">void</span>) hfs_fsync(vp, MNT_WAIT, 0, p);
			error = BTClosePath(VTOF(vp));
			hfs_unlock(VTOC(vp));
		}
		vnode_rele(vp);
		vnode_recycle(vp);
		vnode_put(vp);
	}
	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Assumes that hfsmp-&gt;hfc_filevp points to the hotfile btree vnode
</span><span class="enscript-comment">// (i.e. you called hfc_btree_open() ahead of time)
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_delete_record</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, BTreeIterator *iterator, HotFileKey *key)
{
	<span class="enscript-type">int</span> error;
	filefork_t *filefork=VTOF(hfsmp-&gt;hfc_filevp);

	<span class="enscript-comment">/* Start a new transaction before calling BTree code. */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	error = BTDeleteRecord(filefork, iterator);
	<span class="enscript-keyword">if</span> (error) {
		error = MacToVFSError(error);
		printf(<span class="enscript-string">&quot;hfs: failed to delete record for file-id %d : err %d\n&quot;</span>, key-&gt;fileID, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-type">int</span> savedtemp;
	savedtemp = key-&gt;temperature;
	key-&gt;temperature = HFC_LOOKUPTAG;
	error = BTDeleteRecord(filefork, iterator);
	<span class="enscript-keyword">if</span> (error) {
		error = MacToVFSError(error);
		printf(<span class="enscript-string">&quot;hfs:2: failed to delete record for file-id %d : err %d\n&quot;</span>, key-&gt;fileID, error);
	}
	key-&gt;temperature = savedtemp;

	(<span class="enscript-type">void</span>) BTFlushPath(filefork);

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* Transaction complete. */</span>
	hfs_end_transaction(hfsmp);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// You have to have already opened the hotfile btree so
</span><span class="enscript-comment">// that hfsmp-&gt;hfc_filevp is filled in.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_delete</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">struct</span> vnode *dvp = NULL;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> componentname cname;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> filename[] = HFC_FILENAME;
	<span class="enscript-type">int</span>  error;

	error = VFS_ROOT(HFSTOVFS(hfsmp), &amp;dvp, ctx);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	cname.cn_nameiop = DELETE;
	cname.cn_flags = ISLASTCN;
	cname.cn_context = ctx;
	cname.cn_pnbuf = filename;
	cname.cn_pnlen = <span class="enscript-keyword">sizeof</span>(filename);
	cname.cn_nameptr = filename;
	cname.cn_namelen = strlen(filename);
	cname.cn_hash = 0;
	cname.cn_consume = 0;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_type, VREG);
	VATTR_SET(&amp;va, va_mode, S_IFREG | S_IRUSR | S_IWUSR);
	VATTR_SET(&amp;va, va_uid, 0);
	VATTR_SET(&amp;va, va_gid, 0);

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 

	<span class="enscript-comment">/* call ourselves directly, ignore the higher-level VFS file creation code */</span>
	error = VNOP_REMOVE(dvp, hfsmp-&gt;hfc_filevp, &amp;cname, 0, ctx);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs: error %d removing HFBT on %s\n&quot;</span>, error, HFSTOVCB(hfsmp)-&gt;vcbVN);
	}

	hfs_end_transaction(hfsmp);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
		dvp = NULL;
	}

	<span class="enscript-keyword">return</span> 0;
}




<span class="enscript-comment">/*
 *  Create a hot files btree file.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_btree_create</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nodesize, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> entries)
{
	<span class="enscript-type">struct</span> vnode *dvp = NULL;
	<span class="enscript-type">struct</span> vnode *vp = NULL;
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> componentname cname;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> filename[] = HFC_FILENAME;
	<span class="enscript-type">int</span>  error;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_filevp)
		panic(<span class="enscript-string">&quot;hfs: hfc_btree_create: hfc_filevp exists (vp = %p)&quot;</span>, hfsmp-&gt;hfc_filevp);

	error = VFS_ROOT(HFSTOVFS(hfsmp), &amp;dvp, ctx);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	cname.cn_nameiop = CREATE;
	cname.cn_flags = ISLASTCN;
	cname.cn_context = ctx;
	cname.cn_pnbuf = filename;
	cname.cn_pnlen = <span class="enscript-keyword">sizeof</span>(filename);
	cname.cn_nameptr = filename;
	cname.cn_namelen = strlen(filename);
	cname.cn_hash = 0;
	cname.cn_consume = 0;

	VATTR_INIT(&amp;va);
	VATTR_SET(&amp;va, va_type, VREG);
	VATTR_SET(&amp;va, va_mode, S_IFREG | S_IRUSR | S_IWUSR);
	VATTR_SET(&amp;va, va_uid, 0);
	VATTR_SET(&amp;va, va_gid, 0);

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} 

	<span class="enscript-comment">/* call ourselves directly, ignore the higher-level VFS file creation code */</span>
	error = VNOP_CREATE(dvp, &amp;vp, &amp;cname, &amp;va, ctx);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs: error %d creating HFBT on %s\n&quot;</span>, error, HFSTOVCB(hfsmp)-&gt;vcbVN);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
		dvp = NULL;
	}
	<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	cp = VTOC(vp);

	<span class="enscript-comment">/* Don't use non-regular files or files with links. */</span>
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp) || cp-&gt;c_linkcount != 1) {
		error = EFTYPE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	printf(<span class="enscript-string">&quot;hfs: created HFBT on %s\n&quot;</span>, HFSTOVCB(hfsmp)-&gt;vcbVN);

	<span class="enscript-keyword">if</span> (VTOF(vp)-&gt;ff_size &lt; nodesize) {
		caddr_t  buffer;
		u_int16_t *index;
		u_int16_t  offset;
		BTNodeDescriptor  *ndp;
		BTHeaderRec  *bthp;
		HotFilesInfo *hotfileinfo;
		<span class="enscript-type">int</span>  nodecnt;
		<span class="enscript-type">int</span>  filesize;
		<span class="enscript-type">int</span>  entirespernode;

		<span class="enscript-comment">/*
		 * Mark it invisible (truncate will pull these changes).
		 */</span>
		((FndrFileInfo *)&amp;cp-&gt;c_finderinfo[0])-&gt;fdFlags |=
			SWAP_BE16 (kIsInvisible + kNameLocked);

		<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;buffer, nodesize, VM_KERN_MEMORY_FILE)) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}	
		bzero(buffer, nodesize);
		index = (u_int16_t *)buffer;
	
		entirespernode = (nodesize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) - 2) /
				 (<span class="enscript-keyword">sizeof</span>(HotFileKey) + 6);
		nodecnt = 2 + howmany(entries * 2, entirespernode);
		nodecnt = roundup(nodecnt, 8);
		filesize = nodecnt * nodesize;
	
		<span class="enscript-comment">/* FILL IN THE NODE DESCRIPTOR:  */</span>
		ndp = (BTNodeDescriptor *)buffer;
		ndp-&gt;kind = kBTHeaderNode;
		ndp-&gt;numRecords = SWAP_BE16 (3);
		offset = <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor);
		index[(nodesize / 2) - 1] = SWAP_BE16 (offset);
	
		<span class="enscript-comment">/* FILL IN THE HEADER RECORD:  */</span>
		bthp = (BTHeaderRec *)((u_int8_t *)buffer + offset);
		bthp-&gt;nodeSize     = SWAP_BE16 (nodesize);
		bthp-&gt;totalNodes   = SWAP_BE32 (filesize / nodesize);
		bthp-&gt;freeNodes    = SWAP_BE32 (nodecnt - 1);
		bthp-&gt;clumpSize    = SWAP_BE32 (filesize);
		bthp-&gt;btreeType    = kUserBTreeType; <span class="enscript-comment">/* non-metadata */</span>
		bthp-&gt;attributes  |= SWAP_BE32 (kBTBigKeysMask);
		bthp-&gt;maxKeyLength = SWAP_BE16 (HFC_KEYLENGTH);
		offset += <span class="enscript-keyword">sizeof</span>(BTHeaderRec);
		index[(nodesize / 2) - 2] = SWAP_BE16 (offset);
	
		<span class="enscript-comment">/* FILL IN THE USER RECORD:  */</span>
		hotfileinfo = (HotFilesInfo *)((u_int8_t *)buffer + offset);
		hotfileinfo-&gt;magic       = SWAP_BE32 (HFC_MAGIC);
		hotfileinfo-&gt;version     = SWAP_BE32 (HFC_VERSION);
		hotfileinfo-&gt;duration    = SWAP_BE32 (HFC_DEFAULT_DURATION);
		hotfileinfo-&gt;timebase    = 0;
		hotfileinfo-&gt;timeleft    = 0;
		hotfileinfo-&gt;threshold   = SWAP_BE32 (HFC_MINIMUM_TEMPERATURE);
		hotfileinfo-&gt;maxfileblks = SWAP_BE32 (HFC_MAXIMUM_FILESIZE / HFSTOVCB(hfsmp)-&gt;blockSize);
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_hotfile_freeblks == 0) {
				hfsmp-&gt;hfs_hotfile_freeblks = hfsmp-&gt;hfs_hotfile_maxblks;
			}
			hotfileinfo-&gt;usedblocks = SWAP_BE32 (hfsmp-&gt;hfs_hotfile_maxblks - hfsmp-&gt;hfs_hotfile_freeblks);
		} <span class="enscript-keyword">else</span> {
			hotfileinfo-&gt;maxfilecnt  = SWAP_BE32 (HFC_DEFAULT_FILE_COUNT);
		}
		strlcpy((<span class="enscript-type">char</span> *)hotfileinfo-&gt;tag, hfc_tag,
			<span class="enscript-keyword">sizeof</span> hotfileinfo-&gt;tag);
		offset += kBTreeHeaderUserBytes;
		index[(nodesize / 2) - 3] = SWAP_BE16 (offset);
	
		<span class="enscript-comment">/* FILL IN THE MAP RECORD (only one node in use). */</span>
		*((u_int8_t *)buffer + offset) = 0x80;
		offset += nodesize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) - <span class="enscript-keyword">sizeof</span>(BTHeaderRec)
				   - kBTreeHeaderUserBytes - (4 * <span class="enscript-keyword">sizeof</span>(int16_t));
		index[(nodesize / 2) - 4] = SWAP_BE16 (offset);

		vnode_setnoflush(vp);
		error = hfs_truncate(vp, (off_t)filesize, IO_NDELAY, 0, ctx);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs: error %d growing HFBT on %s\n&quot;</span>, error, HFSTOVCB(hfsmp)-&gt;vcbVN);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		cp-&gt;c_flag |= C_ZFWANTSYNC;
		cp-&gt;c_zftimeout = 1;
		
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-type">struct</span> vnop_write_args args;
			uio_t auio;

			auio = uio_create(1, 0, UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, (uintptr_t)buffer, nodesize);

			args.a_desc = &amp;vnop_write_desc;
			args.a_vp = vp;
			args.a_uio = auio;
			args.a_ioflag = 0;
			args.a_context = ctx;

			hfs_unlock(cp);
			cp = NULL;

			error = hfs_vnop_write(&amp;args);
			<span class="enscript-keyword">if</span> (error)
				printf(<span class="enscript-string">&quot;hfs: error %d writing HFBT on %s\n&quot;</span>, error, HFSTOVCB(hfsmp)-&gt;vcbVN);

			uio_free(auio);
		}
		kmem_free(kernel_map, (vm_offset_t)buffer, nodesize);
	}
<span class="enscript-reference">out</span>:
	hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (dvp) {
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-keyword">if</span> (cp)
			hfs_unlock(cp);
		vnode_recycle(vp);
		vnode_put(vp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Compare two hot file b-tree keys.
 *
 * Result:   +n  search key &gt; trial key
 *            0  search key = trial key
 *           -n  search key &lt; trial key
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfc_comparekeys</span>(HotFileKey *searchKey, HotFileKey *trialKey)
{
	<span class="enscript-comment">/*
	 * Compared temperatures first.
	 */</span>
	<span class="enscript-keyword">if</span> (searchKey-&gt;temperature == trialKey-&gt;temperature) {
		<span class="enscript-comment">/*
		 * Temperatures are equal so compare file ids.
		 */</span>
		<span class="enscript-keyword">if</span> (searchKey-&gt;fileID == trialKey-&gt;fileID) {
			<span class="enscript-comment">/*
			 * File ids are equal so compare fork types.
			 */</span>
			<span class="enscript-keyword">if</span> (searchKey-&gt;forkType == trialKey-&gt;forkType) {
				<span class="enscript-keyword">return</span> (0);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchKey-&gt;forkType &gt; trialKey-&gt;forkType) {
				<span class="enscript-keyword">return</span> (1);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchKey-&gt;fileID &gt; trialKey-&gt;fileID) {
			<span class="enscript-keyword">return</span> (1);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchKey-&gt;temperature &gt; trialKey-&gt;temperature) {
		<span class="enscript-keyword">return</span> (1);
	}
	
	<span class="enscript-keyword">return</span> (-1);
}


<span class="enscript-comment">/*
 *========================================================================
 *               HOT FILE DATA COLLECTING ROUTINES
 *========================================================================
 */</span>

<span class="enscript-comment">/*
 * Lookup a hot file entry in the tree.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_DEBUG</span>
<span class="enscript-type">static</span> hotfile_entry_t *
<span class="enscript-function-name">hf_lookup</span>(hotfile_data_t *hotdata, u_int32_t fileid, u_int32_t temperature)
{
	hotfile_entry_t *entry = hotdata-&gt;rootentry;

	<span class="enscript-keyword">while</span> (entry &amp;&amp;
	       entry-&gt;temperature != temperature &amp;&amp;
	       entry-&gt;fileid != fileid) {

		<span class="enscript-keyword">if</span> (temperature &gt; entry-&gt;temperature)
			entry = entry-&gt;right;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (temperature &lt; entry-&gt;temperature)
			entry = entry-&gt;left;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fileid &gt; entry-&gt;fileid)
			entry = entry-&gt;right;
		<span class="enscript-keyword">else</span>
			entry = entry-&gt;left;
	}
	<span class="enscript-keyword">return</span> (entry);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Insert a hot file entry into the tree.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hf_insert</span>(hotfile_data_t *hotdata, hotfile_entry_t *newentry) 
{
	hotfile_entry_t *entry = hotdata-&gt;rootentry;
	u_int32_t fileid = newentry-&gt;fileid;
	u_int32_t temperature = newentry-&gt;temperature;

	<span class="enscript-keyword">if</span> (entry == NULL) {
		hotdata-&gt;rootentry = newentry;
		hotdata-&gt;coldest = newentry;
		hotdata-&gt;activefiles++;
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">while</span> (entry) {
		<span class="enscript-keyword">if</span> (temperature &gt; entry-&gt;temperature) {
			<span class="enscript-keyword">if</span> (entry-&gt;right) {
				entry = entry-&gt;right;
			} <span class="enscript-keyword">else</span> {
				entry-&gt;right = newentry;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (temperature &lt; entry-&gt;temperature) {
			<span class="enscript-keyword">if</span> (entry-&gt;left) {
				entry = entry-&gt;left;
			} <span class="enscript-keyword">else</span> {
			    	entry-&gt;left = newentry;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fileid &gt; entry-&gt;fileid) { 
			<span class="enscript-keyword">if</span> (entry-&gt;right) {
				entry = entry-&gt;right;
			} <span class="enscript-keyword">else</span> {
	       			<span class="enscript-keyword">if</span> (entry-&gt;fileid != fileid)
					entry-&gt;right = newentry;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> { 
			<span class="enscript-keyword">if</span> (entry-&gt;left) {
				entry = entry-&gt;left;
			} <span class="enscript-keyword">else</span> {
	       			<span class="enscript-keyword">if</span> (entry-&gt;fileid != fileid) {
			    		entry-&gt;left = newentry;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">return</span> EEXIST;
				}
				<span class="enscript-keyword">break</span>;
			}
		}
	}

	hotdata-&gt;activefiles++;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Find the coldest entry in the tree.
 */</span>
<span class="enscript-type">static</span> hotfile_entry_t *
<span class="enscript-function-name">hf_coldest</span>(hotfile_data_t *hotdata)
{
	hotfile_entry_t *entry = hotdata-&gt;rootentry;

	<span class="enscript-keyword">if</span> (entry) {
		<span class="enscript-keyword">while</span> (entry-&gt;left)
			entry = entry-&gt;left;
	}
	<span class="enscript-keyword">return</span> (entry);
}

<span class="enscript-comment">/*
 * Find the hottest entry in the tree.
 */</span>
<span class="enscript-type">static</span> hotfile_entry_t *
<span class="enscript-function-name">hf_hottest</span>(hotfile_data_t *hotdata)
{
	hotfile_entry_t *entry = hotdata-&gt;rootentry;

	<span class="enscript-keyword">if</span> (entry) {
		<span class="enscript-keyword">while</span> (entry-&gt;right)
			entry = entry-&gt;right;
	}
	<span class="enscript-keyword">return</span> (entry);
}

<span class="enscript-comment">/*
 * Delete a hot file entry from the tree.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hf_delete</span>(hotfile_data_t *hotdata, u_int32_t fileid, u_int32_t temperature)
{
	hotfile_entry_t *entry, *parent, *next;

	parent = NULL;
	entry = hotdata-&gt;rootentry;

	<span class="enscript-keyword">while</span> (entry &amp;&amp;
	       entry-&gt;temperature != temperature &amp;&amp;
	       entry-&gt;fileid != fileid) {

		parent = entry;
		<span class="enscript-keyword">if</span> (temperature &gt; entry-&gt;temperature)
			entry = entry-&gt;right;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (temperature &lt; entry-&gt;temperature)
			entry = entry-&gt;left;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fileid &gt; entry-&gt;fileid)
			entry = entry-&gt;right;
		<span class="enscript-keyword">else</span>
			entry = entry-&gt;left;
	}

	<span class="enscript-keyword">if</span> (entry) {
		<span class="enscript-comment">/*
		 * Reorganize the sub-trees spanning from our entry.
		 */</span>
		<span class="enscript-keyword">if</span> ((next = entry-&gt;right)) {
			hotfile_entry_t *pnextl, *psub;
			<span class="enscript-comment">/*
			 * Tree pruning: take the left branch of the
			 * current entry and place it at the lowest
			 * left branch of the current right branch 
			 */</span>
			psub = next;
			
			<span class="enscript-comment">/* Walk the Right/Left sub tree from current entry */</span>
			<span class="enscript-keyword">while</span> ((pnextl = psub-&gt;left))
				psub = pnextl;	
			
			<span class="enscript-comment">/* Plug the old left tree to the new -&gt;Right leftmost entry */</span>	
			psub-&gt;left = entry-&gt;left;
	
		} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* only left sub-tree, simple case */</span> {  
			next = entry-&gt;left;
		}
		<span class="enscript-comment">/* 
		 * Now, plug the current entry sub tree to
		 * the good pointer of our parent entry.
		 */</span>
		<span class="enscript-keyword">if</span> (parent == NULL)
			hotdata-&gt;rootentry = next;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parent-&gt;left == entry)
			parent-&gt;left = next;
		<span class="enscript-keyword">else</span>
			parent-&gt;right = next;	
		
		<span class="enscript-comment">/* Place entry back on the free-list */</span>
		entry-&gt;left = 0;
		entry-&gt;fileid = 0;
		entry-&gt;temperature = 0;

		entry-&gt;right = hotdata-&gt;freelist; 
		hotdata-&gt;freelist = entry; 		
		hotdata-&gt;activefiles--;
		
		<span class="enscript-keyword">if</span> (hotdata-&gt;coldest == entry || hotdata-&gt;coldest == NULL) {
			hotdata-&gt;coldest = hf_coldest(hotdata);
		}

	}
}

<span class="enscript-comment">/*
 * Get a free hot file entry.
 */</span>
<span class="enscript-type">static</span> hotfile_entry_t *
<span class="enscript-function-name">hf_getnewentry</span>(hotfile_data_t *hotdata)
{
	hotfile_entry_t * entry;
	
	<span class="enscript-comment">/*
	 * When the free list is empty then steal the coldest one
	 */</span>
	<span class="enscript-keyword">if</span> (hotdata-&gt;freelist == NULL) {
		entry = hf_coldest(hotdata);
		hf_delete(hotdata, entry-&gt;fileid, entry-&gt;temperature);
	}
	entry = hotdata-&gt;freelist;
	hotdata-&gt;freelist = entry-&gt;right;
	entry-&gt;right = 0;
	
	<span class="enscript-keyword">return</span> (entry);
}


<span class="enscript-comment">/*
 * Generate a sorted list of hot files (hottest to coldest).
 *
 * As a side effect, every node in the hot file tree will be
 * deleted (moved to the free list).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hf_getsortedlist</span>(hotfile_data_t * hotdata, hotfilelist_t *sortedlist)
{
	<span class="enscript-type">int</span> i = 0;
	hotfile_entry_t *entry;
	
	<span class="enscript-keyword">while</span> ((entry = hf_hottest(hotdata)) != NULL) {
		sortedlist-&gt;hfl_hotfile[i].hf_fileid = entry-&gt;fileid;
		sortedlist-&gt;hfl_hotfile[i].hf_temperature = entry-&gt;temperature;
		sortedlist-&gt;hfl_hotfile[i].hf_blocks = entry-&gt;blocks;
		sortedlist-&gt;hfl_totalblocks += entry-&gt;blocks;
		++i;

		hf_delete(hotdata, entry-&gt;fileid, entry-&gt;temperature);
	}
	
	sortedlist-&gt;hfl_count = i;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_VERBOSE</span>
	printf(<span class="enscript-string">&quot;hfs: hf_getsortedlist returning %d entries w/%d total blocks\n&quot;</span>, i, sortedlist-&gt;hfl_totalblocks);
#<span class="enscript-reference">endif</span>
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFC_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hf_maxdepth</span>(hotfile_entry_t * root, <span class="enscript-type">int</span> depth, <span class="enscript-type">int</span> *maxdepth)
{
	<span class="enscript-keyword">if</span> (root) {
		depth++;
		<span class="enscript-keyword">if</span> (depth &gt; *maxdepth)
			*maxdepth = depth;
		hf_maxdepth(root-&gt;left, depth, maxdepth);
		hf_maxdepth(root-&gt;right, depth, maxdepth);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hf_printtree</span>(hotfile_entry_t * root)
{
	<span class="enscript-keyword">if</span> (root) {
		hf_printtree(root-&gt;left);
		printf(<span class="enscript-string">&quot;hfs: temperature: % 8d, fileid %d\n&quot;</span>, root-&gt;temperature, root-&gt;fileid);
		hf_printtree(root-&gt;right);
	}
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>