<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_vnops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_vnops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/paths.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_dbg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_mount.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_quota.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_kdebug.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cprotect.h&quot;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/FileMgrInternal.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KNDETACH_VNLOCKED</span> 0x00000001

<span class="enscript-comment">/* Global vfs data structures for hfs */</span>

<span class="enscript-comment">/* Always F_FULLFSYNC? 1=yes,0=no (default due to &quot;various&quot; reasons is 'no') */</span>
<span class="enscript-type">int</span> always_do_fullfsync = 0;
<span class="enscript-function-name">SYSCTL_DECL</span>(_vfs_generic);
<span class="enscript-function-name">SYSCTL_INT</span> (_vfs_generic, OID_AUTO, always_do_fullfsync, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;always_do_fullfsync, 0, <span class="enscript-string">&quot;always F_FULLFSYNC when fsync is called&quot;</span>);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_makenode</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp,
                        <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">struct</span> vnode_attr *vap,
                        vfs_context_t ctx);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_metasync</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, daddr64_t node, __unused <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_metasync_all</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_removedir</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">struct</span> vnode *, <span class="enscript-type">struct</span> componentname *,
                         <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_removefile</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">struct</span> vnode *, <span class="enscript-type">struct</span> componentname *,
                          <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> vnode *, <span class="enscript-type">int</span>);

<span class="enscript-comment">/* Used here and in cnode teardown -- for symlinks */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_removefile_callback</span>(<span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> *hfsmp);

<span class="enscript-type">enum</span> {
	HFS_MOVE_DATA_INCLUDE_RSRC		= 1,
};
<span class="enscript-type">typedef</span> uint32_t hfs_move_data_options_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_data</span>(cnode_t *from_cp, cnode_t *to_cp, 
						 hfs_move_data_options_t options);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_fork</span>(filefork_t *srcfork, cnode_t *src, 
 						 filefork_t *dstfork, cnode_t *dst);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_compressed</span>(cnode_t *from_vp, cnode_t *to_vp);
#<span class="enscript-reference">endif</span>

decmpfs_cnode* <span class="enscript-function-name">hfs_lazy_init_decmpfs_cnode</span> (<span class="enscript-type">struct</span> cnode *cp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsfifo_read</span>(<span class="enscript-type">struct</span> vnop_read_args *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsfifo_write</span>(<span class="enscript-type">struct</span> vnop_write_args *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsfifo_close</span>(<span class="enscript-type">struct</span> vnop_close_args *);

<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**fifo_vnodeop_p)(<span class="enscript-type">void</span> *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_close</span>(<span class="enscript-type">struct</span> vnop_close_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_create</span>(<span class="enscript-type">struct</span> vnop_create_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_exchange</span>(<span class="enscript-type">struct</span> vnop_exchange_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_fsync</span>(<span class="enscript-type">struct</span> vnop_fsync_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_mkdir</span>(<span class="enscript-type">struct</span> vnop_mkdir_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_mknod</span>(<span class="enscript-type">struct</span> vnop_mknod_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_getattr</span>(<span class="enscript-type">struct</span> vnop_getattr_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_open</span>(<span class="enscript-type">struct</span> vnop_open_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_readdir</span>(<span class="enscript-type">struct</span> vnop_readdir_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_remove</span>(<span class="enscript-type">struct</span> vnop_remove_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_rename</span>(<span class="enscript-type">struct</span> vnop_rename_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_rmdir</span>(<span class="enscript-type">struct</span> vnop_rmdir_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_symlink</span>(<span class="enscript-type">struct</span> vnop_symlink_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_setattr</span>(<span class="enscript-type">struct</span> vnop_setattr_args*);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_readlink</span>(<span class="enscript-type">struct</span> vnop_readlink_args *);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_pathconf</span>(<span class="enscript-type">struct</span> vnop_pathconf_args *);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_mmap</span>(<span class="enscript-type">struct</span> vnop_mmap_args *ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfsspec_read</span>(<span class="enscript-type">struct</span> vnop_read_args *);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfsspec_write</span>(<span class="enscript-type">struct</span> vnop_write_args *);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfsspec_close</span>(<span class="enscript-type">struct</span> vnop_close_args *);

<span class="enscript-comment">/* Options for hfs_removedir and hfs_removefile */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFSRM_SKIP_RESERVE</span>  0x01



<span class="enscript-comment">/*****************************************************************************
*
* Common Operations on vnodes
*
*****************************************************************************/</span>

<span class="enscript-comment">/*
 * Is the given cnode either the .journal or .journal_info_block file on
 * a volume with an active journal?  Many VNOPs use this to deny access
 * to those files.
 *
 * Note: the .journal file on a volume with an external journal still
 * returns true here, even though it does not actually hold the contents
 * of the volume's journal.
 */</span>
<span class="enscript-type">static</span> _Bool
<span class="enscript-function-name">hfs_is_journal_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl != NULL &amp;&amp;
	    (cp-&gt;c_fileid == hfsmp-&gt;hfs_jnlinfoblkid ||
	     cp-&gt;c_fileid == hfsmp-&gt;hfs_jnlfileid)) {
		<span class="enscript-keyword">return</span> true;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> false;
	}
}

<span class="enscript-comment">/*
 * Create a regular file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_create</span>(<span class="enscript-type">struct</span> vnop_create_args *ap)
{
	<span class="enscript-comment">/*
	 * We leave handling of certain race conditions here to the caller
	 * which will have a better understanding of the semantics it
	 * requires.  For example, if it turns out that the file exists,
	 * it would be wrong of us to return a reference to the existing
	 * file because the caller might not want that and it would be
	 * misleading to suggest the file had been created when it hadn't
	 * been.  Note that our NFS server code does not set the
	 * VA_EXCLUSIVE flag so you cannot assume that callers don't want
	 * EEXIST errors if it's not set.  The common case, where users
	 * are calling open with the O_CREAT mode, is handled in VFS; when
	 * we return EEXIST, it will loop and do the look-up again.
	 */</span>
	<span class="enscript-keyword">return</span> hfs_makenode(ap-&gt;a_dvp, ap-&gt;a_vpp, ap-&gt;a_cnp, ap-&gt;a_vap, ap-&gt;a_context);
}

<span class="enscript-comment">/*
 * Make device special file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_mknod</span>(<span class="enscript-type">struct</span> vnop_mknod_args *ap)
{
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode **vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (VTOVCB(dvp)-&gt;vcbSigWord != kHFSPlusSigWord) {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	<span class="enscript-comment">/* Create the vnode */</span>
	error = hfs_makenode(dvp, vpp, ap-&gt;a_cnp, vap, ap-&gt;a_context);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	cp = VTOC(*vpp);
	cp-&gt;c_touch_acctime = TRUE;
	cp-&gt;c_touch_chgtime = TRUE;
	cp-&gt;c_touch_modtime = TRUE;

	<span class="enscript-keyword">if</span> ((vap-&gt;va_rdev != VNOVAL) &amp;&amp;
	    (vap-&gt;va_type == VBLK || vap-&gt;va_type == VCHR))
		cp-&gt;c_rdev = vap-&gt;va_rdev;

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-comment">/* 
 *	hfs_ref_data_vp(): returns the data fork vnode for a given cnode. 
 *	In the (hopefully rare) case where the data fork vnode is not 
 *	present, it will use hfs_vget() to create a new vnode for the
 *	data fork. 
 *	
 *	NOTE: If successful and a vnode is returned, the caller is responsible
 *	for releasing the returned vnode with vnode_rele().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_ref_data_vp</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> vnode **data_vp, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-type">int</span> vref = 0;

	<span class="enscript-keyword">if</span> (!data_vp || !cp) <span class="enscript-comment">/* sanity check incoming parameters */</span>
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-comment">/* maybe we should take the hfs cnode lock here, and if so, use the skiplock parameter to tell us not to */</span>

	<span class="enscript-keyword">if</span> (!skiplock) hfs_lock(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-type">struct</span> vnode *c_vp = cp-&gt;c_vp;
	<span class="enscript-keyword">if</span> (c_vp) {
		<span class="enscript-comment">/* we already have a data vnode */</span>
		*data_vp = c_vp;
		vref = vnode_ref(*data_vp);
		<span class="enscript-keyword">if</span> (!skiplock) hfs_unlock(cp);
		<span class="enscript-keyword">if</span> (vref == 0) {
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-comment">/* no data fork vnode in the cnode, so ask hfs for one. */</span>

	<span class="enscript-keyword">if</span> (!cp-&gt;c_rsrc_vp) {
		<span class="enscript-comment">/* if we don't have either a c_vp or c_rsrc_vp, we can't really do anything useful */</span>
		*data_vp = NULL;
		<span class="enscript-keyword">if</span> (!skiplock) hfs_unlock(cp);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-keyword">if</span> (0 == hfs_vget(VTOHFS(cp-&gt;c_rsrc_vp), cp-&gt;c_cnid, data_vp, 1, 0) &amp;&amp;
		0 != data_vp) {
		vref = vnode_ref(*data_vp);
		vnode_put(*data_vp);
		<span class="enscript-keyword">if</span> (!skiplock) hfs_unlock(cp);
		<span class="enscript-keyword">if</span> (vref == 0) {
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-comment">/* there was an error getting the vnode */</span>
	*data_vp = NULL;
	<span class="enscript-keyword">if</span> (!skiplock) hfs_unlock(cp);
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-comment">/*
 *	hfs_lazy_init_decmpfs_cnode(): returns the decmpfs_cnode for a cnode,
 *	allocating it if necessary; returns NULL if there was an allocation error.
 *  function is non-static so that it can be used from the FCNTL handler.
 */</span>
decmpfs_cnode *
<span class="enscript-function-name">hfs_lazy_init_decmpfs_cnode</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-keyword">if</span> (!cp-&gt;c_decmp) {
		decmpfs_cnode *dp = NULL;
		MALLOC_ZONE(dp, decmpfs_cnode *, <span class="enscript-keyword">sizeof</span>(decmpfs_cnode), M_DECMPFS_CNODE, M_WAITOK);
		<span class="enscript-keyword">if</span> (!dp) {
			<span class="enscript-comment">/* error allocating a decmpfs cnode */</span>
			<span class="enscript-keyword">return</span> NULL;
		}
		decmpfs_cnode_init(dp);
		<span class="enscript-keyword">if</span> (!OSCompareAndSwapPtr(NULL, dp, (<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;cp-&gt;c_decmp)) {
			<span class="enscript-comment">/* another thread got here first, so free the decmpfs_cnode we allocated */</span>
			decmpfs_cnode_destroy(dp);
			FREE_ZONE(dp, <span class="enscript-keyword">sizeof</span>(*dp), M_DECMPFS_CNODE);
		}
	}
	
	<span class="enscript-keyword">return</span> cp-&gt;c_decmp;
}

<span class="enscript-comment">/*
 *	hfs_file_is_compressed(): returns 1 if the file is compressed, and 0 (zero) if not.
 *	if the file's compressed flag is set, makes sure that the decmpfs_cnode field
 *	is allocated by calling hfs_lazy_init_decmpfs_cnode(), then makes sure it is populated,
 *	or else fills it in via the decmpfs_file_is_compressed() function.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_file_is_compressed</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-type">int</span> ret = 0;
	
	<span class="enscript-comment">/* fast check to see if file is compressed. If flag is clear, just answer no */</span>
	<span class="enscript-keyword">if</span> (!(cp-&gt;c_bsdflags &amp; UF_COMPRESSED)) {
		<span class="enscript-keyword">return</span> 0;
	}

	decmpfs_cnode *dp = hfs_lazy_init_decmpfs_cnode(cp);
	<span class="enscript-keyword">if</span> (!dp) {
		<span class="enscript-comment">/* error allocating a decmpfs cnode, treat the file as uncompressed */</span>
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* flag was set, see if the decmpfs_cnode state is valid (zero == invalid) */</span>
	uint32_t decmpfs_state = decmpfs_cnode_get_vnode_state(dp);
	<span class="enscript-keyword">switch</span>(decmpfs_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>: <span class="enscript-comment">/* treat decompressing files as if they are compressed */</span>
			<span class="enscript-keyword">return</span> 1;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-comment">/* otherwise the state is not cached yet */</span>
	}
	
	<span class="enscript-comment">/* decmpfs hasn't seen this file yet, so call decmpfs_file_is_compressed() to init the decmpfs_cnode struct */</span>
	<span class="enscript-type">struct</span> vnode *data_vp = NULL;
	<span class="enscript-keyword">if</span> (0 == hfs_ref_data_vp(cp, &amp;data_vp, skiplock)) {
		<span class="enscript-keyword">if</span> (data_vp) {
			ret = decmpfs_file_is_compressed(data_vp, VTOCMP(data_vp)); <span class="enscript-comment">// fill in decmpfs_cnode
</span>			vnode_rele(data_vp);
		}
	}
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*	hfs_uncompressed_size_of_compressed_file() - get the uncompressed size of the file.
 *	if the caller has passed a valid vnode (has a ref count &gt; 0), then hfsmp and fid are not required.
 *	if the caller doesn't have a vnode, pass NULL in vp, and pass valid hfsmp and fid.
 *	files size is returned in size (required)
 *	if the indicated file is a directory (or something that doesn't have a data fork), then this call
 *	will return an error and the caller should fall back to treating the item as an uncompressed file
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_uncompressed_size_of_compressed_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, cnid_t fid, off_t *size, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-type">int</span> ret = 0;
	<span class="enscript-type">int</span> putaway = 0;									<span class="enscript-comment">/* flag to remember if we used hfs_vget() */</span>

	<span class="enscript-keyword">if</span> (!size) {
		<span class="enscript-keyword">return</span> EINVAL;									<span class="enscript-comment">/* no place to put the file size */</span>
	}

	<span class="enscript-keyword">if</span> (NULL == vp) {
		<span class="enscript-keyword">if</span> (!hfsmp || !fid) {							<span class="enscript-comment">/* make sure we have the required parameters */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (0 != hfs_vget(hfsmp, fid, &amp;vp, skiplock, 0)) {		<span class="enscript-comment">/* vnode is null, use hfs_vget() to get it */</span>
			vp = NULL;
		} <span class="enscript-keyword">else</span> {
			putaway = 1;								<span class="enscript-comment">/* note that hfs_vget() was used to aquire the vnode */</span>
		}
	}
	<span class="enscript-comment">/* this double check for compression (hfs_file_is_compressed)
	 * ensures the cached size is present in case decmpfs hasn't 
	 * encountered this node yet.
	 */</span>
	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-keyword">if</span> (hfs_file_is_compressed(VTOC(vp), skiplock) ) {
			*size = decmpfs_cnode_get_vnode_cached_size(VTOCMP(vp));	<span class="enscript-comment">/* file info will be cached now, so get size */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (VTOCMP(vp) &amp;&amp; VTOCMP(vp)-&gt;cmp_type &gt;= CMP_MAX) {
				<span class="enscript-keyword">if</span> (VTOCMP(vp)-&gt;cmp_type != DATALESS_CMPFS_TYPE) {
					<span class="enscript-comment">// if we don't recognize this type, just use the real data fork size
</span>					<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_datafork) {
						*size = VTOC(vp)-&gt;c_datafork-&gt;ff_size;
						ret = 0;
					} <span class="enscript-keyword">else</span> {
						ret = EINVAL;
					}
				} <span class="enscript-keyword">else</span> {
					*size = decmpfs_cnode_get_vnode_cached_size(VTOCMP(vp));	<span class="enscript-comment">/* file info will be cached now, so get size */</span>
					ret = 0;
				}
			} <span class="enscript-keyword">else</span> {
				ret = EINVAL;
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (putaway) {		<span class="enscript-comment">/* did we use hfs_vget() to get this vnode? */</span>
		vnode_put(vp);	<span class="enscript-comment">/* if so, release it and set it to null */</span>
		vp = NULL;
	}
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hides_rsrc</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-keyword">if</span> (ctx == decmpfs_ctx)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (!hfs_file_is_compressed(cp, skiplock))
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">return</span> decmpfs_hides_rsrc(ctx, cp-&gt;c_decmp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_hides_xattr</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-keyword">if</span> (ctx == decmpfs_ctx)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (!hfs_file_is_compressed(cp, skiplock))
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">return</span> decmpfs_hides_xattr(ctx, cp-&gt;c_decmp, name);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
		

<span class="enscript-comment">//
</span><span class="enscript-comment">// This function gets the doc_tombstone structure for the
</span><span class="enscript-comment">// current thread.  If the thread doesn't have one, the
</span><span class="enscript-comment">// structure is allocated.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">struct</span> doc_tombstone *
<span class="enscript-function-name">get_uthread_doc_tombstone</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span>  uthread *ut;
	ut = get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> (ut-&gt;t_tombstone == NULL) {
		ut-&gt;t_tombstone = kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> doc_tombstone));
		<span class="enscript-keyword">if</span> (ut-&gt;t_tombstone) {
			memset(ut-&gt;t_tombstone, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> doc_tombstone));
		}
	}
	
	<span class="enscript-keyword">return</span> ut-&gt;t_tombstone;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// This routine clears out the current tombstone for the
</span><span class="enscript-comment">// current thread and if necessary passes the doc-id of
</span><span class="enscript-comment">// the tombstone on to the dst_cnode.
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If the doc-id transfers to dst_cnode, we also generate
</span><span class="enscript-comment">// a doc-id changed fsevent.  Unlike all the other fsevents,
</span><span class="enscript-comment">// doc-id changed events can only be generated here in HFS
</span><span class="enscript-comment">// where we have the necessary info.
</span><span class="enscript-comment">// 
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">clear_tombstone_docid</span>(<span class="enscript-type">struct</span>  doc_tombstone *ut, __unused <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *dst_cnode)
{
	uint32_t old_id = ut-&gt;t_lastop_document_id;

	ut-&gt;t_lastop_document_id = 0;
	ut-&gt;t_lastop_parent = NULL;
	ut-&gt;t_lastop_parent_vid = 0;
	ut-&gt;t_lastop_filename[0] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// If the lastop item is still the same and needs to be cleared,
</span>	<span class="enscript-comment">// clear it.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (dst_cnode &amp;&amp; old_id &amp;&amp; ut-&gt;t_lastop_item &amp;&amp; vnode_vid(ut-&gt;t_lastop_item) == ut-&gt;t_lastop_item_vid) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// clear the document_id from the file that used to have it.
</span>		<span class="enscript-comment">// XXXdbg - we need to lock the other vnode and make sure to
</span>		<span class="enscript-comment">// update it on disk.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-type">struct</span> cnode *ocp = VTOC(ut-&gt;t_lastop_item);
		<span class="enscript-type">struct</span> FndrExtendedFileInfo *ofip = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((<span class="enscript-type">char</span> *)&amp;ocp-&gt;c_attr.ca_finderinfo + 16);

		<span class="enscript-comment">// printf(&quot;clearing doc-id from ino %d\n&quot;, ocp-&gt;c_desc.cd_cnid);
</span>		ofip-&gt;document_id = 0;
		ocp-&gt;c_bsdflags &amp;= ~UF_TRACKED;
		ocp-&gt;c_flag |= C_MODIFIED;
		<span class="enscript-comment">/* cat_update(hfsmp, &amp;ocp-&gt;c_desc, &amp;ocp-&gt;c_attr, NULL, NULL); */</span>

	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (dst_cnode &amp;&amp; old_id) {
		<span class="enscript-type">struct</span> FndrExtendedFileInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((<span class="enscript-type">char</span> *)&amp;dst_cnode-&gt;c_attr.ca_finderinfo + 16);

		add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
			    FSE_ARG_DEV, hfsmp-&gt;hfs_raw_dev,
			    FSE_ARG_INO, (ino64_t)ut-&gt;t_lastop_fileid,    <span class="enscript-comment">// src inode #
</span>			    FSE_ARG_INO, (ino64_t)dst_cnode-&gt;c_fileid,    <span class="enscript-comment">// dst inode #
</span>			    FSE_ARG_INT32, (uint32_t)fip-&gt;document_id,
			    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">// last, clear these now that we're all done
</span>	ut-&gt;t_lastop_item     = NULL;
	ut-&gt;t_lastop_fileid   = 0;
	ut-&gt;t_lastop_item_vid = 0;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// This function is used to filter out operations on temp
</span><span class="enscript-comment">// filenames.  We have to filter out operations on certain
</span><span class="enscript-comment">// temp filenames to work-around questionable application
</span><span class="enscript-comment">// behavior from apps like Autocad that perform unusual
</span><span class="enscript-comment">// sequences of file system operations for a &quot;safe save&quot;.
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_ignorable_temp_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *nameptr, <span class="enscript-type">int</span> len)
{
	<span class="enscript-keyword">if</span> (len == 0) {
		len = strlen(nameptr);
	}
	
	<span class="enscript-keyword">if</span> (   strncmp(nameptr, <span class="enscript-string">&quot;atmp&quot;</span>, 4) == 0
	   || (len &gt; 4 &amp;&amp; strncmp(nameptr+len-4, <span class="enscript-string">&quot;.bak&quot;</span>, 4) == 0)
	   || (len &gt; 4 &amp;&amp; strncmp(nameptr+len-4, <span class="enscript-string">&quot;.tmp&quot;</span>, 4) == 0)) {
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// Decide if we need to save a tombstone or not.  Normally we always
</span><span class="enscript-comment">// save a tombstone - but if there already is one and the name we're
</span><span class="enscript-comment">// given is an ignorable name, then we will not save a tombstone.
</span><span class="enscript-comment">// 
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">should_save_docid_tombstone</span>(<span class="enscript-type">struct</span> doc_tombstone *ut, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp)
{
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_nameptr == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id &amp;&amp; ut-&gt;t_lastop_item == vp &amp;&amp; is_ignorable_temp_name(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">return</span> 1;
}


<span class="enscript-comment">//
</span><span class="enscript-comment">// This function saves a tombstone for the given vnode and name.  The
</span><span class="enscript-comment">// tombstone represents the parent directory and name where the document
</span><span class="enscript-comment">// used to live and the document-id of that file.  This info is recorded
</span><span class="enscript-comment">// in the doc_tombstone structure hanging off the uthread (which assumes
</span><span class="enscript-comment">// that all safe-save operations happen on the same thread).
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// If later on the same parent/name combo comes back into existence then
</span><span class="enscript-comment">// we'll preserve the doc-id from this vnode onto the new vnode.
</span><span class="enscript-comment">//
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">save_tombstone</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> for_unlink)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span>  doc_tombstone *ut;
	ut = get_uthread_doc_tombstone();
				
	<span class="enscript-keyword">if</span> (for_unlink &amp;&amp; vp-&gt;v_type == VREG &amp;&amp; cp-&gt;c_linkcount &gt; 1) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// a regular file that is being unlinked and that is also
</span>		<span class="enscript-comment">// hardlinked should not clear the UF_TRACKED state or
</span>		<span class="enscript-comment">// mess with the tombstone because somewhere else in the
</span>		<span class="enscript-comment">// file system the file is still alive.
</span>		<span class="enscript-comment">// 
</span>		<span class="enscript-keyword">return</span>;
	}

	ut-&gt;t_lastop_parent     = dvp;
	ut-&gt;t_lastop_parent_vid = vnode_vid(dvp);
	ut-&gt;t_lastop_fileid     = cp-&gt;c_fileid;
	<span class="enscript-keyword">if</span> (for_unlink) {
		ut-&gt;t_lastop_item      = NULL;
		ut-&gt;t_lastop_item_vid  = 0;
	} <span class="enscript-keyword">else</span> {
		ut-&gt;t_lastop_item      = vp;
		ut-&gt;t_lastop_item_vid  = vnode_vid(vp);
	}
		
	strlcpy((<span class="enscript-type">char</span> *)&amp;ut-&gt;t_lastop_filename[0], cnp-&gt;cn_nameptr, <span class="enscript-keyword">sizeof</span>(ut-&gt;t_lastop_filename));
		
	<span class="enscript-type">struct</span> FndrExtendedFileInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16);
	ut-&gt;t_lastop_document_id = fip-&gt;document_id;

	<span class="enscript-keyword">if</span> (for_unlink) {
		<span class="enscript-comment">// clear this so it's never returned again
</span>		fip-&gt;document_id = 0;
		cp-&gt;c_bsdflags &amp;= ~UF_TRACKED;

		<span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id) {
			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr, NULL, NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-comment">// this event is more of a &quot;pending-delete&quot; 
</span>			add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
				    FSE_ARG_DEV, hfsmp-&gt;hfs_raw_dev,
				    FSE_ARG_INO, (ino64_t)cp-&gt;c_fileid,       <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO, (ino64_t)0,                  <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, ut-&gt;t_lastop_document_id,  <span class="enscript-comment">// document id
</span>				    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
		}
	}
}


<span class="enscript-comment">/*
 * Open a file/directory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_open</span>(<span class="enscript-type">struct</span> vnop_open_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> past_bootup = 0;
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_mode &amp; FWRITE) {
		<span class="enscript-comment">/* open for write */</span>
		<span class="enscript-keyword">if</span> ( hfs_file_is_compressed(cp, 1) ) { <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
			<span class="enscript-comment">/* opening a compressed file for write, so convert it to decompressed */</span>
			<span class="enscript-type">struct</span> vnode *data_vp = NULL;
			error = hfs_ref_data_vp(cp, &amp;data_vp, 1); <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
			<span class="enscript-keyword">if</span> (0 == error) {
				<span class="enscript-keyword">if</span> (data_vp) {
					error = decmpfs_decompress_file(data_vp, VTOCMP(data_vp), -1, 1, 0);
					vnode_rele(data_vp);
				} <span class="enscript-keyword">else</span> {
					error = EINVAL;
				}
			}
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">return</span> error;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* open for read */</span>
		<span class="enscript-keyword">if</span> (hfs_file_is_compressed(cp, 1) ) { <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
			<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
				<span class="enscript-comment">/* opening the resource fork of a compressed file, so nothing to do */</span>
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* opening a compressed file for read, make sure it validates */</span>
				error = decmpfs_validate_compressed_file(vp, VTOCMP(vp));
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">return</span> error;
			}
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Files marked append-only must be opened for appending.
	 */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;c_bsdflags &amp; APPEND) &amp;&amp; !vnode_isdir(vp) &amp;&amp;
	    (ap-&gt;a_mode &amp; (FWRITE | O_APPEND)) == FWRITE)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> (vnode_isreg(vp) &amp;&amp; !UBCINFOEXISTS(vp))
		<span class="enscript-keyword">return</span> (EBUSY);  <span class="enscript-comment">/* file is in use by the kernel */</span>

	<span class="enscript-comment">/* Don't allow journal to be opened externally. */</span>
	<span class="enscript-keyword">if</span> (hfs_is_journal_file(hfsmp, cp))
		<span class="enscript-keyword">return</span> (EPERM);

	bool have_lock = false;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (ISSET(ap-&gt;a_mode, FENCRYPTED) &amp;&amp; cp-&gt;c_cpentry &amp;&amp; vnode_isreg(vp)) {
		bool have_trunc_lock = false;


		<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
			<span class="enscript-keyword">if</span> (have_trunc_lock)
				hfs_unlock_truncate(cp, 0);
			<span class="enscript-keyword">return</span> error;
		}

		have_lock = true;

		<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry-&gt;cp_raw_open_count + 1
			&lt; cp-&gt;c_cpentry-&gt;cp_raw_open_count) {
			<span class="enscript-comment">// Overflow; too many raw opens on this file
</span>			hfs_unlock(cp);
			<span class="enscript-keyword">if</span> (have_trunc_lock)
				hfs_unlock_truncate(cp, 0);
			<span class="enscript-keyword">return</span> ENFILE;
		}


		<span class="enscript-keyword">if</span> (have_trunc_lock)
			hfs_unlock_truncate(cp, 0);

		++cp-&gt;c_cpentry-&gt;cp_raw_open_count;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) ||
	    (hfsmp-&gt;jnl == NULL) ||
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	    !vnode_isreg(vp) || vnode_isinuse(vp, 0) || vnode_isnamedstream(vp)) {
#<span class="enscript-reference">else</span>
	    !vnode_isreg(vp) || vnode_isinuse(vp, 0)) {
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-keyword">if</span> (have_lock)
			hfs_unlock(cp);
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (!have_lock &amp;&amp; (error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
		<span class="enscript-keyword">return</span> (error);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-comment">/* If we're going to write to the file, initialize quotas. */</span>
	<span class="enscript-keyword">if</span> ((ap-&gt;a_mode &amp; FWRITE) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS))
		(<span class="enscript-type">void</span>)hfs_getinoquota(cp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-comment">/*
	 * On the first (non-busy) open of a fragmented
	 * file attempt to de-frag it (if its less than 20MB).
	 */</span>
	fp = VTOF(vp);
	<span class="enscript-keyword">if</span> (fp-&gt;ff_blocks &amp;&amp;
	    fp-&gt;ff_extents[7].blockCount != 0 &amp;&amp;
	    fp-&gt;ff_size &lt;= (20 * 1024 * 1024)) {
		<span class="enscript-type">int</span> no_mods = 0;
		<span class="enscript-type">struct</span> timeval now;
		<span class="enscript-comment">/* 
		 * Wait until system bootup is done (3 min).
		 * And don't relocate a file that's been modified
		 * within the past minute -- this can lead to
		 * system thrashing.
		 */</span>

		<span class="enscript-keyword">if</span> (!past_bootup) {
			microuptime(&amp;tv);
			<span class="enscript-keyword">if</span> (tv.tv_sec &gt; (60*3)) {
				past_bootup = 1;
			}
		}
		
		microtime(&amp;now);
		<span class="enscript-keyword">if</span> ((now.tv_sec - cp-&gt;c_mtime) &gt; 60) {	
			no_mods = 1;
		} 
		
		<span class="enscript-keyword">if</span> (past_bootup &amp;&amp; no_mods) {
			(<span class="enscript-type">void</span>) hfs_relocate(vp, hfsmp-&gt;nextAllocation + 4096,
					vfs_context_ucred(ap-&gt;a_context),
					vfs_context_proc(ap-&gt;a_context));
		}
	}

	hfs_unlock(cp);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Close a file/directory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_close</span>(ap)
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		int a_fflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
 	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> busy;
	<span class="enscript-type">int</span> tooktrunclock = 0;
	<span class="enscript-type">int</span> knownrefs = 0;

	<span class="enscript-keyword">if</span> ( hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0)
		<span class="enscript-keyword">return</span> (0);
	cp = VTOC(vp);
	hfsmp = VTOHFS(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry &amp;&amp; ISSET(ap-&gt;a_fflag, FENCRYPTED) &amp;&amp; vnode_isreg(vp)) {
		assert(cp-&gt;c_cpentry-&gt;cp_raw_open_count &gt; 0);
		--cp-&gt;c_cpentry-&gt;cp_raw_open_count;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* 
	 * If the rsrc fork is a named stream, it can cause the data fork to
	 * stay around, preventing de-allocation of these blocks. 
	 * Do checks for truncation on close. Purge extra extents if they exist.
	 * Make sure the vp is not a directory, and that it has a resource fork,
	 * and that resource fork is also a named stream.
	 */</span>

	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VREG) &amp;&amp; (cp-&gt;c_rsrc_vp)
			&amp;&amp; (vnode_isnamedstream(cp-&gt;c_rsrc_vp))) {
		uint32_t blks;

		blks = howmany(VTOF(vp)-&gt;ff_size, VTOVCB(vp)-&gt;blockSize);
		<span class="enscript-comment">/*
		 * If there are extra blocks and there are only 2 refs on
		 * this vp (ourselves + rsrc fork holding ref on us), go ahead
		 * and try to truncate.
		 */</span>
		<span class="enscript-keyword">if</span> ((blks &lt; VTOF(vp)-&gt;ff_blocks) &amp;&amp; (!vnode_isinuse(vp, 2))) {
			<span class="enscript-comment">// release cnode lock; must acquire truncate lock BEFORE cnode lock
</span>			hfs_unlock(cp);

			hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			tooktrunclock = 1;

			<span class="enscript-keyword">if</span> (hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) { 
				hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
				<span class="enscript-comment">// bail out if we can't re-acquire cnode lock
</span>				<span class="enscript-keyword">return</span> 0;
			}
			<span class="enscript-comment">// now re-test to make sure it's still valid
</span>			<span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp) {
				knownrefs = 1 + vnode_isnamedstream(cp-&gt;c_rsrc_vp);
				<span class="enscript-keyword">if</span> (!vnode_isinuse(vp, knownrefs)){
					<span class="enscript-comment">// now we can truncate the file, if necessary
</span>					blks = howmany(VTOF(vp)-&gt;ff_size, VTOVCB(vp)-&gt;blockSize);
					<span class="enscript-keyword">if</span> (blks &lt; VTOF(vp)-&gt;ff_blocks){
						(<span class="enscript-type">void</span>) hfs_truncate(vp, VTOF(vp)-&gt;ff_size, IO_NDELAY,
											0, ap-&gt;a_context);
					}
				}
			}
		}
	}


	<span class="enscript-comment">// if we froze the fs and we're exiting, then &quot;thaw&quot; the fs 
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_freeze_state == HFS_FROZEN
	    &amp;&amp; hfsmp-&gt;hfs_freezing_proc == p &amp;&amp; proc_exiting(p)) {
		hfs_thaw(hfsmp, p);
	}

	busy = vnode_isinuse(vp, 1);

	<span class="enscript-keyword">if</span> (busy) {
		hfs_touchtimes(VTOHFS(vp), cp);	
	}
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		hfs_reldirhints(cp, busy);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_issystem(vp) &amp;&amp; !busy) {
		vnode_recycle(vp);
	}

	<span class="enscript-keyword">if</span> (tooktrunclock){
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}
	hfs_unlock(cp);

	<span class="enscript-keyword">if</span> (ap-&gt;a_fflag &amp; FWASWRITTEN) {
		hfs_sync_ejectable(hfsmp);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> bool <span class="enscript-function-name">hfs_should_generate_document_id</span>(hfsmount_t *hfsmp, cnode_t *cp)
{
	<span class="enscript-keyword">return</span> (!ISSET(hfsmp-&gt;hfs_flags, HFS_READ_ONLY)
			&amp;&amp; ISSET(cp-&gt;c_bsdflags, UF_TRACKED)
			&amp;&amp; cp-&gt;c_desc.cd_cnid != kHFSRootFolderID
			&amp;&amp; (S_ISDIR(cp-&gt;c_mode) || S_ISREG(cp-&gt;c_mode) || S_ISLNK(cp-&gt;c_mode)));
}

<span class="enscript-comment">/*
 * Get basic attributes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_getattr</span>(<span class="enscript-type">struct</span> vnop_getattr_args *ap)
{
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_TIMES</span>  \
	(VNODE_ATTR_va_access_time|VNODE_ATTR_va_change_time|VNODE_ATTR_va_modify_time)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNODE_ATTR_AUTH</span>  \
	(VNODE_ATTR_va_mode | VNODE_ATTR_va_uid | VNODE_ATTR_va_gid | \
         VNODE_ATTR_va_flags | VNODE_ATTR_va_acl)

	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> vnode *rvp = NULLVP;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> cnode *cp;
	uint64_t data_size;
	<span class="enscript-type">enum</span> vtype v_type;
	<span class="enscript-type">int</span> error = 0;
	cp = VTOC(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-comment">/* we need to inspect the decmpfs state of the file before we take the hfs cnode lock */</span>
	<span class="enscript-type">int</span> compressed = 0;
	<span class="enscript-type">int</span> hide_size = 0;
	off_t uncompressed_size = -1;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size) || VATTR_IS_ACTIVE(vap, va_total_alloc) || VATTR_IS_ACTIVE(vap, va_data_alloc) || VATTR_IS_ACTIVE(vap, va_total_size)) {
		<span class="enscript-comment">/* we only care about whether the file is compressed if asked for the uncompressed size */</span>
		<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
			<span class="enscript-comment">/* if it's a resource fork, decmpfs may want us to hide the size */</span>
			hide_size = hfs_hides_rsrc(ap-&gt;a_context, cp, 0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* if it's a data fork, we need to know if it was compressed so we can report the uncompressed size */</span>
			compressed = hfs_file_is_compressed(cp, 0);
		}
		<span class="enscript-keyword">if</span> ((VATTR_IS_ACTIVE(vap, va_data_size) || VATTR_IS_ACTIVE(vap, va_total_size))) {
			<span class="enscript-comment">// if it's compressed 
</span>			<span class="enscript-keyword">if</span> (compressed || (!VNODE_IS_RSRC(vp) &amp;&amp; cp-&gt;c_decmp &amp;&amp; cp-&gt;c_decmp-&gt;cmp_type &gt;= CMP_MAX)) {
				<span class="enscript-keyword">if</span> (0 != hfs_uncompressed_size_of_compressed_file(NULL, vp, 0, &amp;uncompressed_size, 0)) {
					<span class="enscript-comment">/* failed to get the uncompressed size, we'll check for this later */</span>
					uncompressed_size = -1;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// fake that it's compressed
</span>					compressed = 1;
				}
			}
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Shortcut for vnode_authorize path.  Each of the attributes
	 * in this set is updated atomically so we don't need to take
	 * the cnode lock to access them.
	 */</span>
	<span class="enscript-keyword">if</span> ((vap-&gt;va_active &amp; ~VNODE_ATTR_AUTH) == 0) {
		<span class="enscript-comment">/* Make sure file still exists. */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NOEXISTS)
			<span class="enscript-keyword">return</span> (ENOENT);

		vap-&gt;va_uid = cp-&gt;c_uid;
		vap-&gt;va_gid = cp-&gt;c_gid;
		vap-&gt;va_mode = cp-&gt;c_mode;
		vap-&gt;va_flags = cp-&gt;c_bsdflags;
		vap-&gt;va_supported |= VNODE_ATTR_AUTH &amp; ~VNODE_ATTR_va_acl;

		<span class="enscript-keyword">if</span> ((cp-&gt;c_attr.ca_recflags &amp; kHFSHasSecurityMask) == 0) {
			vap-&gt;va_acl = (kauth_acl_t) KAUTH_FILESEC_NONE;
			VATTR_SET_SUPPORTED(vap, va_acl);
		}
	
		<span class="enscript-keyword">return</span> (0);
	}

	hfsmp = VTOHFS(vp);
	v_type = vnode_vtype(vp);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_document_id)) {
		uint32_t document_id;

		<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_cnid == kHFSRootFolderID)
			document_id = kHFSRootFolderID;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * This is safe without a lock because we're just reading
			 * a 32 bit aligned integer which should be atomic on all
			 * platforms we support.
			 */</span>
			document_id = hfs_get_document_id(cp);

			<span class="enscript-keyword">if</span> (!document_id &amp;&amp; hfs_should_generate_document_id(hfsmp, cp)) {
				uint32_t new_document_id;

				error = hfs_generate_document_id(hfsmp, &amp;new_document_id);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">return</span> error;

				error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">return</span> error;

				bool want_docid_fsevent = false;

				<span class="enscript-comment">// Need to check again now that we have the lock
</span>				document_id = hfs_get_document_id(cp);
				<span class="enscript-keyword">if</span> (!document_id &amp;&amp; hfs_should_generate_document_id(hfsmp, cp)) {
					cp-&gt;c_attr.ca_finderextendeddirinfo.document_id = document_id = new_document_id;
					want_docid_fsevent = true;
					SET(cp-&gt;c_flag, C_MODIFIED);
				}

				hfs_unlock(cp);

				<span class="enscript-keyword">if</span> (want_docid_fsevent) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
					add_fsevent(FSE_DOCID_CHANGED, ap-&gt;a_context,
								FSE_ARG_DEV,   hfsmp-&gt;hfs_raw_dev,
								FSE_ARG_INO,   (ino64_t)0,             <span class="enscript-comment">// src inode #
</span>								FSE_ARG_INO,   (ino64_t)cp-&gt;c_fileid,  <span class="enscript-comment">// dst inode #
</span>								FSE_ARG_INT32, document_id,
								FSE_ARG_DONE);

					<span class="enscript-keyword">if</span> (need_fsevent(FSE_STAT_CHANGED, vp)) {
						add_fsevent(FSE_STAT_CHANGED, ap-&gt;a_context, 
									FSE_ARG_VNODE, vp, FSE_ARG_DONE);
					}
#<span class="enscript-reference">endif</span>
				}
			}
		}

		vap-&gt;va_document_id = document_id;
		VATTR_SET_SUPPORTED(vap, va_document_id);
	}

	<span class="enscript-comment">/*
	 * If time attributes are requested and we have cnode times
	 * that require updating, then acquire an exclusive lock on
	 * the cnode before updating the times.  Otherwise we can
	 * just acquire a shared lock.
	 */</span>
	<span class="enscript-keyword">if</span> ((vap-&gt;va_active &amp; VNODE_ATTR_TIMES) &amp;&amp;
	    (cp-&gt;c_touch_acctime || cp-&gt;c_touch_chgtime || cp-&gt;c_touch_modtime)) {
		<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
			<span class="enscript-keyword">return</span> (error);
		hfs_touchtimes(hfsmp, cp);

		<span class="enscript-comment">// downgrade to a shared lock since that's all we need from here on out
</span>		cp-&gt;c_lockowner = HFS_SHARED_OWNER;
		lck_rw_lock_exclusive_to_shared(&amp;cp-&gt;c_rwlock);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (v_type == VDIR) {
		data_size = (cp-&gt;c_entries + 2) * AVERAGE_HFSDIRENTRY_SIZE;

		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_nlink)) {
			<span class="enscript-type">int</span> nlink;
	
			<span class="enscript-comment">/*
			 * For directories, the va_nlink is esentially a count
			 * of the &quot;..&quot; references to a directory plus the &quot;.&quot;
			 * reference and the directory itself. So for HFS+ this
			 * becomes the sub-directory count plus two.
			 *
			 * In the absence of a sub-directory count we use the
			 * directory's item count.  This will be too high in
			 * most cases since it also includes files.
			 */</span>
			<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT) &amp;&amp; 
			    (cp-&gt;c_attr.ca_recflags &amp; kHFSHasFolderCountMask))
				nlink = cp-&gt;c_attr.ca_dircount;  <span class="enscript-comment">/* implied &quot;..&quot; entries */</span>
			<span class="enscript-keyword">else</span>
				nlink = cp-&gt;c_entries;

			<span class="enscript-comment">/* Account for ourself and our &quot;.&quot; entry */</span>
			nlink += 2;  
			 <span class="enscript-comment">/* Hide our private directories. */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_cnid == kHFSRootFolderID) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid != 0) {
					--nlink;    
				}
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid != 0) {
					--nlink;
				}
			}
			VATTR_RETURN(vap, va_nlink, (u_int64_t)nlink);
		}		
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_nchildren)) {
			<span class="enscript-type">int</span> entries;
	
			entries = cp-&gt;c_entries;
			<span class="enscript-comment">/* Hide our private files and directories. */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_cnid == kHFSRootFolderID) {
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid != 0)
					--entries;
				<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid != 0)
					--entries;
				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl || ((hfsmp-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY)))
					entries -= 2;   <span class="enscript-comment">/* hide the journal files */</span>
			}
			VATTR_RETURN(vap, va_nchildren, entries);
		}
		<span class="enscript-comment">/*
		 * The va_dirlinkcount is the count of real directory hard links.
		 * (i.e. its not the sum of the implied &quot;.&quot; and &quot;..&quot; references)
		 */</span>
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_dirlinkcount)) {
			VATTR_RETURN(vap, va_dirlinkcount, (uint32_t)cp-&gt;c_linkcount);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* !VDIR */</span> {
		data_size = VCTOF(vp, cp)-&gt;ff_size;

		VATTR_RETURN(vap, va_nlink, (u_int64_t)cp-&gt;c_linkcount);
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_alloc)) {
			u_int64_t blocks;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
			<span class="enscript-keyword">if</span> (hide_size) {
				VATTR_RETURN(vap, va_data_alloc, 0);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compressed) {
				<span class="enscript-comment">/* for compressed files, we report all allocated blocks as belonging to the data fork */</span>
				blocks = cp-&gt;c_blocks;
				VATTR_RETURN(vap, va_data_alloc, blocks * (u_int64_t)hfsmp-&gt;blockSize);
			}
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			{
				blocks = VCTOF(vp, cp)-&gt;ff_blocks;
				VATTR_RETURN(vap, va_data_alloc, blocks * (u_int64_t)hfsmp-&gt;blockSize);
			}
		}
	}

	<span class="enscript-comment">/* conditional because 64-bit arithmetic can be expensive */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_total_size)) {
		<span class="enscript-keyword">if</span> (v_type == VDIR) {
			VATTR_RETURN(vap, va_total_size, (cp-&gt;c_entries + 2) * AVERAGE_HFSDIRENTRY_SIZE);
		} <span class="enscript-keyword">else</span> {
			u_int64_t total_size = ~0ULL;
			<span class="enscript-type">struct</span> cnode *rcp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
			<span class="enscript-keyword">if</span> (hide_size) {
				<span class="enscript-comment">/* we're hiding the size of this file, so just return 0 */</span>
				total_size = 0;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compressed) {
				<span class="enscript-keyword">if</span> (uncompressed_size == -1) {
					<span class="enscript-comment">/*
					 * We failed to get the uncompressed size above,
					 * so we'll fall back to the standard path below
					 * since total_size is still -1
					 */</span>
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* use the uncompressed size we fetched above */</span>
					total_size = uncompressed_size;
				}
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (total_size == ~0ULL) {
				<span class="enscript-keyword">if</span> (cp-&gt;c_datafork) {
					total_size = cp-&gt;c_datafork-&gt;ff_size;
				}
				
				<span class="enscript-keyword">if</span> (cp-&gt;c_blocks - VTOF(vp)-&gt;ff_blocks) {
					<span class="enscript-comment">/* We deal with rsrc fork vnode iocount at the end of the function */</span>
					error = hfs_vgetrsrc(hfsmp, vp, &amp;rvp);
					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-comment">/*
						 * Note that we call hfs_vgetrsrc with error_on_unlinked
						 * set to FALSE.  This is because we may be invoked via
						 * fstat() on an open-unlinked file descriptor and we must 
						 * continue to support access to the rsrc fork until it disappears.
						 * The code at the end of this function will be
						 * responsible for releasing the iocount generated by 
						 * hfs_vgetrsrc.  This is because we can't drop the iocount
						 * without unlocking the cnode first.
						 */</span>
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
					}
					
					rcp = VTOC(rvp);
					<span class="enscript-keyword">if</span> (rcp &amp;&amp; rcp-&gt;c_rsrcfork) {
						total_size += rcp-&gt;c_rsrcfork-&gt;ff_size;
					}
				}
			}
			
			VATTR_RETURN(vap, va_total_size, total_size);
		}
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_total_alloc)) {
		<span class="enscript-keyword">if</span> (v_type == VDIR) {
			VATTR_RETURN(vap, va_total_alloc, 0);
		} <span class="enscript-keyword">else</span> {
			VATTR_RETURN(vap, va_total_alloc, (u_int64_t)cp-&gt;c_blocks * (u_int64_t)hfsmp-&gt;blockSize);
		}
	}

	<span class="enscript-comment">/*
	 * If the VFS wants extended security data, and we know that we
	 * don't have any (because it never told us it was setting any)
	 * then we can return the supported bit and no data.  If we do
	 * have extended security, we can just leave the bit alone and
	 * the VFS will use the fallback path to fetch it.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl)) {
		<span class="enscript-keyword">if</span> ((cp-&gt;c_attr.ca_recflags &amp; kHFSHasSecurityMask) == 0) {
			vap-&gt;va_acl = (kauth_acl_t) KAUTH_FILESEC_NONE;
			VATTR_SET_SUPPORTED(vap, va_acl);
		}
	}

	vap-&gt;va_access_time.tv_sec = cp-&gt;c_atime;
	vap-&gt;va_access_time.tv_nsec = 0;
	vap-&gt;va_create_time.tv_sec = cp-&gt;c_itime;
	vap-&gt;va_create_time.tv_nsec = 0;
	vap-&gt;va_modify_time.tv_sec = cp-&gt;c_mtime;
	vap-&gt;va_modify_time.tv_nsec = 0;
	vap-&gt;va_change_time.tv_sec = cp-&gt;c_ctime;
	vap-&gt;va_change_time.tv_nsec = 0;
	vap-&gt;va_backup_time.tv_sec = cp-&gt;c_btime;
	vap-&gt;va_backup_time.tv_nsec = 0;	

	<span class="enscript-comment">/* See if we need to emit the date added field to the user */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_addedtime)) {
		u_int32_t dateadded = hfs_get_dateadded (cp);
		<span class="enscript-keyword">if</span> (dateadded) {
			vap-&gt;va_addedtime.tv_sec = dateadded;
			vap-&gt;va_addedtime.tv_nsec = 0;
			VATTR_SET_SUPPORTED (vap, va_addedtime);
		}
	}

	<span class="enscript-comment">/* XXX is this really a good 'optimal I/O size'? */</span>
	vap-&gt;va_iosize = hfsmp-&gt;hfs_logBlockSize;
	vap-&gt;va_uid = cp-&gt;c_uid;
	vap-&gt;va_gid = cp-&gt;c_gid;
	vap-&gt;va_mode = cp-&gt;c_mode;
	vap-&gt;va_flags = cp-&gt;c_bsdflags;

	<span class="enscript-comment">/*
	 * Exporting file IDs from HFS Plus:
	 *
	 * For &quot;normal&quot; files the c_fileid is the same value as the
	 * c_cnid.  But for hard link files, they are different - the
	 * c_cnid belongs to the active directory entry (ie the link)
	 * and the c_fileid is for the actual inode (ie the data file).
	 *
	 * The stat call (getattr) uses va_fileid and the Carbon APIs,
	 * which are hardlink-ignorant, will ask for va_linkid.
	 */</span>
	vap-&gt;va_fileid = (u_int64_t)cp-&gt;c_fileid;
	<span class="enscript-comment">/* 
	 * We need to use the origin cache for both hardlinked files 
	 * and directories. Hardlinked directories have multiple cnids 
	 * and parents (one per link). Hardlinked files also have their 
	 * own parents and link IDs separate from the indirect inode number. 
	 * If we don't use the cache, we could end up vending the wrong ID 
	 * because the cnode will only reflect the link that was looked up most recently.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_HARDLINK) {
		vap-&gt;va_linkid = (u_int64_t)hfs_currentcnid(cp);
		vap-&gt;va_parentid = (u_int64_t)hfs_currentparent(cp, <span class="enscript-comment">/* have_lock: */</span> true);
	} <span class="enscript-keyword">else</span> {
		vap-&gt;va_linkid = (u_int64_t)cp-&gt;c_cnid;
		vap-&gt;va_parentid = (u_int64_t)cp-&gt;c_parentcnid;
	}
	vap-&gt;va_fsid = hfsmp-&gt;hfs_raw_dev;
	vap-&gt;va_filerev = 0;
	vap-&gt;va_encoding = cp-&gt;c_encoding;
	vap-&gt;va_rdev = (v_type == VBLK || v_type == VCHR) ? cp-&gt;c_rdev : 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-keyword">if</span> (hide_size)
			vap-&gt;va_data_size = 0;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (compressed) {
			<span class="enscript-keyword">if</span> (uncompressed_size == -1) {
				<span class="enscript-comment">/* failed to get the uncompressed size above, so just return data_size */</span>
				vap-&gt;va_data_size = data_size;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* use the uncompressed size we fetched above */</span>
				vap-&gt;va_data_size = uncompressed_size;
			}
		} <span class="enscript-keyword">else</span>
			vap-&gt;va_data_size = data_size;
		VATTR_SET_SUPPORTED(vap, va_data_size);
	}
#<span class="enscript-reference">else</span>
	vap-&gt;va_data_size = data_size;
	vap-&gt;va_supported |= VNODE_ATTR_va_data_size;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_dataprotect_class)) {
    		vap-&gt;va_dataprotect_class = cp-&gt;c_cpentry ? CP_CLASS(cp-&gt;c_cpentry-&gt;cp_pclass) : 0;
    		VATTR_SET_SUPPORTED(vap, va_dataprotect_class);
    	} 	
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_write_gencount)) {
		<span class="enscript-keyword">if</span> (ubc_is_mapped_writable(vp)) {
			<span class="enscript-comment">/*
			 * Return 0 to the caller to indicate the file may be
			 * changing.  There is no need for us to increment the
			 * generation counter here because it gets done as part of
			 * page-out and also when the file is unmapped (to account
			 * for changes we might not have seen).
			 */</span>
			vap-&gt;va_write_gencount = 0;
		} <span class="enscript-keyword">else</span> {
			vap-&gt;va_write_gencount = hfs_get_gencount(cp);
		}

		VATTR_SET_SUPPORTED(vap, va_write_gencount);
	}

	<span class="enscript-comment">/* Mark them all at once instead of individual VATTR_SET_SUPPORTED calls. */</span>
	vap-&gt;va_supported |= VNODE_ATTR_va_access_time |
						 VNODE_ATTR_va_create_time | VNODE_ATTR_va_modify_time |
	                     VNODE_ATTR_va_change_time| VNODE_ATTR_va_backup_time |
	                     VNODE_ATTR_va_iosize | VNODE_ATTR_va_uid |
	                     VNODE_ATTR_va_gid | VNODE_ATTR_va_mode |
	                     VNODE_ATTR_va_flags |VNODE_ATTR_va_fileid |
	                     VNODE_ATTR_va_linkid | VNODE_ATTR_va_parentid |
	                     VNODE_ATTR_va_fsid | VNODE_ATTR_va_filerev |
	                     VNODE_ATTR_va_encoding | VNODE_ATTR_va_rdev;

	<span class="enscript-comment">/* If this is the root, let VFS to find out the mount name, which 
	 * may be different from the real name.  Otherwise, we need to take care
	 * for hardlinked files, which need to be looked up, if necessary 
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_name) &amp;&amp; (cp-&gt;c_cnid != kHFSRootFolderID)) {
		<span class="enscript-type">struct</span> cat_desc linkdesc;
		<span class="enscript-type">int</span> lockflags;
		<span class="enscript-type">int</span> uselinkdesc = 0;
		cnid_t nextlinkid = 0;
		cnid_t prevlinkid = 0;

		<span class="enscript-comment">/* Get the name for ATTR_CMN_NAME.  We need to take special care for hardlinks      
		 * here because the info. for the link ID requested by getattrlist may be
		 * different than what's currently in the cnode.  This is because the cnode     
		 * will be filled in with the information for the most recent link ID that went
		 * through namei/lookup().  If there are competing lookups for hardlinks that point 
	 	 * to the same inode, one (or more) getattrlists could be vended incorrect name information.
		 * Also, we need to beware of open-unlinked files which could have a namelen of 0.     
		 */</span>

		<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_HARDLINK) &amp;&amp; 
				((cp-&gt;c_desc.cd_namelen == 0) || (vap-&gt;va_linkid != cp-&gt;c_cnid))) {
			<span class="enscript-comment">/* 
			 * If we have no name and our link ID is the raw inode number, then we may
			 * have an open-unlinked file.  Go to the next link in this case.
			 */</span>
			<span class="enscript-keyword">if</span> ((cp-&gt;c_desc.cd_namelen == 0) &amp;&amp; (vap-&gt;va_linkid == cp-&gt;c_fileid)) {
				<span class="enscript-keyword">if</span> ((error = hfs_lookup_siblinglinks(hfsmp, vap-&gt;va_linkid, &amp;prevlinkid, &amp;nextlinkid))){
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}	
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* just use link obtained from vap above */</span>
				nextlinkid = vap-&gt;va_linkid;
			}

			<span class="enscript-comment">/* We need to probe the catalog for the descriptor corresponding to the link ID
			 * stored in nextlinkid.  Note that we don't know if we have the exclusive lock
			 * for the cnode here, so we can't just update the descriptor.  Instead,
			 * we should just store the descriptor's value locally and then use it to pass
			 * out the name value as needed below. 
			 */</span> 
			<span class="enscript-keyword">if</span> (nextlinkid){
				lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
				error = cat_findname(hfsmp, nextlinkid, &amp;linkdesc);
				hfs_systemfile_unlock(hfsmp, lockflags);	
				<span class="enscript-keyword">if</span> (error == 0) {
					uselinkdesc = 1;
				}
			}
		}

		<span class="enscript-comment">/* By this point, we've either patched up the name above and the c_desc
		 * points to the correct data, or it already did, in which case we just proceed
		 * by copying the name into the vap.  Note that we will never set va_name to
		 * supported if nextlinkid is never initialized.  This could happen in the degenerate
		 * case above involving the raw inode number, where it has no nextlinkid.  In this case
		 * we will simply not mark the name bit as supported.
		 */</span>
		<span class="enscript-keyword">if</span> (uselinkdesc) {
			strlcpy(vap-&gt;va_name, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) linkdesc.cd_nameptr, MAXPATHLEN);
			VATTR_SET_SUPPORTED(vap, va_name);
			cat_releasedesc(&amp;linkdesc);
		}	
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_namelen) {
			strlcpy(vap-&gt;va_name, (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*) cp-&gt;c_desc.cd_nameptr, MAXPATHLEN);
			VATTR_SET_SUPPORTED(vap, va_name);
		}
	}

<span class="enscript-reference">out</span>:
	hfs_unlock(cp);
	<span class="enscript-comment">/*
	 * We need to vnode_put the rsrc fork vnode only *after* we've released
	 * the cnode lock, since vnode_put can trigger an inactive call, which 
	 * will go back into HFS and try to acquire a cnode lock.
	 */</span>
	<span class="enscript-keyword">if</span> (rvp) {
		vnode_put (rvp);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_setattr</span>(ap)
	<span class="enscript-type">struct</span> vnop_setattr_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	kauth_cred_t cred = vfs_context_ucred(ap-&gt;a_context);
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">int</span> error = 0;
	uid_t nuid;
	gid_t ngid;
	time_t orig_ctime;

	orig_ctime = VTOC(vp)-&gt;c_ctime;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-type">int</span> decmpfs_reset_state = 0;
	<span class="enscript-comment">/*
	 we call decmpfs_update_attributes even if the file is not compressed
	 because we want to update the incoming flags if the xattrs are invalid
	 */</span>
	error = decmpfs_update_attributes(vp, vap);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if this is not a size-changing setattr and it is not just
</span>	<span class="enscript-comment">// an atime update, then check for a snapshot.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_data_size) &amp;&amp; !(vap-&gt;va_active == VNODE_ATTR_va_access_time)) {
		check_for_tracked_file(vp, orig_ctime, NAMESPACE_HANDLER_METADATA_MOD, NSPACE_REARM_NO_ARG);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/*
	 * All metadata changes should be allowed except a size-changing setattr, which
	 * has effects on file content and requires calling into cp_handle_vnop
	 * to have content protection check.
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-keyword">if</span> ((error = cp_handle_vnop(vp, CP_WRITE_ACCESS, 0)) != 0) {
			<span class="enscript-keyword">return</span> (error);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>

	hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/* Don't allow modification of the journal. */</span>
	<span class="enscript-keyword">if</span> (hfs_is_journal_file(hfsmp, VTOC(vp))) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Check if we'll need a document_id and if so, get it before we lock the
</span>	<span class="enscript-comment">// the cnode to avoid any possible deadlock with the root vnode which has
</span>	<span class="enscript-comment">// to get locked to get the document id
</span>	<span class="enscript-comment">//
</span>	u_int32_t document_id=0;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags) &amp;&amp; (vap-&gt;va_flags &amp; UF_TRACKED) &amp;&amp; !(VTOC(vp)-&gt;c_bsdflags &amp; UF_TRACKED)) {
		<span class="enscript-type">struct</span> FndrExtendedDirInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;(VTOC(vp)-&gt;c_attr.ca_finderinfo) + 16);
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// If the document_id is not set, get a new one.  It will be set
</span>		<span class="enscript-comment">// on the file down below once we hold the cnode lock.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (fip-&gt;document_id == 0) {
			<span class="enscript-keyword">if</span> (hfs_generate_document_id(hfsmp, &amp;document_id) != 0) {
				document_id = 0;
			}
		}
	}


	<span class="enscript-comment">/*
	 * File size change request.
	 * We are guaranteed that this is not a directory, and that
	 * the filesystem object is writeable.
	 *
	 * NOTE: HFS COMPRESSION depends on the data_size being set *before* the bsd flags are updated
	 */</span>
	VATTR_SET_SUPPORTED(vap, va_data_size);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size) &amp;&amp; !vnode_islnk(vp)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-comment">/* keep the compressed state locked until we're done truncating the file */</span>
		decmpfs_cnode *dp = VTOCMP(vp);
		<span class="enscript-keyword">if</span> (!dp) {
			<span class="enscript-comment">/*
			 * call hfs_lazy_init_decmpfs_cnode() to make sure that the decmpfs_cnode
			 * is filled in; we need a decmpfs_cnode to lock out decmpfs state changes
			 * on this file while it's truncating
			 */</span>
			dp = hfs_lazy_init_decmpfs_cnode(VTOC(vp));
			<span class="enscript-keyword">if</span> (!dp) {
				<span class="enscript-comment">/* failed to allocate a decmpfs_cnode */</span>
				<span class="enscript-keyword">return</span> ENOMEM; <span class="enscript-comment">/* what should this be? */</span>
			}
		}
		
		check_for_tracked_file(vp, orig_ctime, vap-&gt;va_data_size == 0 ? NAMESPACE_HANDLER_TRUNCATE_OP|NAMESPACE_HANDLER_DELETE_OP : NAMESPACE_HANDLER_TRUNCATE_OP, NULL);

		decmpfs_lock_compressed_data(dp, 1);
		<span class="enscript-keyword">if</span> (hfs_file_is_compressed(VTOC(vp), 1)) {
			error = decmpfs_decompress_file(vp, dp, -1<span class="enscript-comment">/*vap-&gt;va_data_size*/</span>, 0, 1);
			<span class="enscript-keyword">if</span> (error != 0) {
				decmpfs_unlock_compressed_data(dp, 1);
				<span class="enscript-keyword">return</span> error;
			}
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">// Take truncate lock
</span>		hfs_lock_truncate(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

		<span class="enscript-comment">// hfs_truncate will deal with the cnode lock
</span>		error = hfs_truncate(vp, vap-&gt;va_data_size, vap-&gt;va_vaflags &amp; 0xffff, 
							 0, ap-&gt;a_context);

		hfs_unlock_truncate(VTOC(vp), HFS_LOCK_DEFAULT);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		decmpfs_unlock_compressed_data(dp, 1);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> (cp == NULL) {
		<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
			<span class="enscript-keyword">return</span> (error);
		cp = VTOC(vp);
	}

	<span class="enscript-comment">/*
	 * If it is just an access time update request by itself
	 * we know the request is from kernel level code, and we
	 * can delay it without being as worried about consistency.
	 * This change speeds up mmaps, in the rare case that they
	 * get caught behind a sync.
	 */</span>

	<span class="enscript-keyword">if</span> (vap-&gt;va_active == VNODE_ATTR_va_access_time) {
		cp-&gt;c_touch_acctime=TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}



	<span class="enscript-comment">/*
	 * Owner/group change request.
	 * We are guaranteed that the new owner/group is valid and legal.
	 */</span>
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	nuid = VATTR_IS_ACTIVE(vap, va_uid) ? vap-&gt;va_uid : (uid_t)VNOVAL;
	ngid = VATTR_IS_ACTIVE(vap, va_gid) ? vap-&gt;va_gid : (gid_t)VNOVAL;
	<span class="enscript-keyword">if</span> (((nuid != (uid_t)VNOVAL) || (ngid != (gid_t)VNOVAL)) &amp;&amp;
	    ((error = hfs_chown(vp, nuid, ngid, cred, p)) != 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Mode change request.
	 * We are guaranteed that the mode value is valid and that in
	 * conjunction with the owner and group, this change is legal.
   	*/</span>
	VATTR_SET_SUPPORTED(vap, va_mode);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp;
	    ((error = hfs_chmod(vp, (<span class="enscript-type">int</span>)vap-&gt;va_mode, cred, p)) != 0))
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * File flags change.
	 * We are guaranteed that only flags allowed to change given the
	 * current securelevel are being changed.
	 */</span>
	VATTR_SET_SUPPORTED(vap, va_flags);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		u_int16_t *fdFlags;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_bsdflags ^ vap-&gt;va_flags) &amp; UF_COMPRESSED) {
			<span class="enscript-comment">/*
			 * the UF_COMPRESSED was toggled, so reset our cached compressed state
			 * but we don't want to actually do the update until we've released the cnode lock down below
			 * NOTE: turning the flag off doesn't actually decompress the file, so that we can
			 * turn off the flag and look at the &quot;raw&quot; file for debugging purposes
			 */</span>
			decmpfs_reset_state = 1;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ((vap-&gt;va_flags &amp; UF_TRACKED) &amp;&amp; !(cp-&gt;c_bsdflags &amp; UF_TRACKED)) {
			<span class="enscript-type">struct</span> FndrExtendedDirInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16);

			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// we're marking this item UF_TRACKED.  if the document_id is
</span>			<span class="enscript-comment">// not set, get a new one and put it on the file.
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-keyword">if</span> (fip-&gt;document_id == 0) {
				<span class="enscript-keyword">if</span> (document_id != 0) {
					<span class="enscript-comment">// printf(&quot;SETATTR: assigning doc-id %d to %s (ino %d)\n&quot;, document_id, vp-&gt;v_name, cp-&gt;c_desc.cd_cnid);
</span>					fip-&gt;document_id = (uint32_t)document_id;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
					add_fsevent(FSE_DOCID_CHANGED, ap-&gt;a_context,
						    FSE_ARG_DEV, hfsmp-&gt;hfs_raw_dev,
						    FSE_ARG_INO, (ino64_t)0,                <span class="enscript-comment">// src inode #
</span>						    FSE_ARG_INO, (ino64_t)cp-&gt;c_fileid,     <span class="enscript-comment">// dst inode #
</span>						    FSE_ARG_INT32, document_id,
						    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">// printf(&quot;hfs: could not acquire a new document_id for %s (ino %d)\n&quot;, vp-&gt;v_name, cp-&gt;c_desc.cd_cnid);
</span>				}
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(vap-&gt;va_flags &amp; UF_TRACKED) &amp;&amp; (cp-&gt;c_bsdflags &amp; UF_TRACKED)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// UF_TRACKED is being cleared so clear the document_id
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-type">struct</span> FndrExtendedDirInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16);
			<span class="enscript-keyword">if</span> (fip-&gt;document_id) {
				<span class="enscript-comment">// printf(&quot;SETATTR: clearing doc-id %d from %s (ino %d)\n&quot;, fip-&gt;document_id, vp-&gt;v_name, cp-&gt;c_desc.cd_cnid);
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
				add_fsevent(FSE_DOCID_CHANGED, ap-&gt;a_context,
					    FSE_ARG_DEV, hfsmp-&gt;hfs_raw_dev,
					    FSE_ARG_INO, (ino64_t)cp-&gt;c_fileid,          <span class="enscript-comment">// src inode #
</span>					    FSE_ARG_INO, (ino64_t)0,                     <span class="enscript-comment">// dst inode #
</span>					    FSE_ARG_INT32, fip-&gt;document_id,             <span class="enscript-comment">// document id
</span>					    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
				fip-&gt;document_id = 0;
				cp-&gt;c_bsdflags &amp;= ~UF_TRACKED;
			}
		}

		cp-&gt;c_bsdflags = vap-&gt;va_flags;
		cp-&gt;c_flag |= C_MODIFIED;
		cp-&gt;c_touch_chgtime = TRUE;

		
		<span class="enscript-comment">/*
		 * Mirror the UF_HIDDEN flag to the invisible bit of the Finder Info.
		 *
		 * The fdFlags for files and frFlags for folders are both 8 bytes
		 * into the userInfo (the first 16 bytes of the Finder Info).  They
		 * are both 16-bit fields.
		 */</span>
		fdFlags = (u_int16_t *) &amp;cp-&gt;c_finderinfo[8];
		<span class="enscript-keyword">if</span> (vap-&gt;va_flags &amp; UF_HIDDEN)
			*fdFlags |= OSSwapHostToBigConstInt16(kFinderInvisibleMask);
		<span class="enscript-keyword">else</span>
			*fdFlags &amp;= ~OSSwapHostToBigConstInt16(kFinderInvisibleMask);
	}

	<span class="enscript-comment">/*
	 * Timestamp updates.
	 */</span>
	VATTR_SET_SUPPORTED(vap, va_create_time);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	VATTR_SET_SUPPORTED(vap, va_backup_time);
	VATTR_SET_SUPPORTED(vap, va_change_time);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time) ||
	    VATTR_IS_ACTIVE(vap, va_access_time) ||
	    VATTR_IS_ACTIVE(vap, va_modify_time) ||
	    VATTR_IS_ACTIVE(vap, va_backup_time)) {
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time))
			cp-&gt;c_itime = vap-&gt;va_create_time.tv_sec;
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_access_time)) {
			cp-&gt;c_atime = vap-&gt;va_access_time.tv_sec;
			cp-&gt;c_touch_acctime = FALSE;
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time)) {
			cp-&gt;c_mtime = vap-&gt;va_modify_time.tv_sec;
			cp-&gt;c_touch_modtime = FALSE;
			cp-&gt;c_touch_chgtime = TRUE;

			hfs_clear_might_be_dirty_flag(cp);

			<span class="enscript-comment">/*
			 * The utimes system call can reset the modification
			 * time but it doesn't know about HFS create times.
			 * So we need to ensure that the creation time is
			 * always at least as old as the modification time.
			 */</span>
			<span class="enscript-keyword">if</span> ((VTOVCB(vp)-&gt;vcbSigWord == kHFSPlusSigWord) &amp;&amp;
			    (cp-&gt;c_cnid != kHFSRootFolderID) &amp;&amp;
				!VATTR_IS_ACTIVE(vap, va_create_time) &amp;&amp;
			    (cp-&gt;c_mtime &lt; cp-&gt;c_itime)) {
				cp-&gt;c_itime = cp-&gt;c_mtime;
			}
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_backup_time))
			cp-&gt;c_btime = vap-&gt;va_backup_time.tv_sec;
		cp-&gt;c_flag |= C_MINOR_MOD;
	}
	
	<span class="enscript-comment">/*
	 * Set name encoding.
	 */</span>
	VATTR_SET_SUPPORTED(vap, va_encoding);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_encoding)) {
		cp-&gt;c_encoding = vap-&gt;va_encoding;
		cp-&gt;c_flag |= C_MODIFIED;
		hfs_setencodingbits(hfsmp, cp-&gt;c_encoding);
	}

	<span class="enscript-keyword">if</span> ((error = hfs_update(vp, 0)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (cp) {
		<span class="enscript-comment">/* Purge origin cache for cnode, since caller now has correct link ID for it 
		 * We purge it here since it was acquired for us during lookup, and we no longer need it.
		 */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_HARDLINK) &amp;&amp; (vp-&gt;v_type != VDIR)){
			hfs_relorigin(cp, 0);
		}

		hfs_unlock(cp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> (decmpfs_reset_state) {
			<span class="enscript-comment">/*
			 * we've changed the UF_COMPRESSED flag, so reset the decmpfs state for this cnode
			 * but don't do it while holding the hfs cnode lock
			 */</span>
			decmpfs_cnode *dp = VTOCMP(vp);
			<span class="enscript-keyword">if</span> (!dp) {
				<span class="enscript-comment">/*
				 * call hfs_lazy_init_decmpfs_cnode() to make sure that the decmpfs_cnode
				 * is filled in; we need a decmpfs_cnode to prevent decmpfs state changes
				 * on this file if it's locked
				 */</span>
				dp = hfs_lazy_init_decmpfs_cnode(VTOC(vp));
				<span class="enscript-keyword">if</span> (!dp) {
					<span class="enscript-comment">/* failed to allocate a decmpfs_cnode */</span>
					<span class="enscript-keyword">return</span> ENOMEM; <span class="enscript-comment">/* what should this be? */</span>
				}
			}
			decmpfs_cnode_set_vnode_state(dp, FILE_TYPE_UNKNOWN, 0);
		}
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Change the mode on a file.
 * cnode must be locked before calling.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_chmod</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> mode, __unused kauth_cred_t cred, __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> cnode *cp = VTOC(vp);

	<span class="enscript-keyword">if</span> (VTOVCB(vp)-&gt;vcbSigWord != kHFSPlusSigWord)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">// Don't allow modification of the journal or journal_info_block
</span>	<span class="enscript-keyword">if</span> (hfs_is_journal_file(VTOHFS(vp), cp)) {
		<span class="enscript-keyword">return</span> EPERM;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">OVERRIDE_UNKNOWN_PERMISSIONS</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(VTOVFS(vp))) &amp; MNT_UNKNOWNPERMISSIONS) {
		<span class="enscript-keyword">return</span> (0);
	};
#<span class="enscript-reference">endif</span>

	mode_t new_mode = (cp-&gt;c_mode &amp; ~ALLPERMS) | (mode &amp; ALLPERMS);
	<span class="enscript-keyword">if</span> (new_mode != cp-&gt;c_mode) {
		cp-&gt;c_mode = new_mode;
		cp-&gt;c_flag |= C_MINOR_MOD;
	}
	cp-&gt;c_touch_chgtime = TRUE;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_write_access</span>(<span class="enscript-type">struct</span> vnode *vp, kauth_cred_t cred, <span class="enscript-type">struct</span> proc *p, Boolean considerFlags)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> is_member;

	<span class="enscript-comment">/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */</span>
	<span class="enscript-keyword">switch</span> (vnode_vtype(vp)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
 	<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
		<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;hfs_flags &amp; HFS_READ_ONLY)
			<span class="enscript-keyword">return</span> (EROFS);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
 	}
 
	<span class="enscript-comment">/* If immutable bit set, nobody gets to write it. */</span>
	<span class="enscript-keyword">if</span> (considerFlags &amp;&amp; (cp-&gt;c_bsdflags &amp; IMMUTABLE))
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* Otherwise, user id 0 always gets access. */</span>
	<span class="enscript-keyword">if</span> (!suser(cred, NULL))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* Otherwise, check the owner. */</span>
	<span class="enscript-keyword">if</span> ((retval = hfs_owner_rights(VTOHFS(vp), cp-&gt;c_uid, cred, p, false)) == 0)
		<span class="enscript-keyword">return</span> ((cp-&gt;c_mode &amp; S_IWUSR) == S_IWUSR ? 0 : EACCES);
 
	<span class="enscript-comment">/* Otherwise, check the groups. */</span>
	<span class="enscript-keyword">if</span> (kauth_cred_ismember_gid(cred, cp-&gt;c_gid, &amp;is_member) == 0 &amp;&amp; is_member) {
		<span class="enscript-keyword">return</span> ((cp-&gt;c_mode &amp; S_IWGRP) == S_IWGRP ? 0 : EACCES);
 	}
 
	<span class="enscript-comment">/* Otherwise, check everyone else. */</span>
	<span class="enscript-keyword">return</span> ((cp-&gt;c_mode &amp; S_IWOTH) == S_IWOTH ? 0 : EACCES);
}


<span class="enscript-comment">/*
 * Perform chown operation on cnode cp;
 * code must be locked prior to call.
 */</span>
<span class="enscript-type">int</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">QUOTA</span>
<span class="enscript-function-name">hfs_chown</span>(<span class="enscript-type">struct</span> vnode *vp, uid_t uid, gid_t gid, __unused kauth_cred_t cred,
	__unused <span class="enscript-type">struct</span> proc *p)
#<span class="enscript-reference">else</span> 
<span class="enscript-function-name">hfs_chown</span>(<span class="enscript-type">struct</span> vnode *vp, uid_t uid, gid_t gid, kauth_cred_t cred,
	__unused <span class="enscript-type">struct</span> proc *p)
#<span class="enscript-reference">endif</span>
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	uid_t ouid;
	gid_t ogid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;
	int64_t change;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-keyword">if</span> (VTOVCB(vp)-&gt;vcbSigWord != kHFSPlusSigWord)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(VTOVFS(vp))) &amp; MNT_UNKNOWNPERMISSIONS)
		<span class="enscript-keyword">return</span> (0);
	
	<span class="enscript-keyword">if</span> (uid == (uid_t)VNOVAL)
		uid = cp-&gt;c_uid;
	<span class="enscript-keyword">if</span> (gid == (gid_t)VNOVAL)
		gid = cp-&gt;c_gid;

#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* we are guaranteed that this is already the case */</span>
	<span class="enscript-comment">/*
	 * If we don't own the file, are trying to change the owner
	 * of the file, or are not a member of the target group,
	 * the caller must be superuser or the call fails.
	 */</span>
	<span class="enscript-keyword">if</span> ((kauth_cred_getuid(cred) != cp-&gt;c_uid || uid != cp-&gt;c_uid ||
	    (gid != cp-&gt;c_gid &amp;&amp;
	     (kauth_cred_ismember_gid(cred, gid, &amp;is_member) || !is_member))) &amp;&amp;
	    (error = suser(cred, 0)))
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	ogid = cp-&gt;c_gid;
	ouid = cp-&gt;c_uid;

	<span class="enscript-keyword">if</span> (ouid == uid &amp;&amp; ogid == gid) {
		<span class="enscript-comment">// No change, just set change time
</span>		cp-&gt;c_touch_chgtime = TRUE;
		<span class="enscript-keyword">return</span> 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> ((error = hfs_getinoquota(cp)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (ouid == uid) {
		dqrele(cp-&gt;c_dquot[USRQUOTA]);
		cp-&gt;c_dquot[USRQUOTA] = NODQUOT;
	}
	<span class="enscript-keyword">if</span> (ogid == gid) {
		dqrele(cp-&gt;c_dquot[GRPQUOTA]);
		cp-&gt;c_dquot[GRPQUOTA] = NODQUOT;
	}

	<span class="enscript-comment">/*
	 * Eventually need to account for (fake) a block per directory
	 * if (vnode_isdir(vp))
	 *     change = VTOHFS(vp)-&gt;blockSize;
	 * else
	 */</span>

	change = (int64_t)(cp-&gt;c_blocks) * (int64_t)VTOVCB(vp)-&gt;blockSize;
	(<span class="enscript-type">void</span>) hfs_chkdq(cp, -change, cred, CHOWN);
	(<span class="enscript-type">void</span>) hfs_chkiq(cp, -1, cred, CHOWN);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++) {
		dqrele(cp-&gt;c_dquot[i]);
		cp-&gt;c_dquot[i] = NODQUOT;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
	cp-&gt;c_gid = gid;
	cp-&gt;c_uid = uid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> ((error = hfs_getinoquota(cp)) == 0) {
		<span class="enscript-keyword">if</span> (ouid == uid) {
			dqrele(cp-&gt;c_dquot[USRQUOTA]);
			cp-&gt;c_dquot[USRQUOTA] = NODQUOT;
		}
		<span class="enscript-keyword">if</span> (ogid == gid) {
			dqrele(cp-&gt;c_dquot[GRPQUOTA]);
			cp-&gt;c_dquot[GRPQUOTA] = NODQUOT;
		}
		<span class="enscript-keyword">if</span> ((error = hfs_chkdq(cp, change, cred, CHOWN)) == 0) {
			<span class="enscript-keyword">if</span> ((error = hfs_chkiq(cp, 1, cred, CHOWN)) == 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">good</span>;
			<span class="enscript-keyword">else</span>
				(<span class="enscript-type">void</span>) hfs_chkdq(cp, -change, cred, CHOWN|FORCE);
		}
		<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++) {
			dqrele(cp-&gt;c_dquot[i]);
			cp-&gt;c_dquot[i] = NODQUOT;
		}
	}
	cp-&gt;c_gid = ogid;
	cp-&gt;c_uid = ouid;
	<span class="enscript-keyword">if</span> (hfs_getinoquota(cp) == 0) {
		<span class="enscript-keyword">if</span> (ouid == uid) {
			dqrele(cp-&gt;c_dquot[USRQUOTA]);
			cp-&gt;c_dquot[USRQUOTA] = NODQUOT;
		}
		<span class="enscript-keyword">if</span> (ogid == gid) {
			dqrele(cp-&gt;c_dquot[GRPQUOTA]);
			cp-&gt;c_dquot[GRPQUOTA] = NODQUOT;
		}
		(<span class="enscript-type">void</span>) hfs_chkdq(cp, change, cred, FORCE|CHOWN);
		(<span class="enscript-type">void</span>) hfs_chkiq(cp, 1, cred, FORCE|CHOWN);
		(<span class="enscript-type">void</span>) hfs_getinoquota(cp);
	}
	<span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">good</span>:
	<span class="enscript-keyword">if</span> (hfs_getinoquota(cp))
		panic(<span class="enscript-string">&quot;hfs_chown: lost quota&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-comment">/*
	 * Without quotas, we could probably make this a minor
	 * modification.
	 */</span>
	cp-&gt;c_flag |= C_MODIFIED;

	<span class="enscript-comment">/*
	  According to the SUSv3 Standard, chown() shall mark
	  for update the st_ctime field of the file.
	  (No exceptions mentioned)
	*/</span>
		cp-&gt;c_touch_chgtime = TRUE;
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-comment">/*
 * Flush the resource fork if it exists.  vp is the data fork and has
 * an iocount.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_flush_rsrc</span>(vnode_t vp, vfs_context_t ctx)
{
	cnode_t *cp = VTOC(vp);

	hfs_lock(cp, HFS_SHARED_LOCK, 0);

	vnode_t rvp = cp-&gt;c_rsrc_vp;

	<span class="enscript-keyword">if</span> (!rvp) {
		hfs_unlock(cp);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-type">int</span> vid = vnode_vid(rvp);

	hfs_unlock(cp);

	<span class="enscript-type">int</span> error = vnode_getwithvid(rvp, vid);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error == ENOENT ? 0 : error;

	hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, 0);
	hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);
	hfs_filedone(rvp, ctx, HFS_FILE_DONE_NO_SYNC);
	hfs_unlock(cp);
	hfs_unlock_truncate(cp, 0);

	error = ubc_msync(rvp, 0, ubc_getsize(rvp), NULL,
					  UBC_PUSHALL | UBC_SYNC);

	vnode_put(rvp);

	<span class="enscript-keyword">return</span> error;
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">HFS_COMPRESSION</span>

<span class="enscript-comment">/*
 * hfs_vnop_exchange:
 * 
 * Inputs: 
 * 		'from' vnode/cnode
 * 		'to' vnode/cnode
 * 		options flag bits
 * 		vfs_context
 * 
 * Discussion:
 * hfs_vnop_exchange is used to service the exchangedata(2) system call.
 * Per the requirements of that system call, this function &quot;swaps&quot; some
 * of the information that lives in one catalog record for some that
 * lives in another.  Note that not everything is swapped; in particular, 
 * the extent information stored in each cnode is kept local to that 
 * cnode.  This allows existing file descriptor references to continue
 * to operate on the same content, regardless of the location in the
 * namespace that the file may have moved to.  See inline comments
 * in the function for more information.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_exchange</span>(ap)
	<span class="enscript-type">struct</span> vnop_exchange_args <span class="enscript-comment">/* {
		struct vnode *a_fvp;
		struct vnode *a_tvp;
		int a_options;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *from_vp = ap-&gt;a_fvp;
	<span class="enscript-type">struct</span> vnode *to_vp = ap-&gt;a_tvp;
	<span class="enscript-type">struct</span> cnode *from_cp;
	<span class="enscript-type">struct</span> cnode *to_cp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> cat_desc tempdesc;
	<span class="enscript-type">struct</span> cat_attr tempattr;
	<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *from_nameptr;
	<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *to_nameptr;
	<span class="enscript-type">char</span> from_iname[32];
	<span class="enscript-type">char</span> to_iname[32];
	uint32_t to_flag_special;
	uint32_t from_flag_special;
	cnid_t  from_parid;
	cnid_t  to_parid;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error = 0, started_tr = 0, got_cookie = 0;
	cat_cookie_t cookie;
	time_t orig_from_ctime, orig_to_ctime;
	bool have_cnode_locks = false, have_from_trunc_lock = false, have_to_trunc_lock = false;

	<span class="enscript-comment">/*
	 * VFS does the following checks:
	 * 1. Validate that both are files.
	 * 2. Validate that both are on the same mount.
	 * 3. Validate that they're not the same vnode.
	 */</span>

	from_cp = VTOC(from_vp);
	to_cp = VTOC(to_vp);
	hfsmp = VTOHFS(from_vp);

	orig_from_ctime = from_cp-&gt;c_ctime;
	orig_to_ctime = to_cp-&gt;c_ctime;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* 
	 * Do not allow exchangedata/F_MOVEDATAEXTENTS on data-protected filesystems 
	 * because the EAs will not be swapped.  As a result, the persistent keys would not
	 * match and the files will be garbage.
	 */</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected (vnode_mount(from_vp))) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (!ISSET(ap-&gt;a_options, FSOPT_EXCHANGE_DATA_ONLY)) {
		<span class="enscript-keyword">if</span> ( hfs_file_is_compressed(from_cp, 0) ) {
			<span class="enscript-keyword">if</span> ( 0 != ( error = decmpfs_decompress_file(from_vp, VTOCMP(from_vp), -1, 0, 1) ) ) {
				<span class="enscript-keyword">return</span> error;
			}
		}

		<span class="enscript-keyword">if</span> ( hfs_file_is_compressed(to_cp, 0) ) {
			<span class="enscript-keyword">if</span> ( 0 != ( error = decmpfs_decompress_file(to_vp, VTOCMP(to_vp), -1, 0, 1) ) ) {
				<span class="enscript-keyword">return</span> error;
			}
		}
	}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">HFS_COMPRESSION</span>

	<span class="enscript-comment">// Resource forks cannot be exchanged.
</span>	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(from_vp) || VNODE_IS_RSRC(to_vp))
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-comment">/* 
	 * Normally, we want to notify the user handlers about the event,
	 * except if it's a handler driving the event.
	 */</span>
	<span class="enscript-keyword">if</span> ((ap-&gt;a_options &amp; FSOPT_EXCHANGE_DATA_ONLY) == 0) {
		check_for_tracked_file(from_vp, orig_from_ctime, NAMESPACE_HANDLER_WRITE_OP, NULL);
		check_for_tracked_file(to_vp, orig_to_ctime, NAMESPACE_HANDLER_WRITE_OP, NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * This is currently used by mtmd so we should tidy up the
		 * file now because the data won't be used again in the
		 * destination file.
		 */</span>
		hfs_lock_truncate(from_cp, HFS_EXCLUSIVE_LOCK, 0);
		hfs_lock_always(from_cp, HFS_EXCLUSIVE_LOCK);
		hfs_filedone(from_vp, ap-&gt;a_context, HFS_FILE_DONE_NO_SYNC);
		hfs_unlock(from_cp);
		hfs_unlock_truncate(from_cp, 0);

		<span class="enscript-comment">// Flush all the data from the source file
</span> 		error = ubc_msync(from_vp, 0, ubc_getsize(from_vp), NULL,
 						  UBC_PUSHALL | UBC_SYNC);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-comment">/*
		 * If this is a compressed file, we need to do the same for
		 * the resource fork.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(from_cp-&gt;c_bsdflags, UF_COMPRESSED)) {
			error = hfs_flush_rsrc(from_vp, ap-&gt;a_context);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * We're doing a data-swap so we need to take the truncate
		 * lock exclusively.  We need an exclusive lock because we
		 * will be completely truncating the source file and we must
		 * make sure nobody else sneaks in and trys to issue I/O
		 * whilst we don't have the cnode lock.
		 *
		 * After taking the truncate lock we do a quick check to
		 * verify there are no other references (including mmap
		 * references), but we must remember that this does not stop
		 * anybody coming in later and taking a reference.  We will
		 * have the truncate lock exclusively so that will prevent
		 * them from issuing any I/O.
		 */</span>

		<span class="enscript-keyword">if</span> (to_cp &lt; from_cp) {
			hfs_lock_truncate(to_cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			have_to_trunc_lock = true;
		}

		hfs_lock_truncate(from_cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		have_from_trunc_lock = true;

 		<span class="enscript-comment">/*
		 * Do an early check to verify the source is not in use by
		 * anyone.  We should be called from an FD opened as F_EVTONLY
		 * so that doesn't count as a reference.
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isinuse(from_vp, 0)) {
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-keyword">if</span> (to_cp &gt;= from_cp) {
			hfs_lock_truncate(to_cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			have_to_trunc_lock = true;
		}
	}

	<span class="enscript-keyword">if</span> ((error = hfs_lockpair(from_cp, to_cp, HFS_EXCLUSIVE_LOCK)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	have_cnode_locks = true;

	<span class="enscript-comment">// Don't allow modification of the journal or journal_info_block
</span>	<span class="enscript-keyword">if</span> (hfs_is_journal_file(hfsmp, from_cp) ||
	    hfs_is_journal_file(hfsmp, to_cp)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* 
	 * Ok, now that all of the pre-flighting is done, call the underlying
	 * function if needed.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(ap-&gt;a_options, FSOPT_EXCHANGE_DATA_ONLY)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> (ISSET(from_cp-&gt;c_bsdflags, UF_COMPRESSED)) {
			error = hfs_move_compressed(from_cp, to_cp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
#<span class="enscript-reference">endif</span>

		error = hfs_move_data(from_cp, to_cp, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	started_tr = 1;
	
	<span class="enscript-comment">/*
	 * Reserve some space in the Catalog file.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_EXCHANGE, &amp;cookie, vfs_context_proc(ap-&gt;a_context)))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	got_cookie = 1;

	<span class="enscript-comment">/* The backend code always tries to delete the virtual
	 * extent id for exchanging files so we need to lock
	 * the extents b-tree.
	 */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_EXTENTS | SFL_ATTRIBUTE, HFS_EXCLUSIVE_LOCK);

	<span class="enscript-comment">/* Account for the location of the catalog objects. */</span>
	<span class="enscript-keyword">if</span> (from_cp-&gt;c_flag &amp; C_HARDLINK) {
		MAKE_INODE_NAME(from_iname, <span class="enscript-keyword">sizeof</span>(from_iname),
				from_cp-&gt;c_attr.ca_linkref);
		from_nameptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)from_iname;
		from_parid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
		from_cp-&gt;c_hint = 0;
	} <span class="enscript-keyword">else</span> {
		from_nameptr = from_cp-&gt;c_desc.cd_nameptr;
		from_parid = from_cp-&gt;c_parentcnid;
	}
	<span class="enscript-keyword">if</span> (to_cp-&gt;c_flag &amp; C_HARDLINK) {
		MAKE_INODE_NAME(to_iname, <span class="enscript-keyword">sizeof</span>(to_iname),
				to_cp-&gt;c_attr.ca_linkref);
		to_nameptr = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)to_iname;
		to_parid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
		to_cp-&gt;c_hint = 0;
	} <span class="enscript-keyword">else</span> {
		to_nameptr = to_cp-&gt;c_desc.cd_nameptr;
		to_parid = to_cp-&gt;c_parentcnid;
	}

	<span class="enscript-comment">/*
	 * ExchangeFileIDs swaps the on-disk, or in-BTree extent information 
	 * attached to two different file IDs.  It also swaps the extent 
	 * information that may live in the extents-overflow B-Tree.
	 *
	 * We do this in a transaction as this may require a lot of B-Tree nodes
	 * to do completely, particularly if one of the files in question
	 * has a lot of extents. 
	 *
	 * For example, assume &quot;file1&quot; has fileID 50, and &quot;file2&quot; has fileID 52.
	 * For the on-disk records, which are assumed to be synced, we will
	 * first swap the resident inline-8 extents as part of the catalog records.
	 * Then we will swap any extents overflow records for each file.
	 * 
	 * When ExchangeFileIDs returns successfully, &quot;file1&quot; will have fileID 52, 
	 * and &quot;file2&quot; will have fileID 50.  However, note that this is only 
	 * approximately half of the work that exchangedata(2) will need to 
	 * accomplish.  In other words, we swap &quot;too much&quot; of the information 
	 * because if we only called ExchangeFileIDs, both the fileID and extent 
	 * information would be the invariants of this operation.  We don't 
	 * actually want that; we want to conclude with &quot;file1&quot; having 
	 * file ID 50, and &quot;file2&quot; having fileID 52.
	 * 
	 * The remainder of hfs_vnop_exchange will swap the file ID and other cnode
	 * data back to the proper ownership, while still allowing the cnode to remain
	 * pointing at the same set of extents that it did originally.
	 */</span>
	error = ExchangeFileIDs(hfsmp, from_nameptr, to_nameptr, from_parid,
	                        to_parid, from_cp-&gt;c_hint, to_cp-&gt;c_hint);
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-comment">/*
	 * Note that we don't need to exchange any extended attributes
	 * since the attributes are keyed by file ID.
	 */</span>

	<span class="enscript-keyword">if</span> (error != E_NONE) {
		error = MacToVFSError(error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* Purge the vnodes from the name cache */</span>
 	<span class="enscript-keyword">if</span> (from_vp)
		cache_purge(from_vp);
	<span class="enscript-keyword">if</span> (to_vp)
		cache_purge(to_vp);

	<span class="enscript-comment">/* Bump both source and destination write counts before any swaps. */</span>
	{
		hfs_incr_gencount (from_cp);
		hfs_incr_gencount (to_cp);
	}

	<span class="enscript-comment">/* Save a copy of &quot;from&quot; attributes before swapping. */</span>
	bcopy(&amp;from_cp-&gt;c_desc, &amp;tempdesc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));
	bcopy(&amp;from_cp-&gt;c_attr, &amp;tempattr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_attr));
	
	<span class="enscript-comment">/* Save whether or not each cnode is a hardlink or has EAs */</span>
	from_flag_special = from_cp-&gt;c_flag &amp; (C_HARDLINK | C_HASXATTRS);
	to_flag_special = to_cp-&gt;c_flag &amp; (C_HARDLINK | C_HASXATTRS);

	<span class="enscript-comment">/* Drop the special bits from each cnode */</span>
	from_cp-&gt;c_flag &amp;= ~(C_HARDLINK | C_HASXATTRS);
	to_cp-&gt;c_flag &amp;= ~(C_HARDLINK | C_HASXATTRS);

	<span class="enscript-comment">/*
	 * Now complete the in-memory portion of the copy.
	 *
	 * ExchangeFileIDs swaps the on-disk records involved.  We complete the
	 * operation by swapping the in-memory contents of the two files here.
	 * We swap the cnode descriptors, which contain name, BSD attributes,
	 * timestamps, etc, about the file.  
	 * 
	 * NOTE: We do *NOT* swap the fileforks of the two cnodes.  We have
	 * already swapped the on-disk extent information.  As long as we swap the 
	 * IDs, the in-line resident 8 extents that live in the filefork data
	 * structure will point to the right data for the new file ID if we leave 
	 * them alone.
	 *
	 * As a result, any file descriptor that points to a particular
	 * vnode (even though it should change names), will continue
	 * to point to the same content. 
	 */</span>

	<span class="enscript-comment">/* Copy the &quot;to&quot; -&gt; &quot;from&quot; cnode */</span>
	bcopy(&amp;to_cp-&gt;c_desc, &amp;from_cp-&gt;c_desc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));

	from_cp-&gt;c_hint = 0;
	<span class="enscript-comment">/*
	 * If 'to' was a hardlink, then we copied over its link ID/CNID/(namespace ID) 
	 * when we bcopy'd the descriptor above.  However, the cnode attributes
	 * are not bcopied.  As a result, make sure to swap the file IDs of each item.
	 *
	 * Further, other hardlink attributes must be moved along in this swap:
	 * the linkcount, the linkref, and the firstlink all need to move
	 * along with the file IDs.  See note below regarding the flags and
	 * what moves vs. what does not.
	 *
	 * For Reference:
	 * linkcount == total # of hardlinks.
	 * linkref == the indirect inode pointer.
	 * firstlink == the first hardlink in the chain (written to the raw inode).
	 * These three are tied to the fileID and must move along with the rest of the data.
	 */</span> 
	from_cp-&gt;c_fileid = to_cp-&gt;c_attr.ca_fileid;

	from_cp-&gt;c_itime = to_cp-&gt;c_itime;
	from_cp-&gt;c_btime = to_cp-&gt;c_btime;
	from_cp-&gt;c_atime = to_cp-&gt;c_atime;
	from_cp-&gt;c_ctime = to_cp-&gt;c_ctime;
	from_cp-&gt;c_gid = to_cp-&gt;c_gid;
	from_cp-&gt;c_uid = to_cp-&gt;c_uid;
	from_cp-&gt;c_bsdflags = to_cp-&gt;c_bsdflags;
	from_cp-&gt;c_mode = to_cp-&gt;c_mode;
	from_cp-&gt;c_linkcount = to_cp-&gt;c_linkcount;
	from_cp-&gt;c_attr.ca_linkref = to_cp-&gt;c_attr.ca_linkref;
	from_cp-&gt;c_attr.ca_firstlink = to_cp-&gt;c_attr.ca_firstlink;

	<span class="enscript-comment">/* 
	 * The cnode flags need to stay with the cnode and not get transferred
	 * over along with everything else because they describe the content; they are
	 * not attributes that reflect changes specific to the file ID.  In general, 
	 * fields that are tied to the file ID are the ones that will move.
	 * 
	 * This reflects the fact that the file may have borrowed blocks, dirty metadata, 
	 * or other extents, which may not yet have been written to the catalog.  If 
	 * they were, they would have been transferred above in the ExchangeFileIDs call above...
	 *
	 * The flags that are special are:
	 * C_HARDLINK, C_HASXATTRS
	 * 
	 * These flags move with the item and file ID in the namespace since their
	 * state is tied to that of the file ID.
	 * 
	 * So to transfer the flags, we have to take the following steps
	 * 1) Store in a localvar whether or not the special bits are set.
	 * 2) Drop the special bits from the current flags
	 * 3) swap the special flag bits to their destination
	 */</span>	 
	from_cp-&gt;c_flag |= to_flag_special | C_MODIFIED;
	from_cp-&gt;c_attr.ca_recflags = to_cp-&gt;c_attr.ca_recflags;
	bcopy(to_cp-&gt;c_finderinfo, from_cp-&gt;c_finderinfo, 32);


	<span class="enscript-comment">/* Copy the &quot;from&quot; -&gt; &quot;to&quot; cnode */</span>
	bcopy(&amp;tempdesc, &amp;to_cp-&gt;c_desc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));
	to_cp-&gt;c_hint = 0;
	<span class="enscript-comment">/* 
	 * Pull the file ID from the tempattr we copied above. We can't assume 
	 * it is the same as the CNID.
	 */</span>
	to_cp-&gt;c_fileid = tempattr.ca_fileid;
	to_cp-&gt;c_itime = tempattr.ca_itime;
	to_cp-&gt;c_btime = tempattr.ca_btime;
	to_cp-&gt;c_atime = tempattr.ca_atime;
	to_cp-&gt;c_ctime = tempattr.ca_ctime;
	to_cp-&gt;c_gid = tempattr.ca_gid;
	to_cp-&gt;c_uid = tempattr.ca_uid;
	to_cp-&gt;c_bsdflags = tempattr.ca_flags;
	to_cp-&gt;c_mode = tempattr.ca_mode;
	to_cp-&gt;c_linkcount = tempattr.ca_linkcount;
	to_cp-&gt;c_attr.ca_linkref = tempattr.ca_linkref;
	to_cp-&gt;c_attr.ca_firstlink = tempattr.ca_firstlink;

	<span class="enscript-comment">/* 
	 * Only OR in the &quot;from&quot; flags into our cnode flags below. 
	 * Leave the rest of the flags alone.
	 */</span>
	to_cp-&gt;c_flag |= from_flag_special | C_MODIFIED;

	to_cp-&gt;c_attr.ca_recflags = tempattr.ca_recflags;
	bcopy(tempattr.ca_finderinfo, to_cp-&gt;c_finderinfo, 32);


	<span class="enscript-comment">/* Rehash the cnodes using their new file IDs */</span>
	hfs_chash_rehash(hfsmp, from_cp, to_cp);

	<span class="enscript-comment">/*
	 * When a file moves out of &quot;Cleanup At Startup&quot;
	 * we can drop its NODUMP status.
	 */</span>
	<span class="enscript-keyword">if</span> ((from_cp-&gt;c_bsdflags &amp; UF_NODUMP) &amp;&amp;
	    (from_cp-&gt;c_parentcnid != to_cp-&gt;c_parentcnid)) {
		from_cp-&gt;c_bsdflags &amp;= ~UF_NODUMP;
		from_cp-&gt;c_touch_chgtime = TRUE;
	}
	<span class="enscript-keyword">if</span> ((to_cp-&gt;c_bsdflags &amp; UF_NODUMP) &amp;&amp;
	    (to_cp-&gt;c_parentcnid != from_cp-&gt;c_parentcnid)) {
		to_cp-&gt;c_bsdflags &amp;= ~UF_NODUMP;
		to_cp-&gt;c_touch_chgtime = TRUE;
	}

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (got_cookie) {
		cat_postflight(hfsmp, &amp;cookie, vfs_context_proc(ap-&gt;a_context));
	}
	<span class="enscript-keyword">if</span> (started_tr) {
	    hfs_end_transaction(hfsmp);
	}

	<span class="enscript-keyword">if</span> (have_cnode_locks)
		hfs_unlockpair(from_cp, to_cp);

	<span class="enscript-keyword">if</span> (have_from_trunc_lock)
		hfs_unlock_truncate(from_cp, 0);

	<span class="enscript-keyword">if</span> (have_to_trunc_lock)
		hfs_unlock_truncate(to_cp, 0);

 	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-comment">/*
 * This function is used specifically for the case when a namespace
 * handler is trying to steal data before it's deleted.  Note that we
 * don't bother deleting the xattr from the source because it will get
 * deleted a short time later anyway.
 *
 * cnodes must be locked
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_compressed</span>(cnode_t *from_cp, cnode_t *to_cp)
{
	<span class="enscript-type">int</span> 	ret;
	<span class="enscript-type">void</span>   *data 	= NULL;

	CLR(from_cp-&gt;c_bsdflags, UF_COMPRESSED);
	SET(from_cp-&gt;c_flag, C_MODIFIED);

	ret = hfs_move_data(from_cp, to_cp, HFS_MOVE_DATA_INCLUDE_RSRC);
	<span class="enscript-keyword">if</span> (ret)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/*
	 * Transfer the xattr that decmpfs uses.  Ideally, this code
	 * should be with the other decmpfs code but it's file system
	 * agnostic and this path is currently, and likely to remain, HFS+
	 * specific.  It's easier and more performant if we implement it
	 * here.
	 */</span>

	size_t size = MAX_DECMPFS_XATTR_SIZE;
	MALLOC(data, <span class="enscript-type">void</span> *, size, M_TEMP, M_WAITOK);

	ret = hfs_xattr_read(from_cp-&gt;c_vp, DECMPFS_XATTR_NAME, data, &amp;size);
	<span class="enscript-keyword">if</span> (ret)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	ret = hfs_xattr_write(to_cp-&gt;c_vp, DECMPFS_XATTR_NAME, data, size);
	<span class="enscript-keyword">if</span> (ret)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	SET(to_cp-&gt;c_bsdflags, UF_COMPRESSED);
	SET(to_cp-&gt;c_flag, C_MODIFIED);

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (data)
		FREE(data, M_TEMP);

	<span class="enscript-keyword">return</span> ret;
}
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">HFS_COMPRESSION</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_mmap</span>(<span class="enscript-type">struct</span> vnop_mmap_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	cnode_t *cp = VTOC(vp);
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-comment">/* allow pageins of the resource fork */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> compressed = hfs_file_is_compressed(cp, 1); <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
		time_t orig_ctime = cp-&gt;c_ctime;
		
		<span class="enscript-keyword">if</span> (!compressed &amp;&amp; (cp-&gt;c_bsdflags &amp; UF_COMPRESSED)) {
			error = check_for_dataless_file(vp, NAMESPACE_HANDLER_READ_OP);
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">return</span> error;
			}
		}

		<span class="enscript-keyword">if</span> (ap-&gt;a_fflags &amp; PROT_WRITE) {
			check_for_tracked_file(vp, orig_ctime, NAMESPACE_HANDLER_WRITE_OP, NULL);
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// NOTE: we return ENOTSUP because we want the cluster layer
</span>	<span class="enscript-comment">//       to actually do all the real work.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_vnop_mnomap</span>(<span class="enscript-type">struct</span> vnop_mnomap_args *ap)
{
	vnode_t vp = ap-&gt;a_vp;

	<span class="enscript-comment">/*
	 * Whilst the file was mapped, there may not have been any
	 * page-outs so we need to increment the generation counter now.
	 * Unfortunately this may lead to a change in the generation
	 * counter when no actual change has been made, but there is
	 * little we can do about that with our current architecture.
	 */</span>
	<span class="enscript-keyword">if</span> (ubc_is_mapped_writable(vp)) {
		cnode_t *cp = VTOC(vp);
		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		hfs_incr_gencount(cp);

		<span class="enscript-comment">/*
		 * We don't want to set the modification time here since a
		 * change to that is not acceptable if no changes were made.
		 * Instead we set a flag so that if we get any page-outs we
		 * know to update the modification time.  It's possible that
		 * they weren't actually because of changes made whilst the
		 * file was mapped but that's not easy to fix now.
		 */</span>
		SET(cp-&gt;c_flag, C_MIGHT_BE_DIRTY_FROM_MAPPING);

		hfs_unlock(cp);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Mark the resource fork as needing a ubc_setsize when we drop the
 * cnode lock later.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_rsrc_setsize</span>(cnode_t *cp)
{
	<span class="enscript-comment">/*
	 * We need to take an iocount if we don't have one.  vnode_get
	 * will return ENOENT if the vnode is terminating which is what we
	 * want as it's not safe to call ubc_setsize in that case.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp &amp;&amp; !vnode_get(cp-&gt;c_rsrc_vp)) {
		<span class="enscript-comment">// Shouldn't happen, but better safe...
</span>		<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_NEED_RVNODE_PUT))
			vnode_put(cp-&gt;c_rsrc_vp);
		SET(cp-&gt;c_flag, C_NEED_RVNODE_PUT | C_NEED_RSRC_SETSIZE);
	}
}

<span class="enscript-comment">/*
 * hfs_move_data
 *
 * This is a non-symmetric variant of exchangedata.  In this function,
 * the contents of the data fork (and optionally the resource fork)
 * are moved from from_cp to to_cp.
 * 
 * The cnodes must be locked. 
 *
 * The cnode pointed to by 'to_cp' *must* be empty prior to invoking
 * this function.  We impose this restriction because we may not be
 * able to fully delete the entire file's contents in a single
 * transaction, particularly if it has a lot of extents.  In the
 * normal file deletion codepath, the file is screened for two
 * conditions: 1) bigger than 400MB, and 2) more than 8 extents.  If
 * so, the file is relocated to the hidden directory and the deletion
 * is broken up into multiple truncates.  We can't do that here
 * because both files need to exist in the namespace. The main reason
 * this is imposed is that we may have to touch a whole lot of bitmap
 * blocks if there are many extents.
 * 
 * Any data written to 'from_cp' after this call completes is not
 * guaranteed to be moved.
 * 
 * Arguments:
 * cnode_t *from_cp : source file
 * cnode_t *to_cp   : destination file; must be empty
 * 
 * Returns:
 *  
 *  EBUSY - File has been deleted or is in use
 *	EFBIG - Destination file was not empty
 *  EIO   - An I/O error
 *	0	  - success
 *  other - Other errors that can be returned from called functions
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_data</span>(cnode_t *from_cp, cnode_t *to_cp, 
				  hfs_move_data_options_t options)
{	
	hfsmount_t *hfsmp 			= VTOHFS(from_cp-&gt;c_vp);
	<span class="enscript-type">int</span> error 					= 0;
	<span class="enscript-type">int</span> lockflags				= 0;
	bool return_EIO_on_error 	= false;
	<span class="enscript-type">const</span> bool include_rsrc		= ISSET(options, HFS_MOVE_DATA_INCLUDE_RSRC);

	<span class="enscript-comment">/* Verify that neither source/dest file is open-unlinked */</span>
	<span class="enscript-keyword">if</span> (ISSET(from_cp-&gt;c_flag, C_DELETED | C_NOEXISTS)
		|| ISSET(to_cp-&gt;c_flag, C_DELETED | C_NOEXISTS)) {
		<span class="enscript-keyword">return</span> EBUSY;
	}

	<span class="enscript-comment">/* 
	 * Verify the source file is not in use by anyone besides us.
	 *
	 * This function is typically invoked by a namespace handler 
	 * process responding to a temporarily stalled system call.  
	 * The FD that it is working off of is opened O_EVTONLY, so
	 * it really has no active usecounts (the kusecount from O_EVTONLY
	 * is subtracted from the total usecounts).
	 * 
	 * As a result, we shouldn't have any active usecounts against
	 * this vnode when we go to check it below.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isinuse(from_cp-&gt;c_vp, 0))
		<span class="enscript-keyword">return</span> EBUSY;

	<span class="enscript-keyword">if</span> (include_rsrc &amp;&amp; from_cp-&gt;c_rsrc_vp) {
		<span class="enscript-keyword">if</span> (vnode_isinuse(from_cp-&gt;c_rsrc_vp, 0))
			<span class="enscript-keyword">return</span> EBUSY;

		<span class="enscript-comment">/* 
		 * In the code below, if the destination file doesn't have a
		 * c_rsrcfork then we don't create it which means we we cannot
		 * transfer the ff_invalidranges and cf_vblocks fields.  These
		 * shouldn't be set because we flush the resource fork before
		 * calling this function but there is a tiny window when we
		 * did not have any locks...
		 */</span>
		<span class="enscript-keyword">if</span> (!to_cp-&gt;c_rsrcfork
			&amp;&amp; (!TAILQ_EMPTY(&amp;from_cp-&gt;c_rsrcfork-&gt;ff_invalidranges)
				|| from_cp-&gt;c_rsrcfork-&gt;ff_unallocblocks)) {
			<span class="enscript-comment">/*
			 * The file isn't really busy now but something did slip
			 * in and tinker with the file while we didn't have any
			 * locks, so this is the most meaningful return code for
			 * the caller.
			 */</span>
			<span class="enscript-keyword">return</span> EBUSY;
		}
	}

	<span class="enscript-comment">// Check the destination file is empty
</span>	<span class="enscript-keyword">if</span> (to_cp-&gt;c_datafork-&gt;ff_blocks 
		|| to_cp-&gt;c_datafork-&gt;ff_size
		|| (include_rsrc
			&amp;&amp; (to_cp-&gt;c_blocks
				|| (to_cp-&gt;c_rsrcfork &amp;&amp; to_cp-&gt;c_rsrcfork-&gt;ff_size)))) {
		<span class="enscript-keyword">return</span> EFBIG;
	}

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction (hfsmp)))
		<span class="enscript-keyword">return</span> error;

	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_EXTENTS | SFL_ATTRIBUTE, 
									HFS_EXCLUSIVE_LOCK);

	<span class="enscript-comment">// filefork_t is 128 bytes which should be OK
</span>	filefork_t rfork_buf, *from_rfork = NULL;

	<span class="enscript-keyword">if</span> (include_rsrc) {
		from_rfork = from_cp-&gt;c_rsrcfork;

		<span class="enscript-comment">/*
		 * Creating resource fork vnodes is expensive, so just get get
		 * the fork data if we need it.
		 */</span>
		<span class="enscript-keyword">if</span> (!from_rfork &amp;&amp; hfs_has_rsrc(from_cp)) {
			from_rfork = &amp;rfork_buf;

			from_rfork-&gt;ff_cp = from_cp;
			TAILQ_INIT(&amp;from_rfork-&gt;ff_invalidranges);

			error = cat_idlookup(hfsmp, from_cp-&gt;c_fileid, 0, 1, NULL, NULL,
								 &amp;from_rfork-&gt;ff_data);

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	<span class="enscript-comment">/*
	 * From here on, any failures mean that we might be leaving things
	 * in a weird or inconsistent state.  Ideally, we should back out
	 * all the changes, but to do that properly we need to fix
	 * MoveData.  We'll save fixing that for another time.  For now,
	 * just return EIO in all cases to the caller so that they know.
	 */</span>
	return_EIO_on_error = true;

	bool data_overflow_extents = overflow_extents(from_cp-&gt;c_datafork);

	<span class="enscript-comment">// Move the data fork
</span>	<span class="enscript-keyword">if</span> ((error = hfs_move_fork (from_cp-&gt;c_datafork, from_cp,
								to_cp-&gt;c_datafork, to_cp))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	SET(from_cp-&gt;c_flag, C_NEED_DATA_SETSIZE);
	SET(to_cp-&gt;c_flag, C_NEED_DATA_SETSIZE);

	<span class="enscript-comment">// We move the resource fork later
</span>
	<span class="enscript-comment">/* 
	 * Note that because all we're doing is moving the extents around,
	 * we can probably do this in a single transaction: Each extent
	 * record (group of 8) is 64 bytes.  A extent overflow B-Tree node
	 * is typically 4k.  This means each node can hold roughly ~60
	 * extent records == (480 extents).
	 *
	 * If a file was massively fragmented and had 20k extents, this
	 * means we'd roughly touch 20k/480 == 41 to 42 nodes, plus the
	 * index nodes, for half of the operation.  (inserting or
	 * deleting). So if we're manipulating 80-100 nodes, this is
	 * basically 320k of data to write to the journal in a bad case.
	 */</span>
	<span class="enscript-keyword">if</span> (data_overflow_extents) {
		<span class="enscript-keyword">if</span> ((error = MoveData(hfsmp, from_cp-&gt;c_cnid, to_cp-&gt;c_cnid, 0)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (from_rfork &amp;&amp; overflow_extents(from_rfork)) {
		<span class="enscript-keyword">if</span> ((error = MoveData(hfsmp, from_cp-&gt;c_cnid, to_cp-&gt;c_cnid, 1)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">// Touch times
</span>	from_cp-&gt;c_touch_acctime = TRUE;
	from_cp-&gt;c_touch_chgtime = TRUE;
	from_cp-&gt;c_touch_modtime = TRUE;
	hfs_touchtimes(hfsmp, from_cp);

	to_cp-&gt;c_touch_acctime = TRUE;
	to_cp-&gt;c_touch_chgtime = TRUE;
	to_cp-&gt;c_touch_modtime = TRUE;
	hfs_touchtimes(hfsmp, to_cp);

	<span class="enscript-type">struct</span> cat_fork dfork_buf;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dfork, *rfork;

	dfork = hfs_prepare_fork_for_update(to_cp-&gt;c_datafork, NULL,
										&amp;dfork_buf, hfsmp-&gt;blockSize);
	rfork = hfs_prepare_fork_for_update(from_rfork, NULL,
										&amp;rfork_buf.ff_data, hfsmp-&gt;blockSize);

	<span class="enscript-comment">// Update the catalog nodes, to_cp first
</span>	<span class="enscript-keyword">if</span> ((error = cat_update(hfsmp, &amp;to_cp-&gt;c_desc, &amp;to_cp-&gt;c_attr, 
							dfork, rfork))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	CLR(to_cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD);

	<span class="enscript-comment">// Update in-memory resource fork data here
</span>	<span class="enscript-keyword">if</span> (from_rfork) {
		<span class="enscript-comment">// Update c_blocks
</span>		uint32_t moving = from_rfork-&gt;ff_blocks + from_rfork-&gt;ff_unallocblocks;

		from_cp-&gt;c_blocks -= moving;
		to_cp-&gt;c_blocks   += moving;

		<span class="enscript-comment">// Update to_cp's resource data if it has it
</span>		filefork_t *to_rfork = to_cp-&gt;c_rsrcfork;
		<span class="enscript-keyword">if</span> (to_rfork) {
			to_rfork-&gt;ff_invalidranges = from_rfork-&gt;ff_invalidranges;
			to_rfork-&gt;ff_data 		   = from_rfork-&gt;ff_data;

			<span class="enscript-comment">// Deal with ubc_setsize
</span>			hfs_rsrc_setsize(to_cp);
		}

		<span class="enscript-comment">// Wipe out the resource fork in from_cp
</span>		rl_init(&amp;from_rfork-&gt;ff_invalidranges);
		bzero(&amp;from_rfork-&gt;ff_data, <span class="enscript-keyword">sizeof</span>(from_rfork-&gt;ff_data));

		<span class="enscript-comment">// Deal with ubc_setsize
</span>		hfs_rsrc_setsize(from_cp);
	}

	<span class="enscript-comment">// Currently unnecessary, but might be useful in future...
</span>	dfork = hfs_prepare_fork_for_update(from_cp-&gt;c_datafork, NULL, &amp;dfork_buf,
										hfsmp-&gt;blockSize);
	rfork = hfs_prepare_fork_for_update(from_rfork, NULL, &amp;rfork_buf.ff_data,
										hfsmp-&gt;blockSize);

	<span class="enscript-comment">// Update from_cp
</span>	<span class="enscript-keyword">if</span> ((error = cat_update(hfsmp, &amp;from_cp-&gt;c_desc, &amp;from_cp-&gt;c_attr, 
							dfork, rfork))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	CLR(from_cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD);

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		hfs_end_transaction(hfsmp);
	}

	<span class="enscript-keyword">if</span> (error &amp;&amp; error != EIO &amp;&amp; return_EIO_on_error) {
		printf(<span class="enscript-string">&quot;hfs_move_data: encountered error %d\n&quot;</span>, error);
		error = EIO;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* 
 * Move all of the catalog and runtime data in srcfork to dstfork.
 * 
 * This allows us to maintain the invalid ranges across the move data
 * operation so we don't need to force all of the pending IO right
 * now. In addition, we move all non overflow-extent extents into the
 * destination here.
 *
 * The destination fork must be empty and should have been checked
 * prior to calling this.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_move_fork</span>(filefork_t *srcfork, cnode_t *src_cp,
						 filefork_t *dstfork, cnode_t *dst_cp) 
{
	<span class="enscript-comment">// Move the invalid ranges
</span>	TAILQ_SWAP(&amp;dstfork-&gt;ff_invalidranges, &amp;srcfork-&gt;ff_invalidranges,
			   rl_entry, rl_link);
	rl_remove_all(&amp;srcfork-&gt;ff_invalidranges);

	<span class="enscript-comment">// Move the fork data (copy whole structure)
</span>	dstfork-&gt;ff_data = srcfork-&gt;ff_data;
	bzero(&amp;srcfork-&gt;ff_data, <span class="enscript-keyword">sizeof</span>(srcfork-&gt;ff_data));

	<span class="enscript-comment">// Update c_blocks
</span>	src_cp-&gt;c_blocks -= dstfork-&gt;ff_blocks + dstfork-&gt;ff_unallocblocks;
	dst_cp-&gt;c_blocks += dstfork-&gt;ff_blocks + dstfork-&gt;ff_unallocblocks;

	<span class="enscript-keyword">return</span> 0;
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/panic_hooks.h&gt;</span>

<span class="enscript-type">struct</span> hfs_fsync_panic_hook {
	panic_hook_t hook;
	<span class="enscript-type">struct</span> cnode *cp;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_fsync_panic_hook</span>(panic_hook_t *hook_)
{
	<span class="enscript-type">struct</span> hfs_fsync_panic_hook *hook = (<span class="enscript-type">struct</span> hfs_fsync_panic_hook *)hook_;
	<span class="enscript-type">extern</span> <span class="enscript-type">int</span> kdb_log(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...);

	<span class="enscript-comment">// Get the physical region just before cp
</span>	panic_phys_range_t range;
	uint64_t phys;

	<span class="enscript-keyword">if</span> (panic_phys_range_before(hook-&gt;cp, &amp;phys, &amp;range)) {
		kdb_log(<span class="enscript-string">&quot;cp = %p, phys = %p, prev (%p: %p-%p)\n&quot;</span>, 
				hook-&gt;cp, phys, range.type, range.phys_start,
				range.phys_start + range.len);
	} <span class="enscript-keyword">else</span>
		kdb_log(<span class="enscript-string">&quot;cp = %p, phys = %p, prev (!)\n&quot;</span>, hook-&gt;cp, phys);

	panic_dump_mem((<span class="enscript-type">void</span> *)(((vm_offset_t)hook-&gt;cp - 4096) &amp; ~4095), 12288);

	kdb_log(<span class="enscript-string">&quot;\n&quot;</span>);
}


<span class="enscript-comment">/*
 *  cnode must be locked
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_fsync</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> waitfor, hfs_fsync_mode_t fsyncmode, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> filefork *fp = NULL;
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> waitdata;		<span class="enscript-comment">/* attributes necessary for data retrieval */</span>
	<span class="enscript-type">int</span> wait;		<span class="enscript-comment">/* all other attributes (e.g. atime, etc.) */</span>
	<span class="enscript-type">int</span> lockflag;
	<span class="enscript-type">int</span> took_trunc_lock = 0;
	<span class="enscript-type">int</span> locked_buffers = 0;
	<span class="enscript-type">int</span> fsync_default = 1;

	<span class="enscript-comment">/*
	 * Applications which only care about data integrity rather than full
	 * file integrity may opt out of (delay) expensive metadata update
	 * operations as a performance optimization.
	 */</span>
	wait = (waitfor == MNT_WAIT);
	waitdata = (waitfor == MNT_DWAIT) | wait;

	<span class="enscript-keyword">if</span> (always_do_fullfsync)
		fsyncmode = HFS_FSYNC_FULL;
	<span class="enscript-keyword">if</span> (fsyncmode != HFS_FSYNC)
		fsync_default = 0;
	
	<span class="enscript-comment">/* HFS directories don't have any data blocks. */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">metasync</span>;
	fp = VTOF(vp);

	<span class="enscript-comment">/*
	 * For system files flush the B-tree header and
	 * for regular files write out any clusters
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_issystem(vp)) {
	    <span class="enscript-keyword">if</span> (VTOF(vp)-&gt;fcbBTCBPtr != NULL) {
			<span class="enscript-comment">// XXXdbg
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
				BTFlushPath(VTOF(vp));
			}
	    }
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp)) {
		hfs_unlock(cp);
		hfs_lock_truncate(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
		took_trunc_lock = 1;

		<span class="enscript-type">struct</span> hfs_fsync_panic_hook hook;
		hook.cp = cp;
		panic_hook(&amp;hook.hook, hfs_fsync_panic_hook);

		<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks != 0) {
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);

			hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		}

		panic_unhook(&amp;hook.hook);

		<span class="enscript-comment">/* Don't hold cnode lock when calling into cluster layer. */</span>
		(<span class="enscript-type">void</span>) cluster_push(vp, waitdata ? IO_SYNC : 0);

		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
	}
	<span class="enscript-comment">/*
	 * When MNT_WAIT is requested and the zero fill timeout
	 * has expired then we must explicitly zero out any areas
	 * that are currently marked invalid (holes).
	 *
	 * Files with NODUMP can bypass zero filling here.
	 */</span>
	<span class="enscript-keyword">if</span> (fp &amp;&amp; (((cp-&gt;c_flag &amp; C_ALWAYS_ZEROFILL) &amp;&amp; !TAILQ_EMPTY(&amp;fp-&gt;ff_invalidranges)) ||
	    ((wait || (cp-&gt;c_flag &amp; C_ZFWANTSYNC)) &amp;&amp;
		((cp-&gt;c_bsdflags &amp; UF_NODUMP) == 0) &amp;&amp;
		UBCINFOEXISTS(vp) &amp;&amp; (vnode_issystem(vp) ==0) &amp;&amp;
		cp-&gt;c_zftimeout != 0))) {

		microuptime(&amp;tv);
		<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_ALWAYS_ZEROFILL) == 0 &amp;&amp; fsync_default &amp;&amp; tv.tv_sec &lt; (<span class="enscript-type">long</span>)cp-&gt;c_zftimeout) {
			<span class="enscript-comment">/* Remember that a force sync was requested. */</span>
			cp-&gt;c_flag |= C_ZFWANTSYNC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">datasync</span>;
		}
		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;fp-&gt;ff_invalidranges)) {
			<span class="enscript-keyword">if</span> (!took_trunc_lock || (cp-&gt;c_truncatelockowner == HFS_SHARED_OWNER)) {
				hfs_unlock(cp);
				<span class="enscript-keyword">if</span> (took_trunc_lock) {
					hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
				}
				hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
				hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
				took_trunc_lock = 1;
			}
			hfs_flush_invalid_ranges(vp);
			hfs_unlock(cp);
			(<span class="enscript-type">void</span>) cluster_push(vp, waitdata ? IO_SYNC : 0);
			hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		}
	}
<span class="enscript-reference">datasync</span>:
	<span class="enscript-keyword">if</span> (took_trunc_lock) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
		took_trunc_lock = 0;
	}
	<span class="enscript-comment">/*
	 * if we have a journal and if journal_active() returns != 0 then the
	 * we shouldn't do anything to a locked block (because it is part 
	 * of a transaction).  otherwise we'll just go through the normal 
	 * code path and flush the buffer.  note journal_active() can return
	 * -1 if the journal is invalid -- however we still need to skip any 
	 * locked blocks as they get cleaned up when we finish the transaction
	 * or close the journal.
	 */</span>
	<span class="enscript-comment">// if (hfsmp-&gt;jnl &amp;&amp; journal_active(hfsmp-&gt;jnl) &gt;= 0)
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
	        lockflag = BUF_SKIP_LOCKED;
	<span class="enscript-keyword">else</span>
	        lockflag = 0;

	<span class="enscript-comment">/*
	 * Flush all dirty buffers associated with a vnode.
	 * Record how many of them were dirty AND locked (if necessary).
	 */</span>
	locked_buffers = buf_flushdirtyblks_skipinfo(vp, waitdata, lockflag, <span class="enscript-string">&quot;hfs_fsync&quot;</span>);
	<span class="enscript-keyword">if</span> ((lockflag &amp; BUF_SKIP_LOCKED) &amp;&amp; (locked_buffers) &amp;&amp; (vnode_vtype(vp) == VLNK)) {
		<span class="enscript-comment">/* 
		 * If there are dirty symlink buffers, then we may need to take action
		 * to prevent issues later on if we are journaled. If we're fsyncing a 
		 * symlink vnode then we are in one of three cases:
		 * 
		 * 1) automatic sync has fired.  In this case, we don't want the behavior to change.
		 * 
		 * 2) Someone has opened the FD for the symlink (not what it points to)
		 * and has issued an fsync against it.  This should be rare, and we don't
		 * want the behavior to change.
		 * 
		 * 3) We are being called by a vclean which is trying to reclaim this
		 * symlink vnode.  If this is the case, then allowing this fsync to 
		 * proceed WITHOUT flushing the journal could result in the vclean 
		 * invalidating the buffer's blocks before the journal transaction is
		 * written to disk.  To prevent this, we force a journal flush 
		 * if the vnode is in the middle of a recycle (VL_TERMINATE or VL_DEAD is set).
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isrecycled(vp)) {
			fsync_default = 0;
		}
	}

<span class="enscript-reference">metasync</span>:
	<span class="enscript-keyword">if</span> (vnode_isreg(vp) &amp;&amp; vnode_issystem(vp)) {
		<span class="enscript-keyword">if</span> (VTOF(vp)-&gt;fcbBTCBPtr != NULL) {
			microuptime(&amp;tv);
			BTSetLastSync(VTOF(vp), tv.tv_sec);
		}
		cp-&gt;c_touch_acctime = FALSE;
		cp-&gt;c_touch_chgtime = FALSE;
		cp-&gt;c_touch_modtime = FALSE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( !(vp-&gt;v_flag &amp; VSWAP) ) <span class="enscript-comment">/* User file */</span> {
		retval = hfs_update(vp, HFS_UPDATE_FORCE);

		<span class="enscript-comment">/*
		 * When MNT_WAIT is requested push out the catalog record for
		 * this file.  If they asked for a full fsync, we can skip this
		 * because the journal_flush or hfs_metasync_all will push out
		 * all of the metadata changes.
		 */</span>
		<span class="enscript-keyword">if</span> ((retval == 0) &amp;&amp; wait &amp;&amp; fsync_default &amp;&amp; cp-&gt;c_hint &amp;&amp;
   		    !ISSET(cp-&gt;c_flag, C_DELETED | C_NOEXISTS)) {
   			hfs_metasync(VTOHFS(vp), (daddr64_t)cp-&gt;c_hint, p);
		}

		<span class="enscript-comment">/*
		 * If this was a full fsync, make sure all metadata
		 * changes get to stable storage.
		 */</span>
		<span class="enscript-keyword">if</span> (!fsync_default) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				<span class="enscript-keyword">if</span> (fsyncmode == HFS_FSYNC_FULL)
					hfs_flush(hfsmp, HFS_FLUSH_FULL);
				<span class="enscript-keyword">else</span>
					hfs_flush(hfsmp,
					    HFS_FLUSH_JOURNAL_BARRIER);
			} <span class="enscript-keyword">else</span> {
				retval = hfs_metasync_all(hfsmp);
				<span class="enscript-comment">/* XXX need to pass context! */</span>
				hfs_flush(hfsmp, HFS_FLUSH_CACHE);
			}
		}
	}

	<span class="enscript-keyword">if</span> (!hfs_is_dirty(cp) &amp;&amp; !ISSET(cp-&gt;c_flag, C_DELETED))
		vnode_cleardirty(vp);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-comment">/* Sync an hfs catalog b-tree node */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_metasync</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, daddr64_t node, __unused <span class="enscript-type">struct</span> proc *p)
{
	vnode_t	vp;
	buf_t	bp;
	<span class="enscript-type">int</span> lockflags;

	vp = HFSTOVCB(hfsmp)-&gt;catalogRefNum;

	<span class="enscript-comment">// XXXdbg - don't need to do this on a journaled volume
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		<span class="enscript-keyword">return</span> 0;
	}

	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
	<span class="enscript-comment">/*
	 * Look for a matching node that has been delayed
	 * but is not part of a set (B_LOCKED).
	 *
	 * BLK_ONLYVALID causes buf_getblk to return a
	 * buf_t for the daddr64_t specified only if it's
	 * currently resident in the cache... the size
	 * parameter to buf_getblk is ignored when this flag
	 * is set
	 */</span>
	bp = buf_getblk(vp, node, 0, 0, 0, BLK_META | BLK_ONLYVALID);

	<span class="enscript-keyword">if</span> (bp) {
	        <span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; (B_LOCKED | B_DELWRI)) == B_DELWRI)
		        (<span class="enscript-type">void</span>) VNOP_BWRITE(bp);
		<span class="enscript-keyword">else</span>
		        buf_brelse(bp);
	}

	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Sync all hfs B-trees.  Use this instead of journal_flush for a volume
 * without a journal.  Note that the volume bitmap does not get written;
 * we rely on fsck_hfs to fix that up (which it can do without any loss
 * of data).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_metasync_all</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	<span class="enscript-type">int</span> lockflags;

	<span class="enscript-comment">/* Lock all of the B-trees so we get a mutually consistent state */</span>
	lockflags = hfs_systemfile_lock(hfsmp,
		SFL_CATALOG|SFL_EXTENTS|SFL_ATTRIBUTE, HFS_EXCLUSIVE_LOCK);

	<span class="enscript-comment">/* Sync each of the B-trees */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_vp)
		hfs_btsync(hfsmp-&gt;hfs_catalog_vp, 0);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_vp)
		hfs_btsync(hfsmp-&gt;hfs_extents_vp, 0);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp)
		hfs_btsync(hfsmp-&gt;hfs_attribute_vp, 0);
	
	<span class="enscript-comment">/* Wait for all of the writes to complete */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_vp)
		vnode_waitforwrites(hfsmp-&gt;hfs_catalog_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_metasync_all&quot;</span>);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_vp)
		vnode_waitforwrites(hfsmp-&gt;hfs_extents_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_metasync_all&quot;</span>);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp)
		vnode_waitforwrites(hfsmp-&gt;hfs_attribute_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_metasync_all&quot;</span>);

	hfs_systemfile_unlock(hfsmp, lockflags);
	
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*ARGSUSED 1*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_btsync_callback</span>(<span class="enscript-type">struct</span> buf *bp, __unused <span class="enscript-type">void</span> *dummy)
{
	buf_clearflags(bp, B_LOCKED);
	(<span class="enscript-type">void</span>) buf_bawrite(bp);

	<span class="enscript-keyword">return</span>(BUF_CLAIMED);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_btsync</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> sync_transaction)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span>    flags = 0;

	<span class="enscript-keyword">if</span> (sync_transaction)
	        flags |= BUF_SKIP_NONLOCKED;
	<span class="enscript-comment">/*
	 * Flush all dirty buffers associated with b-tree.
	 */</span>
	buf_iterate(vp, hfs_btsync_callback, flags, 0);

	microuptime(&amp;tv);
	<span class="enscript-keyword">if</span> (vnode_issystem(vp) &amp;&amp; (VTOF(vp)-&gt;fcbBTCBPtr != NULL))
		(<span class="enscript-type">void</span>) BTSetLastSync(VTOF(vp), tv.tv_sec);
	cp-&gt;c_touch_acctime = FALSE;
	cp-&gt;c_touch_chgtime = FALSE;
	cp-&gt;c_touch_modtime = FALSE;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Remove a directory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_rmdir</span>(ap)
	<span class="enscript-type">struct</span> vnop_rmdir_args <span class="enscript-comment">/* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *dcp = VTOC(dvp);
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">int</span> error;
	time_t orig_ctime;

	orig_ctime = VTOC(vp)-&gt;c_ctime;

	<span class="enscript-keyword">if</span> (!S_ISDIR(cp-&gt;c_mode)) {
		<span class="enscript-keyword">return</span> (ENOTDIR);
	}
	<span class="enscript-keyword">if</span> (dvp == vp) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	check_for_tracked_file(vp, orig_ctime, NAMESPACE_HANDLER_DELETE_OP, NULL);
	cp = VTOC(vp);

	<span class="enscript-keyword">if</span> ((error = hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK))) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Check for a race with rmdir on the parent directory */</span>
	<span class="enscript-keyword">if</span> (dcp-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS)) {
		hfs_unlockpair (dcp, cp);
		<span class="enscript-keyword">return</span> ENOENT;
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if the item is tracked but doesn't have a document_id, assign one and generate an fsevent for it
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((cp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; ((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id == 0) {
		uint32_t newid;

		hfs_unlockpair(dcp, cp);

		<span class="enscript-keyword">if</span> (hfs_generate_document_id(VTOHFS(vp), &amp;newid) == 0) {
			hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK);
			((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id = newid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
				    FSE_ARG_DEV,   VTOHFS(vp)-&gt;hfs_raw_dev,
				    FSE_ARG_INO,   (ino64_t)0,             <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO,   (ino64_t)cp-&gt;c_fileid,  <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, newid,
				    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// XXXdbg - couldn't get a new docid... what to do?  can't really fail the rm...
</span>			hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK);
		}
	}

	error = hfs_removedir(dvp, vp, ap-&gt;a_cnp, 0, 0);

	hfs_unlockpair(dcp, cp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove a directory
 *
 * Both dvp and vp cnodes are locked
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_removedir</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp,
              <span class="enscript-type">int</span> skip_reserve, <span class="enscript-type">int</span> only_unlink)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cnode *dcp;
	<span class="enscript-type">struct</span> hfsmount * hfsmp;
	<span class="enscript-type">struct</span> cat_desc desc;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error = 0, started_tr = 0;

	cp = VTOC(vp);
	dcp = VTOC(dvp);
	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> (dcp == cp) {
		<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* cannot remove &quot;.&quot; */</span>
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) {
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_entries != 0) {
		<span class="enscript-keyword">return</span> (ENOTEMPTY);
	}
	
	<span class="enscript-comment">/*
	 * If the directory is open or in use (e.g. opendir() or current working
	 * directory for some process); wait for inactive/reclaim to actually
	 * remove cnode from the catalog.  Both inactive and reclaim codepaths are capable
	 * of removing open-unlinked directories from the catalog, as well as getting rid
	 * of EAs still on the element.  So change only_unlink to true, so that it will get 
	 * cleaned up below.
	 *
	 * Otherwise, we can get into a weird old mess where the directory has C_DELETED,
	 * but it really means C_NOEXISTS because the item was actually removed from the 
	 * catalog.  Then when we try to remove the entry from the catalog later on, it won't
	 * really be there anymore.  
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isinuse(vp, 0))  {
		only_unlink = 1;
	}

	<span class="enscript-comment">/* Deal with directory hardlinks */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_HARDLINK) {
		<span class="enscript-comment">/* 
		 * Note that if we have a directory which was a hardlink at any point,
		 * its actual directory data is stored in the directory inode in the hidden
		 * directory rather than the leaf element(s) present in the namespace.
		 * 
		 * If there are still other hardlinks to this directory, 
		 * then we'll just eliminate this particular link and the vnode will still exist.
		 * If this is the last link to an empty directory, then we'll open-unlink the 
		 * directory and it will be only tagged with C_DELETED (as opposed to C_NOEXISTS).
		 * 
		 * We could also return EBUSY here. 
		 */</span>
		
		<span class="enscript-keyword">return</span> hfs_unlink(hfsmp, dvp, vp, cnp, skip_reserve);
	}
	
	<span class="enscript-comment">/*
	 * In a few cases, we may want to allow the directory to persist in an
	 * open-unlinked state.  If the directory is being open-unlinked (still has usecount
	 * references), or if it has EAs, or if it was being deleted as part of a rename, 
	 * then we go ahead and move it to the hidden directory. 
	 *
	 * If the directory is being open-unlinked, then we want to keep the catalog entry 
	 * alive so that future EA calls and fchmod/fstat etc. do not cause issues later.
	 * 
	 * If the directory had EAs, then we want to use the open-unlink trick so that the 
	 * EA removal is not done in one giant transaction.  Otherwise, it could cause a panic
	 * due to overflowing the journal.
	 * 
	 * Finally, if it was deleted as part of a rename, we move it to the hidden directory
	 * in order to maintain rename atomicity.  
	 * 
	 * Note that the allow_dirs argument to hfs_removefile specifies that it is
	 * supposed to handle directories for this case.
     */</span>
		
	<span class="enscript-keyword">if</span> (((hfsmp-&gt;hfs_attribute_vp != NULL) &amp;&amp;
	    ((cp-&gt;c_attr.ca_recflags &amp; kHFSHasAttributesMask) != 0)) ||
		(only_unlink != 0)) {
		
		<span class="enscript-type">int</span> ret = hfs_removefile(dvp, vp, cnp, 0, 0, 1, NULL, only_unlink);
		<span class="enscript-comment">/* 
		 * Even though hfs_vnop_rename calls vnode_recycle for us on tvp we call 
		 * it here just in case we were invoked by rmdir() on a directory that had 
		 * EAs.  To ensure that we start reclaiming the space as soon as possible,
		 * we call vnode_recycle on the directory.
		 */</span>
		vnode_recycle(vp);
		
		<span class="enscript-keyword">return</span> ret;
		
	}

	dcp-&gt;c_flag |= C_DIR_MODIFICATION;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS)
		(<span class="enscript-type">void</span>)hfs_getinoquota(cp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	started_tr = 1;

	<span class="enscript-comment">/*
	 * Verify the directory is empty (and valid).
	 * (Rmdir &quot;..&quot; won't be valid since
	 *  &quot;..&quot; will contain a reference to
	 *  the current directory and thus be
	 *  non-empty.)
	 */</span>
	<span class="enscript-keyword">if</span> ((dcp-&gt;c_bsdflags &amp; APPEND) || (cp-&gt;c_bsdflags &amp; (IMMUTABLE | APPEND))) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Remove the entry from the namei cache: */</span>
	cache_purge(vp);

	<span class="enscript-comment">/* 
	 * Protect against a race with rename by using the component
	 * name passed in and parent id from dvp (instead of using 
	 * the cp-&gt;c_desc which may have changed).
	 */</span>
	desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
	desc.cd_namelen = cnp-&gt;cn_namelen;
	desc.cd_parentcnid = dcp-&gt;c_fileid;
	desc.cd_cnid = cp-&gt;c_cnid;
	desc.cd_flags = CD_ISDIR;
	desc.cd_encoding = cp-&gt;c_encoding;
	desc.cd_hint = 0;

	<span class="enscript-keyword">if</span> (!hfs_valid_cnode(hfsmp, dvp, cnp, cp-&gt;c_fileid, NULL, &amp;error)) {
	    error = 0;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Remove entry from catalog */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);

	<span class="enscript-keyword">if</span> (!skip_reserve) {
		<span class="enscript-comment">/*
		 * Reserve some space in the Catalog file.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_DELETE, NULL, 0))) {
			hfs_systemfile_unlock(hfsmp, lockflags);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	error = cat_delete(hfsmp, &amp;desc, &amp;cp-&gt;c_attr);

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// if skip_reserve == 1 then we're being called from hfs_vnop_rename() and thus
</span>		<span class="enscript-comment">// we don't need to touch the document_id as it's handled by the rename code.
</span>		<span class="enscript-comment">// otherwise it's a normal remove and we need to save the document id in the
</span>		<span class="enscript-comment">// per thread struct and clear it from the cnode.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-type">struct</span>  doc_tombstone *ut;
		ut = get_uthread_doc_tombstone();
		<span class="enscript-keyword">if</span> (!skip_reserve &amp;&amp; (cp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; should_save_docid_tombstone(ut, vp, cnp)) {
		
			<span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id) {
				clear_tombstone_docid(ut, hfsmp, NULL);
			}
			save_tombstone(hfsmp, dvp, vp, cnp, 1);

		}

		<span class="enscript-comment">/* The parent lost a child */</span>
		<span class="enscript-keyword">if</span> (dcp-&gt;c_entries &gt; 0)
			dcp-&gt;c_entries--;
		DEC_FOLDERCOUNT(hfsmp, dcp-&gt;c_attr);
		dcp-&gt;c_dirchangecnt++;
		hfs_incr_gencount(dcp);

		dcp-&gt;c_touch_chgtime = TRUE;
		dcp-&gt;c_touch_modtime = TRUE;
		dcp-&gt;c_flag |= C_MODIFIED;

		hfs_update(dcp-&gt;c_vp, 0);
	}

	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS)
		(<span class="enscript-type">void</span>)hfs_chkiq(cp, -1, NOCRED, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	hfs_volupdate(hfsmp, VOL_RMDIR, (dcp-&gt;c_cnid == kHFSRootFolderID));

	<span class="enscript-comment">/* Mark C_NOEXISTS since the catalog entry is now gone */</span>
	cp-&gt;c_flag |= C_NOEXISTS;

<span class="enscript-reference">out</span>:
	dcp-&gt;c_flag &amp;= ~C_DIR_MODIFICATION;
	wakeup((caddr_t)&amp;dcp-&gt;c_flag);

	<span class="enscript-keyword">if</span> (started_tr) { 
	    hfs_end_transaction(hfsmp);
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Remove a file or link.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_remove</span>(ap)
	<span class="enscript-type">struct</span> vnop_remove_args <span class="enscript-comment">/* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *dcp = VTOC(dvp);
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> vnode *rvp = NULL;
	<span class="enscript-type">int</span> error=0, recycle_rsrc=0;
	<span class="enscript-type">int</span> recycle_vnode = 0;
	uint32_t rsrc_vid = 0;
	time_t orig_ctime;

	<span class="enscript-keyword">if</span> (dvp == vp) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	orig_ctime = VTOC(vp)-&gt;c_ctime;
	<span class="enscript-keyword">if</span> (!vnode_isnamedstream(vp) &amp;&amp; ((ap-&gt;a_flags &amp; VNODE_REMOVE_SKIP_NAMESPACE_EVENT) == 0)) {
		error = check_for_tracked_file(vp, orig_ctime, NAMESPACE_HANDLER_DELETE_OP, NULL);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">// XXXdbg - decide on a policy for handling namespace handler failures!
</span>			<span class="enscript-comment">// for now we just let them proceed.
</span>		}		
	}
	error = 0;

	cp = VTOC(vp);

<span class="enscript-reference">relock</span>:

	hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

	<span class="enscript-keyword">if</span> ((error = hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK))) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (rvp) {
			vnode_put (rvp);
		}	
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if the item is tracked but doesn't have a document_id, assign one and generate an fsevent for it
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((cp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; ((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id == 0) {
		uint32_t newid;

		hfs_unlockpair(dcp, cp);

		<span class="enscript-keyword">if</span> (hfs_generate_document_id(VTOHFS(vp), &amp;newid) == 0) {
			hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK);
			((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id = newid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
				    FSE_ARG_DEV,   VTOHFS(vp)-&gt;hfs_raw_dev,
				    FSE_ARG_INO,   (ino64_t)0,             <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO,   (ino64_t)cp-&gt;c_fileid,  <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, newid,
				    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// XXXdbg - couldn't get a new docid... what to do?  can't really fail the rm...
</span>			hfs_lockpair(dcp, cp, HFS_EXCLUSIVE_LOCK);
		}
	}
	
	<span class="enscript-comment">/*
	 * Lazily respond to determining if there is a valid resource fork
	 * vnode attached to 'cp' if it is a regular file or symlink.  
	 * If the vnode does not exist, then we may proceed without having to
	 * create it.
	 *
	 * If, however, it does exist, then we need to acquire an iocount on the
	 * vnode after acquiring its vid.  This ensures that if we have to do I/O
	 * against it, it can't get recycled from underneath us in the middle
	 * of this call.
	 *
	 * Note: this function may be invoked for directory hardlinks, so just skip these
	 * steps if 'vp' is a directory.
	 */</span>

	<span class="enscript-keyword">if</span> ((vp-&gt;v_type == VLNK) || (vp-&gt;v_type == VREG)) {
		<span class="enscript-keyword">if</span> ((cp-&gt;c_rsrc_vp) &amp;&amp; (rvp == NULL)) {
			<span class="enscript-comment">/* We need to acquire the rsrc vnode */</span>
			rvp = cp-&gt;c_rsrc_vp;
			rsrc_vid = vnode_vid (rvp);

			<span class="enscript-comment">/* Unlock everything to acquire iocount on the rsrc vnode */</span>	
			hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);
			hfs_unlockpair (dcp, cp);
			<span class="enscript-comment">/* Use the vid to maintain identity on rvp */</span>
			<span class="enscript-keyword">if</span> (vnode_getwithvid(rvp, rsrc_vid)) {
				<span class="enscript-comment">/*
				 * If this fails, then it was recycled or 
				 * reclaimed in the interim.  Reset fields and
				 * start over.
				 */</span>
				rvp = NULL;
				rsrc_vid = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relock</span>;
		}
	}

	<span class="enscript-comment">/* 
	 * Check to see if we raced rmdir for the parent directory 
	 * hfs_removefile already checks for a race on vp/cp
	 */</span>
	<span class="enscript-keyword">if</span> (dcp-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS)) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rm_done</span>;	
	}

	error = hfs_removefile(dvp, vp, ap-&gt;a_cnp, ap-&gt;a_flags, 0, 0, NULL, 0);
	
	<span class="enscript-comment">/*
	 * If the remove succeeded in deleting the file, then we may need to mark
	 * the resource fork for recycle so that it is reclaimed as quickly
	 * as possible.  If it were not recycled quickly, then this resource fork
	 * vnode could keep a v_parent reference on the data fork, which prevents it
	 * from going through reclaim (by giving it extra usecounts), except in the force-
	 * unmount case.  
	 * 
	 * However, a caveat:  we need to continue to supply resource fork
	 * access to open-unlinked files even if the resource fork is not open.  This is
	 * a requirement for the compressed files work.  Luckily, hfs_vgetrsrc will handle
	 * this already if the data fork has been re-parented to the hidden directory.
	 * 
	 * As a result, all we really need to do here is mark the resource fork vnode
	 * for recycle.  If it goes out of core, it can be brought in again if needed.  
	 * If the cnode was instead marked C_NOEXISTS, then there wouldn't be any 
	 * more work.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		hfs_hotfile_deleted(vp);
		
	   	<span class="enscript-keyword">if</span> (rvp) {
	    	recycle_rsrc = 1;
		}
		<span class="enscript-comment">/* 
		 * If the target was actually removed from the catalog schedule it for
		 * full reclamation/inactivation.  We hold an iocount on it so it should just
		 * get marked with MARKTERM
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NOEXISTS) {
			recycle_vnode = 1;
		}
	}


	<span class="enscript-comment">/*
	 * Drop the truncate lock before unlocking the cnode
	 * (which can potentially perform a vnode_put and
	 * recycle the vnode which in turn might require the
	 * truncate lock)
	 */</span>
<span class="enscript-reference">rm_done</span>:
	hfs_unlockpair(dcp, cp);
	hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);

	<span class="enscript-keyword">if</span> (recycle_rsrc) {
		<span class="enscript-comment">/* inactive or reclaim on rvp will clean up the blocks from the rsrc fork */</span>
		vnode_recycle(rvp);
	} 
	<span class="enscript-keyword">if</span> (recycle_vnode) {
		vnode_recycle (vp);
	}

	<span class="enscript-keyword">if</span> (rvp) {
		<span class="enscript-comment">/* drop iocount on rsrc fork, was obtained at beginning of fxn */</span>
		vnode_put(rvp);
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_removefile_callback</span>(<span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> *hfsmp) {

        <span class="enscript-keyword">if</span> ( !(buf_flags(bp) &amp; B_META))
	        panic(<span class="enscript-string">&quot;hfs: symlink bp @ %p is not marked meta-data!\n&quot;</span>, bp);
	<span class="enscript-comment">/*
	 * it's part of the current transaction, kill it.
	 */</span>
	journal_kill_block(((<span class="enscript-type">struct</span> hfsmount *)hfsmp)-&gt;jnl, bp);

	<span class="enscript-keyword">return</span> (BUF_CLAIMED);
}

<span class="enscript-comment">/*
 * hfs_removefile
 *
 * Similar to hfs_vnop_remove except there are additional options.
 * This function may be used to remove directories if they have
 * lots of EA's -- note the 'allow_dirs' argument.
 *
 * This function is able to delete blocks &amp; fork data for the resource
 * fork even if it does not exist in core (and have a backing vnode).  
 * It should infer the correct behavior based on the number of blocks
 * in the cnode and whether or not the resource fork pointer exists or 
 * not.  As a result, one only need pass in the 'vp' corresponding to the
 * data fork of this file (or main vnode in the case of a directory).  
 * Passing in a resource fork will result in an error.
 *
 * Because we do not create any vnodes in this function, we are not at 
 * risk of deadlocking against ourselves by double-locking.
 *
 * Requires cnode and truncate locks to be held.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_removefile</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> componentname *cnp,
               <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> skip_reserve, <span class="enscript-type">int</span> allow_dirs, 
			   __unused <span class="enscript-type">struct</span> vnode *rvp, <span class="enscript-type">int</span> only_unlink)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cnode *dcp;
	<span class="enscript-type">struct</span> vnode *rsrc_vp = NULL;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> cat_desc desc;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> dataforkbusy = 0;
	<span class="enscript-type">int</span> rsrcforkbusy = 0;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> started_tr = 0;
	<span class="enscript-type">int</span> isbigfile = 0, defer_remove=0, isdir=0;
	<span class="enscript-type">int</span> update_vh = 0;

	cp = VTOC(vp);
	dcp = VTOC(dvp);
	hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/* Check if we lost a race post lookup. */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (!hfs_valid_cnode(hfsmp, dvp, cnp, cp-&gt;c_fileid, NULL, &amp;error)) {
	    <span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* Make sure a remove is permitted */</span>
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * We know it's a data fork.
		 * Probe the cnode to see if we have a valid resource fork
		 * in hand or not.
		 */</span>
		rsrc_vp = cp-&gt;c_rsrc_vp;
	}

	<span class="enscript-comment">/* Don't allow deleting the journal or journal_info_block. */</span>
	<span class="enscript-keyword">if</span> (hfs_is_journal_file(hfsmp, cp)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">/*
	 * Hard links require special handling.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_HARDLINK) {
		<span class="enscript-keyword">if</span> ((flags &amp; VNODE_REMOVE_NODELETEBUSY) &amp;&amp; vnode_isinuse(vp, 0)) {
			<span class="enscript-keyword">return</span> (EBUSY);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* A directory hard link with a link count of one is 
			 * treated as a regular directory.  Therefore it should 
			 * only be removed using rmdir().
			 */</span>
			<span class="enscript-keyword">if</span> ((vnode_isdir(vp) == 1) &amp;&amp; (cp-&gt;c_linkcount == 1) &amp;&amp; 
			    (allow_dirs == 0)) {
			    	<span class="enscript-keyword">return</span> (EPERM);
			}
			<span class="enscript-keyword">return</span> hfs_unlink(hfsmp, dvp, vp, cnp, skip_reserve);
		}
	}

	<span class="enscript-comment">/* Directories should call hfs_rmdir! (unless they have a lot of attributes) */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-keyword">if</span> (allow_dirs == 0)
			<span class="enscript-keyword">return</span> (EPERM);  <span class="enscript-comment">/* POSIX */</span>
		isdir = 1;
	}
	<span class="enscript-comment">/* Sanity check the parent ids. */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;c_parentcnid != hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) &amp;&amp;
	    (cp-&gt;c_parentcnid != dcp-&gt;c_fileid)) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	dcp-&gt;c_flag |= C_DIR_MODIFICATION;

	<span class="enscript-comment">// this guy is going away so mark him as such
</span>	cp-&gt;c_flag |= C_DELETED;


	<span class="enscript-comment">/* Remove our entry from the namei cache. */</span>
	cache_purge(vp);
	
	<span class="enscript-comment">/*
	 * If the caller was operating on a file (as opposed to a 
	 * directory with EAs), then we need to figure out
	 * whether or not it has a valid resource fork vnode.
	 * 
	 * If there was a valid resource fork vnode, then we need
	 * to use hfs_truncate to eliminate its data.  If there is
	 * no vnode, then we hold the cnode lock which would
	 * prevent it from being created.  As a result, 
	 * we can use the data deletion functions which do not
	 * require that a cnode/vnode pair exist.
	 */</span>

	<span class="enscript-comment">/* Check if this file is being used. */</span>
	<span class="enscript-keyword">if</span> (isdir == 0) {
		dataforkbusy = vnode_isinuse(vp, 0);
		<span class="enscript-comment">/*  
		 * At this point, we know that 'vp' points to the 
		 * a data fork because we checked it up front. And if 
		 * there is no rsrc fork, rsrc_vp will be NULL.
		 */</span>
		<span class="enscript-keyword">if</span> (rsrc_vp &amp;&amp; (cp-&gt;c_blocks - VTOF(vp)-&gt;ff_blocks)) {
			rsrcforkbusy = vnode_isinuse(rsrc_vp, 0);
		}
	}
	
	<span class="enscript-comment">/* Check if we have to break the deletion into multiple pieces. */</span>
	<span class="enscript-keyword">if</span> (isdir == 0)
		isbigfile = cp-&gt;c_datafork-&gt;ff_size &gt;= HFS_BIGFILE_SIZE;

	<span class="enscript-comment">/* Check if the file has xattrs.  If it does we'll have to delete them in
	   individual transactions in case there are too many */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_attribute_vp != NULL) &amp;&amp;
	    (cp-&gt;c_attr.ca_recflags &amp; kHFSHasAttributesMask) != 0) {
	    defer_remove = 1;
	}
	
	<span class="enscript-comment">/* If we are explicitly told to only unlink item and move to hidden dir, then do it */</span>
	<span class="enscript-keyword">if</span> (only_unlink) {
		defer_remove = 1;
	}

	<span class="enscript-comment">/*
	 * Carbon semantics prohibit deleting busy files.
	 * (enforced when VNODE_REMOVE_NODELETEBUSY is requested)
	 */</span>
	<span class="enscript-keyword">if</span> (dataforkbusy || rsrcforkbusy) {
		<span class="enscript-keyword">if</span> ((flags &amp; VNODE_REMOVE_NODELETEBUSY) ||
		    (hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid == 0)) {
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS)
		(<span class="enscript-type">void</span>)hfs_getinoquota(cp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
	
	<span class="enscript-comment">/* 
	 * Do a ubc_setsize to indicate we need to wipe contents if:
	 *  1) item is a regular file.
	 *  2) Neither fork is busy AND we are not told to unlink this. 
	 *
	 * We need to check for the defer_remove since it can be set without 
	 * having a busy data or rsrc fork   
	 */</span>
	<span class="enscript-keyword">if</span> (isdir == 0 &amp;&amp; (!dataforkbusy || !rsrcforkbusy) &amp;&amp; (defer_remove == 0)) {
		<span class="enscript-comment">/*
		 * A ubc_setsize can cause a pagein so defer it
		 * until after the cnode lock is dropped.  The
		 * cnode lock cannot be dropped/reacquired here
		 * since we might already hold the journal lock.
		 */</span>
		<span class="enscript-keyword">if</span> (!dataforkbusy &amp;&amp; cp-&gt;c_datafork-&gt;ff_blocks &amp;&amp; !isbigfile) {
			cp-&gt;c_flag |= C_NEED_DATA_SETSIZE;
		}
		<span class="enscript-keyword">if</span> (!rsrcforkbusy &amp;&amp; rsrc_vp) {
			cp-&gt;c_flag |= C_NEED_RSRC_SETSIZE;
		}
	}

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	started_tr = 1;

	<span class="enscript-comment">// XXXdbg - if we're journaled, kill any dirty symlink buffers 
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; vnode_islnk(vp) &amp;&amp; (defer_remove == 0)) {
	        buf_iterate(vp, hfs_removefile_callback, BUF_SKIP_NONLOCKED, (<span class="enscript-type">void</span> *)hfsmp);
	}

	<span class="enscript-comment">/*
	 * Prepare to truncate any non-busy forks.  Busy forks will
	 * get truncated when their vnode goes inactive.
	 * Note that we will only enter this region if we
	 * can avoid creating an open-unlinked file.  If 
	 * either region is busy, we will have to create an open
	 * unlinked file.
	 *
	 * Since we are deleting the file, we need to stagger the runtime
	 * modifications to do things in such a way that a crash won't 
	 * result in us getting overlapped extents or any other 
	 * bad inconsistencies.  As such, we call prepare_release_storage
	 * which updates the UBC, updates quota information, and releases
	 * any loaned blocks that belong to this file.  No actual 
	 * truncation or bitmap manipulation is done until *AFTER*
	 * the catalog record is removed. 
	 */</span>
	<span class="enscript-keyword">if</span> (isdir == 0 &amp;&amp; (!dataforkbusy &amp;&amp; !rsrcforkbusy) &amp;&amp; (only_unlink == 0)) {
		
		<span class="enscript-keyword">if</span> (!dataforkbusy &amp;&amp; !isbigfile &amp;&amp; cp-&gt;c_datafork-&gt;ff_blocks != 0) {
			
			error = hfs_prepare_release_storage (hfsmp, vp);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			update_vh = 1;
		}
		
		<span class="enscript-comment">/*
		 * If the resource fork vnode does not exist, we can skip this step.
		 */</span>
		<span class="enscript-keyword">if</span> (!rsrcforkbusy &amp;&amp; rsrc_vp) {
			error = hfs_prepare_release_storage (hfsmp, rsrc_vp);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			update_vh = 1;
		}
	}
	
	<span class="enscript-comment">/* 
	 * Protect against a race with rename by using the component
	 * name passed in and parent id from dvp (instead of using 
	 * the cp-&gt;c_desc which may have changed).   Also, be aware that
	 * because we allow directories to be passed in, we need to special case
	 * this temporary descriptor in case we were handed a directory.
	 */</span>
	<span class="enscript-keyword">if</span> (isdir) {
		desc.cd_flags = CD_ISDIR;
	}
	<span class="enscript-keyword">else</span> {
		desc.cd_flags = 0;
	}
	desc.cd_encoding = cp-&gt;c_desc.cd_encoding;
	desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
	desc.cd_namelen = cnp-&gt;cn_namelen;
	desc.cd_parentcnid = dcp-&gt;c_fileid;
	desc.cd_hint = cp-&gt;c_desc.cd_hint;
	desc.cd_cnid = cp-&gt;c_cnid;
	microtime(&amp;tv);

	<span class="enscript-comment">/*
	 * There are two cases to consider:
	 *  1. File/Dir is busy/big/defer_remove ==&gt; move/rename the file/dir
	 *  2. File is not in use ==&gt; remove the file
	 * 
	 * We can get a directory in case 1 because it may have had lots of attributes,
	 * which need to get removed here.
	 */</span>
	<span class="enscript-keyword">if</span> (dataforkbusy || rsrcforkbusy || isbigfile || defer_remove) {
		<span class="enscript-type">char</span> delname[32];
		<span class="enscript-type">struct</span> cat_desc to_desc;
		<span class="enscript-type">struct</span> cat_desc todir_desc;

		<span class="enscript-comment">/*
		 * Orphan this file or directory (move to hidden directory).
		 * Again, we need to take care that we treat directories as directories,
		 * and files as files.  Because directories with attributes can be passed in
		 * check to make sure that we have a directory or a file before filling in the 
		 * temporary descriptor's flags.  We keep orphaned directories AND files in
		 * the FILE_HARDLINKS private directory since we're generalizing over all
		 * orphaned filesystem objects.
		 */</span>
		bzero(&amp;todir_desc, <span class="enscript-keyword">sizeof</span>(todir_desc));
		todir_desc.cd_parentcnid = 2;

		MAKE_DELETED_NAME(delname, <span class="enscript-keyword">sizeof</span>(delname), cp-&gt;c_fileid);
		bzero(&amp;to_desc, <span class="enscript-keyword">sizeof</span>(to_desc));
		to_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)delname;
		to_desc.cd_namelen = strlen(delname);
		to_desc.cd_parentcnid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
		<span class="enscript-keyword">if</span> (isdir) {
			to_desc.cd_flags = CD_ISDIR;
		}
		<span class="enscript-keyword">else</span> {
			to_desc.cd_flags = 0;
		}
		to_desc.cd_cnid = cp-&gt;c_cnid;

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
		<span class="enscript-keyword">if</span> (!skip_reserve) {
			<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_RENAME, NULL, 0))) {
				hfs_systemfile_unlock(hfsmp, lockflags);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		error = cat_rename(hfsmp, &amp;desc, &amp;todir_desc,
				&amp;to_desc, (<span class="enscript-type">struct</span> cat_desc *)NULL);

		<span class="enscript-keyword">if</span> (error == 0) {
			hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS].ca_entries++;
			<span class="enscript-keyword">if</span> (isdir == 1) {
				INC_FOLDERCOUNT(hfsmp, hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS]);
			}
			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS],
			                  &amp;hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS], NULL, NULL);

			<span class="enscript-comment">/* Update the parent directory */</span>
			<span class="enscript-keyword">if</span> (dcp-&gt;c_entries &gt; 0)
				dcp-&gt;c_entries--;
			<span class="enscript-keyword">if</span> (isdir == 1) {
				DEC_FOLDERCOUNT(hfsmp, dcp-&gt;c_attr);
			}
			dcp-&gt;c_dirchangecnt++;
			hfs_incr_gencount(dcp);

			dcp-&gt;c_ctime = tv.tv_sec;
			dcp-&gt;c_mtime = tv.tv_sec;
			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;dcp-&gt;c_desc, &amp;dcp-&gt;c_attr, NULL, NULL);

			<span class="enscript-comment">/* Update the file or directory's state */</span>
			cp-&gt;c_flag |= C_DELETED;
			cp-&gt;c_ctime = tv.tv_sec;
			--cp-&gt;c_linkcount;
			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;to_desc, &amp;cp-&gt;c_attr, NULL, NULL);
		}
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Nobody is using this item; we can safely remove everything.
		 */</span>
		<span class="enscript-type">struct</span> filefork *temp_rsrc_fork = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		off_t savedbytes;
		<span class="enscript-type">int</span> blksize = hfsmp-&gt;blockSize;
#<span class="enscript-reference">endif</span>
		u_int32_t fileid = cp-&gt;c_fileid;
	
		<span class="enscript-comment">/* 
		 * Figure out if we need to read the resource fork data into 
		 * core before wiping out the catalog record.  
		 *
		 * 1) Must not be a directory
		 * 2) cnode's c_rsrcfork ptr must be NULL.
		 * 3) rsrc fork must have actual blocks 
		 */</span>
		<span class="enscript-keyword">if</span> ((isdir == 0) &amp;&amp; (cp-&gt;c_rsrcfork == NULL) &amp;&amp; 
				(cp-&gt;c_blocks - VTOF(vp)-&gt;ff_blocks)) {
			<span class="enscript-comment">/*
			 * The resource fork vnode &amp; filefork did not exist.
			 * Create a temporary one for use in this function only. 
			 */</span>
			MALLOC_ZONE (temp_rsrc_fork, <span class="enscript-type">struct</span> filefork *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> filefork), M_HFSFORK, M_WAITOK);
			bzero(temp_rsrc_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork));
			temp_rsrc_fork-&gt;ff_cp = cp;
			rl_init(&amp;temp_rsrc_fork-&gt;ff_invalidranges);
		}	

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">/* Look up the resource fork first, if necessary */</span>
		<span class="enscript-keyword">if</span> (temp_rsrc_fork) {
			error = cat_lookup (hfsmp, &amp;desc, 1, 0, (<span class="enscript-type">struct</span> cat_desc*) NULL, 
					(<span class="enscript-type">struct</span> cat_attr*) NULL, &amp;temp_rsrc_fork-&gt;ff_data, NULL);
			<span class="enscript-keyword">if</span> (error) {
				FREE_ZONE (temp_rsrc_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
				hfs_systemfile_unlock (hfsmp, lockflags);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-keyword">if</span> (!skip_reserve) {
			<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_DELETE, NULL, 0))) {
				<span class="enscript-keyword">if</span> (temp_rsrc_fork) {
					FREE_ZONE (temp_rsrc_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
				}
				hfs_systemfile_unlock(hfsmp, lockflags);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		
		error = cat_delete(hfsmp, &amp;desc, &amp;cp-&gt;c_attr);
		
		<span class="enscript-keyword">if</span> (error &amp;&amp; error != ENXIO &amp;&amp; error != ENOENT) {
			printf(<span class="enscript-string">&quot;hfs_removefile: deleting file %s (id=%d) vol=%s err=%d\n&quot;</span>,
				   cp-&gt;c_desc.cd_nameptr, cp-&gt;c_attr.ca_fileid, hfsmp-&gt;vcbVN, error);
		}
		
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">/* Update the parent directory */</span>
			<span class="enscript-keyword">if</span> (dcp-&gt;c_entries &gt; 0)
				dcp-&gt;c_entries--;
			dcp-&gt;c_dirchangecnt++;
			hfs_incr_gencount(dcp);

			dcp-&gt;c_ctime = tv.tv_sec;
			dcp-&gt;c_mtime = tv.tv_sec;
			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;dcp-&gt;c_desc, &amp;dcp-&gt;c_attr, NULL, NULL);
		}
		hfs_systemfile_unlock(hfsmp, lockflags);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (temp_rsrc_fork) {
				FREE_ZONE (temp_rsrc_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-comment">/* 
		 * Now that we've wiped out the catalog record, the file effectively doesn't
		 * exist anymore. So update the quota records to reflect the loss of the 
		 * data fork and the resource fork. 
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_datafork-&gt;ff_blocks &gt; 0) {
			savedbytes = ((off_t)cp-&gt;c_datafork-&gt;ff_blocks * (off_t)blksize);
			(<span class="enscript-type">void</span>) hfs_chkdq(cp, (int64_t)-(savedbytes), NOCRED, 0);
		}
		
		<span class="enscript-comment">/*
		 * We may have just deleted the catalog record for a resource fork even 
		 * though it did not exist in core as a vnode. However, just because there 
		 * was a resource fork pointer in the cnode does not mean that it had any blocks.
		 */</span>
		<span class="enscript-keyword">if</span> (temp_rsrc_fork || cp-&gt;c_rsrcfork) {
			<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork) {
			   	<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork-&gt;ff_blocks &gt; 0) {
					savedbytes = ((off_t)cp-&gt;c_rsrcfork-&gt;ff_blocks * (off_t)blksize);
					(<span class="enscript-type">void</span>) hfs_chkdq(cp, (int64_t)-(savedbytes), NOCRED, 0);
				}
			}	
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* we must have used a temporary fork */</span>
				savedbytes = ((off_t)temp_rsrc_fork-&gt;ff_blocks * (off_t)blksize);	
				(<span class="enscript-type">void</span>) hfs_chkdq(cp, (int64_t)-(savedbytes), NOCRED, 0);
			}
		}
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS) {
			(<span class="enscript-type">void</span>)hfs_chkiq(cp, -1, NOCRED, 0);
		}
#<span class="enscript-reference">endif</span>
		
		<span class="enscript-comment">/* 
		 * If we didn't get any errors deleting the catalog entry, then go ahead
		 * and release the backing store now.  The filefork pointers are still valid.
		 */</span>
		<span class="enscript-keyword">if</span> (temp_rsrc_fork) {	
			error = hfs_release_storage (hfsmp, cp-&gt;c_datafork, temp_rsrc_fork, fileid);
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* if cp-&gt;c_rsrcfork == NULL, hfs_release_storage will skip over it. */</span>
			error = hfs_release_storage (hfsmp, cp-&gt;c_datafork, cp-&gt;c_rsrcfork, fileid);
		}
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* 
			 * If we encountered an error updating the extents and bitmap,
			 * mark the volume inconsistent.  At this point, the catalog record has
			 * already been deleted, so we can't recover it at this point. We need
			 * to proceed and update the volume header and mark the cnode C_NOEXISTS.
			 * The subsequent fsck should be able to recover the free space for us.
			 */</span>
			hfs_mark_inconsistent(hfsmp, HFS_OP_INCOMPLETE);
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* reset update_vh to 0, since hfs_release_storage should have done it for us */</span>
			update_vh = 0;
		}

		<span class="enscript-comment">/* Get rid of the temporary rsrc fork */</span>
		<span class="enscript-keyword">if</span> (temp_rsrc_fork) {
			FREE_ZONE (temp_rsrc_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
		}

		cp-&gt;c_flag |= C_NOEXISTS;
		cp-&gt;c_flag &amp;= ~C_DELETED;
		
		cp-&gt;c_touch_chgtime = TRUE;
		--cp-&gt;c_linkcount;
		
		<span class="enscript-comment">/* 
		 * We must never get a directory if we're in this else block.  We could 
		 * accidentally drop the number of files in the volume header if we did.
		 */</span>
		hfs_volupdate(hfsmp, VOL_RMFILE, (dcp-&gt;c_cnid == kHFSRootFolderID));
		
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if skip_reserve == 1 then we're being called from hfs_vnop_rename() and thus
</span>	<span class="enscript-comment">// we don't need to touch the document_id as it's handled by the rename code.
</span>	<span class="enscript-comment">// otherwise it's a normal remove and we need to save the document id in the
</span>	<span class="enscript-comment">// per thread struct and clear it from the cnode.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-type">struct</span>  doc_tombstone *ut;
	ut = get_uthread_doc_tombstone();
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !skip_reserve &amp;&amp; (cp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; should_save_docid_tombstone(ut, vp, cnp)) {

		<span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id) {
			clear_tombstone_docid(ut, hfsmp, NULL);
		}
		save_tombstone(hfsmp, dvp, vp, cnp, 1);

	}


	<span class="enscript-comment">/*
	 * All done with this cnode's descriptor...
	 *
	 * Note: all future catalog calls for this cnode must be by
	 * fileid only.  This is OK for HFS (which doesn't have file
	 * thread records) since HFS doesn't support the removal of
	 * busy files.
	 */</span>
	cat_releasedesc(&amp;cp-&gt;c_desc);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
	    cp-&gt;c_flag &amp;= ~C_DELETED;
	}
	
	<span class="enscript-keyword">if</span> (update_vh) {
		<span class="enscript-comment">/* 
		 * If we bailed out earlier, we may need to update the volume header
		 * to deal with the borrowed blocks accounting. 
		 */</span>
		hfs_volupdate (hfsmp, VOL_UPDATE, 0);
	}	

	<span class="enscript-keyword">if</span> (started_tr) {
	    hfs_end_transaction(hfsmp);
	}

	dcp-&gt;c_flag &amp;= ~C_DIR_MODIFICATION;
	wakeup((caddr_t)&amp;dcp-&gt;c_flag);

	<span class="enscript-keyword">return</span> (error);
}


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">replace_desc</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cat_desc *cdp)
{
	<span class="enscript-comment">// fixes 4348457 and 4463138
</span>	<span class="enscript-keyword">if</span> (&amp;cp-&gt;c_desc == cdp) {
	    <span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* First release allocated name buffer */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_flags &amp; CD_HASBUF &amp;&amp; cp-&gt;c_desc.cd_nameptr != 0) {
		<span class="enscript-type">const</span> u_int8_t *name = cp-&gt;c_desc.cd_nameptr;

		cp-&gt;c_desc.cd_nameptr = 0;
		cp-&gt;c_desc.cd_namelen = 0;
		cp-&gt;c_desc.cd_flags &amp;= ~CD_HASBUF;
		vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)name);
	}
	bcopy(cdp, &amp;cp-&gt;c_desc, <span class="enscript-keyword">sizeof</span>(cp-&gt;c_desc));

	<span class="enscript-comment">/* Cnode now owns the name buffer */</span>
	cdp-&gt;cd_nameptr = 0;
	cdp-&gt;cd_namelen = 0;
	cdp-&gt;cd_flags &amp;= ~CD_HASBUF;
}


<span class="enscript-comment">/*
 * Rename a cnode.
 *
 * The VFS layer guarantees that:
 *   - source and destination will either both be directories, or
 *     both not be directories.
 *   - all the vnodes are from the same file system
 *
 * When the target is a directory, HFS must ensure that its empty.
 *
 * Note that this function requires up to 6 vnodes in order to work properly
 * if it is operating on files (and not on directories).  This is because only
 * files can have resource forks, and we now require iocounts to be held on the
 * vnodes corresponding to the resource forks (if applicable) as well as
 * the files or directories undergoing rename.  The problem with not holding 
 * iocounts on the resource fork vnodes is that it can lead to a deadlock 
 * situation: The rsrc fork of the source file may be recycled and reclaimed 
 * in order to provide a vnode for the destination file's rsrc fork.  Since
 * data and rsrc forks share the same cnode, we'd eventually try to lock the
 * source file's cnode in order to sync its rsrc fork to disk, but it's already 
 * been locked.  By taking the rsrc fork vnodes up front we ensure that they 
 * cannot be recycled, and that the situation mentioned above cannot happen.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_rename</span>(ap)
	<span class="enscript-type">struct</span> vnop_rename_args  <span class="enscript-comment">/* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *tvp = ap-&gt;a_tvp;
	<span class="enscript-type">struct</span> vnode *tdvp = ap-&gt;a_tdvp;
	<span class="enscript-type">struct</span> vnode *fvp = ap-&gt;a_fvp;
	<span class="enscript-type">struct</span> vnode *fdvp = ap-&gt;a_fdvp;
	<span class="enscript-comment">/*
	 * Note that we only need locals for the target/destination's
 	 * resource fork vnode (and only if necessary).  We don't care if the
	 * source has a resource fork vnode or not.
	 */</span>
	<span class="enscript-type">struct</span> vnode *tvp_rsrc = NULLVP;	
	uint32_t tvp_rsrc_vid = 0;
	<span class="enscript-type">struct</span> componentname *tcnp = ap-&gt;a_tcnp;
	<span class="enscript-type">struct</span> componentname *fcnp = ap-&gt;a_fcnp;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">struct</span> cnode *fcp;
	<span class="enscript-type">struct</span> cnode *fdcp;
	<span class="enscript-type">struct</span> cnode *tdcp;
	<span class="enscript-type">struct</span> cnode *tcp;
	<span class="enscript-type">struct</span> cnode *error_cnode;
	<span class="enscript-type">struct</span> cat_desc from_desc;
	<span class="enscript-type">struct</span> cat_desc to_desc;
	<span class="enscript-type">struct</span> cat_desc out_desc;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	cat_cookie_t cookie;
	<span class="enscript-type">int</span> tvp_deleted = 0;
	<span class="enscript-type">int</span> started_tr = 0, got_cookie = 0;
	<span class="enscript-type">int</span> took_trunc_lock = 0;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error;
	time_t orig_from_ctime, orig_to_ctime;
	<span class="enscript-type">int</span> emit_rename = 1;
	<span class="enscript-type">int</span> emit_delete = 1;
	<span class="enscript-type">int</span> is_tracked = 0;
	<span class="enscript-type">int</span> unlocked;

	orig_from_ctime = VTOC(fvp)-&gt;c_ctime;
	<span class="enscript-keyword">if</span> (tvp &amp;&amp; VTOC(tvp)) {
		orig_to_ctime = VTOC(tvp)-&gt;c_ctime;
	} <span class="enscript-keyword">else</span> {
		orig_to_ctime = ~0;
	}

	hfsmp = VTOHFS(tdvp);
	<span class="enscript-comment">/* 
	 * Do special case checks here.  If fvp == tvp then we need to check the
	 * cnode with locks held.
	 */</span>
	<span class="enscript-keyword">if</span> (fvp == tvp) {
		<span class="enscript-type">int</span> is_hardlink = 0;
		<span class="enscript-comment">/* 
		 * In this case, we do *NOT* ever emit a DELETE event.  
		 * We may not necessarily emit a RENAME event 
		 */</span>	
		emit_delete = 0;
		<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(fvp), HFS_SHARED_LOCK, HFS_LOCK_DEFAULT))) {
			<span class="enscript-keyword">return</span> error;
		}
		<span class="enscript-comment">/* Check to see if the item is a hardlink or not */</span>
		is_hardlink = (VTOC(fvp)-&gt;c_flag &amp; C_HARDLINK);
		hfs_unlock (VTOC(fvp));
		
		<span class="enscript-comment">/* 
		 * If the item is not a hardlink, then case sensitivity must be off, otherwise
		 * two names should not resolve to the same cnode unless they were case variants.
		 */</span>
		<span class="enscript-keyword">if</span> (is_hardlink) {
			emit_rename = 0;
			<span class="enscript-comment">/*
			 * Hardlinks are a little trickier.  We only want to emit a rename event
			 * if the item is a hardlink, the parent directories are the same, case sensitivity
			 * is off, and the case folded names are the same.  See the fvp == tvp case below for more
			 * info.
			 */</span>

			<span class="enscript-keyword">if</span> ((fdvp == tdvp) &amp;&amp; ((hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE) == 0)) {
				<span class="enscript-keyword">if</span> (hfs_namecmp((<span class="enscript-type">const</span> u_int8_t *)fcnp-&gt;cn_nameptr, fcnp-&gt;cn_namelen,
							(<span class="enscript-type">const</span> u_int8_t *)tcnp-&gt;cn_nameptr, tcnp-&gt;cn_namelen) == 0) {
					<span class="enscript-comment">/* Then in this case only it is ok to emit a rename */</span>
					emit_rename = 1;
				}
			}
		}
	}
	<span class="enscript-keyword">if</span> (emit_rename) {
		<span class="enscript-comment">/* c_bsdflags should only be assessed while holding the cnode lock.  
		 * This is not done consistently throughout the code and can result 
		 * in race.  This will be fixed via rdar://12181064
		 */</span>
		<span class="enscript-keyword">if</span> (VTOC(fvp)-&gt;c_bsdflags &amp; UF_TRACKED) {
			is_tracked = 1;
		}
		check_for_tracked_file(fvp, orig_from_ctime, NAMESPACE_HANDLER_RENAME_OP, NULL);
	}

	<span class="enscript-keyword">if</span> (tvp &amp;&amp; VTOC(tvp)) {
		<span class="enscript-keyword">if</span> (emit_delete) {
			check_for_tracked_file(tvp, orig_to_ctime, NAMESPACE_HANDLER_DELETE_OP, NULL);
		}
	}

<span class="enscript-reference">retry</span>:
	<span class="enscript-comment">/* When tvp exists, take the truncate lock for hfs_removefile(). */</span>
	<span class="enscript-keyword">if</span> (tvp &amp;&amp; (vnode_isreg(tvp) || vnode_islnk(tvp))) {
		hfs_lock_truncate(VTOC(tvp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		took_trunc_lock = 1;
	}

<span class="enscript-reference">relock</span>:
	error = hfs_lockfour(VTOC(fdvp), VTOC(fvp), VTOC(tdvp), tvp ? VTOC(tvp) : NULL,
	                     HFS_EXCLUSIVE_LOCK, &amp;error_cnode);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (took_trunc_lock) {
			hfs_unlock_truncate(VTOC(tvp), HFS_LOCK_DEFAULT);
			took_trunc_lock = 0;
		}

		<span class="enscript-comment">/* 
		 * We hit an error path.  If we were trying to re-acquire the locks
		 * after coming through here once, we might have already obtained
		 * an iocount on tvp's resource fork vnode.  Drop that before dealing
		 * with the failure.  Note this is safe -- since we are in an
		 * error handling path, we can't be holding the cnode locks.
		 */</span>
		<span class="enscript-keyword">if</span> (tvp_rsrc) {
			vnode_put (tvp_rsrc);
			tvp_rsrc_vid = 0;
			tvp_rsrc = NULL;
		}

		<span class="enscript-comment">/* 
		 * tvp might no longer exist.  If the cause of the lock failure 
		 * was tvp, then we can try again with tvp/tcp set to NULL.  
		 * This is ok because the vfs syscall will vnode_put the vnodes 
		 * after we return from hfs_vnop_rename.
		 */</span>
		<span class="enscript-keyword">if</span> ((error == ENOENT) &amp;&amp; (tvp != NULL) &amp;&amp; (error_cnode == VTOC(tvp))) {	
			tcp = NULL;
			tvp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		<span class="enscript-comment">/* If we want to reintroduce notifications for failed renames, this
		   is the place to do it. */</span>

		<span class="enscript-keyword">return</span> (error);
	}

	fdcp = VTOC(fdvp);
	fcp = VTOC(fvp);
	tdcp = VTOC(tdvp);
	tcp = tvp ? VTOC(tvp) : NULL;

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// if the item is tracked but doesn't have a document_id, assign one and generate an fsevent for it
</span>	<span class="enscript-comment">//
</span>	unlocked = 0;
	<span class="enscript-keyword">if</span> ((fcp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; ((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;fcp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id == 0) {
		uint32_t newid;

		hfs_unlockfour(VTOC(fdvp), VTOC(fvp), VTOC(tdvp), tvp ? VTOC(tvp) : NULL);
		unlocked = 1;

		<span class="enscript-keyword">if</span> (hfs_generate_document_id(hfsmp, &amp;newid) == 0) {
			hfs_lock(fcp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;fcp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id = newid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
				    FSE_ARG_DEV,   hfsmp-&gt;hfs_raw_dev,
				    FSE_ARG_INO,   (ino64_t)0,             <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO,   (ino64_t)fcp-&gt;c_fileid,  <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, newid,
				    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
			hfs_unlock(fcp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// XXXdbg - couldn't get a new docid... what to do?  can't really fail the rename...
</span>		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// check if we're going to need to fix tcp as well.  if we aren't, go back relock
</span>		<span class="enscript-comment">// everything.  otherwise continue on and fix up tcp as well before relocking.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (tcp == NULL || !(tcp-&gt;c_bsdflags &amp; UF_TRACKED) || ((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;tcp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">relock</span>;
		}
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// same thing for tcp if it's set
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (tcp &amp;&amp; (tcp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; ((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;tcp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id == 0) {
		uint32_t newid;

		<span class="enscript-keyword">if</span> (!unlocked) {
			hfs_unlockfour(VTOC(fdvp), VTOC(fvp), VTOC(tdvp), tvp ? VTOC(tvp) : NULL);
			unlocked = 1;
		}

		<span class="enscript-keyword">if</span> (hfs_generate_document_id(hfsmp, &amp;newid) == 0) {
			hfs_lock(tcp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
			((<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;tcp-&gt;c_attr.ca_finderinfo + 16))-&gt;document_id = newid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
				    FSE_ARG_DEV,   hfsmp-&gt;hfs_raw_dev,
				    FSE_ARG_INO,   (ino64_t)0,             <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO,   (ino64_t)tcp-&gt;c_fileid,  <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, newid,
				    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
			hfs_unlock(tcp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// XXXdbg - couldn't get a new docid... what to do?  can't really fail the rename...
</span>		}

		<span class="enscript-comment">// go back up and relock everything.  next time through the if statement won't be true
</span>		<span class="enscript-comment">// and we'll skip over this block of code.
</span>		<span class="enscript-keyword">goto</span> <span class="enscript-reference">relock</span>;
	}



	<span class="enscript-comment">/* 
	 * Acquire iocounts on the destination's resource fork vnode 
	 * if necessary. If dst/src are files and the dst has a resource 
	 * fork vnode, then we need to try and acquire an iocount on the rsrc vnode. 
	 * If it does not exist, then we don't care and can skip it.
	 */</span>
	<span class="enscript-keyword">if</span> ((vnode_isreg(fvp)) || (vnode_islnk(fvp))) {
		<span class="enscript-keyword">if</span> ((tvp) &amp;&amp; (tcp-&gt;c_rsrc_vp) &amp;&amp; (tvp_rsrc == NULL)) {
			tvp_rsrc = tcp-&gt;c_rsrc_vp;
			<span class="enscript-comment">/*
			 * We can look at the vid here because we're holding the 
			 * cnode lock on the underlying cnode for this rsrc vnode. 
			 */</span>
			tvp_rsrc_vid = vnode_vid (tvp_rsrc);

			<span class="enscript-comment">/* Unlock everything to acquire iocount on this rsrc vnode */</span>
			<span class="enscript-keyword">if</span> (took_trunc_lock) {
				hfs_unlock_truncate (VTOC(tvp), HFS_LOCK_DEFAULT);
				took_trunc_lock = 0;	
			}	
			hfs_unlockfour(fdcp, fcp, tdcp, tcp);

			<span class="enscript-keyword">if</span> (vnode_getwithvid (tvp_rsrc, tvp_rsrc_vid)) {
				<span class="enscript-comment">/* iocount acquisition failed.  Reset fields and start over.. */</span>
				tvp_rsrc_vid = 0;
				tvp_rsrc = NULL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	}



	<span class="enscript-comment">/* Ensure we didn't race src or dst parent directories with rmdir. */</span>
	<span class="enscript-keyword">if</span> (fdcp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (tdcp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
	}


	<span class="enscript-comment">/* Check for a race against unlink.  The hfs_valid_cnode checks validate
	 * the parent/child relationship with fdcp and tdcp, as well as the
	 * component name of the target cnodes.  
	 */</span>
	<span class="enscript-keyword">if</span> ((fcp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) || !hfs_valid_cnode(hfsmp, fdvp, fcnp, fcp-&gt;c_fileid, NULL, &amp;error)) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (tcp &amp;&amp; ((tcp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) || !hfs_valid_cnode(hfsmp, tdvp, tcnp, tcp-&gt;c_fileid, NULL, &amp;error))) {
	    <span class="enscript-comment">//
</span>	    <span class="enscript-comment">// hmm, the destination vnode isn't valid any more.
</span>	    <span class="enscript-comment">// in this case we can just drop him and pretend he
</span>	    <span class="enscript-comment">// never existed in the first place.
</span>	    <span class="enscript-comment">//
</span>	    <span class="enscript-keyword">if</span> (took_trunc_lock) {
			hfs_unlock_truncate(VTOC(tvp), HFS_LOCK_DEFAULT);
			took_trunc_lock = 0;
	    }
		error = 0;

	    hfs_unlockfour(fdcp, fcp, tdcp, tcp);

	    tcp = NULL;
	    tvp = NULL;
	    
	    <span class="enscript-comment">// retry the locking with tvp null'ed out
</span>	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}

	fdcp-&gt;c_flag |= C_DIR_MODIFICATION;
	<span class="enscript-keyword">if</span> (fdvp != tdvp) {
	    tdcp-&gt;c_flag |= C_DIR_MODIFICATION;
	}

	<span class="enscript-comment">/*
	 * Disallow renaming of a directory hard link if the source and 
	 * destination parent directories are different, or a directory whose 
	 * descendant is a directory hard link and the one of the ancestors
	 * of the destination directory is a directory hard link.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(fvp) &amp;&amp; (fdvp != tdvp)) {
		<span class="enscript-keyword">if</span> (fcp-&gt;c_flag &amp; C_HARDLINK) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (fcp-&gt;c_attr.ca_recflags &amp; kHFSHasChildLinkMask) {
		    lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
		    <span class="enscript-keyword">if</span> (cat_check_link_ancestry(hfsmp, tdcp-&gt;c_fileid, 0)) {
				error = EPERM;
				hfs_systemfile_unlock(hfsmp, lockflags);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			hfs_systemfile_unlock(hfsmp, lockflags);
		}
	}

	<span class="enscript-comment">/*
	 * The following edge case is caught here:
	 * (to cannot be a descendent of from)
	 *
	 *       o fdvp
	 *      /
	 *     /
	 *    o fvp
	 *     \
	 *      \
	 *       o tdvp
	 *      /
	 *     /
	 *    o tvp
	 */</span>
	<span class="enscript-keyword">if</span> (tdcp-&gt;c_parentcnid == fcp-&gt;c_fileid) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * The following two edge cases are caught here:
	 * (note tvp is not empty)
	 *
	 *       o tdvp               o tdvp
	 *      /                    /
	 *     /                    /
	 *    o tvp            tvp o fdvp
	 *     \                    \
	 *      \                    \
	 *       o fdvp               o fvp
	 *      /
	 *     /
	 *    o fvp
	 */</span>
	<span class="enscript-keyword">if</span> (tvp &amp;&amp; vnode_isdir(tvp) &amp;&amp; (tcp-&gt;c_entries != 0) &amp;&amp; fvp != tvp) {
		error = ENOTEMPTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * The following edge case is caught here:
	 * (the from child and parent are the same)
	 *
	 *          o tdvp
	 *         /
	 *        /
	 *  fdvp o fvp
	 */</span>
	<span class="enscript-keyword">if</span> (fdvp == fvp) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Make sure &quot;from&quot; vnode and its parent are changeable.
	 */</span>
	<span class="enscript-keyword">if</span> ((fcp-&gt;c_bsdflags &amp; (IMMUTABLE | APPEND)) || (fdcp-&gt;c_bsdflags &amp; APPEND)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * If the destination parent directory is &quot;sticky&quot;, then the
	 * user must own the parent directory, or the destination of
	 * the rename, otherwise the destination may not be changed
	 * (except by root). This implements append-only directories.
	 *
	 * Note that checks for immutable and write access are done
	 * by the call to hfs_removefile.
	 */</span>
	<span class="enscript-keyword">if</span> (tvp &amp;&amp; (tdcp-&gt;c_mode &amp; S_ISTXT) &amp;&amp;
	    (suser(vfs_context_ucred(tcnp-&gt;cn_context), NULL)) &amp;&amp;
	    (kauth_cred_getuid(vfs_context_ucred(tcnp-&gt;cn_context)) != tdcp-&gt;c_uid) &amp;&amp;
	    (hfs_owner_rights(hfsmp, tcp-&gt;c_uid, vfs_context_ucred(tcnp-&gt;cn_context), p, false)) ) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Don't allow modification of the journal or journal_info_block */</span>
	<span class="enscript-keyword">if</span> (hfs_is_journal_file(hfsmp, fcp) ||
	    (tcp &amp;&amp; hfs_is_journal_file(hfsmp, tcp))) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> (tvp)
		(<span class="enscript-type">void</span>)hfs_getinoquota(tcp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Preflighting done, take fvp out of the name space. */</span>
	cache_purge(fvp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SECLUDED_RENAME</span>
	<span class="enscript-comment">/*
	 * Check for &quot;secure&quot; rename that imposes additional restrictions on the
	 * source vnode.  We wait until here to check in order to prevent a race
	 * with other threads that manage to look up fvp, but their open or link
	 * is blocked by our locks.  At this point, with fvp out of the name cache,
	 * and holding the lock on fdvp, no other thread can find fvp.
	 *
	 * TODO: Do we need to limit these checks to regular files only?
	 */</span>
	<span class="enscript-keyword">if</span> (fcnp-&gt;cn_flags &amp; CN_SECLUDE_RENAME) {
		<span class="enscript-keyword">if</span> (vnode_isdir(fvp)) {
			error = EISDIR;
	        	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	    	}
	    
		<span class="enscript-comment">/*
		 * Neither fork of source may be open or memory mapped.
		 * We also don't want it in use by any other system call.
		 * The file must not have hard links.
		 *
		 * We can't simply use vnode_isinuse() because that does not
		 * count opens with O_EVTONLY.  We don't want a malicious
		 * process using O_EVTONLY to subvert a secluded rename.
		 */</span>
		<span class="enscript-keyword">if</span> (fcp-&gt;c_linkcount != 1) {
			error = EMLINK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (fcp-&gt;c_rsrc_vp &amp;&amp; (fcp-&gt;c_rsrc_vp-&gt;v_usecount &gt; 0 ||
				       fcp-&gt;c_rsrc_vp-&gt;v_iocount &gt; 0)) {
			<span class="enscript-comment">/* Resource fork is in use (including O_EVTONLY) */</span>
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (fcp-&gt;c_vp &amp;&amp; (fcp-&gt;c_vp-&gt;v_usecount &gt; (fcp-&gt;c_rsrc_vp ? 1 : 0) ||
				  fcp-&gt;c_vp-&gt;v_iocount &gt; 1)) {
			<span class="enscript-comment">/*
			 * Data fork is in use, including O_EVTONLY, but not
			 * including a reference from the resource fork.
			 */</span>
			error = EBUSY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
#<span class="enscript-reference">endif</span>
    
	bzero(&amp;from_desc, <span class="enscript-keyword">sizeof</span>(from_desc));
	from_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)fcnp-&gt;cn_nameptr;
	from_desc.cd_namelen = fcnp-&gt;cn_namelen;
	from_desc.cd_parentcnid = fdcp-&gt;c_fileid;
	from_desc.cd_flags = fcp-&gt;c_desc.cd_flags &amp; ~(CD_HASBUF | CD_DECOMPOSED);
	from_desc.cd_cnid = fcp-&gt;c_cnid;

	bzero(&amp;to_desc, <span class="enscript-keyword">sizeof</span>(to_desc));
	to_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)tcnp-&gt;cn_nameptr;
	to_desc.cd_namelen = tcnp-&gt;cn_namelen;
	to_desc.cd_parentcnid = tdcp-&gt;c_fileid;
	to_desc.cd_flags = fcp-&gt;c_desc.cd_flags &amp; ~(CD_HASBUF | CD_DECOMPOSED);
	to_desc.cd_cnid = fcp-&gt;c_cnid;

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	started_tr = 1;

	<span class="enscript-comment">/* hfs_vnop_link() and hfs_vnop_rename() set kHFSHasChildLinkMask 
	 * inside a journal transaction and without holding a cnode lock.  
	 * As setting of this bit depends on being in journal transaction for 
	 * concurrency, check this bit again after we start journal transaction for rename
	 * to ensure that this directory does not have any descendant that
	 * is a directory hard link. 
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(fvp) &amp;&amp; (fdvp != tdvp)) {
		<span class="enscript-keyword">if</span> (fcp-&gt;c_attr.ca_recflags &amp; kHFSHasChildLinkMask) {
		    lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
		    <span class="enscript-keyword">if</span> (cat_check_link_ancestry(hfsmp, tdcp-&gt;c_fileid, 0)) {
				error = EPERM;
				hfs_systemfile_unlock(hfsmp, lockflags);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			hfs_systemfile_unlock(hfsmp, lockflags);
		}
	}

	<span class="enscript-comment">// if it's a hardlink then re-lookup the name so
</span>	<span class="enscript-comment">// that we get the correct cnid in from_desc (see
</span>	<span class="enscript-comment">// the comment in hfs_removefile for more details)
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (fcp-&gt;c_flag &amp; C_HARDLINK) {
	    <span class="enscript-type">struct</span> cat_desc tmpdesc;
	    cnid_t real_cnid;

	    tmpdesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)fcnp-&gt;cn_nameptr;
	    tmpdesc.cd_namelen = fcnp-&gt;cn_namelen;
	    tmpdesc.cd_parentcnid = fdcp-&gt;c_fileid;
	    tmpdesc.cd_hint = fdcp-&gt;c_childhint;
	    tmpdesc.cd_flags = fcp-&gt;c_desc.cd_flags &amp; CD_ISDIR;
	    tmpdesc.cd_encoding = 0;
	    
	    lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

	    <span class="enscript-keyword">if</span> (cat_lookup(hfsmp, &amp;tmpdesc, 0, 0, NULL, NULL, NULL, &amp;real_cnid) != 0) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	    }

	    <span class="enscript-comment">// use the real cnid instead of whatever happened to be there
</span>	    from_desc.cd_cnid = real_cnid;
	    hfs_systemfile_unlock(hfsmp, lockflags);
	}

	<span class="enscript-comment">/*
	 * Reserve some space in the Catalog file.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_RENAME + CAT_DELETE, &amp;cookie, p))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	got_cookie = 1;

	<span class="enscript-comment">/*
	 * If the destination exists then it may need to be removed.  
	 * 
	 * Due to HFS's locking system, we should always move the 
	 * existing 'tvp' element to the hidden directory in hfs_vnop_rename.
	 * Because the VNOP_LOOKUP call enters and exits the filesystem independently
	 * of the actual vnop that it was trying to do (stat, link, readlink),
	 * we must release the cnode lock of that element during the interim to 
	 * do MAC checking, vnode authorization, and other calls.  In that time, 
	 * the item can be deleted (or renamed over). However, only in the rename 
	 * case is it inappropriate to return ENOENT from any of those calls.  Either 
	 * the call should return information about the old element (stale), or get 
	 * information about the newer element that we are about to write in its place.  
	 * 
	 * HFS lookup has been modified to detect a rename and re-drive its 
	 * lookup internally. For other calls that have already succeeded in 
	 * their lookup call and are waiting to acquire the cnode lock in order 
	 * to proceed, that cnode lock will not fail due to the cnode being marked 
	 * C_NOEXISTS, because it won't have been marked as such.  It will only 
	 * have C_DELETED.  Thus, they will simply act on the stale open-unlinked
	 * element.  All future callers will get the new element.
	 *
	 * To implement this behavior, we pass the &quot;only_unlink&quot; argument to 
	 * hfs_removefile and hfs_removedir.  This will result in the vnode acting 
	 * as though it is open-unlinked.  Additionally, when we are done moving the 
	 * element to the hidden directory, we vnode_recycle the target so that it is 
	 * reclaimed as soon as possible.  Reclaim and inactive are both 
	 * capable of clearing out unused blocks for an open-unlinked file or dir.
	 */</span>
	<span class="enscript-keyword">if</span> (tvp) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// if the destination has a document id, we need to preserve it
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (fvp != tvp) {
			uint32_t document_id;
			<span class="enscript-type">struct</span> FndrExtendedDirInfo *ffip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;fcp-&gt;c_attr.ca_finderinfo + 16);
			<span class="enscript-type">struct</span> FndrExtendedDirInfo *tfip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;tcp-&gt;c_attr.ca_finderinfo + 16);
			
			<span class="enscript-keyword">if</span> (ffip-&gt;document_id &amp;&amp; tfip-&gt;document_id) {
				<span class="enscript-comment">// both documents are tracked.  only save a tombstone from tcp and do nothing else.
</span>				save_tombstone(hfsmp, tdvp, tvp, tcnp, 0);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span>  doc_tombstone *ut;
				ut = get_uthread_doc_tombstone();
				
				document_id = tfip-&gt;document_id;
				tfip-&gt;document_id = 0;
			
				<span class="enscript-keyword">if</span> (document_id != 0) {
					<span class="enscript-comment">// clear UF_TRACKED as well since tcp is now no longer tracked
</span>					tcp-&gt;c_bsdflags &amp;= ~UF_TRACKED;
					(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;tcp-&gt;c_desc, &amp;tcp-&gt;c_attr, NULL, NULL);
				}

				<span class="enscript-keyword">if</span> (ffip-&gt;document_id == 0 &amp;&amp; document_id != 0) {
					<span class="enscript-comment">// printf(&quot;RENAME: preserving doc-id %d onto %s (from ino %d, to ino %d)\n&quot;, document_id, tcp-&gt;c_desc.cd_nameptr, tcp-&gt;c_desc.cd_cnid, fcp-&gt;c_desc.cd_cnid);
</span>					fcp-&gt;c_bsdflags |= UF_TRACKED;
					ffip-&gt;document_id = document_id;
					
					(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;fcp-&gt;c_desc, &amp;fcp-&gt;c_attr, NULL, NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
					add_fsevent(FSE_DOCID_CHANGED, vfs_context_current(),
						    FSE_ARG_DEV, hfsmp-&gt;hfs_raw_dev,
						    FSE_ARG_INO, (ino64_t)tcp-&gt;c_fileid,           <span class="enscript-comment">// src inode #
</span>						    FSE_ARG_INO, (ino64_t)fcp-&gt;c_fileid,           <span class="enscript-comment">// dst inode #
</span>						    FSE_ARG_INT32, (uint32_t)ffip-&gt;document_id,
						    FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((fcp-&gt;c_bsdflags &amp; UF_TRACKED) &amp;&amp; should_save_docid_tombstone(ut, fvp, fcnp)) {

					<span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id) {
						clear_tombstone_docid(ut, hfsmp, NULL);
					}
					save_tombstone(hfsmp, fdvp, fvp, fcnp, 0);

					<span class="enscript-comment">//printf(&quot;RENAME: (dest-exists): saving tombstone doc-id %lld @ %s (ino %d)\n&quot;,
</span>					<span class="enscript-comment">//       ut-&gt;t_lastop_document_id, ut-&gt;t_lastop_filename, fcp-&gt;c_desc.cd_cnid);
</span>				}
			}
		}

		<span class="enscript-comment">/*
		 * When fvp matches tvp they could be case variants
		 * or matching hard links.
		 */</span>
		<span class="enscript-keyword">if</span> (fvp == tvp) {
			<span class="enscript-keyword">if</span> (!(fcp-&gt;c_flag &amp; C_HARDLINK)) {
				<span class="enscript-comment">/* 
				 * If they're not hardlinks, then fvp == tvp must mean we 
				 * are using case-insensitive HFS because case-sensitive would
				 * not use the same vnode for both.  In this case we just update
				 * the catalog for: a -&gt; A
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_rm</span>;  <span class="enscript-comment">/* simple case variant */</span>

			}
		   	<span class="enscript-comment">/* For all cases below, we must be using hardlinks */</span>	
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((fdvp != tdvp) ||
			           (hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE)) {
				<span class="enscript-comment">/*
				 * If the parent directories are not the same, AND the two items
				 * are hardlinks, posix says to do nothing:
				 * dir1/fred &lt;-&gt; dir2/bob   and the op was mv dir1/fred -&gt; dir2/bob
				 * We just return 0 in this case.
				 *
				 * If case sensitivity is on, and we are using hardlinks 
				 * then renaming is supposed to do nothing.
				 * dir1/fred &lt;-&gt; dir2/FRED, and op == mv dir1/fred -&gt; dir2/FRED
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;  <span class="enscript-comment">/* matching hardlinks, nothing to do */</span>

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfs_namecmp((<span class="enscript-type">const</span> u_int8_t *)fcnp-&gt;cn_nameptr, fcnp-&gt;cn_namelen,
			                       (<span class="enscript-type">const</span> u_int8_t *)tcnp-&gt;cn_nameptr, tcnp-&gt;cn_namelen) == 0) {
				<span class="enscript-comment">/*
				 * If we get here, then the following must be true:
				 * a) We are running case-insensitive HFS+.
				 * b) Both paths 'fvp' and 'tvp' are in the same parent directory.
				 * c) the two names are case-variants of each other.
				 *
				 * In this case, we are really only dealing with a single catalog record
				 * whose name is being updated.
				 * 
				 * op is dir1/fred -&gt; dir1/FRED
				 * 
				 * We need to special case the name matching, because if
				 * dir1/fred &lt;-&gt; dir1/bob were the two links, and the 
				 * op was dir1/fred -&gt; dir1/bob
				 * That would fail/do nothing.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_rm</span>;  <span class="enscript-comment">/* case-variant hardlink in the same dir */</span>
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;  <span class="enscript-comment">/* matching hardlink, nothing to do */</span>
			}
		}

		
		<span class="enscript-keyword">if</span> (vnode_isdir(tvp)) {
			<span class="enscript-comment">/*
			 * hfs_removedir will eventually call hfs_removefile on the directory
			 * we're working on, because only hfs_removefile does the renaming of the
			 * item to the hidden directory.  The directory will stay around in the
			 * hidden directory with C_DELETED until it gets an inactive or a reclaim.
			 * That way, we can destroy all of the EAs as needed and allow new ones to be
			 * written.
			 */</span>
			error = hfs_removedir(tdvp, tvp, tcnp, HFSRM_SKIP_RESERVE, 1);
		}
		<span class="enscript-keyword">else</span> {
			error = hfs_removefile(tdvp, tvp, tcnp, 0, HFSRM_SKIP_RESERVE, 0, NULL, 1);
			
			<span class="enscript-comment">/*
			 * If the destination file had a resource fork vnode, then we need to get rid of
			 * its blocks when there are no more references to it.  Because the call to
			 * hfs_removefile above always open-unlinks things, we need to force an inactive/reclaim
			 * on the resource fork vnode, in order to prevent block leaks.  Otherwise,
			 * the resource fork vnode could prevent the data fork vnode from going out of scope
			 * because it holds a v_parent reference on it.  So we mark it for termination
			 * with a call to vnode_recycle. hfs_vnop_reclaim has been modified so that it 
			 * can clean up the blocks of open-unlinked files and resource forks. 
			 *
			 * We can safely call vnode_recycle on the resource fork because we took an iocount
			 * reference on it at the beginning of the function. 
			 */</span> 
			
			<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (tcp-&gt;c_flag &amp; C_DELETED) &amp;&amp; (tvp_rsrc)) {
				vnode_recycle(tvp_rsrc);
			}
		}

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		tvp_deleted = 1;
		
		<span class="enscript-comment">/* Mark 'tcp' as being deleted due to a rename */</span>
		tcp-&gt;c_flag |= C_RENAMED;
		
		<span class="enscript-comment">/*
		 * Aggressively mark tvp/tcp for termination to ensure that we recover all blocks
		 * as quickly as possible.
		 */</span>
		vnode_recycle(tvp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span>  doc_tombstone *ut;
		ut = get_uthread_doc_tombstone();
		
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// There is nothing at the destination.  If the file being renamed is
</span>		<span class="enscript-comment">// tracked, save a &quot;tombstone&quot; of the document_id.  If the file is
</span>		<span class="enscript-comment">// not a tracked file, then see if it needs to inherit a tombstone.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// NOTE: we do not save a tombstone if the file being renamed begins
</span>		<span class="enscript-comment">//       with &quot;atmp&quot; which is done to work-around AutoCad's bizarre
</span>		<span class="enscript-comment">//       5-step un-safe save behavior
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (fcp-&gt;c_bsdflags &amp; UF_TRACKED) {
			<span class="enscript-keyword">if</span> (should_save_docid_tombstone(ut, fvp, fcnp)) {
				save_tombstone(hfsmp, fdvp, fvp, fcnp, 0);
				
				<span class="enscript-comment">//printf(&quot;RENAME: (no dest): saving tombstone doc-id %lld @ %s (ino %d)\n&quot;,
</span>				<span class="enscript-comment">//       ut-&gt;t_lastop_document_id, ut-&gt;t_lastop_filename, fcp-&gt;c_desc.cd_cnid);
</span>			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// intentionally do nothing
</span>			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (   ut-&gt;t_lastop_document_id != 0
			   &amp;&amp; tdvp == ut-&gt;t_lastop_parent
			   &amp;&amp; vnode_vid(tdvp) == ut-&gt;t_lastop_parent_vid
			   &amp;&amp; strcmp((<span class="enscript-type">char</span> *)ut-&gt;t_lastop_filename, (<span class="enscript-type">char</span> *)tcnp-&gt;cn_nameptr) == 0) {

			<span class="enscript-comment">//printf(&quot;RENAME: %s (ino %d) inheriting doc-id %lld\n&quot;, tcnp-&gt;cn_nameptr, fcp-&gt;c_desc.cd_cnid, ut-&gt;t_lastop_document_id);
</span>			<span class="enscript-type">struct</span> FndrExtendedFileInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((<span class="enscript-type">char</span> *)&amp;fcp-&gt;c_attr.ca_finderinfo + 16);
			fcp-&gt;c_bsdflags |= UF_TRACKED;
			fip-&gt;document_id = ut-&gt;t_lastop_document_id;
			cat_update(hfsmp, &amp;fcp-&gt;c_desc, &amp;fcp-&gt;c_attr, NULL, NULL);
			
			clear_tombstone_docid(ut, hfsmp, fcp);    <span class="enscript-comment">// will send the docid-changed fsevent
</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id &amp;&amp; should_save_docid_tombstone(ut, fvp, fcnp) &amp;&amp; should_save_docid_tombstone(ut, tvp, tcnp)) {
			<span class="enscript-comment">// no match, clear the tombstone
</span>			<span class="enscript-comment">//printf(&quot;RENAME: clearing the tombstone %lld @ %s\n&quot;, ut-&gt;t_lastop_document_id, ut-&gt;t_lastop_filename);
</span>			clear_tombstone_docid(ut, hfsmp, NULL);
		}
			   
	}
<span class="enscript-reference">skip_rm</span>:
	<span class="enscript-comment">/*
	 * All done with tvp and fvp. 
	 * 
	 * We also jump to this point if there was no destination observed during lookup and namei.
	 * However, because only iocounts are held at the VFS layer, there is nothing preventing a 
	 * competing thread from racing us and creating a file or dir at the destination of this rename 
	 * operation.  If this occurs, it may cause us to get a spurious EEXIST out of the cat_rename 
	 * call below.  To preserve rename's atomicity, we need to signal VFS to re-drive the 
	 * namei/lookup and restart the rename operation.  EEXIST is an allowable errno to be bubbled 
	 * out of the rename syscall, but not for this reason, since it is a synonym errno for ENOTEMPTY.
	 * To signal VFS, we return ERECYCLE (which is also used for lookup restarts). This errno
	 * will be swallowed and it will restart the operation.
	 */</span>
	
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
	error = cat_rename(hfsmp, &amp;from_desc, &amp;tdcp-&gt;c_desc, &amp;to_desc, &amp;out_desc);
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == EEXIST) {
			error = ERECYCLE;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Invalidate negative cache entries in the destination directory */</span>
	<span class="enscript-keyword">if</span> (tdcp-&gt;c_flag &amp; C_NEG_ENTRIES) {
		cache_purge_negatives(tdvp);
		tdcp-&gt;c_flag &amp;= ~C_NEG_ENTRIES;
	}

	<span class="enscript-comment">/* Update cnode's catalog descriptor */</span>
	replace_desc(fcp, &amp;out_desc);
	fcp-&gt;c_parentcnid = tdcp-&gt;c_fileid;
	fcp-&gt;c_hint = 0;

	<span class="enscript-comment">/* Now indicate this cnode needs to have date-added written to the finderinfo */</span>
	fcp-&gt;c_flag |= C_NEEDS_DATEADDED;
	(<span class="enscript-type">void</span>) hfs_update (fvp, 0);


	hfs_volupdate(hfsmp, vnode_isdir(fvp) ? VOL_RMDIR : VOL_RMFILE,
	              (fdcp-&gt;c_cnid == kHFSRootFolderID));
	hfs_volupdate(hfsmp, vnode_isdir(fvp) ? VOL_MKDIR : VOL_MKFILE,
	              (tdcp-&gt;c_cnid == kHFSRootFolderID));

	<span class="enscript-comment">/* Update both parent directories. */</span>
	<span class="enscript-keyword">if</span> (fdvp != tdvp) {
		<span class="enscript-keyword">if</span> (vnode_isdir(fvp)) {
			<span class="enscript-comment">/* If the source directory has directory hard link 
			 * descendants, set the kHFSHasChildLinkBit in the 
			 * destination parent hierarchy 
			 */</span>
			<span class="enscript-keyword">if</span> ((fcp-&gt;c_attr.ca_recflags &amp; kHFSHasChildLinkMask) &amp;&amp; 
			    !(tdcp-&gt;c_attr.ca_recflags &amp; kHFSHasChildLinkMask)) {

				tdcp-&gt;c_attr.ca_recflags |= kHFSHasChildLinkMask;

				error = cat_set_childlinkbit(hfsmp, tdcp-&gt;c_parentcnid);
				<span class="enscript-keyword">if</span> (error) {
					printf (<span class="enscript-string">&quot;hfs_vnop_rename: error updating parent chain for %u\n&quot;</span>, tdcp-&gt;c_cnid);
					error = 0;
				}
			}
			INC_FOLDERCOUNT(hfsmp, tdcp-&gt;c_attr);
			DEC_FOLDERCOUNT(hfsmp, fdcp-&gt;c_attr);
		}
		tdcp-&gt;c_entries++;
		tdcp-&gt;c_dirchangecnt++;
		tdcp-&gt;c_flag |= C_MODIFIED;
		hfs_incr_gencount(tdcp);

		<span class="enscript-keyword">if</span> (fdcp-&gt;c_entries &gt; 0)
			fdcp-&gt;c_entries--;
		fdcp-&gt;c_dirchangecnt++;
		fdcp-&gt;c_flag |= C_MODIFIED;
		fdcp-&gt;c_touch_chgtime = TRUE;
		fdcp-&gt;c_touch_modtime = TRUE;

		<span class="enscript-keyword">if</span> (ISSET(fcp-&gt;c_flag, C_HARDLINK)) {
			hfs_relorigin(fcp, fdcp-&gt;c_fileid);
			<span class="enscript-keyword">if</span> (fdcp-&gt;c_fileid != fdcp-&gt;c_cnid)
				hfs_relorigin(fcp, fdcp-&gt;c_cnid);
		}

		(<span class="enscript-type">void</span>) hfs_update(fdvp, 0);
	}
	hfs_incr_gencount(fdcp);
		
	tdcp-&gt;c_childhint = out_desc.cd_hint;	<span class="enscript-comment">/* Cache directory's location */</span>
	tdcp-&gt;c_touch_chgtime = TRUE;
	tdcp-&gt;c_touch_modtime = TRUE;

	(<span class="enscript-type">void</span>) hfs_update(tdvp, 0);

	<span class="enscript-comment">/* Update the vnode's name now that the rename has completed. */</span>
	vnode_update_identity(fvp, tdvp, tcnp-&gt;cn_nameptr, tcnp-&gt;cn_namelen, 
			tcnp-&gt;cn_hash, (VNODE_UPDATE_PARENT | VNODE_UPDATE_NAME));
	
	<span class="enscript-comment">/* 
	 * At this point, we may have a resource fork vnode attached to the 
	 * 'from' vnode.  If it exists, we will want to update its name, because
	 * it contains the old name + _PATH_RSRCFORKSPEC. (&quot;/..namedfork/rsrc&quot;).
	 *
	 * Note that the only thing we need to update here is the name attached to
	 * the vnode, since a resource fork vnode does not have a separate resource
	 * cnode -- it's still 'fcp'.
	 */</span>
	<span class="enscript-keyword">if</span> (fcp-&gt;c_rsrc_vp) {
		<span class="enscript-type">char</span>* rsrc_path = NULL;
		<span class="enscript-type">int</span> len;

		<span class="enscript-comment">/* Create a new temporary buffer that's going to hold the new name */</span>
		MALLOC_ZONE (rsrc_path, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
		len = snprintf (rsrc_path, MAXPATHLEN, <span class="enscript-string">&quot;%s%s&quot;</span>, tcnp-&gt;cn_nameptr, _PATH_RSRCFORKSPEC);
		len = MIN(len, MAXPATHLEN);

		<span class="enscript-comment">/* 
		 * vnode_update_identity will do the following for us:
		 * 1) release reference on the existing rsrc vnode's name.
		 * 2) copy/insert new name into the name cache
		 * 3) attach the new name to the resource vnode
		 * 4) update the vnode's vid
		 */</span>
		vnode_update_identity (fcp-&gt;c_rsrc_vp, fvp, rsrc_path, len, 0, (VNODE_UPDATE_NAME | VNODE_UPDATE_CACHE));
		
		<span class="enscript-comment">/* Free the memory associated with the resource fork's name */</span>
		FREE_ZONE (rsrc_path, MAXPATHLEN, M_NAMEI);	
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (got_cookie) {
		cat_postflight(hfsmp, &amp;cookie, p);
	}
	<span class="enscript-keyword">if</span> (started_tr) {
	    hfs_end_transaction(hfsmp);
	}

	fdcp-&gt;c_flag &amp;= ~C_DIR_MODIFICATION;
	wakeup((caddr_t)&amp;fdcp-&gt;c_flag);
	<span class="enscript-keyword">if</span> (fdvp != tdvp) {
	    tdcp-&gt;c_flag &amp;= ~C_DIR_MODIFICATION;
	    wakeup((caddr_t)&amp;tdcp-&gt;c_flag);
	}

	hfs_unlockfour(fdcp, fcp, tdcp, tcp);

	<span class="enscript-keyword">if</span> (took_trunc_lock) {
		hfs_unlock_truncate(VTOC(tvp), HFS_LOCK_DEFAULT);	
	}

	<span class="enscript-comment">/* Now vnode_put the resource forks vnodes if necessary */</span>
	<span class="enscript-keyword">if</span> (tvp_rsrc) {
		vnode_put(tvp_rsrc);
		tvp_rsrc = NULL;	
	}

	<span class="enscript-comment">/* After tvp is removed the only acceptable error is EIO */</span>
	<span class="enscript-keyword">if</span> (error &amp;&amp; tvp_deleted)
		error = EIO;

	<span class="enscript-comment">/* If we want to reintroduce notifications for renames, this is the
	   place to do it. */</span>

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Make a directory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_mkdir</span>(<span class="enscript-type">struct</span> vnop_mkdir_args *ap)
{
	<span class="enscript-comment">/***** HACK ALERT ********/</span>
	ap-&gt;a_cnp-&gt;cn_flags |= MAKEENTRY;
	<span class="enscript-keyword">return</span> hfs_makenode(ap-&gt;a_dvp, ap-&gt;a_vpp, ap-&gt;a_cnp, ap-&gt;a_vap, ap-&gt;a_context);
}


<span class="enscript-comment">/*
 * Create a symbolic link.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_symlink</span>(<span class="enscript-type">struct</span> vnop_symlink_args *ap)
{
	<span class="enscript-type">struct</span> vnode **vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode *vp = NULL;
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	<span class="enscript-type">char</span> *datap;
	<span class="enscript-type">int</span> started_tr = 0;
	u_int32_t len;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* HFS standard disks don't support symbolic links */</span>
	<span class="enscript-keyword">if</span> (VTOVCB(dvp)-&gt;vcbSigWord != kHFSPlusSigWord)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-comment">/* Check for empty target name */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_target[0] == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	hfsmp = VTOHFS(dvp);
	len = strlen(ap-&gt;a_target);

	<span class="enscript-comment">/* Check for free space */</span>
	<span class="enscript-keyword">if</span> (((u_int64_t)hfs_freeblks(hfsmp, 0) * (u_int64_t)hfsmp-&gt;blockSize) &lt; len) {
		<span class="enscript-keyword">return</span> (ENOSPC);
	}

	<span class="enscript-comment">/* Create the vnode */</span>
	ap-&gt;a_vap-&gt;va_mode |= S_IFLNK;
	<span class="enscript-keyword">if</span> ((error = hfs_makenode(dvp, vpp, ap-&gt;a_cnp, ap-&gt;a_vap, ap-&gt;a_context))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	vp = *vpp;
	<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	cp = VTOC(vp);
	fp = VTOF(vp);

	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; (C_NOEXISTS | C_DELETED)) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	(<span class="enscript-type">void</span>)hfs_getinoquota(cp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	started_tr = 1;

	<span class="enscript-comment">/*
	 * Allocate space for the link.
	 *
	 * Since we're already inside a transaction,
	 *
	 * Don't need truncate lock since a symlink is treated as a system file.
	 */</span>
	error = hfs_truncate(vp, len, IO_NOZEROFILL, 0, ap-&gt;a_context);

	<span class="enscript-comment">/* On errors, remove the symlink file */</span>
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/*
		 * End the transaction so we don't re-take the cnode lock
		 * below while inside a transaction (lock order violation).
		 */</span>
		hfs_end_transaction(hfsmp);

		<span class="enscript-comment">/* hfs_removefile() requires holding the truncate lock */</span>
		hfs_unlock(cp);
		hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			started_tr = 0;
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		(<span class="enscript-type">void</span>) hfs_removefile(dvp, vp, ap-&gt;a_cnp, 0, 0, 0, NULL, 0);
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
	}

	<span class="enscript-comment">/* Write the link to disk */</span>
	bp = buf_getblk(vp, (daddr64_t)0, roundup((<span class="enscript-type">int</span>)fp-&gt;ff_size, hfsmp-&gt;hfs_physical_block_size),
			0, 0, BLK_META);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_start(hfsmp-&gt;jnl, bp);
	}
	datap = (<span class="enscript-type">char</span> *)buf_dataptr(bp);
	bzero(datap, buf_size(bp));
	bcopy(ap-&gt;a_target, datap, len);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_end(hfsmp-&gt;jnl, bp, NULL, NULL);
	} <span class="enscript-keyword">else</span> {
		buf_bawrite(bp);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (started_tr)
	    hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> ((cp != NULL) &amp;&amp; (vp != NULL)) {
		hfs_unlock(cp);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (vp) {
			vnode_put(vp);
		}
		*vpp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/* structures to hold a &quot;.&quot; or &quot;..&quot; directory entry */</span>
<span class="enscript-type">struct</span> hfs_stddotentry {
	u_int32_t	d_fileno;   <span class="enscript-comment">/* unique file number */</span>
	u_int16_t	d_reclen;   <span class="enscript-comment">/* length of this structure */</span>
	u_int8_t	d_type;     <span class="enscript-comment">/* dirent file type */</span>
	u_int8_t	d_namlen;   <span class="enscript-comment">/* len of filename */</span>
	<span class="enscript-type">char</span>		d_name[4];  <span class="enscript-comment">/* &quot;.&quot; or &quot;..&quot; */</span>
};

<span class="enscript-type">struct</span> hfs_extdotentry {
	u_int64_t  d_fileno;   <span class="enscript-comment">/* unique file number */</span>
	u_int64_t  d_seekoff;  <span class="enscript-comment">/* seek offset (optional, used by servers) */</span>
	u_int16_t  d_reclen;   <span class="enscript-comment">/* length of this structure */</span>
	u_int16_t  d_namlen;   <span class="enscript-comment">/* len of filename */</span>
	u_int8_t   d_type;     <span class="enscript-comment">/* dirent file type */</span>
	u_char     d_name[3];  <span class="enscript-comment">/* &quot;.&quot; or &quot;..&quot; */</span>
};

<span class="enscript-type">typedef</span> <span class="enscript-type">union</span> {
	<span class="enscript-type">struct</span> hfs_stddotentry  std;
	<span class="enscript-type">struct</span> hfs_extdotentry  ext;
} hfs_dotentry_t;

<span class="enscript-comment">/*
 *  hfs_vnop_readdir reads directory entries into the buffer pointed
 *  to by uio, in a filesystem independent format.  Up to uio_resid
 *  bytes of data can be transferred.  The data in the buffer is a
 *  series of packed dirent structures where each one contains the
 *  following entries:
 *
 *	u_int32_t   d_fileno;              // file number of entry
 *	u_int16_t   d_reclen;              // length of this record
 *	u_int8_t    d_type;                // file type
 *	u_int8_t    d_namlen;              // length of string in d_name
 *	char        d_name[MAXNAMELEN+1];  // null terminated file name
 *
 *  The current position (uio_offset) refers to the next block of
 *  entries.  The offset can only be set to a value previously
 *  returned by hfs_vnop_readdir or zero.  This offset does not have
 *  to match the number of bytes returned (in uio_resid).
 *
 *  In fact, the offset used by HFS is essentially an index (26 bits)
 *  with a tag (6 bits).  The tag is for associating the next request
  *  with the current request.  This enables us to have multiple threads
 *  reading the directory while the directory is also being modified.
 *
 *  Each tag/index pair is tied to a unique directory hint.  The hint
 *  contains information (filename) needed to build the catalog b-tree
 *  key for finding the next set of entries.
 *
 * If the directory is marked as deleted-but-in-use (cp-&gt;c_flag &amp; C_DELETED),
 * do NOT synthesize entries for &quot;.&quot; and &quot;..&quot;.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_readdir</span>(ap)
	<span class="enscript-type">struct</span> vnop_readdir_args <span class="enscript-comment">/* {
		vnode_t a_vp;
		uio_t a_uio;
		int a_flags;
		int *a_eofflag;
		int *a_numdirent;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	directoryhint_t *dirhint = NULL;
	directoryhint_t localhint;
	off_t offset;
	off_t startoffset;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> eofflag = 0;
	user_addr_t user_start = 0;
	user_size_t user_len = 0;
	<span class="enscript-type">int</span> index;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tag;
	<span class="enscript-type">int</span> items;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> extended;
	<span class="enscript-type">int</span> nfs_cookies;
	cnid_t cnid_hint = 0;
	<span class="enscript-type">int</span> bump_valence = 0;

	items = 0;
	startoffset = offset = uio_offset(uio);
	extended = (ap-&gt;a_flags &amp; VNODE_READDIR_EXTENDED);
	nfs_cookies = extended &amp;&amp; (ap-&gt;a_flags &amp; VNODE_READDIR_REQSEEKOFF);

	<span class="enscript-comment">/* Sanity check the uio data. */</span>
	<span class="enscript-keyword">if</span> (uio_iovcnt(uio) &gt; 1)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED) {
		<span class="enscript-type">int</span> compressed = hfs_file_is_compressed(VTOC(vp), 0);  <span class="enscript-comment">/* 0 == take the cnode lock */</span>
		<span class="enscript-keyword">if</span> (VTOCMP(vp) != NULL &amp;&amp; !compressed) {
			error = check_for_dataless_file(vp, NAMESPACE_HANDLER_READ_OP);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">return</span> error;
			}
		}
	}

	cp = VTOC(vp);
	hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/* Note that the dirhint calls require an exclusive lock. */</span>
	<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* Pick up cnid hint (if any). */</span>
	<span class="enscript-keyword">if</span> (nfs_cookies) {
		cnid_hint = (cnid_t)(uio_offset(uio) &gt;&gt; 32);
		uio_setoffset(uio, uio_offset(uio) &amp; 0x00000000ffffffffLL);
		<span class="enscript-keyword">if</span> (cnid_hint == INT_MAX) { <span class="enscript-comment">/* searching pass the last item */</span>
			eofflag = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-comment">/*
	 * Synthesize entries for &quot;.&quot; and &quot;..&quot;, unless the directory has
	 * been deleted, but not closed yet (lazy delete in progress).
	 */</span>
	<span class="enscript-keyword">if</span> (offset == 0 &amp;&amp; !(cp-&gt;c_flag &amp; C_DELETED)) {
		hfs_dotentry_t  dotentry[2];
		size_t  uiosize;

		<span class="enscript-keyword">if</span> (extended) {
			<span class="enscript-type">struct</span> hfs_extdotentry *entry = &amp;dotentry[0].ext;

			entry-&gt;d_fileno = cp-&gt;c_cnid;
			entry-&gt;d_reclen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_extdotentry);
			entry-&gt;d_type = DT_DIR;
			entry-&gt;d_namlen = 1;
			entry-&gt;d_name[0] = <span class="enscript-string">'.'</span>;
			entry-&gt;d_name[1] = <span class="enscript-string">'\0'</span>;
			entry-&gt;d_name[2] = <span class="enscript-string">'\0'</span>;
			entry-&gt;d_seekoff = 1;

			++entry;
			entry-&gt;d_fileno = cp-&gt;c_parentcnid;
			entry-&gt;d_reclen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_extdotentry);
			entry-&gt;d_type = DT_DIR;
			entry-&gt;d_namlen = 2;
			entry-&gt;d_name[0] = <span class="enscript-string">'.'</span>;
			entry-&gt;d_name[1] = <span class="enscript-string">'.'</span>;
			entry-&gt;d_name[2] = <span class="enscript-string">'\0'</span>;
			entry-&gt;d_seekoff = 2;
			uiosize = 2 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_extdotentry);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> hfs_stddotentry *entry = &amp;dotentry[0].std;

			entry-&gt;d_fileno = cp-&gt;c_cnid;
			entry-&gt;d_reclen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_stddotentry);
			entry-&gt;d_type = DT_DIR;
			entry-&gt;d_namlen = 1;
			*(<span class="enscript-type">int</span> *)&amp;entry-&gt;d_name[0] = 0;
			entry-&gt;d_name[0] = <span class="enscript-string">'.'</span>;

			++entry;
			entry-&gt;d_fileno = cp-&gt;c_parentcnid;
			entry-&gt;d_reclen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_stddotentry);
			entry-&gt;d_type = DT_DIR;
			entry-&gt;d_namlen = 2;
			*(<span class="enscript-type">int</span> *)&amp;entry-&gt;d_name[0] = 0;
			entry-&gt;d_name[0] = <span class="enscript-string">'.'</span>;
			entry-&gt;d_name[1] = <span class="enscript-string">'.'</span>;
			uiosize = 2 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_stddotentry);
		}
		<span class="enscript-keyword">if</span> ((error = uiomove((caddr_t)&amp;dotentry, uiosize, uio))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		offset += 2;
	}

	<span class="enscript-comment">/* 
	 * Intentionally avoid checking the valence here.  If we
	 * have FS corruption that reports the valence is 0, even though it
	 * has contents, we might artificially skip over iterating 
	 * this directory.
	 */</span>
	
	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// We have to lock the user's buffer here so that we won't
</span>	<span class="enscript-comment">// fault on it after we've acquired a shared lock on the
</span>	<span class="enscript-comment">// catalog file.  The issue is that you can get a 3-way
</span>	<span class="enscript-comment">// deadlock if someone else starts a transaction and then
</span>	<span class="enscript-comment">// tries to lock the catalog file but can't because we're
</span>	<span class="enscript-comment">// here and we can't service our page fault because VM is
</span>	<span class="enscript-comment">// blocked trying to start a transaction as a result of
</span>	<span class="enscript-comment">// trying to free up pages for our page fault.  It's messy
</span>	<span class="enscript-comment">// but it does happen on dual-processors that are paging
</span>	<span class="enscript-comment">// heavily (see radar 3082639 for more info).  By locking
</span>	<span class="enscript-comment">// the buffer up-front we prevent ourselves from faulting
</span>	<span class="enscript-comment">// while holding the shared catalog file lock.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// Fortunately this and hfs_search() are the only two places
</span>	<span class="enscript-comment">// currently (10/30/02) that can fault on user data with a
</span>	<span class="enscript-comment">// shared lock on the catalog file.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; uio_isuserspace(uio)) {
		user_start = uio_curriovbase(uio);
		user_len = uio_curriovlen(uio);

		<span class="enscript-keyword">if</span> ((error = vslock(user_start, user_len)) != 0) {
			user_start = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-comment">/* Convert offset into a catalog directory index. */</span>
	index = (offset &amp; HFS_INDEX_MASK) - 2;
	tag = offset &amp; ~HFS_INDEX_MASK;

	<span class="enscript-comment">/* Lock catalog during cat_findname and cat_getdirentries. */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

	<span class="enscript-comment">/* When called from NFS, try and resolve a cnid hint. */</span>
	<span class="enscript-keyword">if</span> (nfs_cookies &amp;&amp; cnid_hint != 0) {
		<span class="enscript-keyword">if</span> (cat_findname(hfsmp, cnid_hint, &amp;localhint.dh_desc) == 0) {
			<span class="enscript-keyword">if</span> ( localhint.dh_desc.cd_parentcnid == cp-&gt;c_fileid) {
				localhint.dh_index = index - 1;
				localhint.dh_time = 0;
				bzero(&amp;localhint.dh_link, <span class="enscript-keyword">sizeof</span>(localhint.dh_link));
				dirhint = &amp;localhint;  <span class="enscript-comment">/* don't forget to release the descriptor */</span>
			} <span class="enscript-keyword">else</span> {
				cat_releasedesc(&amp;localhint.dh_desc);
			}
		}
	}

	<span class="enscript-comment">/* Get a directory hint (cnode must be locked exclusive) */</span>
	<span class="enscript-keyword">if</span> (dirhint == NULL) {
		dirhint = hfs_getdirhint(cp, ((index - 1) &amp; HFS_INDEX_MASK) | tag, 0);

		<span class="enscript-comment">/* Hide tag from catalog layer. */</span>
		dirhint-&gt;dh_index &amp;= HFS_INDEX_MASK;
		<span class="enscript-keyword">if</span> (dirhint-&gt;dh_index == HFS_INDEX_MASK) {
			dirhint-&gt;dh_index = -1;
		}
	}
	
	<span class="enscript-keyword">if</span> (index == 0) {
		dirhint-&gt;dh_threadhint = cp-&gt;c_dirthreadhint;
	} 
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If we have a non-zero index, there is a possibility that during the last
		 * call to hfs_vnop_readdir we hit EOF for this directory.  If that is the case
		 * then we don't want to return any new entries for the caller.  Just return 0
		 * items, mark the eofflag, and bail out.  Because we won't have done any work, the 
		 * code at the end of the function will release the dirhint for us.  
		 *
		 * Don't forget to unlock the catalog lock on the way out, too.
		 */</span>
		<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_flags &amp; CD_EOF) {
			error = 0;
			eofflag = 1;
			uio_setoffset(uio, startoffset);
			hfs_systemfile_unlock (hfsmp, lockflags);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">seekoffcalc</span>;
		}
	}

	<span class="enscript-comment">/* Pack the buffer with dirent entries. */</span>
	error = cat_getdirentries(hfsmp, cp-&gt;c_entries, dirhint, uio, ap-&gt;a_flags, &amp;items, &amp;eofflag);

	<span class="enscript-keyword">if</span> (index == 0 &amp;&amp; error == 0) {
		cp-&gt;c_dirthreadhint = dirhint-&gt;dh_threadhint;
	}

	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/* Get index to the next item */</span>
	index += items;
	
	<span class="enscript-keyword">if</span> (items &gt;= (<span class="enscript-type">int</span>)cp-&gt;c_entries) {
		eofflag = 1;
	}
	
	<span class="enscript-comment">/* 
	 * Detect valence FS corruption.
	 *
	 * We are holding the cnode lock exclusive, so there should not be
	 * anybody modifying the valence field of this cnode.  If we enter
	 * this block, that means we observed filesystem corruption, because
	 * this directory reported a valence of 0, yet we found at least one
	 * item.  In this case, we need to minimally self-heal this
	 * directory to prevent userland from tripping over a directory
	 * that appears empty (getattr of valence reports 0), but actually 
	 * has contents. 
	 *
	 * We'll force the cnode update at the end of the function after 
	 * completing all of the normal getdirentries steps.
	 */</span> 
	<span class="enscript-keyword">if</span> ((cp-&gt;c_entries == 0) &amp;&amp; (items &gt; 0)) {
		<span class="enscript-comment">/* disk corruption */</span>
		cp-&gt;c_entries++;
		<span class="enscript-comment">/* Mark the cnode as dirty. */</span>
		cp-&gt;c_flag |= C_MODIFIED;
		printf(<span class="enscript-string">&quot;hfs_vnop_readdir: repairing valence to non-zero! \n&quot;</span>);
		bump_valence++;
	}


	<span class="enscript-comment">/* Convert catalog directory index back into an offset. */</span>
	<span class="enscript-keyword">while</span> (tag == 0)
		tag = (++cp-&gt;c_dirhinttag) &lt;&lt; HFS_INDEX_BITS;	
	uio_setoffset(uio, (index + 2) | tag);
	dirhint-&gt;dh_index |= tag;

<span class="enscript-reference">seekoffcalc</span>:
	cp-&gt;c_touch_acctime = TRUE;

	<span class="enscript-keyword">if</span> (ap-&gt;a_numdirent) {
		<span class="enscript-keyword">if</span> (startoffset == 0)
			items += 2;
		*ap-&gt;a_numdirent = items;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (user_start) {
		vsunlock(user_start, user_len, TRUE);
	}
	<span class="enscript-comment">/* If we didn't do anything then go ahead and dump the hint. */</span>
	<span class="enscript-keyword">if</span> ((dirhint != NULL) &amp;&amp;
	    (dirhint != &amp;localhint) &amp;&amp;
	    (uio_offset(uio) == startoffset)) {
		hfs_reldirhint(cp, dirhint);
		eofflag = 1;
	}
	<span class="enscript-keyword">if</span> (ap-&gt;a_eofflag) {
		*ap-&gt;a_eofflag = eofflag;
	}
	<span class="enscript-keyword">if</span> (dirhint == &amp;localhint) {
		cat_releasedesc(&amp;localhint.dh_desc);
	}

	<span class="enscript-keyword">if</span> (bump_valence) {
		<span class="enscript-comment">/* force the update before dropping the cnode lock*/</span>
		hfs_update(vp, 0);
	}

	hfs_unlock(cp);
	
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Read contents of a symbolic link.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_readlink</span>(ap)
	<span class="enscript-type">struct</span> vnop_readlink_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct uio *a_uio;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!vnode_islnk(vp))
		<span class="enscript-keyword">return</span> (EINVAL);
 
	<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
		<span class="enscript-keyword">return</span> (error);
	cp = VTOC(vp);
	fp = VTOF(vp);
   
	<span class="enscript-comment">/* Zero length sym links are not allowed */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;ff_size == 0 || fp-&gt;ff_size &gt; MAXPATHLEN) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
    
	<span class="enscript-comment">/* Cache the path so we don't waste buffer cache resources */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;ff_symlinkptr == NULL) {
		<span class="enscript-type">struct</span> buf *bp = NULL;

		MALLOC(fp-&gt;ff_symlinkptr, <span class="enscript-type">char</span> *, fp-&gt;ff_size, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (fp-&gt;ff_symlinkptr == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		error = (<span class="enscript-type">int</span>)buf_meta_bread(vp, (daddr64_t)0,
		                            roundup((<span class="enscript-type">int</span>)fp-&gt;ff_size, VTOHFS(vp)-&gt;hfs_physical_block_size),
		                            vfs_context_ucred(ap-&gt;a_context), &amp;bp);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (bp)
				buf_brelse(bp);
			<span class="enscript-keyword">if</span> (fp-&gt;ff_symlinkptr) {
				FREE(fp-&gt;ff_symlinkptr, M_TEMP);
				fp-&gt;ff_symlinkptr = NULL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		bcopy((<span class="enscript-type">char</span> *)buf_dataptr(bp), fp-&gt;ff_symlinkptr, (size_t)fp-&gt;ff_size);

		<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;jnl &amp;&amp; (buf_flags(bp) &amp; B_LOCKED) == 0) {
		        buf_markinvalid(bp);		<span class="enscript-comment">/* data no longer needed */</span>
		}
		buf_brelse(bp);
	}
	error = uiomove((caddr_t)fp-&gt;ff_symlinkptr, (<span class="enscript-type">int</span>)fp-&gt;ff_size, ap-&gt;a_uio);

	<span class="enscript-comment">/*
	 * Keep track blocks read
	 */</span>
	<span class="enscript-keyword">if</span> ((VTOHFS(vp)-&gt;hfc_stage == HFC_RECORDING) &amp;&amp; (error == 0)) {
		
		<span class="enscript-comment">/*
		 * If this file hasn't been seen since the start of
		 * the current sampling period then start over.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_atime &lt; VTOHFS(vp)-&gt;hfc_timebase)
			VTOF(vp)-&gt;ff_bytesread = fp-&gt;ff_size;
		<span class="enscript-keyword">else</span>
			VTOF(vp)-&gt;ff_bytesread += fp-&gt;ff_size;
		
	<span class="enscript-comment">//	if (VTOF(vp)-&gt;ff_bytesread &gt; fp-&gt;ff_size)
</span>	<span class="enscript-comment">//		cp-&gt;c_touch_acctime = TRUE;
</span>	}

<span class="enscript-reference">exit</span>:
	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Get configurable pathname variables.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_pathconf</span>(ap)
	<span class="enscript-type">struct</span> vnop_pathconf_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		int a_name;
		int *a_retval;
		vfs_context_t a_context;
	} */</span> *ap;
{

	<span class="enscript-type">int</span> std_hfs = (VTOHFS(ap-&gt;a_vp)-&gt;hfs_flags &amp; HFS_STANDARD);
	<span class="enscript-keyword">switch</span> (ap-&gt;a_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_LINK_MAX</span>:
		<span class="enscript-keyword">if</span> (std_hfs == 0){
			*ap-&gt;a_retval = HFS_LINK_MAX;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			*ap-&gt;a_retval = 1;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NAME_MAX</span>:
		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			*ap-&gt;a_retval = kHFSPlusMaxFileNameChars;  <span class="enscript-comment">/* 255 */</span>
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			*ap-&gt;a_retval = kHFSMaxFileNameChars;  <span class="enscript-comment">/* 31 */</span>
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_PATH_MAX</span>:
		*ap-&gt;a_retval = PATH_MAX;  <span class="enscript-comment">/* 1024 */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_PIPE_BUF</span>:
		*ap-&gt;a_retval = PIPE_BUF;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CHOWN_RESTRICTED</span>:
		*ap-&gt;a_retval = 200112;		<span class="enscript-comment">/* _POSIX_CHOWN_RESTRICTED */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NO_TRUNC</span>:
		*ap-&gt;a_retval = 200112;		<span class="enscript-comment">/* _POSIX_NO_TRUNC */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NAME_CHARS_MAX</span>:
		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			*ap-&gt;a_retval = kHFSPlusMaxFileNameChars; <span class="enscript-comment">/* 255 */</span>
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			*ap-&gt;a_retval = kHFSMaxFileNameChars; <span class="enscript-comment">/* 31 */</span>
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_SENSITIVE</span>:
		<span class="enscript-keyword">if</span> (VTOHFS(ap-&gt;a_vp)-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE)
			*ap-&gt;a_retval = 1;
		<span class="enscript-keyword">else</span>
			*ap-&gt;a_retval = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_PRESERVING</span>:
		*ap-&gt;a_retval = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_FILESIZEBITS</span>:
		<span class="enscript-comment">/* number of bits to store max file size */</span>
		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			*ap-&gt;a_retval = 64;	
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			*ap-&gt;a_retval = 32;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_XATTR_SIZE_BITS</span>:
		<span class="enscript-comment">/* Number of bits to store maximum extended attribute size */</span>
		*ap-&gt;a_retval = HFS_XATTR_SIZE_BITS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Prepares a fork for cat_update by making sure ff_size and ff_blocks
 * are no bigger than the valid data on disk thus reducing the chance
 * of exposing uninitialised data in the event of a non clean unmount.
 * fork_buf is where to put the temporary copy if required.  (It can
 * be inside pfork.)
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *
<span class="enscript-function-name">hfs_prepare_fork_for_update</span>(filefork_t *ff,
							<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *cf,
							<span class="enscript-type">struct</span> cat_fork *cf_buf,
							uint32_t block_size)
{
	<span class="enscript-keyword">if</span> (!ff)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (!cf)
		cf = &amp;ff-&gt;ff_data;
	<span class="enscript-keyword">if</span> (!cf_buf)
		cf_buf = &amp;ff-&gt;ff_data;

	off_t max_size = ff-&gt;ff_size;

	<span class="enscript-comment">// Check first invalid range
</span>	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ff-&gt;ff_invalidranges))
		max_size = TAILQ_FIRST(&amp;ff-&gt;ff_invalidranges)-&gt;rl_start;

	<span class="enscript-keyword">if</span> (!ff-&gt;ff_unallocblocks &amp;&amp; ff-&gt;ff_size &lt;= max_size)
		<span class="enscript-keyword">return</span> cf; <span class="enscript-comment">// Nothing to do
</span>
	<span class="enscript-keyword">if</span> (ff-&gt;ff_blocks &lt; ff-&gt;ff_unallocblocks) {
		panic(<span class="enscript-string">&quot;hfs: ff_blocks %d is less than unalloc blocks %d\n&quot;</span>,
			  ff-&gt;ff_blocks, ff-&gt;ff_unallocblocks);
	}

	<span class="enscript-type">struct</span> cat_fork *out = cf_buf;

	<span class="enscript-keyword">if</span> (out != cf)
		bcopy(cf, out, <span class="enscript-keyword">sizeof</span>(*cf));

	<span class="enscript-comment">// Adjust cf_blocks for cf_vblocks
</span>	out-&gt;cf_blocks -= out-&gt;cf_vblocks;

	<span class="enscript-comment">/*
	 * Here we trim the size with the updated cf_blocks.  This is
	 * probably unnecessary now because the invalid ranges should
	 * catch this (but that wasn't always the case).
	 */</span>
	off_t alloc_bytes = hfs_blk_to_bytes(out-&gt;cf_blocks, block_size);
	<span class="enscript-keyword">if</span> (out-&gt;cf_size &gt; alloc_bytes)
		out-&gt;cf_size = alloc_bytes;

	<span class="enscript-comment">// Trim cf_size to first invalid range
</span>	<span class="enscript-keyword">if</span> (out-&gt;cf_size &gt; max_size)
		out-&gt;cf_size = max_size;

	<span class="enscript-keyword">return</span> out;
}

<span class="enscript-comment">/*
 * Update a cnode's on-disk metadata.
 *
 * The cnode must be locked exclusive.  See declaration for possible
 * options.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_update</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> options)
{
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">struct</span> proc *p;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dataforkp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *rsrcforkp = NULL;
	<span class="enscript-type">struct</span> cat_fork datafork;
	<span class="enscript-type">struct</span> cat_fork rsrcfork;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error;
	uint32_t tstate = 0;

	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_NOEXISTS))
		<span class="enscript-keyword">return</span> 0;

	p = current_proc();
	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> (((vnode_issystem(vp) &amp;&amp; (cp-&gt;c_cnid &lt; kHFSFirstUserCatalogNodeID))) || 
	   	hfsmp-&gt;hfs_catalog_vp == NULL){
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) || (cp-&gt;c_mode == 0)) {
		CLR(cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD | C_NEEDS_DATEADDED);
		cp-&gt;c_touch_acctime = 0;
		cp-&gt;c_touch_chgtime = 0;
		cp-&gt;c_touch_modtime = 0;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (kdebug_enable) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime || cp-&gt;c_atime != cp-&gt;c_attr.ca_atimeondisk)
			tstate |= DBG_HFS_UPDATE_ACCTIME;
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_modtime)
			tstate |= DBG_HFS_UPDATE_MODTIME;
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_chgtime)
			tstate |= DBG_HFS_UPDATE_CHGTIME;

		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_MODIFIED)
			tstate |= DBG_HFS_UPDATE_MODIFIED;
		<span class="enscript-keyword">if</span> (ISSET(options, HFS_UPDATE_FORCE))
			tstate |= DBG_HFS_UPDATE_FORCE;
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NEEDS_DATEADDED)
			tstate |= DBG_HFS_UPDATE_DATEADDED;
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_MINOR_MOD)
			tstate |= DBG_HFS_UPDATE_MINOR;
	}
	hfs_touchtimes(hfsmp, cp);

	<span class="enscript-keyword">if</span> (!ISSET(cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD)
		&amp;&amp; !hfs_should_save_atime(cp)) {
		<span class="enscript-comment">// Nothing to update
</span>		<span class="enscript-keyword">return</span> 0;
	}

	KDBG(HFSDBG_UPDATE | DBG_FUNC_START, VM_KERNEL_ADDRPERM(vp), tstate);

	bool check_txn = false;

	<span class="enscript-keyword">if</span> (!ISSET(options, HFS_UPDATE_FORCE) &amp;&amp; !ISSET(cp-&gt;c_flag, C_MODIFIED)) {
		<span class="enscript-comment">/*
		 * This must be a minor modification.  If the current
		 * transaction already has an update for this node, then we
		 * bundle in the modification.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl
			&amp;&amp; journal_current_txn(hfsmp-&gt;jnl) == cp-&gt;c_update_txn) {
			check_txn = true;
		} <span class="enscript-keyword">else</span> {
			tstate |= DBG_HFS_UPDATE_SKIPPED;
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-keyword">if</span> (check_txn
		&amp;&amp; journal_current_txn(hfsmp-&gt;jnl) != cp-&gt;c_update_txn) {
		hfs_end_transaction(hfsmp);
		tstate |= DBG_HFS_UPDATE_SKIPPED;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (cp-&gt;c_datafork)
		dataforkp = &amp;cp-&gt;c_datafork-&gt;ff_data;
	<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork)
		rsrcforkp = &amp;cp-&gt;c_rsrcfork-&gt;ff_data;

    <span class="enscript-comment">/*
     * Modify the values passed to cat_update based on whether or not
     * the file has invalid ranges or borrowed blocks.
     */</span>
    dataforkp = hfs_prepare_fork_for_update(cp-&gt;c_datafork, NULL, &amp;datafork, hfsmp-&gt;blockSize);
	rsrcforkp = hfs_prepare_fork_for_update(cp-&gt;c_rsrcfork, NULL, &amp;rsrcfork, hfsmp-&gt;blockSize);

	<span class="enscript-keyword">if</span> (__improbable(kdebug_enable &amp; KDEBUG_TRACE)) {
		<span class="enscript-type">long</span> dbg_parms[NUMPARMS];
		<span class="enscript-type">int</span>  dbg_namelen;

		dbg_namelen = NUMPARMS * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">long</span>);
		vn_getpath(vp, (<span class="enscript-type">char</span> *)dbg_parms, &amp;dbg_namelen);

		<span class="enscript-keyword">if</span> (dbg_namelen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(dbg_parms))
			memset((<span class="enscript-type">char</span> *)dbg_parms + dbg_namelen, 0, <span class="enscript-keyword">sizeof</span>(dbg_parms) - dbg_namelen);

		kdebug_lookup_gen_events(dbg_parms, dbg_namelen, (<span class="enscript-type">void</span> *)vp, TRUE);
	}

	<span class="enscript-comment">/*
	 * Lock the Catalog b-tree file.
	 */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

	error = cat_update(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr, dataforkp, rsrcforkp);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl)
		cp-&gt;c_update_txn = journal_current_txn(hfsmp-&gt;jnl);

	hfs_systemfile_unlock(hfsmp, lockflags);

	CLR(cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD);

	hfs_end_transaction(hfsmp);

<span class="enscript-reference">exit</span>:

	KDBG(HFSDBG_UPDATE | DBG_FUNC_END, VM_KERNEL_ADDRPERM(vp), tstate, error);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Allocate a new node
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_makenode</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> componentname *cnp,
             <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">struct</span> cnode *dcp = NULL;
	<span class="enscript-type">struct</span> vnode *tvp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> cat_desc in_desc, out_desc;
	<span class="enscript-type">struct</span> cat_attr attr;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> error, started_tr = 0;
	<span class="enscript-type">enum</span> vtype vnodetype;
	<span class="enscript-type">int</span> mode;
	<span class="enscript-type">int</span> newvnode_flags = 0;
	u_int32_t gnv_flags = 0;
	<span class="enscript-type">int</span> protectable_target = 0;
	<span class="enscript-type">int</span> nocache = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-type">struct</span> cprotect *entry = NULL;
	int32_t cp_class = -1;

	<span class="enscript-comment">/* 
	 * By default, it's OK for AKS to overrride our target class preferences.
	 */</span>
	uint32_t keywrap_flags = CP_KEYWRAP_DIFFCLASS;

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_dataprotect_class)) {
		cp_class = (int32_t)vap-&gt;va_dataprotect_class;
		<span class="enscript-comment">/* 
		 * Since the user specifically requested this target class be used,
		 * we want to fail this creation operation if we cannot wrap to their 
		 * target class. The CP_KEYWRAP_DIFFCLASS bit says that it is OK to
		 * use a different class than the one specified, so we turn that off
		 * now.
		 */</span>
		keywrap_flags &amp;= ~CP_KEYWRAP_DIFFCLASS;
	}
	<span class="enscript-type">int</span> protected_mount = 0;	
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">if</span> ((error = hfs_lock(VTOC(dvp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* set the cnode pointer only after successfully acquiring lock */</span>
	dcp = VTOC(dvp);

	<span class="enscript-comment">/* Don't allow creation of new entries in open-unlinked directories */</span>
	<span class="enscript-keyword">if</span> ((error = hfs_checkdeleted(dcp))) {
		hfs_unlock(dcp);
		<span class="enscript-keyword">return</span> error;
	}

	dcp-&gt;c_flag |= C_DIR_MODIFICATION;

	hfsmp = VTOHFS(dvp);

	*vpp = NULL;
	tvp = NULL;
	out_desc.cd_flags = 0;
	out_desc.cd_nameptr = NULL;

	vnodetype = vap-&gt;va_type;
	<span class="enscript-keyword">if</span> (vnodetype == VNON)
		vnodetype = VREG;
	mode = MAKEIMODE(vnodetype, vap-&gt;va_mode);

	<span class="enscript-keyword">if</span> (S_ISDIR (mode) || S_ISREG (mode)) {
		protectable_target = 1;
	}
	

	<span class="enscript-comment">/* Check if were out of usable disk space. */</span>
	<span class="enscript-keyword">if</span> ((hfs_freeblks(hfsmp, 1) == 0) &amp;&amp; (vfs_context_suser(ctx) != 0)) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	microtime(&amp;tv);

	<span class="enscript-comment">/* Setup the default attributes */</span>
	bzero(&amp;attr, <span class="enscript-keyword">sizeof</span>(attr));
	attr.ca_mode = mode;
	attr.ca_linkcount = 1;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_rdev)) {
		attr.ca_rdev = vap-&gt;va_rdev;
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time)) {
		VATTR_SET_SUPPORTED(vap, va_create_time);
		attr.ca_itime = vap-&gt;va_create_time.tv_sec;
	} <span class="enscript-keyword">else</span> {
		attr.ca_itime = tv.tv_sec;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) &amp;&amp; gTimeZone.tz_dsttime) {
		attr.ca_itime += 3600;	<span class="enscript-comment">/* Same as what hfs_update does */</span>
	}
#<span class="enscript-reference">endif</span>
	attr.ca_atime = attr.ca_ctime = attr.ca_mtime = attr.ca_itime;
	attr.ca_atimeondisk = attr.ca_atime;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		VATTR_SET_SUPPORTED(vap, va_flags);
		attr.ca_flags = vap-&gt;va_flags;
	}
	
	<span class="enscript-comment">/* 
	 * HFS+ only: all files get ThreadExists
	 * HFSX only: dirs get HasFolderCount
	 */</span>
	<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; HFS_STANDARD)) {
		<span class="enscript-keyword">if</span> (vnodetype == VDIR) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT)
				attr.ca_recflags = kHFSHasFolderCountMask;
		} <span class="enscript-keyword">else</span> {
			attr.ca_recflags = kHFSThreadExistsMask;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>	
	<span class="enscript-keyword">if</span> (cp_fs_protected(hfsmp-&gt;hfs_mp)) {
		protected_mount = 1;
	}
	<span class="enscript-comment">/*
	 * On a content-protected HFS+/HFSX filesystem, files and directories
	 * cannot be created without atomically setting/creating the EA that 
	 * contains the protection class metadata and keys at the same time, in
	 * the same transaction.  As a result, pre-set the &quot;EAs exist&quot; flag
	 * on the cat_attr for protectable catalog record creations.  This will
	 * cause the cnode creation routine in hfs_getnewvnode to mark the cnode
	 * as having EAs.
	 */</span>
	<span class="enscript-keyword">if</span> ((protected_mount) &amp;&amp; (protectable_target)) {
		attr.ca_recflags |= kHFSHasAttributesMask;
		<span class="enscript-comment">/* delay entering in the namecache */</span>
		nocache = 1;
	}
#<span class="enscript-reference">endif</span>


	<span class="enscript-comment">/* 
	 * Add the date added to the item. See above, as
	 * all of the dates are set to the itime.
	 */</span>
	hfs_write_dateadded (&amp;attr, attr.ca_atime);

	<span class="enscript-comment">/* Initialize the gen counter to 1 */</span>
	hfs_write_gencount(&amp;attr, (uint32_t)1);

	attr.ca_uid = vap-&gt;va_uid;
	attr.ca_gid = vap-&gt;va_gid;
	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-comment">/* check to see if this node's creation would cause us to go over
	 * quota.  If so, abort this operation.
	 */</span>
   	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS) {
		<span class="enscript-keyword">if</span> ((error = hfs_quotacheck(hfsmp, 1, attr.ca_uid, attr.ca_gid,
									vfs_context_ucred(ctx)))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}	
#<span class="enscript-reference">endif</span>


	<span class="enscript-comment">/* Tag symlinks with a type and creator. */</span>
	<span class="enscript-keyword">if</span> (vnodetype == VLNK) {
		<span class="enscript-type">struct</span> FndrFileInfo *fip;

		fip = (<span class="enscript-type">struct</span> FndrFileInfo *)&amp;attr.ca_finderinfo;
		fip-&gt;fdType    = SWAP_BE32(kSymLinkFileType);
		fip-&gt;fdCreator = SWAP_BE32(kSymLinkCreator);
	}

	<span class="enscript-comment">/* Setup the descriptor */</span>
	in_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
	in_desc.cd_namelen = cnp-&gt;cn_namelen;
	in_desc.cd_parentcnid = dcp-&gt;c_fileid;
	in_desc.cd_flags = S_ISDIR(mode) ? CD_ISDIR : 0;
	in_desc.cd_hint = dcp-&gt;c_childhint;
	in_desc.cd_encoding = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/*
	 * To preserve file creation atomicity with regards to the content protection EA,
	 * we must create the file in the catalog and then write out its EA in the same
	 * transaction.  
	 * 
	 * We only denote the target class in this EA; key generation is not completed
	 * until the file has been inserted into the catalog and will be done
	 * in a separate transaction.
	 */</span>
	<span class="enscript-keyword">if</span> ((protected_mount) &amp;&amp; (protectable_target)) {
		error = cp_setup_newentry(hfsmp, dcp, cp_class, attr.ca_mode, &amp;entry);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) != 0) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	started_tr = 1;

	<span class="enscript-comment">// have to also lock the attribute file because cat_create() needs
</span>	<span class="enscript-comment">// to check that any fileID it wants to use does not have orphaned
</span>	<span class="enscript-comment">// attributes in it.
</span>	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE, HFS_EXCLUSIVE_LOCK);
	cnid_t new_id;

	<span class="enscript-comment">/* Reserve some space in the Catalog file. */</span>
	<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_CREATE, NULL, 0))) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> ((error = cat_acquire_cnid(hfsmp, &amp;new_id))) {
		hfs_systemfile_unlock (hfsmp, lockflags);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	error = cat_create(hfsmp, new_id, &amp;in_desc, &amp;attr, &amp;out_desc);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* Update the parent directory */</span>
		dcp-&gt;c_childhint = out_desc.cd_hint;	<span class="enscript-comment">/* Cache directory's location */</span>
		dcp-&gt;c_entries++;

		<span class="enscript-keyword">if</span> (vnodetype == VDIR) {
			INC_FOLDERCOUNT(hfsmp, dcp-&gt;c_attr);
		}
		dcp-&gt;c_dirchangecnt++;
		hfs_incr_gencount(dcp);

		dcp-&gt;c_touch_chgtime = dcp-&gt;c_touch_modtime = true;
		dcp-&gt;c_flag |= C_MODIFIED;

		hfs_update(dcp-&gt;c_vp, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">/*
		 * If we are creating a content protected file, now is when
		 * we create the EA. We must create it in the same transaction
		 * that creates the file.  We can also guarantee that the file 
		 * MUST exist because we are still holding the catalog lock
		 * at this point.
		 */</span>
		<span class="enscript-keyword">if</span> ((attr.ca_fileid != 0) &amp;&amp; (protected_mount) &amp;&amp; (protectable_target)) {
			error = cp_setxattr (NULL, entry, hfsmp, attr.ca_fileid, XATTR_CREATE);
			
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-type">int</span> delete_err;
				<span class="enscript-comment">/* 
				 * If we fail the EA creation, then we need to delete the file. 
				 * Luckily, we are still holding all of the right locks.
				 */</span>
				delete_err = cat_delete (hfsmp, &amp;out_desc, &amp;attr);
				<span class="enscript-keyword">if</span> (delete_err == 0) {
					<span class="enscript-comment">/* Update the parent directory */</span>
					<span class="enscript-keyword">if</span> (dcp-&gt;c_entries &gt; 0)
						dcp-&gt;c_entries--;
					dcp-&gt;c_dirchangecnt++;
					dcp-&gt;c_ctime = tv.tv_sec;
					dcp-&gt;c_mtime = tv.tv_sec;
					(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;dcp-&gt;c_desc, &amp;dcp-&gt;c_attr, NULL, NULL);
				}

				<span class="enscript-comment">/* Emit EINVAL if we fail to create EA*/</span>
				error = EINVAL;
			}
		}		
#<span class="enscript-reference">endif</span>
	}
	hfs_systemfile_unlock(hfsmp, lockflags);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	uint32_t txn = hfsmp-&gt;jnl ? journal_current_txn(hfsmp-&gt;jnl) : 0;

	<span class="enscript-comment">/* Invalidate negative cache entries in the directory */</span>
	<span class="enscript-keyword">if</span> (dcp-&gt;c_flag &amp; C_NEG_ENTRIES) {
		cache_purge_negatives(dvp);
		dcp-&gt;c_flag &amp;= ~C_NEG_ENTRIES;
	}

	hfs_volupdate(hfsmp, vnodetype == VDIR ? VOL_MKDIR : VOL_MKFILE,
		(dcp-&gt;c_cnid == kHFSRootFolderID));

	<span class="enscript-comment">// XXXdbg
</span>	<span class="enscript-comment">// have to end the transaction here before we call hfs_getnewvnode()
</span>	<span class="enscript-comment">// because that can cause us to try and reclaim a vnode on a different
</span>	<span class="enscript-comment">// file system which could cause us to start a transaction which can
</span>	<span class="enscript-comment">// deadlock with someone on that other file system (since we could be
</span>	<span class="enscript-comment">// holding two transaction locks as well as various vnodes and we did
</span>	<span class="enscript-comment">// not obtain the locks on them in the proper order).
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// NOTE: this means that if the quota check fails or we have to update
</span>	<span class="enscript-comment">//       the change time on a block-special device that those changes
</span>	<span class="enscript-comment">//       will happen as part of independent transactions.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (started_tr) {
	    hfs_end_transaction(hfsmp);
	    started_tr = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* 
	 * At this point, we must have encountered success with writing the EA.
	 * Destroy our temporary cprotect (which had no keys). 
	 */</span>

	<span class="enscript-keyword">if</span> ((attr.ca_fileid != 0) &amp;&amp; (protected_mount) &amp;&amp; (protectable_target))  {
		cp_entry_destroy (hfsmp, entry);
		entry = NULL;
	}
#<span class="enscript-reference">endif</span>
	gnv_flags |= GNV_CREATE;
	<span class="enscript-keyword">if</span> (nocache) {
		gnv_flags |= GNV_NOCACHE;
	}

	<span class="enscript-comment">/*
	 * Create a vnode for the object just created.
	 * 
	 * NOTE: Maintaining the cnode lock on the parent directory is important,
	 * as it prevents race conditions where other threads want to look up entries 
	 * in the directory and/or add things as we are in the process of creating
	 * the vnode below.  However, this has the potential for causing a 
	 * double lock panic when dealing with shadow files on a HFS boot partition. 
	 * The panic could occur if we are not cleaning up after ourselves properly 
	 * when done with a shadow file or in the error cases.  The error would occur if we 
	 * try to create a new vnode, and then end up reclaiming another shadow vnode to 
	 * create the new one.  However, if everything is working properly, this should
	 * be a non-issue as we would never enter that reclaim codepath.
	 * 
	 * The cnode is locked on successful return.
	 */</span>
	error = hfs_getnewvnode(hfsmp, dvp, cnp, &amp;out_desc, gnv_flags, &amp;attr, 
							NULL, &amp;tvp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	cp = VTOC(tvp);

	cp-&gt;c_update_txn = txn;

	<span class="enscript-type">struct</span>  doc_tombstone *ut;
	ut = get_uthread_doc_tombstone();
	<span class="enscript-keyword">if</span> (   ut-&gt;t_lastop_document_id != 0 
	    &amp;&amp; ut-&gt;t_lastop_parent == dvp
	    &amp;&amp; ut-&gt;t_lastop_parent_vid == vnode_vid(dvp)
	    &amp;&amp; strcmp((<span class="enscript-type">char</span> *)ut-&gt;t_lastop_filename, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr) == 0) {
		<span class="enscript-type">struct</span> FndrExtendedDirInfo *fip = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)((<span class="enscript-type">char</span> *)&amp;cp-&gt;c_attr.ca_finderinfo + 16);

		<span class="enscript-comment">//printf(&quot;CREATE: preserving doc-id %lld on %s\n&quot;, ut-&gt;t_lastop_document_id, ut-&gt;t_lastop_filename);
</span>		fip-&gt;document_id = (uint32_t)(ut-&gt;t_lastop_document_id &amp; 0xffffffff);

		cp-&gt;c_bsdflags |= UF_TRACKED;
		cp-&gt;c_flag |= C_MODIFIED;

		<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) == 0) {
			lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

			(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr, NULL, NULL);

			hfs_systemfile_unlock (hfsmp, lockflags);
			(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);
		}

		clear_tombstone_docid(ut, hfsmp, cp);       <span class="enscript-comment">// will send the docid-changed fsevent
</span>	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ut-&gt;t_lastop_document_id != 0) {
		<span class="enscript-type">int</span> len = cnp-&gt;cn_namelen;
		<span class="enscript-keyword">if</span> (len == 0) {
			len = strlen(cnp-&gt;cn_nameptr);
		}

		<span class="enscript-keyword">if</span> (is_ignorable_temp_name(cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen)) {
			<span class="enscript-comment">// printf(&quot;CREATE: not clearing tombstone because %s is a temp name.\n&quot;, cnp-&gt;cn_nameptr);
</span>		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// Clear the tombstone because the thread is not recreating the same path
</span>			<span class="enscript-comment">// printf(&quot;CREATE: clearing tombstone because %s is NOT a temp name.\n&quot;, cnp-&gt;cn_nameptr);
</span>			clear_tombstone_docid(ut, hfsmp, NULL);
		}
	}

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; (vnode_isfastdevicecandidate(dvp) &amp;&amp; !vnode_isautocandidate(dvp))) {

		<span class="enscript-comment">//printf(&quot;hfs: flagging %s (fileid: %d) as VFASTDEVCANDIDATE (dvp name: %s)\n&quot;,
</span>		<span class="enscript-comment">//       cnp-&gt;cn_nameptr ? cnp-&gt;cn_nameptr : &quot;&lt;NONAME&gt;&quot;,
</span>		<span class="enscript-comment">//       cp-&gt;c_fileid,
</span>		<span class="enscript-comment">//       dvp-&gt;v_name ? dvp-&gt;v_name : &quot;no-dir-name&quot;);
</span>
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// On new files we set the FastDevCandidate flag so that
</span>		<span class="enscript-comment">// any new blocks allocated to it will be pinned.
</span>		<span class="enscript-comment">//
</span>		cp-&gt;c_attr.ca_recflags |= kHFSFastDevCandidateMask;
		vnode_setfastdevicecandidate(tvp);

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// properly inherit auto-cached flags
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (vnode_isautocandidate(dvp)) {
			cp-&gt;c_attr.ca_recflags |= kHFSAutoCandidateMask;
			vnode_setautocandidate(tvp);
		}


		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// We also want to add it to the hotfile adoption list so
</span>		<span class="enscript-comment">// that it will eventually land in the hotfile btree
</span>		<span class="enscript-comment">//
</span>		(<span class="enscript-type">void</span>) hfs_addhotfile(tvp);
	}
	
	*vpp = tvp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* 
	 * Now that we have a vnode-in-hand, generate keys for this namespace item.
	 * If we fail to create the keys, then attempt to delete the item from the 
	 * namespace.  If we can't delete the item, that's not desirable but also not fatal..
	 *  All of the places which deal with restoring/unwrapping keys must also be 
	 * prepared to encounter an entry that does not have keys. 
	 */</span>
	<span class="enscript-keyword">if</span> ((protectable_target) &amp;&amp; (protected_mount)) {
		<span class="enscript-type">struct</span> cprotect *keyed_entry = NULL;

		<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry == NULL) {
			panic (<span class="enscript-string">&quot;hfs_makenode: no cpentry for cnode (%p)&quot;</span>, cp);
		}

		error = cp_generate_keys (hfsmp, cp, CP_CLASS(cp-&gt;c_cpentry-&gt;cp_pclass), keywrap_flags, &amp;keyed_entry);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">/* 
			 * Upon success, the keys were generated and written out. 
			 * Update the cp pointer in the cnode.
			 */</span>
			cp_replace_entry (hfsmp, cp, keyed_entry);
			<span class="enscript-keyword">if</span> (nocache) {
				cache_enter (dvp, tvp, cnp);
			}
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* If key creation OR the setxattr failed, emit EPERM to userland */</span>
			error = EPERM;

			<span class="enscript-comment">/* 
			 * Beware! This slightly violates the lock ordering for the
			 * cnode/vnode 'tvp'.  Ordinarily, you must acquire the truncate lock
			 * which guards file size changes before acquiring the normal cnode lock
			 * and calling hfs_removefile on an item.  
			 * 
			 * However, in this case, we are still holding the directory lock so 
			 * 'tvp' is not lookup-able and it was a newly created vnode so it 
			 * cannot have any content yet. The only reason we are initiating 
			 * the removefile is because we could not generate content protection keys
			 * for this namespace item. Note also that we pass a '1' in the allow_dirs
			 * argument for hfs_removefile because we may be creating a directory here.
			 * 
			 * All this to say that while it is technically a violation it is 
			 * impossible to race with another thread for this cnode so it is safe.
			 */</span>
			<span class="enscript-type">int</span> err = hfs_removefile (dvp, tvp, cnp, 0, 0, 1, NULL, 0); 
			<span class="enscript-keyword">if</span> (err) {
				printf(<span class="enscript-string">&quot;hfs_makenode: removefile failed (%d) for CP entry %p\n&quot;</span>, err, tvp);
			}

			<span class="enscript-comment">/* Release the cnode lock and mark the vnode for termination */</span>	
			hfs_unlock (cp);
			err = vnode_recycle (tvp);
			<span class="enscript-keyword">if</span> (err) {
				printf(<span class="enscript-string">&quot;hfs_makenode: vnode_recycle failed (%d) for CP entry %p\n&quot;</span>, err, tvp);
			}

			<span class="enscript-comment">/* Drop the iocount on the new vnode to force reclamation/recycling */</span>
			vnode_put (tvp);
			cp = NULL;
			*vpp = NULL;
		}	
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-comment">/* 
	 * Once we create this vnode, we need to initialize its quota data 
	 * structures, if necessary.  We know that it is OK to just go ahead and 
	 * initialize because we've already validated earlier (through the hfs_quotacheck 
	 * function) to see if creating this cnode/vnode would cause us to go over quota. 
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS) {
		<span class="enscript-keyword">if</span> (cp) {
			<span class="enscript-comment">/* cp could have been zeroed earlier */</span> 
			(<span class="enscript-type">void</span>) hfs_getinoquota(cp); 
		}
	}
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">exit</span>:
	cat_releasedesc(&amp;out_desc);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/*  
	 * We may have jumped here in error-handling various situations above.
	 * If we haven't already dumped the temporary CP used to initialize
	 * the file atomically, then free it now. cp_entry_destroy should null
	 * out the pointer if it was called already.
	 */</span>
	<span class="enscript-keyword">if</span> (entry) {
		cp_entry_destroy (hfsmp, entry);
		entry = NULL;
	}	
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Make sure we release cnode lock on dcp.
	 */</span>
	<span class="enscript-keyword">if</span> (dcp) {
		dcp-&gt;c_flag &amp;= ~C_DIR_MODIFICATION;
		wakeup((caddr_t)&amp;dcp-&gt;c_flag);
		
		hfs_unlock(dcp);
	}
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; cp != NULL) {
		hfs_unlock(cp);
	}
	<span class="enscript-keyword">if</span> (started_tr) {
	    hfs_end_transaction(hfsmp);
	    started_tr = 0;
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * hfs_vgetrsrc acquires a resource fork vnode corresponding to the
 * cnode that is found in 'vp'.  The cnode should be locked upon entry
 * and will be returned locked, but it may be dropped temporarily.
 *
 * If the resource fork vnode does not exist, HFS will attempt to acquire an
 * empty (uninitialized) vnode from VFS so as to avoid deadlocks with
 * jetsam. If we let the normal getnewvnode code produce the vnode for us
 * we would be doing so while holding the cnode lock of our cnode.
 * 
 * On success, *rvpp wlll hold the resource fork vnode with an
 * iocount.  *Don't* forget the vnode_put.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vgetrsrc</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">struct</span> vnode **rvpp)
{
	<span class="enscript-type">struct</span> vnode *rvp = NULLVP;
	<span class="enscript-type">struct</span> vnode *empty_rvp = NULLVP;
	<span class="enscript-type">struct</span> vnode *dvp = NULLVP;
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> vid;

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VDIR) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
<span class="enscript-reference">restart</span>:
	<span class="enscript-comment">/* Attempt to use existing vnode */</span>
	<span class="enscript-keyword">if</span> ((rvp = cp-&gt;c_rsrc_vp)) {
		vid = vnode_vid(rvp);

		<span class="enscript-comment">// vnode_getwithvid can block so we need to drop the cnode lock
</span>		hfs_unlock(cp);

		error = vnode_getwithvid(rvp, vid);

		hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">/*
		 * When our lock was relinquished, the resource fork
		 * could have been recycled.  Check for this and try
		 * again.
		 */</span>
		<span class="enscript-keyword">if</span> (error == ENOENT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)VTOC(vp)-&gt;c_desc.cd_nameptr;

			<span class="enscript-keyword">if</span> (name)
				printf(<span class="enscript-string">&quot;hfs_vgetrsrc: couldn't get resource&quot;</span>
				       <span class="enscript-string">&quot; fork for %s, vol=%s, err=%d\n&quot;</span>, name, hfsmp-&gt;vcbVN, error);
			<span class="enscript-keyword">return</span> (error);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> cat_fork rsrcfork;
		<span class="enscript-type">struct</span> componentname cn;
		<span class="enscript-type">struct</span> cat_desc *descptr = NULL;
		<span class="enscript-type">struct</span> cat_desc to_desc;
		<span class="enscript-type">char</span> delname[32];
		<span class="enscript-type">int</span> lockflags;
		<span class="enscript-type">int</span> newvnode_flags = 0;

		<span class="enscript-comment">/* 
		 * In this case, we don't currently see a resource fork vnode attached
		 * to this cnode.  In most cases, we were called from a read-only VNOP
		 * like getattr, so it should be safe to drop the cnode lock and then 
		 * re-acquire it.  
		 *
		 * Here, we drop the lock so that we can acquire an empty/husk
		 * vnode so that we don't deadlock against jetsam.  
		 *
		 * It does not currently appear possible to hold the truncate lock via
		 * FS re-entrancy when we get to this point. (8/2014)
		 */</span>
		hfs_unlock (cp);

		error = vnode_create_empty (&amp;empty_rvp); 

		hfs_lock_always (cp, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* If acquiring the 'empty' vnode failed, then nothing to clean up */</span>
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/* 
		 * We could have raced with another thread here while we dropped our cnode
		 * lock.  See if the cnode now has a resource fork vnode and restart if appropriate.
		 *
		 * Note: We just released the cnode lock, so there is a possibility that the
		 * cnode that we just acquired has been deleted or even removed from disk
		 * completely, though this is unlikely. If the file is open-unlinked, the 
		 * check below will resolve it for us.  If it has been completely 
		 * removed (even from the catalog!), then when we examine the catalog 
		 * directly, below, while holding the catalog lock, we will not find the
		 * item and we can fail out properly.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp) {
			<span class="enscript-comment">/* Drop the empty vnode before restarting */</span>
			vnode_put (empty_rvp);
			empty_rvp = NULL;
			rvp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
	
		<span class="enscript-comment">/*
		 * hfs_vgetsrc may be invoked for a cnode that has already been marked
		 * C_DELETED.  This is because we need to continue to provide rsrc
		 * fork access to open-unlinked files.  In this case, build a fake descriptor
		 * like in hfs_removefile.  If we don't do this, buildkey will fail in
		 * cat_lookup because this cnode has no name in its descriptor.
		 */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_DELETED ) &amp;&amp; (cp-&gt;c_desc.cd_namelen == 0)) {
			bzero (&amp;to_desc, <span class="enscript-keyword">sizeof</span>(to_desc));
			bzero (delname, 32);
			MAKE_DELETED_NAME(delname, <span class="enscript-keyword">sizeof</span>(delname), cp-&gt;c_fileid);
			to_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t*) delname;
			to_desc.cd_namelen = strlen(delname);
			to_desc.cd_parentcnid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
			to_desc.cd_flags = 0;
			to_desc.cd_cnid = cp-&gt;c_cnid;

			descptr = &amp;to_desc;
		}
		<span class="enscript-keyword">else</span> {
			descptr = &amp;cp-&gt;c_desc;
		}


		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

		<span class="enscript-comment">/*
		 * We call cat_idlookup (instead of cat_lookup) below because we can't
		 * trust the descriptor in the provided cnode for lookups at this point.  
		 * Between the time of the original lookup of this vnode and now, the 
		 * descriptor could have gotten swapped or replaced.  If this occurred, 
		 * the parent/name combo originally desired may not necessarily be provided
		 * if we use the descriptor.  Even worse, if the vnode represents
		 * a hardlink, we could have removed one of the links from the namespace
		 * but left the descriptor alone, since hfs_unlink does not invalidate
		 * the descriptor in the cnode if other links still point to the inode.
		 * 
		 * Consider the following (slightly contrived) scenario:
		 * /tmp/a &lt;--&gt; /tmp/b (hardlinks).
		 * 1. Thread A: open rsrc fork on /tmp/b.
		 * 1a. Thread A: does lookup, goes out to lunch right before calling getnamedstream.
		 * 2. Thread B does 'mv /foo/b /tmp/b'
		 * 2. Thread B succeeds.
		 * 3. Thread A comes back and wants rsrc fork info for /tmp/b.  
		 * 
		 * Even though the hardlink backing /tmp/b is now eliminated, the descriptor
		 * is not removed/updated during the unlink process.  So, if you were to
		 * do a lookup on /tmp/b, you'd acquire an entirely different record's resource
		 * fork.
		 * 
		 * As a result, we use the fileid, which should be invariant for the lifetime
		 * of the cnode (possibly barring calls to exchangedata).
		 *
		 * Addendum: We can't do the above for HFS standard since we aren't guaranteed to
		 * have thread records for files.  They were only required for directories.  So
		 * we need to do the lookup with the catalog name. This is OK since hardlinks were
		 * never allowed on HFS standard.
		 */</span>

		<span class="enscript-comment">/* Get resource fork data */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
			error = cat_idlookup (hfsmp, cp-&gt;c_fileid, 0, 1, NULL, NULL, &amp;rsrcfork);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * HFS standard only:
			 * 
			 * Get the resource fork for this item with a cat_lookup call, but do not 
			 * force a case lookup since HFS standard is case-insensitive only. We 
			 * don't want the descriptor; just the fork data here. If we tried to
			 * do a ID lookup (via thread record -&gt; catalog record), then we might fail
			 * prematurely since, as noted above, thread records were not strictly required
			 * on files in HFS.
			 */</span>
			error = cat_lookup (hfsmp, descptr, 1, 0, (<span class="enscript-type">struct</span> cat_desc*)NULL, 
					(<span class="enscript-type">struct</span> cat_attr*)NULL, &amp;rsrcfork, NULL);
		}
#<span class="enscript-reference">endif</span>

		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* Drop our 'empty' vnode ! */</span>
			vnode_put (empty_rvp);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-comment">/*
		 * Supply hfs_getnewvnode with a component name. 
		 */</span>
		cn.cn_pnbuf = NULL;
		<span class="enscript-keyword">if</span> (descptr-&gt;cd_nameptr) {
			MALLOC_ZONE(cn.cn_pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
			cn.cn_nameiop = LOOKUP;
			cn.cn_flags = ISLASTCN | HASBUF;
			cn.cn_context = NULL;
			cn.cn_pnlen = MAXPATHLEN;
			cn.cn_nameptr = cn.cn_pnbuf;
			cn.cn_hash = 0;
			cn.cn_consume = 0;
			cn.cn_namelen = snprintf(cn.cn_nameptr, MAXPATHLEN,
						 <span class="enscript-string">&quot;%s%s&quot;</span>, descptr-&gt;cd_nameptr,
						 _PATH_RSRCFORKSPEC);
			<span class="enscript-comment">// Should never happen because cn.cn_nameptr won't ever be long...
</span>			<span class="enscript-keyword">if</span> (cn.cn_namelen &gt;= MAXPATHLEN) {
				FREE_ZONE(cn.cn_pnbuf, cn.cn_pnlen, M_NAMEI);
				<span class="enscript-comment">/* Drop our 'empty' vnode ! */</span>
				vnode_put (empty_rvp);
				<span class="enscript-keyword">return</span> ENAMETOOLONG;
				
			}
		}
		dvp = vnode_getparent(vp);
		
		<span class="enscript-comment">/* 
		 * We are about to call hfs_getnewvnode and pass in the vnode that we acquired
		 * earlier when we were not holding any locks. The semantics of GNV_USE_VP require that
		 * either hfs_getnewvnode consume the vnode and vend it back to us, properly initialized,
		 * or it will consume/dispose of it properly if it errors out.
		 */</span> 
		rvp = empty_rvp;
		
		error = hfs_getnewvnode(hfsmp, dvp, cn.cn_pnbuf ? &amp;cn : NULL,
		                        descptr, (GNV_WANTRSRC | GNV_SKIPLOCK | GNV_USE_VP), 
								&amp;cp-&gt;c_attr, &amp;rsrcfork, &amp;rvp, &amp;newvnode_flags);
			
		<span class="enscript-keyword">if</span> (dvp)
			vnode_put(dvp);
		<span class="enscript-keyword">if</span> (cn.cn_pnbuf)
			FREE_ZONE(cn.cn_pnbuf, cn.cn_pnlen, M_NAMEI);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}  <span class="enscript-comment">/* End 'else' for rsrc fork not existing */</span>

	*rvpp = rvp;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Wrapper for special device reads
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsspec_read</span>(ap)
	<span class="enscript-type">struct</span> vnop_read_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-comment">/*
	 * Set access flag.
	 */</span>
	VTOC(ap-&gt;a_vp)-&gt;c_touch_acctime = TRUE;
	<span class="enscript-keyword">return</span> (VOCALL (spec_vnodeop_p, VOFFSET(vnop_read), ap));
}

<span class="enscript-comment">/*
 * Wrapper for special device writes
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsspec_write</span>(ap)
	<span class="enscript-type">struct</span> vnop_write_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-comment">/*
	 * Set update and change flags.
	 */</span>
	VTOC(ap-&gt;a_vp)-&gt;c_touch_chgtime = TRUE;
	VTOC(ap-&gt;a_vp)-&gt;c_touch_modtime = TRUE;
	<span class="enscript-keyword">return</span> (VOCALL (spec_vnodeop_p, VOFFSET(vnop_write), ap));
}

<span class="enscript-comment">/*
 * Wrapper for special device close
 *
 * Update the times on the cnode then do device close.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfsspec_close</span>(ap)
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		int  a_fflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;

	<span class="enscript-keyword">if</span> (vnode_isinuse(ap-&gt;a_vp, 0)) {
		<span class="enscript-keyword">if</span> (hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) == 0) {
			cp = VTOC(vp);
			hfs_touchtimes(VTOHFS(vp), cp);
			hfs_unlock(cp);
		}
	}
	<span class="enscript-keyword">return</span> (VOCALL (spec_vnodeop_p, VOFFSET(vnop_close), ap));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-comment">/*
 * Wrapper for fifo reads
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsfifo_read</span>(ap)
	<span class="enscript-type">struct</span> vnop_read_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-comment">/*
	 * Set access flag.
	 */</span>
	VTOC(ap-&gt;a_vp)-&gt;c_touch_acctime = TRUE;
	<span class="enscript-keyword">return</span> (VOCALL (fifo_vnodeop_p, VOFFSET(vnop_read), ap));
}

<span class="enscript-comment">/*
 * Wrapper for fifo writes
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsfifo_write</span>(ap)
	<span class="enscript-type">struct</span> vnop_write_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-comment">/*
	 * Set update and change flags.
	 */</span>
	VTOC(ap-&gt;a_vp)-&gt;c_touch_chgtime = TRUE;
	VTOC(ap-&gt;a_vp)-&gt;c_touch_modtime = TRUE;
	<span class="enscript-keyword">return</span> (VOCALL (fifo_vnodeop_p, VOFFSET(vnop_write), ap));
}

<span class="enscript-comment">/*
 * Wrapper for fifo close
 *
 * Update the times on the cnode then do device close.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfsfifo_close</span>(ap)
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		int  a_fflag;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;

	<span class="enscript-keyword">if</span> (vnode_isinuse(ap-&gt;a_vp, 1)) {
		<span class="enscript-keyword">if</span> (hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) == 0) {
			cp = VTOC(vp);
			hfs_touchtimes(VTOHFS(vp), cp);
			hfs_unlock(cp);
		}
	}
	<span class="enscript-keyword">return</span> (VOCALL (fifo_vnodeop_p, VOFFSET(vnop_close), ap));
}


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>

<span class="enscript-comment">/* 
 * Getter for the document_id 
 * the document_id is stored in FndrExtendedFileInfo/FndrExtendedDirInfo
 */</span>
<span class="enscript-type">static</span> u_int32_t 
<span class="enscript-function-name">hfs_get_document_id_internal</span>(<span class="enscript-type">const</span> uint8_t *finderinfo, mode_t mode)
{
	<span class="enscript-type">const</span> uint8_t *finfo = NULL;
	u_int32_t doc_id = 0;
	
	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = finderinfo + 16;

	<span class="enscript-keyword">if</span> (S_ISDIR(mode) || S_ISREG(mode)) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		doc_id = extinfo-&gt;document_id;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (S_ISDIR(mode)) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedDirInfo *extinfo = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedDirInfo *)finfo;
		doc_id = extinfo-&gt;document_id;
	}	

	<span class="enscript-keyword">return</span> doc_id;
}


<span class="enscript-comment">/* getter(s) for document id */</span>
u_int32_t
<span class="enscript-function-name">hfs_get_document_id</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-keyword">return</span> (hfs_get_document_id_internal((u_int8_t*)cp-&gt;c_finderinfo,
	    cp-&gt;c_attr.ca_mode));
}

<span class="enscript-comment">/* If you have finderinfo and mode, you can use this */</span>
u_int32_t
<span class="enscript-function-name">hfs_get_document_id_from_blob</span>(<span class="enscript-type">const</span> uint8_t *finderinfo, mode_t mode)
{
	<span class="enscript-keyword">return</span> (hfs_get_document_id_internal(finderinfo, mode));
}

<span class="enscript-comment">/*
 * Synchronize a file's in-core state with that on disk.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_fsync</span>(ap)
	<span class="enscript-type">struct</span> vnop_fsync_args <span class="enscript-comment">/* {
		struct vnode *a_vp;
		int a_waitfor;
		vfs_context_t a_context;
	} */</span> *ap;
{
	<span class="enscript-type">struct</span> vnode* vp = ap-&gt;a_vp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* Note: We check hfs flags instead of vfs mount flag because during 
	 * read-write update, hfs marks itself read-write much earlier than
	 * the vfs, and hence won't result in skipping of certain writes like 
	 * zero'ing out of unused nodes, creation of hotfiles btree, etc. 
	 */</span>
	<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		<span class="enscript-keyword">return</span> 0;		
	}

	<span class="enscript-comment">/*
	 * No need to call cp_handle_vnop to resolve fsync().  Any dirty data
	 * should have caused the keys to be unwrapped at the time the data was
	 * put into the UBC, either at mmap/pagein/read-write.  If we did manage
	 * to let this by, then strategy will auto-resolve for us.
	 * 
	 * We also need to allow ENOENT lock errors since unlink
	 * system call can call VNOP_FSYNC during vclean.
	 */</span>
	error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (0);

	error = hfs_fsync(vp, ap-&gt;a_waitfor, 0, vfs_context_proc(ap-&gt;a_context));

	hfs_unlock(VTOC(vp));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">int</span> (**hfs_vnodeop_p)(<span class="enscript-type">void</span> *);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VOPFUNC</span> int (*)(void *)


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-function-name">int</span> (**hfs_std_vnodeop_p) (<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_readonly_op</span> (__unused <span class="enscript-type">void</span>* ap) { <span class="enscript-keyword">return</span> (EROFS); }

<span class="enscript-comment">/* 
 * In 10.6 and forward, HFS Standard is read-only and deprecated.  The vnop table below
 * is for use with HFS standard to block out operations that would modify the file system
 */</span>

<span class="enscript-type">struct</span> vnodeopv_entry_desc hfs_standard_vnodeop_entries[] = {
    { &amp;vnop_default_desc, (VOPFUNC)vn_default_error },
    { &amp;vnop_lookup_desc, (VOPFUNC)hfs_vnop_lookup },		<span class="enscript-comment">/* lookup */</span>
    { &amp;vnop_create_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* create (READONLY) */</span>
    { &amp;vnop_mknod_desc, (VOPFUNC)hfs_readonly_op },             <span class="enscript-comment">/* mknod (READONLY) */</span>
    { &amp;vnop_open_desc, (VOPFUNC)hfs_vnop_open },			<span class="enscript-comment">/* open */</span>
    { &amp;vnop_close_desc, (VOPFUNC)hfs_vnop_close },		<span class="enscript-comment">/* close */</span>
    { &amp;vnop_getattr_desc, (VOPFUNC)hfs_vnop_getattr },		<span class="enscript-comment">/* getattr */</span>
    { &amp;vnop_setattr_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* setattr */</span>
    { &amp;vnop_read_desc, (VOPFUNC)hfs_vnop_read },			<span class="enscript-comment">/* read */</span>
    { &amp;vnop_write_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* write (READONLY) */</span>
    { &amp;vnop_ioctl_desc, (VOPFUNC)hfs_vnop_ioctl },		<span class="enscript-comment">/* ioctl */</span>
    { &amp;vnop_select_desc, (VOPFUNC)hfs_vnop_select },		<span class="enscript-comment">/* select */</span>
    { &amp;vnop_revoke_desc, (VOPFUNC)nop_revoke },			<span class="enscript-comment">/* revoke */</span>
    { &amp;vnop_exchange_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* exchange  (READONLY)*/</span>
    { &amp;vnop_mmap_desc, (VOPFUNC)err_mmap },			<span class="enscript-comment">/* mmap */</span>
    { &amp;vnop_fsync_desc, (VOPFUNC)hfs_readonly_op},		<span class="enscript-comment">/* fsync (READONLY) */</span>
    { &amp;vnop_remove_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* remove (READONLY) */</span>
    { &amp;vnop_link_desc, (VOPFUNC)hfs_readonly_op },			<span class="enscript-comment">/* link ( READONLLY) */</span>
    { &amp;vnop_rename_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* rename (READONLY)*/</span>
    { &amp;vnop_mkdir_desc, (VOPFUNC)hfs_readonly_op },             <span class="enscript-comment">/* mkdir (READONLY) */</span>
    { &amp;vnop_rmdir_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* rmdir (READONLY) */</span>
    { &amp;vnop_symlink_desc, (VOPFUNC)hfs_readonly_op },         <span class="enscript-comment">/* symlink (READONLY) */</span>
    { &amp;vnop_readdir_desc, (VOPFUNC)hfs_vnop_readdir },		<span class="enscript-comment">/* readdir */</span>
    { &amp;vnop_readdirattr_desc, (VOPFUNC)hfs_vnop_readdirattr },	<span class="enscript-comment">/* readdirattr */</span>
    { &amp;vnop_readlink_desc, (VOPFUNC)hfs_vnop_readlink },		<span class="enscript-comment">/* readlink */</span>
    { &amp;vnop_inactive_desc, (VOPFUNC)hfs_vnop_inactive },		<span class="enscript-comment">/* inactive */</span>
    { &amp;vnop_reclaim_desc, (VOPFUNC)hfs_vnop_reclaim },		<span class="enscript-comment">/* reclaim */</span>
    { &amp;vnop_strategy_desc, (VOPFUNC)hfs_vnop_strategy },		<span class="enscript-comment">/* strategy */</span>
    { &amp;vnop_pathconf_desc, (VOPFUNC)hfs_vnop_pathconf },		<span class="enscript-comment">/* pathconf */</span>
    { &amp;vnop_advlock_desc, (VOPFUNC)err_advlock },		<span class="enscript-comment">/* advlock */</span>
    { &amp;vnop_allocate_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* allocate (READONLY) */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SEARCHFS</span>
    { &amp;vnop_searchfs_desc, (VOPFUNC)hfs_vnop_search },		<span class="enscript-comment">/* search fs */</span>
#<span class="enscript-reference">else</span>
    { &amp;vnop_searchfs_desc, (VOPFUNC)err_searchfs },		<span class="enscript-comment">/* search fs */</span>
#<span class="enscript-reference">endif</span>
    { &amp;vnop_bwrite_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* bwrite (READONLY) */</span>
    { &amp;vnop_pagein_desc, (VOPFUNC)hfs_vnop_pagein },		<span class="enscript-comment">/* pagein */</span>
    { &amp;vnop_pageout_desc,(VOPFUNC) hfs_readonly_op },		<span class="enscript-comment">/* pageout (READONLY)  */</span>
    { &amp;vnop_copyfile_desc, (VOPFUNC)hfs_readonly_op },		<span class="enscript-comment">/* copyfile (READONLY)*/</span>
    { &amp;vnop_blktooff_desc, (VOPFUNC)hfs_vnop_blktooff },		<span class="enscript-comment">/* blktooff */</span>
    { &amp;vnop_offtoblk_desc, (VOPFUNC)hfs_vnop_offtoblk },		<span class="enscript-comment">/* offtoblk */</span>
    { &amp;vnop_blockmap_desc, (VOPFUNC)hfs_vnop_blockmap },			<span class="enscript-comment">/* blockmap */</span>
    { &amp;vnop_getxattr_desc, (VOPFUNC)hfs_vnop_getxattr},
    { &amp;vnop_setxattr_desc, (VOPFUNC)hfs_readonly_op},         <span class="enscript-comment">/* set xattr (READONLY) */</span>
    { &amp;vnop_removexattr_desc, (VOPFUNC)hfs_readonly_op},      <span class="enscript-comment">/* remove xattr (READONLY) */</span>
    { &amp;vnop_listxattr_desc, (VOPFUNC)hfs_vnop_listxattr},
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
    { &amp;vnop_getnamedstream_desc, (VOPFUNC)hfs_vnop_getnamedstream },
    { &amp;vnop_makenamedstream_desc, (VOPFUNC)hfs_readonly_op }, 
    { &amp;vnop_removenamedstream_desc, (VOPFUNC)hfs_readonly_op },
#<span class="enscript-reference">endif</span>
    { &amp;vnop_getattrlistbulk_desc, (VOPFUNC)hfs_vnop_getattrlistbulk },	<span class="enscript-comment">/* getattrlistbulk */</span>
    { NULL, (VOPFUNC)NULL }
};

<span class="enscript-type">struct</span> vnodeopv_desc hfs_std_vnodeop_opv_desc =
{ &amp;hfs_std_vnodeop_p, hfs_standard_vnodeop_entries };
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* VNOP table for HFS+ */</span>
<span class="enscript-type">struct</span> vnodeopv_entry_desc hfs_vnodeop_entries[] = {
    { &amp;vnop_default_desc, (VOPFUNC)vn_default_error },
    { &amp;vnop_lookup_desc, (VOPFUNC)hfs_vnop_lookup },		<span class="enscript-comment">/* lookup */</span>
    { &amp;vnop_create_desc, (VOPFUNC)hfs_vnop_create },		<span class="enscript-comment">/* create */</span>
    { &amp;vnop_mknod_desc, (VOPFUNC)hfs_vnop_mknod },             <span class="enscript-comment">/* mknod */</span>
    { &amp;vnop_open_desc, (VOPFUNC)hfs_vnop_open },			<span class="enscript-comment">/* open */</span>
    { &amp;vnop_close_desc, (VOPFUNC)hfs_vnop_close },		<span class="enscript-comment">/* close */</span>
    { &amp;vnop_getattr_desc, (VOPFUNC)hfs_vnop_getattr },		<span class="enscript-comment">/* getattr */</span>
    { &amp;vnop_setattr_desc, (VOPFUNC)hfs_vnop_setattr },		<span class="enscript-comment">/* setattr */</span>
    { &amp;vnop_read_desc, (VOPFUNC)hfs_vnop_read },			<span class="enscript-comment">/* read */</span>
    { &amp;vnop_write_desc, (VOPFUNC)hfs_vnop_write },		<span class="enscript-comment">/* write */</span>
    { &amp;vnop_ioctl_desc, (VOPFUNC)hfs_vnop_ioctl },		<span class="enscript-comment">/* ioctl */</span>
    { &amp;vnop_select_desc, (VOPFUNC)hfs_vnop_select },		<span class="enscript-comment">/* select */</span>
    { &amp;vnop_revoke_desc, (VOPFUNC)nop_revoke },			<span class="enscript-comment">/* revoke */</span>
    { &amp;vnop_exchange_desc, (VOPFUNC)hfs_vnop_exchange },		<span class="enscript-comment">/* exchange */</span>
    { &amp;vnop_mmap_desc, (VOPFUNC)hfs_vnop_mmap },			<span class="enscript-comment">/* mmap */</span>
    { &amp;vnop_fsync_desc, (VOPFUNC)hfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
    { &amp;vnop_remove_desc, (VOPFUNC)hfs_vnop_remove },		<span class="enscript-comment">/* remove */</span>
    { &amp;vnop_link_desc, (VOPFUNC)hfs_vnop_link },			<span class="enscript-comment">/* link */</span>
    { &amp;vnop_rename_desc, (VOPFUNC)hfs_vnop_rename },		<span class="enscript-comment">/* rename */</span>
    { &amp;vnop_mkdir_desc, (VOPFUNC)hfs_vnop_mkdir },             <span class="enscript-comment">/* mkdir */</span>
    { &amp;vnop_rmdir_desc, (VOPFUNC)hfs_vnop_rmdir },		<span class="enscript-comment">/* rmdir */</span>
    { &amp;vnop_symlink_desc, (VOPFUNC)hfs_vnop_symlink },         <span class="enscript-comment">/* symlink */</span>
    { &amp;vnop_readdir_desc, (VOPFUNC)hfs_vnop_readdir },		<span class="enscript-comment">/* readdir */</span>
    { &amp;vnop_readdirattr_desc, (VOPFUNC)hfs_vnop_readdirattr },	<span class="enscript-comment">/* readdirattr */</span>
    { &amp;vnop_readlink_desc, (VOPFUNC)hfs_vnop_readlink },		<span class="enscript-comment">/* readlink */</span>
    { &amp;vnop_inactive_desc, (VOPFUNC)hfs_vnop_inactive },		<span class="enscript-comment">/* inactive */</span>
    { &amp;vnop_reclaim_desc, (VOPFUNC)hfs_vnop_reclaim },		<span class="enscript-comment">/* reclaim */</span>
    { &amp;vnop_strategy_desc, (VOPFUNC)hfs_vnop_strategy },		<span class="enscript-comment">/* strategy */</span>
    { &amp;vnop_pathconf_desc, (VOPFUNC)hfs_vnop_pathconf },		<span class="enscript-comment">/* pathconf */</span>
    { &amp;vnop_advlock_desc, (VOPFUNC)err_advlock },		<span class="enscript-comment">/* advlock */</span>
    { &amp;vnop_allocate_desc, (VOPFUNC)hfs_vnop_allocate },		<span class="enscript-comment">/* allocate */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_SEARCHFS</span>
    { &amp;vnop_searchfs_desc, (VOPFUNC)hfs_vnop_search },		<span class="enscript-comment">/* search fs */</span>
#<span class="enscript-reference">else</span>
    { &amp;vnop_searchfs_desc, (VOPFUNC)err_searchfs },		<span class="enscript-comment">/* search fs */</span>
#<span class="enscript-reference">endif</span>
    { &amp;vnop_bwrite_desc, (VOPFUNC)hfs_vnop_bwrite },		<span class="enscript-comment">/* bwrite */</span>
    { &amp;vnop_pagein_desc, (VOPFUNC)hfs_vnop_pagein },		<span class="enscript-comment">/* pagein */</span>
    { &amp;vnop_pageout_desc,(VOPFUNC) hfs_vnop_pageout },		<span class="enscript-comment">/* pageout */</span>
    { &amp;vnop_copyfile_desc, (VOPFUNC)err_copyfile },		<span class="enscript-comment">/* copyfile */</span>
    { &amp;vnop_blktooff_desc, (VOPFUNC)hfs_vnop_blktooff },		<span class="enscript-comment">/* blktooff */</span>
    { &amp;vnop_offtoblk_desc, (VOPFUNC)hfs_vnop_offtoblk },		<span class="enscript-comment">/* offtoblk */</span>
    { &amp;vnop_blockmap_desc, (VOPFUNC)hfs_vnop_blockmap },			<span class="enscript-comment">/* blockmap */</span>
    { &amp;vnop_getxattr_desc, (VOPFUNC)hfs_vnop_getxattr},
    { &amp;vnop_setxattr_desc, (VOPFUNC)hfs_vnop_setxattr},
    { &amp;vnop_removexattr_desc, (VOPFUNC)hfs_vnop_removexattr},
    { &amp;vnop_listxattr_desc, (VOPFUNC)hfs_vnop_listxattr},
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
    { &amp;vnop_getnamedstream_desc, (VOPFUNC)hfs_vnop_getnamedstream },
    { &amp;vnop_makenamedstream_desc, (VOPFUNC)hfs_vnop_makenamedstream },
    { &amp;vnop_removenamedstream_desc, (VOPFUNC)hfs_vnop_removenamedstream },
#<span class="enscript-reference">endif</span>
    { &amp;vnop_getattrlistbulk_desc, (VOPFUNC)hfs_vnop_getattrlistbulk },	<span class="enscript-comment">/* getattrlistbulk */</span>
	{ &amp;vnop_mnomap_desc, (VOPFUNC)hfs_vnop_mnomap },
    { NULL, (VOPFUNC)NULL }
};

<span class="enscript-type">struct</span> vnodeopv_desc hfs_vnodeop_opv_desc =
{ &amp;hfs_vnodeop_p, hfs_vnodeop_entries };


<span class="enscript-comment">/* Spec Op vnop table for HFS+ */</span>
<span class="enscript-function-name">int</span> (**hfs_specop_p)(<span class="enscript-type">void</span> *);
<span class="enscript-type">struct</span> vnodeopv_entry_desc hfs_specop_entries[] = {
	{ &amp;vnop_default_desc, (VOPFUNC)vn_default_error },
	{ &amp;vnop_lookup_desc, (VOPFUNC)spec_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (VOPFUNC)spec_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (VOPFUNC)spec_mknod },              <span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (VOPFUNC)spec_open },			<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (VOPFUNC)hfsspec_close },		<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (VOPFUNC)hfs_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (VOPFUNC)hfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (VOPFUNC)hfsspec_read },		<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (VOPFUNC)hfsspec_write },		<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (VOPFUNC)spec_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (VOPFUNC)spec_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (VOPFUNC)spec_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (VOPFUNC)spec_mmap },			<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (VOPFUNC)hfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (VOPFUNC)spec_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (VOPFUNC)spec_link },			<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (VOPFUNC)spec_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (VOPFUNC)spec_mkdir },              <span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (VOPFUNC)spec_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (VOPFUNC)spec_symlink },          <span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (VOPFUNC)spec_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (VOPFUNC)spec_readlink },		<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (VOPFUNC)hfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (VOPFUNC)hfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (VOPFUNC)spec_strategy },		<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (VOPFUNC)spec_pathconf },		<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (VOPFUNC)err_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (VOPFUNC)hfs_vnop_bwrite },
	{ &amp;vnop_pagein_desc, (VOPFUNC)hfs_vnop_pagein },		<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (VOPFUNC)hfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
    { &amp;vnop_copyfile_desc, (VOPFUNC)err_copyfile },		<span class="enscript-comment">/* copyfile */</span>
	{ &amp;vnop_blktooff_desc, (VOPFUNC)hfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (VOPFUNC)hfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_getxattr_desc, (VOPFUNC)hfs_vnop_getxattr},
	{ &amp;vnop_setxattr_desc, (VOPFUNC)hfs_vnop_setxattr},
	{ &amp;vnop_removexattr_desc, (VOPFUNC)hfs_vnop_removexattr},
	{ &amp;vnop_listxattr_desc, (VOPFUNC)hfs_vnop_listxattr},
	{ (<span class="enscript-type">struct</span> vnodeop_desc*)NULL, (VOPFUNC)NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc hfs_specop_opv_desc =
	{ &amp;hfs_specop_p, hfs_specop_entries };

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-comment">/* HFS+ FIFO VNOP table  */</span>
<span class="enscript-function-name">int</span> (**hfs_fifoop_p)(<span class="enscript-type">void</span> *);
<span class="enscript-type">struct</span> vnodeopv_entry_desc hfs_fifoop_entries[] = {
	{ &amp;vnop_default_desc, (VOPFUNC)vn_default_error },
	{ &amp;vnop_lookup_desc, (VOPFUNC)fifo_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (VOPFUNC)fifo_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (VOPFUNC)fifo_mknod },              <span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (VOPFUNC)fifo_open },			<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (VOPFUNC)hfsfifo_close },		<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (VOPFUNC)hfs_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (VOPFUNC)hfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (VOPFUNC)hfsfifo_read },		<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (VOPFUNC)hfsfifo_write },		<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (VOPFUNC)fifo_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (VOPFUNC)fifo_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (VOPFUNC)fifo_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (VOPFUNC)fifo_mmap },			<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (VOPFUNC)hfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (VOPFUNC)fifo_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (VOPFUNC)fifo_link },			<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (VOPFUNC)fifo_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (VOPFUNC)fifo_mkdir },              <span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (VOPFUNC)fifo_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (VOPFUNC)fifo_symlink },          <span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (VOPFUNC)fifo_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (VOPFUNC)fifo_readlink },		<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (VOPFUNC)hfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (VOPFUNC)hfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (VOPFUNC)fifo_strategy },		<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (VOPFUNC)fifo_pathconf },		<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (VOPFUNC)err_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (VOPFUNC)hfs_vnop_bwrite },
	{ &amp;vnop_pagein_desc, (VOPFUNC)hfs_vnop_pagein },		<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (VOPFUNC)hfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_copyfile_desc, (VOPFUNC)err_copyfile }, 		<span class="enscript-comment">/* copyfile */</span>
	{ &amp;vnop_blktooff_desc, (VOPFUNC)hfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (VOPFUNC)hfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
  	{ &amp;vnop_blockmap_desc, (VOPFUNC)hfs_vnop_blockmap },		<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_getxattr_desc, (VOPFUNC)hfs_vnop_getxattr},
	{ &amp;vnop_setxattr_desc, (VOPFUNC)hfs_vnop_setxattr},
	{ &amp;vnop_removexattr_desc, (VOPFUNC)hfs_vnop_removexattr},
	{ &amp;vnop_listxattr_desc, (VOPFUNC)hfs_vnop_listxattr},
	{ (<span class="enscript-type">struct</span> vnodeop_desc*)NULL, (VOPFUNC)NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc hfs_fifoop_opv_desc =
	{ &amp;hfs_fifoop_p, hfs_fifoop_entries };
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>



</pre>
<hr />
</body></html>