<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_cnode.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_cnode.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_HFS_CNODE_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_HFS_CNODE_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_catalog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/rangelist.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/decmpfs.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

<span class="enscript-comment">/*
 * The filefork is used to represent an HFS file fork (data or resource).
 * Reading or writing any of these fields requires holding cnode lock.
 */</span>
<span class="enscript-type">struct</span> filefork {
	<span class="enscript-type">struct</span> cnode   *ff_cp;               <span class="enscript-comment">/* cnode associated with this fork */</span>
	<span class="enscript-type">struct</span> rl_head  ff_invalidranges;    <span class="enscript-comment">/* Areas of disk that should read back as zeroes */</span>
	<span class="enscript-type">union</span> {
	   <span class="enscript-type">void</span>        *ffu_sysfileinfo;     <span class="enscript-comment">/* additional info for system files */</span>
	   <span class="enscript-type">char</span>        *ffu_symlinkptr;      <span class="enscript-comment">/* symbolic link pathname */</span>
	} ff_union;
	<span class="enscript-type">struct</span> cat_fork ff_data;             <span class="enscript-comment">/* fork data (size, extents) */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> filefork filefork_t;


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_TEMPLOOKUP_NAMELEN</span> 32

<span class="enscript-comment">/*
 * Catalog Lookup struct (runtime)
 *
 * This is used so that when we need to malloc a container for a catalog
 * lookup operation, we can acquire memory for everything in one fell swoop
 * as opposed to putting many of these objects on the stack.  The cat_fork
 * data structure can take up 100+bytes easily, and that can add to stack
 * overhead.  
 *
 * As a result, we use this to easily pass around the memory needed for a
 * lookup operation.
 */</span>
<span class="enscript-type">struct</span> cat_lookup_buffer {
	<span class="enscript-type">struct</span> cat_desc lookup_desc;
	<span class="enscript-type">struct</span> cat_attr lookup_attr;
	<span class="enscript-type">struct</span> filefork lookup_fork;
	<span class="enscript-type">struct</span> componentname lookup_cn;
	<span class="enscript-type">char</span> lookup_name[HFS_TEMPLOOKUP_NAMELEN]; <span class="enscript-comment">/* for open-unlinked paths only */</span>
};


<span class="enscript-comment">/* Aliases for common fields */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_size</span>          ff_data.cf_size
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_new_size</span>      ff_data.cf_new_size
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_clumpsize</span>     ff_data.cf_clump
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_bytesread</span>     ff_data.cf_bytesread
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_extents</span>       ff_data.cf_extents

<span class="enscript-comment">/*
 * Note that the blocks fields are protected by the cnode lock, *not*
 * the truncate lock.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_blocks</span>        ff_data.cf_blocks
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_unallocblocks</span> ff_data.cf_vblocks
<span class="enscript-type">static</span> inline uint32_t <span class="enscript-function-name">ff_allocblocks</span>(filefork_t *ff)
{
	assert(ff-&gt;ff_blocks &gt;= ff-&gt;ff_unallocblocks);
	<span class="enscript-keyword">return</span> ff-&gt;ff_blocks - ff-&gt;ff_unallocblocks;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_symlinkptr</span>    ff_union.ffu_symlinkptr
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ff_sysfileinfo</span>   ff_union.ffu_sysfileinfo


<span class="enscript-comment">/* The btree code still needs these... */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fcbEOF</span>           ff_size
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fcbExtents</span>       ff_extents
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">fcbBTCBPtr</span>       ff_sysfileinfo

<span class="enscript-type">typedef</span> u_int8_t atomicflag_t;


<span class="enscript-comment">/*
 * Hardlink Origin (for hardlinked directories).
 */</span>
<span class="enscript-type">struct</span> linkorigin {
	TAILQ_ENTRY(linkorigin)  lo_link;  <span class="enscript-comment">/* chain */</span>
	<span class="enscript-type">void</span> *  lo_thread;      <span class="enscript-comment">/* thread that performed the lookup */</span>
	cnid_t  lo_cnid;        <span class="enscript-comment">/* hardlink's cnid */</span>
	cnid_t  lo_parentcnid;  <span class="enscript-comment">/* hardlink's parent cnid */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> linkorigin linkorigin_t;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CACHED_ORIGINS</span>  10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CACHED_FILE_ORIGINS</span> 8

<span class="enscript-comment">/*
 * The cnode is used to represent each active (or recently active)
 * file or directory in the HFS filesystem.
 *
 * Reading or writing any of these fields requires holding c_lock.
 */</span>
<span class="enscript-type">struct</span> cnode {
	lck_rw_t                c_rwlock;       <span class="enscript-comment">/* cnode's lock */</span>
	thread_t                c_lockowner;    <span class="enscript-comment">/* cnode's lock owner (exclusive case only) */</span>
	lck_rw_t                c_truncatelock; <span class="enscript-comment">/* protects file from truncation during read/write */</span>
	thread_t                c_truncatelockowner;    <span class="enscript-comment">/* truncate lock owner (exclusive case only) */</span>
	LIST_ENTRY(cnode)	c_hash;		<span class="enscript-comment">/* cnode's hash chain */</span>
	u_int32_t		c_flag;		<span class="enscript-comment">/* cnode's runtime flags */</span>
	u_int32_t		c_hflag;	<span class="enscript-comment">/* cnode's flags for maintaining hash - protected by global hash lock */</span>
	<span class="enscript-type">struct</span> vnode		*c_vp;		<span class="enscript-comment">/* vnode for data fork or dir */</span>
	<span class="enscript-type">struct</span> vnode		*c_rsrc_vp;	<span class="enscript-comment">/* vnode for resource fork */</span>
    <span class="enscript-type">struct</span> dquot		*c_dquot[MAXQUOTAS]; <span class="enscript-comment">/* cnode's quota info */</span>
	u_int32_t		c_childhint;	 <span class="enscript-comment">/* catalog hint for children (small dirs only) */</span>
	u_int32_t		c_dirthreadhint; <span class="enscript-comment">/* catalog hint for directory's thread rec */</span>
	<span class="enscript-type">struct</span> cat_desc		c_desc;		<span class="enscript-comment">/* cnode's descriptor */</span>
	<span class="enscript-type">struct</span> cat_attr		c_attr;		<span class="enscript-comment">/* cnode's attributes */</span>
	TAILQ_HEAD(hfs_originhead, linkorigin) c_originlist;  <span class="enscript-comment">/* hardlink origin cache */</span>
	TAILQ_HEAD(hfs_hinthead, directoryhint) c_hintlist;  <span class="enscript-comment">/* readdir directory hint list */</span>
  	int16_t			c_dirhinttag;	<span class="enscript-comment">/* directory hint tag */</span>
	<span class="enscript-type">union</span> {
	    int16_t     cu_dirhintcnt;          <span class="enscript-comment">/* directory hint count */</span>
	    int16_t     cu_syslockcount;        <span class="enscript-comment">/* system file use only */</span>
	} c_union;
	u_int32_t		c_dirchangecnt; <span class="enscript-comment">/* changes each insert/delete (in-core only) */</span>
 	<span class="enscript-type">struct</span> filefork		*c_datafork;	<span class="enscript-comment">/* cnode's data fork */</span>
	<span class="enscript-type">struct</span> filefork		*c_rsrcfork;	<span class="enscript-comment">/* cnode's rsrc fork */</span>
	atomicflag_t	c_touch_acctime;
	atomicflag_t	c_touch_chgtime;
	atomicflag_t	c_touch_modtime;

	<span class="enscript-comment">// The following flags are protected by the truncate lock
</span>	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			bool	c_need_dvnode_put_after_truncate_unlock : 1;
			bool	c_need_rvnode_put_after_truncate_unlock : 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
			bool	c_need_decmpfs_reset 					: 1;
#<span class="enscript-reference">endif</span>
		};
		uint8_t c_tflags;
	};

	<span class="enscript-comment">/*
	 * Where we're using a journal, we keep track of the last
	 * transaction that we did an update in.  If a minor modification
	 * is made, we'll still push it if we're still on the same
	 * transaction.
	 */</span>
	uint32_t c_update_txn;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	decmpfs_cnode  *c_decmp;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	cprotect_t		c_cpentry;	<span class="enscript-comment">/* content protection data */</span>
#<span class="enscript-reference">endif</span>
	
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cnode cnode_t;

<span class="enscript-comment">/* Aliases for common cnode fields */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_cnid</span>		c_desc.cd_cnid
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_hint</span>		c_desc.cd_hint
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_parentcnid</span>	c_desc.cd_parentcnid
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_encoding</span>	c_desc.cd_encoding

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_fileid</span>	c_attr.ca_fileid
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_mode</span>		c_attr.ca_mode
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_linkcount</span>	c_attr.ca_linkcount
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_uid</span>		c_attr.ca_uid
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_gid</span>		c_attr.ca_gid
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_rdev</span>		c_attr.ca_union1.cau_rdev
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_atime</span>		c_attr.ca_atime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_mtime</span>		c_attr.ca_mtime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_ctime</span>		c_attr.ca_ctime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_itime</span>		c_attr.ca_itime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_btime</span>		c_attr.ca_btime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_bsdflags</span>		c_attr.ca_flags
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_finderinfo</span>	c_attr.ca_finderinfo
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_blocks</span>	c_attr.ca_union2.cau_blocks
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_entries</span>	c_attr.ca_union2.cau_entries
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_zftimeout</span>	c_childhint

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_dirhintcnt</span>    c_union.cu_dirhintcnt
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">c_syslockcount</span>  c_union.cu_syslockcount


<span class="enscript-comment">/* hash maintenance flags kept in c_hflag and protected by hfs_chash_mutex */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">H_ALLOC</span>		0x00001	<span class="enscript-comment">/* CNode is being allocated */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">H_ATTACH</span>	0x00002	<span class="enscript-comment">/* CNode is being attached to by another vnode */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">H_TRANSIT</span>	0x00004	<span class="enscript-comment">/* CNode is getting recycled  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">H_WAITING</span>	0x00008	<span class="enscript-comment">/* CNode is being waited for */</span>


<span class="enscript-comment">/* 
 * Runtime cnode flags (kept in c_flag) 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEED_RVNODE_PUT</span>   0x0000001  <span class="enscript-comment">/* Need to do a vnode_put on c_rsrc_vp after the unlock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEED_DVNODE_PUT</span>   0x0000002  <span class="enscript-comment">/* Need to do a vnode_put on c_vp after the unlock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_ZFWANTSYNC</span>	    0x0000004  <span class="enscript-comment">/* fsync requested and file has holes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_FROMSYNC</span>          0x0000008  <span class="enscript-comment">/* fsync was called from sync */</span> 

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_MODIFIED</span>          0x0000010  <span class="enscript-comment">/* CNode has been modified */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NOEXISTS</span>          0x0000020  <span class="enscript-comment">/* CNode has been deleted, catalog entry is gone */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_DELETED</span>           0x0000040  <span class="enscript-comment">/* CNode has been marked to be deleted */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_HARDLINK</span>          0x0000080  <span class="enscript-comment">/* CNode is a hard link (file or dir) */</span>

<span class="enscript-comment">/*
 * A minor modification is one where the volume would not be inconsistent if
 * the change was not pushed to disk.  For example, changes to times.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_MINOR_MOD</span>			0x0000100  <span class="enscript-comment">/* CNode has a minor modification */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_HASXATTRS</span>         0x0000200  <span class="enscript-comment">/* cnode has extended attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEG_ENTRIES</span>       0x0000400  <span class="enscript-comment">/* directory has negative name entries */</span>
<span class="enscript-comment">/* 
 * For C_SSD_STATIC: SSDs may want to deal with the file payload data in a 
 * different manner knowing that the content is not likely to be modified. This is
 * purely advisory at the HFS level, and is not maintained after the cnode goes out of core.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SSD_STATIC</span>        0x0000800  <span class="enscript-comment">/* Assume future writes contain static content */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEED_DATA_SETSIZE</span> 0x0001000  <span class="enscript-comment">/* Do a ubc_setsize(0) on c_rsrc_vp after the unlock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEED_RSRC_SETSIZE</span> 0x0002000  <span class="enscript-comment">/* Do a ubc_setsize(0) on c_vp after the unlock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_DIR_MODIFICATION</span>  0x0004000  <span class="enscript-comment">/* Directory is being modified, wait for lookups */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_ALWAYS_ZEROFILL</span>   0x0008000  <span class="enscript-comment">/* Always zero-fill the file on an fsync */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_RENAMED</span>           0x0010000  <span class="enscript-comment">/* cnode was deleted as part of rename; C_DELETED should also be set */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_NEEDS_DATEADDED</span>   0x0020000  <span class="enscript-comment">/* cnode needs date-added written to the finderinfo bit */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_BACKINGSTORE</span>      0x0040000  <span class="enscript-comment">/* cnode is a backing store for an existing or currently-mounting filesystem */</span>

<span class="enscript-comment">/*
 * This flag indicates the cnode might be dirty because it
 * was mapped writable so if we get any page-outs, update
 * the modification and change times.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_MIGHT_BE_DIRTY_FROM_MAPPING</span>   0x0080000

<span class="enscript-comment">/* 
 * For C_SSD_GREEDY_MODE: SSDs may want to write the file payload data using the greedy mode knowing
 * that the content needs to be written out to the disk quicker than normal at the expense of storage efficiency.
 * This is purely advisory at the HFS level, and is not maintained after the cnode goes out of core.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_SSD_GREEDY_MODE</span>   0x0100000  <span class="enscript-comment">/* Assume future writes are recommended to be written in SLC mode */</span>

<span class="enscript-comment">/* 0x0200000  is currently unused */</span> 

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">C_IO_ISOCHRONOUS</span>    0x0400000  <span class="enscript-comment">/* device-specific isochronous throughput I/O */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ZFTIMELIMIT</span>	(5 * 60)

<span class="enscript-comment">/*
 * The following is the &quot;invisible&quot; bit from the fdFlags field
 * in the FndrFileInfo.
 */</span>
<span class="enscript-type">enum</span> { kFinderInvisibleMask = 1 &lt;&lt; 14 };


<span class="enscript-comment">/*
 * Convert between cnode pointers and vnode pointers
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOC</span>(vp)	((struct cnode *)vnode_fsnode((vp)))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CTOV</span>(cp,rsrc)	(((rsrc) &amp;&amp; S_ISREG((cp)-&gt;c_mode)) ? \
			(cp)-&gt;c_rsrc_vp : (cp)-&gt;c_vp)

<span class="enscript-comment">/*
 * Convert between vnode pointers and file forks
 *
 * Note: no CTOF since that is ambiguous
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FTOC</span>(fp)	((fp)-&gt;ff_cp)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOF</span>(vp)	((vp) == VTOC((vp))-&gt;c_rsrc_vp ?	\
			 VTOC((vp))-&gt;c_rsrcfork :		\
			 VTOC((vp))-&gt;c_datafork)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCTOF</span>(vp, cp)	((vp) == (cp)-&gt;c_rsrc_vp ?	\
			 (cp)-&gt;c_rsrcfork :		\
			 (cp)-&gt;c_datafork)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FTOV</span>(fp)	((fp) == FTOC(fp)-&gt;c_rsrcfork ?		\
			 FTOC(fp)-&gt;c_rsrc_vp :			\
			 FTOC(fp)-&gt;c_vp)

<span class="enscript-comment">/*
 * This is a helper function used for determining whether or not a cnode has become open
 * unlinked in between the time we acquired its vnode and the time we acquire the cnode lock
 * to start manipulating it.  Due to the SMP nature of VFS, it is probably necessary to 
 * use this macro every time we acquire a cnode lock, as the content of the Cnode may have
 * been modified in betweeen the lookup and a VNOP.  Whether or not to call this is dependent
 * upon the VNOP in question.  Sometimes it is OK to use an open-unlinked file, for example, in,
 * reading.  But other times, such as on the source of a VNOP_RENAME, it should be disallowed.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_checkdeleted</span>(<span class="enscript-type">struct</span> cnode *cp);

<span class="enscript-comment">/*
 * Test for a resource fork
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FORK_IS_RSRC</span>(fp)	((fp) == FTOC(fp)-&gt;c_rsrcfork)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">VNODE_IS_RSRC</span>(vp)	((vp) == VTOC((vp))-&gt;c_rsrc_vp)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-comment">/*
 * VTOCMP(vp) returns a pointer to vp's decmpfs_cnode; this could be NULL
 * if the file is not compressed or if hfs_file_is_compressed() hasn't
 * yet been called on this file.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOCMP</span>(vp) (VTOC((vp))-&gt;c_decmp)
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_file_is_compressed</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">int</span> skiplock);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_uncompressed_size_of_compressed_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, cnid_t fid, off_t *size, <span class="enscript-type">int</span> skiplock);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_hides_rsrc</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">int</span> skiplock);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_hides_xattr</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> skiplock);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ATIME_ONDISK_ACCURACY</span>	300

<span class="enscript-type">static</span> inline bool <span class="enscript-function-name">hfs_should_save_atime</span>(cnode_t *cp)
{
	<span class="enscript-comment">/*
	 * We only write atime updates to disk if the delta is greater
	 * than ATIME_ONDISK_ACCURACY.
	 */</span>
	<span class="enscript-keyword">return</span> (cp-&gt;c_atime &lt; cp-&gt;c_attr.ca_atimeondisk
			|| cp-&gt;c_atime - cp-&gt;c_attr.ca_atimeondisk &gt; ATIME_ONDISK_ACCURACY);
}

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	HFS_NOT_DIRTY   = 0,
	HFS_DIRTY       = 1,
	HFS_DIRTY_ATIME = 2
} hfs_dirty_t;

<span class="enscript-type">static</span> inline hfs_dirty_t <span class="enscript-function-name">hfs_is_dirty</span>(cnode_t *cp)
{
	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_NOEXISTS))
		<span class="enscript-keyword">return</span> HFS_NOT_DIRTY;

	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_MODIFIED | C_MINOR_MOD | C_NEEDS_DATEADDED)
		|| cp-&gt;c_touch_chgtime || cp-&gt;c_touch_modtime) {
		<span class="enscript-keyword">return</span> HFS_DIRTY;
	}

	<span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime || hfs_should_save_atime(cp))
		<span class="enscript-keyword">return</span> HFS_DIRTY_ATIME;

	<span class="enscript-keyword">return</span> HFS_NOT_DIRTY;
}

<span class="enscript-comment">/* This overlays the FileID portion of NFS file handles. */</span>
<span class="enscript-type">struct</span> hfsfid {
	u_int32_t hfsfid_cnid;	<span class="enscript-comment">/* Catalog node ID. */</span>
	u_int32_t hfsfid_gen;	<span class="enscript-comment">/* Generation number (create date). */</span>
};


<span class="enscript-comment">/* Get new default vnode */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getnewvnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> componentname *cnp,
                           <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> cat_attr *attrp,
                           <span class="enscript-type">struct</span> cat_fork *forkp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">int</span> *out_flags);

<span class="enscript-comment">/* Input flags for hfs_getnewvnode */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_WANTRSRC</span>   0x01  <span class="enscript-comment">/* Request the resource fork vnode. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_SKIPLOCK</span>   0x02  <span class="enscript-comment">/* Skip taking the cnode lock (when getting resource fork). */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_CREATE</span>     0x04  <span class="enscript-comment">/* The vnode is for a newly created item. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_NOCACHE</span>	   0x08  <span class="enscript-comment">/* Delay entering this item in the name cache */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_USE_VP</span>     0x10  <span class="enscript-comment">/* Use the vnode provided in *vpp instead of creating a new one */</span>  

<span class="enscript-comment">/* Output flags for hfs_getnewvnode */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_CHASH_RENAMED</span>	0x01	<span class="enscript-comment">/* The cnode was renamed in-flight */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_CAT_DELETED</span>		0x02	<span class="enscript-comment">/* The cnode was deleted from the catalog */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_NEW_CNODE</span>		0x04	<span class="enscript-comment">/* We are vending out a newly initialized cnode */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GNV_CAT_ATTRCHANGED</span>	0x08	<span class="enscript-comment">/* Something in struct cat_attr changed in between cat_lookups */</span>


<span class="enscript-comment">/* Touch cnode times based on c_touch_xxx flags */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_touchtimes</span>(<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_write_dateadded</span> (<span class="enscript-type">struct</span> cat_attr *cattrp, u_int32_t dateadded);
<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">hfs_get_dateadded</span> (<span class="enscript-type">struct</span> cnode *cp); 
<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">hfs_get_dateadded_from_blob</span>(<span class="enscript-type">const</span> uint8_t * <span class="enscript-comment">/* finderinfo */</span>, mode_t <span class="enscript-comment">/* mode */</span>);

<span class="enscript-comment">/* Gen counter methods */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_write_gencount</span>(<span class="enscript-type">struct</span> cat_attr *cattrp, uint32_t gencount);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">hfs_get_gencount</span>(<span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">hfs_incr_gencount</span> (<span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">hfs_get_gencount_from_blob</span>(<span class="enscript-type">const</span> uint8_t * <span class="enscript-comment">/* finderinfo */</span>, mode_t <span class="enscript-comment">/* mode */</span>);

<span class="enscript-comment">/* Document id methods */</span>
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">hfs_get_document_id</span>(<span class="enscript-type">struct</span> cnode * <span class="enscript-comment">/* cp */</span>);
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">hfs_get_document_id_from_blob</span>(<span class="enscript-type">const</span> uint8_t * <span class="enscript-comment">/* finderinfo */</span>, mode_t <span class="enscript-comment">/* mode */</span>);

<span class="enscript-comment">/* Zero-fill file and push regions out to disk */</span>
<span class="enscript-type">enum</span> {
	<span class="enscript-comment">// Use this flag if you're going to sync later
</span>	HFS_FILE_DONE_NO_SYNC 	= 1,
};
<span class="enscript-type">typedef</span> uint32_t hfs_file_done_opts_t;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_filedone</span>(<span class="enscript-type">struct</span> vnode *vp, vfs_context_t context, 
						 hfs_file_done_opts_t opts);

<span class="enscript-comment">/*
 * HFS cnode hash functions.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chashinit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chashinit_finish</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_delete_chash</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>   <span class="enscript-function-name">hfs_chashremove</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chash_abort</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chash_rehash</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chashwakeup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">int</span> flags);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_chash_mark_in_transit</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> vnode * <span class="enscript-function-name">hfs_chash_getvnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, ino_t inum, <span class="enscript-type">int</span> wantrsrc, 
										<span class="enscript-type">int</span> skiplock, <span class="enscript-type">int</span> allow_deleted);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> cnode * <span class="enscript-function-name">hfs_chash_getcnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, ino_t inum, <span class="enscript-type">struct</span> vnode **vpp, 
										 <span class="enscript-type">int</span> wantrsrc, <span class="enscript-type">int</span> skiplock, <span class="enscript-type">int</span> *out_flags, <span class="enscript-type">int</span> *hflags);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_chash_snoop</span>(<span class="enscript-type">struct</span> hfsmount *, ino_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> cnode_t *, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_valid_cnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> componentname *cnp, 
							cnid_t cnid, <span class="enscript-type">struct</span> cat_attr *cattr, <span class="enscript-type">int</span> *error);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_chash_set_childlinkbit</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid);

<span class="enscript-comment">/*
 * HFS cnode lock functions.
 *
 *  HFS Locking Order:
 *
 *  1. cnode truncate lock (if needed) -- see below for more on this
 *
 *     + hfs_vnop_pagein/out handles recursive use of this lock (by
 *       using flag option HFS_LOCK_SKIP_IF_EXCLUSIVE) although there
 *       are issues with this (see #16620278).
 *
 *	   + If locking multiple cnodes then the truncate lock must be taken on
 *       all (in address order), before taking the cnode locks.
 *
 *  2. Hot Files stage mutex (grabbed before manipulating individual vnodes/cnodes)
 *
 *  3. cnode locks in address order (if needed)
 *
 *  4. journal (if needed)
 *
 *  5. Hot Files B-Tree lock (not treated as a system file)
 *
 *  6. system files (as needed)
 *
 *       A. Catalog B-tree file
 *       B. Attributes B-tree file
 *       C. Startup file (if there is one)
 *       D. Allocation Bitmap file (always exclusive, supports recursion)
 *       E. Overflow Extents B-tree file (always exclusive, supports recursion)
 *
 *  7. hfs mount point (always last)
 *
 *
 * I. HFS cnode hash lock (must not acquire any new locks while holding this lock, always taken last)
 */</span>

<span class="enscript-comment">/*
 * -- The Truncate Lock --
 *
 * The truncate lock is used for a few purposes (more than its name
 * might suggest).  The first thing to note is that the cnode lock
 * cannot be held whilst issuing any I/O other than metadata changes,
 * so the truncate lock, in either shared or exclusive form, must
 * usually be held in these cases.  This includes calls to ubc_setsize
 * where the new size is less than the current size known to the VM
 * subsystem (for two reasons: a) because reaping pages can block
 * (e.g. on pages that are busy or being cleaned); b) reaping pages
 * might require page-in for tasks that have that region mapped
 * privately).  The same applies to other calls into the VM subsystem.
 *
 * Here are some (but not necessarily all) cases that the truncate
 * lock protects for:
 *
 *  + When reading and writing a file, we hold the truncate lock
 *    shared to ensure that the underlying blocks cannot be deleted
 *    and on systems that use content protection, this also ensures
 *    the keys remain valid (which might be being used by the
 *    underlying layers).
 *
 *  + We need to protect against the following sequence of events:
 *
 *      A file is initially size X.  A thread issues an append to that
 *      file.  Another thread truncates the file and then extends it
 *      to a a new size Y.  Now the append can be applied at offset X
 *      and then the data is lost when the file is truncated; or it
 *      could be applied after the truncate, i.e. at offset 0; or it
 *      can be applied at offset Y.  What we *cannot* do is apply the
 *      append at offset X and for the data to be visible at the end.
 *      (Note that we are free to choose when we apply the append
 *      operation.)
 *
 *    To solve this, we keep things simple and take the truncate lock
 *    exclusively in order to sequence the append with other size
 *    changes.  Therefore any size change must take the truncate lock
 *    exclusively.
 *
 *    (N.B. we could do better and allow readers to run concurrently
 *    during the append and other size changes.)
 *
 * So here are the rules:
 *
 *  + If you plan to change ff_size, you must take the truncate lock
 *    exclusively, *but* be careful what I/O you do whilst you have
 *    the truncate lock exclusively and try and avoid it if you can:
 *    if the VM subsystem tries to do something with some pages on a
 *    different thread and you try and do some I/O with those same
 *    pages, we will deadlock.  (See #16620278.)
 *
 *  + If you do anything that requires blocks to not be deleted or
 *    encryption keys to remain valid, you must take the truncate lock
 *    shared.
 *
 *  + And it follows therefore, that if you want to delete blocks or
 *    delete keys, you must take the truncate lock exclusively.  Note 
 *    that for asynchronous writes, the truncate lock will be dropped 
 *    after issuing I/O but before the I/O has completed which means
 *    that before manipulating keys, you *must* issue
 *    vnode_wait_for_writes in addition to holding the truncate lock.
 *
 * N.B. ff_size is actually protected by the cnode lock and so you
 * must hold the cnode lock exclusively to change it and shared to
 * read it.
 *
 */</span>

<span class="enscript-type">enum</span> hfs_locktype {
	HFS_SHARED_LOCK = 1, 
	HFS_EXCLUSIVE_LOCK = 2
};

<span class="enscript-comment">/* Option flags for cnode and truncate lock functions */</span>
<span class="enscript-type">enum</span> hfs_lockflags {
	HFS_LOCK_DEFAULT           = 0x0,    <span class="enscript-comment">/* Default flag, no options provided */</span>
	HFS_LOCK_ALLOW_NOEXISTS    = 0x1,    <span class="enscript-comment">/* Allow locking of all cnodes, including cnode marked deleted with no catalog entry */</span>
	HFS_LOCK_SKIP_IF_EXCLUSIVE = 0x2,    <span class="enscript-comment">/* Skip locking if the current thread already holds the lock exclusive */</span>

	<span class="enscript-comment">// Used when you do not want to check return from hfs_lock
</span>	HFS_LOCK_ALWAYS			   = HFS_LOCK_ALLOW_NOEXISTS, 
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SHARED_OWNER</span>  (void *)0xffffffff

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_lock_always</span>(cnode_t *cnode, <span class="enscript-type">enum</span> hfs_locktype);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_lock</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">enum</span> hfs_locktype, <span class="enscript-type">enum</span> hfs_lockflags);
bool <span class="enscript-function-name">hfs_lock_upgrade</span>(cnode_t *cp);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_lockpair</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *, <span class="enscript-type">enum</span> hfs_locktype);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_lockfour</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *,
                        <span class="enscript-type">enum</span> hfs_locktype, <span class="enscript-type">struct</span> cnode **);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlock</span>(<span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlockpair</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlockfour</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_lock_truncate</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">enum</span> hfs_locktype, <span class="enscript-type">enum</span> hfs_lockflags);
bool <span class="enscript-function-name">hfs_truncate_lock_upgrade</span>(<span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_truncate_lock_downgrade</span>(<span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlock_truncate</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">enum</span> hfs_lockflags);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_try_trunclock</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">enum</span> hfs_locktype, <span class="enscript-type">enum</span> hfs_lockflags);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_systemfile_lock</span>(<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">int</span>, <span class="enscript-type">enum</span> hfs_locktype);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_systemfile_unlock</span>(<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_clear_might_be_dirty_flag</span>(cnode_t *cp);

<span class="enscript-comment">// cnode must be locked
</span><span class="enscript-type">static</span> inline <span class="enscript-function-name">__attribute__</span>((pure))
bool <span class="enscript-function-name">hfs_has_rsrc</span>(<span class="enscript-type">const</span> cnode_t *cp)
{
	<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork)
		<span class="enscript-keyword">return</span> cp-&gt;c_rsrcfork-&gt;ff_blocks &gt; 0;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> cp-&gt;c_datafork &amp;&amp; cp-&gt;c_blocks &gt; cp-&gt;c_datafork-&gt;ff_blocks;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ! _HFS_CNODE_H_ */</span>
</pre>
<hr />
</body></html>