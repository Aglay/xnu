<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>rangelist.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">rangelist.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2001-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">RANGELIST_TEST</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;rangelist.h&quot;</span>

<span class="enscript-type">static</span> <span class="enscript-type">enum</span> rl_overlaptype <span class="enscript-function-name">rl_scan_from</span>(<span class="enscript-type">struct</span> rl_head *rangelist, off_t start, off_t end, <span class="enscript-type">struct</span> rl_entry **overlap, <span class="enscript-type">struct</span> rl_entry *range);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rl_collapse_forwards</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rl_collapse_backwards</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rl_collapse_neighbors</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range);


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rl_verify</span>(<span class="enscript-type">struct</span> rl_head *rangelist) {
	<span class="enscript-type">struct</span> rl_entry *entry;
	<span class="enscript-type">struct</span> rl_entry *next;
	off_t limit = 0;
	
	TAILQ_FOREACH_SAFE(rangelist, entry, rl_link, next) {
		<span class="enscript-keyword">if</span> ((limit &gt; 0) &amp;&amp; (entry-&gt;rl_start &lt;= limit)) panic(<span class="enscript-string">&quot;hfs: rl_verify: bad entry start?!&quot;</span>);
		<span class="enscript-keyword">if</span> (entry-&gt;rl_end &lt; entry-&gt;rl_start) panic(<span class="enscript-string">&quot;hfs: rl_verify: bad entry end?!&quot;</span>);
		limit = entry-&gt;rl_end;
	};
}
#<span class="enscript-reference">endif</span>



<span class="enscript-comment">/*
 * Initialize a range list head
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rl_init</span>(<span class="enscript-type">struct</span> rl_head *rangelist)
{
    TAILQ_INIT(rangelist);
}

<span class="enscript-comment">/*
 * Add a range to the list
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rl_add</span>(off_t start, off_t end, <span class="enscript-type">struct</span> rl_head *rangelist)
{
	<span class="enscript-type">struct</span> rl_entry *range;
	<span class="enscript-type">struct</span> rl_entry *overlap;
	<span class="enscript-type">enum</span> rl_overlaptype ovcase;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (end &lt; start) panic(<span class="enscript-string">&quot;hfs: rl_add: end &lt; start?!&quot;</span>);
#<span class="enscript-reference">endif</span>

	ovcase = rl_scan(rangelist, start, end, &amp;overlap);
			
	<span class="enscript-comment">/*
	 * Six cases:
	 *	0) no overlap
	 *	1) overlap == range
	 *	2) overlap contains range
	 *	3) range contains overlap
	 *	4) overlap starts before range
	 *	5) overlap ends after range
	 */</span>
	<span class="enscript-keyword">switch</span> (ovcase) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_NOOVERLAP</span>: <span class="enscript-comment">/* 0: no overlap */</span>
			<span class="enscript-comment">/*
			 * overlap points to the entry we should insert before, or
			 * if NULL, we should insert at the end.
			 */</span>
			MALLOC(range, <span class="enscript-type">struct</span> rl_entry *, <span class="enscript-keyword">sizeof</span>(*range), M_TEMP, M_WAITOK);
			range-&gt;rl_start = start;
			range-&gt;rl_end = end;
			
			<span class="enscript-comment">/* Link in the new range: */</span>
			<span class="enscript-keyword">if</span> (overlap) {
				TAILQ_INSERT_BEFORE(overlap, range, rl_link);
			} <span class="enscript-keyword">else</span> {
				TAILQ_INSERT_TAIL(rangelist, range, rl_link);
			}
			
			<span class="enscript-comment">/* Check to see if any ranges can be combined (possibly including the immediately
			   preceding range entry)
			 */</span>
			rl_collapse_neighbors(rangelist, range);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>: <span class="enscript-comment">/* 1: overlap == range */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>: <span class="enscript-comment">/* 2: overlap contains range */</span>
			range = overlap; <span class="enscript-comment">/* for debug output below */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>: <span class="enscript-comment">/* 3: range contains overlap */</span>
			<span class="enscript-comment">/*
			 * Replace the overlap with the new, larger range:
			 */</span>
			overlap-&gt;rl_start = start;
			overlap-&gt;rl_end = end;
			rl_collapse_neighbors(rangelist, overlap);
			range = overlap; <span class="enscript-comment">/* for debug output below */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>: <span class="enscript-comment">/* 4: overlap starts before range */</span>
			<span class="enscript-comment">/*
			 * Expand the overlap area to cover the new range:
			 */</span>
			overlap-&gt;rl_end = end;
			rl_collapse_forwards(rangelist, overlap);
			range = overlap; <span class="enscript-comment">/* for debug output below */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>: <span class="enscript-comment">/* 5: overlap ends after range */</span>
			<span class="enscript-comment">/*
			 * Expand the overlap area to cover the new range:
			 */</span>
			overlap-&gt;rl_start = start;
			rl_collapse_backwards(rangelist, overlap);
			range = overlap; <span class="enscript-comment">/* for debug output below */</span>
			<span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
	rl_verify(rangelist);
#<span class="enscript-reference">endif</span>
}



<span class="enscript-comment">/*
 * Remove a range from a range list.
 *
 * Generally, find the range (or an overlap to that range)
 * and remove it (or shrink it), then wakeup anyone we can.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rl_remove</span>(off_t start, off_t end, <span class="enscript-type">struct</span> rl_head *rangelist)
{
	<span class="enscript-type">struct</span> rl_entry *range, *next_range, *overlap, *splitrange;
	<span class="enscript-type">int</span> ovcase;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (end &lt; start) panic(<span class="enscript-string">&quot;hfs: rl_remove: end &lt; start?!&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(rangelist)) {
		<span class="enscript-keyword">return</span>;
	};

	range = TAILQ_FIRST(rangelist);
	<span class="enscript-keyword">while</span> ((ovcase = rl_scan_from(rangelist, start, end, &amp;overlap, range))) {
		<span class="enscript-keyword">switch</span> (ovcase) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>: <span class="enscript-comment">/* 1: overlap == range */</span>
			TAILQ_REMOVE(rangelist, overlap, rl_link);
			FREE(overlap, M_TEMP);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>: <span class="enscript-comment">/* 2: overlap contains range: split it */</span>
			<span class="enscript-keyword">if</span> (overlap-&gt;rl_start == start) {
				overlap-&gt;rl_start = end + 1;
				<span class="enscript-keyword">break</span>;
			};
			
			<span class="enscript-keyword">if</span> (overlap-&gt;rl_end == end) {
				overlap-&gt;rl_end = start - 1;
				<span class="enscript-keyword">break</span>;
			};
			
			<span class="enscript-comment">/*
			* Make a new range consisting of the last part of the encompassing range
			*/</span>
			MALLOC(splitrange, <span class="enscript-type">struct</span> rl_entry *, <span class="enscript-keyword">sizeof</span> *splitrange, M_TEMP, M_WAITOK);
			splitrange-&gt;rl_start = end + 1;
			splitrange-&gt;rl_end = overlap-&gt;rl_end;
			overlap-&gt;rl_end = start - 1;
			
			<span class="enscript-comment">/*
			* Now link the new entry into the range list after the range from which it was split:
			*/</span>
			TAILQ_INSERT_AFTER(rangelist, overlap, splitrange, rl_link);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>: <span class="enscript-comment">/* 3: range contains overlap */</span>
			<span class="enscript-comment">/* Check before discarding overlap entry */</span>
			next_range = TAILQ_NEXT(overlap, rl_link);
			TAILQ_REMOVE(rangelist, overlap, rl_link);
			FREE(overlap, M_TEMP);
			<span class="enscript-keyword">if</span> (next_range) {
				range = next_range;
				<span class="enscript-keyword">continue</span>;
			};
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>: <span class="enscript-comment">/* 4: overlap starts before range */</span>
			overlap-&gt;rl_end = start - 1;
			range = TAILQ_NEXT(overlap, rl_link);
			<span class="enscript-keyword">if</span> (range) {
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>: <span class="enscript-comment">/* 5: overlap ends after range */</span>
			overlap-&gt;rl_start = (end == RL_INFINITY ? RL_INFINITY : end + 1);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
	rl_verify(rangelist);
#<span class="enscript-reference">endif</span>
}



<span class="enscript-comment">/*
 * Scan a range list for an entry in a specified range (if any):
 *
 * NOTE: this returns only the FIRST overlapping range.
 *	     There may be more than one.
 */</span>

<span class="enscript-type">enum</span> rl_overlaptype
<span class="enscript-function-name">rl_scan</span>(<span class="enscript-type">struct</span> rl_head *rangelist,
		off_t start,
		off_t end,
		<span class="enscript-type">struct</span> rl_entry **overlap) {

	<span class="enscript-keyword">return</span> rl_scan_from(rangelist, start, end, overlap, TAILQ_FIRST(rangelist));	
}

<span class="enscript-type">enum</span> rl_overlaptype
<span class="enscript-function-name">rl_overlap</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> rl_entry *range, off_t start, off_t end)
{
	<span class="enscript-comment">/*
	 * OK, check for overlap
	 *
	 * Six cases:
	 *	0) no overlap (RL_NOOVERLAP)
	 *	1) overlap == range (RL_MATCHINGOVERLAP)
	 *	2) overlap contains range (RL_OVERLAPCONTAINSRANGE)
	 *	3) range contains overlap (RL_OVERLAPISCONTAINED)
	 *	4) overlap starts before range (RL_OVERLAPSTARTSBEFORE)
	 *	5) overlap ends after range (RL_OVERLAPENDSAFTER)
	 */</span>
	<span class="enscript-keyword">if</span> (start &gt; range-&gt;rl_end || range-&gt;rl_start &gt; end) {
		<span class="enscript-comment">/* Case 0 (RL_NOOVERLAP) */</span>
		<span class="enscript-keyword">return</span> RL_NOOVERLAP;
	}

	<span class="enscript-keyword">if</span> (range-&gt;rl_start == start &amp;&amp; range-&gt;rl_end == end) {
		<span class="enscript-comment">/* Case 1 (RL_MATCHINGOVERLAP) */</span>
		<span class="enscript-keyword">return</span> RL_MATCHINGOVERLAP;
	}

	<span class="enscript-keyword">if</span> (range-&gt;rl_start &lt;= start &amp;&amp; range-&gt;rl_end &gt;= end) {
		<span class="enscript-comment">/* Case 2 (RL_OVERLAPCONTAINSRANGE) */</span>
		<span class="enscript-keyword">return</span> RL_OVERLAPCONTAINSRANGE;
	}

	<span class="enscript-keyword">if</span> (start &lt;= range-&gt;rl_start &amp;&amp; end &gt;= range-&gt;rl_end) {
		<span class="enscript-comment">/* Case 3 (RL_OVERLAPISCONTAINED) */</span>
		<span class="enscript-keyword">return</span> RL_OVERLAPISCONTAINED;
	}

	<span class="enscript-keyword">if</span> (range-&gt;rl_start &lt; start &amp;&amp; range-&gt;rl_end &lt; end) {
		<span class="enscript-comment">/* Case 4 (RL_OVERLAPSTARTSBEFORE) */</span>
		<span class="enscript-keyword">return</span> RL_OVERLAPSTARTSBEFORE;
	}

	<span class="enscript-comment">/* Case 5 (RL_OVERLAPENDSAFTER) */</span>
	<span class="enscript-comment">// range-&gt;rl_start &gt; start &amp;&amp; range-&gt;rl_end &gt; end
</span>	<span class="enscript-keyword">return</span> RL_OVERLAPENDSAFTER;
}

<span class="enscript-comment">/*
 * Walk the list of ranges for an entry to
 * find an overlapping range (if any).
 *
 * NOTE: this returns only the FIRST overlapping range.
 *	     There may be more than one.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">enum</span> rl_overlaptype
<span class="enscript-function-name">rl_scan_from</span>(<span class="enscript-type">struct</span> rl_head *rangelist __unused,
			 off_t start,
			 off_t end,
			 <span class="enscript-type">struct</span> rl_entry **overlap,
			 <span class="enscript-type">struct</span> rl_entry *range)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
	rl_verify(rangelist);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">while</span> (range) {
		<span class="enscript-type">enum</span> rl_overlaptype ot = rl_overlap(range, start, end);

		<span class="enscript-keyword">if</span> (ot != RL_NOOVERLAP || range-&gt;rl_start &gt; end) {
			*overlap = range;
			<span class="enscript-keyword">return</span> ot;
		}

		range = TAILQ_NEXT(range, rl_link);
	}

	*overlap = NULL;
	<span class="enscript-keyword">return</span> RL_NOOVERLAP;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rl_collapse_forwards</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range) {
	<span class="enscript-type">struct</span> rl_entry *next_range;
	
	<span class="enscript-keyword">while</span> ((next_range = TAILQ_NEXT(range, rl_link))) { 
		<span class="enscript-keyword">if</span> ((range-&gt;rl_end != RL_INFINITY) &amp;&amp; (range-&gt;rl_end &lt; next_range-&gt;rl_start - 1)) <span class="enscript-keyword">return</span>;

		<span class="enscript-comment">/* Expand this range to include the next range: */</span>
		range-&gt;rl_end = next_range-&gt;rl_end;

		<span class="enscript-comment">/* Remove the now covered range from the list: */</span>
		TAILQ_REMOVE(rangelist, next_range, rl_link);
		FREE(next_range, M_TEMP);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
		rl_verify(rangelist);
#<span class="enscript-reference">endif</span>
	};
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rl_collapse_backwards</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range) {
    <span class="enscript-type">struct</span> rl_entry *prev_range;
    
		<span class="enscript-keyword">while</span> ((prev_range = TAILQ_PREV(range, rl_head, rl_link))) {
			<span class="enscript-keyword">if</span> (prev_range-&gt;rl_end &lt; range-&gt;rl_start -1) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">RL_DIAGNOSTIC</span>
			rl_verify(rangelist);
#<span class="enscript-reference">endif</span>
        	<span class="enscript-keyword">return</span>;
        };
        
        <span class="enscript-comment">/* Expand this range to include the previous range: */</span>
        range-&gt;rl_start = prev_range-&gt;rl_start;
    
        <span class="enscript-comment">/* Remove the now covered range from the list: */</span>
        TAILQ_REMOVE(rangelist, prev_range, rl_link);
        FREE(prev_range, M_TEMP);
    };
}



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rl_collapse_neighbors</span>(<span class="enscript-type">struct</span> rl_head *rangelist, <span class="enscript-type">struct</span> rl_entry *range)
{
    rl_collapse_forwards(rangelist, range);
    rl_collapse_backwards(rangelist, range);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_remove_all</span>(<span class="enscript-type">struct</span> rl_head *rangelist)
{
	<span class="enscript-type">struct</span> rl_entry *r, *nextr;
	TAILQ_FOREACH_SAFE(r, rangelist, rl_link, nextr)
		FREE(r, M_TEMP);
	TAILQ_INIT(rangelist);
}

<span class="enscript-comment">/*
 * In the case where b is contained by a, we return the the largest part
 * remaining.  The result is stored in a.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">rl_subtract</span>(<span class="enscript-type">struct</span> rl_entry *a, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> rl_entry *b)
{
	<span class="enscript-keyword">switch</span> (rl_overlap(b, a-&gt;rl_start, a-&gt;rl_end)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>:
			a-&gt;rl_end = a-&gt;rl_start - 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>:
			<span class="enscript-comment">// Keep the bigger part
</span>			<span class="enscript-keyword">if</span> (b-&gt;rl_start - a-&gt;rl_start &gt;= a-&gt;rl_end - b-&gt;rl_end) {
				<span class="enscript-comment">// Keep left
</span>				a-&gt;rl_end = b-&gt;rl_start - 1;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">// Keep right
</span>				a-&gt;rl_start = b-&gt;rl_end + 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>:
			a-&gt;rl_start = b-&gt;rl_end + 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>:
			a-&gt;rl_end = b-&gt;rl_start - 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_NOOVERLAP</span>:
			<span class="enscript-keyword">break</span>;
	}
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* not HFS - temp workaround until 4277828 is fixed */</span>
<span class="enscript-comment">/* stubs for exported routines that aren't present when we build kernel without HFS */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_add</span>(off_t start, off_t end, <span class="enscript-type">void</span> *rangelist);
<span class="enscript-type">void</span> <span class="enscript-function-name">rl_init</span>(<span class="enscript-type">void</span> *rangelist);
<span class="enscript-type">void</span> <span class="enscript-function-name">rl_remove</span>(off_t start, off_t end, <span class="enscript-type">void</span> *rangelist);
<span class="enscript-type">int</span> <span class="enscript-function-name">rl_scan</span>(<span class="enscript-type">void</span> *rangelist, off_t start, off_t end, <span class="enscript-type">void</span> **overlap);

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_add</span>(__unused off_t start, __unused off_t end, __unused <span class="enscript-type">void</span> *rangelist)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_init</span>(__unused <span class="enscript-type">void</span> *rangelist)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_remove</span>(__unused off_t start, __unused off_t end, __unused <span class="enscript-type">void</span> *rangelist)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">rl_scan</span>(__unused <span class="enscript-type">void</span> *rangelist, __unused off_t start, __unused off_t end, __unused <span class="enscript-type">void</span> **overlap)
{
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">rl_remove_all</span>(<span class="enscript-type">struct</span> rl_head *rangelist)
{
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS */</span>
</pre>
<hr />
</body></html>