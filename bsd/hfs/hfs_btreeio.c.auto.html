<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_btreeio.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_btreeio.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_dbg.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_btreeio.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/FileMgrInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesPrivate.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FORCESYNCBTREEWRITES</span> 0

<span class="enscript-comment">/* From bsd/vfs/vfs_bio.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bdwrite_internal</span>(<span class="enscript-type">struct</span> buf *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ClearBTNodes</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> blksize, off_t offset, off_t amount);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">btree_journal_modify_block_end</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> buf *bp);

<span class="enscript-type">void</span> <span class="enscript-function-name">btree_swap_node</span>(<span class="enscript-type">struct</span> buf *bp, __unused <span class="enscript-type">void</span> *arg);

<span class="enscript-comment">/* 
 * Return btree node size for given vnode.
 *
 * Returns: 
 * 	For btree vnode, returns btree node size. 
 * 	For non-btree vnodes, returns 0.
 */</span>
u_int16_t <span class="enscript-function-name">get_btree_nodesize</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	BTreeControlBlockPtr btree;
	u_int16_t node_size = 0; 

	<span class="enscript-keyword">if</span> (vnode_issystem(vp)) {
		btree = (BTreeControlBlockPtr) VTOF(vp)-&gt;fcbBTCBPtr;
		<span class="enscript-keyword">if</span> (btree) {
			node_size = btree-&gt;nodeSize;
		}
	}

	<span class="enscript-keyword">return</span> node_size;
}

OSStatus <span class="enscript-function-name">SetBTreeBlockSize</span>(FileReference vp, ByteCount blockSize, __unused ItemCount minBlockCount)
{
	BTreeControlBlockPtr	bTreePtr;
	
	DBG_ASSERT(vp != NULL);
	DBG_ASSERT(blockSize &gt;= kMinNodeSize);
    <span class="enscript-keyword">if</span> (blockSize &gt; MAXBSIZE )
        <span class="enscript-keyword">return</span> (fsBTBadNodeSize);

	bTreePtr = (BTreeControlBlockPtr)VTOF(vp)-&gt;fcbBTCBPtr;
	bTreePtr-&gt;nodeSize = blockSize;
	
    <span class="enscript-keyword">return</span> (E_NONE);
}


OSStatus <span class="enscript-function-name">GetBTreeBlock</span>(FileReference vp, u_int32_t blockNum, GetBlockOptions options, BlockDescriptor *block)
{
    OSStatus	 retval = E_NONE;
    <span class="enscript-type">struct</span> buf   *bp = NULL;
	u_int8_t     allow_empty_node;	  

	<span class="enscript-comment">/* If the btree block is being read using hint, it is 
	 * fine for the swap code to find zeroed out nodes. 
	 */</span>
	<span class="enscript-keyword">if</span> (options &amp; kGetBlockHint) {
			allow_empty_node = true;
	} <span class="enscript-keyword">else</span> {
			allow_empty_node = false;
	}

    <span class="enscript-keyword">if</span> (options &amp; kGetEmptyBlock) {
        daddr64_t blkno;
        off_t offset;

        offset = (daddr64_t)blockNum * (daddr64_t)block-&gt;blockSize;
        bp = buf_getblk(vp, (daddr64_t)blockNum, block-&gt;blockSize, 0, 0, BLK_META);
        <span class="enscript-keyword">if</span> (bp &amp;&amp;
            VNOP_BLOCKMAP(vp, offset, block-&gt;blockSize, &amp;blkno, NULL, NULL, 0, NULL) == 0) {
            buf_setblkno(bp, blkno);
        }
    } <span class="enscript-keyword">else</span> {
        retval = buf_meta_bread(vp, (daddr64_t)blockNum, block-&gt;blockSize, NOCRED, &amp;bp);
    }
    <span class="enscript-keyword">if</span> (bp == NULL)
        retval = -1;	<span class="enscript-comment">//XXX need better error
</span>
    <span class="enscript-keyword">if</span> (retval == E_NONE) {
        block-&gt;blockHeader = bp;
        block-&gt;buffer = (<span class="enscript-type">char</span> *)buf_dataptr(bp);
    	block-&gt;blockNum = buf_lblkno(bp);
        block-&gt;blockReadFromDisk = (buf_fromcache(bp) == 0);	<span class="enscript-comment">/* not found in cache ==&gt; came from disk */</span>

		<span class="enscript-comment">// XXXdbg 
</span>		block-&gt;isModified = 0;

		<span class="enscript-comment">/* Check and endian swap B-Tree node (only if it's a valid block) */</span>
		<span class="enscript-keyword">if</span> (!(options &amp; kGetEmptyBlock)) {

			<span class="enscript-comment">/* This happens when we first open the b-tree, we might not have all the node data on hand */</span>
			<span class="enscript-keyword">if</span> ((((BTNodeDescriptor *)block-&gt;buffer)-&gt;kind == kBTHeaderNode) &amp;&amp;
					(((BTHeaderRec *)((<span class="enscript-type">char</span> *)block-&gt;buffer + 14))-&gt;nodeSize != buf_count(bp)) &amp;&amp;
					(SWAP_BE16 (((BTHeaderRec *)((<span class="enscript-type">char</span> *)block-&gt;buffer + 14))-&gt;nodeSize) != buf_count(bp))) {

				<span class="enscript-comment">/*
				 * Don't swap the node descriptor, record offsets, or other records.
				 * This record will be invalidated and re-read with the correct node
				 * size once the B-tree control block is set up with the node size
				 * from the header record.
				 */</span>
				retval = hfs_swap_BTNode (block, vp, kSwapBTNodeHeaderRecordOnly, allow_empty_node);

			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * In this case, we have enough data in-hand to do basic validation
				 * on the B-Tree node.
				 */</span>
				<span class="enscript-keyword">if</span> (block-&gt;blockReadFromDisk) {
					<span class="enscript-comment">/*
					 * The node was just read from disk, so always swap/check it.
					 * This is necessary on big endian since the test below won't trigger.
					 */</span>
					retval = hfs_swap_BTNode (block, vp, kSwapBTNodeBigToHost, allow_empty_node);
				} 
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * Block wasn't read from disk; it was found in the cache.  
					 */</span>
					<span class="enscript-keyword">if</span> (*((u_int16_t *)((<span class="enscript-type">char</span> *)block-&gt;buffer + (block-&gt;blockSize - <span class="enscript-keyword">sizeof</span> (u_int16_t)))) == 0x0e00) {
						<span class="enscript-comment">/*
						 * The node was left in the cache in non-native order, so swap it.
						 * This only happens on little endian, after the node is written
						 * back to disk.
						 */</span>
						retval = hfs_swap_BTNode (block, vp, kSwapBTNodeBigToHost, allow_empty_node);
					}
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*((u_int16_t *)((<span class="enscript-type">char</span> *)block-&gt;buffer + (block-&gt;blockSize - <span class="enscript-keyword">sizeof</span> (u_int16_t)))) == 0x000e) {
						<span class="enscript-comment">/*
						 * The node was in-cache in native-endianness.  We don't need to do 
						 * anything here, because the node is ready to use.  Set retval == 0.
						 */</span>
						retval = 0;
					}
					<span class="enscript-comment">/*
					 * If the node doesn't have hex 14 (0xe) in the last two bytes of the buffer, 
					 * it doesn't necessarily mean that this is a bad node.  Zeroed nodes that are
					 * marked as unused in the b-tree map node would be OK and not have valid content.
					 */</span>
				}
			}

			<span class="enscript-comment">/*
			 * If we got an error, then the node is only partially swapped.
			 * We mark the buffer invalid so that the next attempt to get the
			 * node will read it and attempt to swap again, and will notice
			 * the error again.  If we didn't do this, the next attempt to get
			 * the node might use the partially swapped node as-is.
			 */</span>
			<span class="enscript-keyword">if</span> (retval)
				buf_markinvalid(bp);
		}
	}
    
    <span class="enscript-keyword">if</span> (retval) {
    	<span class="enscript-keyword">if</span> (bp)
			buf_brelse(bp);
        block-&gt;blockHeader = NULL;
        block-&gt;buffer = NULL;
    }

    <span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">void</span> <span class="enscript-function-name">ModifyBlockStart</span>(FileReference vp, BlockDescPtr blockPtr)
{
	<span class="enscript-type">struct</span> hfsmount	*hfsmp = VTOHFS(vp);
    <span class="enscript-type">struct</span> buf *bp = NULL;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
    bp = (<span class="enscript-type">struct</span> buf *) blockPtr-&gt;blockHeader;
    <span class="enscript-keyword">if</span> (bp == NULL) {
		panic(<span class="enscript-string">&quot;hfs: ModifyBlockStart: null bp  for blockdescptr %p?!?\n&quot;</span>, blockPtr);
		<span class="enscript-keyword">return</span>;
    }

	journal_modify_block_start(hfsmp-&gt;jnl, bp);
	blockPtr-&gt;isModified = 1;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">btree_swap_node</span>(<span class="enscript-type">struct</span> buf *bp, __unused <span class="enscript-type">void</span> *arg)
{
    <span class="enscript-comment">//	struct hfsmount *hfsmp = (struct hfsmount *)arg;
</span>	<span class="enscript-type">int</span> retval;
    <span class="enscript-type">struct</span> vnode *vp = buf_vnode(bp);
    BlockDescriptor block;
				    
    <span class="enscript-comment">/* Prepare the block pointer */</span>
    block.blockHeader = bp;
    block.buffer = (<span class="enscript-type">char</span> *)buf_dataptr(bp);
    block.blockNum = buf_lblkno(bp);
    <span class="enscript-comment">/* not found in cache ==&gt; came from disk */</span>
    block.blockReadFromDisk = (buf_fromcache(bp) == 0);
    block.blockSize = buf_count(bp);

    <span class="enscript-comment">/* Swap the data now that this node is ready to go to disk.
     * We allow swapping of zeroed out nodes here because we might
     * be writing node whose last record just got deleted.
     */</span>
    retval = hfs_swap_BTNode (&amp;block, vp, kSwapBTNodeHostToBig, true);
    <span class="enscript-keyword">if</span> (retval)
    	panic(<span class="enscript-string">&quot;hfs: btree_swap_node: about to write corrupt node!\n&quot;</span>);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">btree_journal_modify_block_end</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> buf *bp)
{
    <span class="enscript-keyword">return</span> journal_modify_block_end(hfsmp-&gt;jnl, bp, btree_swap_node, hfsmp);
}


OSStatus <span class="enscript-function-name">ReleaseBTreeBlock</span>(FileReference vp, BlockDescPtr blockPtr, ReleaseBlockOptions options)
{
    <span class="enscript-type">struct</span> hfsmount	*hfsmp = VTOHFS(vp);
    OSStatus	retval = E_NONE;
    <span class="enscript-type">struct</span> buf *bp = NULL;

    bp = (<span class="enscript-type">struct</span> buf *) blockPtr-&gt;blockHeader;

    <span class="enscript-keyword">if</span> (bp == NULL) {
        retval = -1;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
    }

    <span class="enscript-keyword">if</span> (options &amp; kTrashBlock) {
                buf_markinvalid(bp);

		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; (buf_flags(bp) &amp; B_LOCKED)) {
			journal_kill_block(hfsmp-&gt;jnl, bp);
		} <span class="enscript-keyword">else</span> {
			buf_brelse(bp);	<span class="enscript-comment">/* note: B-tree code will clear blockPtr-&gt;blockHeader and blockPtr-&gt;buffer */</span>
		}
		
		<span class="enscript-comment">/* Don't let anyone else try to use this bp, it's been consumed */</span>
		blockPtr-&gt;blockHeader = NULL;
		
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (options &amp; kForceWriteBlock) {
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				<span class="enscript-keyword">if</span> (blockPtr-&gt;isModified == 0) {
					panic(<span class="enscript-string">&quot;hfs: releaseblock: modified is 0 but forcewrite set! bp %p\n&quot;</span>, bp);
				}

				retval = btree_journal_modify_block_end(hfsmp, bp);
				blockPtr-&gt;isModified = 0;
			} <span class="enscript-keyword">else</span> {
				retval = VNOP_BWRITE(bp);
			}
			
			<span class="enscript-comment">/* Don't let anyone else try to use this bp, it's been consumed */</span>
			blockPtr-&gt;blockHeader = NULL;
			
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (options &amp; kMarkBlockDirty) {
			<span class="enscript-type">struct</span> timeval tv;
			microuptime(&amp;tv);
            <span class="enscript-keyword">if</span> ((options &amp; kLockTransaction) &amp;&amp; hfsmp-&gt;jnl == NULL) {
                <span class="enscript-comment">/*
                 *
                 * Set the B_LOCKED flag and unlock the buffer, causing buf_brelse to move
                 * the buffer onto the LOCKED free list.  This is necessary, otherwise
                 * getnewbuf() would try to reclaim the buffers using buf_bawrite, which
                 * isn't going to work.
                 *
                 */</span>
                <span class="enscript-comment">/* Don't hog all the buffers... */</span>
                <span class="enscript-keyword">if</span> (count_lock_queue() &gt; kMaxLockedMetaBuffers) {
                     hfs_btsync(vp, HFS_SYNCTRANS);
                     <span class="enscript-comment">/* Rollback sync time to cause a sync on lock release... */</span>
                     (<span class="enscript-type">void</span>) BTSetLastSync(VTOF(vp), tv.tv_sec - (kMaxSecsForFsync + 1));
                }
		buf_setflags(bp, B_LOCKED);
            }

            <span class="enscript-comment">/* 
             * Delay-write this block.
             * If the maximum delayed buffers has been exceeded then
             * free up some buffers and fall back to an asynchronous write.
             */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				<span class="enscript-keyword">if</span> (blockPtr-&gt;isModified == 0) {
					panic(<span class="enscript-string">&quot;hfs: releaseblock: modified is 0 but markdirty set! bp %p\n&quot;</span>, bp);
				}
				retval = btree_journal_modify_block_end(hfsmp, bp);
				blockPtr-&gt;isModified = 0;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bdwrite_internal(bp, 1) != 0) {
                hfs_btsync(vp, 0);
                <span class="enscript-comment">/* Rollback sync time to cause a sync on lock release... */</span>
                (<span class="enscript-type">void</span>) BTSetLastSync(VTOF(vp), tv.tv_sec - (kMaxSecsForFsync + 1));

                buf_clearflags(bp, B_LOCKED);
                buf_bawrite(bp);
            }
            
            <span class="enscript-comment">/* Don't let anyone else try to use this bp, it's been consumed */</span>
			blockPtr-&gt;blockHeader = NULL;
			
        } <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// check if we had previously called journal_modify_block_start() 
</span>			<span class="enscript-comment">// on this block and if so, abort it (which will call buf_brelse()).
</span>			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; blockPtr-&gt;isModified) {
				<span class="enscript-comment">// XXXdbg - I don't want to call modify_block_abort()
</span>				<span class="enscript-comment">//          because I think it may be screwing up the
</span>				<span class="enscript-comment">//          journal and blowing away a block that has
</span>				<span class="enscript-comment">//          valid data in it.
</span>				<span class="enscript-comment">//   
</span>				<span class="enscript-comment">//    journal_modify_block_abort(hfsmp-&gt;jnl, bp);
</span>				<span class="enscript-comment">//panic(&quot;hfs: releaseblock called for 0x%x but mod_block_start previously called.\n&quot;, bp);
</span>				btree_journal_modify_block_end(hfsmp, bp);
				blockPtr-&gt;isModified = 0;
			} <span class="enscript-keyword">else</span> {
				buf_brelse(bp);	<span class="enscript-comment">/* note: B-tree code will clear blockPtr-&gt;blockHeader and blockPtr-&gt;buffer */</span>
			}
			
			<span class="enscript-comment">/* Don't let anyone else try to use this bp, it's been consumed */</span>
			blockPtr-&gt;blockHeader = NULL;
        }
    }

<span class="enscript-reference">exit</span>:
    <span class="enscript-keyword">return</span> (retval);
}


OSStatus <span class="enscript-function-name">ExtendBTreeFile</span>(FileReference vp, FSSize minEOF, FSSize maxEOF)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">maxEOF</span>)

	OSStatus	retval = 0, ret = 0;
	int64_t		actualBytesAdded, origSize;
	u_int64_t	bytesToAdd;
	u_int32_t	startAllocation;
	u_int32_t	fileblocks;
	BTreeInfoRec 	btInfo;
	ExtendedVCB	*vcb;
	FCB		*filePtr;
    	<span class="enscript-type">struct</span> proc 	*p = NULL;
	int64_t 	trim = 0;
	<span class="enscript-type">int</span>  		lockflags = 0;

	filePtr = GetFileControlBlock(vp);

	<span class="enscript-keyword">if</span> ( (off_t)minEOF &gt; filePtr-&gt;fcbEOF )
	{
		bytesToAdd = minEOF - filePtr-&gt;fcbEOF;

		<span class="enscript-keyword">if</span> (bytesToAdd &lt; filePtr-&gt;ff_clumpsize)
			bytesToAdd = filePtr-&gt;ff_clumpsize;		<span class="enscript-comment">//XXX why not always be a mutiple of clump size?
</span>	}
	<span class="enscript-keyword">else</span>
	{
		<span class="enscript-keyword">return</span> -1;
	}

	vcb = VTOVCB(vp);
	
	<span class="enscript-comment">/*
	 * The Extents B-tree can't have overflow extents. ExtendFileC will
	 * return an error if an attempt is made to extend the Extents B-tree
	 * when the resident extents are exhausted.
	 */</span>

	<span class="enscript-comment">/* Protect allocation bitmap and extents overflow file. */</span>
	lockflags = SFL_BITMAP;
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_fileid != kHFSExtentsFileID)
		lockflags |= SFL_EXTENTS;
	lockflags = hfs_systemfile_lock(vcb, lockflags, HFS_EXCLUSIVE_LOCK);

	(<span class="enscript-type">void</span>) BTGetInformation(filePtr, 0, &amp;btInfo);

#<span class="enscript-reference">if</span> 0  // <span class="enscript-variable-name">XXXdbg</span>
	<span class="enscript-comment">/*
	 * The b-tree code expects nodes to be contiguous. So when
	 * the allocation block size is less than the b-tree node
	 * size, we need to force disk allocations to be contiguous.
	 */</span>
	<span class="enscript-keyword">if</span> (vcb-&gt;blockSize &gt;= btInfo.nodeSize) {
		extendFlags = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Ensure that all b-tree nodes are contiguous on disk */</span>
		extendFlags = kEFContigMask;
	}
#<span class="enscript-reference">endif</span>

	origSize = filePtr-&gt;fcbEOF;
	fileblocks = filePtr-&gt;ff_blocks;
	startAllocation = vcb-&gt;nextAllocation;

	<span class="enscript-comment">// loop trying to get a contiguous chunk that's an integer multiple
</span>	<span class="enscript-comment">// of the btree node size.  if we can't get a contiguous chunk that
</span>	<span class="enscript-comment">// is at least the node size then we break out of the loop and let
</span>	<span class="enscript-comment">// the error propagate back up.
</span>	<span class="enscript-keyword">while</span>((off_t)bytesToAdd &gt;= btInfo.nodeSize) {
	    <span class="enscript-keyword">do</span> {
		retval = ExtendFileC(vcb, filePtr, bytesToAdd, 0,
		                     kEFContigMask | kEFMetadataMask | kEFNoClumpMask,
		                     (int64_t *)&amp;actualBytesAdded);
		<span class="enscript-keyword">if</span> (retval == dskFulErr &amp;&amp; actualBytesAdded == 0) {
		    bytesToAdd &gt;&gt;= 1;
		    <span class="enscript-keyword">if</span> (bytesToAdd &lt; btInfo.nodeSize) {
			<span class="enscript-keyword">break</span>;
		    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bytesToAdd % btInfo.nodeSize) != 0) {
			<span class="enscript-comment">// make sure it's an integer multiple of the nodeSize
</span>			bytesToAdd -= (bytesToAdd % btInfo.nodeSize);
		    }
		}
	    } <span class="enscript-keyword">while</span> (retval == dskFulErr &amp;&amp; actualBytesAdded == 0);

	    <span class="enscript-keyword">if</span> (retval == dskFulErr &amp;&amp; actualBytesAdded == 0 &amp;&amp; bytesToAdd &lt;= btInfo.nodeSize) {
		<span class="enscript-keyword">break</span>;
	    }

	    filePtr-&gt;fcbEOF = (u_int64_t)filePtr-&gt;ff_blocks * (u_int64_t)vcb-&gt;blockSize;
	    bytesToAdd = minEOF - filePtr-&gt;fcbEOF;
	}

	<span class="enscript-comment">/*
	 * If a new extent was added then move the roving allocator
	 * reference forward by the current b-tree file size so 
	 * there's plenty of room to grow.
	 */</span>
	<span class="enscript-keyword">if</span> ((retval == 0) &amp;&amp;
	    ((VCBTOHFS(vcb)-&gt;hfs_flags &amp; HFS_METADATA_ZONE) == 0) &amp;&amp;
	    (vcb-&gt;nextAllocation &gt; startAllocation) &amp;&amp;
	    ((vcb-&gt;nextAllocation + fileblocks) &lt; vcb-&gt;allocLimit)) {
		HFS_UPDATE_NEXT_ALLOCATION(vcb, vcb-&gt;nextAllocation + fileblocks); 
	}
		
	filePtr-&gt;fcbEOF = (u_int64_t)filePtr-&gt;ff_blocks * (u_int64_t)vcb-&gt;blockSize;

	<span class="enscript-comment">// XXXdbg ExtendFileC() could have returned an error even though
</span>	<span class="enscript-comment">// it grew the file to be big enough for our needs.  If this is
</span>	<span class="enscript-comment">// the case, we don't care about retval so we blow it away.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> (filePtr-&gt;fcbEOF &gt;= (off_t)minEOF &amp;&amp; retval != 0) {
		retval = 0;
	}

	<span class="enscript-comment">// XXXdbg if the file grew but isn't large enough or isn't an
</span>	<span class="enscript-comment">// even multiple of the nodeSize then trim things back.  if
</span>	<span class="enscript-comment">// the file isn't large enough we trim back to the original
</span>	<span class="enscript-comment">// size.  otherwise we trim back to be an even multiple of the
</span>	<span class="enscript-comment">// btree node size.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-keyword">if</span> ((filePtr-&gt;fcbEOF &lt; (off_t)minEOF) || ((filePtr-&gt;fcbEOF - origSize) % btInfo.nodeSize) != 0) {

		<span class="enscript-keyword">if</span> (filePtr-&gt;fcbEOF &lt; (off_t)minEOF) {
			retval = dskFulErr;
			
			<span class="enscript-keyword">if</span> (filePtr-&gt;fcbEOF &lt; origSize) {
				panic(<span class="enscript-string">&quot;hfs: btree file eof %lld less than orig size %lld!\n&quot;</span>,
					  filePtr-&gt;fcbEOF, origSize);
			}
			
			trim = filePtr-&gt;fcbEOF - origSize;
		} <span class="enscript-keyword">else</span> {
			trim = ((filePtr-&gt;fcbEOF - origSize) % btInfo.nodeSize);
		}

		ret = TruncateFileC(vcb, filePtr, filePtr-&gt;fcbEOF - trim, 0, 0, FTOC(filePtr)-&gt;c_fileid, 0);
		filePtr-&gt;fcbEOF = (u_int64_t)filePtr-&gt;ff_blocks * (u_int64_t)vcb-&gt;blockSize;

		<span class="enscript-comment">// XXXdbg - panic if the file didn't get trimmed back properly
</span>		<span class="enscript-keyword">if</span> ((filePtr-&gt;fcbEOF % btInfo.nodeSize) != 0) {
			panic(<span class="enscript-string">&quot;hfs: truncate file didn't! fcbEOF %lld nsize %d fcb %p\n&quot;</span>,
				  filePtr-&gt;fcbEOF, btInfo.nodeSize, filePtr);
		}

		<span class="enscript-keyword">if</span> (ret) {
			<span class="enscript-comment">// XXXdbg - this probably doesn't need to be a panic()
</span>			panic(<span class="enscript-string">&quot;hfs: error truncating btree files (sz 0x%llx, trim %lld, ret %ld)\n&quot;</span>,
			      filePtr-&gt;fcbEOF, trim, (<span class="enscript-type">long</span>)ret);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span>(VTOC(vp)-&gt;c_fileid != kHFSExtentsFileID) {
		<span class="enscript-comment">/*
		 * Get any extents overflow b-tree changes to disk ASAP!
		 */</span>
		(<span class="enscript-type">void</span>) BTFlushPath(VTOF(vcb-&gt;extentsRefNum));
		(<span class="enscript-type">void</span>) hfs_fsync(vcb-&gt;extentsRefNum, MNT_WAIT, 0, p);
	}
	hfs_systemfile_unlock(vcb, lockflags);
	lockflags = 0;

	<span class="enscript-keyword">if</span> ((filePtr-&gt;fcbEOF % btInfo.nodeSize) != 0) {
		panic(<span class="enscript-string">&quot;hfs: extendbtree: fcb %p has eof 0x%llx not a multiple of 0x%x (trim %llx)\n&quot;</span>,
			  filePtr, filePtr-&gt;fcbEOF, btInfo.nodeSize, trim);
	}

	<span class="enscript-comment">/*
	 * Update the Alternate MDB or Alternate VolumeHeader
	 */</span>
	VTOC(vp)-&gt;c_flag |= C_MODIFIED;
	<span class="enscript-keyword">if</span> ((VTOC(vp)-&gt;c_fileid == kHFSExtentsFileID)	||
	    (VTOC(vp)-&gt;c_fileid == kHFSCatalogFileID)	||
	    (VTOC(vp)-&gt;c_fileid == kHFSAttributesFileID)
	   ) {
		MarkVCBDirty( vcb );
		ret = hfs_flushvolumeheader(VCBTOHFS(vcb), HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
	} <span class="enscript-keyword">else</span> {
		VTOC(vp)-&gt;c_touch_chgtime = TRUE;
		VTOC(vp)-&gt;c_touch_modtime = TRUE;
		(<span class="enscript-type">void</span>) hfs_update(vp, 0);
	}

	ret = ClearBTNodes(vp, btInfo.nodeSize, origSize, (filePtr-&gt;fcbEOF - origSize));
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (retval == 0)
		retval = ret;
	
	<span class="enscript-keyword">if</span> (lockflags)
		hfs_systemfile_unlock(vcb, lockflags);
	
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-comment">/*
 * Clear out (zero) new b-tree nodes on disk.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ClearBTNodes</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> blksize, off_t offset, off_t amount)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">struct</span> buf *bp = NULL;
	daddr64_t blk;
	daddr64_t blkcnt;
    
	blk = offset / blksize;
	blkcnt = amount / blksize;
	
	<span class="enscript-keyword">while</span> (blkcnt &gt; 0) {
		bp = buf_getblk(vp, blk, blksize, 0, 0, BLK_META);
		<span class="enscript-keyword">if</span> (bp == NULL)
			<span class="enscript-keyword">continue</span>;

        <span class="enscript-comment">// XXXdbg
</span>		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			<span class="enscript-comment">// XXXdbg -- skipping this for now since it makes a transaction
</span>			<span class="enscript-comment">//           become *way* too large
</span>		    <span class="enscript-comment">//journal_modify_block_start(hfsmp-&gt;jnl, bp);
</span>		}
		bzero((<span class="enscript-type">char</span> *)buf_dataptr(bp), blksize);

		buf_markaged(bp);

        <span class="enscript-comment">// XXXdbg
</span>		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			<span class="enscript-comment">// XXXdbg -- skipping this for now since it makes a transaction
</span>			<span class="enscript-comment">//           become *way* too large
</span>			<span class="enscript-comment">//journal_modify_block_end(hfsmp-&gt;jnl, bp);
</span>
			<span class="enscript-comment">// XXXdbg - remove this once we decide what to do with the
</span>			<span class="enscript-comment">//          writes to the journal
</span>			<span class="enscript-keyword">if</span> ((blk % 32) == 0)
			    VNOP_BWRITE(bp);
			<span class="enscript-keyword">else</span>
			    buf_bawrite(bp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* wait/yield every 32 blocks so we don't hog all the buffers */</span>
			<span class="enscript-keyword">if</span> ((blk % 32) == 0)
				VNOP_BWRITE(bp);
			<span class="enscript-keyword">else</span>
				buf_bawrite(bp);
		}
		--blkcnt;
		++blk;
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">extern</span> <span class="enscript-type">char</span>  hfs_attrname[];

<span class="enscript-comment">/*
 * Create an HFS+ Attribute B-tree File.
 *
 * No global resources should be held.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_create_attr_btree</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t nodesize, u_int32_t nodecnt)
{
	<span class="enscript-type">struct</span> vnode* vp = NULLVP;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr cnattr;
	<span class="enscript-type">struct</span> cat_fork cfork;
	BlockDescriptor blkdesc;
	BTNodeDescriptor  *ndp;
	BTHeaderRec  *bthp;
	BTreeControlBlockPtr btcb = NULL;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	<span class="enscript-type">void</span> * buffer;
	u_int8_t *bitmap;
	u_int16_t *index;
	u_int32_t node_num, num_map_nodes;
	u_int32_t bytes_per_map_record;
	u_int32_t temp;
	u_int16_t  offset;
	<span class="enscript-type">int</span> intrans = 0;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> newvnode_flags = 0;
	
<span class="enscript-reference">again</span>:
	<span class="enscript-comment">/*
	 * Serialize creation using HFS_CREATING_BTREE flag.
	 */</span>
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_CREATING_BTREE) {
			<span class="enscript-comment">/* Someone else beat us, wait for them to finish. */</span>
			(<span class="enscript-type">void</span>) msleep(&amp;hfsmp-&gt;hfs_attribute_cp, &amp;hfsmp-&gt;hfs_mutex,
			              PDROP | PINOD, <span class="enscript-string">&quot;hfs_create_attr_btree&quot;</span>, 0);
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_vp) {
				<span class="enscript-keyword">return</span> (0);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	hfsmp-&gt;hfs_flags |= HFS_CREATING_BTREE;
	hfs_unlock_mount (hfsmp);

	<span class="enscript-comment">/* Check if were out of usable disk space. */</span>
	<span class="enscript-keyword">if</span> ((hfs_freeblks(hfsmp, 1) == 0)) {
		result = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/*
	 * Set up Attribute B-tree vnode
	 * (this must be done before we start a transaction
	 *  or take any system file locks)
	 */</span>
	bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
	cndesc.cd_parentcnid = kHFSRootParentID;
	cndesc.cd_flags |= CD_ISMETA;
	cndesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)hfs_attrname;
	cndesc.cd_namelen = strlen(hfs_attrname);
	cndesc.cd_cnid = kHFSAttributesFileID;

	bzero(&amp;cnattr, <span class="enscript-keyword">sizeof</span>(cnattr));
	cnattr.ca_linkcount = 1;
	cnattr.ca_mode = S_IFREG;
	cnattr.ca_fileid = cndesc.cd_cnid;

	bzero(&amp;cfork, <span class="enscript-keyword">sizeof</span>(cfork));
	cfork.cf_clump = nodesize * nodecnt;

	result = hfs_getnewvnode(hfsmp, NULL, NULL, &amp;cndesc, 0, &amp;cnattr, 
							 &amp;cfork, &amp;vp, &amp;newvnode_flags);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-comment">/*
	 * Set up Attribute B-tree control block
	 */</span>
	MALLOC(btcb, BTreeControlBlock *, <span class="enscript-keyword">sizeof</span>(BTreeControlBlock), M_TEMP, M_WAITOK);
        bzero(btcb, <span class="enscript-keyword">sizeof</span>(BTreeControlBlock));

	btcb-&gt;nodeSize          = nodesize;
	btcb-&gt;maxKeyLength      = kHFSPlusAttrKeyMaximumLength;
	btcb-&gt;btreeType         = 0xFF;
	btcb-&gt;attributes        = kBTVariableIndexKeysMask | kBTBigKeysMask;
	btcb-&gt;version           = kBTreeVersion;
	btcb-&gt;writeCount        = 1;
	btcb-&gt;flags             = 0;  <span class="enscript-comment">/* kBTHeaderDirty */</span>
	btcb-&gt;fileRefNum        = vp;
	btcb-&gt;getBlockProc      = GetBTreeBlock;
	btcb-&gt;releaseBlockProc  = ReleaseBTreeBlock;
	btcb-&gt;setEndOfForkProc  = ExtendBTreeFile;
	btcb-&gt;keyCompareProc    = (KeyCompareProcPtr)hfs_attrkeycompare;
	VTOF(vp)-&gt;fcbBTCBPtr    = btcb;

	<span class="enscript-comment">/*
	 * Allocate some space
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		result = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	intrans = 1;

	<span class="enscript-comment">/* Note ExtendBTreeFile will acquire the necessary system file locks. */</span>
	result = ExtendBTreeFile(vp, nodesize, cfork.cf_clump);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	btcb-&gt;totalNodes = VTOF(vp)-&gt;ff_size / nodesize;

	<span class="enscript-comment">/*
	 * Figure out how many map nodes we'll need.
	 *
	 * bytes_per_map_record = the number of bytes in the map record of a
	 * map node.  Since that is the only record in the node, it is the size
	 * of the node minus the node descriptor at the start, and two record
	 * offsets at the end of the node.  The &quot;- 2&quot; is to round the size down
	 * to a multiple of 4 bytes (since sizeof(BTNodeDescriptor) is not a
	 * multiple of 4).
	 *
	 * The value &quot;temp&quot; here is the number of *bits* in the map record of
	 * the header node.
	 */</span>
	bytes_per_map_record = nodesize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) - 2*<span class="enscript-keyword">sizeof</span>(u_int16_t) - 2;
	temp = 8 * (nodesize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) 
			- <span class="enscript-keyword">sizeof</span>(BTHeaderRec)
			- kBTreeHeaderUserBytes
			- 4 * <span class="enscript-keyword">sizeof</span>(u_int16_t));
	<span class="enscript-keyword">if</span> (btcb-&gt;totalNodes &gt; temp) {
		num_map_nodes = howmany(btcb-&gt;totalNodes - temp, bytes_per_map_record * 8);
	}
	<span class="enscript-keyword">else</span> {
		num_map_nodes = 0;
	}
	
	btcb-&gt;freeNodes = btcb-&gt;totalNodes - 1 - num_map_nodes;
	
	<span class="enscript-comment">/*
	 * Initialize the b-tree header on disk
	 */</span>
	bp = buf_getblk(vp, 0, nodesize, 0, 0, BLK_META);
	<span class="enscript-keyword">if</span> (bp == NULL) {
		result = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	buffer = (<span class="enscript-type">void</span> *)buf_dataptr(bp);
	blkdesc.buffer = buffer;
	blkdesc.blockHeader = (<span class="enscript-type">void</span> *)bp;
	blkdesc.blockReadFromDisk = 0;
	blkdesc.isModified = 0;

	ModifyBlockStart(vp, &amp;blkdesc);

	<span class="enscript-keyword">if</span> (buf_size(bp) != nodesize)
		panic(<span class="enscript-string">&quot;hfs_create_attr_btree: bad buffer size (%d)\n&quot;</span>, buf_size(bp));

	bzero(buffer, nodesize);
	index = (u_int16_t *)buffer;

	<span class="enscript-comment">/* FILL IN THE NODE DESCRIPTOR:  */</span>
	ndp = (BTNodeDescriptor *)buffer;
	<span class="enscript-keyword">if</span> (num_map_nodes != 0)
		ndp-&gt;fLink = 1;
	ndp-&gt;kind = kBTHeaderNode;
	ndp-&gt;numRecords = 3;
	offset = <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor);
	index[(nodesize / 2) - 1] = offset;

	<span class="enscript-comment">/* FILL IN THE HEADER RECORD:  */</span>
	bthp = (BTHeaderRec *)((u_int8_t *)buffer + offset);
	bthp-&gt;nodeSize     = nodesize;
	bthp-&gt;totalNodes   = btcb-&gt;totalNodes;
	bthp-&gt;freeNodes    = btcb-&gt;freeNodes;
	bthp-&gt;clumpSize    = cfork.cf_clump;
	bthp-&gt;btreeType    = 0xFF;
	bthp-&gt;attributes   = kBTVariableIndexKeysMask | kBTBigKeysMask;
	bthp-&gt;maxKeyLength = kHFSPlusAttrKeyMaximumLength;
	bthp-&gt;keyCompareType = kHFSBinaryCompare;
	offset += <span class="enscript-keyword">sizeof</span>(BTHeaderRec);
	index[(nodesize / 2) - 2] = offset;

	<span class="enscript-comment">/* FILL IN THE USER RECORD:  */</span>
	offset += kBTreeHeaderUserBytes;
	index[(nodesize / 2) - 3] = offset;

	<span class="enscript-comment">/* Mark the header node and map nodes in use in the map record.
	 *
	 * NOTE: Assumes that the header node's map record has at least
	 * (num_map_nodes + 1) bits.
	 */</span>
	bitmap = (u_int8_t *) buffer + offset;
	temp = num_map_nodes + 1;	<span class="enscript-comment">/* +1 for the header node */</span>
	<span class="enscript-keyword">while</span> (temp &gt;= 8) {
		*(bitmap++) = 0xFF;
		temp -= 8;
	}
	*bitmap = ~(0xFF &gt;&gt; temp);
	
	offset += nodesize - <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) - <span class="enscript-keyword">sizeof</span>(BTHeaderRec)
			   - kBTreeHeaderUserBytes - (4 * <span class="enscript-keyword">sizeof</span>(int16_t));
	index[(nodesize / 2) - 4] = offset;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		result = btree_journal_modify_block_end(hfsmp, bp);
	} <span class="enscript-keyword">else</span> {
		result = VNOP_BWRITE(bp);
	}
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Create the map nodes: node numbers 1 .. num_map_nodes */</span>
	<span class="enscript-keyword">for</span> (node_num=1; node_num &lt;= num_map_nodes; ++node_num) {
		bp = buf_getblk(vp, node_num, nodesize, 0, 0, BLK_META);
		<span class="enscript-keyword">if</span> (bp == NULL) {
			result = EIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		buffer = (<span class="enscript-type">void</span> *)buf_dataptr(bp);
		blkdesc.buffer = buffer;
		blkdesc.blockHeader = (<span class="enscript-type">void</span> *)bp;
		blkdesc.blockReadFromDisk = 0;
		blkdesc.isModified = 0;
	
		ModifyBlockStart(vp, &amp;blkdesc);
		
		bzero(buffer, nodesize);
		index = (u_int16_t *)buffer;
	
		<span class="enscript-comment">/* Fill in the node descriptor */</span>
		ndp = (BTNodeDescriptor *)buffer;
		<span class="enscript-keyword">if</span> (node_num != num_map_nodes)
			ndp-&gt;fLink = node_num + 1;
		ndp-&gt;kind = kBTMapNode;
		ndp-&gt;numRecords = 1;
		offset = <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor);
		index[(nodesize / 2) - 1] = offset;
	
	
		<span class="enscript-comment">/* Fill in the map record's offset */</span>
		<span class="enscript-comment">/* Note: We assume that the map record is all zeroes */</span>
		offset = <span class="enscript-keyword">sizeof</span>(BTNodeDescriptor) + bytes_per_map_record;
		index[(nodesize / 2) - 2] = offset;
	
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			result = btree_journal_modify_block_end(hfsmp, bp);
		} <span class="enscript-keyword">else</span> {
			result = VNOP_BWRITE(bp);
		}
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	
	<span class="enscript-comment">/* Update vp/cp for attribute btree */</span>
	hfs_lock_mount (hfsmp);
	hfsmp-&gt;hfs_attribute_cp = VTOC(vp);
	hfsmp-&gt;hfs_attribute_vp = vp;
	hfs_unlock_mount (hfsmp);

	(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);

	<span class="enscript-keyword">if</span> (intrans) {
		hfs_end_transaction(hfsmp);
		intrans = 0;
	}

	<span class="enscript-comment">/* Initialize the vnode for virtual attribute data file */</span>
	result = init_attrdata_vnode(hfsmp);
	<span class="enscript-keyword">if</span> (result) {
		printf(<span class="enscript-string">&quot;hfs_create_attr_btree: vol=%s init_attrdata_vnode() error=%d\n&quot;</span>, hfsmp-&gt;vcbVN, result); 
	}

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (vp) {
		hfs_unlock(VTOC(vp));
	}
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (btcb) {
			FREE (btcb, M_TEMP);
		}
		<span class="enscript-keyword">if</span> (vp) {
			vnode_put(vp);
		}
		<span class="enscript-comment">/* XXX need to give back blocks ? */</span>
	}
	<span class="enscript-keyword">if</span> (intrans) {
		hfs_end_transaction(hfsmp);
	}

	<span class="enscript-comment">/*
	 * All done, clear HFS_CREATING_BTREE, and wake up any sleepers.
	 */</span>
	hfs_lock_mount (hfsmp);
	hfsmp-&gt;hfs_flags &amp;= ~HFS_CREATING_BTREE;
	wakeup((caddr_t)&amp;hfsmp-&gt;hfs_attribute_cp);
	hfs_unlock_mount (hfsmp);

	<span class="enscript-keyword">return</span> (result);
}

</pre>
<hr />
</body></html>