<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_lookup.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_lookup.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *	  notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *	  notice, this list of conditions and the following disclaimer in the
 *	  documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *	  must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *	  may be used to endorse or promote products derived from this software
 *	  without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.	IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)hfs_lookup.c	1.0
 *	derived from @(#)ufs_lookup.c	8.15 (Berkeley) 6/16/95
 *
 *	(c) 1998-1999   Apple Computer, Inc.	 All Rights Reserved
 *	(c) 1990, 1992 	NeXT Computer, Inc.	All Rights Reserved
 *	
 *
 *	hfs_lookup.c -- code to handle directory traversal on HFS/HFS+ volume
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>


<span class="enscript-comment">/*	
 * FROM FREEBSD 3.1
 * Convert a component of a pathname into a pointer to a locked cnode.
 * This is a very central and rather complicated routine.
 * If the file system is not maintained in a strict tree hierarchy,
 * this can result in a deadlock situation (see comments in code below).
 *
 * The cnp-&gt;cn_nameiop argument is LOOKUP, CREATE, RENAME, or DELETE depending
 * on whether the name is to be looked up, created, renamed, or deleted.
 * When CREATE, RENAME, or DELETE is specified, information usable in
 * creating, renaming, or deleting a directory entry may be calculated.
 * Notice that these are the only operations that can affect the directory of the target.
 *
 * LOCKPARENT and WANTPARENT actually refer to the parent of the last item,
 * so if ISLASTCN is not set, they should be ignored. Also they are mutually exclusive, or
 * WANTPARENT really implies DONTLOCKPARENT. Either of them set means that the calling
 * routine wants to access the parent of the target, locked or unlocked.
 *
 * Keeping the parent locked as long as possible protects from other processes
 * looking up the same item, so it has to be locked until the cnode is totally finished
 *
 * hfs_cache_lookup() performs the following for us:
 *	check that it is a directory
 *	check accessibility of directory
 *	check for modification attempts on read-only mounts
 *	if name found in cache
 *		if at end of path and deleting or creating
 *		drop it
 *		 else
 *		return name.
 *	return hfs_lookup()
 *
 * Overall outline of hfs_lookup:
 *
 *	handle simple cases of . and ..
 *	search for name in directory, to found or notfound
 * notfound:
 *	if creating, return locked directory, leaving info on available slots
 *	else return error
 * found:
 *	if at end of path and deleting, return information to allow delete
 *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target
 *	  cnode and return info to allow rewrite
 *	if not at end, add name to cache; if at end and neither creating
 *	  nor deleting, add name to cache
 */</span>


<span class="enscript-comment">/*	
 *	Lookup *cnp in directory *dvp, return it in *vpp.
 *	**vpp is held on exit.
 *	We create a cnode for the file, but we do NOT open the file here.

#% lookup	dvp L ? ?
#% lookup	vpp - L -

	IN struct vnode *dvp - Parent node of file;
	INOUT struct vnode **vpp - node of target file, its a new node if
		the target vnode did not exist;
	IN struct componentname *cnp - Name of file;

 *	When should we lock parent_hp in here ??
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_lookup</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> *cnode_locked, <span class="enscript-type">int</span> force_casesensitive_lookup)
{
	<span class="enscript-type">struct</span> cnode *dcp;	<span class="enscript-comment">/* cnode for directory being searched */</span>
	<span class="enscript-type">struct</span> vnode *tvp;	<span class="enscript-comment">/* target vnode */</span>
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> flags;
	<span class="enscript-type">int</span> nameiop;
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> isDot;
	<span class="enscript-type">struct</span> cat_desc desc;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">struct</span> cat_attr attr;
	<span class="enscript-type">struct</span> cat_fork fork;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> newvnode_flags;

  <span class="enscript-reference">retry</span>:
	newvnode_flags = 0;
	dcp = NULL;
	hfsmp = VTOHFS(dvp);
	*vpp = NULL;
	*cnode_locked = 0;
	isDot = FALSE;
	tvp = NULL;
	nameiop = cnp-&gt;cn_nameiop;
	flags = cnp-&gt;cn_flags;
	bzero(&amp;desc, <span class="enscript-keyword">sizeof</span>(desc));

	<span class="enscript-comment">/*
	 * First check to see if it is a . or .., else look it up.
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; ISDOTDOT) {		<span class="enscript-comment">/* Wanting the parent */</span>
		cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;	<span class="enscript-comment">/* .. is always defined */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (cnp-&gt;cn_namelen == 1)) {
		isDot = TRUE;
		cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;	<span class="enscript-comment">/* We always know who we are */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (hfs_lock(VTOC(dvp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT) != 0) {
			retval = ENOENT;  <span class="enscript-comment">/* The parent no longer exists ? */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		dcp = VTOC(dvp);

		<span class="enscript-keyword">if</span> (dcp-&gt;c_flag &amp; C_DIR_MODIFICATION) {
		    <span class="enscript-comment">// XXXdbg - if we could msleep on a lck_rw_t then we would do that
</span>		    <span class="enscript-comment">//          but since we can't we have to unlock, delay for a bit
</span>		    <span class="enscript-comment">//          and then retry...
</span>		    <span class="enscript-comment">// msleep((caddr_t)&amp;dcp-&gt;c_flag, &amp;dcp-&gt;c_rwlock, PINOD, &quot;hfs_vnop_lookup&quot;, 0);
</span>		    hfs_unlock(dcp);
		    tsleep((caddr_t)dvp, PRIBIO, <span class="enscript-string">&quot;hfs_lookup&quot;</span>, 1);

		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}


		<span class="enscript-comment">/*
		 * We shouldn't need to go to the catalog if there are no children.
		 * However, in the face of a minor disk corruption where the valence of
		 * the directory is off, we could infinite loop here if we return ENOENT
		 * even though there are actually items in the directory.  (create will
		 * see the ENOENT, try to create something, which will return with 
		 * EEXIST over and over again).  As a result, always check the catalog.
		 */</span>

		bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
		cndesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
		cndesc.cd_namelen = cnp-&gt;cn_namelen;
		cndesc.cd_parentcnid = dcp-&gt;c_fileid;
		cndesc.cd_hint = dcp-&gt;c_childhint;

		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

		retval = cat_lookup(hfsmp, &amp;cndesc, 0, force_casesensitive_lookup, &amp;desc, &amp;attr, &amp;fork, NULL);
		
		hfs_systemfile_unlock(hfsmp, lockflags);

		<span class="enscript-keyword">if</span> (retval == 0) {
			dcp-&gt;c_childhint = desc.cd_hint;
			<span class="enscript-comment">/*
			 * Note: We must drop the parent lock here before calling
			 * hfs_getnewvnode (which takes the child lock).
			 */</span>
			hfs_unlock(dcp);
			dcp = NULL;
			
			<span class="enscript-comment">/* Verify that the item just looked up isn't one of the hidden directories. */</span>
			<span class="enscript-keyword">if</span> (desc.cd_cnid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
				desc.cd_cnid == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
				retval = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
			
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
		
		<span class="enscript-comment">/*
		 * ENAMETOOLONG supersedes other errors
		 *
		 * For a CREATE or RENAME operation on the last component
		 * the ENAMETOOLONG will be handled in the next VNOP.
		 */</span>
		<span class="enscript-keyword">if</span> ((retval != ENAMETOOLONG) &amp;&amp; 
		    (cnp-&gt;cn_namelen &gt; kHFSPlusMaxFileNameChars) &amp;&amp;
		    (((flags &amp; ISLASTCN) == 0) || ((nameiop != CREATE) &amp;&amp; (nameiop != RENAME)))) {
			retval = ENAMETOOLONG;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval == 0) {
			retval = ENOENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retval == ERESERVEDNAME) {
			<span class="enscript-comment">/*
			 * We found the name in the catalog, but it is unavailable
			 * to us. The exact error to return to our caller depends
			 * on the operation, and whether we've already reached the
			 * last path component. In all cases, avoid a negative
			 * cache entry, since someone else may be able to access
			 * the name if their lookup is configured differently.
			 */</span>

			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;

			<span class="enscript-keyword">if</span> (((flags &amp; ISLASTCN) == 0) || ((nameiop == LOOKUP) || (nameiop == DELETE))) {
				<span class="enscript-comment">/* A reserved name for a pure lookup is the same as the path not being present */</span>
				retval = ENOENT;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* A reserved name with intent to create must be rejected as impossible */</span>
				retval = EEXIST;
			}
		}
		<span class="enscript-keyword">if</span> (retval != ENOENT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		<span class="enscript-comment">/*
		 * This is a non-existing entry
		 *
		 * If creating, and at end of pathname and current
		 * directory has not been removed, then can consider
		 * allowing file to be created.
		 */</span>
		<span class="enscript-keyword">if</span> ((nameiop == CREATE || nameiop == RENAME) &amp;&amp;
		    (flags &amp; ISLASTCN) &amp;&amp;
		    !(ISSET(dcp-&gt;c_flag, C_DELETED | C_NOEXISTS))) {
			retval = EJUSTRETURN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-comment">/*
		 * Insert name into the name cache (as non-existent).
		 */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0 &amp;&amp;
		    (cnp-&gt;cn_flags &amp; MAKEENTRY) &amp;&amp;
		    (nameiop != CREATE)) {
			cache_enter(dvp, NULL, cnp);
			dcp-&gt;c_flag |= C_NEG_ENTRIES;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

<span class="enscript-reference">found</span>:
	<span class="enscript-keyword">if</span> (flags &amp; ISLASTCN) {
		<span class="enscript-keyword">switch</span>(nameiop) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DELETE</span>:
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">RENAME</span>:
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
			<span class="enscript-keyword">if</span> (isDot) {
				retval = EISDIR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (isDot) {
		<span class="enscript-keyword">if</span> ((retval = vnode_get(dvp)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		*vpp = dvp;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; ISDOTDOT) {
		<span class="enscript-comment">/*
		 * Directory hard links can have multiple parents so
		 * find the appropriate parent for the current thread.
		 */</span>
		<span class="enscript-keyword">if</span> ((retval = hfs_vget(hfsmp, hfs_currentparent(VTOC(dvp),
									<span class="enscript-comment">/* have_lock: */</span> false), &amp;tvp, 0, 0))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		*cnode_locked = 1;
		*vpp = tvp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> type = (attr.ca_mode &amp; S_IFMT);

		<span class="enscript-keyword">if</span> (!(flags &amp; ISLASTCN) &amp;&amp; (type != S_IFDIR) &amp;&amp; (type != S_IFLNK)) {
			retval = ENOTDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-comment">/* Don't cache directory hardlink names. */</span>
		<span class="enscript-keyword">if</span> (attr.ca_recflags &amp; kHFSHasLinkChainMask) {
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
		}
		<span class="enscript-comment">/* Names with composed chars are not cached. */</span>
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen != desc.cd_namelen)
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;

		retval = hfs_getnewvnode(hfsmp, dvp, cnp, &amp;desc, 0, &amp;attr, &amp;fork, &amp;tvp, &amp;newvnode_flags);

		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-comment">/*
			 * If this was a create/rename operation lookup, then by this point
			 * we expected to see the item returned from hfs_getnewvnode above.  
			 * In the create case, it would probably eventually bubble out an EEXIST 
			 * because the item existed when we were trying to create it.  In the 
			 * rename case, it would let us know that we need to go ahead and 
			 * delete it as part of the rename.  However, if we hit the condition below
			 * then it means that we found the element during cat_lookup above, but 
			 * it is now no longer there.  We simply behave as though we never found
			 * the element at all and return EJUSTRETURN.
			 */</span>  
			<span class="enscript-keyword">if</span> ((retval == ENOENT) &amp;&amp;
					((cnp-&gt;cn_nameiop == CREATE) || (cnp-&gt;cn_nameiop == RENAME)) &amp;&amp;
					(flags &amp; ISLASTCN)) {
				retval = EJUSTRETURN;
			}
			
			<span class="enscript-comment">/*
			 * If this was a straight lookup operation, we may need to redrive the entire 
			 * lookup starting from cat_lookup if the element was deleted as the result of 
			 * a rename operation.  Since rename is supposed to guarantee atomicity, then
			 * lookups cannot fail because the underlying element is deleted as a result of
			 * the rename call -- either they returned the looked up element prior to rename
			 * or return the newer element.  If we are in this region, then all we can do is add
			 * workarounds to guarantee the latter case. The element has already been deleted, so
			 * we just re-try the lookup to ensure the caller gets the most recent element.
			 */</span>
			<span class="enscript-keyword">if</span> ((retval == ENOENT) &amp;&amp; (cnp-&gt;cn_nameiop == LOOKUP) &amp;&amp;
				(newvnode_flags &amp; (GNV_CHASH_RENAMED | GNV_CAT_DELETED))) {
				<span class="enscript-keyword">if</span> (dcp) {
					hfs_unlock (dcp);
				}
				<span class="enscript-comment">/* get rid of any name buffers that may have lingered from the cat_lookup call */</span>
				cat_releasedesc (&amp;desc);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}

			<span class="enscript-comment">/* Also, re-drive the lookup if the item we looked up was a hardlink, and the number 
			 * or name of hardlinks has changed in the interim between the cat_lookup above, and
			 * our call to hfs_getnewvnode.  hfs_getnewvnode will validate the cattr we passed it
			 * against what is actually in the catalog after the cnode is created.  If there were
			 * any issues, it will bubble out ERECYCLE, which we need to swallow and use as the
			 * key to redrive as well.  We need to special case this below because in this case, 
			 * it needs to occur regardless of the type of lookup we're doing here.  
			 */</span>
			<span class="enscript-keyword">if</span> ((retval == ERECYCLE) &amp;&amp; (newvnode_flags &amp; GNV_CAT_ATTRCHANGED)) {
				<span class="enscript-keyword">if</span> (dcp) {
					hfs_unlock (dcp);
				}
				<span class="enscript-comment">/* get rid of any name buffers that may have lingered from the cat_lookup call */</span>
				cat_releasedesc (&amp;desc);
				retval = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}

			<span class="enscript-comment">/* skip to the error-handling code if we can't retry */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/* 
		 * Save the origin info for file and directory hardlinks.  Directory hardlinks 
		 * need the origin for '..' lookups, and file hardlinks need it to ensure that 
		 * competing lookups do not cause us to vend different hardlinks than the ones requested.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(VTOC(tvp)-&gt;c_flag, C_HARDLINK))
			hfs_savelinkorigin(VTOC(tvp), VTOC(dvp)-&gt;c_fileid);
		*cnode_locked = 1;
		*vpp = tvp;
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (dcp) {
		hfs_unlock(dcp);
	}
	cat_releasedesc(&amp;desc);
	<span class="enscript-keyword">return</span> (retval);
}



<span class="enscript-comment">/*
 * Name caching works as follows:
 *
 * Names found by directory scans are retained in a cache
 * for future reference.  It is managed LRU, so frequently
 * used names will hang around.	 Cache is indexed by hash value
 * obtained from (vp, name) where vp refers to the directory
 * containing name.
 *
 * If it is a &quot;negative&quot; entry, (i.e. for a name that is known NOT to
 * exist) the vnode pointer will be NULL.
 *
 * Upon reaching the last segment of a path, if the reference
 * is for DELETE, or NOCACHE is set (rewrite), and the
 * name is located in the cache, it will be dropped.
 *
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">S_IXALL</span>	0000111

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_lookup</span>(<span class="enscript-type">struct</span> vnop_lookup_args *ap)
{
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cnode *dcp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode **vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">int</span> flags = cnp-&gt;cn_flags;
	<span class="enscript-type">int</span> force_casesensitive_lookup = proc_is_forcing_hfs_case_sensitivity(p);
	<span class="enscript-type">int</span> cnode_locked;
	<span class="enscript-type">int</span> fastdev_candidate = 0;
	<span class="enscript-type">int</span> auto_candidate = 0;

	*vpp = NULL;
	dcp = VTOC(dvp);
	hfsmp = VTOHFS(dvp);

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN) &amp;&amp; (vnode_isfastdevicecandidate(dvp) || (dcp-&gt;c_attr.ca_recflags &amp; kHFSFastDevCandidateMask)) ){
		fastdev_candidate = 1;
		auto_candidate = (vnode_isautocandidate(dvp) || (dcp-&gt;c_attr.ca_recflags &amp; kHFSAutoCandidateMask));
	}
	

	<span class="enscript-comment">/*
	 * Lookup an entry in the cache
	 *
	 * If the lookup succeeds, the vnode is returned in *vpp,
	 * and a status of -1 is returned.
	 *
	 * If the lookup determines that the name does not exist
	 * (negative cacheing), a status of ENOENT is returned.
	 *
	 * If the lookup fails, a status of zero is returned.
	 */</span>
	error = cache_lookup(dvp, vpp, cnp);
	<span class="enscript-keyword">if</span> (error != -1) {
		<span class="enscript-keyword">if</span> ((error == ENOENT) &amp;&amp; (cnp-&gt;cn_nameiop != CREATE))		
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;	<span class="enscript-comment">/* found a negative cache entry */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;		<span class="enscript-comment">/* did not find it in the cache */</span>
	}
	<span class="enscript-comment">/*
	 * We have a name that matched
	 * cache_lookup returns the vp with an iocount reference already taken
	 */</span>
	error = 0;
	vp = *vpp;
	cp = VTOC(vp);
	
	<span class="enscript-comment">/* We aren't allowed to vend out vp's via lookup to the hidden directory */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_cnid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
		cp-&gt;c_cnid == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
		<span class="enscript-comment">/* Drop the iocount from cache_lookup */</span>
		vnode_put (vp);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	
	<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_recflags &amp; kHFSDoNotFastDevPinMask) {
		fastdev_candidate = 0;
	}

	<span class="enscript-comment">/*
	 * If this is a hard-link vnode then we need to update
	 * the name (of the link), the parent ID, the cnid, the
	 * text encoding and the catalog hint.  This enables
	 * getattrlist calls to return the correct link info.
	 */</span>

	<span class="enscript-comment">/*
	 * Alternatively, if we are forcing a case-sensitive lookup
	 * on a case-insensitive volume, the namecache entry
	 * may have been for an incorrect case. Since we cannot
	 * determine case vs. normalization, redrive the catalog
	 * lookup based on any byte mismatch.
	 */</span>
	<span class="enscript-keyword">if</span> (((flags &amp; ISLASTCN) &amp;&amp; (cp-&gt;c_flag &amp; C_HARDLINK))
		|| (force_casesensitive_lookup &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE))) {
		<span class="enscript-type">int</span> stale_link = 0;

		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);	
		<span class="enscript-keyword">if</span> ((cp-&gt;c_parentcnid != dcp-&gt;c_cnid) ||
		    (cnp-&gt;cn_namelen != cp-&gt;c_desc.cd_namelen) ||
		    (bcmp(cnp-&gt;cn_nameptr, cp-&gt;c_desc.cd_nameptr, cp-&gt;c_desc.cd_namelen) != 0)) {
			<span class="enscript-type">struct</span> cat_desc desc;
			<span class="enscript-type">struct</span> cat_attr lookup_attr;
			<span class="enscript-type">int</span> lockflags;

			<span class="enscript-keyword">if</span> (force_casesensitive_lookup &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE)) {
				<span class="enscript-comment">/*
				 * Since the name in the cnode doesn't match our lookup
				 * string exactly, do a full lookup.
				 */</span>
				hfs_unlock (cp);

				vnode_put(vp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;
			}

			<span class="enscript-comment">/*
			 * Get an updated descriptor
			 */</span>
			desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
			desc.cd_namelen = cnp-&gt;cn_namelen;
			desc.cd_parentcnid = dcp-&gt;c_fileid;
			desc.cd_hint = dcp-&gt;c_childhint;
			desc.cd_encoding = 0;
			desc.cd_cnid = 0;
			desc.cd_flags = S_ISDIR(cp-&gt;c_mode) ? CD_ISDIR : 0;

			<span class="enscript-comment">/*
			 * Because lookups call replace_desc to put a new descriptor in
			 * the cnode we are modifying it is possible that this cnode's 
			 * descriptor is out of date for the parent ID / name that
			 * we are trying to look up. (It may point to a different hardlink).
			 *
			 * We need to be cautious that when re-supplying the 
			 * descriptor below that the results of the catalog lookup
			 * still point to the same raw inode for the hardlink.  This would 
			 * not be the case if we found something in the cache above but 
			 * the vnode it returned no longer has a valid hardlink for the 
			 * parent ID/filename combo we are requesting.  (This is because 
			 * hfs_unlink does not directly trigger namecache removal). 
			 *
			 * As a result, before vending out the vnode (and replacing
			 * its descriptor) verify that the fileID is the same by comparing
			 * the in-cnode attributes vs. the one returned from the lookup call
			 * below.  If they do not match, treat this lookup as if we never hit
			 * in the cache at all.
			 */</span>

			lockflags = hfs_systemfile_lock(VTOHFS(dvp), SFL_CATALOG, HFS_SHARED_LOCK);		
		
			error = cat_lookup(VTOHFS(vp), &amp;desc, 0, 0, &amp;desc, &amp;lookup_attr, NULL, NULL);	
			
			hfs_systemfile_unlock(VTOHFS(dvp), lockflags);

			<span class="enscript-comment">/* 
			 * Note that cat_lookup may fail to find something with the name provided in the
			 * stack-based descriptor above. In that case, an ENOENT is a legitimate errno
			 * to be placed in error, which will get returned in the fastpath below.
			 */</span>
			<span class="enscript-keyword">if</span> (error == 0) {
				<span class="enscript-keyword">if</span> (lookup_attr.ca_fileid == cp-&gt;c_attr.ca_fileid) {
					<span class="enscript-comment">/* It still points to the right raw inode.  Replacing the descriptor is fine */</span>
					replace_desc (cp, &amp;desc);

					<span class="enscript-comment">/* 
					 * Save the origin info for file and directory hardlinks.  Directory hardlinks 
					 * need the origin for '..' lookups, and file hardlinks need it to ensure that 
					 * competing lookups do not cause us to vend different hardlinks than the ones requested.
					 */</span>
					hfs_savelinkorigin(cp, dcp-&gt;c_fileid);
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* If the fileID does not match then do NOT replace the descriptor! */</span>
					stale_link = 1;
				}	
			}
		}
		hfs_unlock (cp);
		
		<span class="enscript-keyword">if</span> (stale_link) {
			<span class="enscript-comment">/* 
			 * If we had a stale_link, then we need to pretend as though
			 * we never found this vnode and force a lookup through the 
			 * traditional path.  Drop the iocount acquired through 
			 * cache_lookup above and force a cat lookup / getnewvnode
			 */</span>
			vnode_put(vp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;
		}
		
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* 
			 * If the cat_lookup failed then the caller will not expect 
			 * a vnode with an iocount on it.
			 */</span>
			vnode_put(vp);
		}

	}	
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	
<span class="enscript-reference">lookup</span>:
	<span class="enscript-comment">/*
	 * The vnode was not in the name cache or it was stale.
	 *
	 * So we need to do a real lookup.
	 */</span>
	cnode_locked = 0;

	error = hfs_lookup(dvp, vpp, cnp, &amp;cnode_locked, force_casesensitive_lookup);
	
	<span class="enscript-keyword">if</span> (*vpp &amp;&amp; (VTOC(*vpp)-&gt;c_attr.ca_recflags &amp; kHFSDoNotFastDevPinMask)) {
		fastdev_candidate = 0;
	}

	<span class="enscript-keyword">if</span> (*vpp &amp;&amp; (VTOC(*vpp)-&gt;c_attr.ca_recflags &amp; kHFSAutoCandidateMask)) {
		<span class="enscript-comment">//printf(&quot;vp %s / %d is an auto-candidate\n&quot;, (*vpp)-&gt;v_name ? (*vpp)-&gt;v_name : &quot;no-name&quot;, VTOC(*vpp)-&gt;c_fileid);
</span>		auto_candidate = 1;
	}
	
	<span class="enscript-keyword">if</span> (cnode_locked)
		hfs_unlock(VTOC(*vpp));
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (*vpp &amp;&amp; fastdev_candidate &amp;&amp; (*vpp)-&gt;v_parent == dvp &amp;&amp; !(vnode_isfastdevicecandidate(*vpp))) {
		vnode_setfastdevicecandidate(*vpp);
		<span class="enscript-keyword">if</span> (auto_candidate) {
			vnode_setautocandidate(*vpp);
		}
	}

	{
	uthread_t ut = (<span class="enscript-type">struct</span> uthread *)get_bsdthread_info(current_thread());

	<span class="enscript-comment">/*
	 * check to see if we issued any I/O while completing this lookup and
	 * this thread/task is throttleable... if so, throttle now
	 *
	 * this allows us to throttle in between multiple meta data reads that
	 * might result due to looking up a long pathname (since we'll have to
	 * re-enter hfs_vnop_lookup for each component of the pathnam not in
	 * the VFS cache), instead of waiting until the entire path lookup has
	 * completed and throttling at the systemcall return
	 */</span>
	<span class="enscript-keyword">if</span> (__improbable(ut-&gt;uu_lowpri_window)) {
		throttle_lowpri_io(1);
	}
	}

	<span class="enscript-keyword">return</span> (error);
}


</pre>
<hr />
</body></html>