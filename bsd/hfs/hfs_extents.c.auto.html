<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_extents.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_extents.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_EXTENTS_TEST</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_extents_test.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_extents.h&quot;</span>

#<span class="enscript-reference">else</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_extents.h&quot;</span>

<span class="enscript-comment">// In this file, group refers to a set of 8 extents
</span>
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">hfs_total_blocks</span>(<span class="enscript-type">const</span> HFSPlusExtentDescriptor *ext, <span class="enscript-type">int</span> count);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_ext_iter_next_group</span>(<span class="enscript-type">struct</span> hfs_ext_iter *iter);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_ext_iter_update</span>(<span class="enscript-type">struct</span> hfs_ext_iter *iter,
								   HFSPlusExtentDescriptor *extents,
								   <span class="enscript-type">int</span> count,
								   HFSPlusExtentRecord cat_extents);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_ext_iter_check_group</span>(hfs_ext_iter_t *iter);

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK</span>(x, var, goto_label)									\
	<span class="enscript-keyword">do</span> {															\
		var = (x);													\
		<span class="enscript-keyword">if</span> (var) {													\
			printf(<span class="enscript-string">&quot;%s:%u error: %d\n&quot;</span>, __func__, __LINE__, var);	\
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">goto_label</span>;										\
		}															\
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">min</span>(a,b) \
	({ typeof (a) _a = (a); typeof (b) _b = (b); _a &lt; _b ? _a : _b; })

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((pure))
<span class="enscript-type">const</span> HFSPlusExtentKey *<span class="enscript-function-name">hfs_ext_iter_key</span>(<span class="enscript-type">const</span> hfs_ext_iter_t *iter)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">const</span> HFSPlusExtentKey *)&amp;iter-&gt;bt_iter.key;
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((pure))
HFSPlusExtentKey *<span class="enscript-function-name">hfs_ext_iter_key_mut</span>(hfs_ext_iter_t *iter)
{
	<span class="enscript-keyword">return</span> (HFSPlusExtentKey *)&amp;iter-&gt;bt_iter.key;
}

<span class="enscript-comment">// Returns the total number of blocks for the @count extents provided
</span>uint32_t <span class="enscript-function-name">hfs_total_blocks</span>(<span class="enscript-type">const</span> HFSPlusExtentDescriptor *extents, <span class="enscript-type">int</span> count)
{
	uint32_t block_count = 0;
	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; count; ++i)
		block_count += extents[i].blockCount;
	<span class="enscript-keyword">return</span> block_count;
}

<span class="enscript-comment">/*
 * Checks a group of extents: makes sure that if it's the last group
 * for a fork, that all the remaining extents are properly zeroed and
 * if it's not then checks that all extents are set.  This also sets
 * @group_block_count and @last_in_fork.  Returns ESTALE if
 * inconsistent.
 */</span>
errno_t <span class="enscript-function-name">hfs_ext_iter_check_group</span>(hfs_ext_iter_t *iter)
{
	filefork_t *ff = VTOF(iter-&gt;vp);
	<span class="enscript-type">const</span> HFSPlusExtentKey *key = hfs_ext_iter_key(iter);
	uint32_t count = 0;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
		<span class="enscript-keyword">if</span> (!iter-&gt;group[i].blockCount)
			<span class="enscript-keyword">break</span>;
		count += iter-&gt;group[i].blockCount;
	}

	<span class="enscript-keyword">if</span> (i &lt; kHFSPlusExtentDensity) {
		iter-&gt;last_in_fork = true;
		<span class="enscript-keyword">if</span> (key-&gt;startBlock + count != ff_allocblocks(ff))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-comment">// Check remainder of extents
</span>		<span class="enscript-keyword">for</span> (++i; i &lt; kHFSPlusExtentDensity; ++i) {
			<span class="enscript-keyword">if</span> (iter-&gt;group[i].blockCount)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (key-&gt;startBlock + count &gt; ff_allocblocks(ff))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		iter-&gt;last_in_fork = (key-&gt;startBlock + count == ff_allocblocks(ff));
	}

	iter-&gt;group_block_count = count;

	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	printf(<span class="enscript-string">&quot;hfs_ext_iter_check_group: bad group; start: %u, total blocks: %u\n&quot;</span>,
		   key-&gt;startBlock, ff_allocblocks(ff));

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> j = 0; j &lt; kHFSPlusExtentDensity; ++j) {
		printf(<span class="enscript-string">&quot;%s&lt;%u, %u&gt;&quot;</span>, j ? <span class="enscript-string">&quot;, &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
			   iter-&gt;group[j].startBlock, iter-&gt;group[j].blockCount);
	}

	printf(<span class="enscript-string">&quot;\n&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> ESTALE;
}

<span class="enscript-comment">// NOTE: doesn't copy group data
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_ext_iter_copy</span>(<span class="enscript-type">const</span> hfs_ext_iter_t *src, hfs_ext_iter_t *dst)
{
	dst-&gt;vp = src-&gt;vp;
	memcpy(&amp;dst-&gt;bt_iter.key, &amp;src-&gt;bt_iter.key, <span class="enscript-keyword">sizeof</span>(HFSPlusExtentKey));

	dst-&gt;file_block = src-&gt;file_block;
	dst-&gt;ndx = src-&gt;ndx;

	dst-&gt;bt_iter.hint			= src-&gt;bt_iter.hint;
	dst-&gt;bt_iter.version		= 0;
	dst-&gt;bt_iter.reserved		= 0;
	dst-&gt;bt_iter.hitCount		= 0;
	dst-&gt;bt_iter.maxLeafRecs	= 0;
}

bool <span class="enscript-function-name">hfs_ext_iter_is_catalog_extents</span>(hfs_ext_iter_t *iter)
{
	<span class="enscript-keyword">return</span> hfs_ext_iter_key(iter)-&gt;startBlock == 0;
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_EXTENTS_TEST</span>

<span class="enscript-comment">/*
 * Finds the extent for offset.  It might be in the catalog or the extents
 * file.
 */</span>
errno_t <span class="enscript-function-name">hfs_ext_find</span>(vnode_t vp, off_t offset, hfs_ext_iter_t *iter)
{
	errno_t ret;
	hfsmount_t *hfsmp = VTOHFS(vp);

	iter-&gt;vp = vp;

	uint32_t end_block, index;
	HFSPlusExtentKey *key = hfs_ext_iter_key_mut(iter);

	filefork_t *ff = VTOF(vp);

	CHECK(SearchExtentFile(hfsmp, ff, offset,
						   key, iter-&gt;group, &amp;index,
						   &amp;iter-&gt;bt_iter.hint.nodeNum, &amp;end_block), ret, exit);

	iter-&gt;ndx = index;
	iter-&gt;file_block = end_block - iter-&gt;group[index].blockCount;

	<span class="enscript-keyword">if</span> (!key-&gt;keyLength) {
		<span class="enscript-comment">// We're pointing at the catalog record extents so fix up the key
</span>		key-&gt;keyLength	= kHFSPlusExtentKeyMaximumLength;
		key-&gt;forkType	= (VNODE_IS_RSRC(iter-&gt;vp)
						   ? kHFSResourceForkType : kHFSDataForkType);
		key-&gt;pad		= 0;
		key-&gt;fileID		= VTOC(iter-&gt;vp)-&gt;c_fileid;
		key-&gt;startBlock = 0;
	}

	CHECK(hfs_ext_iter_check_group(iter), ret, exit);

	ret = 0;

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">return</span> MacToVFSError(ret);
}

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">hfs_ext_iter_next_group_block</span>(<span class="enscript-type">const</span> hfs_ext_iter_t *iter)
{
	<span class="enscript-type">const</span> HFSPlusExtentKey *key = hfs_ext_iter_key(iter);

	<span class="enscript-keyword">return</span> key-&gt;startBlock + iter-&gt;group_block_count;
}

<span class="enscript-comment">/*
 * Move the iterator to the next group.  Don't call if there's a chance
 * there is no entry; the caller should check last_in_fork instead.
 */</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_ext_iter_next_group</span>(hfs_ext_iter_t *iter)
{
	errno_t ret;
	hfsmount_t *hfsmp = VTOHFS(iter-&gt;vp);
	filefork_t * <span class="enscript-type">const</span> tree = hfsmp-&gt;hfs_extents_cp-&gt;c_datafork;
	HFSPlusExtentKey *key = hfs_ext_iter_key_mut(iter);
	<span class="enscript-type">const</span> bool catalog_extents = hfs_ext_iter_is_catalog_extents(iter);
	<span class="enscript-type">const</span> uint32_t next_block = hfs_ext_iter_next_group_block(iter);

	FSBufferDescriptor fbd = {
		.bufferAddress = &amp;iter-&gt;group,
		.itemCount = 1,
		.itemSize = <span class="enscript-keyword">sizeof</span>(iter-&gt;group)
	};

	<span class="enscript-keyword">if</span> (catalog_extents) {
		key-&gt;startBlock = next_block;

		CHECK(BTSearchRecord(tree, &amp;iter-&gt;bt_iter, &amp;fbd, NULL,
							 &amp;iter-&gt;bt_iter), ret, exit);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">const</span> uint32_t	 file_id = key-&gt;fileID;
		<span class="enscript-type">const</span> uint8_t 	 fork_type = key-&gt;forkType;

		CHECK(BTIterateRecord(tree, kBTreeNextRecord, &amp;iter-&gt;bt_iter,
							  &amp;fbd, NULL), ret, exit);

		<span class="enscript-keyword">if</span> (key-&gt;fileID != file_id
			|| key-&gt;forkType != fork_type
			|| key-&gt;startBlock != next_block) {
			<span class="enscript-comment">// This indicates an inconsistency
</span>			ret = ESTALE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	iter-&gt;file_block = key-&gt;startBlock;
	iter-&gt;ndx = 0;

	CHECK(hfs_ext_iter_check_group(iter), ret, exit);

	ret = 0;

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">return</span> MacToVFSError(ret);
}

<span class="enscript-comment">/*
 * Updates with the extents provided and sets the key up for the next group.
 * It is assumed that any previous record that might collide has been deleted.
 * NOTE: @extents must point to a buffer that can be zero padded to multiple
 * of 8 extents.
 */</span>
errno_t <span class="enscript-function-name">hfs_ext_iter_update</span>(hfs_ext_iter_t *iter,
							HFSPlusExtentDescriptor *extents,
							<span class="enscript-type">int</span> count,
							HFSPlusExtentRecord cat_extents)
{
	errno_t				 ret;
	hfsmount_t			*hfsmp	= VTOHFS(iter-&gt;vp);
	cnode_t				*cp		= VTOC(iter-&gt;vp);
	HFSPlusExtentKey	*key	= hfs_ext_iter_key_mut(iter);
	<span class="enscript-type">int</span>					 ndx	= 0;

	<span class="enscript-keyword">if</span> (!extents)
		extents = iter-&gt;group;

	<span class="enscript-keyword">if</span> (count % kHFSPlusExtentDensity) {
		<span class="enscript-comment">// Zero out last group
</span>		bzero(&amp;extents[count], (kHFSPlusExtentDensity
								- (count % 8)) * <span class="enscript-keyword">sizeof</span>(*extents));
	}

	<span class="enscript-keyword">if</span> (hfs_ext_iter_is_catalog_extents(iter)) {
		<span class="enscript-comment">// Caller is responsible for in-memory updates
</span>
		<span class="enscript-keyword">if</span> (cat_extents)
			hfs_ext_copy_rec(extents, cat_extents);

		<span class="enscript-type">struct</span> cat_fork fork;

		hfs_fork_copy(&amp;fork, &amp;VTOF(iter-&gt;vp)-&gt;ff_data, extents);
		hfs_prepare_fork_for_update(VTOF(iter-&gt;vp), &amp;fork, &amp;fork, hfsmp-&gt;blockSize);

		bool is_rsrc = VNODE_IS_RSRC(iter-&gt;vp);
		CHECK(cat_update(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr,
						 is_rsrc ? NULL : &amp;fork,
						 is_rsrc ? &amp;fork : NULL), ret, exit);

		<span class="enscript-comment">// Set the key to the next group
</span>		key-&gt;startBlock = hfs_total_blocks(extents, kHFSPlusExtentDensity);

		ndx += 8;
	}

	<span class="enscript-comment">// Deal with the remainder which must be overflow extents
</span>	<span class="enscript-keyword">for</span> (; ndx &lt; count; ndx += 8) {
		filefork_t * <span class="enscript-type">const</span> tree = hfsmp-&gt;hfs_extents_cp-&gt;c_datafork;

		FSBufferDescriptor fbd = {
			.bufferAddress = &amp;extents[ndx],
			.itemCount = 1,
			.itemSize = <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord)
		};

		CHECK(BTInsertRecord(tree, &amp;iter-&gt;bt_iter, &amp;fbd,
							 <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord)), ret, exit);

		<span class="enscript-comment">// Set the key to the next group
</span>		key-&gt;startBlock += hfs_total_blocks(&amp;extents[ndx], kHFSPlusExtentDensity);
	}

	ret = 0;

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">return</span> ret;
}

#<span class="enscript-reference">endif</span> // !<span class="enscript-variable-name">HFS_EXTENTS_TEST</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">push_ext</span>(HFSPlusExtentDescriptor *extents, <span class="enscript-type">int</span> *count,
					 <span class="enscript-type">const</span> HFSPlusExtentDescriptor *ext)
{
	<span class="enscript-keyword">if</span> (!ext-&gt;blockCount)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (*count &amp;&amp; hfs_ext_end(&amp;extents[*count - 1]) == ext-&gt;startBlock)
		extents[*count - 1].blockCount += ext-&gt;blockCount;
	<span class="enscript-keyword">else</span>
		extents[(*count)++] = *ext;
}

<span class="enscript-comment">/*
 * NOTE: Here we rely on the replacement extents not being too big as
 * otherwise the number of BTree records that we have to delete could be
 * too large.
 */</span>
errno_t <span class="enscript-function-name">hfs_ext_replace</span>(hfsmount_t *hfsmp, vnode_t vp,
						uint32_t file_block,
						<span class="enscript-type">const</span> HFSPlusExtentDescriptor *repl,
						<span class="enscript-type">int</span> repl_count,
						HFSPlusExtentRecord catalog_extents)
{
	errno_t						 ret;
	filefork_t * <span class="enscript-type">const</span>			 tree = hfsmp-&gt;hfs_extents_cp-&gt;c_datafork;
	hfs_ext_iter_t				*iter_in = NULL, *iter_out;
	HFSPlusExtentDescriptor		*extents = NULL;
	HFSPlusExtentDescriptor		*roll_back_extents = NULL;
	<span class="enscript-type">int</span>							 roll_back_count = 0;
	<span class="enscript-type">const</span> uint32_t				 end_file_block = file_block + hfs_total_blocks(repl, repl_count);
	filefork_t					*ff = VTOF(vp);

	<span class="enscript-comment">// Indicate we haven't touched catalog extents
</span>	catalog_extents[0].blockCount = 0;

	<span class="enscript-keyword">if</span> (end_file_block &gt; ff_allocblocks(ff)) {
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	MALLOC(iter_in, hfs_ext_iter_t *, <span class="enscript-keyword">sizeof</span>(*iter_in) * 2, M_TEMP, M_WAITOK);
	iter_out = iter_in + 1;
	HFSPlusExtentKey *key_in = hfs_ext_iter_key_mut(iter_in);

	<span class="enscript-comment">// Get to where we want to start
</span>	off_t offset = hfs_blk_to_bytes(file_block, hfsmp-&gt;blockSize);

	<span class="enscript-comment">/*
	 * If the replacement is at the start of a group, we want to pull in the
	 * group before so that we tidy up any padding that we might have done
	 * in a prior hfs_ext_replace call.
	 */</span>
	<span class="enscript-keyword">if</span> (offset &gt; 0)
		--offset;

	CHECK(hfs_ext_find(vp, offset, iter_in), ret, exit);

	<span class="enscript-type">const</span> uint32_t start_group_block = key_in-&gt;startBlock;

	<span class="enscript-type">const</span> <span class="enscript-type">int</span> max_roll_back_extents = 128 * 1024 / <span class="enscript-keyword">sizeof</span>(HFSPlusExtentDescriptor);
	MALLOC(roll_back_extents, HFSPlusExtentDescriptor *, 128 * 1024, M_TEMP, M_WAITOK);

	<span class="enscript-comment">// Move to the first extent in this group
</span>	iter_in-&gt;ndx = 0;

	hfs_ext_iter_copy(iter_in, iter_out);

	<span class="enscript-comment">// Create a buffer for our extents
</span>	<span class="enscript-type">const</span> <span class="enscript-type">int</span> buffered_extents = roundup(3 * kHFSPlusExtentDensity + repl_count,
										 kHFSPlusExtentDensity);
	MALLOC(extents, HFSPlusExtentDescriptor *,
		   <span class="enscript-keyword">sizeof</span>(*extents) * buffered_extents, M_TEMP, M_WAITOK);
	<span class="enscript-type">int</span> count = 0;

	<span class="enscript-comment">/*
	 * Iterate through the extents that are affected by this replace operation.
	 * We cannot push more than 16 + repl_count extents here; 8 for the group
	 * containing the replacement start, repl_count for the replacements and 8
	 * for the group containing the end.  If we went back a group due to
	 * decrementing the offset above, it's still the same because we know in 
	 * that case the replacement starts at the beginning of the next group.
	 */</span>
	uint32_t block = start_group_block;
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (!iter_in-&gt;ndx) {
			hfs_ext_copy_rec(iter_in-&gt;group, &amp;roll_back_extents[roll_back_count]);
			roll_back_count += kHFSPlusExtentDensity;

			<span class="enscript-keyword">if</span> (!hfs_ext_iter_is_catalog_extents(iter_in)) {
				<span class="enscript-comment">// Delete this extent group; we're going to replace it
</span>				CHECK(BTDeleteRecord(tree, &amp;iter_in-&gt;bt_iter), ret, exit);
			}
		}

		HFSPlusExtentDescriptor *ext = &amp;iter_in-&gt;group[iter_in-&gt;ndx];
		<span class="enscript-keyword">if</span> (!ext-&gt;blockCount) {
		    <span class="enscript-comment">/*
			 * We ran out of existing extents so we just write the
			 * extents and we're done.
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
		}

		<span class="enscript-comment">// If the current extent does not overlap replacement...
</span>		<span class="enscript-keyword">if</span> (block + ext-&gt;blockCount &lt;= file_block || block &gt;= end_file_block) {
			<span class="enscript-comment">// Keep the current extent exactly as it is
</span>			push_ext(extents, &amp;count, ext);
		} <span class="enscript-keyword">else</span> {
			HFSPlusExtentDescriptor dealloc_ext = *ext;

			<span class="enscript-keyword">if</span> (block &lt;= file_block) {
				<span class="enscript-comment">/*
				 * The middle or tail of the current extent overlaps
				 * the replacement extents.  Keep the non-overlapping
				 * head of the current extent.
				 */</span>
				uint32_t trimmed_len = file_block - block;

				<span class="enscript-keyword">if</span> (trimmed_len) {
					<span class="enscript-comment">// Push (keep) non-overlapping head of current extent
</span>					push_ext(extents, &amp;count,
							 &amp;(HFSPlusExtentDescriptor){ ext-&gt;startBlock,
								 trimmed_len });

					<span class="enscript-comment">/*
					 * Deallocate the part of the current extent that
					 * overlaps the replacement extents.  That starts
					 * at @file_block.  For now, assume it goes
					 * through the end of the current extent.  (If the
					 * current extent extends beyond the end of the
					 * replacement extents, we'll update the
					 * blockCount below.)
					 */</span>
					dealloc_ext.startBlock += trimmed_len;
					dealloc_ext.blockCount -= trimmed_len;
				}

				<span class="enscript-comment">// Insert the replacements
</span>				<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; repl_count; ++i)
					push_ext(extents, &amp;count, &amp;repl[i]);
			}

			<span class="enscript-keyword">if</span> (block + ext-&gt;blockCount &gt; end_file_block) {
				<span class="enscript-comment">/*
				 * The head or middle of the current extent overlaps
				 * the replacement extents.  Keep the non-overlapping
				 * tail of the current extent.
				 */</span>
				uint32_t overlap = end_file_block - block;

				<span class="enscript-comment">// Push (keep) non-overlapping tail of current extent
</span>				push_ext(extents, &amp;count,
						 &amp;(HFSPlusExtentDescriptor){ ext-&gt;startBlock + overlap,
							 ext-&gt;blockCount - overlap });

				<span class="enscript-comment">/*
				 * Deallocate the part of current extent that overlaps
				 * the replacements.
				 */</span>
				dealloc_ext.blockCount = (ext-&gt;startBlock + overlap
										  - dealloc_ext.startBlock);
			}

			CHECK(BlockDeallocate(hfsmp, dealloc_ext.startBlock,
								  dealloc_ext.blockCount, 0), ret, exit);
		}

		<span class="enscript-comment">// Move to next (existing) extent from iterator
</span>		block += ext-&gt;blockCount;

		<span class="enscript-keyword">if</span> (++iter_in-&gt;ndx &gt;= kHFSPlusExtentDensity) {
			<span class="enscript-keyword">if</span> (block &gt;= end_file_block) {
				<span class="enscript-keyword">if</span> (iter_in-&gt;last_in_fork || !(count % kHFSPlusExtentDensity)) {
					<span class="enscript-comment">/*
					 * This is the easy case.  We've hit the end or we have a 
					 * multiple of 8, so we can just write out the extents we 
					 * have and it should all fit within a transaction.
					 */</span>

					<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
				}

				<span class="enscript-keyword">if</span> (count + kHFSPlusExtentDensity &gt; buffered_extents
					|| (roll_back_count
						+ kHFSPlusExtentDensity &gt; max_roll_back_extents)) {
					<span class="enscript-comment">/*
					 * We've run out of room for the next group, so drop out
					 * and take a different strategy.
					 */</span>
					<span class="enscript-keyword">break</span>;
				}
			}

			CHECK(hfs_ext_iter_next_group(iter_in), ret, exit);
		}
	} <span class="enscript-comment">// for (;;)
</span>
	<span class="enscript-comment">/*
	 * We're not at the end so we need to try and pad to a multiple of 8
	 * so that we don't have to touch all the subsequent records.  We pad
	 * by stealing single blocks.
	 */</span>

	<span class="enscript-type">int</span> stop_at = 0;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">// @in points to the record we're stealing from
</span>		<span class="enscript-type">int</span> in = count - 1;

		count = roundup(count, kHFSPlusExtentDensity);

		<span class="enscript-comment">// @out is where we put the stolen single blocks
</span>		<span class="enscript-type">int</span> out = count - 1;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (out &lt;= in) {
				<span class="enscript-comment">// We suceeded in padding; we're done
</span>				<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
			}

			<span class="enscript-comment">/*
			 * &quot;Steal&quot; a block, or move a one-block extent within the
			 * @extents array.
			 *
			 * If the extent we're &quot;stealing&quot; from (@in) is only one
			 * block long, we'll end up copying it to @out, setting
			 * @in's blockCount to zero, and decrementing @in.  So, we
			 * either split a multi-block extent; or move it within
			 * the @extents array.
			 */</span>
			extents[out].blockCount = 1;
			extents[out].startBlock = (extents[in].startBlock
									   + extents[in].blockCount - 1);
			--out;
		} <span class="enscript-keyword">while</span> (--extents[in].blockCount || --in &gt;= stop_at);

		<span class="enscript-comment">// We ran out of extents
</span>		<span class="enscript-keyword">if</span> (roll_back_count + kHFSPlusExtentDensity &gt; max_roll_back_extents) {
			ret = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">// Need to shift extents starting at out + 1
</span>		++out;
		memmove(&amp;extents[stop_at], &amp;extents[out],
				(count - out) * <span class="enscript-keyword">sizeof</span>(*extents));
		count -= out - stop_at;

		<span class="enscript-comment">// Pull in the next group
</span>		CHECK(hfs_ext_iter_next_group(iter_in), ret, exit);

		<span class="enscript-comment">// Take a copy of these extents for roll back purposes
</span>		hfs_ext_copy_rec(iter_in-&gt;group, &amp;roll_back_extents[roll_back_count]);
		roll_back_count += kHFSPlusExtentDensity;

		<span class="enscript-comment">// Delete this group; we're going to replace it
</span>		CHECK(BTDeleteRecord(tree, &amp;iter_in-&gt;bt_iter), ret, exit);

		<span class="enscript-keyword">if</span> (iter_in-&gt;last_in_fork) {
			<span class="enscript-comment">// Great!  We've hit the end.  Coalesce and write out.
</span>			<span class="enscript-type">int</span> old_count = count;
			count = 0;

			<span class="enscript-comment">/*
			 * First coalesce the extents we already have.  Takes
			 * advantage of push_ext coalescing the input extent with
			 * the last extent in @extents.  If the extents are not
			 * contiguous, then this just copies the extents over
			 * themselves and sets @count back to @old_count.
			 */</span>
			<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; old_count; ++i)
				push_ext(extents, &amp;count, &amp;extents[i]);

			<span class="enscript-comment">// Make room if necessary
</span>			<span class="enscript-type">const</span> <span class="enscript-type">int</span> flush_count = buffered_extents - kHFSPlusExtentDensity;
			<span class="enscript-keyword">if</span> (count &gt; flush_count) {
				CHECK(hfs_ext_iter_update(iter_out, extents,
										  flush_count, catalog_extents), ret, exit);

				memmove(&amp;extents[0], &amp;extents[flush_count],
						(count - flush_count) * <span class="enscript-keyword">sizeof</span>(*extents));

				count -= flush_count;
			}

			<span class="enscript-comment">// Add in the extents we just read in
</span>			<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
				HFSPlusExtentDescriptor *ext = &amp;iter_in-&gt;group[i];
				<span class="enscript-keyword">if</span> (!ext-&gt;blockCount)
					<span class="enscript-keyword">break</span>;
				push_ext(extents, &amp;count, ext);
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
		} <span class="enscript-comment">// if (iter_in-&gt;last_in_fork)
</span>
		<span class="enscript-comment">/*
		 * Otherwise, we're not at the end, so we add these extents and then
		 * try and pad out again to a multiple of 8.  We start by making room.
		 */</span>
		<span class="enscript-keyword">if</span> (count &gt; buffered_extents - kHFSPlusExtentDensity) {
			<span class="enscript-comment">// Only write out one group here
</span>			CHECK(hfs_ext_iter_update(iter_out, extents,
									  kHFSPlusExtentDensity,
									  catalog_extents), ret, exit);

			memmove(&amp;extents[0], &amp;extents[kHFSPlusExtentDensity],
					(count - kHFSPlusExtentDensity) * <span class="enscript-keyword">sizeof</span>(*extents));

			count -= kHFSPlusExtentDensity;
		}

		<span class="enscript-comment">// Record where to stop when padding above
</span>		stop_at = count;

		<span class="enscript-comment">// Copy in the new extents
</span>		hfs_ext_copy_rec(iter_in-&gt;group, &amp;extents[count]);
		count += kHFSPlusExtentDensity;
	} <span class="enscript-comment">// for (;;)
</span>
<span class="enscript-reference">finish</span>:

	<span class="enscript-comment">// Write the remaining extents
</span>	CHECK(hfs_ext_iter_update(iter_out, extents, count,
							  catalog_extents), ret, exit);

	CHECK(BTFlushPath(hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork), ret, exit);
	CHECK(BTFlushPath(hfsmp-&gt;hfs_extents_cp-&gt;c_datafork), ret, exit);

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">if</span> (ret &amp;&amp; roll_back_count) {

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RB_FAILED</span>														\
	<span class="enscript-keyword">do</span> {																\
		printf(<span class="enscript-string">&quot;hfs_ext_replace:%u: roll back failed\n&quot;</span>, __LINE__);		\
		hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);				\
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">roll_back_failed</span>;											\
	} <span class="enscript-keyword">while</span> (0)

		<span class="enscript-comment">// First delete any groups we inserted
</span>		HFSPlusExtentKey *key_out = hfs_ext_iter_key_mut(iter_out);

		key_in-&gt;startBlock = start_group_block;
		<span class="enscript-keyword">if</span> (!key_in-&gt;startBlock &amp;&amp; key_out-&gt;startBlock &gt; key_in-&gt;startBlock) {
			key_in-&gt;startBlock += hfs_total_blocks(catalog_extents,
												   kHFSPlusExtentDensity);
		}

		<span class="enscript-keyword">if</span> (key_out-&gt;startBlock &gt; key_in-&gt;startBlock) {
			FSBufferDescriptor fbd = {
				.bufferAddress = &amp;iter_in-&gt;group,
				.itemCount = 1,
				.itemSize = <span class="enscript-keyword">sizeof</span>(iter_in-&gt;group)
			};

			<span class="enscript-keyword">if</span> (BTSearchRecord(tree, &amp;iter_in-&gt;bt_iter, &amp;fbd, NULL,
							   &amp;iter_in-&gt;bt_iter)) {
				RB_FAILED;
			}

			<span class="enscript-keyword">for</span> (;;) {
				<span class="enscript-keyword">if</span> (BTDeleteRecord(tree, &amp;iter_in-&gt;bt_iter))
					RB_FAILED;

				key_in-&gt;startBlock += hfs_total_blocks(iter_in-&gt;group,
													   kHFSPlusExtentDensity);

				<span class="enscript-keyword">if</span> (key_in-&gt;startBlock &gt;= key_out-&gt;startBlock)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">if</span> (BTSearchRecord(tree, &amp;iter_in-&gt;bt_iter, &amp;fbd, NULL,
								   &amp;iter_in-&gt;bt_iter)) {
					RB_FAILED;
				}
			}
		}

		<span class="enscript-comment">// Position iter_out
</span>		key_out-&gt;startBlock = start_group_block;

		<span class="enscript-comment">// Roll back all the extents
</span>		<span class="enscript-keyword">if</span> (hfs_ext_iter_update(iter_out, roll_back_extents, roll_back_count,
								catalog_extents)) {
			RB_FAILED;
		}

		<span class="enscript-comment">// And we need to reallocate the blocks we deallocated
</span>		<span class="enscript-type">const</span> uint32_t end_block = min(block, end_file_block);
		block = start_group_block;
		<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; roll_back_count &amp;&amp; block &lt; end_block; ++i) {
			HFSPlusExtentDescriptor *ext = &amp;roll_back_extents[i];

			<span class="enscript-keyword">if</span> (block + ext-&gt;blockCount &lt;= file_block)
				<span class="enscript-keyword">continue</span>;

			HFSPlusExtentDescriptor alloc_ext = *ext;

			<span class="enscript-keyword">if</span> (block &lt;= file_block) {
				uint32_t trimmed_len = file_block - block;

				alloc_ext.startBlock += trimmed_len;
				alloc_ext.blockCount -= trimmed_len;
			}

			<span class="enscript-keyword">if</span> (block + ext-&gt;blockCount &gt; end_file_block) {
				uint32_t overlap = end_file_block - block;

				alloc_ext.blockCount = (ext-&gt;startBlock + overlap
										- alloc_ext.startBlock);
			}

			<span class="enscript-keyword">if</span> (hfs_block_alloc(hfsmp, &amp;alloc_ext, HFS_ALLOC_ROLL_BACK, NULL))
				RB_FAILED;

			block += ext-&gt;blockCount;
		}

		<span class="enscript-keyword">if</span> (BTFlushPath(hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork)
			|| BTFlushPath(hfsmp-&gt;hfs_extents_cp-&gt;c_datafork)) {
			RB_FAILED;
		}
	} <span class="enscript-comment">// if (ret &amp;&amp; roll_back_count)
</span>
<span class="enscript-reference">roll_back_failed</span>:

	FREE(iter_in, M_TEMP);
	FREE(extents, M_TEMP);
	FREE(roll_back_extents, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(ret);
}
</pre>
<hr />
</body></html>