<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_readwrite.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_readwrite.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*	@(#)hfs_readwrite.c	1.0
 *
 *	(c) 1998-2001 Apple Computer, Inc.  All Rights Reserved
 *	
 *	hfs_readwrite.c -- vnode operations to deal with reading and writing files.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vfs_context.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs_attrlist.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span>  	<span class="enscript-string">&quot;hfs_fsctl.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs_quota.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfscommon/headers/FileMgrInternal.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfscommon/headers/BTreesInternal.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span>	<span class="enscript-string">&quot;hfs_dbg.h&quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">can_cluster</span>(size) ((((size &amp; (4096-1))) == 0) &amp;&amp; (size &lt;= (MAXPHYSIO/2)))

<span class="enscript-type">enum</span> {
	MAXHFSFILESIZE = 0x7FFFFFFF		<span class="enscript-comment">/* this needs to go in the mount structure */</span>
};

<span class="enscript-comment">/* from bsd/hfs/hfs_vfsops.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vfs_vget</span> (<span class="enscript-type">struct</span> mount *mp, ino64_t ino, <span class="enscript-type">struct</span> vnode **vpp, vfs_context_t context);

<span class="enscript-comment">/* from hfs_hotfiles.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_overflow_extents</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileid,
		                              uint8_t forktype, uint32_t *pinned);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_clonefile</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_clonesysfile</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, kauth_cred_t, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">do_hfs_truncate</span>(<span class="enscript-type">struct</span> vnode *vp, off_t length, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> skip, vfs_context_t context);

<span class="enscript-comment">/* from bsd/hfs/hfs_vnops.c */</span>
<span class="enscript-type">extern</span> decmpfs_cnode* <span class="enscript-function-name">hfs_lazy_init_decmpfs_cnode</span> (<span class="enscript-type">struct</span> cnode *cp);



<span class="enscript-type">int</span> flush_cache_on_write = 0;
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, flush_cache_on_write, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;flush_cache_on_write, 0, <span class="enscript-string">&quot;always flush the drive cache on writes to uncached files&quot;</span>);

<span class="enscript-comment">/*
 * Read data from a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_read</span>(<span class="enscript-type">struct</span> vnop_read_args *ap)
{
	<span class="enscript-comment">/*
	   struct vnop_read_args {
	   struct vnodeop_desc *a_desc;
	   vnode_t a_vp;
	   struct uio *a_uio;
	   int a_ioflag;
	   vfs_context_t a_context;
	   };
	 */</span>

	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	off_t filesize;
	off_t filebytes;
	off_t start_resid = uio_resid(uio);
	off_t offset = uio_offset(uio);
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> took_truncate_lock = 0;
	<span class="enscript-type">int</span> io_throttle = 0;
	<span class="enscript-type">int</span> throttled_count = 0;

	<span class="enscript-comment">/* Preflight checks */</span>
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
		<span class="enscript-comment">/* can only read regular files */</span>
		<span class="enscript-keyword">if</span> (vnode_isdir(vp))
			<span class="enscript-keyword">return</span> (EISDIR);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (EPERM);
	}
	<span class="enscript-keyword">if</span> (start_resid == 0)
		<span class="enscript-keyword">return</span> (0);		<span class="enscript-comment">/* Nothing left to do */</span>
	<span class="enscript-keyword">if</span> (offset &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* cant read from a negative offset */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
	<span class="enscript-keyword">if</span> ((ap-&gt;a_ioflag &amp; (IO_SKIP_ENCRYPTION|IO_SYSCALL_DISPATCH)) ==
						(IO_SKIP_ENCRYPTION|IO_SYSCALL_DISPATCH)) {
		<span class="enscript-comment">/* Don't allow unencrypted io request from user space */</span>
		<span class="enscript-keyword">return</span> EPERM;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-keyword">if</span> (hfs_hides_rsrc(ap-&gt;a_context, VTOC(vp), 1)) { <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-comment">/* otherwise read the resource fork normally */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> compressed = hfs_file_is_compressed(VTOC(vp), 1); <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
		<span class="enscript-keyword">if</span> (compressed) {
			retval = decmpfs_read_compressed(ap, &amp;compressed, VTOCMP(vp));
			<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; !(ap-&gt;a_ioflag &amp; IO_EVTONLY) &amp;&amp; vnode_isfastdevicecandidate(vp)) {
				(<span class="enscript-type">void</span>) hfs_addhotfile(vp);
			}
			<span class="enscript-keyword">if</span> (compressed) {
				<span class="enscript-keyword">if</span> (retval == 0) {
					<span class="enscript-comment">/* successful read, update the access time */</span>
					VTOC(vp)-&gt;c_touch_acctime = TRUE;
					
					<span class="enscript-comment">//
</span>					<span class="enscript-comment">// compressed files are not traditional hot file candidates
</span>					<span class="enscript-comment">// but they may be for CF (which ignores the ff_bytesread
</span>					<span class="enscript-comment">// field)
</span>					<span class="enscript-comment">//
</span>					<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;hfc_stage == HFC_RECORDING) {
						VTOF(vp)-&gt;ff_bytesread = 0;
					}
				}
				<span class="enscript-keyword">return</span> retval;
			}
			<span class="enscript-comment">/* otherwise the file was converted back to a regular file while we were reading it */</span>
			retval = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED)) {
			<span class="enscript-type">int</span> error;
			
			error = check_for_dataless_file(vp, NAMESPACE_HANDLER_READ_OP);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">return</span> error;
			}

		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>

	cp = VTOC(vp);
	fp = VTOF(vp);
	hfsmp = VTOHFS(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> ((retval = cp_handle_vnop (vp, CP_READ_ACCESS, ap-&gt;a_ioflag)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CONFIG_PROTECT</span>

	<span class="enscript-comment">/* 
	 * If this read request originated from a syscall (as opposed to 
	 * an in-kernel page fault or something), then set it up for 
	 * throttle checks
	 */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_ioflag &amp; IO_SYSCALL_DISPATCH) {
		io_throttle = IO_RETURN_ON_THROTTLE;
	}

<span class="enscript-reference">read_again</span>:

	<span class="enscript-comment">/* Protect against a size change. */</span>
	hfs_lock_truncate(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	took_truncate_lock = 1;

	filesize = fp-&gt;ff_size;
	filebytes = (off_t)fp-&gt;ff_blocks * (off_t)hfsmp-&gt;blockSize;

	<span class="enscript-comment">/*
	 * Check the file size. Note that per POSIX spec, we return 0 at 
	 * file EOF, so attempting a read at an offset that is too big
	 * should just return 0 on HFS+. Since the return value was initialized
	 * to 0 above, we just jump to exit.  HFS Standard has its own behavior.
	 */</span>
	<span class="enscript-keyword">if</span> (offset &gt; filesize) {
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) &amp;&amp;
		    (offset &gt; (off_t)MAXHFSFILESIZE)) {
			retval = EFBIG;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	KERNEL_DEBUG(HFSDBG_READ | DBG_FUNC_START,
		(<span class="enscript-type">int</span>)uio_offset(uio), uio_resid(uio), (<span class="enscript-type">int</span>)filesize, (<span class="enscript-type">int</span>)filebytes, 0);

	retval = cluster_read(vp, uio, filesize, ap-&gt;a_ioflag |io_throttle);

	cp-&gt;c_touch_acctime = TRUE;

	KERNEL_DEBUG(HFSDBG_READ | DBG_FUNC_END,
		(<span class="enscript-type">int</span>)uio_offset(uio), uio_resid(uio), (<span class="enscript-type">int</span>)filesize,  (<span class="enscript-type">int</span>)filebytes, 0);

	<span class="enscript-comment">/*
	 * Keep track blocks read
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_RECORDING &amp;&amp; retval == 0) {
		<span class="enscript-type">int</span> took_cnode_lock = 0;
		off_t bytesread;

		bytesread = start_resid - uio_resid(uio);

		<span class="enscript-comment">/* When ff_bytesread exceeds 32-bits, update it behind the cnode lock. */</span>
		<span class="enscript-keyword">if</span> ((fp-&gt;ff_bytesread + bytesread) &gt; 0x00000000ffffffff) {
			hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
			took_cnode_lock = 1;
		}
		<span class="enscript-comment">/*
		 * If this file hasn't been seen since the start of
		 * the current sampling period then start over.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_atime &lt; hfsmp-&gt;hfc_timebase) {
			<span class="enscript-type">struct</span> timeval tv;

			fp-&gt;ff_bytesread = bytesread;
			microtime(&amp;tv);
			cp-&gt;c_atime = tv.tv_sec;
		} <span class="enscript-keyword">else</span> {
			fp-&gt;ff_bytesread += bytesread;
		}

		<span class="enscript-keyword">if</span> (!(ap-&gt;a_ioflag &amp; IO_EVTONLY) &amp;&amp; vnode_isfastdevicecandidate(vp)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// We don't add hotfiles for processes doing IO_EVTONLY I/O
</span>			<span class="enscript-comment">// on the assumption that they're system processes such as
</span>			<span class="enscript-comment">// mdworker which scan everything in the system (and thus
</span>			<span class="enscript-comment">// do not represent user-initiated access to files)
</span>			<span class="enscript-comment">//
</span>			(<span class="enscript-type">void</span>) hfs_addhotfile(vp);
		}
		<span class="enscript-keyword">if</span> (took_cnode_lock)
			hfs_unlock(cp);
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}
	<span class="enscript-keyword">if</span> (retval == EAGAIN) {
		throttle_lowpri_io(1);
		throttled_count++;

		retval = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">read_again</span>;
	}
	<span class="enscript-keyword">if</span> (throttled_count) {
		throttle_info_reset_window((uthread_t)get_bsdthread_info(current_thread()));
	}
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Ideally, this wouldn't be necessary; the cluster code should be
 * able to handle this on the read-side.  See &lt;rdar://20420068&gt;.
 */</span>
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_zero_eof_page</span>(vnode_t vp, off_t zero_up_to)
{
	assert(VTOC(vp)-&gt;c_lockowner != current_thread());
	assert(VTOC(vp)-&gt;c_truncatelockowner == current_thread());

	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);

	<span class="enscript-keyword">if</span> (!(fp-&gt;ff_size &amp; PAGE_MASK_64) || zero_up_to &lt;= fp-&gt;ff_size) {
		<span class="enscript-comment">// Nothing to do
</span>		<span class="enscript-keyword">return</span> 0;
	}

	zero_up_to = MIN(zero_up_to, (off_t)round_page_64(fp-&gt;ff_size));

	<span class="enscript-comment">/* N.B. At present, @zero_up_to is not important because the cluster
	   code will always zero up to the end of the page anyway. */</span>
	<span class="enscript-keyword">return</span> cluster_write(vp, NULL, fp-&gt;ff_size, zero_up_to,
						 fp-&gt;ff_size, 0, IO_HEADZEROFILL);
}

<span class="enscript-comment">/*
 * Write data to a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_write</span>(<span class="enscript-type">struct</span> vnop_write_args *ap)
{
	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	kauth_cred_t cred = NULL;
	off_t origFileSize;
	off_t writelimit;
	off_t bytesToAdd = 0;
	off_t actualBytesAdded;
	off_t filebytes;
	off_t offset;
	ssize_t resid;
	<span class="enscript-type">int</span> eflags;
	<span class="enscript-type">int</span> ioflag = ap-&gt;a_ioflag;
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> cnode_locked = 0;
	<span class="enscript-type">int</span> partialwrite = 0;
	<span class="enscript-type">int</span> do_snapshot = 1;
	time_t orig_ctime=VTOC(vp)-&gt;c_ctime;
	<span class="enscript-type">int</span> took_truncate_lock = 0;
	<span class="enscript-type">int</span> io_return_on_throttle = 0;
	<span class="enscript-type">int</span> throttled_count = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> ( hfs_file_is_compressed(VTOC(vp), 1) ) { <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
		<span class="enscript-type">int</span> state = decmpfs_cnode_get_vnode_state(VTOCMP(vp));
		<span class="enscript-keyword">switch</span>(state) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
				<span class="enscript-keyword">return</span> EACCES;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
				<span class="enscript-comment">/* if FILE_IS_CONVERTING, we allow writes but do not
				   bother with snapshots or else we will deadlock.
				*/</span>
				do_snapshot = 0;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;invalid state %d for compressed file\n&quot;</span>, state);
				<span class="enscript-comment">/* fall through */</span>
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED)) {
		<span class="enscript-type">int</span> error;
		
		error = check_for_dataless_file(vp, NAMESPACE_HANDLER_WRITE_OP);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">return</span> error;
		}
	}

	<span class="enscript-keyword">if</span> (do_snapshot) {
		check_for_tracked_file(vp, orig_ctime, NAMESPACE_HANDLER_WRITE_OP, uio);
	}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
	<span class="enscript-keyword">if</span> ((ioflag &amp; (IO_SKIP_ENCRYPTION|IO_SYSCALL_DISPATCH)) ==
						(IO_SKIP_ENCRYPTION|IO_SYSCALL_DISPATCH)) {
		<span class="enscript-comment">/* Don't allow unencrypted io request from user space */</span>
		<span class="enscript-keyword">return</span> EPERM;
	}
#<span class="enscript-reference">endif</span>

	resid = uio_resid(uio);
	offset = uio_offset(uio);

	<span class="enscript-keyword">if</span> (offset &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (resid == 0)
		<span class="enscript-keyword">return</span> (E_NONE);
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp))
		<span class="enscript-keyword">return</span> (EPERM);  <span class="enscript-comment">/* Can only write regular files */</span>

	cp = VTOC(vp);
	fp = VTOF(vp);
	hfsmp = VTOHFS(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> ((retval = cp_handle_vnop (vp, CP_WRITE_ACCESS, 0)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
#<span class="enscript-reference">endif</span>

	eflags = kEFDeferMask;	<span class="enscript-comment">/* defer file block allocations */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
	<span class="enscript-comment">/* 
	 * When the underlying device is sparse and space
	 * is low (&lt; 8MB), stop doing delayed allocations
	 * and begin doing synchronous I/O.
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) &amp;&amp;
	    (hfs_freeblks(hfsmp, 0) &lt; 2048)) {
		eflags &amp;= ~kEFDeferMask;
		ioflag |= IO_SYNC;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_SPARSE_DEV */</span>

	<span class="enscript-keyword">if</span> ((ioflag &amp; (IO_SINGLE_WRITER | IO_SYSCALL_DISPATCH)) == 
			(IO_SINGLE_WRITER | IO_SYSCALL_DISPATCH)) {
		io_return_on_throttle = IO_RETURN_ON_THROTTLE;
	}

<span class="enscript-reference">again</span>:
	<span class="enscript-comment">/*
	 * Protect against a size change.
	 *
	 * Note: If took_truncate_lock is true, then we previously got the lock shared
	 * but needed to upgrade to exclusive.  So try getting it exclusive from the
	 * start.
	 */</span>
	<span class="enscript-keyword">if</span> (ioflag &amp; IO_APPEND || took_truncate_lock) {
		hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	}	
	<span class="enscript-keyword">else</span> {
		hfs_lock_truncate(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	}
	took_truncate_lock = 1;

	<span class="enscript-comment">/* Update UIO */</span>
	<span class="enscript-keyword">if</span> (ioflag &amp; IO_APPEND) {
		uio_setoffset(uio, fp-&gt;ff_size);
		offset = fp-&gt;ff_size;
	}
	<span class="enscript-keyword">if</span> ((cp-&gt;c_bsdflags &amp; APPEND) &amp;&amp; offset != fp-&gt;ff_size) {
		retval = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	cred = vfs_context_ucred(ap-&gt;a_context);
	<span class="enscript-keyword">if</span> (cred &amp;&amp; suser(cred, NULL) != 0)
		eflags |= kEFReserveMask;

	origFileSize = fp-&gt;ff_size;
	writelimit = offset + resid;

	<span class="enscript-comment">/*
	 * We may need an exclusive truncate lock for several reasons, all
	 * of which are because we may be writing to a (portion of a) block
	 * for the first time, and we need to make sure no readers see the
	 * prior, uninitialized contents of the block.  The cases are:
	 *
	 * 1. We have unallocated (delayed allocation) blocks.  We may be
	 *    allocating new blocks to the file and writing to them.
	 *    (A more precise check would be whether the range we're writing
	 *    to contains delayed allocation blocks.)
	 * 2. We need to extend the file.  The bytes between the old EOF
	 *    and the new EOF are not yet initialized.  This is important
	 *    even if we're not allocating new blocks to the file.  If the
	 *    old EOF and new EOF are in the same block, we still need to
	 *    protect that range of bytes until they are written for the
	 *    first time.
	 *
	 * If we had a shared lock with the above cases, we need to try to upgrade
	 * to an exclusive lock.  If the upgrade fails, we will lose the shared
	 * lock, and will need to take the truncate lock again; the took_truncate_lock
	 * flag will still be set, causing us to try for an exclusive lock next time.
	 */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;c_truncatelockowner == HFS_SHARED_OWNER) &amp;&amp;
	    ((fp-&gt;ff_unallocblocks != 0) ||
	     (writelimit &gt; origFileSize))) {
		<span class="enscript-keyword">if</span> (lck_rw_lock_shared_to_exclusive(&amp;cp-&gt;c_truncatelock) == FALSE) {
			<span class="enscript-comment">/*
			 * Lock upgrade failed and we lost our shared lock, try again.
			 * Note: we do not set took_truncate_lock=0 here.  Leaving it
			 * set to 1 will cause us to try to get the lock exclusive.
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		} 
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Store the owner in the c_truncatelockowner field if we successfully upgrade */</span>
			cp-&gt;c_truncatelockowner = current_thread();  
		}
	}

	<span class="enscript-keyword">if</span> ( (retval = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	cnode_locked = 1;

	filebytes = hfs_blk_to_bytes(fp-&gt;ff_blocks, hfsmp-&gt;blockSize);

	<span class="enscript-keyword">if</span> (offset &gt; filebytes
		&amp;&amp; (hfs_blk_to_bytes(hfs_freeblks(hfsmp, ISSET(eflags, kEFReserveMask)),
							 hfsmp-&gt;blockSize) &lt; offset - filebytes)) {
		retval = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	KERNEL_DEBUG(HFSDBG_WRITE | DBG_FUNC_START,
		     (<span class="enscript-type">int</span>)offset, uio_resid(uio), (<span class="enscript-type">int</span>)fp-&gt;ff_size,
		     (<span class="enscript-type">int</span>)filebytes, 0);

	<span class="enscript-comment">/* Check if we do not need to extend the file */</span>
	<span class="enscript-keyword">if</span> (writelimit &lt;= filebytes) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sizeok</span>;
	}

	bytesToAdd = writelimit - filebytes;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	retval = hfs_chkdq(cp, (int64_t)(roundup(bytesToAdd, hfsmp-&gt;blockSize)), 
			   cred, 0);
	<span class="enscript-keyword">if</span> (retval)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">while</span> (writelimit &gt; filebytes) {
		bytesToAdd = writelimit - filebytes;

		<span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
		lockflags = SFL_BITMAP;
		<span class="enscript-keyword">if</span> (overflow_extents(fp))
			lockflags |= SFL_EXTENTS;
		lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
	
		<span class="enscript-comment">/* Files that are changing size are not hot file candidates. */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_RECORDING) {
			fp-&gt;ff_bytesread = 0;
		}
		retval = MacToVFSError(ExtendFileC (hfsmp, (FCB*)fp, bytesToAdd,
				0, eflags, &amp;actualBytesAdded));

		hfs_systemfile_unlock(hfsmp, lockflags);

		<span class="enscript-keyword">if</span> ((actualBytesAdded == 0) &amp;&amp; (retval == E_NONE))
			retval = ENOSPC;
		<span class="enscript-keyword">if</span> (retval != E_NONE)
			<span class="enscript-keyword">break</span>;
		filebytes = (off_t)fp-&gt;ff_blocks * (off_t)hfsmp-&gt;blockSize;
		KERNEL_DEBUG(HFSDBG_WRITE | DBG_FUNC_NONE,
			(<span class="enscript-type">int</span>)offset, uio_resid(uio), (<span class="enscript-type">int</span>)fp-&gt;ff_size,  (<span class="enscript-type">int</span>)filebytes, 0);
	}
	(<span class="enscript-type">void</span>) hfs_update(vp, 0);
	(<span class="enscript-type">void</span>) hfs_volupdate(hfsmp, VOL_UPDATE, 0);
	(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);

	<span class="enscript-comment">/*
	 * If we didn't grow the file enough try a partial write.
	 * POSIX expects this behavior.
	 */</span>
	<span class="enscript-keyword">if</span> ((retval == ENOSPC) &amp;&amp; (filebytes &gt; offset)) {
		retval = 0;
		partialwrite = 1;
		uio_setresid(uio, (uio_resid(uio) - bytesToAdd));
		resid -= bytesToAdd;
		writelimit = filebytes;
	}
<span class="enscript-reference">sizeok</span>:
	<span class="enscript-keyword">if</span> (retval == E_NONE) {
		off_t filesize;
		off_t head_off;
		<span class="enscript-type">int</span> lflag;

		<span class="enscript-keyword">if</span> (writelimit &gt; fp-&gt;ff_size) {
			filesize = writelimit;
			<span class="enscript-type">struct</span> timeval tv;
			rl_add(fp-&gt;ff_size, writelimit - 1 , &amp;fp-&gt;ff_invalidranges);
			microuptime(&amp;tv);
			cp-&gt;c_zftimeout = tv.tv_sec + ZFTIMELIMIT;
		} <span class="enscript-keyword">else</span>
			filesize = fp-&gt;ff_size;

		lflag = ioflag &amp; ~(IO_TAILZEROFILL | IO_HEADZEROFILL | IO_NOZEROVALID | IO_NOZERODIRTY);

		<span class="enscript-comment">/*
		 * We no longer use IO_HEADZEROFILL or IO_TAILZEROFILL (except
		 * for one case below).  For the regions that lie before the
		 * beginning and after the end of this write that are in the
		 * same page, we let the cluster code handle zeroing that out
		 * if necessary.  If those areas are not cached, the cluster
		 * code will try and read those areas in, and in the case
		 * where those regions have never been written to,
		 * hfs_vnop_blockmap will consult the invalid ranges and then
		 * indicate that.  The cluster code will zero out those areas.
		 */</span>

		head_off = trunc_page_64(offset);

		<span class="enscript-keyword">if</span> (head_off &lt; offset &amp;&amp; head_off &gt;= fp-&gt;ff_size) {
			<span class="enscript-comment">/*
			 * The first page is beyond current EOF, so as an
			 * optimisation, we can pass IO_HEADZEROFILL.
			 */</span>
			lflag |= IO_HEADZEROFILL;
		}

		hfs_unlock(cp);
		cnode_locked = 0;

		<span class="enscript-comment">/*
		 * We need to tell UBC the fork's new size BEFORE calling
		 * cluster_write, in case any of the new pages need to be
		 * paged out before cluster_write completes (which does happen
		 * in embedded systems due to extreme memory pressure).
		 * Similarly, we need to tell hfs_vnop_pageout what the new EOF
		 * will be, so that it can pass that on to cluster_pageout, and
		 * allow those pageouts.
		 *
		 * We don't update ff_size yet since we don't want pageins to
		 * be able to see uninitialized data between the old and new
		 * EOF, until cluster_write has completed and initialized that
		 * part of the file.
		 *
		 * The vnode pager relies on the file size last given to UBC via
		 * ubc_setsize.  hfs_vnop_pageout relies on fp-&gt;ff_new_size or
		 * ff_size (whichever is larger).  NOTE: ff_new_size is always
		 * zero, unless we are extending the file via write.
		 */</span>
		<span class="enscript-keyword">if</span> (filesize &gt; fp-&gt;ff_size) {
			retval = hfs_zero_eof_page(vp, offset);
			<span class="enscript-keyword">if</span> (retval)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			fp-&gt;ff_new_size = filesize;
			ubc_setsize(vp, filesize);
		}
		retval = cluster_write(vp, uio, fp-&gt;ff_size, filesize, head_off,
							   0, lflag | IO_NOZERODIRTY | io_return_on_throttle);
		<span class="enscript-keyword">if</span> (retval) {
			fp-&gt;ff_new_size = 0;	<span class="enscript-comment">/* no longer extending; use ff_size */</span>
			
			<span class="enscript-keyword">if</span> (retval == EAGAIN) {
				<span class="enscript-comment">/*
				 * EAGAIN indicates that we still have I/O to do, but
				 * that we now need to be throttled
				 */</span>
				<span class="enscript-keyword">if</span> (resid != uio_resid(uio)) {
					<span class="enscript-comment">/*
					 * did manage to do some I/O before returning EAGAIN
					 */</span>
					resid = uio_resid(uio);
					offset = uio_offset(uio);

					cp-&gt;c_touch_chgtime = TRUE;
					cp-&gt;c_touch_modtime = TRUE;
					hfs_incr_gencount(cp);
				}
				<span class="enscript-keyword">if</span> (filesize &gt; fp-&gt;ff_size) {
					<span class="enscript-comment">/*
					 * we called ubc_setsize before the call to
					 * cluster_write... since we only partially
					 * completed the I/O, we need to 
					 * re-adjust our idea of the filesize based
					 * on our interim EOF
					 */</span>
					ubc_setsize(vp, offset);

					fp-&gt;ff_size = offset;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
			<span class="enscript-keyword">if</span> (filesize &gt; origFileSize) {
				ubc_setsize(vp, origFileSize);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ioerr_exit</span>;
		}
		
		<span class="enscript-keyword">if</span> (filesize &gt; origFileSize) {
			fp-&gt;ff_size = filesize;
			
			<span class="enscript-comment">/* Files that are changing size are not hot file candidates. */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_RECORDING) {
				fp-&gt;ff_bytesread = 0;
			}
		}
		fp-&gt;ff_new_size = 0;	<span class="enscript-comment">/* ff_size now has the correct size */</span>		
	}
	<span class="enscript-keyword">if</span> (partialwrite) {
		uio_setresid(uio, (uio_resid(uio) + bytesToAdd));
		resid += bytesToAdd;
	}

	<span class="enscript-comment">// XXXdbg - see radar 4871353 for more info
</span>	{
	    <span class="enscript-keyword">if</span> (flush_cache_on_write &amp;&amp; ((ioflag &amp; IO_NOCACHE) || vnode_isnocache(vp))) {
			hfs_flush(hfsmp, HFS_FLUSH_CACHE);
	    }
	}

<span class="enscript-reference">ioerr_exit</span>:
	<span class="enscript-keyword">if</span> (!cnode_locked) {
		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		cnode_locked = 1;
	}

	<span class="enscript-keyword">if</span> (resid &gt; uio_resid(uio)) {
		cp-&gt;c_touch_chgtime = TRUE;
		cp-&gt;c_touch_modtime = TRUE;
		hfs_incr_gencount(cp);

		<span class="enscript-comment">/*
		 * If we successfully wrote any data, and we are not the superuser
		 * we clear the setuid and setgid bits as a precaution against
		 * tampering.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_mode &amp; (S_ISUID | S_ISGID)) {
			cred = vfs_context_ucred(ap-&gt;a_context);
			<span class="enscript-keyword">if</span> (cred &amp;&amp; suser(cred, NULL)) {
				cp-&gt;c_mode &amp;= ~(S_ISUID | S_ISGID);
			}
		}
	}
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-keyword">if</span> (ioflag &amp; IO_UNIT) {
			(<span class="enscript-type">void</span>)hfs_truncate(vp, origFileSize, ioflag &amp; IO_SYNC,
			                   0, ap-&gt;a_context);
			uio_setoffset(uio, (uio_offset(uio) - (resid - uio_resid(uio))));
			uio_setresid(uio, resid);
			filebytes = (off_t)fp-&gt;ff_blocks * (off_t)hfsmp-&gt;blockSize;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ioflag &amp; IO_SYNC) &amp;&amp; (resid &gt; uio_resid(uio)))
		retval = hfs_update(vp, 0);

	<span class="enscript-comment">/* Updating vcbWrCnt doesn't need to be atomic. */</span>
	hfsmp-&gt;vcbWrCnt++;

	KERNEL_DEBUG(HFSDBG_WRITE | DBG_FUNC_END,
		(<span class="enscript-type">int</span>)uio_offset(uio), uio_resid(uio), (<span class="enscript-type">int</span>)fp-&gt;ff_size, (<span class="enscript-type">int</span>)filebytes, 0);
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (retval &amp;&amp; took_truncate_lock
		&amp;&amp; cp-&gt;c_truncatelockowner == current_thread()) {
		fp-&gt;ff_new_size = 0;
		rl_remove(fp-&gt;ff_size, RL_INFINITY, &amp;fp-&gt;ff_invalidranges);
	}

	<span class="enscript-keyword">if</span> (cnode_locked)
		hfs_unlock(cp);

	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}
	<span class="enscript-keyword">if</span> (retval == EAGAIN) {
		throttle_lowpri_io(1);
		throttled_count++;

		retval = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	<span class="enscript-keyword">if</span> (throttled_count) {
		throttle_info_reset_window((uthread_t)get_bsdthread_info(current_thread()));
	}
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/* support for the &quot;bulk-access&quot; fcntl */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CACHE_LEVELS</span> 16
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUM_CACHE_ENTRIES</span> (64*16)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PARENT_IDS_FLAG</span> 0x100

<span class="enscript-type">struct</span> access_cache {
       <span class="enscript-type">int</span> numcached;
       <span class="enscript-type">int</span> cachehits; <span class="enscript-comment">/* these two for statistics gathering */</span>
       <span class="enscript-type">int</span> lookups;
       <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *acache;
       <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *haveaccess;
};

<span class="enscript-type">struct</span> access_t {
	uid_t     uid;              <span class="enscript-comment">/* IN: effective user id */</span>
	<span class="enscript-type">short</span>     flags;            <span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	<span class="enscript-type">short</span>     num_groups;       <span class="enscript-comment">/* IN: number of groups user belongs to */</span>
	<span class="enscript-type">int</span>       num_files;        <span class="enscript-comment">/* IN: number of files to process */</span>
	<span class="enscript-type">int</span>       *file_ids;        <span class="enscript-comment">/* IN: array of file ids */</span>
	gid_t     *groups;          <span class="enscript-comment">/* IN: array of groups */</span>
	<span class="enscript-type">short</span>     *access;          <span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
} __attribute__((unavailable)); <span class="enscript-comment">// this structure is for reference purposes only
</span>
<span class="enscript-type">struct</span> user32_access_t {
	uid_t     uid;              <span class="enscript-comment">/* IN: effective user id */</span>
	<span class="enscript-type">short</span>     flags;            <span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	<span class="enscript-type">short</span>     num_groups;       <span class="enscript-comment">/* IN: number of groups user belongs to */</span>
	<span class="enscript-type">int</span>       num_files;        <span class="enscript-comment">/* IN: number of files to process */</span>
	user32_addr_t      file_ids;        <span class="enscript-comment">/* IN: array of file ids */</span>
	user32_addr_t      groups;          <span class="enscript-comment">/* IN: array of groups */</span>
	user32_addr_t      access;          <span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
};

<span class="enscript-type">struct</span> user64_access_t {
	uid_t		uid;			<span class="enscript-comment">/* IN: effective user id */</span>
	<span class="enscript-type">short</span>		flags;			<span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	<span class="enscript-type">short</span>		num_groups;		<span class="enscript-comment">/* IN: number of groups user belongs to */</span>
	<span class="enscript-type">int</span>		num_files;		<span class="enscript-comment">/* IN: number of files to process */</span>
	user64_addr_t	file_ids;		<span class="enscript-comment">/* IN: array of file ids */</span>
	user64_addr_t	groups;			<span class="enscript-comment">/* IN: array of groups */</span>
	user64_addr_t	access;			<span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
};


<span class="enscript-comment">// these are the &quot;extended&quot; versions of the above structures
</span><span class="enscript-comment">// note that it is crucial that they be different sized than
</span><span class="enscript-comment">// the regular version
</span><span class="enscript-type">struct</span> ext_access_t {
	uint32_t   flags;           <span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	uint32_t   num_files;       <span class="enscript-comment">/* IN: number of files to process */</span>
	uint32_t   map_size;        <span class="enscript-comment">/* IN: size of the bit map */</span>
	uint32_t  *file_ids;        <span class="enscript-comment">/* IN: Array of file ids */</span>
	<span class="enscript-type">char</span>      *bitmap;          <span class="enscript-comment">/* OUT: hash-bitmap of interesting directory ids */</span>
	<span class="enscript-type">short</span>     *access;          <span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
	uint32_t   num_parents;   <span class="enscript-comment">/* future use */</span>
	cnid_t      *parents;   <span class="enscript-comment">/* future use */</span>
} __attribute__((unavailable)); <span class="enscript-comment">// this structure is for reference purposes only
</span>
<span class="enscript-type">struct</span> user32_ext_access_t {
	uint32_t   flags;           <span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	uint32_t   num_files;       <span class="enscript-comment">/* IN: number of files to process */</span>
	uint32_t   map_size;        <span class="enscript-comment">/* IN: size of the bit map */</span>
	user32_addr_t  file_ids;        <span class="enscript-comment">/* IN: Array of file ids */</span>
	user32_addr_t     bitmap;          <span class="enscript-comment">/* OUT: hash-bitmap of interesting directory ids */</span>
	user32_addr_t access;          <span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
	uint32_t   num_parents;   <span class="enscript-comment">/* future use */</span>
	user32_addr_t parents;   <span class="enscript-comment">/* future use */</span>
};

<span class="enscript-type">struct</span> user64_ext_access_t {
	uint32_t      flags;        <span class="enscript-comment">/* IN: access requested (i.e. R_OK) */</span>
	uint32_t      num_files;    <span class="enscript-comment">/* IN: number of files to process */</span>
	uint32_t      map_size;     <span class="enscript-comment">/* IN: size of the bit map */</span>
	user64_addr_t   file_ids;     <span class="enscript-comment">/* IN: array of file ids */</span>
	user64_addr_t   bitmap;       <span class="enscript-comment">/* IN: array of groups */</span>
	user64_addr_t   access;       <span class="enscript-comment">/* OUT: access info for each file (0 for 'has access') */</span>
	uint32_t      num_parents;<span class="enscript-comment">/* future use */</span>
	user64_addr_t   parents;<span class="enscript-comment">/* future use */</span>
};


<span class="enscript-comment">/*
 * Perform a binary search for the given parent_id. Return value is 
 * the index if there is a match.  If no_match_indexp is non-NULL it
 * will be assigned with the index to insert the item (even if it was
 * not found).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cache_binSearch</span>(cnid_t *array, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hi, cnid_t parent_id, <span class="enscript-type">int</span> *no_match_indexp)
{
    <span class="enscript-type">int</span> index=-1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> lo=0;
	
    <span class="enscript-keyword">do</span> {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mid = ((hi - lo)/2) + lo;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> this_id = array[mid];
		
	<span class="enscript-keyword">if</span> (parent_id == this_id) {
	    hi = mid;
	    <span class="enscript-keyword">break</span>;
	}
		
	<span class="enscript-keyword">if</span> (parent_id &lt; this_id) {
	    hi = mid;
	    <span class="enscript-keyword">continue</span>;
	}
		
	<span class="enscript-keyword">if</span> (parent_id &gt; this_id) {
	    lo = mid + 1;
	    <span class="enscript-keyword">continue</span>;
	}
    } <span class="enscript-keyword">while</span>(lo &lt; hi);

    <span class="enscript-comment">/* check if lo and hi converged on the match */</span>
    <span class="enscript-keyword">if</span> (parent_id == array[hi]) {
	index = hi;
    }
	
    <span class="enscript-keyword">if</span> (no_match_indexp) {
	*no_match_indexp = hi;
    }

    <span class="enscript-keyword">return</span> index;
}
 
 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lookup_bucket</span>(<span class="enscript-type">struct</span> access_cache *cache, <span class="enscript-type">int</span> *indexp, cnid_t parent_id)
{
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> hi;
    <span class="enscript-type">int</span> matches = 0;
    <span class="enscript-type">int</span> index, no_match_index;
	
    <span class="enscript-keyword">if</span> (cache-&gt;numcached == 0) {
	*indexp = 0;
	<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">// table is empty, so insert at index=0 and report no match
</span>    }
	
    <span class="enscript-keyword">if</span> (cache-&gt;numcached &gt; NUM_CACHE_ENTRIES) {
	cache-&gt;numcached = NUM_CACHE_ENTRIES;
    }
	
    hi = cache-&gt;numcached - 1;
	
    index = cache_binSearch(cache-&gt;acache, hi, parent_id, &amp;no_match_index);

    <span class="enscript-comment">/* if no existing entry found, find index for new one */</span>
    <span class="enscript-keyword">if</span> (index == -1) {
	index = no_match_index;
	matches = 0;
    } <span class="enscript-keyword">else</span> {
	matches = 1;
    }
	
    *indexp = index;
    <span class="enscript-keyword">return</span> matches;
}

<span class="enscript-comment">/*
 * Add a node to the access_cache at the given index (or do a lookup first
 * to find the index if -1 is passed in). We currently do a replace rather
 * than an insert if the cache is full.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">add_node</span>(<span class="enscript-type">struct</span> access_cache *cache, <span class="enscript-type">int</span> index, cnid_t nodeID, <span class="enscript-type">int</span> access)
{
    <span class="enscript-type">int</span> lookup_index = -1;

    <span class="enscript-comment">/* need to do a lookup first if -1 passed for index */</span>
    <span class="enscript-keyword">if</span> (index == -1) {
	<span class="enscript-keyword">if</span> (lookup_bucket(cache, &amp;lookup_index, nodeID)) {
	    <span class="enscript-keyword">if</span> (cache-&gt;haveaccess[lookup_index] != access &amp;&amp; cache-&gt;haveaccess[lookup_index] == ESRCH) {
		<span class="enscript-comment">// only update an entry if the previous access was ESRCH (i.e. a scope checking error)
</span>		cache-&gt;haveaccess[lookup_index] = access;
	    }

	    <span class="enscript-comment">/* mission accomplished */</span>
	    <span class="enscript-keyword">return</span>;
	} <span class="enscript-keyword">else</span> {
	    index = lookup_index;
	}

    }

    <span class="enscript-comment">/* if the cache is full, do a replace rather than an insert */</span>
    <span class="enscript-keyword">if</span> (cache-&gt;numcached &gt;= NUM_CACHE_ENTRIES) {
	cache-&gt;numcached = NUM_CACHE_ENTRIES-1;

	<span class="enscript-keyword">if</span> (index &gt; cache-&gt;numcached) {
	    index = cache-&gt;numcached;
	}
    }

    <span class="enscript-keyword">if</span> (index &lt; cache-&gt;numcached &amp;&amp; index &lt; NUM_CACHE_ENTRIES &amp;&amp; nodeID &gt; cache-&gt;acache[index]) {
	index++;
    }

    <span class="enscript-keyword">if</span> (index &gt;= 0 &amp;&amp; index &lt; cache-&gt;numcached) {
	<span class="enscript-comment">/* only do bcopy if we're inserting */</span>
	bcopy( cache-&gt;acache+index, cache-&gt;acache+(index+1), (cache-&gt;numcached - index)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) );
	bcopy( cache-&gt;haveaccess+index, cache-&gt;haveaccess+(index+1), (cache-&gt;numcached - index)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) );
    }

    cache-&gt;acache[index] = nodeID;
    cache-&gt;haveaccess[index] = access;
    cache-&gt;numcached++;
}


<span class="enscript-type">struct</span> cinfo {
    uid_t   uid;
    gid_t   gid;
    mode_t  mode;
    cnid_t  parentcnid;
    u_int16_t recflags;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">snoop_callback</span>(<span class="enscript-type">const</span> cnode_t *cp, <span class="enscript-type">void</span> *arg)
{
    <span class="enscript-type">struct</span> cinfo *cip = arg;

    cip-&gt;uid = cp-&gt;c_uid;
    cip-&gt;gid = cp-&gt;c_gid;
    cip-&gt;mode = cp-&gt;c_mode;
    cip-&gt;parentcnid = cp-&gt;c_parentcnid;
    cip-&gt;recflags = cp-&gt;c_attr.ca_recflags;
	
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Lookup the cnid's attr info (uid, gid, and mode) as well as its parent id. If the item
 * isn't incore, then go to the catalog.
 */</span> 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_attr_lookup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> access_cache *cache, cnid_t cnid, 
    <span class="enscript-type">struct</span> cnode *skip_cp, CatalogKey *keyp, <span class="enscript-type">struct</span> cat_attr *cnattrp)
{
    <span class="enscript-type">int</span> error = 0;

    <span class="enscript-comment">/* if this id matches the one the fsctl was called with, skip the lookup */</span>
    <span class="enscript-keyword">if</span> (cnid == skip_cp-&gt;c_cnid) {
		cnattrp-&gt;ca_uid = skip_cp-&gt;c_uid;
		cnattrp-&gt;ca_gid = skip_cp-&gt;c_gid;
		cnattrp-&gt;ca_mode = skip_cp-&gt;c_mode;
		cnattrp-&gt;ca_recflags = skip_cp-&gt;c_attr.ca_recflags;
		keyp-&gt;hfsPlus.parentID = skip_cp-&gt;c_parentcnid;
    } <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> cinfo c_info;

		<span class="enscript-comment">/* otherwise, check the cnode hash incase the file/dir is incore */</span>
		error = hfs_chash_snoop(hfsmp, cnid, 0, snoop_callback, &amp;c_info);

		<span class="enscript-keyword">if</span> (error == EACCES) {
			<span class="enscript-comment">// File is deleted
</span>			<span class="enscript-keyword">return</span> ENOENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
			cnattrp-&gt;ca_uid = c_info.uid;
			cnattrp-&gt;ca_gid = c_info.gid;
			cnattrp-&gt;ca_mode = c_info.mode;
			cnattrp-&gt;ca_recflags = c_info.recflags;
			keyp-&gt;hfsPlus.parentID = c_info.parentcnid;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> lockflags;

			<span class="enscript-keyword">if</span> (throttle_io_will_be_throttled(-1, HFSTOVFS(hfsmp)))
				throttle_lowpri_io(1);

			lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

			<span class="enscript-comment">/* lookup this cnid in the catalog */</span>
			error = cat_getkeyplusattr(hfsmp, cnid, keyp, cnattrp);
			
			hfs_systemfile_unlock(hfsmp, lockflags);
			
			cache-&gt;lookups++;
		}
    }
	
    <span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Compute whether we have access to the given directory (nodeID) and all its parents. Cache
 * up to CACHE_LEVELS as we progress towards the root.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">do_access_check</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> *err, <span class="enscript-type">struct</span> access_cache *cache, HFSCatalogNodeID nodeID, 
    <span class="enscript-type">struct</span> cnode *skip_cp, <span class="enscript-type">struct</span> proc *theProcPtr, kauth_cred_t myp_ucred,
    <span class="enscript-type">struct</span> vfs_context *my_context,
    <span class="enscript-type">char</span> *bitmap,
    uint32_t map_size,
    cnid_t* parents,
    uint32_t num_parents)
{
    <span class="enscript-type">int</span>                     myErr = 0;
    <span class="enscript-type">int</span>                     myResult;
    HFSCatalogNodeID        thisNodeID;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>            myPerms;
    <span class="enscript-type">struct</span> cat_attr         cnattr;
    <span class="enscript-type">int</span>                     cache_index = -1, scope_index = -1, scope_idx_start = -1;
    CatalogKey              catkey;

    <span class="enscript-type">int</span> i = 0, ids_to_cache = 0;
    <span class="enscript-type">int</span> parent_ids[CACHE_LEVELS];

    thisNodeID = nodeID;
    <span class="enscript-keyword">while</span> (thisNodeID &gt;=  kRootDirID) {
	myResult = 0;   <span class="enscript-comment">/* default to &quot;no access&quot; */</span>
	       
	<span class="enscript-comment">/* check the cache before resorting to hitting the catalog */</span>

	<span class="enscript-comment">/* ASSUMPTION: access info of cached entries is &quot;final&quot;... i.e. no need
	 * to look any further after hitting cached dir */</span>

	<span class="enscript-keyword">if</span> (lookup_bucket(cache, &amp;cache_index, thisNodeID)) {
	    cache-&gt;cachehits++;
	    myErr = cache-&gt;haveaccess[cache_index];
	    <span class="enscript-keyword">if</span> (scope_index != -1) {
		<span class="enscript-keyword">if</span> (myErr == ESRCH) {
		    myErr = 0;
		}
	    } <span class="enscript-keyword">else</span> {
		scope_index = 0;   <span class="enscript-comment">// so we'll just use the cache result 
</span>		scope_idx_start = ids_to_cache;
	    }
	    myResult = (myErr == 0) ? 1 : 0;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}


	<span class="enscript-keyword">if</span> (parents) {
	    <span class="enscript-type">int</span> tmp;
	    tmp = cache_binSearch(parents, num_parents-1, thisNodeID, NULL);
	    <span class="enscript-keyword">if</span> (scope_index == -1)
		scope_index = tmp;
	    <span class="enscript-keyword">if</span> (tmp != -1 &amp;&amp; scope_idx_start == -1 &amp;&amp; ids_to_cache &lt; CACHE_LEVELS) {
		scope_idx_start = ids_to_cache;
	    }
	}	   

	<span class="enscript-comment">/* remember which parents we want to cache */</span>
	<span class="enscript-keyword">if</span> (ids_to_cache &lt; CACHE_LEVELS) {
	    parent_ids[ids_to_cache] = thisNodeID;
	    ids_to_cache++;
	}
	<span class="enscript-comment">// Inefficient (using modulo) and we might want to use a hash function, not rely on the node id to be &quot;nice&quot;...
</span>	<span class="enscript-keyword">if</span> (bitmap &amp;&amp; map_size) {
	    bitmap[(thisNodeID/8)%(map_size)]|=(1&lt;&lt;(thisNodeID&amp;7));	       
	}
	       

	<span class="enscript-comment">/* do the lookup (checks the cnode hash, then the catalog) */</span>
	myErr = do_attr_lookup(hfsmp, cache, thisNodeID, skip_cp, &amp;catkey, &amp;cnattr);
	<span class="enscript-keyword">if</span> (myErr) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>; <span class="enscript-comment">/* no access */</span>
	}

	<span class="enscript-comment">/* Root always gets access. */</span>
	<span class="enscript-keyword">if</span> (suser(myp_ucred, NULL) == 0) {
		thisNodeID = catkey.hfsPlus.parentID;
		myResult = 1;
		<span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">// if the thing has acl's, do the full permission check
</span>	<span class="enscript-keyword">if</span> ((cnattr.ca_recflags &amp; kHFSHasSecurityMask) != 0) {
	    <span class="enscript-type">struct</span> vnode *vp;

	    <span class="enscript-comment">/* get the vnode for this cnid */</span>
	    myErr = hfs_vget(hfsmp, thisNodeID, &amp;vp, 0, 0);
	    <span class="enscript-keyword">if</span> ( myErr ) {
		myResult = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	    }

	    thisNodeID = VTOC(vp)-&gt;c_parentcnid;

	    hfs_unlock(VTOC(vp));

	    <span class="enscript-keyword">if</span> (vnode_vtype(vp) == VDIR) {
		myErr = vnode_authorize(vp, NULL, (KAUTH_VNODE_SEARCH | KAUTH_VNODE_LIST_DIRECTORY), my_context);
	    } <span class="enscript-keyword">else</span> {
		myErr = vnode_authorize(vp, NULL, KAUTH_VNODE_READ_DATA, my_context);
	    }

	    vnode_put(vp);
	    <span class="enscript-keyword">if</span> (myErr) {
		myResult = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	    }
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags;
		<span class="enscript-type">int</span> mode = cnattr.ca_mode &amp; S_IFMT;   
		myPerms = DerivePermissionSummary(cnattr.ca_uid, cnattr.ca_gid, cnattr.ca_mode, hfsmp-&gt;hfs_mp,myp_ucred, theProcPtr);

		<span class="enscript-keyword">if</span> (mode == S_IFDIR) {
			flags = R_OK | X_OK;
		} <span class="enscript-keyword">else</span> {
			flags = R_OK;
		}
		<span class="enscript-keyword">if</span> ( (myPerms &amp; flags) != flags) {
			myResult = 0;
			myErr = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;   <span class="enscript-comment">/* no access */</span>
		}

	    <span class="enscript-comment">/* up the hierarchy we go */</span>
	    thisNodeID = catkey.hfsPlus.parentID;
	}
    }

    <span class="enscript-comment">/* if here, we have access to this node */</span>
    myResult = 1;

  <span class="enscript-reference">ExitThisRoutine</span>:
    <span class="enscript-keyword">if</span> (parents &amp;&amp; myErr == 0 &amp;&amp; scope_index == -1) {
	myErr = ESRCH;
    }
				
    <span class="enscript-keyword">if</span> (myErr) {
	myResult = 0;
    }
    *err = myErr;

    <span class="enscript-comment">/* cache the parent directory(ies) */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ids_to_cache; i++) {
	<span class="enscript-keyword">if</span> (myErr == 0 &amp;&amp; parents &amp;&amp; (scope_idx_start == -1 || i &gt; scope_idx_start)) {
	    add_node(cache, -1, parent_ids[i], ESRCH);
	} <span class="enscript-keyword">else</span> {
	    add_node(cache, -1, parent_ids[i], myErr);
	}
    }

    <span class="enscript-keyword">return</span> (myResult);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_bulk_access_check</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp,
    <span class="enscript-type">struct</span> vnop_ioctl_args *ap, <span class="enscript-type">int</span> arg_size, vfs_context_t context)
{
    boolean_t is64bit;

    <span class="enscript-comment">/*
     * NOTE: on entry, the vnode has an io_ref. In case this vnode
     * happens to be in our list of file_ids, we'll note it
     * avoid calling hfs_chashget_nowait() on that id as that
     * will cause a &quot;locking against myself&quot; panic.
     */</span>
    Boolean check_leaf = true;
		
    <span class="enscript-type">struct</span> user64_ext_access_t *user_access_structp;
    <span class="enscript-type">struct</span> user64_ext_access_t tmp_user_access;
    <span class="enscript-type">struct</span> access_cache cache;
		
    <span class="enscript-type">int</span> error = 0, prev_parent_check_ok=1;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
		
    <span class="enscript-type">short</span> flags;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_files = 0;
    <span class="enscript-type">int</span> map_size = 0;
    <span class="enscript-type">int</span> num_parents = 0;
    <span class="enscript-type">int</span> *file_ids=NULL;
    <span class="enscript-type">short</span> *access=NULL;
    <span class="enscript-type">char</span> *bitmap=NULL;
    cnid_t *parents=NULL;
    <span class="enscript-type">int</span> leaf_index;
	
    cnid_t cnid;
    cnid_t prevParent_cnid = 0;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> myPerms;
    <span class="enscript-type">short</span> myaccess = 0;
    <span class="enscript-type">struct</span> cat_attr cnattr;
    CatalogKey catkey;
    <span class="enscript-type">struct</span> cnode *skip_cp = VTOC(vp);
    kauth_cred_t cred = vfs_context_ucred(context);
    proc_t p = vfs_context_proc(context);

    is64bit = proc_is64bit(p);

    <span class="enscript-comment">/* initialize the local cache and buffers */</span>
    cache.numcached = 0;
    cache.cachehits = 0;
    cache.lookups = 0;
    cache.acache = NULL;
    cache.haveaccess = NULL;
		
    <span class="enscript-comment">/* struct copyin done during dispatch... need to copy file_id array separately */</span>
    <span class="enscript-keyword">if</span> (ap-&gt;a_data == NULL) {
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }

    <span class="enscript-keyword">if</span> (is64bit) {
	<span class="enscript-keyword">if</span> (arg_size != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_ext_access_t)) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
	}

	user_access_structp = (<span class="enscript-type">struct</span> user64_ext_access_t *)ap-&gt;a_data;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (arg_size == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_access_t)) {
	<span class="enscript-type">struct</span> user32_access_t *accessp = (<span class="enscript-type">struct</span> user32_access_t *)ap-&gt;a_data;

	<span class="enscript-comment">// convert an old style bulk-access struct to the new style
</span>	tmp_user_access.flags     = accessp-&gt;flags;
	tmp_user_access.num_files = accessp-&gt;num_files;
	tmp_user_access.map_size  = 0;
	tmp_user_access.file_ids  = CAST_USER_ADDR_T(accessp-&gt;file_ids);
	tmp_user_access.bitmap    = USER_ADDR_NULL;
	tmp_user_access.access    = CAST_USER_ADDR_T(accessp-&gt;access);
	tmp_user_access.num_parents = 0;
	user_access_structp = &amp;tmp_user_access;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (arg_size == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_ext_access_t)) {
	<span class="enscript-type">struct</span> user32_ext_access_t *accessp = (<span class="enscript-type">struct</span> user32_ext_access_t *)ap-&gt;a_data;

	<span class="enscript-comment">// up-cast from a 32-bit version of the struct
</span>	tmp_user_access.flags     = accessp-&gt;flags;
	tmp_user_access.num_files = accessp-&gt;num_files;
	tmp_user_access.map_size  = accessp-&gt;map_size;
	tmp_user_access.num_parents  = accessp-&gt;num_parents;

	tmp_user_access.file_ids  = CAST_USER_ADDR_T(accessp-&gt;file_ids);
	tmp_user_access.bitmap    = CAST_USER_ADDR_T(accessp-&gt;bitmap);
	tmp_user_access.access    = CAST_USER_ADDR_T(accessp-&gt;access);
	tmp_user_access.parents    = CAST_USER_ADDR_T(accessp-&gt;parents);

	user_access_structp = &amp;tmp_user_access;
    } <span class="enscript-keyword">else</span> {
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }
		
    map_size = user_access_structp-&gt;map_size;

    num_files = user_access_structp-&gt;num_files;

    num_parents= user_access_structp-&gt;num_parents;

    <span class="enscript-keyword">if</span> (num_files &lt; 1) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }
    <span class="enscript-keyword">if</span> (num_files &gt; 1024) {
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }

    <span class="enscript-keyword">if</span> (num_parents &gt; 1024) {
	error = EINVAL;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }
		
    file_ids = (<span class="enscript-type">int</span> *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * num_files);
    access = (<span class="enscript-type">short</span> *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">short</span>) * num_files);
    <span class="enscript-keyword">if</span> (map_size) {
	bitmap = (<span class="enscript-type">char</span> *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>) * map_size);
    }

    <span class="enscript-keyword">if</span> (num_parents) {
	parents = (cnid_t *) kalloc(<span class="enscript-keyword">sizeof</span>(cnid_t) * num_parents);
    }

    cache.acache = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * NUM_CACHE_ENTRIES);
    cache.haveaccess = (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) * NUM_CACHE_ENTRIES);
		
    <span class="enscript-keyword">if</span> (file_ids == NULL || access == NULL || (map_size != 0 &amp;&amp; bitmap == NULL) || cache.acache == NULL || cache.haveaccess == NULL) {
	<span class="enscript-keyword">if</span> (file_ids) {
	    kfree(file_ids, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * num_files);
	}
	<span class="enscript-keyword">if</span> (bitmap) {
	    kfree(bitmap, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>) * map_size);
	}
	<span class="enscript-keyword">if</span> (access) {
	    kfree(access, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">short</span>) * num_files);
	}
	<span class="enscript-keyword">if</span> (cache.acache) {
	    kfree(cache.acache, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * NUM_CACHE_ENTRIES);
	}
	<span class="enscript-keyword">if</span> (cache.haveaccess) {
	    kfree(cache.haveaccess, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) * NUM_CACHE_ENTRIES);
	}
	<span class="enscript-keyword">if</span> (parents) {
	    kfree(parents, <span class="enscript-keyword">sizeof</span>(cnid_t) * num_parents);
	}			
	<span class="enscript-keyword">return</span> ENOMEM;
    }
		
    <span class="enscript-comment">// make sure the bitmap is zero'ed out...
</span>    <span class="enscript-keyword">if</span> (bitmap) {
	bzero(bitmap, (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>) * map_size));
    }

    <span class="enscript-keyword">if</span> ((error = copyin(user_access_structp-&gt;file_ids, (caddr_t)file_ids,
		num_files * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)))) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }
	
    <span class="enscript-keyword">if</span> (num_parents) {
	<span class="enscript-keyword">if</span> ((error = copyin(user_access_structp-&gt;parents, (caddr_t)parents,
		    num_parents * <span class="enscript-keyword">sizeof</span>(cnid_t)))) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
	}
    }
	
    flags = user_access_structp-&gt;flags;
    <span class="enscript-keyword">if</span> ((flags &amp; (F_OK | R_OK | W_OK | X_OK)) == 0) {
	flags = R_OK;
    }
		
    <span class="enscript-comment">/* check if we've been passed leaf node ids or parent ids */</span>
    <span class="enscript-keyword">if</span> (flags &amp; PARENT_IDS_FLAG) {
	check_leaf = false;
    }
		
    <span class="enscript-comment">/* Check access to each file_id passed in */</span>
    <span class="enscript-keyword">for</span> (i = 0; i &lt; num_files; i++) {
	leaf_index=-1;
	cnid = (cnid_t) file_ids[i];
			
	<span class="enscript-comment">/* root always has access */</span>
	<span class="enscript-keyword">if</span> ((!parents) &amp;&amp; (!suser(cred, NULL))) {
	    access[i] = 0;
	    <span class="enscript-keyword">continue</span>;
	}
			
	<span class="enscript-keyword">if</span> (check_leaf) {
	    <span class="enscript-comment">/* do the lookup (checks the cnode hash, then the catalog) */</span>
	    error = do_attr_lookup(hfsmp, &amp;cache, cnid, skip_cp, &amp;catkey, &amp;cnattr);
	    <span class="enscript-keyword">if</span> (error) {
		access[i] = (<span class="enscript-type">short</span>) error;
		<span class="enscript-keyword">continue</span>;
	    }
	    
	    <span class="enscript-keyword">if</span> (parents) {
		<span class="enscript-comment">// Check if the leaf matches one of the parent scopes
</span>		leaf_index = cache_binSearch(parents, num_parents-1, cnid, NULL);
 		<span class="enscript-keyword">if</span> (leaf_index &gt;= 0 &amp;&amp; parents[leaf_index] == cnid)
 		    prev_parent_check_ok = 0;
 		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (leaf_index &gt;= 0)
 		    prev_parent_check_ok = 1;
	    }

	    <span class="enscript-comment">// if the thing has acl's, do the full permission check
</span>	    <span class="enscript-keyword">if</span> ((cnattr.ca_recflags &amp; kHFSHasSecurityMask) != 0) {
		<span class="enscript-type">struct</span> vnode *cvp;
		<span class="enscript-type">int</span> myErr = 0;
		<span class="enscript-comment">/* get the vnode for this cnid */</span>
		myErr = hfs_vget(hfsmp, cnid, &amp;cvp, 0, 0);
		<span class="enscript-keyword">if</span> ( myErr ) {
		    access[i] = myErr;
		    <span class="enscript-keyword">continue</span>;
		}
		
		hfs_unlock(VTOC(cvp));
		
		<span class="enscript-keyword">if</span> (vnode_vtype(cvp) == VDIR) {
		    myErr = vnode_authorize(cvp, NULL, (KAUTH_VNODE_SEARCH | KAUTH_VNODE_LIST_DIRECTORY), context);
		} <span class="enscript-keyword">else</span> {
		    myErr = vnode_authorize(cvp, NULL, KAUTH_VNODE_READ_DATA, context);
		}
		
		vnode_put(cvp);
		<span class="enscript-keyword">if</span> (myErr) {
		    access[i] = myErr;
		    <span class="enscript-keyword">continue</span>;
		}
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* before calling CheckAccess(), check the target file for read access */</span>
		myPerms = DerivePermissionSummary(cnattr.ca_uid, cnattr.ca_gid,
		    cnattr.ca_mode, hfsmp-&gt;hfs_mp, cred, p);
		
		<span class="enscript-comment">/* fail fast if no access */</span> 
		<span class="enscript-keyword">if</span> ((myPerms &amp; flags) == 0) {
		    access[i] = EACCES;
		    <span class="enscript-keyword">continue</span>;
		}		  					
	    }
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">/* we were passed an array of parent ids */</span>
	    catkey.hfsPlus.parentID = cnid;
	}
			
	<span class="enscript-comment">/* if the last guy had the same parent and had access, we're done */</span>
 	<span class="enscript-keyword">if</span> (i &gt; 0 &amp;&amp; catkey.hfsPlus.parentID == prevParent_cnid &amp;&amp; access[i-1] == 0 &amp;&amp; prev_parent_check_ok) {
	    cache.cachehits++;
	    access[i] = 0;
	    <span class="enscript-keyword">continue</span>;
	}
	
	myaccess = do_access_check(hfsmp, &amp;error, &amp;cache, catkey.hfsPlus.parentID, 
	    skip_cp, p, cred, context,bitmap, map_size, parents, num_parents);
			
	<span class="enscript-keyword">if</span> (myaccess || (error == ESRCH &amp;&amp; leaf_index != -1)) {
	    access[i] = 0; <span class="enscript-comment">// have access.. no errors to report
</span>	} <span class="enscript-keyword">else</span> {
	    access[i] = (error != 0 ? (<span class="enscript-type">short</span>) error : EACCES);
	}
			
	prevParent_cnid = catkey.hfsPlus.parentID;
    }
		
    <span class="enscript-comment">/* copyout the access array */</span>
    <span class="enscript-keyword">if</span> ((error = copyout((caddr_t)access, user_access_structp-&gt;access, 
		num_files * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">short</span>)))) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
    }
    <span class="enscript-keyword">if</span> (map_size &amp;&amp; bitmap) {
	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t)bitmap, user_access_structp-&gt;bitmap, 
		    map_size * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span>)))) {
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">err_exit_bulk_access</span>;
	}
    }
	
		
  <span class="enscript-reference">err_exit_bulk_access</span>:
		
    <span class="enscript-keyword">if</span> (file_ids) 
	kfree(file_ids, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * num_files);
    <span class="enscript-keyword">if</span> (parents) 
	kfree(parents, <span class="enscript-keyword">sizeof</span>(cnid_t) * num_parents);
    <span class="enscript-keyword">if</span> (bitmap) 
	kfree(bitmap, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>) * map_size);
    <span class="enscript-keyword">if</span> (access)
	kfree(access, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">short</span>) * num_files);
    <span class="enscript-keyword">if</span> (cache.acache)
	kfree(cache.acache, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) * NUM_CACHE_ENTRIES);
    <span class="enscript-keyword">if</span> (cache.haveaccess)
	kfree(cache.haveaccess, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>) * NUM_CACHE_ENTRIES);
		
    <span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/* end &quot;bulk-access&quot; support */</span>


<span class="enscript-comment">/*
 * Control filesystem operating characteristics.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_ioctl</span>( <span class="enscript-type">struct</span> vnop_ioctl_args <span class="enscript-comment">/* {
		vnode_t a_vp;
		long  a_command;
		caddr_t  a_data;
		int  a_fflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">struct</span> vnode * vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	vfs_context_t context = ap-&gt;a_context;
	kauth_cred_t cred = vfs_context_ucred(context);
	proc_t p = vfs_context_proc(context);
	<span class="enscript-type">struct</span> vfsstatfs *vfsp;
	boolean_t is64bit;
	off_t jnl_start, jnl_size;
	<span class="enscript-type">struct</span> hfs_journal_info *jip;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-type">int</span> compressed = 0;
	off_t uncompressed_size = -1;
	<span class="enscript-type">int</span> decmpfs_error = 0;
	
	<span class="enscript-keyword">if</span> (ap-&gt;a_command == F_RDADVISE) {
		<span class="enscript-comment">/* we need to inspect the decmpfs state of the file as early as possible */</span>
		compressed = hfs_file_is_compressed(VTOC(vp), 0);
		<span class="enscript-keyword">if</span> (compressed) {
			<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
				<span class="enscript-comment">/* if this is the resource fork, treat it as if it were empty */</span>
				uncompressed_size = 0;
			} <span class="enscript-keyword">else</span> {
				decmpfs_error = hfs_uncompressed_size_of_compressed_file(NULL, vp, 0, &amp;uncompressed_size, 0);
				<span class="enscript-keyword">if</span> (decmpfs_error != 0) {
					<span class="enscript-comment">/* failed to get the uncompressed size, we'll check for this later */</span>
					uncompressed_size = -1;
				}
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>

	is64bit = proc_is64bit(p);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	{
		<span class="enscript-type">int</span> error = 0;
		<span class="enscript-keyword">if</span> ((error = cp_handle_vnop(vp, CP_WRITE_ACCESS, 0)) != 0) {
			<span class="enscript-keyword">return</span> error;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>

	<span class="enscript-keyword">switch</span> (ap-&gt;a_command) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_GETPATH</span>:
	{
		<span class="enscript-type">struct</span> vnode *file_vp;
		cnid_t  cnid;
		<span class="enscript-type">int</span>  outlen;
		<span class="enscript-type">char</span> *bufptr;
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">int</span> flags = 0;

		<span class="enscript-comment">/* Caller must be owner of file system. */</span>
		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES);
		}
		<span class="enscript-comment">/* Target vnode must be file system's root. */</span>
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		bufptr = (<span class="enscript-type">char</span> *)ap-&gt;a_data;
		cnid = strtoul(bufptr, NULL, 10);
		<span class="enscript-keyword">if</span> (ap-&gt;a_fflag &amp; HFS_GETPATH_VOLUME_RELATIVE) {
			flags |= BUILDPATH_VOLUME_RELATIVE; 
		}

		<span class="enscript-comment">/* We need to call hfs_vfs_vget to leverage the code that will
		 * fix the origin list for us if needed, as opposed to calling
		 * hfs_vget, since we will need the parent for build_path call.
		 */</span>

		<span class="enscript-keyword">if</span> ((error = hfs_vfs_vget(HFSTOVFS(hfsmp), cnid, &amp;file_vp, context))) {
			<span class="enscript-keyword">return</span> (error);
		}
		error = build_path(file_vp, bufptr, <span class="enscript-keyword">sizeof</span>(pathname_t), &amp;outlen, flags, context);
		vnode_put(file_vp);

		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_TRANSFER_DOCUMENT_ID</span>:
	{
		<span class="enscript-type">struct</span> cnode *cp = NULL;
		<span class="enscript-type">int</span> error;
		u_int32_t to_fd = *(u_int32_t *)ap-&gt;a_data;
		<span class="enscript-type">struct</span> fileproc *to_fp;
		<span class="enscript-type">struct</span> vnode *to_vp;
		<span class="enscript-type">struct</span> cnode *to_cp;

		cp = VTOC(vp);

		<span class="enscript-keyword">if</span> ((error = fp_getfvp(p, to_fd, &amp;to_fp, &amp;to_vp)) != 0) {
			<span class="enscript-comment">//printf(&quot;could not get the vnode for fd %d (err %d)\n&quot;, to_fd, error);
</span>			<span class="enscript-keyword">return</span> error;
		}
		<span class="enscript-keyword">if</span> ( (error = vnode_getwithref(to_vp)) ) {
			file_drop(to_fd);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-keyword">if</span> (VTOHFS(to_vp) != hfsmp) {
			error = EXDEV;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">transfer_cleanup</span>;
		}

		<span class="enscript-type">int</span> need_unlock = 1;
		to_cp = VTOC(to_vp);
		error = hfs_lockpair(cp, to_cp, HFS_EXCLUSIVE_LOCK);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-comment">//printf(&quot;could not lock the pair of cnodes (error %d)\n&quot;, error);
</span>			<span class="enscript-keyword">goto</span> <span class="enscript-reference">transfer_cleanup</span>;
		}
			
		<span class="enscript-keyword">if</span> (!(cp-&gt;c_bsdflags &amp; UF_TRACKED)) {
			error = EINVAL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (to_cp-&gt;c_bsdflags &amp; UF_TRACKED) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// if the destination is already tracked, return an error
</span>			<span class="enscript-comment">// as otherwise it's a silent deletion of the target's
</span>			<span class="enscript-comment">// document-id
</span>			<span class="enscript-comment">//
</span>			error = EEXIST;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (S_ISDIR(cp-&gt;c_attr.ca_mode) || S_ISREG(cp-&gt;c_attr.ca_mode) || S_ISLNK(cp-&gt;c_attr.ca_mode)) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// we can use the FndrExtendedFileInfo because the doc-id is the first
</span>			<span class="enscript-comment">// thing in both it and the ExtendedDirInfo struct which is fixed in
</span>			<span class="enscript-comment">// format and can not change layout
</span>			<span class="enscript-comment">//
</span>			<span class="enscript-type">struct</span> FndrExtendedFileInfo *f_extinfo = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((u_int8_t*)cp-&gt;c_finderinfo + 16);
			<span class="enscript-type">struct</span> FndrExtendedFileInfo *to_extinfo = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)((u_int8_t*)to_cp-&gt;c_finderinfo + 16);

			<span class="enscript-keyword">if</span> (f_extinfo-&gt;document_id == 0) {
				uint32_t new_id;

				hfs_unlockpair(cp, to_cp);  <span class="enscript-comment">// have to unlock to be able to get a new-id
</span>				
				<span class="enscript-keyword">if</span> ((error = hfs_generate_document_id(hfsmp, &amp;new_id)) == 0) {
					<span class="enscript-comment">//
</span>					<span class="enscript-comment">// re-lock the pair now that we have the document-id
</span>					<span class="enscript-comment">//
</span>					hfs_lockpair(cp, to_cp, HFS_EXCLUSIVE_LOCK);
					f_extinfo-&gt;document_id = new_id;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">transfer_cleanup</span>;
				}
			}
					
			to_extinfo-&gt;document_id = f_extinfo-&gt;document_id;
			f_extinfo-&gt;document_id = 0;
			<span class="enscript-comment">//printf(&quot;TRANSFERRING: doc-id %d from ino %d to ino %d\n&quot;, to_extinfo-&gt;document_id, cp-&gt;c_fileid, to_cp-&gt;c_fileid);
</span>
			<span class="enscript-comment">// make sure the destination is also UF_TRACKED
</span>			to_cp-&gt;c_bsdflags |= UF_TRACKED;
			cp-&gt;c_bsdflags &amp;= ~UF_TRACKED;

			<span class="enscript-comment">// mark the cnodes dirty
</span>			cp-&gt;c_flag |= C_MODIFIED;
			to_cp-&gt;c_flag |= C_MODIFIED;

			<span class="enscript-type">int</span> lockflags;
			<span class="enscript-keyword">if</span> ((error = hfs_start_transaction(hfsmp)) == 0) {

				lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

				(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr, NULL, NULL);
				(<span class="enscript-type">void</span>) cat_update(hfsmp, &amp;to_cp-&gt;c_desc, &amp;to_cp-&gt;c_attr, NULL, NULL);

				hfs_systemfile_unlock (hfsmp, lockflags);
				(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			add_fsevent(FSE_DOCID_CHANGED, context,
				    FSE_ARG_DEV,   hfsmp-&gt;hfs_raw_dev,
				    FSE_ARG_INO,   (ino64_t)cp-&gt;c_fileid,       <span class="enscript-comment">// src inode #
</span>				    FSE_ARG_INO,   (ino64_t)to_cp-&gt;c_fileid,    <span class="enscript-comment">// dst inode #
</span>				    FSE_ARG_INT32, to_extinfo-&gt;document_id,
				    FSE_ARG_DONE);

			hfs_unlockpair(cp, to_cp);    <span class="enscript-comment">// unlock this so we can send the fsevents
</span>			need_unlock = 0;

			<span class="enscript-keyword">if</span> (need_fsevent(FSE_STAT_CHANGED, vp)) {
				add_fsevent(FSE_STAT_CHANGED, context, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
			}
			<span class="enscript-keyword">if</span> (need_fsevent(FSE_STAT_CHANGED, to_vp)) {
				add_fsevent(FSE_STAT_CHANGED, context, FSE_ARG_VNODE, to_vp, FSE_ARG_DONE);
			}
#<span class="enscript-reference">else</span>
			hfs_unlockpair(cp, to_cp);    <span class="enscript-comment">// unlock this so we can send the fsevents
</span>			need_unlock = 0;
#<span class="enscript-reference">endif</span>
		}
		
		<span class="enscript-keyword">if</span> (need_unlock) {
			hfs_unlockpair(cp, to_cp);
		}

	<span class="enscript-reference">transfer_cleanup</span>:
		vnode_put(to_vp);
		file_drop(to_fd);

		<span class="enscript-keyword">return</span> error;
	}



	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_PREV_LINK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_NEXT_LINK</span>:
	{
		cnid_t linkfileid;
		cnid_t nextlinkid;
		cnid_t prevlinkid;
		<span class="enscript-type">int</span> error;

		<span class="enscript-comment">/* Caller must be owner of file system. */</span>
		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES);
		}
		<span class="enscript-comment">/* Target vnode must be file system's root. */</span>
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		linkfileid = *(cnid_t *)ap-&gt;a_data;
		<span class="enscript-keyword">if</span> (linkfileid &lt; kHFSFirstUserCatalogNodeID) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> ((error = hfs_lookup_siblinglinks(hfsmp, linkfileid, &amp;prevlinkid, &amp;nextlinkid))) {
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (ap-&gt;a_command == HFS_NEXT_LINK) {
			*(cnid_t *)ap-&gt;a_data = nextlinkid;
		} <span class="enscript-keyword">else</span> {
			*(cnid_t *)ap-&gt;a_data = prevlinkid;
		}
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_RESIZE_PROGRESS</span>: {

		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-comment">/* file system must not be mounted read-only */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}

		<span class="enscript-keyword">return</span> hfs_resize_progress(hfsmp, (u_int32_t *)ap-&gt;a_data);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_RESIZE_VOLUME</span>: {
		u_int64_t newsize;
		u_int64_t cursize;
		<span class="enscript-type">int</span> ret;

		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		
		<span class="enscript-comment">/* filesystem must not be mounted read only */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		newsize = *(u_int64_t *)ap-&gt;a_data;
		cursize = (u_int64_t)hfsmp-&gt;totalBlocks * (u_int64_t)hfsmp-&gt;blockSize;

		<span class="enscript-keyword">if</span> (newsize == cursize) {
			<span class="enscript-keyword">return</span> (0);
		}
		IOBSDMountChange(hfsmp-&gt;hfs_mp, kIOMountChangeWillResize);
		<span class="enscript-keyword">if</span> (newsize &gt; cursize) {
			ret = hfs_extendfs(hfsmp, *(u_int64_t *)ap-&gt;a_data, context);
		} <span class="enscript-keyword">else</span> {
			ret = hfs_truncatefs(hfsmp, *(u_int64_t *)ap-&gt;a_data, context);
		}
		IOBSDMountChange(hfsmp-&gt;hfs_mp, kIOMountChangeDidResize);
		<span class="enscript-keyword">return</span> (ret);
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_CHANGE_NEXT_ALLOCATION</span>: {
		<span class="enscript-type">int</span> error = 0;		<span class="enscript-comment">/* Assume success */</span>
		u_int32_t location;

		<span class="enscript-keyword">if</span> (vnode_vfsisrdonly(vp)) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		hfs_lock_mount(hfsmp);
		location = *(u_int32_t *)ap-&gt;a_data;
		<span class="enscript-keyword">if</span> ((location &gt;= hfsmp-&gt;allocLimit) &amp;&amp;
			(location != HFS_NO_UPDATE_NEXT_ALLOCATION)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail_change_next_allocation</span>;
		}
		<span class="enscript-comment">/* Return previous value. */</span>
		*(u_int32_t *)ap-&gt;a_data = hfsmp-&gt;nextAllocation;
		<span class="enscript-keyword">if</span> (location == HFS_NO_UPDATE_NEXT_ALLOCATION) {
			<span class="enscript-comment">/* On magic value for location, set nextAllocation to next block
			 * after metadata zone and set flag in mount structure to indicate 
			 * that nextAllocation should not be updated again.
			 */</span>
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_metazone_end != 0) {
				HFS_UPDATE_NEXT_ALLOCATION(hfsmp, hfsmp-&gt;hfs_metazone_end + 1);
			}
			hfsmp-&gt;hfs_flags |= HFS_SKIP_UPDATE_NEXT_ALLOCATION; 
		} <span class="enscript-keyword">else</span> {
			hfsmp-&gt;hfs_flags &amp;= ~HFS_SKIP_UPDATE_NEXT_ALLOCATION; 
			HFS_UPDATE_NEXT_ALLOCATION(hfsmp, location);
		}
		MarkVCBDirty(hfsmp);
<span class="enscript-reference">fail_change_next_allocation</span>:
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">return</span> (error);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_SETBACKINGSTOREINFO</span>: {
		<span class="enscript-type">struct</span> vnode * bsfs_rootvp;
		<span class="enscript-type">struct</span> vnode * di_vp;
		<span class="enscript-type">struct</span> hfs_backingstoreinfo *bsdata;
		<span class="enscript-type">int</span> error = 0;
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
			<span class="enscript-keyword">return</span> (EALREADY);
		}
		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		bsdata = (<span class="enscript-type">struct</span> hfs_backingstoreinfo *)ap-&gt;a_data;
		<span class="enscript-keyword">if</span> (bsdata == NULL) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> ((error = file_vnode(bsdata-&gt;backingfd, &amp;di_vp))) {
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> ((error = vnode_getwithref(di_vp))) {
			file_drop(bsdata-&gt;backingfd);
			<span class="enscript-keyword">return</span>(error);
		}

		<span class="enscript-keyword">if</span> (vnode_mount(vp) == vnode_mount(di_vp)) {
			(<span class="enscript-type">void</span>)vnode_put(di_vp);
			file_drop(bsdata-&gt;backingfd);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-comment">/*
		 * Obtain the backing fs root vnode and keep a reference
		 * on it.  This reference will be dropped in hfs_unmount.
		 */</span>
		error = VFS_ROOT(vnode_mount(di_vp), &amp;bsfs_rootvp, NULL); <span class="enscript-comment">/* XXX use context! */</span>
		<span class="enscript-keyword">if</span> (error) {
			(<span class="enscript-type">void</span>)vnode_put(di_vp);
			file_drop(bsdata-&gt;backingfd);
			<span class="enscript-keyword">return</span> (error);
		}
		vnode_ref(bsfs_rootvp);
		vnode_put(bsfs_rootvp);

		hfs_lock_mount(hfsmp);
		hfsmp-&gt;hfs_backingfs_rootvp = bsfs_rootvp;
		hfsmp-&gt;hfs_flags |= HFS_HAS_SPARSE_DEVICE;
		hfsmp-&gt;hfs_sparsebandblks = bsdata-&gt;bandsize / hfsmp-&gt;blockSize * 4;
		hfs_unlock_mount(hfsmp);

		<span class="enscript-comment">/* We check the MNTK_VIRTUALDEV bit instead of marking the dependent process */</span>

		<span class="enscript-comment">/*
		 * If the sparse image is on a sparse image file (as opposed to a sparse
		 * bundle), then we may need to limit the free space to the maximum size
		 * of a file on that volume.  So we query (using pathconf), and if we get
		 * a meaningful result, we cache the number of blocks for later use in
		 * hfs_freeblks().
		 */</span>
		hfsmp-&gt;hfs_backingfs_maxblocks = 0;
		<span class="enscript-keyword">if</span> (vnode_vtype(di_vp) == VREG) {
			<span class="enscript-type">int</span> terr;
			<span class="enscript-type">int</span> hostbits;
			terr = vn_pathconf(di_vp, _PC_FILESIZEBITS, &amp;hostbits, context);
			<span class="enscript-keyword">if</span> (terr == 0 &amp;&amp; hostbits != 0 &amp;&amp; hostbits &lt; 64) {
				u_int64_t hostfilesizemax = ((u_int64_t)1) &lt;&lt; hostbits;
				
				hfsmp-&gt;hfs_backingfs_maxblocks = hostfilesizemax / hfsmp-&gt;blockSize;
			}
		}
				
		<span class="enscript-comment">/* The free extent cache is managed differently for sparse devices.  
		 * There is a window between which the volume is mounted and the 
		 * device is marked as sparse, so the free extent cache for this 
		 * volume is currently initialized as normal volume (sorted by block 
		 * count).  Reset the cache so that it will be rebuilt again 
		 * for sparse device (sorted by start block).
		 */</span>
		ResetVCBFreeExtCache(hfsmp);

		(<span class="enscript-type">void</span>)vnode_put(di_vp);
		file_drop(bsdata-&gt;backingfd);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_CLRBACKINGSTOREINFO</span>: {
		<span class="enscript-type">struct</span> vnode * tmpvp;

		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}

		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) &amp;&amp;
		    hfsmp-&gt;hfs_backingfs_rootvp) {

			hfs_lock_mount(hfsmp);
			hfsmp-&gt;hfs_flags &amp;= ~HFS_HAS_SPARSE_DEVICE;
			tmpvp = hfsmp-&gt;hfs_backingfs_rootvp;
			hfsmp-&gt;hfs_backingfs_rootvp = NULLVP;
			hfsmp-&gt;hfs_sparsebandblks = 0;
			hfs_unlock_mount(hfsmp);

			vnode_rele(tmpvp);
		}
		<span class="enscript-keyword">return</span> (0);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_SPARSE_DEV */</span>

	<span class="enscript-comment">/* Change the next CNID stored in the VH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_CHANGE_NEXTCNID</span>: {
		<span class="enscript-type">int</span> error = 0;		<span class="enscript-comment">/* Assume success */</span>
		u_int32_t fileid;
		<span class="enscript-type">int</span> wraparound = 0;
		<span class="enscript-type">int</span> lockflags = 0;

		<span class="enscript-keyword">if</span> (vnode_vfsisrdonly(vp)) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		vfsp = vfs_statfs(HFSTOVFS(hfsmp));
		<span class="enscript-keyword">if</span> (suser(cred, NULL) &amp;&amp;
			kauth_cred_getuid(cred) != vfsp-&gt;f_owner) {
			<span class="enscript-keyword">return</span> (EACCES); <span class="enscript-comment">/* must be owner of file system */</span>
		}
		
		fileid = *(u_int32_t *)ap-&gt;a_data;

		<span class="enscript-comment">/* Must have catalog lock excl. to advance the CNID pointer */</span>
		lockflags = hfs_systemfile_lock (hfsmp, SFL_CATALOG , HFS_EXCLUSIVE_LOCK);

		hfs_lock_mount(hfsmp);

		<span class="enscript-comment">/* If it is less than the current next CNID, force the wraparound bit to be set */</span>
		<span class="enscript-keyword">if</span> (fileid &lt; hfsmp-&gt;vcbNxtCNID) {
			wraparound=1;
		}

		<span class="enscript-comment">/* Return previous value. */</span>
		*(u_int32_t *)ap-&gt;a_data = hfsmp-&gt;vcbNxtCNID;

		hfsmp-&gt;vcbNxtCNID = fileid;

		<span class="enscript-keyword">if</span> (wraparound) {
			hfsmp-&gt;vcbAtrb |= kHFSCatalogNodeIDsReusedMask;
		}
		
		MarkVCBDirty(hfsmp);
		hfs_unlock_mount(hfsmp);
		hfs_systemfile_unlock (hfsmp, lockflags);

		<span class="enscript-keyword">return</span> (error);
	}
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FREEZE_FS</span>: {
		<span class="enscript-type">struct</span> mount *mp;
 
		mp = vnode_mount(vp);
		hfsmp = VFSTOHFS(mp);

		<span class="enscript-keyword">if</span> (!(hfsmp-&gt;jnl))
			<span class="enscript-keyword">return</span> (ENOTSUP);

		vfsp = vfs_statfs(mp);
	
		<span class="enscript-keyword">if</span> (kauth_cred_getuid(cred) != vfsp-&gt;f_owner &amp;&amp;
			!kauth_cred_issuser(cred))
			<span class="enscript-keyword">return</span> (EACCES);

		<span class="enscript-keyword">return</span> hfs_freeze(hfsmp);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_THAW_FS</span>: {
		vfsp = vfs_statfs(vnode_mount(vp));
		<span class="enscript-keyword">if</span> (kauth_cred_getuid(cred) != vfsp-&gt;f_owner &amp;&amp;
			!kauth_cred_issuser(cred))
			<span class="enscript-keyword">return</span> (EACCES);

		<span class="enscript-keyword">return</span> hfs_thaw(hfsmp, current_proc());
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_EXT_BULKACCESS_FSCTL</span>: {
	    <span class="enscript-type">int</span> size;
	    
	    <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) {
		<span class="enscript-keyword">return</span> EINVAL;
	    }

	    <span class="enscript-keyword">if</span> (is64bit) {
		size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_ext_access_t);
	    } <span class="enscript-keyword">else</span> {
		size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_ext_access_t);
	    }
	    
	    <span class="enscript-keyword">return</span> do_bulk_access_check(hfsmp, vp, ap, size, context);
	} 

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_SET_XATTREXTENTS_STATE</span>: {
		<span class="enscript-type">int</span> state;

		<span class="enscript-keyword">if</span> (ap-&gt;a_data == NULL) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		state = *(<span class="enscript-type">int</span> *)ap-&gt;a_data;
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}

		<span class="enscript-comment">/* Super-user can enable or disable extent-based extended 
		 * attribute support on a volume 
		 * Note: Starting Mac OS X 10.7, extent-based extended attributes
		 * are enabled by default, so any change will be transient only 
		 * till the volume is remounted.
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> (EPERM);
		}
		<span class="enscript-keyword">if</span> (state == 0 || state == 1)
			<span class="enscript-keyword">return</span> hfs_set_volxattr(hfsmp, HFS_SET_XATTREXTENTS_STATE, state);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (EINVAL);	
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETSTATICCONTENT</span>: {
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">int</span> enable_static = 0;
		<span class="enscript-type">struct</span> cnode *cp = NULL;
		<span class="enscript-comment">/* 
		 * lock the cnode, decorate the cnode flag, and bail out.
		 * VFS should have already authenticated the caller for us.
		 */</span>

		<span class="enscript-keyword">if</span> (ap-&gt;a_data) {
			<span class="enscript-comment">/* 
			 * Note that even though ap-&gt;a_data is of type caddr_t,
			 * the fcntl layer at the syscall handler will pass in NULL
			 * or 1 depending on what the argument supplied to the fcntl
			 * was.  So it is in fact correct to check the ap-&gt;a_data 
			 * argument for zero or non-zero value when deciding whether or not
			 * to enable the static bit in the cnode.
			 */</span>
			enable_static = 1;
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> EROFS;
		}
		cp = VTOC(vp);

		error = hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (enable_static) {
				cp-&gt;c_flag |= C_SSD_STATIC;
			}
			<span class="enscript-keyword">else</span> {
				cp-&gt;c_flag &amp;= ~C_SSD_STATIC;
			}
			hfs_unlock (cp);
		}
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SET_GREEDY_MODE</span>: {
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">int</span> enable_greedy_mode = 0;
		<span class="enscript-type">struct</span> cnode *cp = NULL;
		<span class="enscript-comment">/* 
		 * lock the cnode, decorate the cnode flag, and bail out.
		 * VFS should have already authenticated the caller for us.
		 */</span>

		<span class="enscript-keyword">if</span> (ap-&gt;a_data) {
			<span class="enscript-comment">/* 
			 * Note that even though ap-&gt;a_data is of type caddr_t,
			 * the fcntl layer at the syscall handler will pass in NULL
			 * or 1 depending on what the argument supplied to the fcntl
			 * was.  So it is in fact correct to check the ap-&gt;a_data 
			 * argument for zero or non-zero value when deciding whether or not
			 * to enable the greedy mode bit in the cnode.
			 */</span>
			enable_greedy_mode = 1;
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> EROFS;
		}
		cp = VTOC(vp);

		error = hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (enable_greedy_mode) {
				cp-&gt;c_flag |= C_SSD_GREEDY_MODE;
			}
			<span class="enscript-keyword">else</span> {
				cp-&gt;c_flag &amp;= ~C_SSD_GREEDY_MODE;
			}
			hfs_unlock (cp);
		}
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETIOTYPE</span>: {
		<span class="enscript-type">int</span> error;
		uint32_t iotypeflag = 0;
		
		<span class="enscript-type">struct</span> cnode *cp = NULL;
		<span class="enscript-comment">/* 
		 * lock the cnode, decorate the cnode flag, and bail out.
		 * VFS should have already authenticated the caller for us.
		 */</span>

		<span class="enscript-keyword">if</span> (ap-&gt;a_data == NULL) {
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">/* 
		 * Note that even though ap-&gt;a_data is of type caddr_t, we
		 * can only use 32 bits of flag values.
		 */</span>
		iotypeflag = (uint32_t) ap-&gt;a_data;
		<span class="enscript-keyword">switch</span> (iotypeflag) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">F_IOTYPE_ISOCHRONOUS</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> EINVAL;
		}


		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> EROFS;
		}
		cp = VTOC(vp);

		error = hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">switch</span> (iotypeflag) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">F_IOTYPE_ISOCHRONOUS</span>:
					cp-&gt;c_flag |= C_IO_ISOCHRONOUS;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					<span class="enscript-keyword">break</span>;
			}
			hfs_unlock (cp);
		}
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_MAKECOMPRESSED</span>: {
		<span class="enscript-type">int</span> error = 0;
		uint32_t gen_counter;
		<span class="enscript-type">struct</span> cnode *cp = NULL;
		<span class="enscript-type">int</span> reset_decmp = 0;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> EROFS;
		}

		<span class="enscript-comment">/* 
		 * acquire &amp; lock the cnode.
		 * VFS should have already authenticated the caller for us.
		 */</span>

		<span class="enscript-keyword">if</span> (ap-&gt;a_data) {
			<span class="enscript-comment">/* 
			 * Cast the pointer into a uint32_t so we can extract the 
			 * supplied generation counter.
			 */</span>
			gen_counter = *((uint32_t*)ap-&gt;a_data);
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> EINVAL;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		cp = VTOC(vp);
		<span class="enscript-comment">/* Grab truncate lock first; we may truncate the file */</span>
		hfs_lock_truncate (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

		error = hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error) {
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/* Are there any other usecounts/FDs? */</span>
		<span class="enscript-keyword">if</span> (vnode_isinuse(vp, 1)) {
			hfs_unlock(cp);
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">return</span> EBUSY;
		}

		<span class="enscript-comment">/* now we have the cnode locked down; Validate arguments */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_flags &amp; (UF_IMMUTABLE | UF_COMPRESSED)) {
			<span class="enscript-comment">/* EINVAL if you are trying to manipulate an IMMUTABLE file */</span>
			hfs_unlock(cp);
			hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> ((hfs_get_gencount (cp)) == gen_counter) {
			<span class="enscript-comment">/* 
			 * OK, the gen_counter matched.  Go for it:
			 * Toggle state bits, truncate file, and suppress mtime update 
			 */</span>
			reset_decmp = 1;
			cp-&gt;c_bsdflags |= UF_COMPRESSED;				

			error = hfs_truncate(vp, 0, IO_NDELAY, HFS_TRUNCATE_SKIPTIMES,
								 ap-&gt;a_context);
		}
		<span class="enscript-keyword">else</span> {
			error = ESTALE;
		}

		<span class="enscript-comment">/* Unlock cnode before executing decmpfs ; they may need to get an EA */</span>
		hfs_unlock(cp);

		<span class="enscript-comment">/*
		 * Reset the decmp state while still holding the truncate lock. We need to 
		 * serialize here against a listxattr on this node which may occur at any 
		 * time. 
		 * 
		 * Even if '0/skiplock' is passed in 2nd argument to hfs_file_is_compressed,
		 * that will still potentially require getting the com.apple.decmpfs EA. If the 
	 	 * EA is required, then we can't hold the cnode lock, because the getxattr call is
		 * generic(through VFS), and can't pass along any info telling it that we're already
		 * holding it (the lock). If we don't serialize, then we risk listxattr stopping
		 * and trying to fill in the hfs_file_is_compressed info during the callback
		 * operation, which will result in deadlock against the b-tree node.
		 * 
		 * So, to serialize against listxattr (which will grab buf_t meta references on
		 * the b-tree blocks), we hold the truncate lock as we're manipulating the 
		 * decmpfs payload. 
		 */</span>
		<span class="enscript-keyword">if</span> ((reset_decmp) &amp;&amp; (error == 0)) {
			decmpfs_cnode *dp = VTOCMP (vp);
			<span class="enscript-keyword">if</span> (dp != NULL) {
				decmpfs_cnode_set_vnode_state(dp, FILE_TYPE_UNKNOWN, 0);
			}

			<span class="enscript-comment">/* Initialize the decmpfs node as needed */</span>
			(<span class="enscript-type">void</span>) hfs_file_is_compressed (cp, 0); <span class="enscript-comment">/* ok to take lock */</span>
		}

		hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);

#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETBACKINGSTORE</span>: {

		<span class="enscript-type">int</span> error = 0;

		<span class="enscript-comment">/* 
		 * See comment in F_SETSTATICCONTENT re: using
	     * a null check for a_data
  		 */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_data) {
			error = hfs_set_backingstore (vp, 1);
		}
		<span class="enscript-keyword">else</span> {
			error = hfs_set_backingstore (vp, 0);
		}		

		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETPATH_MTMINFO</span>: {
		<span class="enscript-type">int</span> error = 0;

		<span class="enscript-type">int</span> *data = (<span class="enscript-type">int</span>*) ap-&gt;a_data;	

		<span class="enscript-comment">/* Ask if this is a backingstore vnode */</span>
		error = hfs_is_backingstore (vp, data);

		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FULLFSYNC</span>: {
		<span class="enscript-type">int</span> error;
		
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			error = hfs_fsync(vp, MNT_WAIT, HFS_FSYNC_FULL, p);
			hfs_unlock(VTOC(vp));
		}

		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_BARRIERFSYNC</span>: {
		<span class="enscript-type">int</span> error;

		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			error = hfs_fsync(vp, MNT_WAIT, HFS_FSYNC_BARRIER, p);
			hfs_unlock(VTOC(vp));
		}

		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_CHKCLEAN</span>: {
		<span class="enscript-type">register</span> <span class="enscript-type">struct</span> cnode *cp;
		<span class="enscript-type">int</span> error;

		<span class="enscript-keyword">if</span> (!vnode_isreg(vp))
			<span class="enscript-keyword">return</span> EINVAL;
 
		error = hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error == 0) {
			cp = VTOC(vp);
			<span class="enscript-comment">/*
			 * used by regression test to determine if 
			 * all the dirty pages (via write) have been cleaned
			 * after a call to 'fsysnc'.
			 */</span>
			error = is_file_clean(vp, VTOF(vp)-&gt;ff_size);
			hfs_unlock(cp);
		}
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_RDADVISE</span>: {
		<span class="enscript-type">register</span> <span class="enscript-type">struct</span> radvisory *ra;
		<span class="enscript-type">struct</span> filefork *fp;
		<span class="enscript-type">int</span> error;

		<span class="enscript-keyword">if</span> (!vnode_isreg(vp))
			<span class="enscript-keyword">return</span> EINVAL;
 
		ra = (<span class="enscript-type">struct</span> radvisory *)(ap-&gt;a_data);
		fp = VTOF(vp);

		<span class="enscript-comment">/* Protect against a size change. */</span>
		hfs_lock_truncate(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> (compressed &amp;&amp; (uncompressed_size == -1)) {
			<span class="enscript-comment">/* fetching the uncompressed size failed above, so return the error */</span>
			error = decmpfs_error;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((compressed &amp;&amp; (ra-&gt;ra_offset &gt;= uncompressed_size)) ||
				   (!compressed &amp;&amp; (ra-&gt;ra_offset &gt;= fp-&gt;ff_size))) {
			error = EFBIG;
		}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
		<span class="enscript-keyword">if</span> (ra-&gt;ra_offset &gt;= fp-&gt;ff_size) {
			error = EFBIG;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
		<span class="enscript-keyword">else</span> {
			error = advisory_read(vp, fp-&gt;ff_size, ra-&gt;ra_offset, ra-&gt;ra_count);
		}

		hfs_unlock_truncate(VTOC(vp), HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">_IOC</span>(IOC_OUT,<span class="enscript-string">'h'</span>, 4, 0):     <span class="enscript-comment">/* Create date in local time */</span>
	{
		<span class="enscript-keyword">if</span> (is64bit) {
			*(user_time_t *)(ap-&gt;a_data) = (user_time_t) (to_bsd_time(VTOVCB(vp)-&gt;localCreateDate));
		}
		<span class="enscript-keyword">else</span> {
			*(user32_time_t *)(ap-&gt;a_data) = (user32_time_t) (to_bsd_time(VTOVCB(vp)-&gt;localCreateDate));
		}
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SPOTLIGHT_FSCTL_GET_MOUNT_TIME</span>:
	    *(uint32_t *)ap-&gt;a_data = hfsmp-&gt;hfs_mount_time;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SPOTLIGHT_FSCTL_GET_LAST_MTIME</span>:
	    *(uint32_t *)ap-&gt;a_data = hfsmp-&gt;hfs_last_mounted_mtime;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_GET_VERY_LOW_DISK</span>:
	    *(uint32_t*)ap-&gt;a_data = hfsmp-&gt;hfs_freespace_notify_dangerlimit;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_SET_VERY_LOW_DISK</span>:
	    <span class="enscript-keyword">if</span> (*(uint32_t *)ap-&gt;a_data &gt;= hfsmp-&gt;hfs_freespace_notify_warninglimit) {
		<span class="enscript-keyword">return</span> EINVAL;
	    }

	    hfsmp-&gt;hfs_freespace_notify_dangerlimit = *(uint32_t *)ap-&gt;a_data;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_GET_LOW_DISK</span>:
	    *(uint32_t*)ap-&gt;a_data = hfsmp-&gt;hfs_freespace_notify_warninglimit;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_SET_LOW_DISK</span>:
	    <span class="enscript-keyword">if</span> (   *(uint32_t *)ap-&gt;a_data &gt;= hfsmp-&gt;hfs_freespace_notify_desiredlevel
		|| *(uint32_t *)ap-&gt;a_data &lt;= hfsmp-&gt;hfs_freespace_notify_dangerlimit) {

		<span class="enscript-keyword">return</span> EINVAL;
	    }

	    hfsmp-&gt;hfs_freespace_notify_warninglimit = *(uint32_t *)ap-&gt;a_data;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_GET_DESIRED_DISK</span>:
	    *(uint32_t*)ap-&gt;a_data = hfsmp-&gt;hfs_freespace_notify_desiredlevel;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_SET_DESIRED_DISK</span>:
	    <span class="enscript-keyword">if</span> (*(uint32_t *)ap-&gt;a_data &lt;= hfsmp-&gt;hfs_freespace_notify_warninglimit) {
		<span class="enscript-keyword">return</span> EINVAL;
	    }

	    hfsmp-&gt;hfs_freespace_notify_desiredlevel = *(uint32_t *)ap-&gt;a_data;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_VOLUME_STATUS</span>:
	    *(uint32_t *)ap-&gt;a_data = hfsmp-&gt;hfs_notification_conditions;
	    <span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_SET_BOOT_INFO</span>:
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp))
			<span class="enscript-keyword">return</span>(EINVAL);
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(cred) &amp;&amp; (kauth_cred_getuid(cred) != vfs_statfs(HFSTOVFS(hfsmp))-&gt;f_owner))
			<span class="enscript-keyword">return</span>(EACCES);	<span class="enscript-comment">/* must be superuser or owner of filesystem */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		hfs_lock_mount (hfsmp);
		bcopy(ap-&gt;a_data, &amp;hfsmp-&gt;vcbFndrInfo, <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;vcbFndrInfo));
		hfs_unlock_mount (hfsmp);
		(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT);
		<span class="enscript-keyword">break</span>;
		
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_GET_BOOT_INFO</span>:
		<span class="enscript-keyword">if</span> (!vnode_isvroot(vp))
			<span class="enscript-keyword">return</span>(EINVAL);
		hfs_lock_mount (hfsmp);
		bcopy(&amp;hfsmp-&gt;vcbFndrInfo, ap-&gt;a_data, <span class="enscript-keyword">sizeof</span>(hfsmp-&gt;vcbFndrInfo));
		hfs_unlock_mount(hfsmp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_MARK_BOOT_CORRUPT</span>:
		<span class="enscript-comment">/* Mark the boot volume corrupt by setting 
		 * kHFSVolumeInconsistentBit in the volume header.  This will 
		 * force fsck_hfs on next mount.
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> EACCES;
		}
			
		<span class="enscript-comment">/* Allowed only on the root vnode of the boot volume */</span>
		<span class="enscript-keyword">if</span> (!(vfs_flags(HFSTOVFS(hfsmp)) &amp; MNT_ROOTFS) || 
		    !vnode_isvroot(vp)) {
			<span class="enscript-keyword">return</span> EINVAL;
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}
		printf (<span class="enscript-string">&quot;hfs_vnop_ioctl: Marking the boot volume corrupt.\n&quot;</span>);
		hfs_mark_inconsistent(hfsmp, HFS_FSCK_FORCED);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSCTL_GET_JOURNAL_INFO</span>:
		jip = (<span class="enscript-type">struct</span> hfs_journal_info*)ap-&gt;a_data;

		<span class="enscript-keyword">if</span> (vp == NULLVP)
		        <span class="enscript-keyword">return</span> EINVAL;

	    <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl == NULL) {
			jnl_start = 0;
			jnl_size  = 0;
	    } <span class="enscript-keyword">else</span> {
			jnl_start = hfs_blk_to_bytes(hfsmp-&gt;jnl_start, hfsmp-&gt;blockSize) + hfsmp-&gt;hfsPlusIOPosOffset;
			jnl_size  = hfsmp-&gt;jnl_size;
	    }

		jip-&gt;jstart = jnl_start;
		jip-&gt;jsize = jnl_size;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_SET_ALWAYS_ZEROFILL</span>: {
	    <span class="enscript-type">struct</span> cnode *cp = VTOC(vp);

	    <span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)ap-&gt;a_data) {
		cp-&gt;c_flag |= C_ALWAYS_ZEROFILL;
	    } <span class="enscript-keyword">else</span> {
		cp-&gt;c_flag &amp;= ~C_ALWAYS_ZEROFILL;
	    }
	    <span class="enscript-keyword">break</span>;
	}    

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_DISABLE_METAZONE</span>: {
		<span class="enscript-comment">/* Only root can disable metadata zone */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> EACCES;
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
			<span class="enscript-keyword">return</span> (EROFS);
		}

		<span class="enscript-comment">/* Disable metadata zone now */</span>
		(<span class="enscript-type">void</span>) hfs_metadatazone_init(hfsmp, true);
		printf (<span class="enscript-string">&quot;hfs: Disabling metadata zone on %s\n&quot;</span>, hfsmp-&gt;vcbVN);
		<span class="enscript-keyword">break</span>;
	}


	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_FSINFO_METADATA_BLOCKS</span>: {
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">struct</span> hfsinfo_metadata *hinfo;

		hinfo = (<span class="enscript-type">struct</span> hfsinfo_metadata *)ap-&gt;a_data;

		<span class="enscript-comment">/* Get information about number of metadata blocks */</span>
		error = hfs_getinfo_metadata_blocks(hfsmp, hinfo);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_GET_FSINFO</span>: {
		hfs_fsinfo *fsinfo = (hfs_fsinfo *)ap-&gt;a_data;

		<span class="enscript-comment">/* Only root is allowed to get fsinfo */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> EACCES;
		}

		<span class="enscript-comment">/*
		 * Make sure that the caller's version number matches with
		 * the kernel's version number.  This will make sure that
		 * if the structures being read/written into are changed
		 * by the kernel, the caller will not read incorrect data.
		 *
		 * The first three fields --- request_type, version and
		 * flags are same for all the hfs_fsinfo structures, so
		 * we can access the version number by assuming any
		 * structure for now.
		 */</span>
		<span class="enscript-keyword">if</span> (fsinfo-&gt;header.version != HFS_FSINFO_VERSION) {
			<span class="enscript-keyword">return</span> ENOTSUP;
		}

		<span class="enscript-comment">/* Make sure that the current file system is not marked inconsistent */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbAtrb &amp; kHFSVolumeInconsistentMask) {
			<span class="enscript-keyword">return</span> EIO;
		}

		<span class="enscript-keyword">return</span> hfs_get_fsinfo(hfsmp, ap-&gt;a_data);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_CS_FREESPACE_TRIM</span>: {
		<span class="enscript-type">int</span> error = 0;
		<span class="enscript-type">int</span> lockflags = 0;

		<span class="enscript-comment">/* Only root allowed */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> EACCES;
		}

		<span class="enscript-comment">/* 
		 * This core functionality is similar to hfs_scan_blocks().  
		 * The main difference is that hfs_scan_blocks() is called 
		 * as part of mount where we are assured that the journal is 
		 * empty to start with.  This fcntl() can be called on a 
		 * mounted volume, therefore it has to flush the content of 
		 * the journal as well as ensure the state of summary table. 
		 * 
		 * This fcntl scans over the entire allocation bitmap,
		 * creates list of all the free blocks, and issues TRIM 
		 * down to the underlying device.  This can take long time 
		 * as it can generate up to 512MB of read I/O.
		 */</span>

		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_SUMMARY_TABLE) == 0) {
			error = hfs_init_summary(hfsmp);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;hfs: fsctl() could not initialize summary table for %s\n&quot;</span>, hfsmp-&gt;vcbVN);
				<span class="enscript-keyword">return</span> error;
			}
		}

		<span class="enscript-comment">/* 
		 * The journal maintains list of recently deallocated blocks to 
		 * issue DKIOCUNMAPs when the corresponding journal transaction is 
		 * flushed to the disk.  To avoid any race conditions, we only 
		 * want one active trim list and only one thread issuing DKIOCUNMAPs.
		 * Therefore we make sure that the journal trim list is sync'ed, 
		 * empty, and not modifiable for the duration of our scan.
		 * 
		 * Take the journal lock before flushing the journal to the disk. 
		 * We will keep on holding the journal lock till we don't get the 
		 * bitmap lock to make sure that no new journal transactions can 
		 * start.  This will make sure that the journal trim list is not 
		 * modified after the journal flush and before getting bitmap lock.
		 * We can release the journal lock after we acquire the bitmap 
		 * lock as it will prevent any further block deallocations.
		 */</span>
		hfs_journal_lock(hfsmp);

		<span class="enscript-comment">/* Flush the journal and wait for all I/Os to finish up */</span>
		error = hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
		<span class="enscript-keyword">if</span> (error) {
			hfs_journal_unlock(hfsmp);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/* Take bitmap lock to ensure it is not being modified */</span>
		lockflags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">/* Release the journal lock */</span>
		hfs_journal_unlock(hfsmp);

		<span class="enscript-comment">/* 
		 * ScanUnmapBlocks reads the bitmap in large block size 
		 * (up to 1MB) unlike the runtime which reads the bitmap 
		 * in the 4K block size.  This can cause buf_t collisions 
		 * and potential data corruption.  To avoid this, we 
		 * invalidate all the existing buffers associated with 
		 * the bitmap vnode before scanning it.
		 *
		 * Note: ScanUnmapBlock() cleans up all the buffers 
		 * after itself, so there won't be any large buffers left 
		 * for us to clean up after it returns.
		 */</span>
		error = buf_invalidateblks(hfsmp-&gt;hfs_allocation_vp, 0, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			hfs_systemfile_unlock(hfsmp, lockflags);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/* Traverse bitmap and issue DKIOCUNMAPs */</span>
		error = ScanUnmapBlocks(hfsmp);
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_SET_HOTFILE_STATE</span>: {
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
		uint32_t hf_state = *((uint32_t*)ap-&gt;a_data);
		uint32_t num_unpinned = 0;
		
		error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">// printf(&quot;hfs: setting hotfile state %d on %s\n&quot;, hf_state, vp-&gt;v_name);
</span>		<span class="enscript-keyword">if</span> (hf_state == HFS_MARK_FASTDEVCANDIDATE) {
			vnode_setfastdevicecandidate(vp);

			cp-&gt;c_attr.ca_recflags |= kHFSFastDevCandidateMask;
			cp-&gt;c_attr.ca_recflags &amp;= ~kHFSDoNotFastDevPinMask;
			cp-&gt;c_flag |= C_MODIFIED;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hf_state == HFS_UNMARK_FASTDEVCANDIDATE || hf_state == HFS_NEVER_FASTDEVCANDIDATE) {
			vnode_clearfastdevicecandidate(vp);
			hfs_removehotfile(vp);

			<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_recflags &amp; kHFSFastDevPinnedMask) {
				hfs_pin_vnode(hfsmp, vp, HFS_UNPIN_IT, &amp;num_unpinned, ap-&gt;a_context);
			}
				
			<span class="enscript-keyword">if</span> (hf_state == HFS_NEVER_FASTDEVCANDIDATE) {
				cp-&gt;c_attr.ca_recflags |= kHFSDoNotFastDevPinMask;
			}
			cp-&gt;c_attr.ca_recflags &amp;= ~(kHFSFastDevCandidateMask|kHFSFastDevPinnedMask);
			cp-&gt;c_flag |= C_MODIFIED;

		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
		}

		<span class="enscript-keyword">if</span> (num_unpinned != 0) {
			lck_mtx_lock(&amp;hfsmp-&gt;hfc_mutex);
			hfsmp-&gt;hfs_hotfile_freeblks += num_unpinned;
			lck_mtx_unlock(&amp;hfsmp-&gt;hfc_mutex);
		}

		hfs_unlock(cp);
		<span class="enscript-keyword">return</span> error;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_REPIN_HOTFILE_STATE</span>: {
		<span class="enscript-type">int</span> error=0;
		uint32_t repin_what = *((uint32_t*)ap-&gt;a_data);

		<span class="enscript-comment">/* Only root allowed */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
			<span class="enscript-keyword">return</span> EACCES;
		}

		<span class="enscript-keyword">if</span> (!(hfsmp-&gt;hfs_flags &amp; (HFS_CS_METADATA_PIN | HFS_CS_HOTFILE_PIN))) {
			<span class="enscript-comment">// this system is neither regular Fusion or Cooperative Fusion
</span>			<span class="enscript-comment">// so this fsctl makes no sense.
</span>			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// After a converting a CoreStorage volume to be encrypted, the
</span>		<span class="enscript-comment">// extents could have moved around underneath us.  This call
</span>		<span class="enscript-comment">// allows corestoraged to re-pin everything that should be
</span>		<span class="enscript-comment">// pinned (it would happen on the next reboot too but that could
</span>		<span class="enscript-comment">// be a long time away).
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> ((repin_what &amp; HFS_REPIN_METADATA) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_CS_METADATA_PIN)) {
			hfs_pin_fs_metadata(hfsmp);
		}
		<span class="enscript-keyword">if</span> ((repin_what &amp; HFS_REPIN_USERDATA) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) {
			hfs_repin_hotfiles(hfsmp);
		}
		<span class="enscript-keyword">if</span> ((repin_what &amp; HFS_REPIN_USERDATA) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_CS_SWAPFILE_PIN)) {
			<span class="enscript-comment">//XXX Swapfiles (marked SWAP_PINNED) may have moved too.
</span>			<span class="enscript-comment">//XXX Do we care? They have a more transient/dynamic nature/lifetime.
</span>		}

		<span class="enscript-keyword">return</span> error;
		<span class="enscript-keyword">break</span>;
	}		


	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (ENOTTY);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * select
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_select</span>(__unused <span class="enscript-type">struct</span> vnop_select_args *ap)
<span class="enscript-comment">/*
	struct vnop_select_args {
		vnode_t a_vp;
		int  a_which;
		int  a_fflags;
		void *a_wql;
		vfs_context_t a_context;
	};
*/</span>
{
	<span class="enscript-comment">/*
	 * We should really check to see if I/O is possible.
	 */</span>
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Converts a logical block number to a physical block, and optionally returns
 * the amount of remaining blocks in a run. The logical block is based on hfsNode.logBlockSize.
 * The physical block number is based on the device block size, currently its 512.
 * The block run is returned in logical blocks, and is the REMAINING amount of blocks
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_bmap</span>(<span class="enscript-type">struct</span> vnode *vp, daddr_t bn, <span class="enscript-type">struct</span> vnode **vpp, daddr64_t *bnp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *runp)
{
	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">int</span>  retval = E_NONE;
	u_int32_t  logBlockSize;
	size_t  bytesContAvail = 0;
	off_t  blockposition;
	<span class="enscript-type">int</span> lockExtBtree;
	<span class="enscript-type">int</span> lockflags = 0;

	<span class="enscript-comment">/*
	 * Check for underlying vnode requests and ensure that logical
	 * to physical mapping is requested.
	 */</span>
	<span class="enscript-keyword">if</span> (vpp != NULL)
		*vpp = hfsmp-&gt;hfs_devvp;
	<span class="enscript-keyword">if</span> (bnp == NULL)
		<span class="enscript-keyword">return</span> (0);

	logBlockSize = GetLogicalBlockSize(vp);
	blockposition = (off_t)bn * logBlockSize;

	lockExtBtree = overflow_extents(fp);

	<span class="enscript-keyword">if</span> (lockExtBtree)
		lockflags = hfs_systemfile_lock(hfsmp, SFL_EXTENTS, HFS_EXCLUSIVE_LOCK);

	retval = MacToVFSError(
                            MapFileBlockC (HFSTOVCB(hfsmp),
                                            (FCB*)fp,
                                            MAXPHYSIO,
                                            blockposition,
                                            bnp,
                                            &amp;bytesContAvail));

	<span class="enscript-keyword">if</span> (lockExtBtree)
		hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">if</span> (retval == E_NONE) {
		<span class="enscript-comment">/* Figure out how many read ahead blocks there are */</span>
		<span class="enscript-keyword">if</span> (runp != NULL) {
			<span class="enscript-keyword">if</span> (can_cluster(logBlockSize)) {
				<span class="enscript-comment">/* Make sure this result never goes negative: */</span>
				*runp = (bytesContAvail &lt; logBlockSize) ? 0 : (bytesContAvail / logBlockSize) - 1;
			} <span class="enscript-keyword">else</span> {
				*runp = 0;
			}
		}
	}
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Convert logical block number to file offset.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_blktooff</span>(<span class="enscript-type">struct</span> vnop_blktooff_args *ap)
<span class="enscript-comment">/*
	struct vnop_blktooff_args {
		vnode_t a_vp;
		daddr64_t a_lblkno;  
		off_t *a_offset;
	};
*/</span>
{	
	<span class="enscript-keyword">if</span> (ap-&gt;a_vp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	*ap-&gt;a_offset = (off_t)ap-&gt;a_lblkno * (off_t)GetLogicalBlockSize(ap-&gt;a_vp);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Convert file offset to logical block number.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_offtoblk</span>(<span class="enscript-type">struct</span> vnop_offtoblk_args *ap)
<span class="enscript-comment">/*
	struct vnop_offtoblk_args {
		vnode_t a_vp;
		off_t a_offset;    
		daddr64_t *a_lblkno;
	};
*/</span>
{	
	<span class="enscript-keyword">if</span> (ap-&gt;a_vp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	*ap-&gt;a_lblkno = (daddr64_t)(ap-&gt;a_offset / (off_t)GetLogicalBlockSize(ap-&gt;a_vp));

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Map file offset to physical block number.
 *
 * If this function is called for write operation, and if the file
 * had virtual blocks allocated (delayed allocation), real blocks
 * are allocated by calling ExtendFileC().
 * 
 * If this function is called for read operation, and if the file
 * had virtual blocks allocated (delayed allocation), no change 
 * to the size of file is done, and if required, rangelist is 
 * searched for mapping.
 *
 * System file cnodes are expected to be locked (shared or exclusive).
 *
 * -- INVALID RANGES --
 *
 * Invalid ranges are used to keep track of where we have extended a
 * file, but have not yet written that data to disk.  In the past we
 * would clear up the invalid ranges as we wrote to those areas, but
 * before data was actually flushed to disk.  The problem with that
 * approach is that the data can be left in the cache and is therefore
 * still not valid on disk.  So now we clear up the ranges here, when
 * the flags field has VNODE_WRITE set, indicating a write is about to
 * occur.  This isn't ideal (ideally we want to clear them up when
 * know the data has been successfully written), but it's the best we
 * can do.
 *
 * For reads, we use the invalid ranges here in block map to indicate
 * to the caller that the data should be zeroed (a_bpn == -1).  We
 * have to be careful about what ranges we return to the cluster code.
 * Currently the cluster code can only handle non-rounded values for
 * the EOF; it cannot handle funny sized ranges in the middle of the
 * file (the main problem is that it sends down odd sized I/Os to the
 * disk).  Our code currently works because whilst the very first
 * offset and the last offset in the invalid ranges are not aligned,
 * gaps in the invalid ranges between the first and last, have to be
 * aligned (because we always write page sized blocks).  For example,
 * consider this arrangement:
 *
 *         +-------------+-----+-------+------+
 *         |             |XXXXX|       |XXXXXX|
 *         +-------------+-----+-------+------+
 *                       a     b       c      d
 *
 * This shows two invalid ranges &lt;a, b&gt; and &lt;c, d&gt;.  Whilst a and d
 * are not necessarily aligned, b and c *must* be.
 *
 * Zero-filling occurs in a number of ways:
 *
 *   1. When a read occurs and we return with a_bpn == -1.
 *
 *   2. When hfs_fsync or hfs_filedone calls hfs_flush_invalid_ranges
 *      which will cause us to iterate over the ranges bringing in
 *      pages that are not present in the cache and zeroing them.  Any
 *      pages that are already in the cache are left untouched.  Note
 *      that hfs_fsync does not always flush invalid ranges.
 *
 *   3. When we extend a file we zero out from the old EOF to the end
 *      of the page.  It would be nice if we didn't have to do this if
 *      the page wasn't present (and could defer it), but because of
 *      the problem described above, we have to.
 *
 * The invalid ranges are also used to restrict the size that we write
 * out on disk: see hfs_prepare_fork_for_update.
 *
 * Note that invalid ranges are ignored when neither the VNODE_READ or
 * the VNODE_WRITE flag is specified.  This is useful for the
 * F_LOG2PHYS* fcntls which are not interested in invalid ranges: they
 * just want to know whether blocks are physically allocated or not.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_blockmap</span>(<span class="enscript-type">struct</span> vnop_blockmap_args *ap)
<span class="enscript-comment">/*
	struct vnop_blockmap_args {
		vnode_t a_vp;
		off_t a_foffset;    
		size_t a_size;
		daddr64_t *a_bpn;
		size_t *a_run;
		void *a_poff;
		int a_flags;
		vfs_context_t a_context;
	};
*/</span>
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	size_t bytesContAvail = ap-&gt;a_size;
	<span class="enscript-type">int</span> retval = E_NONE;
	<span class="enscript-type">int</span> syslocks = 0;
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">struct</span> rl_entry *invalid_range;
	<span class="enscript-type">enum</span> rl_overlaptype overlaptype;
	<span class="enscript-type">int</span> started_tr = 0;
	<span class="enscript-type">int</span> tooklock = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-comment">/* allow blockmaps to the resource fork */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ( hfs_file_is_compressed(VTOC(vp), 1) ) { <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>
			<span class="enscript-type">int</span> state = decmpfs_cnode_get_vnode_state(VTOCMP(vp));
			<span class="enscript-keyword">switch</span>(state) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
					<span class="enscript-keyword">return</span> ENOTSUP;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
					<span class="enscript-comment">/* if FILE_IS_CONVERTING, we allow blockmap */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					printf(<span class="enscript-string">&quot;invalid state %d for compressed file\n&quot;</span>, state);
					<span class="enscript-comment">/* fall through */</span>
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>

	<span class="enscript-comment">/* Do not allow blockmap operation on a directory */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	<span class="enscript-comment">/*
	 * Check for underlying vnode requests and ensure that logical
	 * to physical mapping is requested.
	 */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_bpn == NULL)
		<span class="enscript-keyword">return</span> (0);

	hfsmp = VTOHFS(vp);
	cp = VTOC(vp);
	fp = VTOF(vp);

	<span class="enscript-keyword">if</span> ( !vnode_issystem(vp) &amp;&amp; !vnode_islnk(vp) &amp;&amp; !vnode_isswap(vp)) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_lockowner != current_thread()) {
			hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
			tooklock = 1;
		}

		<span class="enscript-comment">// For reads, check the invalid ranges
</span>		<span class="enscript-keyword">if</span> (ISSET(ap-&gt;a_flags, VNODE_READ)) {
			<span class="enscript-keyword">if</span> (ap-&gt;a_foffset &gt;= fp-&gt;ff_size) {
				retval = ERANGE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}

			overlaptype = rl_scan(&amp;fp-&gt;ff_invalidranges, ap-&gt;a_foffset,
								  ap-&gt;a_foffset + (off_t)bytesContAvail - 1,
								  &amp;invalid_range);
			<span class="enscript-keyword">switch</span>(overlaptype) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_MATCHINGOVERLAP</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPCONTAINSRANGE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPSTARTSBEFORE</span>:
					<span class="enscript-comment">/* There's no valid block for this byte offset */</span>
					*ap-&gt;a_bpn = (daddr64_t)-1;
					<span class="enscript-comment">/* There's no point limiting the amount to be returned
					 * if the invalid range that was hit extends all the way
					 * to the EOF (i.e. there's no valid bytes between the
					 * end of this range and the file's EOF):
					 */</span>
					<span class="enscript-keyword">if</span> (((off_t)fp-&gt;ff_size &gt; (invalid_range-&gt;rl_end + 1)) &amp;&amp;
						((size_t)(invalid_range-&gt;rl_end + 1 - ap-&gt;a_foffset) &lt; bytesContAvail)) {
						bytesContAvail = invalid_range-&gt;rl_end + 1 - ap-&gt;a_foffset;
					}

					retval = 0;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPISCONTAINED</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_OVERLAPENDSAFTER</span>:
					<span class="enscript-comment">/* The range of interest hits an invalid block before the end: */</span>
					<span class="enscript-keyword">if</span> (invalid_range-&gt;rl_start == ap-&gt;a_foffset) {
						<span class="enscript-comment">/* There's actually no valid information to be had starting here: */</span>
						*ap-&gt;a_bpn = (daddr64_t)-1;
						<span class="enscript-keyword">if</span> (((off_t)fp-&gt;ff_size &gt; (invalid_range-&gt;rl_end + 1)) &amp;&amp;
							((size_t)(invalid_range-&gt;rl_end + 1 - ap-&gt;a_foffset) &lt; bytesContAvail)) {
							bytesContAvail = invalid_range-&gt;rl_end + 1 - ap-&gt;a_foffset;
						}

						retval = 0;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/*
						 * Sadly, the lower layers don't like us to
						 * return unaligned ranges, so we skip over
						 * any invalid ranges here that are less than
						 * a page: zeroing of those bits is not our
						 * responsibility (it's dealt with elsewhere).
						 */</span>
						<span class="enscript-keyword">do</span> {
							off_t rounded_start = round_page_64(invalid_range-&gt;rl_start);
							<span class="enscript-keyword">if</span> ((off_t)bytesContAvail &lt; rounded_start - ap-&gt;a_foffset)
								<span class="enscript-keyword">break</span>;
							<span class="enscript-keyword">if</span> (rounded_start &lt; invalid_range-&gt;rl_end + 1) {
								bytesContAvail = rounded_start - ap-&gt;a_foffset;
								<span class="enscript-keyword">break</span>;
							}
						} <span class="enscript-keyword">while</span> ((invalid_range = TAILQ_NEXT(invalid_range,
															 rl_link)));
					}
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">RL_NOOVERLAP</span>:
					<span class="enscript-keyword">break</span>;
			} <span class="enscript-comment">// switch
</span>		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry) {
		<span class="enscript-type">const</span> <span class="enscript-type">int</span> direction = (ISSET(ap-&gt;a_flags, VNODE_WRITE)
							   ? VNODE_WRITE : VNODE_READ);

		cp_io_params_t io_params;
		cp_io_params(hfsmp, cp-&gt;c_cpentry,
					 off_rsrc_make(ap-&gt;a_foffset, VNODE_IS_RSRC(vp)),
					 direction, &amp;io_params);

		<span class="enscript-keyword">if</span> (io_params.max_len &lt; (off_t)bytesContAvail)
			bytesContAvail = io_params.max_len;

		<span class="enscript-keyword">if</span> (io_params.phys_offset != -1) {
			*ap-&gt;a_bpn = ((io_params.phys_offset + hfsmp-&gt;hfsPlusIOPosOffset)
						  / hfsmp-&gt;hfs_logical_block_size);

			retval = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}
#<span class="enscript-reference">endif</span>

<span class="enscript-reference">retry</span>:

	<span class="enscript-comment">/* Check virtual blocks only when performing write operation */</span>
	<span class="enscript-keyword">if</span> ((ap-&gt;a_flags &amp; VNODE_WRITE) &amp;&amp; (fp-&gt;ff_unallocblocks != 0)) {
		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		} <span class="enscript-keyword">else</span> {
			started_tr = 1;
		}
		syslocks = SFL_EXTENTS | SFL_BITMAP;
		
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (overflow_extents(fp)) {
		syslocks = SFL_EXTENTS;
	}
	
	<span class="enscript-keyword">if</span> (syslocks)
		lockflags = hfs_systemfile_lock(hfsmp, syslocks, HFS_EXCLUSIVE_LOCK);

	<span class="enscript-comment">/*
	 * Check for any delayed allocations.
	 */</span>
	<span class="enscript-keyword">if</span> ((ap-&gt;a_flags &amp; VNODE_WRITE) &amp;&amp; (fp-&gt;ff_unallocblocks != 0)) {
		int64_t actbytes;
		u_int32_t loanedBlocks;

		<span class="enscript-comment">// 
</span>		<span class="enscript-comment">// Make sure we have a transaction.  It's possible
</span>		<span class="enscript-comment">// that we came in and fp-&gt;ff_unallocblocks was zero
</span>		<span class="enscript-comment">// but during the time we blocked acquiring the extents
</span>		<span class="enscript-comment">// btree, ff_unallocblocks became non-zero and so we
</span>		<span class="enscript-comment">// will need to start a transaction.
</span>		<span class="enscript-comment">//
</span>		<span class="enscript-keyword">if</span> (started_tr == 0) {
			<span class="enscript-keyword">if</span> (syslocks) {
				hfs_systemfile_unlock(hfsmp, lockflags);
				syslocks = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		<span class="enscript-comment">/*
		 * Note: ExtendFileC will Release any blocks on loan and
		 * aquire real blocks.  So we ask to extend by zero bytes
		 * since ExtendFileC will account for the virtual blocks.
		 */</span>

		loanedBlocks = fp-&gt;ff_unallocblocks;
		retval = ExtendFileC(hfsmp, (FCB*)fp, 0, 0,
				     kEFAllMask | kEFNoClumpMask, &amp;actbytes);

		<span class="enscript-keyword">if</span> (retval) {
			fp-&gt;ff_unallocblocks = loanedBlocks;
			cp-&gt;c_blocks += loanedBlocks;
			fp-&gt;ff_blocks += loanedBlocks;

			hfs_lock_mount (hfsmp);
			hfsmp-&gt;loanedBlocks += loanedBlocks;
			hfs_unlock_mount (hfsmp);

			hfs_systemfile_unlock(hfsmp, lockflags);
			cp-&gt;c_flag |= C_MODIFIED;
			<span class="enscript-keyword">if</span> (started_tr) {
				(<span class="enscript-type">void</span>) hfs_update(vp, 0);
				(<span class="enscript-type">void</span>) hfs_volupdate(hfsmp, VOL_UPDATE, 0);

				hfs_end_transaction(hfsmp);
				started_tr = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	retval = MapFileBlockC(hfsmp, (FCB *)fp, bytesContAvail, ap-&gt;a_foffset,
	                       ap-&gt;a_bpn, &amp;bytesContAvail);
	<span class="enscript-keyword">if</span> (syslocks) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		syslocks = 0;
	}

	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-comment">/* On write, always return error because virtual blocks, if any, 
		 * should have been allocated in ExtendFileC().  We do not 
		 * allocate virtual blocks on read, therefore return error 
		 * only if no virtual blocks are allocated.  Otherwise we search
		 * rangelist for zero-fills
		 */</span>
		<span class="enscript-keyword">if</span> ((MacToVFSError(retval) != ERANGE) ||
		    (ap-&gt;a_flags &amp; VNODE_WRITE) ||
		    ((ap-&gt;a_flags &amp; VNODE_READ) &amp;&amp; (fp-&gt;ff_unallocblocks == 0))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/* Validate if the start offset is within logical file size */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_foffset &gt;= fp-&gt;ff_size) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/*
		 * At this point, we have encountered a failure during
		 * MapFileBlockC that resulted in ERANGE, and we are not
		 * servicing a write, and there are borrowed blocks.
		 *
		 * However, the cluster layer will not call blockmap for
		 * blocks that are borrowed and in-cache.  We have to assume
		 * that because we observed ERANGE being emitted from
		 * MapFileBlockC, this extent range is not valid on-disk.  So
		 * we treat this as a mapping that needs to be zero-filled
		 * prior to reading.
		 */</span>

		<span class="enscript-keyword">if</span> (fp-&gt;ff_size - ap-&gt;a_foffset &lt; (off_t)bytesContAvail)
			bytesContAvail = fp-&gt;ff_size - ap-&gt;a_foffset;

		*ap-&gt;a_bpn = (daddr64_t) -1;
		retval = 0;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (retval == 0) {
		<span class="enscript-keyword">if</span> (ISSET(ap-&gt;a_flags, VNODE_WRITE)) {
			<span class="enscript-type">struct</span> rl_entry *r = TAILQ_FIRST(&amp;fp-&gt;ff_invalidranges);

			<span class="enscript-comment">// See if we might be overlapping invalid ranges...
</span>			<span class="enscript-keyword">if</span> (r &amp;&amp; (ap-&gt;a_foffset + (off_t)bytesContAvail) &gt; r-&gt;rl_start) {
				<span class="enscript-comment">/*
				 * Mark the file as needing an update if we think the
				 * on-disk EOF has changed.
				 */</span>
				<span class="enscript-keyword">if</span> (ap-&gt;a_foffset &lt;= r-&gt;rl_start)
					SET(cp-&gt;c_flag, C_MODIFIED);

				<span class="enscript-comment">/*
				 * This isn't the ideal place to put this.  Ideally, we
				 * should do something *after* we have successfully
				 * written to the range, but that's difficult to do
				 * because we cannot take locks in the callback.  At
				 * present, the cluster code will call us with VNODE_WRITE
				 * set just before it's about to write the data so we know
				 * that data is about to be written.  If we get an I/O
				 * error at this point then chances are the metadata
				 * update to follow will also have an I/O error so the
				 * risk here is small.
				 */</span>
				rl_remove(ap-&gt;a_foffset, ap-&gt;a_foffset + bytesContAvail - 1,
						  &amp;fp-&gt;ff_invalidranges);

				<span class="enscript-keyword">if</span> (!TAILQ_FIRST(&amp;fp-&gt;ff_invalidranges)) {
					cp-&gt;c_flag &amp;= ~C_ZFWANTSYNC;
					cp-&gt;c_zftimeout = 0;
				}
			}
		}

		<span class="enscript-keyword">if</span> (ap-&gt;a_run)
			*ap-&gt;a_run = bytesContAvail;

		<span class="enscript-keyword">if</span> (ap-&gt;a_poff)
			*(<span class="enscript-type">int</span> *)ap-&gt;a_poff = 0;
	}

	<span class="enscript-keyword">if</span> (started_tr) {
		hfs_update(vp, TRUE);
		hfs_volupdate(hfsmp, VOL_UPDATE, 0);
		hfs_end_transaction(hfsmp);
		started_tr = 0;
	}

	<span class="enscript-keyword">if</span> (tooklock)
		hfs_unlock(cp);

	<span class="enscript-keyword">return</span> (MacToVFSError(retval));
}

<span class="enscript-comment">/*
 * prepare and issue the I/O
 * buf_strategy knows how to deal
 * with requests that require 
 * fragmented I/Os
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_strategy</span>(<span class="enscript-type">struct</span> vnop_strategy_args *ap)
{
	buf_t	bp = ap-&gt;a_bp;
	vnode_t	vp = buf_vnode(bp);
	<span class="enscript-type">int</span> error = 0;
	
	<span class="enscript-comment">/* Mark buffer as containing static data if cnode flag set */</span>
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_flag &amp; C_SSD_STATIC) {
		buf_markstatic(bp);
	}
	
	<span class="enscript-comment">/* Mark buffer as containing static data if cnode flag set */</span>
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_flag &amp; C_SSD_GREEDY_MODE) {
		bufattr_markgreedymode(&amp;bp-&gt;b_attr);
	}

	<span class="enscript-comment">/* mark buffer as containing burst mode data if cnode flag set */</span>
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_flag &amp; C_IO_ISOCHRONOUS) {
		bufattr_markisochronous(&amp;bp-&gt;b_attr);
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	error = cp_handle_strategy(bp);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span>
	
	error = buf_strategy(VTOHFS(vp)-&gt;hfs_devvp, ap);
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">do_hfs_truncate</span>(<span class="enscript-type">struct</span> vnode *vp, off_t length, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> truncateflags, vfs_context_t context)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
    	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);
	kauth_cred_t cred = vfs_context_ucred(context);
	<span class="enscript-type">int</span> retval;
	off_t bytesToAdd;
	off_t actualBytesAdded;
	off_t filebytes;
	u_int32_t fileblocks;
	<span class="enscript-type">int</span> blksize;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> suppress_times = (truncateflags &amp; HFS_TRUNCATE_SKIPTIMES);

	blksize = VTOVCB(vp)-&gt;blockSize;
	fileblocks = fp-&gt;ff_blocks;
	filebytes = (off_t)fileblocks * (off_t)blksize;

	KERNEL_DEBUG(HFSDBG_TRUNCATE | DBG_FUNC_START,
		 (<span class="enscript-type">int</span>)length, (<span class="enscript-type">int</span>)fp-&gt;ff_size, (<span class="enscript-type">int</span>)filebytes, 0, 0);

	<span class="enscript-keyword">if</span> (length &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* This should only happen with a corrupt filesystem */</span>
	<span class="enscript-keyword">if</span> ((off_t)fp-&gt;ff_size &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((!ISHFSPLUS(VTOVCB(vp))) &amp;&amp; (length &gt; (off_t)MAXHFSFILESIZE))
		<span class="enscript-keyword">return</span> (EFBIG);

	hfsmp = VTOHFS(vp);

	retval = E_NONE;

	<span class="enscript-comment">/* Files that are changing size are not hot file candidates. */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfc_stage == HFC_RECORDING) {
		fp-&gt;ff_bytesread = 0;
	}

	<span class="enscript-comment">/* 
	 * We cannot just check if fp-&gt;ff_size == length (as an optimization)
	 * since there may be extra physical blocks that also need truncation.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> ((retval = hfs_getinoquota(cp)))
		<span class="enscript-keyword">return</span>(retval);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-comment">/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of ff_size is 0, length will be at least 1.
	 */</span>
	<span class="enscript-keyword">if</span> (length &gt; (off_t)fp-&gt;ff_size) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		retval = hfs_chkdq(cp, (int64_t)(roundup(length - filebytes, blksize)),
				   cred, 0);
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
		<span class="enscript-comment">/*
		 * If we don't have enough physical space then
		 * we need to extend the physical size.
		 */</span>
		<span class="enscript-keyword">if</span> (length &gt; filebytes) {
			<span class="enscript-type">int</span> eflags;
			u_int32_t blockHint = 0;

			<span class="enscript-comment">/* All or nothing and don't round up to clumpsize. */</span>
			eflags = kEFAllMask | kEFNoClumpMask;

			<span class="enscript-keyword">if</span> (cred &amp;&amp; (suser(cred, NULL) != 0)) {
				eflags |= kEFReserveMask;  <span class="enscript-comment">/* keep a reserve */</span>
			}

			<span class="enscript-comment">/*
			 * Allocate Journal and Quota files in metadata zone.
			 */</span>
			<span class="enscript-keyword">if</span> (filebytes == 0 &amp;&amp;
			    hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE &amp;&amp;
			    hfs_virtualmetafile(cp)) {
				eflags |= kEFMetadataMask;
				blockHint = hfsmp-&gt;hfs_metazone_start;
			}
			<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			    retval = EINVAL;
			    <span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
			}

			<span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
			lockflags = SFL_BITMAP;
			<span class="enscript-keyword">if</span> (overflow_extents(fp))
				lockflags |= SFL_EXTENTS;
			lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);

			<span class="enscript-comment">/* 
			 * Keep growing the file as long as the current EOF is
			 * less than the desired value.
			 */</span>
			<span class="enscript-keyword">while</span> ((length &gt; filebytes) &amp;&amp; (retval == E_NONE)) {
				bytesToAdd = length - filebytes;
				retval = MacToVFSError(ExtendFileC(VTOVCB(vp),
                                                    (FCB*)fp,
                                                    bytesToAdd,
                                                    blockHint,
                                                    eflags,
                                                    &amp;actualBytesAdded));

				filebytes = (off_t)fp-&gt;ff_blocks * (off_t)blksize;
				<span class="enscript-keyword">if</span> (actualBytesAdded == 0 &amp;&amp; retval == E_NONE) {
					<span class="enscript-keyword">if</span> (length &gt; filebytes)
						length = filebytes;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-comment">/* endwhile */</span>

			hfs_systemfile_unlock(hfsmp, lockflags);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
				hfs_update(vp, 0);
				hfs_volupdate(hfsmp, VOL_UPDATE, 0);
			}

			hfs_end_transaction(hfsmp);

			<span class="enscript-keyword">if</span> (retval)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;

			KERNEL_DEBUG(HFSDBG_TRUNCATE | DBG_FUNC_NONE,
				(<span class="enscript-type">int</span>)length, (<span class="enscript-type">int</span>)fp-&gt;ff_size, (<span class="enscript-type">int</span>)filebytes, 0, 0);
		}
 
		<span class="enscript-keyword">if</span> (ISSET(flags, IO_NOZEROFILL)) {
			<span class="enscript-comment">// An optimisation for the hibernation file
</span>			<span class="enscript-keyword">if</span> (vnode_isswap(vp))
				rl_remove_all(&amp;fp-&gt;ff_invalidranges);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp)  &amp;&amp; (vnode_issystem(vp) == 0) &amp;&amp; retval == E_NONE) {
				<span class="enscript-keyword">if</span> (length &gt; (off_t)fp-&gt;ff_size) {
					<span class="enscript-type">struct</span> timeval tv;

		   			<span class="enscript-comment">/* Extending the file: time to fill out the current last page w. zeroes? */</span>
					<span class="enscript-keyword">if</span> (fp-&gt;ff_size &amp; PAGE_MASK_64) {
						<span class="enscript-comment">/* There might be some valid data at the start of the (current) last page
						   of the file, so zero out the remainder of that page to ensure the
						   entire page contains valid data. */</span>
						hfs_unlock(cp);
						retval = hfs_zero_eof_page(vp, length);
						hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
						<span class="enscript-keyword">if</span> (retval) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
					}
					microuptime(&amp;tv);
					rl_add(fp-&gt;ff_size, length - 1, &amp;fp-&gt;ff_invalidranges);
					cp-&gt;c_zftimeout = tv.tv_sec + ZFTIMELIMIT;
				}
			} <span class="enscript-keyword">else</span> {
					panic(<span class="enscript-string">&quot;hfs_truncate: invoked on non-UBC object?!&quot;</span>);
			};
		}
		<span class="enscript-keyword">if</span> (suppress_times == 0) {
			cp-&gt;c_touch_modtime = TRUE;
		}
		fp-&gt;ff_size = length;

	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* Shorten the size of the file */</span>

		<span class="enscript-comment">// An optimisation for the hibernation file
</span>		<span class="enscript-keyword">if</span> (ISSET(flags, IO_NOZEROFILL) &amp;&amp; vnode_isswap(vp)) {
			rl_remove_all(&amp;fp-&gt;ff_invalidranges);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((off_t)fp-&gt;ff_size &gt; length) {
			<span class="enscript-comment">/* Any space previously marked as invalid is now irrelevant: */</span>
			rl_remove(length, fp-&gt;ff_size - 1, &amp;fp-&gt;ff_invalidranges);
		}

		<span class="enscript-comment">/* 
		 * Account for any unmapped blocks. Note that the new
		 * file length can still end up with unmapped blocks.
		 */</span>
		<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks &gt; 0) {
			u_int32_t finalblks;
			u_int32_t loanedBlocks;

			hfs_lock_mount(hfsmp);
			loanedBlocks = fp-&gt;ff_unallocblocks;
			cp-&gt;c_blocks -= loanedBlocks;
			fp-&gt;ff_blocks -= loanedBlocks;
			fp-&gt;ff_unallocblocks = 0;

			hfsmp-&gt;loanedBlocks -= loanedBlocks;

			finalblks = (length + blksize - 1) / blksize;
			<span class="enscript-keyword">if</span> (finalblks &gt; fp-&gt;ff_blocks) {
				<span class="enscript-comment">/* calculate required unmapped blocks */</span>
				loanedBlocks = finalblks - fp-&gt;ff_blocks;
				hfsmp-&gt;loanedBlocks += loanedBlocks;

				fp-&gt;ff_unallocblocks = loanedBlocks;
				cp-&gt;c_blocks += loanedBlocks;
				fp-&gt;ff_blocks += loanedBlocks;
			}
			hfs_unlock_mount (hfsmp);
		}

		off_t savedbytes = ((off_t)fp-&gt;ff_blocks * (off_t)blksize);
		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
		}

		<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks == 0) {
			<span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
			lockflags = SFL_BITMAP;
			<span class="enscript-keyword">if</span> (overflow_extents(fp))
				lockflags |= SFL_EXTENTS;
			lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);

			retval = MacToVFSError(TruncateFileC(VTOVCB(vp), (FCB*)fp, length, 0, 
												 FORK_IS_RSRC (fp), FTOC(fp)-&gt;c_fileid, false));

			hfs_systemfile_unlock(hfsmp, lockflags);
		}
		<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			<span class="enscript-keyword">if</span> (retval == 0) {
				fp-&gt;ff_size = length;
			}
			hfs_update(vp, 0);
			hfs_volupdate(hfsmp, VOL_UPDATE, 0);
		}
		hfs_end_transaction(hfsmp);

		filebytes = (off_t)fp-&gt;ff_blocks * (off_t)blksize;
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		<span class="enscript-comment">/* These are bytesreleased */</span>
		(<span class="enscript-type">void</span>) hfs_chkdq(cp, (int64_t)-(savedbytes - filebytes), NOCRED, 0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// Unlike when growing a file, we adjust the hotfile block count here
</span>		<span class="enscript-comment">// instead of deeper down in the block allocation code because we do
</span>		<span class="enscript-comment">// not necessarily have a vnode or &quot;fcb&quot; at the time we're deleting
</span>		<span class="enscript-comment">// the file and so we wouldn't know if it was hotfile cached or not
</span>		<span class="enscript-comment">//
</span>		hfs_hotfile_adjust_blocks(vp, (int64_t)((savedbytes - filebytes) / blksize));


		<span class="enscript-comment">/* 
		 * Only set update flag if the logical length changes &amp; we aren't
		 * suppressing modtime updates.
		 */</span>
		<span class="enscript-keyword">if</span> (((off_t)fp-&gt;ff_size != length) &amp;&amp; (suppress_times == 0)) {
			cp-&gt;c_touch_modtime = TRUE;
		}
		fp-&gt;ff_size = length;
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_mode &amp; (S_ISUID | S_ISGID)) {
		<span class="enscript-keyword">if</span> (!vfs_context_issuser(context))
			cp-&gt;c_mode &amp;= ~(S_ISUID | S_ISGID);
	}
	cp-&gt;c_flag |= C_MODIFIED;
	cp-&gt;c_touch_chgtime = TRUE;	<span class="enscript-comment">/* status changed */</span>
	<span class="enscript-keyword">if</span> (suppress_times == 0) {
		cp-&gt;c_touch_modtime = TRUE;	<span class="enscript-comment">/* file data was modified */</span>

		<span class="enscript-comment">/*
		 * If we are not suppressing the modtime update, then
		 * update the gen count as well.
		 */</span>
		<span class="enscript-keyword">if</span> (S_ISREG(cp-&gt;c_attr.ca_mode) || S_ISLNK (cp-&gt;c_attr.ca_mode)) {
			hfs_incr_gencount(cp);
		}
	}

	retval = hfs_update(vp, 0);
	<span class="enscript-keyword">if</span> (retval) {
		KERNEL_DEBUG(HFSDBG_TRUNCATE | DBG_FUNC_NONE,
		     -1, -1, -1, retval, 0);
	}

<span class="enscript-reference">Err_Exit</span>:

	KERNEL_DEBUG(HFSDBG_TRUNCATE | DBG_FUNC_END,
		 (<span class="enscript-type">int</span>)length, (<span class="enscript-type">int</span>)fp-&gt;ff_size, (<span class="enscript-type">int</span>)filebytes, retval, 0);

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Preparation which must be done prior to deleting the catalog record
 * of a file or directory.  In order to make the on-disk as safe as possible,
 * we remove the catalog entry before releasing the bitmap blocks and the 
 * overflow extent records.  However, some work must be done prior to deleting
 * the catalog record.
 * 
 * When calling this function, the cnode must exist both in memory and on-disk.
 * If there are both resource fork and data fork vnodes, this function should
 * be called on both.  
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_prepare_release_storage</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp) {
	
	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> retval = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
	
	<span class="enscript-comment">/* Cannot truncate an HFS directory! */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-keyword">return</span> (EISDIR);
	}
	
	<span class="enscript-comment">/* 
	 * See the comment below in hfs_truncate for why we need to call 
	 * setsize here.  Essentially we want to avoid pending IO if we 
	 * already know that the blocks are going to be released here.
	 * This function is only called when totally removing all storage for a file, so
	 * we can take a shortcut and immediately setsize (0);
	 */</span>
	ubc_setsize(vp, 0);
	
	<span class="enscript-comment">/* This should only happen with a corrupt filesystem */</span>
	<span class="enscript-keyword">if</span> ((off_t)fp-&gt;ff_size &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);
	
	<span class="enscript-comment">/* 
	 * We cannot just check if fp-&gt;ff_size == length (as an optimization)
	 * since there may be extra physical blocks that also need truncation.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-keyword">if</span> ((retval = hfs_getinoquota(cp))) {
		<span class="enscript-keyword">return</span>(retval);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
	
	<span class="enscript-comment">/* Wipe out any invalid ranges which have yet to be backed by disk */</span>
	rl_remove(0, fp-&gt;ff_size - 1, &amp;fp-&gt;ff_invalidranges);
	
	<span class="enscript-comment">/* 
	 * Account for any unmapped blocks. Since we're deleting the 
	 * entire file, we don't have to worry about just shrinking
	 * to a smaller number of borrowed blocks.
	 */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks &gt; 0) {
		u_int32_t loanedBlocks;
		
		hfs_lock_mount (hfsmp);
		loanedBlocks = fp-&gt;ff_unallocblocks;
		cp-&gt;c_blocks -= loanedBlocks;
		fp-&gt;ff_blocks -= loanedBlocks;
		fp-&gt;ff_unallocblocks = 0;
		
		hfsmp-&gt;loanedBlocks -= loanedBlocks;
		
		hfs_unlock_mount (hfsmp);
	}
	
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * Special wrapper around calling TruncateFileC.  This function is useable
 * even when the catalog record does not exist any longer, making it ideal
 * for use when deleting a file.  The simplification here is that we know 
 * that we are releasing all blocks.
 *
 * Note that this function may be called when there is no vnode backing
 * the file fork in question.  We may call this from hfs_vnop_inactive
 * to clear out resource fork data (and may not want to clear out the data 
 * fork yet).  As a result, we pointer-check both sets of inputs before 
 * doing anything with them.
 *
 * The caller is responsible for saving off a copy of the filefork(s)
 * embedded within the cnode prior to calling this function.  The pointers
 * supplied as arguments must be valid even if the cnode is no longer valid.
 */</span>

<span class="enscript-type">int</span> 
<span class="enscript-function-name">hfs_release_storage</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> filefork *datafork, 
					 <span class="enscript-type">struct</span> filefork *rsrcfork, u_int32_t fileid) {
	
	off_t filebytes;
	u_int32_t fileblocks;
	<span class="enscript-type">int</span> blksize = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> lockflags;
	
	blksize = hfsmp-&gt;blockSize;
	
	<span class="enscript-comment">/* Data Fork */</span>
	<span class="enscript-keyword">if</span> (datafork) {
		off_t prev_filebytes;
		datafork-&gt;ff_size = 0;

		fileblocks = datafork-&gt;ff_blocks;
		filebytes = (off_t)fileblocks * (off_t)blksize;
		prev_filebytes = filebytes;
		
		<span class="enscript-comment">/* We killed invalid ranges and loaned blocks before we removed the catalog entry */</span>
		
		<span class="enscript-keyword">while</span> (filebytes &gt; 0) {
			<span class="enscript-keyword">if</span> (filebytes &gt; HFS_BIGFILE_SIZE) {
				filebytes -= HFS_BIGFILE_SIZE;
			} <span class="enscript-keyword">else</span> {
				filebytes = 0;
			}
			
			<span class="enscript-comment">/* Start a transaction, and wipe out as many blocks as we can in this iteration */</span>
			<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (datafork-&gt;ff_unallocblocks == 0) {
				<span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
				lockflags = SFL_BITMAP;
				<span class="enscript-keyword">if</span> (overflow_extents(datafork))
					lockflags |= SFL_EXTENTS;
				lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
				
				error = MacToVFSError(TruncateFileC(HFSTOVCB(hfsmp), datafork, filebytes, 1, 0, fileid, false));
				
				hfs_systemfile_unlock(hfsmp, lockflags);
			}
			(<span class="enscript-type">void</span>) hfs_volupdate(hfsmp, VOL_UPDATE, 0);
			
			<span class="enscript-type">struct</span> cnode *cp = datafork ? FTOC(datafork) : NULL;
			<span class="enscript-type">struct</span> vnode *vp;
			vp = cp ? CTOV(cp, 0) : NULL;
			hfs_hotfile_adjust_blocks(vp, (int64_t)((prev_filebytes - filebytes) / blksize));
			prev_filebytes = filebytes;
			
			<span class="enscript-comment">/* Finish the transaction and start over if necessary */</span>
			hfs_end_transaction(hfsmp);
			
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	
	<span class="enscript-comment">/* Resource fork */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; rsrcfork) {
		rsrcfork-&gt;ff_size = 0;

		fileblocks = rsrcfork-&gt;ff_blocks;
		filebytes = (off_t)fileblocks * (off_t)blksize;
		
		<span class="enscript-comment">/* We killed invalid ranges and loaned blocks before we removed the catalog entry */</span>
		
		<span class="enscript-keyword">while</span> (filebytes &gt; 0) {
			<span class="enscript-keyword">if</span> (filebytes &gt; HFS_BIGFILE_SIZE) {
				filebytes -= HFS_BIGFILE_SIZE;
			} <span class="enscript-keyword">else</span> {
				filebytes = 0;
			}
			
			<span class="enscript-comment">/* Start a transaction, and wipe out as many blocks as we can in this iteration */</span>
			<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (rsrcfork-&gt;ff_unallocblocks == 0) {
				<span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
				lockflags = SFL_BITMAP;
				<span class="enscript-keyword">if</span> (overflow_extents(rsrcfork))
					lockflags |= SFL_EXTENTS;
				lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
				
				error = MacToVFSError(TruncateFileC(HFSTOVCB(hfsmp), rsrcfork, filebytes, 1, 1, fileid, false));
				
				hfs_systemfile_unlock(hfsmp, lockflags);
			}
			(<span class="enscript-type">void</span>) hfs_volupdate(hfsmp, VOL_UPDATE, 0);
			
			<span class="enscript-comment">/* Finish the transaction and start over if necessary */</span>
			hfs_end_transaction(hfsmp);			
			
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	
	<span class="enscript-keyword">return</span> error;
}

errno_t <span class="enscript-function-name">hfs_ubc_setsize</span>(vnode_t vp, off_t len, bool have_cnode_lock)
{
	errno_t error;

	<span class="enscript-comment">/*
	 * Call ubc_setsize to give the VM subsystem a chance to do
	 * whatever it needs to with existing pages before we delete
	 * blocks.  Note that symlinks don't use the UBC so we'll
	 * get back ENOENT in that case.
	 */</span>
	<span class="enscript-keyword">if</span> (have_cnode_lock) {
		error = ubc_setsize_ex(vp, len, UBC_SETSIZE_NO_FS_REENTRY);
		<span class="enscript-keyword">if</span> (error == EAGAIN) {
			cnode_t *cp = VTOC(vp);

			<span class="enscript-keyword">if</span> (cp-&gt;c_truncatelockowner != current_thread()) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
				panic(<span class="enscript-string">&quot;hfs: hfs_ubc_setsize called without exclusive truncate lock!&quot;</span>);
#<span class="enscript-reference">else</span>
				printf(<span class="enscript-string">&quot;hfs: hfs_ubc_setsize called without exclusive truncate lock!\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			}

			hfs_unlock(cp);
			error = ubc_setsize_ex(vp, len, 0);
			hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);
		}
	} <span class="enscript-keyword">else</span>
		error = ubc_setsize_ex(vp, len, 0);

	<span class="enscript-keyword">return</span> error == ENOENT ? 0 : error;
}

<span class="enscript-comment">/*
 * Truncate a cnode to at most length size, freeing (or adding) the
 * disk blocks.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_truncate</span>(<span class="enscript-type">struct</span> vnode *vp, off_t length, <span class="enscript-type">int</span> flags,
			 <span class="enscript-type">int</span> truncateflags, vfs_context_t context)
{
	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);
	off_t filebytes;
	u_int32_t fileblocks;
	<span class="enscript-type">int</span> blksize;
	errno_t error = 0;
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	hfsmount_t *hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/* Cannot truncate an HFS directory! */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-keyword">return</span> (EISDIR);
	}
	<span class="enscript-comment">/* A swap file cannot change size. */</span>
	<span class="enscript-keyword">if</span> (vnode_isswap(vp) &amp;&amp; length &amp;&amp; !ISSET(flags, IO_NOAUTH)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

	blksize = hfsmp-&gt;blockSize;
	fileblocks = fp-&gt;ff_blocks;
	filebytes = (off_t)fileblocks * (off_t)blksize;

	bool caller_has_cnode_lock = (cp-&gt;c_lockowner == current_thread());

	error = hfs_ubc_setsize(vp, length, caller_has_cnode_lock);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-keyword">if</span> (!caller_has_cnode_lock) {
		error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">// have to loop truncating or growing files that are
</span>	<span class="enscript-comment">// really big because otherwise transactions can get
</span>	<span class="enscript-comment">// enormous and consume too many kernel resources.
</span>
	<span class="enscript-keyword">if</span> (length &lt; filebytes) {
		<span class="enscript-keyword">while</span> (filebytes &gt; length) {
			<span class="enscript-keyword">if</span> ((filebytes - length) &gt; HFS_BIGFILE_SIZE) {
		    		filebytes -= HFS_BIGFILE_SIZE;
			} <span class="enscript-keyword">else</span> {
		    		filebytes = length;
			}
			error = do_hfs_truncate(vp, filebytes, flags, truncateflags, context);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (length &gt; filebytes) {
		kauth_cred_t cred = vfs_context_ucred(context);
		<span class="enscript-type">const</span> bool keep_reserve = cred &amp;&amp; suser(cred, NULL) != 0;

		<span class="enscript-keyword">if</span> (hfs_freeblks(hfsmp, keep_reserve)
			&lt; howmany(length - filebytes, blksize)) {
			error = ENOSPC;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">while</span> (filebytes &lt; length) {
				<span class="enscript-keyword">if</span> ((length - filebytes) &gt; HFS_BIGFILE_SIZE) {
					filebytes += HFS_BIGFILE_SIZE;
				} <span class="enscript-keyword">else</span> {
					filebytes = length;
				}
				error = do_hfs_truncate(vp, filebytes, flags, truncateflags, context);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* Same logical size */</span> {

		error = do_hfs_truncate(vp, length, flags, truncateflags, context);
	}
	<span class="enscript-comment">/* Files that are changing size are not hot file candidates. */</span>
	<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;hfc_stage == HFC_RECORDING) {
		fp-&gt;ff_bytesread = 0;
	}


	<span class="enscript-keyword">if</span> (!caller_has_cnode_lock)
		hfs_unlock(cp);

	<span class="enscript-comment">// Make sure UBC's size matches up (in case we didn't completely succeed)
</span>	errno_t err2 = hfs_ubc_setsize(vp, fp-&gt;ff_size, caller_has_cnode_lock);
	<span class="enscript-keyword">if</span> (!error)
		error = err2;

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Preallocate file storage space.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_allocate</span>(<span class="enscript-type">struct</span> vnop_allocate_args <span class="enscript-comment">/* {
		vnode_t a_vp;
		off_t a_length;
		u_int32_t  a_flags;
		off_t *a_bytesallocated;
		off_t a_offset;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	ExtendedVCB *vcb;
	off_t length = ap-&gt;a_length;
	off_t startingPEOF;
	off_t moreBytesRequested;
	off_t actualBytesAdded;
	off_t filebytes;
	u_int32_t fileblocks;
	<span class="enscript-type">int</span> retval, retval2;
	u_int32_t blockHint;
	u_int32_t extendFlags;   <span class="enscript-comment">/* For call to ExtendFileC */</span>
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	kauth_cred_t cred = vfs_context_ucred(ap-&gt;a_context);
	<span class="enscript-type">int</span> lockflags;
	time_t orig_ctime;

	*(ap-&gt;a_bytesallocated) = 0;

	<span class="enscript-keyword">if</span> (!vnode_isreg(vp))
		<span class="enscript-keyword">return</span> (EISDIR);
	<span class="enscript-keyword">if</span> (length &lt; (off_t)0)
		<span class="enscript-keyword">return</span> (EINVAL);
	
	cp = VTOC(vp);

	orig_ctime = VTOC(vp)-&gt;c_ctime;

	check_for_tracked_file(vp, orig_ctime, ap-&gt;a_length == 0 ? NAMESPACE_HANDLER_TRUNCATE_OP|NAMESPACE_HANDLER_DELETE_OP : NAMESPACE_HANDLER_TRUNCATE_OP, NULL);

	hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);

	<span class="enscript-keyword">if</span> ((retval = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
	}
	
	fp = VTOF(vp);
	hfsmp = VTOHFS(vp);
	vcb = VTOVCB(vp);

	fileblocks = fp-&gt;ff_blocks;
	filebytes = (off_t)fileblocks * (off_t)vcb-&gt;blockSize;

	<span class="enscript-keyword">if</span> ((ap-&gt;a_flags &amp; ALLOCATEFROMVOL) &amp;&amp; (length &lt; filebytes)) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
	}

	<span class="enscript-comment">/* Fill in the flags word for the call to Extend the file */</span>

	extendFlags = kEFNoClumpMask;
	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; ALLOCATECONTIG) 
		extendFlags |= kEFContigMask;
	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; ALLOCATEALL)
		extendFlags |= kEFAllMask;
	<span class="enscript-keyword">if</span> (cred &amp;&amp; suser(cred, NULL) != 0)
		extendFlags |= kEFReserveMask;
	<span class="enscript-keyword">if</span> (hfs_virtualmetafile(cp))
		extendFlags |= kEFMetadataMask;

	retval = E_NONE;
	blockHint = 0;
	startingPEOF = filebytes;

	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; ALLOCATEFROMPEOF)
		length += filebytes;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; ALLOCATEFROMVOL)
		blockHint = ap-&gt;a_offset / VTOVCB(vp)-&gt;blockSize;

	<span class="enscript-comment">/* If no changes are necesary, then we're done */</span>
	<span class="enscript-keyword">if</span> (filebytes == length)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">Std_Exit</span>;

	<span class="enscript-comment">/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of filebytes is 0, length will be at least 1.
	 */</span>
	<span class="enscript-keyword">if</span> (length &gt; filebytes) {
		<span class="enscript-keyword">if</span> (ISSET(extendFlags, kEFAllMask)
			&amp;&amp; (hfs_freeblks(hfsmp, ISSET(extendFlags, kEFReserveMask))
				&lt; howmany(length - filebytes, hfsmp-&gt;blockSize))) {
			retval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
		}

		off_t total_bytes_added = 0, orig_request_size;

		orig_request_size = moreBytesRequested = length - filebytes;
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		retval = hfs_chkdq(cp,
				(int64_t)(roundup(moreBytesRequested, vcb-&gt;blockSize)), 
				cred, 0);
		<span class="enscript-keyword">if</span> (retval)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
		<span class="enscript-comment">/*
		 * Metadata zone checks.
		 */</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_METADATA_ZONE) {
			<span class="enscript-comment">/*
			 * Allocate Journal and Quota files in metadata zone.
			 */</span>
			<span class="enscript-keyword">if</span> (hfs_virtualmetafile(cp)) {
				blockHint = hfsmp-&gt;hfs_metazone_start;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((blockHint &gt;= hfsmp-&gt;hfs_metazone_start) &amp;&amp;
				   (blockHint &lt;= hfsmp-&gt;hfs_metazone_end)) {
				<span class="enscript-comment">/*
				 * Move blockHint outside metadata zone.
				 */</span>
				blockHint = hfsmp-&gt;hfs_metazone_end + 1;
			}
		}


		<span class="enscript-keyword">while</span> ((length &gt; filebytes) &amp;&amp; (retval == E_NONE)) {
		    off_t bytesRequested;
		    
		    <span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
		    }

		    <span class="enscript-comment">/* Protect extents b-tree and allocation bitmap */</span>
		    lockflags = SFL_BITMAP;
		    <span class="enscript-keyword">if</span> (overflow_extents(fp))
				lockflags |= SFL_EXTENTS;
		    lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);

		    <span class="enscript-keyword">if</span> (moreBytesRequested &gt;= HFS_BIGFILE_SIZE) {
				bytesRequested = HFS_BIGFILE_SIZE;
		    } <span class="enscript-keyword">else</span> {
				bytesRequested = moreBytesRequested;
		    }

		    <span class="enscript-keyword">if</span> (extendFlags &amp; kEFContigMask) {
			    <span class="enscript-comment">// if we're on a sparse device, this will force it to do a
</span>			    <span class="enscript-comment">// full scan to find the space needed.
</span>			    hfsmp-&gt;hfs_flags &amp;= ~HFS_DID_CONTIG_SCAN;
		    }

		    retval = MacToVFSError(ExtendFileC(vcb,
						(FCB*)fp,
						bytesRequested,
						blockHint,
						extendFlags,
						&amp;actualBytesAdded));

		    <span class="enscript-keyword">if</span> (retval == E_NONE) {
			*(ap-&gt;a_bytesallocated) += actualBytesAdded;
			total_bytes_added += actualBytesAdded;
			moreBytesRequested -= actualBytesAdded;
			<span class="enscript-keyword">if</span> (blockHint != 0) {
			    blockHint += actualBytesAdded / vcb-&gt;blockSize;
			}
		    }
		    filebytes = (off_t)fp-&gt;ff_blocks * (off_t)vcb-&gt;blockSize;
		    
		    hfs_systemfile_unlock(hfsmp, lockflags);

		    <span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
			(<span class="enscript-type">void</span>) hfs_update(vp, 0);
			(<span class="enscript-type">void</span>) hfs_volupdate(hfsmp, VOL_UPDATE, 0);
		    }

		    hfs_end_transaction(hfsmp);
		}


		<span class="enscript-comment">/*
		 * if we get an error and no changes were made then exit
		 * otherwise we must do the hfs_update to reflect the changes
		 */</span>
		<span class="enscript-keyword">if</span> (retval &amp;&amp; (startingPEOF == filebytes))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
        
		<span class="enscript-comment">/*
		 * Adjust actualBytesAdded to be allocation block aligned, not
		 * clump size aligned.
		 * NOTE: So what we are reporting does not affect reality
		 * until the file is closed, when we truncate the file to allocation
		 * block size.
		 */</span>
		<span class="enscript-keyword">if</span> (total_bytes_added != 0 &amp;&amp; orig_request_size &lt; total_bytes_added)
			*(ap-&gt;a_bytesallocated) =
				roundup(orig_request_size, (off_t)vcb-&gt;blockSize);

	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* Shorten the size of the file */</span>

		<span class="enscript-comment">/*
		 * N.B. At present, this code is never called.  If and when we
		 * do start using it, it looks like there might be slightly
		 * strange semantics with the file size: it's possible for the
		 * file size to *increase* e.g. if current file size is 5,
		 * length is 1024 and filebytes is 4096, the file size will
		 * end up being 1024 bytes.  This isn't necessarily a problem
		 * but it's not consistent with the code above which doesn't
		 * change the file size.
		 */</span>

		retval = hfs_truncate(vp, length, 0, 0, ap-&gt;a_context);
		filebytes = (off_t)fp-&gt;ff_blocks * (off_t)vcb-&gt;blockSize;

		<span class="enscript-comment">/*
		 * if we get an error and no changes were made then exit
		 * otherwise we must do the hfs_update to reflect the changes
		 */</span>
		<span class="enscript-keyword">if</span> (retval &amp;&amp; (startingPEOF == filebytes)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">Err_Exit</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		<span class="enscript-comment">/* These are  bytesreleased */</span>
		(<span class="enscript-type">void</span>) hfs_chkdq(cp, (int64_t)-((startingPEOF - filebytes)), NOCRED,0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

		<span class="enscript-keyword">if</span> (fp-&gt;ff_size &gt; filebytes) {
			fp-&gt;ff_size = filebytes;

			hfs_ubc_setsize(vp, fp-&gt;ff_size, true);
		}
	}

<span class="enscript-reference">Std_Exit</span>:
	cp-&gt;c_flag |= C_MODIFIED;
	cp-&gt;c_touch_chgtime = TRUE;
	cp-&gt;c_touch_modtime = TRUE;
	retval2 = hfs_update(vp, 0);

	<span class="enscript-keyword">if</span> (retval == 0)
		retval = retval2;
<span class="enscript-reference">Err_Exit</span>:
	hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-comment">/*
 * Pagein for HFS filesystem
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_pagein</span>(<span class="enscript-type">struct</span> vnop_pagein_args *ap)
<span class="enscript-comment">/*
	struct vnop_pagein_args {
	   	vnode_t a_vp,
	   	upl_t 	      a_pl,
		vm_offset_t   a_pl_offset,
		off_t         a_f_offset,
		size_t        a_size,
		int           a_flags
		vfs_context_t a_context;
	};
*/</span>
{
	vnode_t 	vp;
	<span class="enscript-type">struct</span> cnode	*cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">int</span>		error = 0;
	upl_t 		upl;
	upl_page_info_t	*pl;
	off_t		f_offset;
	off_t		page_needed_f_offset;
	<span class="enscript-type">int</span>		offset;
	<span class="enscript-type">int</span>		isize; 
	<span class="enscript-type">int</span>		upl_size; 
	<span class="enscript-type">int</span>		pg_index;
	boolean_t	truncate_lock_held = FALSE;
	boolean_t 	file_converted = FALSE;
	kern_return_t	kret;
	
	vp = ap-&gt;a_vp;
	cp = VTOC(vp);
	fp = VTOF(vp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> ((error = cp_handle_vnop(vp, CP_READ_ACCESS | CP_WRITE_ACCESS, 0)) != 0) {
		<span class="enscript-comment">/* 
		 * If we errored here, then this means that one of two things occurred:
		 * 1. there was a problem with the decryption of the key.
		 * 2. the device is locked and we are not allowed to access this particular file.
		 * 
		 * Either way, this means that we need to shut down this upl now.  As long as 
		 * the pl pointer is NULL (meaning that we're supposed to create the UPL ourselves)
		 * then we create a upl and immediately abort it.
		 */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_pl == NULL) {
			<span class="enscript-comment">/* create the upl */</span>
			ubc_create_upl (vp, ap-&gt;a_f_offset, ap-&gt;a_size, &amp;upl, &amp;pl, 
					UPL_UBC_PAGEIN | UPL_RET_ONLY_ABSENT);
			<span class="enscript-comment">/* mark the range as needed so it doesn't immediately get discarded upon abort */</span>
			ubc_upl_range_needed (upl, ap-&gt;a_pl_offset / PAGE_SIZE, 1);
	
			<span class="enscript-comment">/* Abort the range */</span>
			ubc_upl_abort_range (upl, 0, ap-&gt;a_size, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR);
		}

	
		<span class="enscript-keyword">return</span> error;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>

	<span class="enscript-keyword">if</span> (ap-&gt;a_pl != NULL) {
		<span class="enscript-comment">/*
		 * this can only happen for swap files now that
		 * we're asking for V2 paging behavior...
		 * so don't need to worry about decompression, or
		 * keeping track of blocks read or taking the truncate lock
		 */</span>
		error = cluster_pagein(vp, ap-&gt;a_pl, ap-&gt;a_pl_offset, ap-&gt;a_f_offset,
				       ap-&gt;a_size, (off_t)fp-&gt;ff_size, ap-&gt;a_flags);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagein_done</span>;
	}

	page_needed_f_offset = ap-&gt;a_f_offset + ap-&gt;a_pl_offset;

<span class="enscript-reference">retry_pagein</span>:
	<span class="enscript-comment">/*
	 * take truncate lock (shared/recursive) to guard against 
	 * zero-fill thru fsync interfering, but only for v2
	 *
	 * the HFS_RECURSE_TRUNCLOCK arg indicates that we want the 
	 * lock shared and we are allowed to recurse 1 level if this thread already
	 * owns the lock exclusively... this can legally occur
	 * if we are doing a shrinking ftruncate against a file
	 * that is mapped private, and the pages being truncated
	 * do not currently exist in the cache... in that case
	 * we will have to page-in the missing pages in order
	 * to provide them to the private mapping... we must
	 * also call hfs_unlock_truncate with a postive been_recursed 
	 * arg to indicate that if we have recursed, there is no need to drop
	 * the lock.  Allowing this simple recursion is necessary
	 * in order to avoid a certain deadlock... since the ftruncate
	 * already holds the truncate lock exclusively, if we try
	 * to acquire it shared to protect the pagein path, we will
	 * hang this thread
	 *
	 * NOTE: The if () block below is a workaround in order to prevent a 
	 * VM deadlock. See rdar://7853471.
	 * 
	 * If we are in a forced unmount, then launchd will still have the 
	 * dyld_shared_cache file mapped as it is trying to reboot.  If we 
	 * take the truncate lock here to service a page fault, then our 
	 * thread could deadlock with the forced-unmount.  The forced unmount 
	 * thread will try to reclaim the dyld_shared_cache vnode, but since it's 
	 * marked C_DELETED, it will call ubc_setsize(0).  As a result, the unmount 
	 * thread will think it needs to copy all of the data out of the file 
	 * and into a VM copy object.  If we hold the cnode lock here, then that 
	 * VM operation will not be able to proceed, because we'll set a busy page 
	 * before attempting to grab the lock.  Note that this isn't as simple as &quot;don't
	 * call ubc_setsize&quot; because doing that would just shift the problem to the
	 * ubc_msync done before the vnode is reclaimed.
	 *
	 * So, if a forced unmount on this volume is in flight AND the cnode is 
	 * marked C_DELETED, then just go ahead and do the page in without taking 
	 * the lock (thus suspending pagein_v2 semantics temporarily).  Since it's on a file
	 * that is not going to be available on the next mount, this seems like a 
	 * OK solution from a correctness point of view, even though it is hacky.
	 */</span>
	<span class="enscript-keyword">if</span> (vfs_isforce(vp-&gt;v_mount)) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_DELETED) {
			<span class="enscript-comment">/* If we don't get it, then just go ahead and operate without the lock */</span>
			truncate_lock_held = hfs_try_trunclock(cp, HFS_SHARED_LOCK, HFS_LOCK_SKIP_IF_EXCLUSIVE);
		}
	}
	<span class="enscript-keyword">else</span> {
		hfs_lock_truncate(cp, HFS_SHARED_LOCK, HFS_LOCK_SKIP_IF_EXCLUSIVE);
		truncate_lock_held = TRUE;
	}

	kret = ubc_create_upl(vp, ap-&gt;a_f_offset, ap-&gt;a_size, &amp;upl, &amp;pl, UPL_UBC_PAGEIN | UPL_RET_ONLY_ABSENT); 

	<span class="enscript-keyword">if</span> ((kret != KERN_SUCCESS) || (upl == (upl_t) NULL)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagein_done</span>;
	}
	ubc_upl_range_needed(upl, ap-&gt;a_pl_offset / PAGE_SIZE, 1);

	upl_size = isize = ap-&gt;a_size;

	<span class="enscript-comment">/*
	 * Scan from the back to find the last page in the UPL, so that we 
	 * aren't looking at a UPL that may have already been freed by the
	 * preceding aborts/completions.
	 */</span> 
	<span class="enscript-keyword">for</span> (pg_index = ((isize) / PAGE_SIZE); pg_index &gt; 0;) {
		<span class="enscript-keyword">if</span> (upl_page_present(pl, --pg_index))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (pg_index == 0) {
			<span class="enscript-comment">/*
			 * no absent pages were found in the range specified
			 * just abort the UPL to get rid of it and then we're done
			 */</span>
			ubc_upl_abort_range(upl, 0, isize, UPL_ABORT_FREE_ON_EMPTY);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagein_done</span>;
		}
	}
	<span class="enscript-comment">/* 
	 * initialize the offset variables before we touch the UPL.
	 * f_offset is the position into the file, in bytes
	 * offset is the position into the UPL, in bytes
	 * pg_index is the pg# of the UPL we're operating on
	 * isize is the offset into the UPL of the last page that is present. 
	 */</span>
	isize = ((pg_index + 1) * PAGE_SIZE);	
	pg_index = 0;
	offset = 0;
	f_offset = ap-&gt;a_f_offset;

	<span class="enscript-keyword">while</span> (isize) {
		<span class="enscript-type">int</span>  xsize;
		<span class="enscript-type">int</span>  num_of_pages;

		<span class="enscript-keyword">if</span> ( !upl_page_present(pl, pg_index)) {
			<span class="enscript-comment">/*
			 * we asked for RET_ONLY_ABSENT, so it's possible
			 * to get back empty slots in the UPL.
			 * just skip over them
			 */</span>
			f_offset += PAGE_SIZE;
			offset   += PAGE_SIZE;
			isize    -= PAGE_SIZE;
			pg_index++;

			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* 
		 * We know that we have at least one absent page.
		 * Now checking to see how many in a row we have
		 */</span>
		num_of_pages = 1;
		xsize = isize - PAGE_SIZE;

		<span class="enscript-keyword">while</span> (xsize) {
			<span class="enscript-keyword">if</span> ( !upl_page_present(pl, pg_index + num_of_pages))
				<span class="enscript-keyword">break</span>;
			num_of_pages++;
			xsize -= PAGE_SIZE;
		}
		xsize = num_of_pages * PAGE_SIZE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
			<span class="enscript-comment">/* allow pageins of the resource fork */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> compressed = hfs_file_is_compressed(VTOC(vp), 1); <span class="enscript-comment">/* 1 == don't take the cnode lock */</span>

			<span class="enscript-keyword">if</span> (compressed) {

				<span class="enscript-keyword">if</span> (truncate_lock_held) {
					<span class="enscript-comment">/*
					 * can't hold the truncate lock when calling into the decmpfs layer
					 * since it calls back into this layer... even though we're only
					 * holding the lock in shared mode, and the re-entrant path only
					 * takes the lock shared, we can deadlock if some other thread
					 * tries to grab the lock exclusively in between.
					 */</span>
					hfs_unlock_truncate(cp, HFS_LOCK_SKIP_IF_EXCLUSIVE);
					truncate_lock_held = FALSE;
				}
				ap-&gt;a_pl = upl;
				ap-&gt;a_pl_offset = offset;
				ap-&gt;a_f_offset = f_offset;
				ap-&gt;a_size = xsize;

				error = decmpfs_pagein_compressed(ap, &amp;compressed, VTOCMP(vp));
				<span class="enscript-comment">/*
				 * note that decpfs_pagein_compressed can change the state of
				 * 'compressed'... it will set it to 0 if the file is no longer
				 * compressed once the compression lock is successfully taken
				 * i.e. we would block on that lock while the file is being inflated
				 */</span>
				<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; vnode_isfastdevicecandidate(vp)) {
					(<span class="enscript-type">void</span>) hfs_addhotfile(vp);
				}
				<span class="enscript-keyword">if</span> (compressed) {
					<span class="enscript-keyword">if</span> (error == 0) {
						<span class="enscript-comment">/* successful page-in, update the access time */</span>
						VTOC(vp)-&gt;c_touch_acctime = TRUE;
					
						<span class="enscript-comment">//
</span>						<span class="enscript-comment">// compressed files are not traditional hot file candidates
</span>						<span class="enscript-comment">// but they may be for CF (which ignores the ff_bytesread
</span>						<span class="enscript-comment">// field)
</span>						<span class="enscript-comment">//
</span>						<span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;hfc_stage == HFC_RECORDING) {
							fp-&gt;ff_bytesread = 0;
						}
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EAGAIN) {
						<span class="enscript-comment">/*
						 * EAGAIN indicates someone else already holds the compression lock...
						 * to avoid deadlocking, we'll abort this range of pages with an
						 * indication that the pagein needs to be redriven
						 */</span>
			        		ubc_upl_abort_range(upl, (upl_offset_t) offset, xsize, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_RESTART);
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == ENOSPC) {

						<span class="enscript-keyword">if</span> (upl_size == PAGE_SIZE)
							panic(<span class="enscript-string">&quot;decmpfs_pagein_compressed: couldn't ubc_upl_map a single page\n&quot;</span>);

						ubc_upl_abort_range(upl, (upl_offset_t) offset, isize, UPL_ABORT_FREE_ON_EMPTY);

						ap-&gt;a_size = PAGE_SIZE;
						ap-&gt;a_pl = NULL;
						ap-&gt;a_pl_offset = 0;
						ap-&gt;a_f_offset = page_needed_f_offset;

						<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_pagein</span>;
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagein_next_range</span>;
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* 
					 * Set file_converted only if the file became decompressed while we were
					 * paging in.  If it were still compressed, we would re-start the loop using the goto
					 * in the above block.  This avoid us overloading truncate_lock_held as our retry_pagein
					 * condition below, since we could have avoided taking the truncate lock to prevent
					 * a deadlock in the force unmount case.
					 */</span>
					file_converted = TRUE;
				}
			}
			<span class="enscript-keyword">if</span> (file_converted == TRUE) {
				<span class="enscript-comment">/*
				 * the file was converted back to a regular file after we first saw it as compressed
				 * we need to abort the upl, retake the truncate lock, recreate the UPL and start over
				 * reset a_size so that we consider what remains of the original request
				 * and null out a_upl and a_pl_offset.
				 *
				 * We should only be able to get into this block if the decmpfs_pagein_compressed 
				 * successfully decompressed the range in question for this file.
				 */</span>
				ubc_upl_abort_range(upl, (upl_offset_t) offset, isize, UPL_ABORT_FREE_ON_EMPTY);

				ap-&gt;a_size = isize;
				ap-&gt;a_pl = NULL;
				ap-&gt;a_pl_offset = 0;

				<span class="enscript-comment">/* Reset file_converted back to false so that we don't infinite-loop. */</span>
				file_converted = FALSE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry_pagein</span>;
			}
		}
#<span class="enscript-reference">endif</span>
		error = cluster_pagein(vp, upl, offset, f_offset, xsize, (off_t)fp-&gt;ff_size, ap-&gt;a_flags);

		<span class="enscript-comment">/*
		 * Keep track of blocks read.
		 */</span>
		<span class="enscript-keyword">if</span> ( !vnode_isswap(vp) &amp;&amp; VTOHFS(vp)-&gt;hfc_stage == HFC_RECORDING &amp;&amp; error == 0) {
			<span class="enscript-type">int</span> bytesread;
			<span class="enscript-type">int</span> took_cnode_lock = 0;
		
			<span class="enscript-keyword">if</span> (ap-&gt;a_f_offset == 0 &amp;&amp; fp-&gt;ff_size &lt; PAGE_SIZE)
				bytesread = fp-&gt;ff_size;
			<span class="enscript-keyword">else</span>
				bytesread = xsize;

			<span class="enscript-comment">/* When ff_bytesread exceeds 32-bits, update it behind the cnode lock. */</span>
			<span class="enscript-keyword">if</span> ((fp-&gt;ff_bytesread + bytesread) &gt; 0x00000000ffffffff &amp;&amp; cp-&gt;c_lockowner != current_thread()) {
				hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
				took_cnode_lock = 1;
			}
			<span class="enscript-comment">/*
			 * If this file hasn't been seen since the start of
			 * the current sampling period then start over.
			 */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_atime &lt; VTOHFS(vp)-&gt;hfc_timebase) {
				<span class="enscript-type">struct</span> timeval tv;

				fp-&gt;ff_bytesread = bytesread;
				microtime(&amp;tv);
				cp-&gt;c_atime = tv.tv_sec;
			} <span class="enscript-keyword">else</span> {
				fp-&gt;ff_bytesread += bytesread;
			}
			cp-&gt;c_touch_acctime = TRUE;

			<span class="enscript-keyword">if</span> (vnode_isfastdevicecandidate(vp)) {
				(<span class="enscript-type">void</span>) hfs_addhotfile(vp);
			}
			<span class="enscript-keyword">if</span> (took_cnode_lock)
				hfs_unlock(cp);
		}
<span class="enscript-reference">pagein_next_range</span>:
		f_offset += xsize;
		offset   += xsize;
		isize    -= xsize;
		pg_index += num_of_pages;

		error = 0;
	}

<span class="enscript-reference">pagein_done</span>:
	<span class="enscript-keyword">if</span> (truncate_lock_held == TRUE) {
		<span class="enscript-comment">/* Note 1 is passed to hfs_unlock_truncate in been_recursed argument */</span>
		hfs_unlock_truncate(cp, HFS_LOCK_SKIP_IF_EXCLUSIVE);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* 
 * Pageout for HFS filesystem.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_pageout</span>(<span class="enscript-type">struct</span> vnop_pageout_args *ap)
<span class="enscript-comment">/*
	struct vnop_pageout_args {
	   vnode_t a_vp,
	   upl_t         a_pl,
	   vm_offset_t   a_pl_offset,
	   off_t         a_f_offset,
	   size_t        a_size,
	   int           a_flags
	   vfs_context_t a_context;
	};
*/</span>
{
	vnode_t vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">int</span> retval = 0;
	off_t filesize;
	upl_t 		upl;
	upl_page_info_t* pl;
	vm_offset_t	a_pl_offset;
	<span class="enscript-type">int</span>		a_flags;
	<span class="enscript-type">int</span> is_pageoutv2 = 0;
	kern_return_t kret;

	cp = VTOC(vp);
	fp = VTOF(vp);
	
	a_flags = ap-&gt;a_flags;
	a_pl_offset = ap-&gt;a_pl_offset;

	<span class="enscript-comment">/*
	 * we can tell if we're getting the new or old behavior from the UPL
	 */</span>
	<span class="enscript-keyword">if</span> ((upl = ap-&gt;a_pl) == NULL) {
		<span class="enscript-type">int</span> request_flags; 

		is_pageoutv2 = 1;
		<span class="enscript-comment">/*
		 * we're in control of any UPL we commit
		 * make sure someone hasn't accidentally passed in UPL_NOCOMMIT 
		 */</span>
		a_flags &amp;= ~UPL_NOCOMMIT;
		a_pl_offset = 0;

		<span class="enscript-comment">/*
		 * For V2 semantics, we want to take the cnode truncate lock
		 * shared to guard against the file size changing via zero-filling.
		 * 
		 * However, we have to be careful because we may be invoked 
		 * via the ubc_msync path to write out dirty mmap'd pages
		 * in response to a lock event on a content-protected
		 * filesystem (e.g. to write out class A files).
		 * As a result, we want to take the truncate lock 'SHARED' with 
		 * the mini-recursion locktype so that we don't deadlock/panic 
		 * because we may be already holding the truncate lock exclusive to force any other
		 * IOs to have blocked behind us. 
		 */</span>
		hfs_lock_truncate(cp, HFS_SHARED_LOCK, HFS_LOCK_SKIP_IF_EXCLUSIVE);

		<span class="enscript-keyword">if</span> (a_flags &amp; UPL_MSYNC) {
			request_flags = UPL_UBC_MSYNC | UPL_RET_ONLY_DIRTY;
		}
		<span class="enscript-keyword">else</span> {
			request_flags = UPL_UBC_PAGEOUT | UPL_RET_ONLY_DIRTY;
		}
		
		kret = ubc_create_upl(vp, ap-&gt;a_f_offset, ap-&gt;a_size, &amp;upl, &amp;pl, request_flags); 

		<span class="enscript-keyword">if</span> ((kret != KERN_SUCCESS) || (upl == (upl_t) NULL)) {
			retval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pageout_done</span>;
		}
	}
	<span class="enscript-comment">/*
	 * from this point forward upl points at the UPL we're working with
	 * it was either passed in or we succesfully created it
	 */</span>

	<span class="enscript-comment">/*
	 * Figure out where the file ends, for pageout purposes.  If
	 * ff_new_size &gt; ff_size, then we're in the middle of extending the
	 * file via a write, so it is safe (and necessary) that we be able
	 * to pageout up to that point.
	 */</span>
	filesize = fp-&gt;ff_size;
	<span class="enscript-keyword">if</span> (fp-&gt;ff_new_size &gt; filesize)
		filesize = fp-&gt;ff_new_size;

	<span class="enscript-comment">/* 
	 * Now that HFS is opting into VFC_VFSVNOP_PAGEOUTV2, we may need to operate on our own  
	 * UPL instead of relying on the UPL passed into us.  We go ahead and do that here,
	 * scanning for dirty ranges.  We'll issue our own N cluster_pageout calls, for
	 * N dirty ranges in the UPL.  Note that this is almost a direct copy of the 
	 * logic in vnode_pageout except that we need to do it after grabbing the truncate 
	 * lock in HFS so that we don't lock invert ourselves.  
	 * 
	 * Note that we can still get into this function on behalf of the default pager with
	 * non-V2 behavior (swapfiles).  However in that case, we did not grab locks above 
	 * since fsync and other writing threads will grab the locks, then mark the 
	 * relevant pages as busy.  But the pageout codepath marks the pages as busy, 
	 * and THEN would attempt to grab the truncate lock, which would result in deadlock.  So
	 * we do not try to grab anything for the pre-V2 case, which should only be accessed
	 * by the paging/VM system.
	 */</span>

	<span class="enscript-keyword">if</span> (is_pageoutv2) {
		off_t f_offset;
		<span class="enscript-type">int</span> offset;
		<span class="enscript-type">int</span> isize; 
		<span class="enscript-type">int</span> pg_index;
		<span class="enscript-type">int</span> error;
		<span class="enscript-type">int</span> error_ret = 0;

		isize = ap-&gt;a_size;
		f_offset = ap-&gt;a_f_offset;

		<span class="enscript-comment">/* 
		 * Scan from the back to find the last page in the UPL, so that we 
		 * aren't looking at a UPL that may have already been freed by the
		 * preceding aborts/completions.
		 */</span> 
		<span class="enscript-keyword">for</span> (pg_index = ((isize) / PAGE_SIZE); pg_index &gt; 0;) {
			<span class="enscript-keyword">if</span> (upl_page_present(pl, --pg_index))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (pg_index == 0) {
				ubc_upl_abort_range(upl, 0, isize, UPL_ABORT_FREE_ON_EMPTY);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">pageout_done</span>;
			}
		}

		<span class="enscript-comment">/* 
		 * initialize the offset variables before we touch the UPL.
		 * a_f_offset is the position into the file, in bytes
		 * offset is the position into the UPL, in bytes
		 * pg_index is the pg# of the UPL we're operating on.
		 * isize is the offset into the UPL of the last non-clean page. 
		 */</span>
		isize = ((pg_index + 1) * PAGE_SIZE);	

		offset = 0;
		pg_index = 0;

		<span class="enscript-keyword">while</span> (isize) {
			<span class="enscript-type">int</span>  xsize;
			<span class="enscript-type">int</span>  num_of_pages;

			<span class="enscript-keyword">if</span> ( !upl_page_present(pl, pg_index)) {
				<span class="enscript-comment">/*
				 * we asked for RET_ONLY_DIRTY, so it's possible
				 * to get back empty slots in the UPL.
				 * just skip over them
				 */</span>
				f_offset += PAGE_SIZE;
				offset   += PAGE_SIZE;
				isize    -= PAGE_SIZE;
				pg_index++;

				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ( !upl_dirty_page(pl, pg_index)) {
				panic (<span class="enscript-string">&quot;hfs_vnop_pageout: unforeseen clean page @ index %d for UPL %p\n&quot;</span>, pg_index, upl);
			}

			<span class="enscript-comment">/* 
			 * We know that we have at least one dirty page.
			 * Now checking to see how many in a row we have
			 */</span>
			num_of_pages = 1;
			xsize = isize - PAGE_SIZE;

			<span class="enscript-keyword">while</span> (xsize) {
				<span class="enscript-keyword">if</span> ( !upl_dirty_page(pl, pg_index + num_of_pages))
					<span class="enscript-keyword">break</span>;
				num_of_pages++;
				xsize -= PAGE_SIZE;
			}
			xsize = num_of_pages * PAGE_SIZE;

			<span class="enscript-keyword">if</span> ((error = cluster_pageout(vp, upl, offset, f_offset,
							xsize, filesize, a_flags))) {
				<span class="enscript-keyword">if</span> (error_ret == 0)
					error_ret = error;
			}
			f_offset += xsize;
			offset   += xsize;
			isize    -= xsize;
			pg_index += num_of_pages;
		}
		<span class="enscript-comment">/* capture errnos bubbled out of cluster_pageout if they occurred */</span>
		<span class="enscript-keyword">if</span> (error_ret != 0) {
			retval = error_ret;
		}
	} <span class="enscript-comment">/* end block for v2 pageout behavior */</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * just call cluster_pageout for old pre-v2 behavior
		 */</span>
		retval = cluster_pageout(vp, upl, a_pl_offset, ap-&gt;a_f_offset,
				ap-&gt;a_size, filesize, a_flags);		
	}

	<span class="enscript-comment">/*
	 * If data was written, update the modification time of the file
	 * but only if it's mapped writable; we will have touched the
	 * modifcation time for direct writes.
	 */</span>
	<span class="enscript-keyword">if</span> (retval == 0 &amp;&amp; (ubc_is_mapped_writable(vp)
						|| ISSET(cp-&gt;c_flag, C_MIGHT_BE_DIRTY_FROM_MAPPING))) {
		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

		<span class="enscript-comment">// Check again with lock
</span>		bool mapped_writable = ubc_is_mapped_writable(vp);
		<span class="enscript-keyword">if</span> (mapped_writable
			|| ISSET(cp-&gt;c_flag, C_MIGHT_BE_DIRTY_FROM_MAPPING)) {
			cp-&gt;c_touch_modtime = TRUE;
			cp-&gt;c_touch_chgtime = TRUE;

			<span class="enscript-comment">/*
			 * We only need to increment the generation counter if
			 * it's currently mapped writable because we incremented
			 * the counter in hfs_vnop_mnomap.
			 */</span>
			<span class="enscript-keyword">if</span> (mapped_writable)
				hfs_incr_gencount(VTOC(vp));

			<span class="enscript-comment">/*
			 * If setuid or setgid bits are set and this process is
			 * not the superuser then clear the setuid and setgid bits
			 * as a precaution against tampering.
			 */</span>
			<span class="enscript-keyword">if</span> ((cp-&gt;c_mode &amp; (S_ISUID | S_ISGID)) &amp;&amp;
				(vfs_context_suser(ap-&gt;a_context) != 0)) {
				cp-&gt;c_mode &amp;= ~(S_ISUID | S_ISGID);
			}
		}

		hfs_unlock(cp);
	}

<span class="enscript-reference">pageout_done</span>:
	<span class="enscript-keyword">if</span> (is_pageoutv2) {
		<span class="enscript-comment">/* 
		 * Release the truncate lock.  Note that because 
		 * we may have taken the lock recursively by 
		 * being invoked via ubc_msync due to lockdown,
		 * we should release it recursively, too.
		 */</span>
		hfs_unlock_truncate(cp, HFS_LOCK_SKIP_IF_EXCLUSIVE);
	}
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Intercept B-Tree node writes to unswap them if necessary.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_bwrite</span>(<span class="enscript-type">struct</span> vnop_bwrite_args *ap)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> buf *bp = ap-&gt;a_bp;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> vnode *vp = buf_vnode(bp);
	BlockDescriptor block;

	<span class="enscript-comment">/* Trap B-Tree writes */</span>
	<span class="enscript-keyword">if</span> ((VTOC(vp)-&gt;c_fileid == kHFSExtentsFileID) ||
	    (VTOC(vp)-&gt;c_fileid == kHFSCatalogFileID) ||
	    (VTOC(vp)-&gt;c_fileid == kHFSAttributesFileID) ||
	    (vp == VTOHFS(vp)-&gt;hfc_filevp)) {

		<span class="enscript-comment">/* 
		 * Swap and validate the node if it is in native byte order.
		 * This is always be true on big endian, so we always validate
		 * before writing here.  On little endian, the node typically has
		 * been swapped and validated when it was written to the journal,
		 * so we won't do anything here.
		 */</span>
		<span class="enscript-keyword">if</span> (((u_int16_t *)((<span class="enscript-type">char</span> *)buf_dataptr(bp) + buf_count(bp) - 2))[0] == 0x000e) {
			<span class="enscript-comment">/* Prepare the block pointer */</span>
			block.blockHeader = bp;
			block.buffer = (<span class="enscript-type">char</span> *)buf_dataptr(bp);
			block.blockNum = buf_lblkno(bp);
			<span class="enscript-comment">/* not found in cache ==&gt; came from disk */</span>
			block.blockReadFromDisk = (buf_fromcache(bp) == 0);
			block.blockSize = buf_count(bp);
    
			<span class="enscript-comment">/* Endian un-swap B-Tree node */</span>
			retval = hfs_swap_BTNode (&amp;block, vp, kSwapBTNodeHostToBig, false);
			<span class="enscript-keyword">if</span> (retval)
				panic(<span class="enscript-string">&quot;hfs_vnop_bwrite: about to write corrupt node!\n&quot;</span>);
		}
	}

	<span class="enscript-comment">/* This buffer shouldn't be locked anymore but if it is clear it */</span>
	<span class="enscript-keyword">if</span> ((buf_flags(bp) &amp; B_LOCKED)) {
	        <span class="enscript-comment">// XXXdbg
</span>	        <span class="enscript-keyword">if</span> (VTOHFS(vp)-&gt;jnl) {
		        panic(<span class="enscript-string">&quot;hfs: CLEARING the lock bit on bp %p\n&quot;</span>, bp);
		}
		buf_clearflags(bp, B_LOCKED);
	}
	retval = vn_bwrite (ap);

	<span class="enscript-keyword">return</span> (retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_pin_block_range</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> pin_state, uint32_t start_block, uint32_t nblocks, vfs_context_t ctx)
{
	_dk_cs_pin_t pin;
	<span class="enscript-type">unsigned</span> ioc;
	<span class="enscript-type">int</span> err;

	memset(&amp;pin, 0, <span class="enscript-keyword">sizeof</span>(pin));
	pin.cp_extent.offset = ((uint64_t)start_block) * HFSTOVCB(hfsmp)-&gt;blockSize;
	pin.cp_extent.length = ((uint64_t)nblocks) * HFSTOVCB(hfsmp)-&gt;blockSize;
	<span class="enscript-keyword">switch</span> (pin_state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_PIN_IT</span>:
		ioc = _DKIOCCSPINEXTENT;
		pin.cp_flags = _DKIOCCSPINTOFASTMEDIA;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_PIN_IT</span> | HFS_TEMP_PIN:
		ioc = _DKIOCCSPINEXTENT;
		pin.cp_flags = _DKIOCCSPINTOFASTMEDIA | _DKIOCCSTEMPORARYPIN;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_PIN_IT</span> | HFS_DATALESS_PIN:
		ioc = _DKIOCCSPINEXTENT;
		pin.cp_flags = _DKIOCCSPINTOFASTMEDIA | _DKIOCCSPINFORSWAPFILE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_UNPIN_IT</span>:
		ioc = _DKIOCCSUNPINEXTENT;
		pin.cp_flags = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">HFS_UNPIN_IT</span> | HFS_EVICT_PIN:
		ioc = _DKIOCCSPINEXTENT;
		pin.cp_flags = _DKIOCCSPINTOSLOWMEDIA;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	}
	err = VNOP_IOCTL(hfsmp-&gt;hfs_devvp, ioc, (caddr_t)&amp;pin, 0, ctx);
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">//
</span><span class="enscript-comment">// The cnode lock should already be held on entry to this function
</span><span class="enscript-comment">//
</span><span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_pin_vnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> pin_state, uint32_t *num_blocks_pinned, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> filefork *fp = VTOF(vp);
	<span class="enscript-type">int</span> i, err=0, need_put=0;
	<span class="enscript-type">struct</span> vnode *rsrc_vp=NULL;
	uint32_t npinned = 0;
	off_t               offset;

	<span class="enscript-keyword">if</span> (num_blocks_pinned) {
		*num_blocks_pinned = 0;
	}
	
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
		<span class="enscript-comment">/* Not allowed to pin directories or symlinks */</span>
		printf(<span class="enscript-string">&quot;hfs: can't pin vnode of type %d\n&quot;</span>, vnode_vtype(vp));
		<span class="enscript-keyword">return</span> (EPERM);
	}
	
	<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks) {
		printf(<span class="enscript-string">&quot;hfs: can't pin a vnode w/unalloced blocks (%d)\n&quot;</span>, fp-&gt;ff_unallocblocks);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * It is possible that if the caller unlocked/re-locked the cnode after checking
	 * for C_NOEXISTS|C_DELETED that the file could have been deleted while the
	 * cnode was unlocked.  So check the condition again and return ENOENT so that
	 * the caller knows why we failed to pin the vnode. 
	 */</span>
	<span class="enscript-keyword">if</span> (VTOC(vp)-&gt;c_flag &amp; (C_NOEXISTS|C_DELETED)) {
		<span class="enscript-comment">// makes no sense to pin something that's pending deletion
</span>		<span class="enscript-keyword">return</span> ENOENT;
	}

	<span class="enscript-keyword">if</span> (fp-&gt;ff_blocks == 0 &amp;&amp; (VTOC(vp)-&gt;c_bsdflags &amp; UF_COMPRESSED)) {
		<span class="enscript-keyword">if</span> (!VNODE_IS_RSRC(vp) &amp;&amp; hfs_vgetrsrc(hfsmp, vp, &amp;rsrc_vp) == 0) {
			<span class="enscript-comment">//printf(&quot;hfs: fileid %d resource fork nblocks: %d / size: %lld\n&quot;, VTOC(vp)-&gt;c_fileid,
</span>			<span class="enscript-comment">//       VTOC(rsrc_vp)-&gt;c_rsrcfork-&gt;ff_blocks,VTOC(rsrc_vp)-&gt;c_rsrcfork-&gt;ff_size);
</span>
			fp = VTOC(rsrc_vp)-&gt;c_rsrcfork;
			need_put = 1;
		}
	}
	<span class="enscript-keyword">if</span> (fp-&gt;ff_blocks == 0) {
		<span class="enscript-keyword">if</span> (need_put) {
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// use a distinct error code for a compressed file that has no resource fork;
</span>			<span class="enscript-comment">// we return EALREADY to indicate that the data is already probably hot file
</span>			<span class="enscript-comment">// cached because it's in an EA and the attributes btree is on the ssd
</span>			<span class="enscript-comment">// 
</span>			err = EALREADY;
		} <span class="enscript-keyword">else</span> {
			err = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	offset = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		<span class="enscript-keyword">if</span> (fp-&gt;ff_extents[i].startBlock == 0) {
			<span class="enscript-keyword">break</span>;
		}

		err = hfs_pin_block_range(hfsmp, pin_state, fp-&gt;ff_extents[i].startBlock, fp-&gt;ff_extents[i].blockCount, ctx);
		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			npinned += fp-&gt;ff_extents[i].blockCount;			
		}
	}
	
	<span class="enscript-keyword">if</span> (err || npinned == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (fp-&gt;ff_extents[kHFSPlusExtentDensity-1].startBlock) {
		uint32_t pblocks;
		uint8_t forktype = 0;

		<span class="enscript-keyword">if</span> (fp == VTOC(vp)-&gt;c_rsrcfork) {
			forktype = 0xff;
		}
		<span class="enscript-comment">/*
		 * The file could have overflow extents, better pin them.
		 *
		 * We assume that since we are holding the cnode lock for this cnode,
		 * the files extents cannot be manipulated, but the tree could, so we
		 * need to ensure that it doesn't change behind our back as we iterate it.
		 */</span>
		<span class="enscript-type">int</span> lockflags = hfs_systemfile_lock (hfsmp, SFL_EXTENTS, HFS_SHARED_LOCK);
		err = hfs_pin_overflow_extents(hfsmp, VTOC(vp)-&gt;c_fileid, forktype, &amp;pblocks);
		hfs_systemfile_unlock (hfsmp, lockflags);

		<span class="enscript-keyword">if</span> (err) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		npinned += pblocks;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (num_blocks_pinned) {
		*num_blocks_pinned = npinned;
	}
	
	<span class="enscript-keyword">if</span> (need_put &amp;&amp; rsrc_vp) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// have to unlock the cnode since it's shared between the
</span>		<span class="enscript-comment">// resource fork vnode and the data fork vnode (and the
</span>		<span class="enscript-comment">// vnode_put() may need to re-acquire the cnode lock to
</span>		<span class="enscript-comment">// reclaim the resource fork vnode)
</span>		<span class="enscript-comment">//
</span>		hfs_unlock(VTOC(vp));
		vnode_put(rsrc_vp);
		hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
	}
	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * Relocate a file to a new location on disk
 *  cnode must be locked on entry
 *
 * Relocation occurs by cloning the file's data from its
 * current set of blocks to a new set of blocks. During
 * the relocation all of the blocks (old and new) are
 * owned by the file.
 *
 * -----------------
 * |///////////////|
 * -----------------
 * 0               N (file offset)
 *
 * -----------------     -----------------
 * |///////////////|     |               |     STEP 1 (acquire new blocks)
 * -----------------     -----------------
 * 0               N     N+1             2N
 *
 * -----------------     -----------------
 * |///////////////|     |///////////////|     STEP 2 (clone data)
 * -----------------     -----------------
 * 0               N     N+1             2N
 *
 *                       -----------------
 *                       |///////////////|     STEP 3 (head truncate blocks)
 *                       -----------------
 *                       0               N
 *
 * During steps 2 and 3 page-outs to file offsets less
 * than or equal to N are suspended.
 *
 * During step 3 page-ins to the file get suspended.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_relocate</span>(<span class="enscript-type">struct</span>  vnode *vp, u_int32_t  blockHint, kauth_cred_t cred,
	<span class="enscript-type">struct</span>  proc *p)
{
	<span class="enscript-type">struct</span>  cnode *cp;
	<span class="enscript-type">struct</span>  filefork *fp;
	<span class="enscript-type">struct</span>  hfsmount *hfsmp;
	u_int32_t  headblks;
	u_int32_t  datablks;
	u_int32_t  blksize;
	u_int32_t  growsize;
	u_int32_t  nextallocsave;
	daddr64_t  sector_a,  sector_b;
	<span class="enscript-type">int</span> eflags;
	off_t  newbytes;
	<span class="enscript-type">int</span>  retval;
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">int</span> took_trunc_lock = 0;
	<span class="enscript-type">int</span> started_tr = 0;
	<span class="enscript-type">enum</span> vtype vnodetype;

	vnodetype = vnode_vtype(vp);
	<span class="enscript-keyword">if</span> (vnodetype != VREG) {
		<span class="enscript-comment">/* Not allowed to move symlinks. */</span>
		<span class="enscript-keyword">return</span> (EPERM);
	}
	
	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_FRAGMENTED_FREESPACE) {
		<span class="enscript-keyword">return</span> (ENOSPC);
	}

	cp = VTOC(vp);
	fp = VTOF(vp);
	<span class="enscript-keyword">if</span> (fp-&gt;ff_unallocblocks)
		<span class="enscript-keyword">return</span> (EINVAL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* 
	 * &lt;rdar://problem/9118426&gt;
	 * Disable HFS file relocation on content-protected filesystems
	 */</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected (hfsmp-&gt;hfs_mp)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* If it's an SSD, also disable HFS relocation */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_SSD) {
		<span class="enscript-keyword">return</span> EINVAL;
	}


	blksize = hfsmp-&gt;blockSize;
	<span class="enscript-keyword">if</span> (blockHint == 0)
		blockHint = hfsmp-&gt;nextAllocation;

	<span class="enscript-keyword">if</span> (fp-&gt;ff_size &gt; 0x7fffffff) {
		<span class="enscript-keyword">return</span> (EFBIG);
	}

	<span class="enscript-comment">//
</span>	<span class="enscript-comment">// We do not believe that this call to hfs_fsync() is
</span>	<span class="enscript-comment">// necessary and it causes a journal transaction
</span>	<span class="enscript-comment">// deadlock so we are removing it.
</span>	<span class="enscript-comment">//
</span>	<span class="enscript-comment">//if (vnodetype == VREG &amp;&amp; !vnode_issystem(vp)) {
</span>	<span class="enscript-comment">//	retval = hfs_fsync(vp, MNT_WAIT, 0, p);
</span>	<span class="enscript-comment">//	if (retval)
</span>	<span class="enscript-comment">//		return (retval);
</span>	<span class="enscript-comment">//}
</span>
	<span class="enscript-keyword">if</span> (!vnode_issystem(vp) &amp;&amp; (vnodetype != VLNK)) {
		hfs_unlock(cp);
		hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		<span class="enscript-comment">/* Force lock since callers expects lock to be held. */</span>
		<span class="enscript-keyword">if</span> ((retval = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS))) {
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">return</span> (retval);
		}
		<span class="enscript-comment">/* No need to continue if file was removed. */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NOEXISTS) {
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
		took_trunc_lock = 1;
	}
	headblks = fp-&gt;ff_blocks;
	datablks = howmany(fp-&gt;ff_size, blksize);
	growsize = datablks * blksize;
	eflags = kEFContigMask | kEFAllMask | kEFNoClumpMask;
	<span class="enscript-keyword">if</span> (blockHint &gt;= hfsmp-&gt;hfs_metazone_start &amp;&amp;
	    blockHint &lt;= hfsmp-&gt;hfs_metazone_end)
		eflags |= kEFMetadataMask;

	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		<span class="enscript-keyword">if</span> (took_trunc_lock)
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	    <span class="enscript-keyword">return</span> (EINVAL);
	}
	started_tr = 1;
	<span class="enscript-comment">/*
	 * Protect the extents b-tree and the allocation bitmap
	 * during MapFileBlockC and ExtendFileC operations.
	 */</span>
	lockflags = SFL_BITMAP;
	<span class="enscript-keyword">if</span> (overflow_extents(fp))
		lockflags |= SFL_EXTENTS;
	lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);

	retval = MapFileBlockC(hfsmp, (FCB *)fp, 1, growsize - 1, &amp;sector_a, NULL);
	<span class="enscript-keyword">if</span> (retval) {
		retval = MacToVFSError(retval);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * STEP 1 - acquire new allocation blocks.
	 */</span>
	nextallocsave = hfsmp-&gt;nextAllocation;
	retval = ExtendFileC(hfsmp, (FCB*)fp, growsize, blockHint, eflags, &amp;newbytes);
	<span class="enscript-keyword">if</span> (eflags &amp; kEFMetadataMask) {
		hfs_lock_mount(hfsmp);
		HFS_UPDATE_NEXT_ALLOCATION(hfsmp, nextallocsave);
		MarkVCBDirty(hfsmp);
		hfs_unlock_mount(hfsmp);
	}

	retval = MacToVFSError(retval);
	<span class="enscript-keyword">if</span> (retval == 0) {
		cp-&gt;c_flag |= C_MODIFIED;
		<span class="enscript-keyword">if</span> (newbytes &lt; growsize) {
			retval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fp-&gt;ff_blocks &lt; (headblks + datablks)) {
			printf(<span class="enscript-string">&quot;hfs_relocate: allocation failed id=%u, vol=%s\n&quot;</span>, cp-&gt;c_cnid, hfsmp-&gt;vcbVN);
			retval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;
		}

		retval = MapFileBlockC(hfsmp, (FCB *)fp, 1, growsize, &amp;sector_b, NULL);
		<span class="enscript-keyword">if</span> (retval) {
			retval = MacToVFSError(retval);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((sector_a + 1) == sector_b) {
			retval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((eflags &amp; kEFMetadataMask) &amp;&amp;
		           ((((u_int64_t)sector_b * hfsmp-&gt;hfs_logical_block_size) / blksize) &gt;
		              hfsmp-&gt;hfs_metazone_end)) {
#<span class="enscript-reference">if</span> 0
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> * filestr;
			<span class="enscript-type">char</span> emptystr = <span class="enscript-string">'\0'</span>;

			<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_nameptr != NULL) {
				filestr = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)&amp;cp-&gt;c_desc.cd_nameptr[0];
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_name(vp) != NULL) {
				filestr = vnode_name(vp);
			} <span class="enscript-keyword">else</span> {
				filestr = &amp;emptystr;
			}
#<span class="enscript-reference">endif</span>
			retval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;
		}
	}
	<span class="enscript-comment">/* Done with system locks and journal for now. */</span>
	hfs_systemfile_unlock(hfsmp, lockflags);
	lockflags = 0;
	hfs_end_transaction(hfsmp);
	started_tr = 0;

	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-comment">/*
		 * Check to see if failure is due to excessive fragmentation.
		 */</span>
		<span class="enscript-keyword">if</span> ((retval == ENOSPC) &amp;&amp;
		    (hfs_freeblks(hfsmp, 0) &gt; (datablks * 2))) {
			hfsmp-&gt;hfs_flags |= HFS_FRAGMENTED_FREESPACE;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * STEP 2 - clone file data into the new allocation blocks.
	 */</span>

	<span class="enscript-keyword">if</span> (vnodetype == VLNK)
		retval = EPERM;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_issystem(vp))
		retval = hfs_clonesysfile(vp, headblks, datablks, blksize, cred, p);
	<span class="enscript-keyword">else</span>
		retval = hfs_clonefile(vp, headblks, datablks, blksize);

	<span class="enscript-comment">/* Start transaction for step 3 or for a restore. */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	started_tr = 1;
	<span class="enscript-keyword">if</span> (retval)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;

	<span class="enscript-comment">/*
	 * STEP 3 - switch to cloned data and remove old blocks.
	 */</span>
	lockflags = SFL_BITMAP;
	<span class="enscript-keyword">if</span> (overflow_extents(fp))
		lockflags |= SFL_EXTENTS;
	lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);

	retval = HeadTruncateFile(hfsmp, (FCB*)fp, headblks);

	hfs_systemfile_unlock(hfsmp, lockflags);
	lockflags = 0;
	<span class="enscript-keyword">if</span> (retval)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restore</span>;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (took_trunc_lock)
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);

	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		lockflags = 0;
	}

	<span class="enscript-comment">/* Push cnode's new extent data to disk. */</span>
	<span class="enscript-keyword">if</span> (retval == 0) {
		hfs_update(vp, 0);
	}
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_cnid &lt; kHFSFirstUserCatalogNodeID)
			(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
		<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>) hfs_flushvolumeheader(hfsmp, 0);
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (started_tr)
		hfs_end_transaction(hfsmp);

	<span class="enscript-keyword">return</span> (retval);

<span class="enscript-reference">restore</span>:
	<span class="enscript-keyword">if</span> (fp-&gt;ff_blocks == headblks) {
		<span class="enscript-keyword">if</span> (took_trunc_lock)
			hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-comment">/*
	 * Give back any newly allocated space.
	 */</span>
	<span class="enscript-keyword">if</span> (lockflags == 0) {
		lockflags = SFL_BITMAP;
		<span class="enscript-keyword">if</span> (overflow_extents(fp))
			lockflags |= SFL_EXTENTS;
		lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
	}

	(<span class="enscript-type">void</span>) TruncateFileC(hfsmp, (FCB*)fp, fp-&gt;ff_size, 0, FORK_IS_RSRC(fp), 
						 FTOC(fp)-&gt;c_fileid, false);

	hfs_systemfile_unlock(hfsmp, lockflags);
	lockflags = 0;

	<span class="enscript-keyword">if</span> (took_trunc_lock)
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
}


<span class="enscript-comment">/*
 * Clone a file's data within the file.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_clonefile</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> blkstart, <span class="enscript-type">int</span> blkcnt, <span class="enscript-type">int</span> blksize)
{
	caddr_t  bufp;
	size_t  bufsize;
	size_t  copysize;
        size_t  iosize;
	size_t  offset;
	off_t	writebase;
	uio_t auio;
	<span class="enscript-type">int</span>  error = 0;

	writebase = blkstart * blksize;
	copysize = blkcnt * blksize;
	iosize = bufsize = MIN(copysize, 128 * 1024);
	offset = 0;

	hfs_unlock(VTOC(vp));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> ((error = cp_handle_vnop(vp, CP_WRITE_ACCESS, 0)) != 0) {
		hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);	
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>

	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;bufp, bufsize, VM_KERN_MEMORY_FILE)) {
		hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	auio = uio_create(1, 0, UIO_SYSSPACE, UIO_READ);

	<span class="enscript-keyword">while</span> (offset &lt; copysize) {
		iosize = MIN(copysize - offset, iosize);

		uio_reset(auio, offset, UIO_SYSSPACE, UIO_READ);
		uio_addiov(auio, (uintptr_t)bufp, iosize);

		error = cluster_read(vp, auio, copysize, IO_NOCACHE);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_clonefile: cluster_read failed - %d\n&quot;</span>, error);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) {
			printf(<span class="enscript-string">&quot;hfs_clonefile: cluster_read: uio_resid = %lld\n&quot;</span>, (int64_t)uio_resid(auio));
			error = EIO;		
			<span class="enscript-keyword">break</span>;
		}

		uio_reset(auio, writebase + offset, UIO_SYSSPACE, UIO_WRITE);
		uio_addiov(auio, (uintptr_t)bufp, iosize);

		error = cluster_write(vp, auio, writebase + offset,
		                      writebase + offset + iosize,
		                      uio_offset(auio), 0, IO_NOCACHE | IO_SYNC);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_clonefile: cluster_write failed - %d\n&quot;</span>, error);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) {
			printf(<span class="enscript-string">&quot;hfs_clonefile: cluster_write failed - uio_resid not zero\n&quot;</span>);
			error = EIO;		
			<span class="enscript-keyword">break</span>;
		}	
		offset += iosize;
	}
	uio_free(auio);

	<span class="enscript-keyword">if</span> ((blksize &amp; PAGE_MASK)) {
		<span class="enscript-comment">/*
		 * since the copy may not have started on a PAGE
		 * boundary (or may not have ended on one), we 
		 * may have pages left in the cache since NOCACHE
		 * will let partially written pages linger...
		 * lets just flush the entire range to make sure
		 * we don't have any pages left that are beyond
		 * (or intersect) the real LEOF of this file
		 */</span>
		ubc_msync(vp, writebase, writebase + offset, NULL, UBC_INVALIDATE | UBC_PUSHDIRTY);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * No need to call ubc_msync or hfs_invalbuf
		 * since the file was copied using IO_NOCACHE and
		 * the copy was done starting and ending on a page
		 * boundary in the file.
		 */</span>
	}
	kmem_free(kernel_map, (vm_offset_t)bufp, bufsize);

	hfs_lock(VTOC(vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Clone a system (metadata) file.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_clonesysfile</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> blkstart, <span class="enscript-type">int</span> blkcnt, <span class="enscript-type">int</span> blksize,
                 kauth_cred_t cred, <span class="enscript-type">struct</span> proc *p)
{
	caddr_t  bufp;
	<span class="enscript-type">char</span> * offset;
	size_t  bufsize;
	size_t  iosize;
	<span class="enscript-type">struct</span> buf *bp = NULL;
	daddr64_t  blkno;
 	daddr64_t  blk;
	daddr64_t  start_blk;
	daddr64_t  last_blk;
	<span class="enscript-type">int</span>  breadcnt;
        <span class="enscript-type">int</span>  i;
	<span class="enscript-type">int</span>  error = 0;


	iosize = GetLogicalBlockSize(vp);
	bufsize = MIN(blkcnt * blksize, 1024 * 1024) &amp; ~(iosize - 1);
	breadcnt = bufsize / iosize;

	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;bufp, bufsize, VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}	
	start_blk = ((daddr64_t)blkstart * blksize) / iosize;
	last_blk  = ((daddr64_t)blkcnt * blksize) / iosize;
	blkno = 0;

	<span class="enscript-keyword">while</span> (blkno &lt; last_blk) {
		<span class="enscript-comment">/*
		 * Read up to a megabyte
		 */</span>
		offset = bufp;
		<span class="enscript-keyword">for</span> (i = 0, blk = blkno; (i &lt; breadcnt) &amp;&amp; (blk &lt; last_blk); ++i, ++blk) {
			error = (<span class="enscript-type">int</span>)buf_meta_bread(vp, blk, iosize, cred, &amp;bp);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;hfs_clonesysfile: meta_bread error %d\n&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (buf_count(bp) != iosize) {
				printf(<span class="enscript-string">&quot;hfs_clonesysfile: b_bcount is only %d\n&quot;</span>, buf_count(bp));
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			bcopy((<span class="enscript-type">char</span> *)buf_dataptr(bp), offset, iosize);

			buf_markinvalid(bp);
			buf_brelse(bp);
			bp = NULL;

			offset += iosize;
		}
	
		<span class="enscript-comment">/*
		 * Write up to a megabyte
		 */</span>
		offset = bufp;
		<span class="enscript-keyword">for</span> (i = 0; (i &lt; breadcnt) &amp;&amp; (blkno &lt; last_blk); ++i, ++blkno) {
			bp = buf_getblk(vp, start_blk + blkno, iosize, 0, 0, BLK_META);
			<span class="enscript-keyword">if</span> (bp == NULL) {
				printf(<span class="enscript-string">&quot;hfs_clonesysfile: getblk failed on blk %qd\n&quot;</span>, start_blk + blkno);
				error = EIO;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			bcopy(offset, (<span class="enscript-type">char</span> *)buf_dataptr(bp), iosize);
			error = (<span class="enscript-type">int</span>)buf_bwrite(bp);
			bp = NULL;
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			offset += iosize;
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (bp) {
		buf_brelse(bp);
	}

	kmem_free(kernel_map, (vm_offset_t)bufp, bufsize);

	error = hfs_fsync(vp, MNT_WAIT, 0, p);

	<span class="enscript-keyword">return</span> (error);
}

errno_t <span class="enscript-function-name">hfs_flush_invalid_ranges</span>(vnode_t vp)
{
	cnode_t *cp = VTOC(vp);

	assert(cp-&gt;c_lockowner == current_thread());
	assert(cp-&gt;c_truncatelockowner == current_thread());

	<span class="enscript-keyword">if</span> (!ISSET(cp-&gt;c_flag, C_ZFWANTSYNC) &amp;&amp; !cp-&gt;c_zftimeout)
		<span class="enscript-keyword">return</span> 0;

	filefork_t *fp = VTOF(vp);

	<span class="enscript-comment">/*
	 * We can't hold the cnode lock whilst we call cluster_write so we
	 * need to copy the extents into a local buffer.
	 */</span>
	<span class="enscript-type">int</span> max_exts = 16;
	<span class="enscript-type">struct</span> ext {
		off_t start, end;
	} exts_buf[max_exts];		<span class="enscript-comment">// 256 bytes
</span>	<span class="enscript-type">struct</span> ext *exts = exts_buf;
	<span class="enscript-type">int</span> ext_count = 0;
	errno_t ret;

	<span class="enscript-type">struct</span> rl_entry *r = TAILQ_FIRST(&amp;fp-&gt;ff_invalidranges);

	<span class="enscript-keyword">while</span> (r) {
		<span class="enscript-comment">/* If we have more than can fit in our stack buffer, switch
		   to a heap buffer. */</span>
		<span class="enscript-keyword">if</span> (exts == exts_buf &amp;&amp; ext_count == max_exts) {
			max_exts = 256;
			MALLOC(exts, <span class="enscript-type">struct</span> ext *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ext) * max_exts,
				   M_TEMP, M_WAITOK);
			memcpy(exts, exts_buf, ext_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ext));
		}

		<span class="enscript-type">struct</span> rl_entry *next = TAILQ_NEXT(r, rl_link);

		exts[ext_count++] = (<span class="enscript-type">struct</span> ext){ r-&gt;rl_start, r-&gt;rl_end };

		<span class="enscript-keyword">if</span> (!next || (ext_count == max_exts &amp;&amp; exts != exts_buf)) {
			hfs_unlock(cp);
			<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; ext_count; ++i) {
				ret = cluster_write(vp, NULL, fp-&gt;ff_size, exts[i].end + 1,
									exts[i].start, 0,
									IO_HEADZEROFILL | IO_NOZERODIRTY | IO_NOCACHE);
				<span class="enscript-keyword">if</span> (ret) {
					hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
				}
			}

			<span class="enscript-keyword">if</span> (!next) {
				hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Push any existing clusters which should clean up our invalid
			   ranges as they go through hfs_vnop_blockmap. */</span>
			cluster_push(vp, 0);

			hfs_lock_always(cp, HFS_EXCLUSIVE_LOCK);

			<span class="enscript-comment">/*
			 * Get back to where we were (given we dropped the lock).
			 * This shouldn't be many because we pushed above.
			 */</span>
			TAILQ_FOREACH(r, &amp;fp-&gt;ff_invalidranges, rl_link) {
				<span class="enscript-keyword">if</span> (r-&gt;rl_end &gt; exts[ext_count - 1].end)
					<span class="enscript-keyword">break</span>;
			}

			ext_count = 0;
		} <span class="enscript-keyword">else</span>
			r = next;
	}

	ret = 0;

<span class="enscript-reference">exit</span>:

	<span class="enscript-keyword">if</span> (exts != exts_buf)
		FREE(exts, M_TEMP);

	<span class="enscript-keyword">return</span> ret;
}
</pre>
<hr />
</body></html>