<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_resize.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_resize.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2013-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_journal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_btreeio.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cprotect.h&quot;</span>

<span class="enscript-comment">/* Enable/disable debugging code for live volume resizing */</span>
<span class="enscript-type">int</span> hfs_resize_debug = 0;

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">hfs_file_extent_overlaps</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit,
										<span class="enscript-type">struct</span> HFSPlusCatalogFile *filerec, bool *overlaps);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_reclaimspace</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, u_int32_t reclaimblks, vfs_context_t context);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_extend_journal</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t sector_size, u_int64_t sector_count, vfs_context_t context);

<span class="enscript-comment">/*
 * Extend a file system.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_extendfs</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int64_t newsize, vfs_context_t context)
{
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(context);
	kauth_cred_t cred = vfs_context_ucred(context);
	<span class="enscript-type">struct</span>  vnode *vp;
	<span class="enscript-type">struct</span>  vnode *devvp;
	<span class="enscript-type">struct</span>  buf *bp;
	<span class="enscript-type">struct</span>  filefork *fp = NULL;
	ExtendedVCB  *vcb;
	<span class="enscript-type">struct</span>  cat_fork forkdata;
	u_int64_t  oldsize;
	u_int64_t  newblkcnt;
	u_int64_t  prev_phys_block_count;
	u_int32_t  addblks;
	u_int64_t  sector_count;
	u_int32_t  sector_size;
	u_int32_t  phys_sector_size;
	u_int32_t  overage_blocks;
	daddr64_t  prev_fs_alt_sector;
	daddr_t	   bitmapblks;
	<span class="enscript-type">int</span>  lockflags = 0;
	<span class="enscript-type">int</span>  error;
	int64_t oldBitmapSize;
	
	Boolean  usedExtendFileC = false;
	<span class="enscript-type">int</span> transaction_begun = 0;
	
	devvp = hfsmp-&gt;hfs_devvp;
	vcb = HFSTOVCB(hfsmp);
    
	<span class="enscript-comment">/*
	 * - HFS Plus file systems only.
	 * - Journaling must be enabled.
	 * - No embedded volumes.
	 */</span>
	<span class="enscript-keyword">if</span> ((vcb-&gt;vcbSigWord == kHFSSigWord) ||
        (hfsmp-&gt;jnl == NULL) ||
        (vcb-&gt;hfsPlusIOPosOffset != 0)) {
		<span class="enscript-keyword">return</span> (EPERM);
	}
	<span class="enscript-comment">/*
	 * If extending file system by non-root, then verify
	 * ownership and check permissions.
	 */</span>
	<span class="enscript-keyword">if</span> (suser(cred, NULL)) {
		error = hfs_vget(hfsmp, kHFSRootFolderID, &amp;vp, 0, 0);
        
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		error = hfs_owner_rights(hfsmp, VTOC(vp)-&gt;c_uid, cred, p, 0);
		<span class="enscript-keyword">if</span> (error == 0) {
			error = hfs_write_access(vp, cred, p, false);
		}
		hfs_unlock(VTOC(vp));
		vnode_put(vp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
        
		error = vnode_authorize(devvp, NULL, KAUTH_VNODE_READ_DATA | KAUTH_VNODE_WRITE_DATA, context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;sector_size, 0, context)) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	<span class="enscript-keyword">if</span> (sector_size != hfsmp-&gt;hfs_logical_block_size) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	<span class="enscript-keyword">if</span> (VNOP_IOCTL(devvp, DKIOCGETBLOCKCOUNT, (caddr_t)&amp;sector_count, 0, context)) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	<span class="enscript-comment">/* Check if partition size is correct for new file system size */</span>
	<span class="enscript-keyword">if</span> ((sector_size * sector_count) &lt; newsize) {
		printf(<span class="enscript-string">&quot;hfs_extendfs: not enough space on device (vol=%s)\n&quot;</span>, hfsmp-&gt;vcbVN);
		<span class="enscript-keyword">return</span> (ENOSPC);
	}
	error = VNOP_IOCTL(devvp, DKIOCGETPHYSICALBLOCKSIZE, (caddr_t)&amp;phys_sector_size, 0, context);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> ((error != ENOTSUP) &amp;&amp; (error != ENOTTY)) {
			<span class="enscript-keyword">return</span> (ENXIO);
		}
		<span class="enscript-comment">/* If ioctl is not supported, force physical and logical sector size to be same */</span>
		phys_sector_size = sector_size;
	}
	oldsize = (u_int64_t)hfsmp-&gt;totalBlocks * (u_int64_t)hfsmp-&gt;blockSize;
    
	<span class="enscript-comment">/*
	 * Validate new size.
	 */</span>
	<span class="enscript-keyword">if</span> ((newsize &lt;= oldsize) || (newsize % sector_size) || (newsize % phys_sector_size)) {
		printf(<span class="enscript-string">&quot;hfs_extendfs: invalid size (newsize=%qu, oldsize=%qu)\n&quot;</span>, newsize, oldsize);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	newblkcnt = newsize / vcb-&gt;blockSize;
	<span class="enscript-keyword">if</span> (newblkcnt &gt; (u_int64_t)0xFFFFFFFF) {
		printf (<span class="enscript-string">&quot;hfs_extendfs: current blockSize=%u too small for newsize=%qu\n&quot;</span>, hfsmp-&gt;blockSize, newsize);
		<span class="enscript-keyword">return</span> (EOVERFLOW);
	}
    
	addblks = newblkcnt - vcb-&gt;totalBlocks;
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_extendfs: old: size=%qu, blkcnt=%u\n&quot;</span>, oldsize, hfsmp-&gt;totalBlocks);
		printf (<span class="enscript-string">&quot;hfs_extendfs: new: size=%qu, blkcnt=%u, addblks=%u\n&quot;</span>, newsize, (u_int32_t)newblkcnt, addblks);
	}
	printf(<span class="enscript-string">&quot;hfs_extendfs: will extend \&quot;%s\&quot; by %d blocks\n&quot;</span>, vcb-&gt;vcbVN, addblks);
    
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_RESIZE_IN_PROGRESS) {
		hfs_unlock_mount(hfsmp);
		error = EALREADY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	hfsmp-&gt;hfs_flags |= HFS_RESIZE_IN_PROGRESS;
	hfs_unlock_mount (hfsmp);

	<span class="enscript-comment">/* Start with a clean journal. */</span>
	hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
    
	<span class="enscript-comment">/*
	 * Enclose changes inside a transaction.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	transaction_begun = 1;
    
    
	<span class="enscript-comment">/* Update the hfsmp fields for the physical information about the device */</span>
	prev_phys_block_count = hfsmp-&gt;hfs_logical_block_count;
	prev_fs_alt_sector = hfsmp-&gt;hfs_fs_avh_sector;
    
	hfsmp-&gt;hfs_logical_block_count = sector_count;
	hfsmp-&gt;hfs_logical_bytes = (uint64_t) sector_count * (uint64_t) sector_size;
	
	<span class="enscript-comment">/*
	 * It is possible that the new file system is smaller than the partition size.
	 * Therefore, update offsets for AVH accordingly.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_extendfs: old: partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>, 
				hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
	}
	hfsmp-&gt;hfs_partition_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / sector_size) +
		HFS_ALT_SECTOR(sector_size, hfsmp-&gt;hfs_logical_block_count);
	
	hfsmp-&gt;hfs_fs_avh_sector = (hfsmp-&gt;hfsPlusIOPosOffset / sector_size) + 
		HFS_ALT_SECTOR(sector_size, (newsize/hfsmp-&gt;hfs_logical_block_size));
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_extendfs: new: partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>, 
				hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
	}

	<span class="enscript-comment">/*
	 * Note: we take the attributes lock in case we have an attribute data vnode
	 * which needs to change size.
	 */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_ATTRIBUTE | SFL_EXTENTS | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	vp = vcb-&gt;allocationsRefNum;
	fp = VTOF(vp);
	bcopy(&amp;fp-&gt;ff_data, &amp;forkdata, <span class="enscript-keyword">sizeof</span>(forkdata));
    
	<span class="enscript-comment">/*
	 * Calculate additional space required (if any) by allocation bitmap.
	 */</span>
	oldBitmapSize = fp-&gt;ff_size;
	bitmapblks = roundup((newblkcnt+7) / 8, vcb-&gt;vcbVBMIOSize) / vcb-&gt;blockSize;
	<span class="enscript-keyword">if</span> (bitmapblks &gt; (daddr_t)fp-&gt;ff_blocks)
		bitmapblks -= fp-&gt;ff_blocks;
	<span class="enscript-keyword">else</span>
		bitmapblks = 0;
    
	<span class="enscript-comment">/*
	 * The allocation bitmap can contain unused bits that are beyond end of
	 * current volume's allocation blocks.  Usually they are supposed to be
	 * zero'ed out but there can be cases where they might be marked as used.
	 * After extending the file system, those bits can represent valid
	 * allocation blocks, so we mark all the bits from the end of current
	 * volume to end of allocation bitmap as &quot;free&quot;.
	 *
	 * Figure out the number of overage blocks before proceeding though,
	 * so we don't add more bytes to our I/O than necessary.
	 * First figure out the total number of blocks representable by the
	 * end of the bitmap file vs. the total number of blocks in the new FS.
	 * Then subtract away the number of blocks in the current FS.  This is how much
	 * we can mark as free right now without having to grow the bitmap file.
	 */</span>
	overage_blocks = fp-&gt;ff_blocks * vcb-&gt;blockSize * 8;
	overage_blocks = MIN (overage_blocks, newblkcnt);
   	overage_blocks -= vcb-&gt;totalBlocks;
    
	BlockMarkFreeUnused(vcb, vcb-&gt;totalBlocks, overage_blocks);
    
	<span class="enscript-keyword">if</span> (bitmapblks &gt; 0) {
		daddr64_t blkno;
		daddr_t blkcnt;
		off_t bytesAdded;
        
		<span class="enscript-comment">/*
		 * Get the bitmap's current size (in allocation blocks) so we know
		 * where to start zero filling once the new space is added.  We've
		 * got to do this before the bitmap is grown.
		 */</span>
		blkno  = (daddr64_t)fp-&gt;ff_blocks;
        
		<span class="enscript-comment">/*
		 * Try to grow the allocation file in the normal way, using allocation
		 * blocks already existing in the file system.  This way, we might be
		 * able to grow the bitmap contiguously, or at least in the metadata
		 * zone.
		 */</span>
		error = ExtendFileC(vcb, fp, bitmapblks * vcb-&gt;blockSize, 0,
                            kEFAllMask | kEFNoClumpMask | kEFReserveMask
                            | kEFMetadataMask | kEFContigMask, &amp;bytesAdded);
        
		<span class="enscript-keyword">if</span> (error == 0) {
			usedExtendFileC = true;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If the above allocation failed, fall back to allocating the new
			 * extent of the bitmap from the space we're going to add.  Since those
			 * blocks don't yet belong to the file system, we have to update the
			 * extent list directly, and manually adjust the file size.
			 */</span>
			bytesAdded = 0;
			error = AddFileExtent(vcb, fp, vcb-&gt;totalBlocks, bitmapblks);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;hfs_extendfs: error %d adding extents\n&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			fp-&gt;ff_blocks += bitmapblks;
			VTOC(vp)-&gt;c_blocks = fp-&gt;ff_blocks;
			VTOC(vp)-&gt;c_flag |= C_MODIFIED;
		}
		
		<span class="enscript-comment">/*
		 * Update the allocation file's size to include the newly allocated
		 * blocks.  Note that ExtendFileC doesn't do this, which is why this
		 * statement is outside the above &quot;if&quot; statement.
		 */</span>
		fp-&gt;ff_size += (u_int64_t)bitmapblks * (u_int64_t)vcb-&gt;blockSize;
		
		<span class="enscript-comment">/*
		 * Zero out the new bitmap blocks.
		 */</span>
		{
            
			bp = NULL;
			blkcnt = bitmapblks;
			<span class="enscript-keyword">while</span> (blkcnt &gt; 0) {
				error = (<span class="enscript-type">int</span>)buf_meta_bread(vp, blkno, vcb-&gt;blockSize, NOCRED, &amp;bp);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (bp) {
						buf_brelse(bp);
					}
					<span class="enscript-keyword">break</span>;
				}
				bzero((<span class="enscript-type">char</span> *)buf_dataptr(bp), vcb-&gt;blockSize);
				buf_markaged(bp);
				error = (<span class="enscript-type">int</span>)buf_bwrite(bp);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
				--blkcnt;
				++blkno;
			}
		}
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_extendfs: error %d clearing blocks\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/*
		 * Mark the new bitmap space as allocated.
		 *
		 * Note that ExtendFileC will have marked any blocks it allocated, so
		 * this is only needed if we used AddFileExtent.  Also note that this
		 * has to come *after* the zero filling of new blocks in the case where
		 * we used AddFileExtent (since the part of the bitmap we're touching
		 * is in those newly allocated blocks).
		 */</span>
		<span class="enscript-keyword">if</span> (!usedExtendFileC) {
			error = BlockMarkAllocated(vcb, vcb-&gt;totalBlocks, bitmapblks);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;hfs_extendfs: error %d setting bitmap\n&quot;</span>, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			vcb-&gt;freeBlocks -= bitmapblks;
		}
	}

	<span class="enscript-comment">/*
	 * Mark the new alternate VH as allocated.
	 */</span>
	<span class="enscript-keyword">if</span> (vcb-&gt;blockSize == 512)
		error = BlockMarkAllocated(vcb, vcb-&gt;totalBlocks + addblks - 2, 2);
	<span class="enscript-keyword">else</span>
		error = BlockMarkAllocated(vcb, vcb-&gt;totalBlocks + addblks - 1, 1);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_extendfs: error %d setting bitmap (VH)\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Mark the old alternate VH as free.
	 */</span>
	<span class="enscript-keyword">if</span> (vcb-&gt;blockSize == 512)
		(<span class="enscript-type">void</span>) BlockMarkFree(vcb, vcb-&gt;totalBlocks - 2, 2);
	<span class="enscript-keyword">else</span>
		(<span class="enscript-type">void</span>) BlockMarkFree(vcb, vcb-&gt;totalBlocks - 1, 1);

	<span class="enscript-comment">/*
	 * Adjust file system variables for new space.
	 */</span>
	vcb-&gt;totalBlocks += addblks;
	vcb-&gt;freeBlocks += addblks;
	MarkVCBDirty(vcb);
	error = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_extendfs: couldn't flush volume headers (%d)&quot;</span>, error);
		<span class="enscript-comment">/*
		 * Restore to old state.
		 */</span>
		<span class="enscript-keyword">if</span> (usedExtendFileC) {
			(<span class="enscript-type">void</span>) TruncateFileC(vcb, fp, oldBitmapSize, 0, FORK_IS_RSRC(fp),
								 FTOC(fp)-&gt;c_fileid, false);
		} <span class="enscript-keyword">else</span> {
			fp-&gt;ff_blocks -= bitmapblks;
			fp-&gt;ff_size -= (u_int64_t)bitmapblks * (u_int64_t)vcb-&gt;blockSize;
			<span class="enscript-comment">/*
			 * No need to mark the excess blocks free since those bitmap blocks
			 * are no longer part of the bitmap.  But we do need to undo the
			 * effect of the &quot;vcb-&gt;freeBlocks -= bitmapblks&quot; above.
			 */</span>
			vcb-&gt;freeBlocks += bitmapblks;
		}
		vcb-&gt;totalBlocks -= addblks;
		vcb-&gt;freeBlocks -= addblks;
		hfsmp-&gt;hfs_logical_block_count = prev_phys_block_count;
		hfsmp-&gt;hfs_fs_avh_sector = prev_fs_alt_sector;
		<span class="enscript-comment">/* Do not revert hfs_partition_avh_sector because the 
		 * partition size is larger than file system size
		 */</span>
		MarkVCBDirty(vcb);
		<span class="enscript-keyword">if</span> (vcb-&gt;blockSize == 512) {
			<span class="enscript-keyword">if</span> (BlockMarkAllocated(vcb, vcb-&gt;totalBlocks - 2, 2)) {
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (BlockMarkAllocated(vcb, vcb-&gt;totalBlocks - 1, 1)) {
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
			}
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Invalidate the old alternate volume header.  We are growing the filesystem so
	 * this sector must be returned to the FS as free space.
	 */</span>
	bp = NULL;
	<span class="enscript-keyword">if</span> (prev_fs_alt_sector) {
		<span class="enscript-keyword">if</span> (buf_meta_bread(hfsmp-&gt;hfs_devvp,
                           HFS_PHYSBLK_ROUNDDOWN(prev_fs_alt_sector, hfsmp-&gt;hfs_log_per_phys),
                           hfsmp-&gt;hfs_physical_block_size, NOCRED, &amp;bp) == 0) {
			journal_modify_block_start(hfsmp-&gt;jnl, bp);
            
			bzero((<span class="enscript-type">char</span> *)buf_dataptr(bp) + HFS_ALT_OFFSET(hfsmp-&gt;hfs_physical_block_size), kMDBSize);
            
			journal_modify_block_end(hfsmp-&gt;jnl, bp, NULL, NULL);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp) {
			buf_brelse(bp);
		}
	}
	
	<span class="enscript-comment">/*
	 * Update the metadata zone size based on current volume size
	 */</span>
	hfs_metadatazone_init(hfsmp, false);
    
	<span class="enscript-comment">/*
	 * Adjust the size of hfsmp-&gt;hfs_attrdata_vp
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attrdata_vp) {
		<span class="enscript-type">struct</span> cnode *attr_cp;
		<span class="enscript-type">struct</span> filefork *attr_fp;
		
		<span class="enscript-keyword">if</span> (vnode_get(hfsmp-&gt;hfs_attrdata_vp) == 0) {
			attr_cp = VTOC(hfsmp-&gt;hfs_attrdata_vp);
			attr_fp = VTOF(hfsmp-&gt;hfs_attrdata_vp);
			
			attr_cp-&gt;c_blocks = newblkcnt;
			attr_fp-&gt;ff_blocks = newblkcnt;
			attr_fp-&gt;ff_extents[0].blockCount = newblkcnt;
			attr_fp-&gt;ff_size = (off_t) newblkcnt * hfsmp-&gt;blockSize;
			ubc_setsize(hfsmp-&gt;hfs_attrdata_vp, attr_fp-&gt;ff_size);
			vnode_put(hfsmp-&gt;hfs_attrdata_vp);
		}
	}
    
	<span class="enscript-comment">/*
	 * We only update hfsmp-&gt;allocLimit if totalBlocks actually increased.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		UpdateAllocLimit(hfsmp, hfsmp-&gt;totalBlocks);
	}
    
	<span class="enscript-comment">/* Release all locks and sync up journal content before
	 * checking and extending, if required, the journal
	 */</span>
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		lockflags = 0;
	}
	<span class="enscript-keyword">if</span> (transaction_begun) {
		hfs_end_transaction(hfsmp);
		hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
		transaction_begun = 0;
	}
    
	<span class="enscript-comment">/* Increase the journal size, if required. */</span>
	error = hfs_extend_journal(hfsmp, sector_size, sector_count, context);
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_extendfs: Could not extend journal size\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out_noalloc</span>;
	}
    
	<span class="enscript-comment">/* Log successful extending */</span>
	printf(<span class="enscript-string">&quot;hfs_extendfs: extended \&quot;%s\&quot; to %d blocks (was %d blocks)\n&quot;</span>,
	       hfsmp-&gt;vcbVN, hfsmp-&gt;totalBlocks, (u_int32_t)(oldsize/hfsmp-&gt;blockSize));
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; fp) {
		<span class="enscript-comment">/* Restore allocation fork. */</span>
		bcopy(&amp;forkdata, &amp;fp-&gt;ff_data, <span class="enscript-keyword">sizeof</span>(forkdata));
		VTOC(vp)-&gt;c_blocks = fp-&gt;ff_blocks;
		
	}
    
<span class="enscript-reference">out_noalloc</span>:
	hfs_lock_mount (hfsmp);
	hfsmp-&gt;hfs_flags &amp;= ~HFS_RESIZE_IN_PROGRESS;
	hfs_unlock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
	}
	<span class="enscript-keyword">if</span> (transaction_begun) {
		hfs_end_transaction(hfsmp);
		<span class="enscript-comment">/* Just to be sure, sync all data to the disk */</span>
		<span class="enscript-type">int</span> flush_error = hfs_flush(hfsmp, HFS_FLUSH_FULL);
		<span class="enscript-keyword">if</span> (flush_error &amp;&amp; !error)
			error = flush_error;
	}
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_extentfs: failed error=%d on vol=%s\n&quot;</span>, MacToVFSError(error), hfsmp-&gt;vcbVN);
	}
    
	<span class="enscript-keyword">return</span> MacToVFSError(error);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MIN_SIZE</span>  (32LL * 1024LL * 1024LL)

<span class="enscript-comment">/*
 * Truncate a file system (while still mounted).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_truncatefs</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int64_t newsize, vfs_context_t context)
{
	u_int64_t oldsize;
	u_int32_t newblkcnt;
	u_int32_t reclaimblks = 0;
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">int</span> transaction_begun = 0;
	Boolean updateFreeBlocks = false;
	Boolean disable_sparse = false;
	<span class="enscript-type">int</span> error = 0;
    
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_RESIZE_IN_PROGRESS) {
		hfs_unlock_mount (hfsmp);
		<span class="enscript-keyword">return</span> (EALREADY);
	}
	hfsmp-&gt;hfs_flags |= HFS_RESIZE_IN_PROGRESS;
	hfsmp-&gt;hfs_resize_blocksmoved = 0;
	hfsmp-&gt;hfs_resize_totalblocks = 0;
	hfsmp-&gt;hfs_resize_progress = 0;
	hfs_unlock_mount (hfsmp);
    
	<span class="enscript-comment">/*
	 * - Journaled HFS Plus volumes only.
	 * - No embedded volumes.
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;jnl == NULL) ||
	    (hfsmp-&gt;hfsPlusIOPosOffset != 0)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	oldsize = (u_int64_t)hfsmp-&gt;totalBlocks * (u_int64_t)hfsmp-&gt;blockSize;
	newblkcnt = newsize / hfsmp-&gt;blockSize;
	reclaimblks = hfsmp-&gt;totalBlocks - newblkcnt;
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_truncatefs: old: size=%qu, blkcnt=%u, freeblks=%u\n&quot;</span>, oldsize, hfsmp-&gt;totalBlocks, hfs_freeblks(hfsmp, 1));
		printf (<span class="enscript-string">&quot;hfs_truncatefs: new: size=%qu, blkcnt=%u, reclaimblks=%u\n&quot;</span>, newsize, newblkcnt, reclaimblks);
	}
    
	<span class="enscript-comment">/* Make sure new size is valid. */</span>
	<span class="enscript-keyword">if</span> ((newsize &lt; HFS_MIN_SIZE) ||
	    (newsize &gt;= oldsize) ||
	    (newsize % hfsmp-&gt;hfs_logical_block_size) ||
	    (newsize % hfsmp-&gt;hfs_physical_block_size)) {
		printf (<span class="enscript-string">&quot;hfs_truncatefs: invalid size (newsize=%qu, oldsize=%qu)\n&quot;</span>, newsize, oldsize);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Make sure that the file system has enough free blocks reclaim.
	 *
	 * Before resize, the disk is divided into four zones -
	 * 	A. Allocated_Stationary - These are allocated blocks that exist
	 * 	   before the new end of disk.  These blocks will not be
	 * 	   relocated or modified during resize.
	 * 	B. Free_Stationary - These are free blocks that exist before the
	 * 	   new end of disk.  These blocks can be used for any new
	 * 	   allocations during resize, including allocation for relocating
	 * 	   data from the area of disk being reclaimed.
	 * 	C. Allocated_To-Reclaim - These are allocated blocks that exist
	 *         beyond the new end of disk.  These blocks need to be reclaimed
	 *         during resize by allocating equal number of blocks in Free
	 *         Stationary zone and copying the data.
	 *      D. Free_To-Reclaim - These are free blocks that exist beyond the
	 *         new end of disk.  Nothing special needs to be done to reclaim
	 *         them.
	 *
	 * Total number of blocks on the disk before resize:
	 * ------------------------------------------------
	 * 	Total Blocks = Allocated_Stationary + Free_Stationary +
	 * 	               Allocated_To-Reclaim + Free_To-Reclaim
	 *
	 * Total number of blocks that need to be reclaimed:
	 * ------------------------------------------------
	 *	Blocks to Reclaim = Allocated_To-Reclaim + Free_To-Reclaim
	 *
	 * Note that the check below also makes sure that we have enough space
	 * to relocate data from Allocated_To-Reclaim to Free_Stationary.
	 * Therefore we do not need to check total number of blocks to relocate
	 * later in the code.
	 *
	 * The condition below gets converted to:
	 *
	 * Allocated To-Reclaim + Free To-Reclaim &gt;= Free Stationary + Free To-Reclaim
	 *
	 * which is equivalent to:
	 *
	 *              Allocated To-Reclaim &gt;= Free Stationary
	 */</span>
	<span class="enscript-keyword">if</span> (reclaimblks &gt;= hfs_freeblks(hfsmp, 1)) {
		printf(<span class="enscript-string">&quot;hfs_truncatefs: insufficient space (need %u blocks; have %u free blocks)\n&quot;</span>, reclaimblks, hfs_freeblks(hfsmp, 1));
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Start with a clean journal. */</span>
	hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
	
	<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	transaction_begun = 1;
	
	<span class="enscript-comment">/* Take the bitmap lock to update the alloc limit field */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	
	<span class="enscript-comment">/*
	 * Prevent new allocations from using the part we're trying to truncate.
	 *
	 * NOTE: allocLimit is set to the allocation block number where the new
	 * alternate volume header will be.  That way there will be no files to
	 * interfere with allocating the new alternate volume header, and no files
	 * in the allocation blocks beyond (i.e. the blocks we're trying to
	 * truncate away.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;blockSize == 512) {
		error = UpdateAllocLimit (hfsmp, newblkcnt - 2);
	}
	<span class="enscript-keyword">else</span> {
		error = UpdateAllocLimit (hfsmp, newblkcnt - 1);
	}
    
	<span class="enscript-comment">/* Sparse devices use first fit allocation which is not ideal
	 * for volume resize which requires best fit allocation.  If a
	 * sparse device is being truncated, disable the sparse device
	 * property temporarily for the duration of resize.  Also reset
	 * the free extent cache so that it is rebuilt as sorted by
	 * totalBlocks instead of startBlock.
	 *
	 * Note that this will affect all allocations on the volume and
	 * ideal fix would be just to modify resize-related allocations,
	 * but it will result in complexity like handling of two free
	 * extent caches sorted differently, etc.  So we stick to this
	 * solution for now.
	 */</span>
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_HAS_SPARSE_DEVICE) {
		hfsmp-&gt;hfs_flags &amp;= ~HFS_HAS_SPARSE_DEVICE;
		ResetVCBFreeExtCache(hfsmp);
		disable_sparse = true;
	}
	
	<span class="enscript-comment">/*
	 * Update the volume free block count to reflect the total number
	 * of free blocks that will exist after a successful resize.
	 * Relocation of extents will result in no net change in the total
	 * free space on the disk.  Therefore the code that allocates
	 * space for new extent and deallocates the old extent explicitly
	 * prevents updating the volume free block count.  It will also
	 * prevent false disk full error when the number of blocks in
	 * an extent being relocated is more than the free blocks that
	 * will exist after the volume is resized.
	 */</span>
	hfsmp-&gt;reclaimBlocks = reclaimblks;
	hfsmp-&gt;freeBlocks -= reclaimblks;
	updateFreeBlocks = true;
	hfs_unlock_mount(hfsmp);
    
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
		lockflags = 0;
	}
	
	<span class="enscript-comment">/*
	 * Update the metadata zone size to match the new volume size,
	 * and if it too less, metadata zone might be disabled.
	 */</span>
	hfs_metadatazone_init(hfsmp, false);
    
	<span class="enscript-comment">/*
	 * If some files have blocks at or beyond the location of the
	 * new alternate volume header, recalculate free blocks and
	 * reclaim blocks.  Otherwise just update free blocks count.
	 *
	 * The current allocLimit is set to the location of new alternate
	 * volume header, and reclaimblks are the total number of blocks
	 * that need to be reclaimed.  So the check below is really
	 * ignoring the blocks allocated for old alternate volume header.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_isallocated(hfsmp, hfsmp-&gt;allocLimit, reclaimblks)) {
		<span class="enscript-comment">/*
		 * hfs_reclaimspace will use separate transactions when
		 * relocating files (so we don't overwhelm the journal).
		 */</span>
		hfs_end_transaction(hfsmp);
		transaction_begun = 0;

		<span class="enscript-comment">/* Attempt to reclaim some space. */</span>
		error = hfs_reclaimspace(hfsmp, hfsmp-&gt;allocLimit, reclaimblks, context);
		<span class="enscript-keyword">if</span> (error != 0) {
			printf(<span class="enscript-string">&quot;hfs_truncatefs: couldn't reclaim space on %s (error=%d)\n&quot;</span>, hfsmp-&gt;vcbVN, error);
			error = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		transaction_begun = 1;
		
		<span class="enscript-comment">/* Check if we're clear now. */</span>
		error = hfs_isallocated(hfsmp, hfsmp-&gt;allocLimit, reclaimblks);
		<span class="enscript-keyword">if</span> (error != 0) {
			printf(<span class="enscript-string">&quot;hfs_truncatefs: didn't reclaim enough space on %s (error=%d)\n&quot;</span>, hfsmp-&gt;vcbVN, error);
			error = EAGAIN;  <span class="enscript-comment">/* tell client to try again */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-comment">/*
	 * Note: we take the attributes lock in case we have an attribute data vnode
	 * which needs to change size.
	 */</span>
	lockflags = hfs_systemfile_lock(hfsmp, SFL_ATTRIBUTE | SFL_EXTENTS | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
    
	<span class="enscript-comment">/*
	 * Allocate last 1KB for alternate volume header.
	 */</span>
	error = BlockMarkAllocated(hfsmp, hfsmp-&gt;allocLimit, (hfsmp-&gt;blockSize == 512) ? 2 : 1);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_truncatefs: Error %d allocating new alternate volume header\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/*
	 * Mark the old alternate volume header as free.
	 * We don't bother shrinking allocation bitmap file.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;blockSize == 512)
		(<span class="enscript-type">void</span>) BlockMarkFree(hfsmp, hfsmp-&gt;totalBlocks - 2, 2);
	<span class="enscript-keyword">else</span>
		(<span class="enscript-type">void</span>) BlockMarkFree(hfsmp, hfsmp-&gt;totalBlocks - 1, 1);
	
	<span class="enscript-comment">/* Don't invalidate the old AltVH yet.  It is still valid until the partition size is updated ! */</span>
    
	<span class="enscript-comment">/* Log successful shrinking. */</span>
	printf(<span class="enscript-string">&quot;hfs_truncatefs: shrank \&quot;%s\&quot; to %d blocks (was %d blocks)\n&quot;</span>,
	       hfsmp-&gt;vcbVN, newblkcnt, hfsmp-&gt;totalBlocks);
    
	<span class="enscript-comment">/*
	 * Adjust file system variables and flush them to disk.
	 *
	 * Note that although the logical block size is updated here, it is only
	 * done for the benefit/convenience of the partition management software.  The
	 * logical block count change has not yet actually been propagated to
	 * the disk device yet (and we won't get any notification when it does).
	 */</span>
	hfsmp-&gt;totalBlocks = newblkcnt;
	hfsmp-&gt;hfs_logical_block_count = newsize / hfsmp-&gt;hfs_logical_block_size;
	hfsmp-&gt;hfs_logical_bytes = (uint64_t) hfsmp-&gt;hfs_logical_block_count * (uint64_t) hfsmp-&gt;hfs_logical_block_size;
	hfsmp-&gt;reclaimBlocks = 0;

	<span class="enscript-comment">/*
	 * At this point, a smaller HFS file system exists in a larger volume.
	 * As per volume format, the alternate volume header is located 1024 bytes
	 * before end of the partition.  So, until the partition is also resized,
	 * a valid alternate volume header will need to be updated at 1024 bytes
	 * before end of the volume.  Under normal circumstances, a file system
	 * resize is always followed by a volume resize, so we also need to
	 * write a copy of the new alternate volume header at 1024 bytes before
	 * end of the new file system.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_truncatefs: old: partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>, 
				hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
	}
	hfsmp-&gt;hfs_fs_avh_sector = HFS_ALT_SECTOR(hfsmp-&gt;hfs_logical_block_size, hfsmp-&gt;hfs_logical_block_count);
	<span class="enscript-comment">/* Note hfs_partition_avh_sector stays unchanged! partition size has not yet been modified */</span>
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_truncatefs: new: partition_avh_sector=%qu, fs_avh_sector=%qu\n&quot;</span>, 
				hfsmp-&gt;hfs_partition_avh_sector, hfsmp-&gt;hfs_fs_avh_sector);
	}
	
	MarkVCBDirty(hfsmp);
	error = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
	<span class="enscript-keyword">if</span> (error) {
		panic(<span class="enscript-string">&quot;hfs_truncatefs: unexpected error flushing volume header (%d)\n&quot;</span>, error);
	}
    
	<span class="enscript-comment">/*
	 * Adjust the size of hfsmp-&gt;hfs_attrdata_vp
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attrdata_vp) {
		<span class="enscript-type">struct</span> cnode *cp;
		<span class="enscript-type">struct</span> filefork *fp;
		
		<span class="enscript-keyword">if</span> (vnode_get(hfsmp-&gt;hfs_attrdata_vp) == 0) {
			cp = VTOC(hfsmp-&gt;hfs_attrdata_vp);
			fp = VTOF(hfsmp-&gt;hfs_attrdata_vp);
			
			cp-&gt;c_blocks = newblkcnt;
			fp-&gt;ff_blocks = newblkcnt;
			fp-&gt;ff_extents[0].blockCount = newblkcnt;
			fp-&gt;ff_size = (off_t) newblkcnt * hfsmp-&gt;blockSize;
			ubc_setsize(hfsmp-&gt;hfs_attrdata_vp, fp-&gt;ff_size);
			vnode_put(hfsmp-&gt;hfs_attrdata_vp);
		}
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * Update the allocLimit to acknowledge the last one or two blocks now.
	 * Add it to the tree as well if necessary.
	 */</span>
	UpdateAllocLimit (hfsmp, hfsmp-&gt;totalBlocks);
	
	hfs_lock_mount (hfsmp);
	<span class="enscript-keyword">if</span> (disable_sparse == true) {
		<span class="enscript-comment">/* Now that resize is completed, set the volume to be sparse
		 * device again so that all further allocations will be first
		 * fit instead of best fit.  Reset free extent cache so that
		 * it is rebuilt.
		 */</span>
		hfsmp-&gt;hfs_flags |= HFS_HAS_SPARSE_DEVICE;
		ResetVCBFreeExtCache(hfsmp);
	}
    
	<span class="enscript-keyword">if</span> (error &amp;&amp; (updateFreeBlocks == true)) {
		hfsmp-&gt;freeBlocks += reclaimblks;
	}
	hfsmp-&gt;reclaimBlocks = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;nextAllocation &gt;= hfsmp-&gt;allocLimit) {
		hfsmp-&gt;nextAllocation = hfsmp-&gt;hfs_metazone_end + 1;
	}
	hfsmp-&gt;hfs_flags &amp;= ~HFS_RESIZE_IN_PROGRESS;
	hfs_unlock_mount (hfsmp);
	
	<span class="enscript-comment">/* On error, reset the metadata zone for original volume size */</span>
	<span class="enscript-keyword">if</span> (error &amp;&amp; (updateFreeBlocks == true)) {
		hfs_metadatazone_init(hfsmp, false);
	}
	
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
	}
	<span class="enscript-keyword">if</span> (transaction_begun) {
		hfs_end_transaction(hfsmp);
		<span class="enscript-comment">/* Just to be sure, sync all data to the disk */</span>
		<span class="enscript-type">int</span> flush_error = hfs_flush(hfsmp, HFS_FLUSH_FULL);
		<span class="enscript-keyword">if</span> (flush_error &amp;&amp; !error)
			error = flush_error;
	}
    
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_truncatefs: failed error=%d on vol=%s\n&quot;</span>, MacToVFSError(error), hfsmp-&gt;vcbVN);
	}
    
	<span class="enscript-keyword">return</span> MacToVFSError(error);
}


<span class="enscript-comment">/*
 * Invalidate the physical block numbers associated with buffer cache blocks
 * in the given extent of the given vnode.
 */</span>
<span class="enscript-type">struct</span> hfs_inval_blk_no {
	daddr64_t sectorStart;
	daddr64_t sectorCount;
};
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_invalidate_block_numbers_callback</span>(buf_t bp, <span class="enscript-type">void</span> *args_in)
{
	daddr64_t blkno;
	<span class="enscript-type">struct</span> hfs_inval_blk_no *args;
	
	blkno = buf_blkno(bp);
	args = args_in;
	
	<span class="enscript-keyword">if</span> (blkno &gt;= args-&gt;sectorStart &amp;&amp; blkno &lt; args-&gt;sectorStart+args-&gt;sectorCount)
		buf_setblkno(bp, buf_lblkno(bp));
    
	<span class="enscript-keyword">return</span> BUF_RETURNED;
}
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_invalidate_sectors</span>(<span class="enscript-type">struct</span> vnode *vp, daddr64_t sectorStart, daddr64_t sectorCount)
{
	<span class="enscript-type">struct</span> hfs_inval_blk_no args;
	args.sectorStart = sectorStart;
	args.sectorCount = sectorCount;
	
	buf_iterate(vp, hfs_invalidate_block_numbers_callback, BUF_SCAN_DIRTY|BUF_SCAN_CLEAN, &amp;args);
}


<span class="enscript-comment">/*
 * Copy the contents of an extent to a new location.  Also invalidates the
 * physical block number of any buffer cache block in the copied extent
 * (so that if the block is written, it will go through VNOP_BLOCKMAP to
 * determine the new physical block number).
 *
 * At this point, for regular files, we hold the truncate lock exclusive
 * and the cnode lock exclusive.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_copy_extent</span>(
                <span class="enscript-type">struct</span> hfsmount *hfsmp,
                <span class="enscript-type">struct</span> vnode *vp,		<span class="enscript-comment">/* The file whose extent is being copied. */</span>
                u_int32_t oldStart,		<span class="enscript-comment">/* The start of the source extent. */</span>
                u_int32_t newStart,		<span class="enscript-comment">/* The start of the destination extent. */</span>
                u_int32_t blockCount,	<span class="enscript-comment">/* The number of allocation blocks to copy. */</span>
                __unused vfs_context_t context)
{
	<span class="enscript-type">int</span> err = 0;
	size_t bufferSize;
	<span class="enscript-type">void</span> *buffer = NULL;
	<span class="enscript-type">struct</span> vfsioattr ioattr;
	buf_t bp = NULL;
	off_t resid;
	size_t ioSize;
	u_int32_t ioSizeSectors;	<span class="enscript-comment">/* Device sectors in this I/O */</span>
	daddr64_t srcSector, destSector;
	u_int32_t sectorsPerBlock = hfsmp-&gt;blockSize / hfsmp-&gt;hfs_logical_block_size;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-type">int</span> cpenabled = 0;
#<span class="enscript-reference">endif</span>
    
	<span class="enscript-comment">/*
	 * Sanity check that we have locked the vnode of the file we're copying.
	 *
	 * But since hfs_systemfile_lock() doesn't actually take the lock on
	 * the allocation file if a journal is active, ignore the check if the
	 * file being copied is the allocation file.
	 */</span>
	<span class="enscript-type">struct</span> cnode *cp = VTOC(vp);
	<span class="enscript-keyword">if</span> (cp != hfsmp-&gt;hfs_allocation_cp &amp;&amp; cp-&gt;c_lockowner != current_thread())
		panic(<span class="enscript-string">&quot;hfs_copy_extent: vp=%p (cp=%p) not owned?\n&quot;</span>, vp, cp);
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/*
	 * Prepare the CP blob and get it ready for use, if necessary.
	 *
	 * Note that we specifically *exclude* system vnodes (catalog, bitmap, extents, EAs),
	 * because they are implicitly protected via the media key on iOS.  As such, they
	 * must not be relocated except with the media key.  So it is OK to not pass down
	 * a special cpentry to the IOMedia/LwVM code for handling.
	 */</span>
	<span class="enscript-keyword">if</span> (!vnode_issystem (vp) &amp;&amp; vnode_isreg(vp) &amp;&amp; cp_fs_protected (hfsmp-&gt;hfs_mp)) {
		cpenabled = 1;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Determine the I/O size to use
	 *
	 * NOTE: Many external drives will result in an ioSize of 128KB.
	 * TODO: Should we use a larger buffer, doing several consecutive
	 * reads, then several consecutive writes?
	 */</span>
	vfs_ioattr(hfsmp-&gt;hfs_mp, &amp;ioattr);
	bufferSize = MIN(ioattr.io_maxreadcnt, ioattr.io_maxwritecnt);
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t*) &amp;buffer, bufferSize, VM_KERN_MEMORY_FILE))
		<span class="enscript-keyword">return</span> ENOMEM;
    
	<span class="enscript-comment">/* Get a buffer for doing the I/O */</span>
	bp = buf_alloc(hfsmp-&gt;hfs_devvp);
	buf_setdataptr(bp, (uintptr_t)buffer);
	
	resid = (off_t) blockCount * (off_t) hfsmp-&gt;blockSize;
	srcSector = (daddr64_t) oldStart * hfsmp-&gt;blockSize / hfsmp-&gt;hfs_logical_block_size;
	destSector = (daddr64_t) newStart * hfsmp-&gt;blockSize / hfsmp-&gt;hfs_logical_block_size;
	<span class="enscript-keyword">while</span> (resid &gt; 0) {
		ioSize = MIN(bufferSize, (size_t) resid);
		ioSizeSectors = ioSize / hfsmp-&gt;hfs_logical_block_size;
		
		<span class="enscript-comment">/* Prepare the buffer for reading */</span>
		buf_reset(bp, B_READ);
		buf_setsize(bp, ioSize);
		buf_setcount(bp, ioSize);
		buf_setblkno(bp, srcSector);
		buf_setlblkno(bp, srcSector);
        
		<span class="enscript-comment">/*
		 * Note that because this is an I/O to the device vp
		 * it is correct to have lblkno and blkno both point to the
		 * start sector being read from.  If it were being issued against the
		 * underlying file then that would be different.
		 */</span>
        
		<span class="enscript-comment">/* Attach the new CP blob  to the buffer if needed */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-keyword">if</span> (cpenabled) {
			<span class="enscript-comment">/* attach the RELOCATION_INFLIGHT flag for the underlying call to VNOP_STRATEGY */</span>
			cp-&gt;c_cpentry-&gt;cp_flags |= CP_RELOCATION_INFLIGHT;
			bufattr_setcpx(buf_attr(bp), hfsmp-&gt;hfs_resize_cpx);

			<span class="enscript-comment">/* Initialize the content protection file offset to start at 0 */</span>
			buf_setcpoff (bp, 0);
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* Do the read */</span>
		err = VNOP_STRATEGY(bp);
		<span class="enscript-keyword">if</span> (!err)
			err = buf_biowait(bp);
		<span class="enscript-keyword">if</span> (err) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
			<span class="enscript-comment">/* Turn the flag off in error cases. */</span>
			<span class="enscript-keyword">if</span> (cpenabled) {
				cp-&gt;c_cpentry-&gt;cp_flags &amp;= ~CP_RELOCATION_INFLIGHT;
			}
#<span class="enscript-reference">endif</span>
			printf(<span class="enscript-string">&quot;hfs_copy_extent: Error %d from VNOP_STRATEGY (read)\n&quot;</span>, err);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* Prepare the buffer for writing */</span>
		buf_reset(bp, B_WRITE);
		buf_setsize(bp, ioSize);
		buf_setcount(bp, ioSize);
		buf_setblkno(bp, destSector);
		buf_setlblkno(bp, destSector);
		<span class="enscript-keyword">if</span> (vnode_issystem(vp) &amp;&amp; journal_uses_fua(hfsmp-&gt;jnl))
			buf_markfua(bp);
        
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">/* Attach the CP to the buffer if needed */</span>
		<span class="enscript-keyword">if</span> (cpenabled) {
			bufattr_setcpx(buf_attr(bp), hfsmp-&gt;hfs_resize_cpx);
			<span class="enscript-comment">/*
			 * The last STRATEGY call may have updated the cp file offset behind our
			 * back, so we cannot trust it.  Re-initialize the content protection
			 * file offset back to 0 before initiating the write portion of this I/O.
			 */</span>
			buf_setcpoff (bp, 0);
		}
#<span class="enscript-reference">endif</span>
        
		<span class="enscript-comment">/* Do the write */</span>
		vnode_startwrite(hfsmp-&gt;hfs_devvp);
		err = VNOP_STRATEGY(bp);
		<span class="enscript-keyword">if</span> (!err) {
			err = buf_biowait(bp);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
		<span class="enscript-comment">/* Turn the flag off regardless once the strategy call finishes. */</span>
		<span class="enscript-keyword">if</span> (cpenabled) {
			cp-&gt;c_cpentry-&gt;cp_flags &amp;= ~CP_RELOCATION_INFLIGHT;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (err) {
			printf(<span class="enscript-string">&quot;hfs_copy_extent: Error %d from VNOP_STRATEGY (write)\n&quot;</span>, err);
			<span class="enscript-keyword">break</span>;
		}
		
		resid -= ioSize;
		srcSector += ioSizeSectors;
		destSector += ioSizeSectors;
	}
	<span class="enscript-keyword">if</span> (bp)
		buf_free(bp);
	<span class="enscript-keyword">if</span> (buffer)
		kmem_free(kernel_map, (vm_offset_t)buffer, bufferSize);
    
	<span class="enscript-comment">/* Make sure all writes have been flushed to disk. */</span>
	<span class="enscript-keyword">if</span> (vnode_issystem(vp) &amp;&amp; !journal_uses_fua(hfsmp-&gt;jnl)) {

		err = hfs_flush(hfsmp, HFS_FLUSH_CACHE);
		<span class="enscript-keyword">if</span> (err) {
			printf(<span class="enscript-string">&quot;hfs_copy_extent: hfs_flush failed (%d)\n&quot;</span>, err);
			err = 0;	<span class="enscript-comment">/* Don't fail the copy. */</span>
		}
	}
    
	<span class="enscript-keyword">if</span> (!err)
		hfs_invalidate_sectors(vp, (daddr64_t)oldStart*sectorsPerBlock, (daddr64_t)blockCount*sectorsPerBlock);
    
	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/* Structure to store state of reclaiming extents from a
 * given file.  hfs_reclaim_file()/hfs_reclaim_xattr()
 * initializes the values in this structure which are then
 * used by code that reclaims and splits the extents.
 */</span>
<span class="enscript-type">struct</span> hfs_reclaim_extent_info {
	<span class="enscript-type">struct</span> vnode *vp;
	u_int32_t fileID;
	u_int8_t forkType;
	u_int8_t is_dirlink;                 <span class="enscript-comment">/* Extent belongs to directory hard link */</span>
	u_int8_t is_sysfile;                 <span class="enscript-comment">/* Extent belongs to system file */</span>
	u_int8_t is_xattr;                   <span class="enscript-comment">/* Extent belongs to extent-based xattr */</span>
	u_int8_t extent_index;
	<span class="enscript-type">int</span> lockflags;                       <span class="enscript-comment">/* Locks that reclaim and split code should grab before modifying the extent record */</span>
	u_int32_t blocks_relocated;          <span class="enscript-comment">/* Total blocks relocated for this file till now */</span>
	u_int32_t recStartBlock;             <span class="enscript-comment">/* File allocation block number (FABN) for current extent record */</span>
	u_int32_t cur_blockCount;            <span class="enscript-comment">/* Number of allocation blocks that have been checked for reclaim */</span>
	<span class="enscript-type">struct</span> filefork *catalog_fp;         <span class="enscript-comment">/* If non-NULL, extent is from catalog record */</span>
	<span class="enscript-type">union</span> record {
		HFSPlusExtentRecord overflow;<span class="enscript-comment">/* Extent record from overflow extents btree */</span>
		HFSPlusAttrRecord xattr;     <span class="enscript-comment">/* Attribute record for large EAs */</span>
	} record;
	HFSPlusExtentDescriptor *extents;    <span class="enscript-comment">/* Pointer to current extent record being processed.
                                          * For catalog extent record, points to the correct
                                          * extent information in filefork.  For overflow extent
                                          * record, or xattr record, points to extent record
                                          * in the structure above
                                          */</span>
	<span class="enscript-type">struct</span> cat_desc *dirlink_desc;
	<span class="enscript-type">struct</span> cat_attr *dirlink_attr;
	<span class="enscript-type">struct</span> filefork *dirlink_fork;	      <span class="enscript-comment">/* For directory hard links, fp points actually to this */</span>
	<span class="enscript-type">struct</span> BTreeIterator *iterator;       <span class="enscript-comment">/* Shared read/write iterator, hfs_reclaim_file/xattr()
                                           * use it for reading and hfs_reclaim_extent()/hfs_split_extent()
                                           * use it for writing updated extent record
                                           */</span>
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;     <span class="enscript-comment">/* Shared btdata for reading/writing extent record, same as iterator above */</span>
	u_int16_t recordlen;
	<span class="enscript-type">int</span> overflow_count;                   <span class="enscript-comment">/* For debugging, counter for overflow extent record */</span>
	FCB *fcb;                             <span class="enscript-comment">/* Pointer to the current btree being traversed */</span>
};

<span class="enscript-comment">/*
 * Split the current extent into two extents, with first extent
 * to contain given number of allocation blocks.  Splitting of
 * extent creates one new extent entry which can result in
 * shifting of many entries through all the extent records of a
 * file, and/or creating a new extent record in the overflow
 * extent btree.
 *
 * Example:
 * The diagram below represents two consecutive extent records,
 * for simplicity, lets call them record X and X+1 respectively.
 * Interesting extent entries have been denoted by letters.
 * If the letter is unchanged before and after split, it means
 * that the extent entry was not modified during the split.
 * A '.' means that the entry remains unchanged after the split
 * and is not relevant for our example.  A '0' means that the
 * extent entry is empty.
 *
 * If there isn't sufficient contiguous free space to relocate
 * an extent (extent &quot;C&quot; below), we will have to break the one
 * extent into multiple smaller extents, and relocate each of
 * the smaller extents individually.  The way we do this is by
 * finding the largest contiguous free space that is currently
 * available (N allocation blocks), and then convert extent &quot;C&quot;
 * into two extents, C1 and C2, that occupy exactly the same
 * allocation blocks as extent C.  Extent C1 is the first
 * N allocation blocks of extent C, and extent C2 is the remainder
 * of extent C.  Then we can relocate extent C1 since we know
 * we have enough contiguous free space to relocate it in its
 * entirety.  We then repeat the process starting with extent C2.
 *
 * In record X, only the entries following entry C are shifted, and
 * the original entry C is replaced with two entries C1 and C2 which
 * are actually two extent entries for contiguous allocation blocks.
 *
 * Note that the entry E from record X is shifted into record X+1 as
 * the new first entry.  Since the first entry of record X+1 is updated,
 * the FABN will also get updated with the blockCount of entry E.
 * This also results in shifting of all extent entries in record X+1.
 * Note that the number of empty entries after the split has been
 * changed from 3 to 2.
 *
 * Before:
 *               record X                           record X+1
 *  ---------------------===---------     ---------------------------------
 *  | A | . | . | . | B | C | D | E |     | F | . | . | . | G | 0 | 0 | 0 |
 *  ---------------------===---------     ---------------------------------
 *
 * After:
 *  ---------------------=======-----     ---------------------------------
 *  | A | . | . | . | B | C1| C2| D |     | E | F | . | . | . | G | 0 | 0 |
 *  ---------------------=======-----     ---------------------------------
 *
 *  C1.startBlock = C.startBlock
 *  C1.blockCount = N
 *
 *  C2.startBlock = C.startBlock + N
 *  C2.blockCount = C.blockCount - N
 *
 *                                        FABN = old FABN - E.blockCount
 *
 * Inputs:
 *	extent_info -   This is the structure that contains state about
 *	                the current file, extent, and extent record that
 *	                is being relocated.  This structure is shared
 *	                among code that traverses through all the extents
 *	                of the file, code that relocates extents, and
 *	                code that splits the extent.
 *	newBlockCount - The blockCount of the extent to be split after
 *	                successfully split operation.
 * Output:
 * 	Zero on success, non-zero on failure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_split_extent</span>(<span class="enscript-type">struct</span> hfs_reclaim_extent_info *extent_info, uint32_t newBlockCount)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> index = extent_info-&gt;extent_index;
	<span class="enscript-type">int</span> i;
	HFSPlusExtentDescriptor shift_extent; <span class="enscript-comment">/* Extent entry that should be shifted into next extent record */</span>
	HFSPlusExtentDescriptor last_extent;
	HFSPlusExtentDescriptor *extents; <span class="enscript-comment">/* Pointer to current extent record being manipulated */</span>
	HFSPlusExtentRecord *extents_rec = NULL;
	HFSPlusExtentKey *extents_key = NULL;
	HFSPlusAttrRecord *xattr_rec = NULL;
	HFSPlusAttrKey *xattr_key = NULL;
	<span class="enscript-type">struct</span> BTreeIterator iterator;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	uint16_t reclen;
	uint32_t read_recStartBlock;	<span class="enscript-comment">/* Starting allocation block number to read old extent record */</span>
	uint32_t write_recStartBlock;	<span class="enscript-comment">/* Starting allocation block number to insert newly updated extent record */</span>
	Boolean create_record = false;
	Boolean is_xattr;
	<span class="enscript-type">struct</span> cnode *cp;
    
	is_xattr = extent_info-&gt;is_xattr;
	extents = extent_info-&gt;extents;
	cp = VTOC(extent_info-&gt;vp);
    
	<span class="enscript-keyword">if</span> (newBlockCount == 0) {
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: No splitting required for newBlockCount=0\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_split_extent: Split record:%u recStartBlock=%u %u:(%u,%u) for %u blocks\n&quot;</span>, extent_info-&gt;overflow_count, extent_info-&gt;recStartBlock, index, extents[index].startBlock, extents[index].blockCount, newBlockCount);
	}
    
	<span class="enscript-comment">/* Extents overflow btree can not have more than 8 extents.
	 * No split allowed if the 8th extent is already used.
	 */</span>
	<span class="enscript-keyword">if</span> ((extent_info-&gt;fileID == kHFSExtentsFileID) &amp;&amp; (extents[kHFSPlusExtentDensity - 1].blockCount != 0)) {
		printf (<span class="enscript-string">&quot;hfs_split_extent: Maximum 8 extents allowed for extents overflow btree, cannot split further.\n&quot;</span>);
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* Determine the starting allocation block number for the following
	 * overflow extent record, if any, before the current record
	 * gets modified.
	 */</span>
	read_recStartBlock = extent_info-&gt;recStartBlock;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
		<span class="enscript-keyword">if</span> (extents[i].blockCount == 0) {
			<span class="enscript-keyword">break</span>;
		}
		read_recStartBlock += extents[i].blockCount;
	}
    
	<span class="enscript-comment">/* Shift and split */</span>
	<span class="enscript-keyword">if</span> (index == kHFSPlusExtentDensity-1) {
		<span class="enscript-comment">/* The new extent created after split will go into following overflow extent record */</span>
		shift_extent.startBlock = extents[index].startBlock + newBlockCount;
		shift_extent.blockCount = extents[index].blockCount - newBlockCount;
        
		<span class="enscript-comment">/* Last extent in the record will be split, so nothing to shift */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Splitting of extents can result in at most of one
		 * extent entry to be shifted into following overflow extent
		 * record.  So, store the last extent entry for later.
		 */</span>
		shift_extent = extents[kHFSPlusExtentDensity-1];
		<span class="enscript-keyword">if</span> ((hfs_resize_debug) &amp;&amp; (shift_extent.blockCount != 0)) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: Save 7:(%u,%u) to shift into overflow record\n&quot;</span>, shift_extent.startBlock, shift_extent.blockCount);
		}
        
		<span class="enscript-comment">/* Start shifting extent information from the end of the extent
		 * record to the index where we want to insert the new extent.
		 * Note that kHFSPlusExtentDensity-1 is already saved above, and
		 * does not need to be shifted.  The extent entry that is being
		 * split does not get shifted.
		 */</span>
		<span class="enscript-keyword">for</span> (i = kHFSPlusExtentDensity-2; i &gt; index; i--) {
			<span class="enscript-keyword">if</span> (hfs_resize_debug) {
				<span class="enscript-keyword">if</span> (extents[i].blockCount) {
					printf (<span class="enscript-string">&quot;hfs_split_extent: Shift %u:(%u,%u) to %u:(%u,%u)\n&quot;</span>, i, extents[i].startBlock, extents[i].blockCount, i+1, extents[i].startBlock, extents[i].blockCount);
				}
			}
			extents[i+1] = extents[i];
		}
	}
    
	<span class="enscript-keyword">if</span> (index == kHFSPlusExtentDensity-1) {
		<span class="enscript-comment">/* The second half of the extent being split will be the overflow
		 * entry that will go into following overflow extent record.  The
		 * value has been stored in 'shift_extent' above, so there is
		 * nothing to be done here.
		 */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Update the values in the second half of the extent being split
		 * before updating the first half of the split.  Note that the
		 * extent to split or first half of the split is at index 'index'
		 * and a new extent or second half of the split will be inserted at
		 * 'index+1' or into following overflow extent record.
		 */</span>
		extents[index+1].startBlock = extents[index].startBlock + newBlockCount;
		extents[index+1].blockCount = extents[index].blockCount - newBlockCount;
	}
	<span class="enscript-comment">/* Update the extent being split, only the block count will change */</span>
	extents[index].blockCount = newBlockCount;
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_split_extent: Split %u:(%u,%u) and &quot;</span>, index, extents[index].startBlock, extents[index].blockCount);
		<span class="enscript-keyword">if</span> (index != kHFSPlusExtentDensity-1) {
			printf (<span class="enscript-string">&quot;%u:(%u,%u)\n&quot;</span>, index+1, extents[index+1].startBlock, extents[index+1].blockCount);
		} <span class="enscript-keyword">else</span> {
			printf (<span class="enscript-string">&quot;overflow:(%u,%u)\n&quot;</span>, shift_extent.startBlock, shift_extent.blockCount);
		}
	}
    
	<span class="enscript-comment">/* Write out information about the newly split extent to the disk */</span>
	<span class="enscript-keyword">if</span> (extent_info-&gt;catalog_fp) {
		<span class="enscript-comment">/* (extent_info-&gt;catalog_fp != NULL) means the newly split
		 * extent exists in the catalog record.  This means that
		 * the cnode was updated.  Therefore, to write out the changes,
		 * mark the cnode as modified.   We cannot call hfs_update()
		 * in this function because the caller hfs_reclaim_extent()
		 * is holding the catalog lock currently.
		 */</span>
		cp-&gt;c_flag |= C_MODIFIED;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* The newly split extent is for large EAs or is in overflow
		 * extent record, so update it directly in the btree using the
		 * iterator information from the shared extent_info structure
	 	 */</span>
		error = BTReplaceRecord(extent_info-&gt;fcb, extent_info-&gt;iterator,
                                &amp;(extent_info-&gt;btdata), extent_info-&gt;recordlen);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: fileID=%u BTReplaceRecord returned error=%d\n&quot;</span>, extent_info-&gt;fileID, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-comment">/* No extent entry to be shifted into another extent overflow record */</span>
	<span class="enscript-keyword">if</span> (shift_extent.blockCount == 0) {
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: No extent entry to be shifted into overflow records\n&quot;</span>);
		}
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* The overflow extent entry has to be shifted into an extent
	 * overflow record.  This means that we might have to shift
	 * extent entries from all subsequent overflow records by one.
	 * We start iteration from the first record to the last record,
	 * and shift the extent entry from one record to another.
	 * We might have to create a new extent record for the last
	 * extent entry for the file.
	 */</span>
	
	<span class="enscript-comment">/* Initialize iterator to search the next record */</span>
	bzero(&amp;iterator, <span class="enscript-keyword">sizeof</span>(iterator));
	<span class="enscript-keyword">if</span> (is_xattr) {
		<span class="enscript-comment">/* Copy the key from the iterator that was used to update the modified attribute record. */</span>
		xattr_key = (HFSPlusAttrKey *)&amp;(iterator.key);
		bcopy((HFSPlusAttrKey *)&amp;(extent_info-&gt;iterator-&gt;key), xattr_key, <span class="enscript-keyword">sizeof</span>(HFSPlusAttrKey));
		<span class="enscript-comment">/* Note: xattr_key-&gt;startBlock will be initialized later in the iteration loop */</span>
        
		MALLOC(xattr_rec, HFSPlusAttrRecord *,
               <span class="enscript-keyword">sizeof</span>(HFSPlusAttrRecord), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (xattr_rec == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		btdata.bufferAddress = xattr_rec;
		btdata.itemSize = <span class="enscript-keyword">sizeof</span>(HFSPlusAttrRecord);
		btdata.itemCount = 1;
		extents = xattr_rec-&gt;overflowExtents.extents;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Initialize the extent key for the current file */</span>
		extents_key = (HFSPlusExtentKey *) &amp;(iterator.key);
		extents_key-&gt;keyLength = kHFSPlusExtentKeyMaximumLength;
		extents_key-&gt;forkType = extent_info-&gt;forkType;
		extents_key-&gt;fileID = extent_info-&gt;fileID;
		<span class="enscript-comment">/* Note: extents_key-&gt;startBlock will be initialized later in the iteration loop */</span>
		
		MALLOC(extents_rec, HFSPlusExtentRecord *,
               <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (extents_rec == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		btdata.bufferAddress = extents_rec;
		btdata.itemSize = <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord);
		btdata.itemCount = 1;
		extents = extents_rec[0];
	}
    
	<span class="enscript-comment">/* The overflow extent entry has to be shifted into an extent
	 * overflow record.  This means that we might have to shift
	 * extent entries from all subsequent overflow records by one.
	 * We start iteration from the first record to the last record,
	 * examine one extent record in each iteration and shift one
	 * extent entry from one record to another.  We might have to
	 * create a new extent record for the last extent entry for the
	 * file.
	 *
	 * If shift_extent.blockCount is non-zero, it means that there is
	 * an extent entry that needs to be shifted into the next
	 * overflow extent record.  We keep on going till there are no such
	 * entries left to be shifted.  This will also change the starting
	 * allocation block number of the extent record which is part of
	 * the key for the extent record in each iteration.  Note that
	 * because the extent record key is changing while we are searching,
	 * the record can not be updated directly, instead it has to be
	 * deleted and inserted again.
	 */</span>
	<span class="enscript-keyword">while</span> (shift_extent.blockCount) {
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: Will shift (%u,%u) into overflow record with startBlock=%u\n&quot;</span>, shift_extent.startBlock, shift_extent.blockCount, read_recStartBlock);
		}
        
		<span class="enscript-comment">/* Search if there is any existing overflow extent record
		 * that matches the current file and the logical start block
		 * number.
		 *
		 * For this, the logical start block number in the key is
		 * the value calculated based on the logical start block
		 * number of the current extent record and the total number
		 * of blocks existing in the current extent record.
		 */</span>
		<span class="enscript-keyword">if</span> (is_xattr) {
			xattr_key-&gt;startBlock = read_recStartBlock;
		} <span class="enscript-keyword">else</span> {
			extents_key-&gt;startBlock = read_recStartBlock;
		}
		error = BTSearchRecord(extent_info-&gt;fcb, &amp;iterator, &amp;btdata, &amp;reclen, &amp;iterator);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error != btNotFound) {
				printf (<span class="enscript-string">&quot;hfs_split_extent: fileID=%u startBlock=%u BTSearchRecord error=%d\n&quot;</span>, extent_info-&gt;fileID, read_recStartBlock, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/* No matching record was found, so create a new extent record.
			 * Note:  Since no record was found, we can't rely on the
			 * btree key in the iterator any longer.  This will be initialized
			 * later before we insert the record.
			 */</span>
			create_record = true;
		}
        
		<span class="enscript-comment">/* The extra extent entry from the previous record is being inserted
		 * as the first entry in the current extent record.  This will change
		 * the file allocation block number (FABN) of the current extent
		 * record, which is the startBlock value from the extent record key.
		 * Since one extra entry is being inserted in the record, the new
		 * FABN for the record will less than old FABN by the number of blocks
		 * in the new extent entry being inserted at the start.  We have to
		 * do this before we update read_recStartBlock to point at the
		 * startBlock of the following record.
		 */</span>
		write_recStartBlock = read_recStartBlock - shift_extent.blockCount;
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			<span class="enscript-keyword">if</span> (create_record) {
				printf (<span class="enscript-string">&quot;hfs_split_extent: No records found for startBlock=%u, will create new with startBlock=%u\n&quot;</span>, read_recStartBlock, write_recStartBlock);
			}
		}
        
		<span class="enscript-comment">/* Now update the read_recStartBlock to account for total number
		 * of blocks in this extent record.  It will now point to the
		 * starting allocation block number for the next extent record.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			<span class="enscript-keyword">if</span> (extents[i].blockCount == 0) {
				<span class="enscript-keyword">break</span>;
			}
			read_recStartBlock += extents[i].blockCount;
		}
        
		<span class="enscript-keyword">if</span> (create_record == true) {
			<span class="enscript-comment">/* Initialize new record content with only one extent entry */</span>
			bzero(extents, <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
			<span class="enscript-comment">/* The new record will contain only one extent entry */</span>
			extents[0] = shift_extent;
			<span class="enscript-comment">/* There are no more overflow extents to be shifted */</span>
			shift_extent.startBlock = shift_extent.blockCount = 0;
            
			<span class="enscript-keyword">if</span> (is_xattr) {
				<span class="enscript-comment">/* BTSearchRecord above returned btNotFound,
				 * but since the attribute btree is never empty
				 * if we are trying to insert new overflow
				 * record for the xattrs, the extents_key will
				 * contain correct data.  So we don't need to
				 * re-initialize it again like below.
				 */</span>
                
				<span class="enscript-comment">/* Initialize the new xattr record */</span>
				xattr_rec-&gt;recordType = kHFSPlusAttrExtents;
				xattr_rec-&gt;overflowExtents.reserved = 0;
				reclen = <span class="enscript-keyword">sizeof</span>(HFSPlusAttrExtents);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* BTSearchRecord above returned btNotFound,
				 * which means that extents_key content might
				 * not correspond to the record that we are
				 * trying to create, especially when the extents
				 * overflow btree is empty.  So we reinitialize
				 * the extents_key again always.
				 */</span>
				extents_key-&gt;keyLength = kHFSPlusExtentKeyMaximumLength;
				extents_key-&gt;forkType = extent_info-&gt;forkType;
				extents_key-&gt;fileID = extent_info-&gt;fileID;
                
				<span class="enscript-comment">/* Initialize the new extent record */</span>
				reclen = <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* The overflow extent entry from previous record will be
			 * the first entry in this extent record.  If the last
			 * extent entry in this record is valid, it will be shifted
			 * into the following extent record as its first entry.  So
			 * save the last entry before shifting entries in current
			 * record.
			 */</span>
			last_extent = extents[kHFSPlusExtentDensity-1];
			
			<span class="enscript-comment">/* Shift all entries by one index towards the end */</span>
			<span class="enscript-keyword">for</span> (i = kHFSPlusExtentDensity-2; i &gt;= 0; i--) {
				extents[i+1] = extents[i];
			}
            
			<span class="enscript-comment">/* Overflow extent entry saved from previous record
			 * is now the first entry in the current record.
			 */</span>
			extents[0] = shift_extent;
            
			<span class="enscript-keyword">if</span> (hfs_resize_debug) {
				printf (<span class="enscript-string">&quot;hfs_split_extent: Shift overflow=(%u,%u) to record with updated startBlock=%u\n&quot;</span>, shift_extent.startBlock, shift_extent.blockCount, write_recStartBlock);
			}
            
			<span class="enscript-comment">/* The last entry from current record will be the
			 * overflow entry which will be the first entry for
			 * the following extent record.
			 */</span>
			shift_extent = last_extent;
            
			<span class="enscript-comment">/* Since the key-&gt;startBlock is being changed for this record,
			 * it should be deleted and inserted with the new key.
			 */</span>
			error = BTDeleteRecord(extent_info-&gt;fcb, &amp;iterator);
			<span class="enscript-keyword">if</span> (error) {
				printf (<span class="enscript-string">&quot;hfs_split_extent: fileID=%u startBlock=%u BTDeleteRecord error=%d\n&quot;</span>, extent_info-&gt;fileID, read_recStartBlock, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (hfs_resize_debug) {
				printf (<span class="enscript-string">&quot;hfs_split_extent: Deleted extent record with startBlock=%u\n&quot;</span>, (is_xattr ? xattr_key-&gt;startBlock : extents_key-&gt;startBlock));
			}
		}
        
		<span class="enscript-comment">/* Insert the newly created or modified extent record */</span>
		bzero(&amp;iterator.hint, <span class="enscript-keyword">sizeof</span>(iterator.hint));
		<span class="enscript-keyword">if</span> (is_xattr) {
			xattr_key-&gt;startBlock = write_recStartBlock;
		} <span class="enscript-keyword">else</span> {
			extents_key-&gt;startBlock = write_recStartBlock;
		}
		error = BTInsertRecord(extent_info-&gt;fcb, &amp;iterator, &amp;btdata, reclen);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: fileID=%u, startBlock=%u BTInsertRecord error=%d\n&quot;</span>, extent_info-&gt;fileID, write_recStartBlock, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_split_extent: Inserted extent record with startBlock=%u\n&quot;</span>, write_recStartBlock);
		}
	}
    
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * Extents overflow btree or attributes btree headers might have
	 * been modified during the split/shift operation, so flush the
	 * changes to the disk while we are inside journal transaction.
	 * We should only be able to generate I/O that modifies the B-Tree
	 * header nodes while we're in the middle of a journal transaction.
	 * Otherwise it might result in panic during unmount.
	 */</span>
	BTFlushPath(extent_info-&gt;fcb);
    
	<span class="enscript-keyword">if</span> (extents_rec) {
		FREE (extents_rec, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (xattr_rec) {
		FREE (xattr_rec, M_TEMP);
	}
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Relocate an extent if it lies beyond the expected end of volume.
 *
 * This function is called for every extent of the file being relocated.
 * It allocates space for relocation, copies the data, deallocates
 * the old extent, and update corresponding on-disk extent.  If the function
 * does not find contiguous space to  relocate an extent, it splits the
 * extent in smaller size to be able to relocate it out of the area of
 * disk being reclaimed.  As an optimization, if an extent lies partially
 * in the area of the disk being reclaimed, it is split so that we only
 * have to relocate the area that was overlapping with the area of disk
 * being reclaimed.
 *
 * Note that every extent is relocated in its own transaction so that
 * they do not overwhelm the journal.  This function handles the extent
 * record that exists in the catalog record, extent record from overflow
 * extents btree, and extents for large EAs.
 *
 * Inputs:
 *	extent_info - This is the structure that contains state about
 *	              the current file, extent, and extent record that
 *	              is being relocated.  This structure is shared
 *	              among code that traverses through all the extents
 *	              of the file, code that relocates extents, and
 *	              code that splits the extent.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_extent</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> u_long allocLimit, <span class="enscript-type">struct</span> hfs_reclaim_extent_info *extent_info, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> index;
	<span class="enscript-type">struct</span> cnode *cp;
	u_int32_t oldStartBlock;
	u_int32_t oldBlockCount;
	u_int32_t newStartBlock;
	u_int32_t newBlockCount;
	u_int32_t roundedBlockCount;
	uint16_t node_size;
	uint32_t remainder_blocks;
	u_int32_t alloc_flags;
	<span class="enscript-type">int</span> blocks_allocated = false;
    
	index = extent_info-&gt;extent_index;
	cp = VTOC(extent_info-&gt;vp);
    
	oldStartBlock = extent_info-&gt;extents[index].startBlock;
	oldBlockCount = extent_info-&gt;extents[index].blockCount;
    
	<span class="enscript-keyword">if</span> (0 &amp;&amp; hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Examine record:%u recStartBlock=%u, %u:(%u,%u)\n&quot;</span>, extent_info-&gt;overflow_count, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount);
	}
    
	<span class="enscript-comment">/* If the current extent lies completely within allocLimit,
	 * it does not require any relocation.
	 */</span>
	<span class="enscript-keyword">if</span> ((oldStartBlock + oldBlockCount) &lt;= allocLimit) {
		extent_info-&gt;cur_blockCount += oldBlockCount;
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Every extent should be relocated in its own transaction
	 * to make sure that we don't overflow the journal buffer.
	 */</span>
	error = hfs_start_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}
	extent_info-&gt;lockflags = hfs_systemfile_lock(hfsmp, extent_info-&gt;lockflags, HFS_EXCLUSIVE_LOCK);
    
	<span class="enscript-comment">/* Check if the extent lies partially in the area to reclaim,
	 * i.e. it starts before allocLimit and ends beyond allocLimit.
	 * We have already skipped extents that lie completely within
	 * allocLimit in the check above, so we only check for the
	 * startBlock.  If it lies partially, split it so that we
	 * only relocate part of the extent.
	 */</span>
	<span class="enscript-keyword">if</span> (oldStartBlock &lt; allocLimit) {
		newBlockCount = allocLimit - oldStartBlock;
        
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			<span class="enscript-type">int</span> idx = extent_info-&gt;extent_index;
			printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Split straddling extent %u:(%u,%u) for %u blocks\n&quot;</span>, idx, extent_info-&gt;extents[idx].startBlock, extent_info-&gt;extents[idx].blockCount, newBlockCount);
		}
        
		<span class="enscript-comment">/* If the extent belongs to a btree, check and trim
		 * it to be multiple of the node size.
		 */</span>
		<span class="enscript-keyword">if</span> (extent_info-&gt;is_sysfile) {
			node_size = get_btree_nodesize(extent_info-&gt;vp);
			<span class="enscript-comment">/* If the btree node size is less than the block size,
			 * splitting this extent will not split a node across
			 * different extents.  So we only check and trim if
			 * node size is more than the allocation block size.
			 */</span>
			<span class="enscript-keyword">if</span> (node_size &gt; hfsmp-&gt;blockSize) {
				remainder_blocks = newBlockCount % (node_size / hfsmp-&gt;blockSize);
				<span class="enscript-keyword">if</span> (remainder_blocks) {
					newBlockCount -= remainder_blocks;
					<span class="enscript-keyword">if</span> (hfs_resize_debug) {
						printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Round-down newBlockCount to be multiple of nodeSize, node_allocblks=%u, old=%u, new=%u\n&quot;</span>, node_size/hfsmp-&gt;blockSize, newBlockCount + remainder_blocks, newBlockCount);
					}
				}
			}
			<span class="enscript-comment">/* The newBlockCount is zero because of rounding-down so that
			 * btree nodes are not split across extents.  Therefore this
			 * straddling extent across resize-boundary does not require
			 * splitting.  Skip over to relocating of complete extent.
			 */</span>
			<span class="enscript-keyword">if</span> (newBlockCount == 0) {
				<span class="enscript-keyword">if</span> (hfs_resize_debug) {
					printf (<span class="enscript-string">&quot;hfs_reclaim_extent: After round-down newBlockCount=0, skip split, relocate full extent\n&quot;</span>);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">relocate_full_extent</span>;
			}
		}
        
		<span class="enscript-comment">/* Split the extents into two parts --- the first extent lies
		 * completely within allocLimit and therefore does not require
		 * relocation.  The second extent will require relocation which
		 * will be handled when the caller calls this function again
		 * for the next extent.
		 */</span>
		error = hfs_split_extent(extent_info, newBlockCount);
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">/* Split success, no relocation required */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* Split failed, so try to relocate entire extent */</span>
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			<span class="enscript-type">int</span> idx = extent_info-&gt;extent_index;
			printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Split straddling extent %u:(%u,%u) for %u blocks failed, relocate full extent\n&quot;</span>, idx, extent_info-&gt;extents[idx].startBlock, extent_info-&gt;extents[idx].blockCount, newBlockCount);
		}
	}
    
<span class="enscript-reference">relocate_full_extent</span>:
	<span class="enscript-comment">/* At this point, the current extent requires relocation.
	 * We will try to allocate space equal to the size of the extent
	 * being relocated first to try to relocate it without splitting.
	 * If the allocation fails, we will try to allocate contiguous
	 * blocks out of metadata zone.  If that allocation also fails,
	 * then we will take a whatever contiguous block run is returned
	 * by the allocation, split the extent into two parts, and then
	 * relocate the first splitted extent.
	 */</span>
	alloc_flags = HFS_ALLOC_FORCECONTIG | HFS_ALLOC_SKIPFREEBLKS;
	<span class="enscript-keyword">if</span> (extent_info-&gt;is_sysfile) {
		alloc_flags |= HFS_ALLOC_METAZONE;
	}
    
	error = BlockAllocate(hfsmp, 1, oldBlockCount, oldBlockCount, alloc_flags,
                          &amp;newStartBlock, &amp;newBlockCount);
	<span class="enscript-keyword">if</span> ((extent_info-&gt;is_sysfile == false) &amp;&amp;
	    ((error == dskFulErr) || (error == ENOSPC))) {
		<span class="enscript-comment">/* For non-system files, try reallocating space in metadata zone */</span>
		alloc_flags |= HFS_ALLOC_METAZONE;
		error = BlockAllocate(hfsmp, 1, oldBlockCount, oldBlockCount,
                              alloc_flags, &amp;newStartBlock, &amp;newBlockCount);
	}
	<span class="enscript-keyword">if</span> ((error == dskFulErr) || (error == ENOSPC)) {
		<span class="enscript-comment">/*
		 * We did not find desired contiguous space for this
		 * extent, when we asked for it, including the metazone allocations.
		 * At this point we are not worrying about getting contiguity anymore.
		 *
		 * HOWEVER, if we now allow blocks to be used which were recently
		 * de-allocated, we may find a contiguous range (though this seems
		 * unlikely). As a result, assume that we will have to split the
		 * current extent into two pieces, but if we are able to satisfy
		 * the request with a single extent, detect that as well.
		 */</span>
		alloc_flags &amp;= ~HFS_ALLOC_FORCECONTIG;
		alloc_flags |= HFS_ALLOC_FLUSHTXN;
        
		error = BlockAllocate(hfsmp, 1, oldBlockCount, oldBlockCount,
                              alloc_flags, &amp;newStartBlock, &amp;newBlockCount);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u start=%u, %u:(%u,%u) BlockAllocate error=%d\n&quot;</span>, extent_info-&gt;fileID, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
        
		<span class="enscript-comment">/*
		 * Allowing recently deleted extents may now allow us to find
		 * a single contiguous extent in the amount &amp; size desired.  If so,
		 * do NOT split this extent into two pieces.  This is technically a
		 * check for &quot;&lt; oldBlockCount&quot;, but we use != to highlight the point
		 * that the special case is when they're equal. The allocator should
		 * never vend back more blocks than were requested.
		 */</span>
		<span class="enscript-keyword">if</span> (newBlockCount != oldBlockCount) {
			blocks_allocated = true;
            
			<span class="enscript-comment">/* The number of blocks allocated is less than the requested
			 * number of blocks.  For btree extents, check and trim the
			 * extent to be multiple of the node size.
			 */</span>
			<span class="enscript-keyword">if</span> (extent_info-&gt;is_sysfile) {
				node_size = get_btree_nodesize(extent_info-&gt;vp);
				<span class="enscript-keyword">if</span> (node_size &gt; hfsmp-&gt;blockSize) {
					remainder_blocks = newBlockCount % (node_size / hfsmp-&gt;blockSize);
					<span class="enscript-keyword">if</span> (remainder_blocks) {
						roundedBlockCount = newBlockCount - remainder_blocks;
						<span class="enscript-comment">/* Free tail-end blocks of the newly allocated extent */</span>
						BlockDeallocate(hfsmp, newStartBlock + roundedBlockCount,
                                        newBlockCount - roundedBlockCount,
                                        HFS_ALLOC_SKIPFREEBLKS);
						newBlockCount = roundedBlockCount;
						<span class="enscript-keyword">if</span> (hfs_resize_debug) {
							printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Fixing extent block count, node_blks=%u, old=%u, new=%u\n&quot;</span>, node_size/hfsmp-&gt;blockSize, newBlockCount + remainder_blocks, newBlockCount);
						}
						<span class="enscript-keyword">if</span> (newBlockCount == 0) {
							printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Not enough contiguous blocks available to relocate fileID=%d\n&quot;</span>, extent_info-&gt;fileID);
							error = ENOSPC;
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
						}
					}
				}
			}
            
			<span class="enscript-comment">/* The number of blocks allocated is less than the number of
			 * blocks requested, so split this extent --- the first extent
			 * will be relocated as part of this function call and the caller
			 * will handle relocating the second extent by calling this
			 * function again for the second extent.
			 */</span>
			error = hfs_split_extent(extent_info, newBlockCount);
			<span class="enscript-keyword">if</span> (error) {
				printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u start=%u, %u:(%u,%u) split error=%d\n&quot;</span>, extent_info-&gt;fileID, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			oldBlockCount = newBlockCount;
		} <span class="enscript-comment">/* end oldBlockCount != newBlockCount */</span>
	} <span class="enscript-comment">/* end allocation request for any available free space */</span>
    
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u start=%u, %u:(%u,%u) contig BlockAllocate error=%d\n&quot;</span>, extent_info-&gt;fileID, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	blocks_allocated = true;
    
	<span class="enscript-comment">/* Copy data from old location to new location */</span>
	error = hfs_copy_extent(hfsmp, extent_info-&gt;vp, oldStartBlock,
                            newStartBlock, newBlockCount, context);
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u start=%u, %u:(%u,%u)=&gt;(%u,%u) hfs_copy_extent error=%d\n&quot;</span>, extent_info-&gt;fileID, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount, newStartBlock, newBlockCount, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* Update the extent record with the new start block information */</span>
	extent_info-&gt;extents[index].startBlock = newStartBlock;
    
	<span class="enscript-comment">/* Sync the content back to the disk */</span>
	<span class="enscript-keyword">if</span> (extent_info-&gt;catalog_fp) {
		<span class="enscript-comment">/* Update the extents in catalog record */</span>
		<span class="enscript-keyword">if</span> (extent_info-&gt;is_dirlink) {
			error = cat_update_dirlink(hfsmp, extent_info-&gt;forkType,
                                       extent_info-&gt;dirlink_desc, extent_info-&gt;dirlink_attr,
                                       &amp;(extent_info-&gt;dirlink_fork-&gt;ff_data));
		} <span class="enscript-keyword">else</span> {
			cp-&gt;c_flag |= C_MODIFIED;
			<span class="enscript-comment">/* If this is a system file, sync volume headers on disk */</span>
			<span class="enscript-keyword">if</span> (extent_info-&gt;is_sysfile) {
				error = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Replace record for extents overflow or extents-based xattrs */</span>
		error = BTReplaceRecord(extent_info-&gt;fcb, extent_info-&gt;iterator,
                                &amp;(extent_info-&gt;btdata), extent_info-&gt;recordlen);
	}
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u, update record error=%u\n&quot;</span>, extent_info-&gt;fileID, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* Deallocate the old extent */</span>
	error = BlockDeallocate(hfsmp, oldStartBlock, oldBlockCount, HFS_ALLOC_SKIPFREEBLKS);
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: fileID=%u start=%u, %u:(%u,%u) BlockDeallocate error=%d\n&quot;</span>, extent_info-&gt;fileID, extent_info-&gt;recStartBlock, index, oldStartBlock, oldBlockCount, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	extent_info-&gt;blocks_relocated += newBlockCount;
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_extent: Relocated record:%u %u:(%u,%u) to (%u,%u)\n&quot;</span>, extent_info-&gt;overflow_count, index, oldStartBlock, oldBlockCount, newStartBlock, newBlockCount);
	}
    
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">if</span> (blocks_allocated == true) {
			BlockDeallocate(hfsmp, newStartBlock, newBlockCount, HFS_ALLOC_SKIPFREEBLKS);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* On success, increment the total allocation blocks processed */</span>
		extent_info-&gt;cur_blockCount += newBlockCount;
	}
    
	hfs_systemfile_unlock(hfsmp, extent_info-&gt;lockflags);
    
	<span class="enscript-comment">/* For a non-system file, if an extent entry from catalog record
	 * was modified, sync the in-memory changes to the catalog record
	 * on disk before ending the transaction.
	 */</span>
    <span class="enscript-keyword">if</span> ((extent_info-&gt;catalog_fp) &amp;&amp;
        (extent_info-&gt;is_sysfile == false)) {
		hfs_update(extent_info-&gt;vp, 0);
	}
    
	hfs_end_transaction(hfsmp);
    
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* Report intermediate progress during volume resize */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_truncatefs_progress</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	u_int32_t cur_progress = 0;
    
	hfs_resize_progress(hfsmp, &amp;cur_progress);
	<span class="enscript-keyword">if</span> (cur_progress &gt; (hfsmp-&gt;hfs_resize_progress + 9)) {
		printf(<span class="enscript-string">&quot;hfs_truncatefs: %d%% done...\n&quot;</span>, cur_progress);
		hfsmp-&gt;hfs_resize_progress = cur_progress;
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Reclaim space at the end of a volume for given file and forktype.
 *
 * This routine attempts to move any extent which contains allocation blocks
 * at or after &quot;allocLimit.&quot;  A separate transaction is used for every extent
 * that needs to be moved.  If there is not contiguous space available for
 * moving an extent, it can be split into smaller extents.  The contents of
 * any moved extents are read and written via the volume's device vnode --
 * NOT via &quot;vp.&quot;  During the move, moved blocks which are part of a transaction
 * have their physical block numbers invalidated so they will eventually be
 * written to their new locations.
 *
 * This function is also called for directory hard links.  Directory hard links
 * are regular files with no data fork and resource fork that contains alias
 * information for backward compatibility with pre-Leopard systems.  However
 * non-Mac OS X implementation can add/modify data fork or resource fork
 * information to directory hard links, so we check, and if required, relocate
 * both data fork and resource fork.
 *
 * Inputs:
 *    hfsmp       The volume being resized.
 *    vp          The vnode for the system file.
 *    fileID	  ID of the catalog record that needs to be relocated
 *    forktype	  The type of fork that needs relocated,
 *    			kHFSResourceForkType for resource fork,
 *    			kHFSDataForkType for data fork
 *    allocLimit  Allocation limit for the new volume size,
 *    		  do not use this block or beyond.  All extents
 *    		  that use this block or any blocks beyond this limit
 *    		  will be relocated.
 *
 * Side Effects:
 * hfsmp-&gt;hfs_resize_blocksmoved is incremented by the number of allocation
 * blocks that were relocated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, u_int32_t fileID,
                 u_int8_t forktype, u_long allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> hfs_reclaim_extent_info *extent_info;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">int</span> took_truncate_lock = false;
	<span class="enscript-type">int</span> release_desc = false;
	HFSPlusExtentKey *key;
    
	<span class="enscript-comment">/* If there is no vnode for this file, then there's nothing to do. */</span>
	<span class="enscript-keyword">if</span> (vp == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}
    
	cp = VTOC(vp);
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *filename = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) cp-&gt;c_desc.cd_nameptr;
		<span class="enscript-type">int</span> namelen = cp-&gt;c_desc.cd_namelen;
        
		<span class="enscript-keyword">if</span> (filename == NULL) {
			filename = <span class="enscript-string">&quot;&quot;</span>;
			namelen = 0;
		}
		printf(<span class="enscript-string">&quot;hfs_reclaim_file: reclaiming '%.*s'\n&quot;</span>, namelen, filename);
	}
    
	MALLOC(extent_info, <span class="enscript-type">struct</span> hfs_reclaim_extent_info *,
	       <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_reclaim_extent_info), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (extent_info == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero(extent_info, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_reclaim_extent_info));
	extent_info-&gt;vp = vp;
	extent_info-&gt;fileID = fileID;
	extent_info-&gt;forkType = forktype;
	extent_info-&gt;is_sysfile = vnode_issystem(vp);
	<span class="enscript-keyword">if</span> (vnode_isdir(vp) &amp;&amp; (cp-&gt;c_flag &amp; C_HARDLINK)) {
		extent_info-&gt;is_dirlink = true;
	}
	<span class="enscript-comment">/* We always need allocation bitmap and extent btree lock */</span>
	lockflags = SFL_BITMAP | SFL_EXTENTS;
	<span class="enscript-keyword">if</span> ((fileID == kHFSCatalogFileID) || (extent_info-&gt;is_dirlink == true)) {
		lockflags |= SFL_CATALOG;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fileID == kHFSAttributesFileID) {
		lockflags |= SFL_ATTRIBUTE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fileID == kHFSStartupFileID) {
		lockflags |= SFL_STARTUP;
	}
	extent_info-&gt;lockflags = lockflags;
	extent_info-&gt;fcb = VTOF(hfsmp-&gt;hfs_extents_vp);
    
	<span class="enscript-comment">/* Flush data associated with current file on disk.
	 *
	 * If the current vnode is directory hard link, no flushing of
	 * journal or vnode is required.  The current kernel does not
	 * modify data/resource fork of directory hard links, so nothing
	 * will be in the cache.  If a directory hard link is newly created,
	 * the resource fork data is written directly using devvp and
	 * the code that actually relocates data (hfs_copy_extent()) also
	 * uses devvp for its I/O --- so they will see a consistent copy.
	 */</span>
	<span class="enscript-keyword">if</span> (extent_info-&gt;is_sysfile) {
		<span class="enscript-comment">/* If the current vnode is system vnode, flush journal
		 * to make sure that all data is written to the disk.
		 */</span>
		error = hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_file: journal_flush returned %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (extent_info-&gt;is_dirlink == false) {
		<span class="enscript-comment">/* Flush all blocks associated with this regular file vnode.
		 * Normally there should not be buffer cache blocks for regular
		 * files, but for objects like symlinks, we can have buffer cache
		 * blocks associated with the vnode.  Therefore we call
		 * buf_flushdirtyblks() also.
		 */</span>
		buf_flushdirtyblks(vp, 0, BUF_SKIP_LOCKED, <span class="enscript-string">&quot;hfs_reclaim_file&quot;</span>);
        
		hfs_unlock(cp);
		hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		took_truncate_lock = true;
		(<span class="enscript-type">void</span>) cluster_push(vp, 0);
		error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
        
		<span class="enscript-comment">/* If the file no longer exists, nothing left to do */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NOEXISTS) {
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
        
		<span class="enscript-comment">/* Wait for any in-progress writes to this vnode to complete, so that we'll
		 * be copying consistent bits.  (Otherwise, it's possible that an async
		 * write will complete to the old extent after we read from it.  That
		 * could lead to corruption.)
		 */</span>
		error = vnode_waitforwrites(vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_reclaim_file&quot;</span>);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_file: === Start reclaiming %sfork for %sid=%u ===\n&quot;</span>, (forktype ? <span class="enscript-string">&quot;rsrc&quot;</span> : <span class="enscript-string">&quot;data&quot;</span>), (extent_info-&gt;is_dirlink ? <span class="enscript-string">&quot;dirlink&quot;</span> : <span class="enscript-string">&quot;file&quot;</span>), fileID);
	}
    
	<span class="enscript-keyword">if</span> (extent_info-&gt;is_dirlink) {
		MALLOC(extent_info-&gt;dirlink_desc, <span class="enscript-type">struct</span> cat_desc *,
               <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc), M_TEMP, M_WAITOK);
		MALLOC(extent_info-&gt;dirlink_attr, <span class="enscript-type">struct</span> cat_attr *,
               <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_attr), M_TEMP, M_WAITOK);
		MALLOC(extent_info-&gt;dirlink_fork, <span class="enscript-type">struct</span> filefork *,
               <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> ((extent_info-&gt;dirlink_desc == NULL) ||
		    (extent_info-&gt;dirlink_attr == NULL) ||
		    (extent_info-&gt;dirlink_fork == NULL)) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
        
		<span class="enscript-comment">/* Lookup catalog record for directory hard link and
		 * create a fake filefork for the value looked up from
		 * the disk.
		 */</span>
		fp = extent_info-&gt;dirlink_fork;
		bzero(extent_info-&gt;dirlink_fork, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork));
		extent_info-&gt;dirlink_fork-&gt;ff_cp = cp;
		lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
		error = cat_lookup_dirlink(hfsmp, fileID, forktype,
                                   extent_info-&gt;dirlink_desc, extent_info-&gt;dirlink_attr,
                                   &amp;(extent_info-&gt;dirlink_fork-&gt;ff_data));
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_file: cat_lookup_dirlink for fileID=%u returned error=%u\n&quot;</span>, fileID, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		release_desc = true;
	} <span class="enscript-keyword">else</span> {
		fp = VTOF(vp);
	}
    
	extent_info-&gt;catalog_fp = fp;
	extent_info-&gt;recStartBlock = 0;
	extent_info-&gt;extents = extent_info-&gt;catalog_fp-&gt;ff_extents;
	<span class="enscript-comment">/* Relocate extents from the catalog record */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
		<span class="enscript-keyword">if</span> (fp-&gt;ff_extents[i].blockCount == 0) {
			<span class="enscript-keyword">break</span>;
		}
		extent_info-&gt;extent_index = i;
		error = hfs_reclaim_extent(hfsmp, allocLimit, extent_info, context);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_file: fileID=%u #%d %u:(%u,%u) hfs_reclaim_extent error=%d\n&quot;</span>, fileID, extent_info-&gt;overflow_count, i, fp-&gt;ff_extents[i].startBlock, fp-&gt;ff_extents[i].blockCount, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-comment">/* If the number of allocation blocks processed for reclaiming
	 * are less than total number of blocks for the file, continuing
	 * working on overflow extents record.
	 */</span>
	<span class="enscript-keyword">if</span> (fp-&gt;ff_blocks &lt;= extent_info-&gt;cur_blockCount) {
		<span class="enscript-keyword">if</span> (0 &amp;&amp; hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_file: Nothing more to relocate, offset=%d, ff_blocks=%u, cur_blockCount=%u\n&quot;</span>, i, fp-&gt;ff_blocks, extent_info-&gt;cur_blockCount);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_file: Will check overflow records, offset=%d, ff_blocks=%u, cur_blockCount=%u\n&quot;</span>, i, fp-&gt;ff_blocks, extent_info-&gt;cur_blockCount);
	}
    
	MALLOC(extent_info-&gt;iterator, <span class="enscript-type">struct</span> BTreeIterator *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> BTreeIterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (extent_info-&gt;iterator == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(extent_info-&gt;iterator, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> BTreeIterator));
	key = (HFSPlusExtentKey *) &amp;(extent_info-&gt;iterator-&gt;key);
	key-&gt;keyLength = kHFSPlusExtentKeyMaximumLength;
	key-&gt;forkType = forktype;
	key-&gt;fileID = fileID;
	key-&gt;startBlock = extent_info-&gt;cur_blockCount;
    
	extent_info-&gt;btdata.bufferAddress = extent_info-&gt;record.overflow;
	extent_info-&gt;btdata.itemSize = <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord);
	extent_info-&gt;btdata.itemCount = 1;
    
	extent_info-&gt;catalog_fp = NULL;
    
	<span class="enscript-comment">/* Search the first overflow extent with expected startBlock as 'cur_blockCount' */</span>
	lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
	error = BTSearchRecord(extent_info-&gt;fcb, extent_info-&gt;iterator,
                           &amp;(extent_info-&gt;btdata), &amp;(extent_info-&gt;recordlen),
                           extent_info-&gt;iterator);
	hfs_systemfile_unlock(hfsmp, lockflags);
	<span class="enscript-keyword">while</span> (error == 0) {
		extent_info-&gt;overflow_count++;
		extent_info-&gt;recStartBlock = key-&gt;startBlock;
		extent_info-&gt;extents = extent_info-&gt;record.overflow;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			<span class="enscript-keyword">if</span> (extent_info-&gt;record.overflow[i].blockCount == 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			extent_info-&gt;extent_index = i;
			error = hfs_reclaim_extent(hfsmp, allocLimit, extent_info, context);
			<span class="enscript-keyword">if</span> (error) {
				printf (<span class="enscript-string">&quot;hfs_reclaim_file: fileID=%u #%d %u:(%u,%u) hfs_reclaim_extent error=%d\n&quot;</span>, fileID, extent_info-&gt;overflow_count, i, extent_info-&gt;record.overflow[i].startBlock, extent_info-&gt;record.overflow[i].blockCount, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
        
		<span class="enscript-comment">/* Look for more overflow records */</span>
		lockflags = hfs_systemfile_lock(hfsmp, lockflags, HFS_EXCLUSIVE_LOCK);
		error = BTIterateRecord(extent_info-&gt;fcb, kBTreeNextRecord,
                                extent_info-&gt;iterator, &amp;(extent_info-&gt;btdata),
                                &amp;(extent_info-&gt;recordlen));
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Stop when we encounter a different file or fork. */</span>
		<span class="enscript-keyword">if</span> ((key-&gt;fileID != fileID) || (key-&gt;forkType != forktype)) {
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (error == fsBTRecordNotFoundErr || error == fsBTEndOfIterationErr) {
		error = 0;
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* If any blocks were relocated, account them and report progress */</span>
	<span class="enscript-keyword">if</span> (extent_info-&gt;blocks_relocated) {
		hfsmp-&gt;hfs_resize_blocksmoved += extent_info-&gt;blocks_relocated;
		hfs_truncatefs_progress(hfsmp);
		<span class="enscript-keyword">if</span> (fileID &lt; kHFSFirstUserCatalogNodeID) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_file: Relocated %u blocks from fileID=%u on \&quot;%s\&quot;\n&quot;</span>,
					extent_info-&gt;blocks_relocated, fileID, hfsmp-&gt;vcbVN);
		}
	}
	<span class="enscript-keyword">if</span> (extent_info-&gt;iterator) {
		FREE(extent_info-&gt;iterator, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (release_desc == true) {
		cat_releasedesc(extent_info-&gt;dirlink_desc);
	}
	<span class="enscript-keyword">if</span> (extent_info-&gt;dirlink_desc) {
		FREE(extent_info-&gt;dirlink_desc, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (extent_info-&gt;dirlink_attr) {
		FREE(extent_info-&gt;dirlink_attr, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (extent_info-&gt;dirlink_fork) {
		FREE(extent_info-&gt;dirlink_fork, M_TEMP);
	}
	<span class="enscript-keyword">if</span> ((extent_info-&gt;blocks_relocated != 0) &amp;&amp; (extent_info-&gt;is_sysfile == false)) {
		hfs_update(vp, 0);
	}
	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}
	<span class="enscript-keyword">if</span> (extent_info) {
		FREE(extent_info, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_file: === Finished relocating %sfork for fileid=%u (error=%d) ===\n&quot;</span>, (forktype ? <span class="enscript-string">&quot;rsrc&quot;</span> : <span class="enscript-string">&quot;data&quot;</span>), fileID, error);
	}
    
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * This journal_relocate callback updates the journal info block to point
 * at the new journal location.  This write must NOT be done using the
 * transaction.  We must write the block immediately.  We must also force
 * it to get to the media so that the new journal location will be seen by
 * the replay code before we can safely let journaled blocks be written
 * to their normal locations.
 *
 * The tests for journal_uses_fua below are mildly hacky.  Since the journal
 * and the file system are both on the same device, I'm leveraging what
 * the journal has decided about FUA.
 */</span>
<span class="enscript-type">struct</span> hfs_journal_relocate_args {
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	vfs_context_t context;
	u_int32_t newStartBlock;
	u_int32_t newBlockCount;
};

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">hfs_journal_relocate_callback</span>(<span class="enscript-type">void</span> *_args)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> hfs_journal_relocate_args *args = _args;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = args-&gt;hfsmp;
	buf_t bp;
	JournalInfoBlock *jibp;
    
	error = buf_meta_bread(hfsmp-&gt;hfs_devvp,
                           (uint64_t)hfsmp-&gt;vcbJinfoBlock * (hfsmp-&gt;blockSize/hfsmp-&gt;hfs_logical_block_size),
                           hfsmp-&gt;blockSize, vfs_context_ucred(args-&gt;context), &amp;bp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_journal_relocate_callback: failed to read JIB (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">if</span> (bp) {
            buf_brelse(bp);
		}
		<span class="enscript-keyword">return</span> error;
	}
	jibp = (JournalInfoBlock*) buf_dataptr(bp);
	jibp-&gt;offset = SWAP_BE64((u_int64_t)args-&gt;newStartBlock * hfsmp-&gt;blockSize);
	jibp-&gt;size = SWAP_BE64((u_int64_t)args-&gt;newBlockCount * hfsmp-&gt;blockSize);
	<span class="enscript-keyword">if</span> (journal_uses_fua(hfsmp-&gt;jnl))
		buf_markfua(bp);
	error = buf_bwrite(bp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_journal_relocate_callback: failed to write JIB (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> (!journal_uses_fua(hfsmp-&gt;jnl)) {
		error = hfs_flush(hfsmp, HFS_FLUSH_CACHE);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_journal_relocate_callback: hfs_flush failed (%d)\n&quot;</span>, error);
			error = 0;		<span class="enscript-comment">/* Don't fail the operation. */</span>
		}
	}
    
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/* Type of resize operation in progress */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_RESIZE_TRUNCATE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_RESIZE_EXTEND</span>	2

<span class="enscript-comment">/*
 * Core function to relocate the journal file.  This function takes the
 * journal size of the newly relocated journal --- the caller can
 * provide a new journal size if they want to change the size of
 * the journal.  The function takes care of updating the journal info
 * block and all other data structures correctly.
 *
 * Note: This function starts a transaction and grabs the btree locks.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_relocate_journal_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t jnl_size, <span class="enscript-type">int</span> resize_type, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> journal_err;
	<span class="enscript-type">int</span> lockflags;
	u_int32_t oldStartBlock;
	u_int32_t newStartBlock;
	u_int32_t oldBlockCount;
	u_int32_t newBlockCount;
	u_int32_t jnlBlockCount;
	u_int32_t alloc_skipfreeblks;
	<span class="enscript-type">struct</span> cat_desc journal_desc;
	<span class="enscript-type">struct</span> cat_attr journal_attr;
	<span class="enscript-type">struct</span> cat_fork journal_fork;
	<span class="enscript-type">struct</span> hfs_journal_relocate_args callback_args;
    
	<span class="enscript-comment">/* Calculate the number of allocation blocks required for the journal */</span>
	jnlBlockCount = howmany(jnl_size, hfsmp-&gt;blockSize);
    
	<span class="enscript-comment">/*
	 * During truncatefs(), the volume free block count is updated
	 * before relocating data and reflects the total number of free
	 * blocks that will exist on volume after the resize is successful.
	 * This means that the allocation blocks required for relocation
	 * have already been reserved and accounted for in the free block
	 * count.  Therefore, block allocation and deallocation routines
	 * can skip the free block check by passing HFS_ALLOC_SKIPFREEBLKS
	 * flag.
	 *
	 * This special handling is not required when the file system
	 * is being extended as we want all the allocated and deallocated
	 * blocks to be accounted for correctly.
	 */</span>
	<span class="enscript-keyword">if</span> (resize_type == HFS_RESIZE_TRUNCATE) {
		alloc_skipfreeblks = HFS_ALLOC_SKIPFREEBLKS;
	} <span class="enscript-keyword">else</span> {
		alloc_skipfreeblks = 0;
	}
    
	error = hfs_start_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: hfs_start_transaction returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	
	error = BlockAllocate(hfsmp, 1, jnlBlockCount, jnlBlockCount,
                          HFS_ALLOC_METAZONE | HFS_ALLOC_FORCECONTIG | HFS_ALLOC_FLUSHTXN | alloc_skipfreeblks,
                          &amp;newStartBlock, &amp;newBlockCount);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: BlockAllocate returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	<span class="enscript-keyword">if</span> (newBlockCount != jnlBlockCount) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: newBlockCount != jnlBlockCount (%u, %u)\n&quot;</span>, newBlockCount, jnlBlockCount);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
	
	error = cat_idlookup(hfsmp, hfsmp-&gt;hfs_jnlfileid, 1, 0, &amp;journal_desc, &amp;journal_attr, &amp;journal_fork);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: cat_idlookup returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
    
	oldStartBlock = journal_fork.cf_extents[0].startBlock;
	oldBlockCount = journal_fork.cf_extents[0].blockCount;
	error = BlockDeallocate(hfsmp, oldStartBlock, oldBlockCount, alloc_skipfreeblks);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: BlockDeallocate returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
    
	<span class="enscript-comment">/* Update the catalog record for .journal */</span>
	journal_fork.cf_size = hfs_blk_to_bytes(newBlockCount, hfsmp-&gt;blockSize);
	journal_fork.cf_extents[0].startBlock = newStartBlock;
	journal_fork.cf_extents[0].blockCount = newBlockCount;
	journal_fork.cf_blocks = newBlockCount;
	error = cat_update(hfsmp, &amp;journal_desc, &amp;journal_attr, &amp;journal_fork, NULL);
	cat_releasedesc(&amp;journal_desc);  <span class="enscript-comment">/* all done with cat descriptor */</span>
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: cat_update returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
	
	<span class="enscript-comment">/*
	 * If the journal is part of the file system, then tell the journal
	 * code about the new location.  If the journal is on an external
	 * device, then just keep using it as-is.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jvp == hfsmp-&gt;hfs_devvp) {
		callback_args.hfsmp = hfsmp;
		callback_args.context = context;
		callback_args.newStartBlock = newStartBlock;
		callback_args.newBlockCount = newBlockCount;
        
		error = journal_relocate(hfsmp-&gt;jnl, (off_t)newStartBlock*hfsmp-&gt;blockSize,
                                 (off_t)newBlockCount*hfsmp-&gt;blockSize, 0,
                                 hfs_journal_relocate_callback, &amp;callback_args);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* NOTE: journal_relocate will mark the journal invalid. */</span>
			printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: journal_relocate returned %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_relocate_journal_file: Successfully relocated journal from (%u,%u) to (%u,%u)\n&quot;</span>, oldStartBlock, oldBlockCount, newStartBlock, newBlockCount);
		}
		hfsmp-&gt;jnl_start = newStartBlock;
		hfsmp-&gt;jnl_size = (off_t)newBlockCount * hfsmp-&gt;blockSize;
	}
    
	hfs_systemfile_unlock(hfsmp, lockflags);
	error = hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: hfs_end_transaction returned %d\n&quot;</span>, error);
	}
    
	<span class="enscript-keyword">return</span> error;
    
<span class="enscript-reference">free_fail</span>:
	journal_err = BlockDeallocate(hfsmp, newStartBlock, newBlockCount, HFS_ALLOC_SKIPFREEBLKS);
	<span class="enscript-keyword">if</span> (journal_err) {
		printf(<span class="enscript-string">&quot;hfs_relocate_journal_file: BlockDeallocate returned %d\n&quot;</span>, error);
		hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
	}
<span class="enscript-reference">fail</span>:
	hfs_systemfile_unlock(hfsmp, lockflags);
	(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_relocate_journal_file: Error relocating journal file (error=%d)\n&quot;</span>, error);
	}
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Relocate the journal file when the file system is being truncated.
 * We do not down-size the journal when the file system size is
 * reduced, so we always provide the current journal size to the
 * relocate code.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_journal_file</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	u_int32_t startBlock;
	u_int32_t blockCount = hfsmp-&gt;jnl_size / hfsmp-&gt;blockSize;
    
	<span class="enscript-comment">/*
	 * Figure out the location of the .journal file.  When the journal
	 * is on an external device, we need to look up the .journal file.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jvp == hfsmp-&gt;hfs_devvp) {
		startBlock = hfsmp-&gt;jnl_start;
		blockCount = hfsmp-&gt;jnl_size / hfsmp-&gt;blockSize;
	} <span class="enscript-keyword">else</span> {
		u_int32_t fileid;
		u_int32_t old_jnlfileid;
		<span class="enscript-type">struct</span> cat_attr attr;
		<span class="enscript-type">struct</span> cat_fork fork;
        
		<span class="enscript-comment">/*
		 * The cat_lookup inside GetFileInfo will fail because hfs_jnlfileid
		 * is set, and it is trying to hide the .journal file.  So temporarily
		 * unset the field while calling GetFileInfo.
		 */</span>
		old_jnlfileid = hfsmp-&gt;hfs_jnlfileid;
		hfsmp-&gt;hfs_jnlfileid = 0;
		fileid = GetFileInfo(hfsmp, kHFSRootFolderID, <span class="enscript-string">&quot;.journal&quot;</span>, &amp;attr, &amp;fork);
		hfsmp-&gt;hfs_jnlfileid = old_jnlfileid;
		<span class="enscript-keyword">if</span> (fileid != old_jnlfileid) {
			printf(<span class="enscript-string">&quot;hfs_reclaim_journal_file: cannot find .journal file!\n&quot;</span>);
			<span class="enscript-keyword">return</span> EIO;
		}
        
		startBlock = fork.cf_extents[0].startBlock;
		blockCount = fork.cf_extents[0].blockCount;
	}
    
	<span class="enscript-keyword">if</span> (startBlock + blockCount &lt;= allocLimit) {
		<span class="enscript-comment">/* The journal file does not require relocation */</span>
		<span class="enscript-keyword">return</span> 0;
	}
    
	error = hfs_relocate_journal_file(hfsmp, hfs_blk_to_bytes(blockCount, hfsmp-&gt;blockSize),
									  HFS_RESIZE_TRUNCATE, context);
	<span class="enscript-keyword">if</span> (error == 0) {
		hfsmp-&gt;hfs_resize_blocksmoved += blockCount;
		hfs_truncatefs_progress(hfsmp);
		printf (<span class="enscript-string">&quot;hfs_reclaim_journal_file: Relocated %u blocks from journal on \&quot;%s\&quot;\n&quot;</span>,
				blockCount, hfsmp-&gt;vcbVN);
	}
    
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Move the journal info block to a new location.  We have to make sure the
 * new copy of the journal info block gets to the media first, then change
 * the field in the volume header and the catalog record.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_journal_info_block</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> journal_err;
	<span class="enscript-type">int</span> lockflags;
	u_int32_t oldBlock;
	u_int32_t newBlock;
	u_int32_t blockCount;
	<span class="enscript-type">struct</span> cat_desc jib_desc;
	<span class="enscript-type">struct</span> cat_attr jib_attr;
	<span class="enscript-type">struct</span> cat_fork jib_fork;
	buf_t old_bp, new_bp;
    
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbJinfoBlock &lt;= allocLimit) {
		<span class="enscript-comment">/* The journal info block does not require relocation */</span>
		<span class="enscript-keyword">return</span> 0;
	}
	
	error = hfs_start_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: hfs_start_transaction returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_BITMAP, HFS_EXCLUSIVE_LOCK);
	
	error = BlockAllocate(hfsmp, 1, 1, 1,
                          HFS_ALLOC_METAZONE | HFS_ALLOC_FORCECONTIG | HFS_ALLOC_SKIPFREEBLKS | HFS_ALLOC_FLUSHTXN,
                          &amp;newBlock, &amp;blockCount);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: BlockAllocate returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	<span class="enscript-keyword">if</span> (blockCount != 1) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: blockCount != 1 (%u)\n&quot;</span>, blockCount);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
	
	<span class="enscript-comment">/* Copy the old journal info block content to the new location */</span>
	error = buf_meta_bread(hfsmp-&gt;hfs_devvp,
                           (uint64_t)hfsmp-&gt;vcbJinfoBlock * (hfsmp-&gt;blockSize/hfsmp-&gt;hfs_logical_block_size),
                           hfsmp-&gt;blockSize, vfs_context_ucred(context), &amp;old_bp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: failed to read JIB (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">if</span> (old_bp) {
            buf_brelse(old_bp);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
	new_bp = buf_getblk(hfsmp-&gt;hfs_devvp,
                        (uint64_t)newBlock * (hfsmp-&gt;blockSize/hfsmp-&gt;hfs_logical_block_size),
                        hfsmp-&gt;blockSize, 0, 0, BLK_META);
	bcopy((<span class="enscript-type">char</span>*)buf_dataptr(old_bp), (<span class="enscript-type">char</span>*)buf_dataptr(new_bp), hfsmp-&gt;blockSize);
	buf_brelse(old_bp);
	<span class="enscript-keyword">if</span> (journal_uses_fua(hfsmp-&gt;jnl))
		buf_markfua(new_bp);
	error = buf_bwrite(new_bp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: failed to write new JIB (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
	<span class="enscript-keyword">if</span> (!journal_uses_fua(hfsmp-&gt;jnl)) {
		error = hfs_flush(hfsmp, HFS_FLUSH_CACHE);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: hfs_flush failed (%d)\n&quot;</span>, error);
			<span class="enscript-comment">/* Don't fail the operation. */</span>
		}
	}
    
	<span class="enscript-comment">/* Deallocate the old block once the new one has the new valid content */</span>
	error = BlockDeallocate(hfsmp, hfsmp-&gt;vcbJinfoBlock, 1, HFS_ALLOC_SKIPFREEBLKS);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: BlockDeallocate returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">free_fail</span>;
	}
    
	
	<span class="enscript-comment">/* Update the catalog record for .journal_info_block */</span>
	error = cat_idlookup(hfsmp, hfsmp-&gt;hfs_jnlinfoblkid, 1, 0, &amp;jib_desc, &amp;jib_attr, &amp;jib_fork);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: cat_idlookup returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	oldBlock = jib_fork.cf_extents[0].startBlock;
	jib_fork.cf_size = hfsmp-&gt;blockSize;
	jib_fork.cf_extents[0].startBlock = newBlock;
	jib_fork.cf_extents[0].blockCount = 1;
	jib_fork.cf_blocks = 1;
	error = cat_update(hfsmp, &amp;jib_desc, &amp;jib_attr, &amp;jib_fork, NULL);
	cat_releasedesc(&amp;jib_desc);  <span class="enscript-comment">/* all done with cat descriptor */</span>
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: cat_update returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-comment">/* Update the pointer to the journal info block in the volume header. */</span>
	hfsmp-&gt;vcbJinfoBlock = newBlock;
	error = hfs_flushvolumeheader(hfsmp, HFS_FVH_WAIT | HFS_FVH_WRITE_ALT);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: hfs_flushvolumeheader returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	hfs_systemfile_unlock(hfsmp, lockflags);
	error = hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: hfs_end_transaction returned %d\n&quot;</span>, error);
	}
	error = hfs_flush(hfsmp, HFS_FLUSH_JOURNAL);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: journal_flush returned %d\n&quot;</span>, error);
	}
    
	<span class="enscript-comment">/* Account for the block relocated and print progress */</span>
	hfsmp-&gt;hfs_resize_blocksmoved += 1;
	hfs_truncatefs_progress(hfsmp);
	<span class="enscript-keyword">if</span> (!error) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_journal_info: Relocated 1 block from journal info on \&quot;%s\&quot;\n&quot;</span>,
				hfsmp-&gt;vcbVN);
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: Successfully relocated journal info block from (%u,%u) to (%u,%u)\n&quot;</span>, oldBlock, blockCount, newBlock, blockCount);
		}
	}
	<span class="enscript-keyword">return</span> error;
    
<span class="enscript-reference">free_fail</span>:
	journal_err = BlockDeallocate(hfsmp, newBlock, blockCount, HFS_ALLOC_SKIPFREEBLKS);
	<span class="enscript-keyword">if</span> (journal_err) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: BlockDeallocate returned %d\n&quot;</span>, error);
		hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
	}
    
<span class="enscript-reference">fail</span>:
	hfs_systemfile_unlock(hfsmp, lockflags);
	(<span class="enscript-type">void</span>) hfs_end_transaction(hfsmp);
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_reclaim_journal_info_block: Error relocating journal info block (error=%d)\n&quot;</span>, error);
	}
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> u_int64_t
<span class="enscript-function-name">calculate_journal_size</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t sector_size, u_int64_t sector_count)
{
	u_int64_t journal_size;
	u_int32_t journal_scale;
    
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_JOURNAL_SIZE</span> (8*1024*1024)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_JOURNAL_SIZE</span>     (512*1024*1024)
    
	<span class="enscript-comment">/* Calculate the journal size for this volume.   We want
	 * at least 8 MB of journal for each 100 GB of disk space.
	 * We cap the size at 512 MB, unless the allocation block
	 * size is larger, in which case, we use one allocation
	 * block.
	 */</span>
	journal_scale = (sector_size * sector_count) / ((u_int64_t)100 * 1024 * 1024 * 1024);
	journal_size = DEFAULT_JOURNAL_SIZE * (journal_scale + 1);
	<span class="enscript-keyword">if</span> (journal_size &gt; MAX_JOURNAL_SIZE) {
		journal_size = MAX_JOURNAL_SIZE;
	}
	<span class="enscript-keyword">if</span> (journal_size &lt; hfsmp-&gt;blockSize) {
		journal_size = hfsmp-&gt;blockSize;
	}
	<span class="enscript-keyword">return</span> journal_size;
}


<span class="enscript-comment">/*
 * Calculate the expected journal size based on current partition size.
 * If the size of the current journal is less than the calculated size,
 * force journal relocation with the new journal size.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_extend_journal</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t sector_size, u_int64_t sector_count, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	u_int64_t calc_journal_size;
    
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jvp != hfsmp-&gt;hfs_devvp) {
		<span class="enscript-keyword">if</span> (hfs_resize_debug) {
			printf(<span class="enscript-string">&quot;hfs_extend_journal: not resizing the journal because it is on an external device.\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span> 0;
	}
    
	calc_journal_size = calculate_journal_size(hfsmp, sector_size, sector_count);
	<span class="enscript-keyword">if</span> (calc_journal_size &lt;= hfsmp-&gt;jnl_size) {
		<span class="enscript-comment">/* The journal size requires no modification */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_extend_journal: journal old=%u, new=%qd\n&quot;</span>, hfsmp-&gt;jnl_size, calc_journal_size);
	}
    
	<span class="enscript-comment">/* Extend the journal to the new calculated size */</span>
	error = hfs_relocate_journal_file(hfsmp, calc_journal_size, HFS_RESIZE_EXTEND, context);
	<span class="enscript-keyword">if</span> (error == 0) {
		printf (<span class="enscript-string">&quot;hfs_extend_journal: Extended journal size to %u bytes on \&quot;%s\&quot;\n&quot;</span>,
				hfsmp-&gt;jnl_size, hfsmp-&gt;vcbVN);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * This function traverses through all extended attribute records for a given
 * fileID, and calls function that reclaims data blocks that exist in the
 * area of the disk being reclaimed which in turn is responsible for allocating
 * new space, copying extent data, deallocating new space, and if required,
 * splitting the extent.
 *
 * Note: The caller has already acquired the cnode lock on the file.  Therefore
 * we are assured that no other thread would be creating/deleting/modifying
 * extended attributes for this file.
 *
 * Side Effects:
 * hfsmp-&gt;hfs_resize_blocksmoved is incremented by the number of allocation
 * blocks that were relocated.
 *
 * Returns:
 * 	0 on success, non-zero on failure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_xattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, u_int32_t fileID, u_int32_t allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> hfs_reclaim_extent_info *extent_info;
	<span class="enscript-type">int</span> i;
	HFSPlusAttrKey *key;
	<span class="enscript-type">int</span> *lockflags;
    
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_xattr: === Start reclaiming xattr for id=%u ===\n&quot;</span>, fileID);
	}
    
	MALLOC(extent_info, <span class="enscript-type">struct</span> hfs_reclaim_extent_info *,
	       <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_reclaim_extent_info), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (extent_info == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero(extent_info, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> hfs_reclaim_extent_info));
	extent_info-&gt;vp = vp;
	extent_info-&gt;fileID = fileID;
	extent_info-&gt;is_xattr = true;
	extent_info-&gt;is_sysfile = vnode_issystem(vp);
	extent_info-&gt;fcb = VTOF(hfsmp-&gt;hfs_attribute_vp);
	lockflags = &amp;(extent_info-&gt;lockflags);
	*lockflags = SFL_ATTRIBUTE | SFL_BITMAP;
    
	<span class="enscript-comment">/* Initialize iterator from the extent_info structure */</span>
	MALLOC(extent_info-&gt;iterator, <span class="enscript-type">struct</span> BTreeIterator *,
	       <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> BTreeIterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (extent_info-&gt;iterator == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(extent_info-&gt;iterator, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> BTreeIterator));
    
	<span class="enscript-comment">/* Build attribute key */</span>
	key = (HFSPlusAttrKey *)&amp;(extent_info-&gt;iterator-&gt;key);
	error = hfs_buildattrkey(fileID, NULL, key);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* Initialize btdata from extent_info structure.  Note that the
	 * buffer pointer actually points to the xattr record from the
	 * extent_info structure itself.
	 */</span>
	extent_info-&gt;btdata.bufferAddress = &amp;(extent_info-&gt;record.xattr);
	extent_info-&gt;btdata.itemSize = <span class="enscript-keyword">sizeof</span>(HFSPlusAttrRecord);
	extent_info-&gt;btdata.itemCount = 1;
    
	<span class="enscript-comment">/*
	 * Sync all extent-based attribute data to the disk.
	 *
	 * All extent-based attribute data I/O is performed via cluster
	 * I/O using a virtual file that spans across entire file system
	 * space.
	 */</span>
	hfs_lock_truncate(VTOC(hfsmp-&gt;hfs_attrdata_vp), HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	(<span class="enscript-type">void</span>)cluster_push(hfsmp-&gt;hfs_attrdata_vp, 0);
	error = vnode_waitforwrites(hfsmp-&gt;hfs_attrdata_vp, 0, 0, 0, <span class="enscript-string">&quot;hfs_reclaim_xattr&quot;</span>);
	hfs_unlock_truncate(VTOC(hfsmp-&gt;hfs_attrdata_vp), HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	<span class="enscript-comment">/* Search for extended attribute for current file.  This
	 * will place the iterator before the first matching record.
	 */</span>
	*lockflags = hfs_systemfile_lock(hfsmp, *lockflags, HFS_EXCLUSIVE_LOCK);
	error = BTSearchRecord(extent_info-&gt;fcb, extent_info-&gt;iterator,
                           &amp;(extent_info-&gt;btdata), &amp;(extent_info-&gt;recordlen),
                           extent_info-&gt;iterator);
	hfs_systemfile_unlock(hfsmp, *lockflags);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error != btNotFound) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* btNotFound is expected here, so just mask it */</span>
		error = 0;
	}
    
	<span class="enscript-keyword">while</span> (1) {
		<span class="enscript-comment">/* Iterate to the next record */</span>
		*lockflags = hfs_systemfile_lock(hfsmp, *lockflags, HFS_EXCLUSIVE_LOCK);
		error = BTIterateRecord(extent_info-&gt;fcb, kBTreeNextRecord,
                                extent_info-&gt;iterator, &amp;(extent_info-&gt;btdata),
                                &amp;(extent_info-&gt;recordlen));
		hfs_systemfile_unlock(hfsmp, *lockflags);
        
		<span class="enscript-comment">/* Stop the iteration if we encounter end of btree or xattr with different fileID */</span>
		<span class="enscript-keyword">if</span> (error || key-&gt;fileID != fileID) {
			<span class="enscript-keyword">if</span> (error == fsBTRecordNotFoundErr || error == fsBTEndOfIterationErr) {
				error = 0;
			}
			<span class="enscript-keyword">break</span>;
		}
        
		<span class="enscript-comment">/* We only care about extent-based EAs */</span>
		<span class="enscript-keyword">if</span> ((extent_info-&gt;record.xattr.recordType != kHFSPlusAttrForkData) &amp;&amp;
		    (extent_info-&gt;record.xattr.recordType != kHFSPlusAttrExtents)) {
			<span class="enscript-keyword">continue</span>;
		}
        
		<span class="enscript-keyword">if</span> (extent_info-&gt;record.xattr.recordType == kHFSPlusAttrForkData) {
			extent_info-&gt;overflow_count = 0;
			extent_info-&gt;extents = extent_info-&gt;record.xattr.forkData.theFork.extents;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (extent_info-&gt;record.xattr.recordType == kHFSPlusAttrExtents) {
			extent_info-&gt;overflow_count++;
			extent_info-&gt;extents = extent_info-&gt;record.xattr.overflowExtents.extents;
		}
        
		extent_info-&gt;recStartBlock = key-&gt;startBlock;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
			<span class="enscript-keyword">if</span> (extent_info-&gt;extents[i].blockCount == 0) {
				<span class="enscript-keyword">break</span>;
			}
			extent_info-&gt;extent_index = i;
			error = hfs_reclaim_extent(hfsmp, allocLimit, extent_info, context);
			<span class="enscript-keyword">if</span> (error) {
				printf (<span class="enscript-string">&quot;hfs_reclaim_xattr: fileID=%u hfs_reclaim_extent error=%d\n&quot;</span>, fileID, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}
    
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* If any blocks were relocated, account them and report progress */</span>
	<span class="enscript-keyword">if</span> (extent_info-&gt;blocks_relocated) {
		hfsmp-&gt;hfs_resize_blocksmoved += extent_info-&gt;blocks_relocated;
		hfs_truncatefs_progress(hfsmp);
	}
	<span class="enscript-keyword">if</span> (extent_info-&gt;iterator) {
		FREE(extent_info-&gt;iterator, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (extent_info) {
		FREE(extent_info, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_xattr: === Finished relocating xattr for fileid=%u (error=%d) ===\n&quot;</span>, fileID, error);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Reclaim any extent-based extended attributes allocation blocks from
 * the area of the disk that is being truncated.
 *
 * The function traverses the attribute btree to find out the fileIDs
 * of the extended attributes that need to be relocated.  For every
 * file whose large EA requires relocation, it looks up the cnode and
 * calls hfs_reclaim_xattr() to do all the work for allocating
 * new space, copying data, deallocating old space, and if required,
 * splitting the extents.
 *
 * Inputs:
 * 	allocLimit    - starting block of the area being reclaimed
 *
 * Returns:
 *   	returns 0 on success, non-zero on failure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_xattrspace</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
	FCB *fcb;
	<span class="enscript-type">struct</span> BTreeIterator *iterator = NULL;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	HFSPlusAttrKey *key;
	HFSPlusAttrRecord rec;
	<span class="enscript-type">int</span> lockflags = 0;
	cnid_t prev_fileid = 0;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">int</span> need_relocate;
	<span class="enscript-type">int</span> btree_operation;
	u_int32_t files_moved = 0;
	u_int32_t prev_blocksmoved;
	<span class="enscript-type">int</span> i;
    
	fcb = VTOF(hfsmp-&gt;hfs_attribute_vp);
	<span class="enscript-comment">/* Store the value to print total blocks moved by this function in end */</span>
	prev_blocksmoved = hfsmp-&gt;hfs_resize_blocksmoved;
    
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;iterator, <span class="enscript-keyword">sizeof</span>(*iterator), VM_KERN_MEMORY_FILE)) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (HFSPlusAttrKey *)&amp;iterator-&gt;key;
	btdata.bufferAddress = &amp;rec;
	btdata.itemSize = <span class="enscript-keyword">sizeof</span>(rec);
	btdata.itemCount = 1;
    
	need_relocate = false;
	btree_operation = kBTreeFirstRecord;
	<span class="enscript-comment">/* Traverse the attribute btree to find extent-based EAs to reclaim */</span>
	<span class="enscript-keyword">while</span> (1) {
		lockflags = hfs_systemfile_lock(hfsmp, SFL_ATTRIBUTE, HFS_SHARED_LOCK);
		error = BTIterateRecord(fcb, btree_operation, iterator, &amp;btdata, NULL);
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == fsBTRecordNotFoundErr || error == fsBTEndOfIterationErr) {
				error = 0;
			}
			<span class="enscript-keyword">break</span>;
		}
		btree_operation = kBTreeNextRecord;
        
		<span class="enscript-comment">/* If the extents of current fileID were already relocated, skip it */</span>
		<span class="enscript-keyword">if</span> (prev_fileid == key-&gt;fileID) {
			<span class="enscript-keyword">continue</span>;
		}
        
		<span class="enscript-comment">/* Check if any of the extents in the current record need to be relocated */</span>
		need_relocate = false;
		<span class="enscript-keyword">switch</span>(rec.recordType) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusAttrForkData</span>:
				<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
					<span class="enscript-keyword">if</span> (rec.forkData.theFork.extents[i].blockCount == 0) {
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">if</span> ((rec.forkData.theFork.extents[i].startBlock +
					     rec.forkData.theFork.extents[i].blockCount) &gt; allocLimit) {
						need_relocate = true;
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">break</span>;
                
			<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusAttrExtents</span>:
				<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; i++) {
					<span class="enscript-keyword">if</span> (rec.overflowExtents.extents[i].blockCount == 0) {
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">if</span> ((rec.overflowExtents.extents[i].startBlock +
					     rec.overflowExtents.extents[i].blockCount) &gt; allocLimit) {
						need_relocate = true;
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">break</span>;
		};
        
		<span class="enscript-comment">/* Continue iterating to next attribute record */</span>
		<span class="enscript-keyword">if</span> (need_relocate == false) {
			<span class="enscript-keyword">continue</span>;
		}
        
		<span class="enscript-comment">/* Look up the vnode for corresponding file.  The cnode
		 * will be locked which will ensure that no one modifies
		 * the xattrs when we are relocating them.
		 *
		 * We want to allow open-unlinked files to be moved,
		 * so provide allow_deleted == 1 for hfs_vget().
		 */</span>
		<span class="enscript-keyword">if</span> (hfs_vget(hfsmp, key-&gt;fileID, &amp;vp, 0, 1) != 0) {
			<span class="enscript-keyword">continue</span>;
		}
        
		error = hfs_reclaim_xattr(hfsmp, vp, key-&gt;fileID, allocLimit, context);
		hfs_unlock(VTOC(vp));
		vnode_put(vp);
		<span class="enscript-keyword">if</span> (error) {
			printf (<span class="enscript-string">&quot;hfs_reclaim_xattrspace: Error relocating xattrs for fileid=%u (error=%d)\n&quot;</span>, key-&gt;fileID, error);
			<span class="enscript-keyword">break</span>;
		}
		prev_fileid = key-&gt;fileID;
		files_moved++;
	}
    
	<span class="enscript-keyword">if</span> (files_moved) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_xattrspace: Relocated %u xattr blocks from %u files on \&quot;%s\&quot;\n&quot;</span>,
               (hfsmp-&gt;hfs_resize_blocksmoved - prev_blocksmoved),
               files_moved, hfsmp-&gt;vcbVN);
	}
    
	kmem_free(kernel_map, (vm_offset_t)iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Reclaim blocks from regular files.
 *
 * This function iterates over all the record in catalog btree looking
 * for files with extents that overlap into the space we're trying to
 * free up.  If a file extent requires relocation, it looks up the vnode
 * and calls function to relocate the data.
 *
 * Returns:
 * 	Zero on success, non-zero on failure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaim_filespace</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, vfs_context_t context)
{
	<span class="enscript-type">int</span> error;
	FCB *fcb;
	<span class="enscript-type">struct</span> BTreeIterator *iterator = NULL;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	<span class="enscript-type">int</span> btree_operation;
	<span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">struct</span> HFSPlusCatalogFile filerec;
	<span class="enscript-type">struct</span> vnode *vp;
	<span class="enscript-type">struct</span> vnode *rvp;
	<span class="enscript-type">struct</span> filefork *datafork;
	u_int32_t files_moved = 0;
	u_int32_t prev_blocksmoved;
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-type">int</span> keys_generated = 0;
#<span class="enscript-reference">endif</span>
    
	fcb = VTOF(hfsmp-&gt;hfs_catalog_vp);
	<span class="enscript-comment">/* Store the value to print total blocks moved by this function at the end */</span>
	prev_blocksmoved = hfsmp-&gt;hfs_resize_blocksmoved;
    
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, (vm_offset_t *)&amp;iterator, <span class="enscript-keyword">sizeof</span>(*iterator), VM_KERN_MEMORY_FILE)) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">reclaim_filespace_done</span>;
	}
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/*
	 * For content-protected filesystems, we may need to relocate files that
	 * are encrypted.  If they use the new-style offset-based IVs, then
	 * we can move them regardless of the lock state.  We create a temporary
	 * key here that we use to read/write the data, then we discard it at the
	 * end of the function.
	 */</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected (hfsmp-&gt;hfs_mp)) {
		error = cpx_gentempkeys(&amp;hfsmp-&gt;hfs_resize_cpx, hfsmp);
		<span class="enscript-keyword">if</span> (error == 0) {
			keys_generated = 1;
		}

		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_reclaimspace: Error generating temporary keys for resize (%d)\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">reclaim_filespace_done</span>;
		}
	}
    
#<span class="enscript-reference">endif</span>
    
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
    
	btdata.bufferAddress = &amp;filerec;
	btdata.itemSize = <span class="enscript-keyword">sizeof</span>(filerec);
	btdata.itemCount = 1;
    
	btree_operation = kBTreeFirstRecord;
	<span class="enscript-keyword">while</span> (1) {
		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);
		error = BTIterateRecord(fcb, btree_operation, iterator, &amp;btdata, NULL);
		hfs_systemfile_unlock(hfsmp, lockflags);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == fsBTRecordNotFoundErr || error == fsBTEndOfIterationErr) {
				error = 0;
			}
			<span class="enscript-keyword">break</span>;
		}
		btree_operation = kBTreeNextRecord;
        
		<span class="enscript-keyword">if</span> (filerec.recordType != kHFSPlusFileRecord) {
			<span class="enscript-keyword">continue</span>;
		}
        
		<span class="enscript-comment">/* Check if any of the extents require relocation */</span>
		bool overlaps;
		error = hfs_file_extent_overlaps(hfsmp, allocLimit, &amp;filerec, &amp;overlaps);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (!overlaps)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* We want to allow open-unlinked files to be moved, so allow_deleted == 1 */</span>
		<span class="enscript-keyword">if</span> (hfs_vget(hfsmp, filerec.fileID, &amp;vp, 0, 1) != 0) {
			<span class="enscript-keyword">if</span> (hfs_resize_debug) {
				printf(<span class="enscript-string">&quot;hfs_reclaim_filespace: hfs_vget(%u) failed.\n&quot;</span>, filerec.fileID);
			}
			<span class="enscript-keyword">continue</span>;
		}
        
		<span class="enscript-comment">/* If data fork exists or item is a directory hard link, relocate blocks */</span>
		datafork = VTOF(vp);
		<span class="enscript-keyword">if</span> ((datafork &amp;&amp; datafork-&gt;ff_blocks &gt; 0) || vnode_isdir(vp)) {
			error = hfs_reclaim_file(hfsmp, vp, filerec.fileID,
                                     kHFSDataForkType, allocLimit, context);
			<span class="enscript-keyword">if</span> (error)  {
				printf (<span class="enscript-string">&quot;hfs_reclaimspace: Error reclaiming datafork blocks of fileid=%u (error=%d)\n&quot;</span>, filerec.fileID, error);
				hfs_unlock(VTOC(vp));
				vnode_put(vp);
				<span class="enscript-keyword">break</span>;
			}
		}
        
		<span class="enscript-comment">/* If resource fork exists or item is a directory hard link, relocate blocks */</span>
		<span class="enscript-keyword">if</span> (((VTOC(vp)-&gt;c_blocks - (datafork ? datafork-&gt;ff_blocks : 0)) &gt; 0) || vnode_isdir(vp)) {
			<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
				<span class="enscript-comment">/* Resource fork vnode lookup is invalid for directory hard link.
				 * So we fake data fork vnode as resource fork vnode.
				 */</span>
				rvp = vp;
			} <span class="enscript-keyword">else</span> {
				error = hfs_vgetrsrc(hfsmp, vp, &amp;rvp);
				<span class="enscript-keyword">if</span> (error) {
					printf (<span class="enscript-string">&quot;hfs_reclaimspace: Error looking up rvp for fileid=%u (error=%d)\n&quot;</span>, filerec.fileID, error);
					hfs_unlock(VTOC(vp));
					vnode_put(vp);
					<span class="enscript-keyword">break</span>;
				}
				VTOC(rvp)-&gt;c_flag |= C_NEED_RVNODE_PUT;
			}
            
			error = hfs_reclaim_file(hfsmp, rvp, filerec.fileID,
                                     kHFSResourceForkType, allocLimit, context);
			<span class="enscript-keyword">if</span> (error) {
				printf (<span class="enscript-string">&quot;hfs_reclaimspace: Error reclaiming rsrcfork blocks of fileid=%u (error=%d)\n&quot;</span>, filerec.fileID, error);
				hfs_unlock(VTOC(vp));
				vnode_put(vp);
				<span class="enscript-keyword">break</span>;
			}
		}
        
		<span class="enscript-comment">/* The file forks were relocated successfully, now drop the
		 * cnode lock and vnode reference, and continue iterating to
		 * next catalog record.
		 */</span>
		hfs_unlock(VTOC(vp));
		vnode_put(vp);
		files_moved++;
	}
    
	<span class="enscript-keyword">if</span> (files_moved) {
		printf(<span class="enscript-string">&quot;hfs_reclaim_filespace: Relocated %u blocks from %u files on \&quot;%s\&quot;\n&quot;</span>,
               (hfsmp-&gt;hfs_resize_blocksmoved - prev_blocksmoved),
               files_moved, hfsmp-&gt;vcbVN);
	}
    
<span class="enscript-reference">reclaim_filespace_done</span>:
	<span class="enscript-keyword">if</span> (iterator) {
		kmem_free(kernel_map, (vm_offset_t)iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	}
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-keyword">if</span> (keys_generated) {
		cpx_free(hfsmp-&gt;hfs_resize_cpx);
		hfsmp-&gt;hfs_resize_cpx = NULL;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Reclaim space at the end of a file system.
 *
 * Inputs -
 * 	allocLimit 	- start block of the space being reclaimed
 * 	reclaimblks 	- number of allocation blocks to reclaim
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_reclaimspace</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit, u_int32_t reclaimblks, vfs_context_t context)
{
	<span class="enscript-type">int</span> error = 0;
    
	<span class="enscript-comment">/*
	 * Preflight the bitmap to find out total number of blocks that need
	 * relocation.
	 *
	 * Note: Since allocLimit is set to the location of new alternate volume
	 * header, the check below does not account for blocks allocated for old
	 * alternate volume header.
	 */</span>
	error = hfs_count_allocated(hfsmp, allocLimit, reclaimblks, &amp;(hfsmp-&gt;hfs_resize_totalblocks));
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaimspace: Unable to determine total blocks to reclaim error=%d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> (hfs_resize_debug) {
		printf (<span class="enscript-string">&quot;hfs_reclaimspace: Total number of blocks to reclaim = %u\n&quot;</span>, hfsmp-&gt;hfs_resize_totalblocks);
	}
    
	<span class="enscript-comment">/* Just to be safe, sync the content of the journal to the disk before we proceed */</span>
	hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
    
	<span class="enscript-comment">/* First, relocate journal file blocks if they're in the way.
	 * Doing this first will make sure that journal relocate code
	 * gets access to contiguous blocks on disk first.  The journal
	 * file has to be contiguous on the disk, otherwise resize will
	 * fail.
	 */</span>
	error = hfs_reclaim_journal_file(hfsmp, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: hfs_reclaim_journal_file failed (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-comment">/* Relocate journal info block blocks if they're in the way. */</span>
	error = hfs_reclaim_journal_info_block(hfsmp, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: hfs_reclaim_journal_info_block failed (%d)\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Relocate extents of the Extents B-tree if they're in the way.
	 * Relocating extents btree before other btrees is important as
	 * this will provide access to largest contiguous block range on
	 * the disk for relocating extents btree.  Note that extents btree
	 * can only have maximum of 8 extents.
	 */</span>
	error = hfs_reclaim_file(hfsmp, hfsmp-&gt;hfs_extents_vp, kHFSExtentsFileID,
                             kHFSDataForkType, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: reclaim extents b-tree returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Relocate extents of the Allocation file if they're in the way. */</span>
	error = hfs_reclaim_file(hfsmp, hfsmp-&gt;hfs_allocation_vp, kHFSAllocationFileID,
                             kHFSDataForkType, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: reclaim allocation file returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Relocate extents of the Catalog B-tree if they're in the way. */</span>
	error = hfs_reclaim_file(hfsmp, hfsmp-&gt;hfs_catalog_vp, kHFSCatalogFileID,
                             kHFSDataForkType, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: reclaim catalog b-tree returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Relocate extents of the Attributes B-tree if they're in the way. */</span>
	error = hfs_reclaim_file(hfsmp, hfsmp-&gt;hfs_attribute_vp, kHFSAttributesFileID,
                             kHFSDataForkType, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: reclaim attribute b-tree returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Relocate extents of the Startup File if there is one and they're in the way. */</span>
	error = hfs_reclaim_file(hfsmp, hfsmp-&gt;hfs_startup_vp, kHFSStartupFileID,
                             kHFSDataForkType, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;hfs_reclaimspace: reclaim startup file returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-comment">/*
	 * We need to make sure the alternate volume header gets flushed if we moved
	 * any extents in the volume header.  But we need to do that before
	 * shrinking the size of the volume, or else the journal code will panic
	 * with an invalid (too large) block number.
	 *
	 * Note that blks_moved will be set if ANY extent was moved, even
	 * if it was just an overflow extent.  In this case, the journal_flush isn't
	 * strictly required, but shouldn't hurt.
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_resize_blocksmoved) {
		hfs_flush(hfsmp, HFS_FLUSH_JOURNAL_META);
	}
    
	<span class="enscript-comment">/* Reclaim extents from catalog file records */</span>
	error = hfs_reclaim_filespace(hfsmp, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaimspace: hfs_reclaim_filespace returned error=%d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}
    
	<span class="enscript-comment">/* Reclaim extents from extent-based extended attributes, if any */</span>
	error = hfs_reclaim_xattrspace(hfsmp, allocLimit, context);
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs_reclaimspace: hfs_reclaim_xattrspace returned error=%d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/*
	 * Make sure reserved ranges in the region we're to allocate don't
	 * overlap.
	 */</span>
	<span class="enscript-type">struct</span> rl_entry *range;
<span class="enscript-reference">again</span>:;
	<span class="enscript-type">int</span> lockf = hfs_systemfile_lock(hfsmp, SFL_BITMAP, HFS_SHARED_LOCK);
	TAILQ_FOREACH(range, &amp;hfsmp-&gt;hfs_reserved_ranges[HFS_LOCKED_BLOCKS], rl_link) {
		<span class="enscript-keyword">if</span> (rl_overlap(range, hfsmp-&gt;allocLimit, RL_INFINITY) != RL_NOOVERLAP) {
			<span class="enscript-comment">// Wait 100ms
</span>			hfs_systemfile_unlock(hfsmp, lockf);
			msleep(hfs_reclaimspace, NULL, PINOD, <span class="enscript-string">&quot;waiting on reserved blocks&quot;</span>,
				   &amp;(<span class="enscript-type">struct</span> timespec){ 0, 100 * 1000000 });
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
	}
	hfs_systemfile_unlock(hfsmp, lockf);

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Check if there are any extents (including overflow extents) that overlap
 * into the disk space that is being reclaimed.
 *
 * Output -
 * 	true  - One of the extents need to be relocated
 * 	false - No overflow extents need to be relocated, or there was an error
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">hfs_file_extent_overlaps</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t allocLimit,
						 <span class="enscript-type">struct</span> HFSPlusCatalogFile *filerec, bool *overlaps)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator = NULL;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	HFSPlusExtentRecord extrec;
	HFSPlusExtentKey *extkeyptr;
	FCB *fcb;
	<span class="enscript-type">int</span> i, j;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> lockflags = 0;
	u_int32_t endblock;
	errno_t ret = 0;

	<span class="enscript-comment">/* Check if data fork overlaps the target space */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
		<span class="enscript-keyword">if</span> (filerec-&gt;dataFork.extents[i].blockCount == 0) {
			<span class="enscript-keyword">break</span>;
		}
		endblock = filerec-&gt;dataFork.extents[i].startBlock +
        filerec-&gt;dataFork.extents[i].blockCount;
		<span class="enscript-keyword">if</span> (endblock &gt; allocLimit) {
			*overlaps = true;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-comment">/* Check if resource fork overlaps the target space */</span>
	<span class="enscript-keyword">for</span> (j = 0; j &lt; kHFSPlusExtentDensity; ++j) {
		<span class="enscript-keyword">if</span> (filerec-&gt;resourceFork.extents[j].blockCount == 0) {
			<span class="enscript-keyword">break</span>;
		}
		endblock = filerec-&gt;resourceFork.extents[j].startBlock +
        filerec-&gt;resourceFork.extents[j].blockCount;
		<span class="enscript-keyword">if</span> (endblock &gt; allocLimit) {
			*overlaps = true;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
    
	<span class="enscript-comment">/* Return back if there are no overflow extents for this file */</span>
	<span class="enscript-keyword">if</span> ((i &lt; kHFSPlusExtentDensity) &amp;&amp; (j &lt; kHFSPlusExtentDensity)) {
		*overlaps = false;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);

	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	extkeyptr = (HFSPlusExtentKey *)&amp;iterator-&gt;key;
	extkeyptr-&gt;keyLength = kHFSPlusExtentKeyMaximumLength;
	extkeyptr-&gt;forkType = 0;
	extkeyptr-&gt;fileID = filerec-&gt;fileID;
	extkeyptr-&gt;startBlock = 0;
    
	btdata.bufferAddress = &amp;extrec;
	btdata.itemSize = <span class="enscript-keyword">sizeof</span>(extrec);
	btdata.itemCount = 1;
	
	fcb = VTOF(hfsmp-&gt;hfs_extents_vp);
    
	lockflags = hfs_systemfile_lock(hfsmp, SFL_EXTENTS, HFS_SHARED_LOCK);
    
	<span class="enscript-comment">/* This will position the iterator just before the first overflow 
	 * extent record for given fileID.  It will always return btNotFound, 
	 * so we special case the error code.
	 */</span>
	error = BTSearchRecord(fcb, iterator, &amp;btdata, NULL, iterator);
	<span class="enscript-keyword">if</span> (error &amp;&amp; (error != btNotFound)) {
		ret = MacToVFSError(error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* BTIterateRecord() might return error if the btree is empty, and 
	 * therefore we return that the extent does not overflow to the caller
	 */</span>
	error = BTIterateRecord(fcb, kBTreeNextRecord, iterator, &amp;btdata, NULL);
	<span class="enscript-keyword">while</span> (error == 0) {
		<span class="enscript-comment">/* Stop when we encounter a different file. */</span>
		<span class="enscript-keyword">if</span> (extkeyptr-&gt;fileID != filerec-&gt;fileID) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Check if any of the forks exist in the target space. */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
			<span class="enscript-keyword">if</span> (extrec[i].blockCount == 0) {
				<span class="enscript-keyword">break</span>;
			}
			endblock = extrec[i].startBlock + extrec[i].blockCount;
			<span class="enscript-keyword">if</span> (endblock &gt; allocLimit) {
				*overlaps = true;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
		<span class="enscript-comment">/* Look for more records. */</span>
		error = BTIterateRecord(fcb, kBTreeNextRecord, iterator, &amp;btdata, NULL);
	}

	<span class="enscript-keyword">if</span> (error &amp;&amp; error != btNotFound) {
		ret = MacToVFSError(error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	*overlaps = false;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (lockflags) {
		hfs_systemfile_unlock(hfsmp, lockflags);
	}

	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-comment">/*
 * Calculate the progress of a file system resize operation.
 */</span>
__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_resize_progress</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t *progress)
{
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_RESIZE_IN_PROGRESS) == 0) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
    
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_resize_totalblocks &gt; 0) {
		*progress = (u_int32_t)((hfsmp-&gt;hfs_resize_blocksmoved * 100ULL) / hfsmp-&gt;hfs_resize_totalblocks);
	} <span class="enscript-keyword">else</span> {
		*progress = 0;
	}
    
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>