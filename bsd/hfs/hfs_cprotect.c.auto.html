<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_cprotect.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_cprotect.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/sha1.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cnode.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_fsctl.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_cprotect.h&quot;</span>


#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTR_ADD</span>(type, base, offset)		(type)((uintptr_t)(base) + (offset))

<span class="enscript-comment">/*
 * The wrap function pointers and the variable to indicate if they
 * are initialized are system-wide, and hence are defined globally.
 */</span> 
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cp_wrap_func g_cp_wrap_func = {};
<span class="enscript-type">static</span> <span class="enscript-type">int</span> are_wraps_initialized = false;

<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**hfs_vnodeop_p) (<span class="enscript-type">void</span> *);

<span class="enscript-comment">/*
 * CP private functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_root_major_vers</span>(mount_t mp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_getxattr</span>(cnode_t *, <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cprotect **);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_entry_dealloc</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cprotect *entry);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_restore_keys</span>(<span class="enscript-type">struct</span> cprotect *, <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_lock_vfs_callback</span>(mount_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_lock_vnode_callback</span>(vnode_t, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_vnode_is_eligible</span> (vnode_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_check_access</span> (cnode_t *cp, <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> vnop);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_unwrap</span>(<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">struct</span> cprotect *, <span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_init_access</span>(cp_cred_t access, <span class="enscript-type">struct</span> cnode *cp);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CP_ASSERT</span>(x)		\
	<span class="enscript-keyword">if</span> ((x) == 0) {			\
		panic(<span class="enscript-string">&quot;Content Protection: failed assertion in %s&quot;</span>, __FUNCTION__); 	\
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">CP_ASSERT</span>(x)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// -- cpx_t accessors --
</span>
size_t <span class="enscript-function-name">cpx_size</span>(size_t key_size)
{
	size_t size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cpx) + key_size;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	size += 4; <span class="enscript-comment">// Extra for magic
</span>#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> size;
}

<span class="enscript-type">static</span> size_t <span class="enscript-function-name">cpx_sizex</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> cpx_size(cpx-&gt;cpx_max_key_len);
}

cpx_t <span class="enscript-function-name">cpx_alloc</span>(size_t key_len)
{
	cpx_t cpx;

	MALLOC(cpx, cpx_t, cpx_size(key_len), M_TEMP, M_WAITOK);

	cpx_init(cpx, key_len);

	<span class="enscript-keyword">return</span> cpx;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t cpx_magic1 = 0x7b787063;		<span class="enscript-comment">// cpx{
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t cpx_magic2 = 0x7870637d;		<span class="enscript-comment">// }cpx
</span>#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_free</span>(cpx_t cpx)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	assert(cpx-&gt;cpx_magic1 == cpx_magic1);
	assert(*PTR_ADD(uint32_t *, cpx, cpx_sizex(cpx) - 4) == cpx_magic2);
#<span class="enscript-reference">endif</span>
	bzero(cpx-&gt;cpx_cached_key, cpx-&gt;cpx_max_key_len);
	FREE(cpx, M_TEMP);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_init</span>(cpx_t cpx, size_t key_len)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	cpx-&gt;cpx_magic1 = cpx_magic1;
	*PTR_ADD(uint32_t *, cpx, cpx_size(key_len) - 4) = cpx_magic2;
#<span class="enscript-reference">endif</span>
	cpx-&gt;cpx_flags = 0;
	cpx-&gt;cpx_key_len = 0;
	cpx-&gt;cpx_max_key_len = key_len;
}

bool <span class="enscript-function-name">cpx_is_sep_wrapped_key</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> ISSET(cpx-&gt;cpx_flags, CPX_SEP_WRAPPEDKEY);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_is_sep_wrapped_key</span>(<span class="enscript-type">struct</span> cpx *cpx, bool v)
{
	<span class="enscript-keyword">if</span> (v)
		SET(cpx-&gt;cpx_flags, CPX_SEP_WRAPPEDKEY);
	<span class="enscript-keyword">else</span>
		CLR(cpx-&gt;cpx_flags, CPX_SEP_WRAPPEDKEY);
}

bool <span class="enscript-function-name">cpx_use_offset_for_iv</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> ISSET(cpx-&gt;cpx_flags, CPX_USE_OFFSET_FOR_IV);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_use_offset_for_iv</span>(<span class="enscript-type">struct</span> cpx *cpx, bool v)
{
	<span class="enscript-keyword">if</span> (v)
		SET(cpx-&gt;cpx_flags, CPX_USE_OFFSET_FOR_IV);
	<span class="enscript-keyword">else</span>
		CLR(cpx-&gt;cpx_flags, CPX_USE_OFFSET_FOR_IV);
}

uint16_t <span class="enscript-function-name">cpx_max_key_len</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> cpx-&gt;cpx_max_key_len;
}

uint16_t <span class="enscript-function-name">cpx_key_len</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> cpx-&gt;cpx_key_len;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_key_len</span>(<span class="enscript-type">struct</span> cpx *cpx, uint16_t key_len)
{
	cpx-&gt;cpx_key_len = key_len;

	<span class="enscript-keyword">if</span> (ISSET(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_HFS)) {
		<span class="enscript-comment">/*
		 * We assume that if the key length is being modified, the key
		 * has changed.  As a result, un-set any bits related to the
		 * AES context, if needed. They should be re-generated
		 * on-demand.
		 */</span> 
		CLR(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_INITIALIZED | CPX_IV_AES_CTX_HFS);
	}
}

bool <span class="enscript-function-name">cpx_has_key</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> cpx-&gt;cpx_key_len &gt; 0;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wcast-qual&quot;</span>
<span class="enscript-type">void</span> *<span class="enscript-function-name">cpx_key</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-type">void</span> *)cpx-&gt;cpx_cached_key;
}
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_aes_iv_key</span>(<span class="enscript-type">struct</span> cpx *cpx, <span class="enscript-type">void</span> *iv_key)
{
	aes_encrypt_key128(iv_key, &amp;cpx-&gt;cpx_iv_aes_ctx);
	SET(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_INITIALIZED | CPX_USE_OFFSET_FOR_IV);
	CLR(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_HFS);
}

aes_encrypt_ctx *<span class="enscript-function-name">cpx_iv_aes_ctx</span>(<span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">if</span> (ISSET(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_INITIALIZED))
		<span class="enscript-keyword">return</span> &amp;cpx-&gt;cpx_iv_aes_ctx;
 
 	SHA1_CTX sha1ctxt;
	uint8_t digest[SHA_DIGEST_LENGTH]; <span class="enscript-comment">/* Kiv */</span>

	<span class="enscript-comment">/* First init the cp_cache_iv_key[] */</span>
	SHA1Init(&amp;sha1ctxt);
 
	<span class="enscript-comment">/*
	 * We can only use this when the keys are generated in the AP; As a result
	 * we only use the first 32 bytes of key length in the cache key 
	 */</span>
	SHA1Update(&amp;sha1ctxt, cpx-&gt;cpx_cached_key, cpx-&gt;cpx_key_len);
	SHA1Final(digest, &amp;sha1ctxt);

	cpx_set_aes_iv_key(cpx, digest);
	SET(cpx-&gt;cpx_flags, CPX_IV_AES_CTX_HFS);

	<span class="enscript-keyword">return</span> &amp;cpx-&gt;cpx_iv_aes_ctx;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cpx_flush</span>(cpx_t cpx)
{
	bzero(cpx-&gt;cpx_cached_key, cpx-&gt;cpx_max_key_len);
	bzero(&amp;cpx-&gt;cpx_iv_aes_ctx, <span class="enscript-keyword">sizeof</span>(cpx-&gt;cpx_iv_aes_ctx));
	cpx-&gt;cpx_flags = 0;
	cpx-&gt;cpx_key_len = 0;
}

<span class="enscript-type">static</span> bool <span class="enscript-function-name">cpx_can_copy</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *src, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *dst)
{
	<span class="enscript-keyword">return</span> src-&gt;cpx_key_len &lt;= dst-&gt;cpx_max_key_len;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_copy</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *src, cpx_t dst)
{
	uint16_t key_len = cpx_key_len(src);
	cpx_set_key_len(dst, key_len);
	memcpy(cpx_key(dst), cpx_key(src), key_len);
	dst-&gt;cpx_flags = src-&gt;cpx_flags;
	<span class="enscript-keyword">if</span> (ISSET(dst-&gt;cpx_flags, CPX_IV_AES_CTX_INITIALIZED))
		dst-&gt;cpx_iv_aes_ctx = src-&gt;cpx_iv_aes_ctx;
}

<span class="enscript-comment">// -- cp_key_pair accessors --
</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_init</span>(cp_key_pair_t *cpkp, uint16_t max_pers_key_len,
			   uint16_t max_cached_key_len)
{
	cpkp-&gt;cpkp_max_pers_key_len = max_pers_key_len;
	cpkp-&gt;cpkp_pers_key_len = 0;
	cpx_init(&amp;cpkp-&gt;cpkp_cpx, max_cached_key_len);

	<span class="enscript-comment">// Default to using offsets
</span>	cpx_set_use_offset_for_iv(&amp;cpkp-&gt;cpkp_cpx, true);
}

uint16_t <span class="enscript-function-name">cpkp_max_pers_key_len</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-keyword">return</span> cpkp-&gt;cpkp_max_pers_key_len;
}

uint16_t <span class="enscript-function-name">cpkp_pers_key_len</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-keyword">return</span> cpkp-&gt;cpkp_pers_key_len;
}

<span class="enscript-type">static</span> bool <span class="enscript-function-name">cpkp_has_pers_key</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-keyword">return</span> cpkp-&gt;cpkp_pers_key_len &gt; 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">cpkp_pers_key</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-keyword">return</span> PTR_ADD(<span class="enscript-type">void</span> *, &amp;cpkp-&gt;cpkp_cpx, cpx_sizex(&amp;cpkp-&gt;cpkp_cpx));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_set_pers_key_len</span>(cp_key_pair_t *cpkp, uint16_t key_len)
{
	<span class="enscript-keyword">if</span> (key_len &gt; cpkp-&gt;cpkp_max_pers_key_len)
		panic(<span class="enscript-string">&quot;hfs_cprotect: key too big!&quot;</span>);
	cpkp-&gt;cpkp_pers_key_len = key_len;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wcast-qual&quot;</span>
cpx_t <span class="enscript-function-name">cpkp_cpx</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-comment">// Cast to remove const qualifier
</span>	<span class="enscript-keyword">return</span> (cpx_t)&amp;cpkp-&gt;cpkp_cpx;
}
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>

size_t <span class="enscript-function-name">cpkp_size</span>(uint16_t pers_key_len, uint16_t cached_key_len)
{
	<span class="enscript-keyword">return</span> (<span class="enscript-keyword">sizeof</span>(cp_key_pair_t) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cpx)
			+ pers_key_len + cpx_size(cached_key_len));
}

size_t <span class="enscript-function-name">cpkp_sizex</span>(<span class="enscript-type">const</span> cp_key_pair_t *cpkp)
{
	<span class="enscript-keyword">return</span> cpkp_size(cpkp-&gt;cpkp_max_pers_key_len, cpkp-&gt;cpkp_cpx.cpx_max_key_len);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_flush</span>(cp_key_pair_t *cpkp)
{
	cpx_flush(&amp;cpkp-&gt;cpkp_cpx);
	cpkp-&gt;cpkp_pers_key_len = 0;
	bzero(cpkp_pers_key(cpkp), cpkp-&gt;cpkp_max_pers_key_len);
}

bool <span class="enscript-function-name">cpkp_can_copy</span>(<span class="enscript-type">const</span> cp_key_pair_t *src, <span class="enscript-type">const</span> cp_key_pair_t *dst)
{
	<span class="enscript-keyword">return</span> (cpkp_pers_key_len(src) &lt;= dst-&gt;cpkp_max_pers_key_len
			&amp;&amp; cpx_can_copy(&amp;src-&gt;cpkp_cpx, &amp;dst-&gt;cpkp_cpx));
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpkp_copy</span>(<span class="enscript-type">const</span> cp_key_pair_t *src, cp_key_pair_t *dst)
{
	<span class="enscript-type">const</span> uint16_t key_len = cpkp_pers_key_len(src);
	cpkp_set_pers_key_len(dst, key_len);
	memcpy(cpkp_pers_key(dst), cpkp_pers_key(src), key_len);
	cpx_copy(&amp;src-&gt;cpkp_cpx, &amp;dst-&gt;cpkp_cpx);
}

<span class="enscript-comment">// --
</span>
bool <span class="enscript-function-name">cp_is_supported_version</span>(uint16_t vers)
{
	<span class="enscript-keyword">return</span> vers == CP_VERS_4 || vers == CP_VERS_5;
}

<span class="enscript-comment">/*
 * Return the appropriate key and, if requested, the physical offset and
 * maximum length for a particular I/O operation.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">cp_io_params</span>(__unused hfsmount_t *hfsmp, cprotect_t cpr,
				  __unused off_rsrc_t off_rsrc,
				  __unused <span class="enscript-type">int</span> direction, cp_io_params_t *io_params)
{

	io_params-&gt;max_len = INT64_MAX;
	io_params-&gt;phys_offset = -1;
	io_params-&gt;cpx = cpkp_cpx(&amp;cpr-&gt;cp_keys);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_flush_cached_keys</span>(cprotect_t cpr)
{
	cpx_flush(cpkp_cpx(&amp;cpr-&gt;cp_keys));
}

<span class="enscript-type">static</span> bool <span class="enscript-function-name">cp_needs_pers_key</span>(cprotect_t cpr)
{
	<span class="enscript-keyword">if</span> (CP_CLASS(cpr-&gt;cp_pclass) == PROTECTION_CLASS_F)
		<span class="enscript-keyword">return</span> !cpx_has_key(cpkp_cpx(&amp;cpr-&gt;cp_keys));
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> !cpkp_has_pers_key(&amp;cpr-&gt;cp_keys);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_key_store_action</span>(<span class="enscript-type">int</span> action)
{

	<span class="enscript-keyword">if</span> (action &lt; 0 || action &gt; CP_MAX_STATE) {
		<span class="enscript-keyword">return</span> -1;
	}
	
	<span class="enscript-comment">/* 
	 * The lock state is kept locally to each data protected filesystem to 
	 * avoid using globals.  Pass along the lock request to each filesystem
	 * we iterate through.
	 */</span>

	<span class="enscript-comment">/*
	 * Upcast the value in 'action' to be a pointer-width unsigned integer.
	 * This avoids issues relating to pointer-width. 
	 */</span>
	<span class="enscript-keyword">return</span> vfs_iterate(0, cp_lock_vfs_callback, (<span class="enscript-type">void</span>*)(uintptr_t)action);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_register_wraps</span>(cp_wrap_func_t key_store_func)
{
	g_cp_wrap_func.new_key = key_store_func-&gt;new_key;
	g_cp_wrap_func.unwrapper = key_store_func-&gt;unwrapper;
	g_cp_wrap_func.rewrapper = key_store_func-&gt;rewrapper;
	<span class="enscript-comment">/* do not use invalidater until rdar://12170050 goes in ! */</span>
	g_cp_wrap_func.invalidater = key_store_func-&gt;invalidater;
	g_cp_wrap_func.backup_key = key_store_func-&gt;backup_key;

	<span class="enscript-comment">/* Mark the functions as initialized in the function pointer container */</span>
	are_wraps_initialized = true;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> cp_key_revision_t <span class="enscript-function-name">cp_initial_key_revision</span>(__unused hfsmount_t *hfsmp)
{
	<span class="enscript-keyword">return</span> 1;
}

cp_key_revision_t <span class="enscript-function-name">cp_next_key_revision</span>(cp_key_revision_t rev)
{
	rev = (rev + 0x0100) ^ (mach_absolute_time() &amp; 0xff);
	<span class="enscript-keyword">if</span> (!rev)
		rev = 1;
	<span class="enscript-keyword">return</span> rev;
}

<span class="enscript-comment">/*
 * Allocate and initialize a cprotect blob for a new cnode.
 * Called from hfs_getnewvnode: cnode is locked exclusive.
 * 
 * Read xattr data off the cnode. Then, if conditions permit,
 * unwrap the file key and cache it in the cprotect blob.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_entry_init</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> mount *mp)
{
	<span class="enscript-type">struct</span> cprotect *entry = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VFSTOHFS(mp);

	<span class="enscript-comment">/*
	 * The cnode should be locked at this point, regardless of whether or not
	 * we are creating a new item in the namespace or vending a vnode on behalf
	 * of lookup.  The only time we tell getnewvnode to skip the lock is when 
	 * constructing a resource fork vnode. But a resource fork vnode must come
	 * after the regular data fork cnode has already been constructed.
	 */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected (mp)) {
		cp-&gt;c_cpentry = NULL;
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (!S_ISREG(cp-&gt;c_mode) &amp;&amp; !S_ISDIR(cp-&gt;c_mode)) {
		cp-&gt;c_cpentry = NULL;
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (are_wraps_initialized == false)  {
		printf(<span class="enscript-string">&quot;hfs: cp_update_entry: wrap functions not yet set\n&quot;</span>);
		<span class="enscript-keyword">return</span> ENXIO;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_running_cp_major_vers == 0) {
		panic (<span class="enscript-string">&quot;hfs cp: no running mount point version! &quot;</span>);		
	}

	CP_ASSERT (cp-&gt;c_cpentry == NULL);

	error = cp_getxattr(cp, hfsmp, &amp;entry);
	<span class="enscript-keyword">if</span> (error == ENOATTR) {
		<span class="enscript-comment">/*
		 * Normally, we should always have a CP EA for a file or directory that
		 * we are initializing here. However, there are some extenuating circumstances,
		 * such as the root directory immediately following a newfs_hfs.
		 *
		 * As a result, we leave code here to deal with an ENOATTR which will always
		 * default to a 'D/NONE' key, though we don't expect to use it much.
		 */</span>
		cp_key_class_t target_class = PROTECTION_CLASS_D;

		<span class="enscript-keyword">if</span> (S_ISDIR(cp-&gt;c_mode)) {
			target_class = PROTECTION_CLASS_DIR_NONE;
		}

		cp_key_revision_t key_revision = cp_initial_key_revision(hfsmp);

		<span class="enscript-comment">/* allow keybag to override our class preferences */</span>
		error = cp_new (&amp;target_class, hfsmp, cp, cp-&gt;c_mode, CP_KEYWRAP_DIFFCLASS,
						key_revision, (cp_new_alloc_fn)cp_entry_alloc, (<span class="enscript-type">void</span> **)&amp;entry);
		<span class="enscript-keyword">if</span> (error == 0) {
			entry-&gt;cp_pclass = target_class;
			entry-&gt;cp_key_os_version = cp_os_version();
			entry-&gt;cp_key_revision = key_revision;
			error = cp_setxattr (cp, entry, hfsmp, cp-&gt;c_fileid, XATTR_CREATE);
		}
	}

	<span class="enscript-comment">/* 
	 * Bail out if:
	 * a) error was not ENOATTR (we got something bad from the getxattr call)
	 * b) we encountered an error setting the xattr above.
	 * c) we failed to generate a new cprotect data structure.
	 */</span>
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}	

	cp-&gt;c_cpentry = entry;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error == 0) {
		entry-&gt;cp_backing_cnode = cp;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (entry) {
			cp_entry_destroy(hfsmp, entry);
		}
		cp-&gt;c_cpentry = NULL;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * cp_setup_newentry
 * 
 * Generate a keyless cprotect structure for use with the new AppleKeyStore kext.
 * Since the kext is now responsible for vending us both wrapped/unwrapped keys
 * we need to create a keyless xattr upon file / directory creation. When we have the inode value
 * and the file/directory is established, then we can ask it to generate keys.  Note that
 * this introduces a potential race;  If the device is locked and the wrapping
 * keys are purged between the time we call this function and the time we ask it to generate
 * keys for us, we could have to fail the open(2) call and back out the entry.
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_setup_newentry</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *dcp,
					   cp_key_class_t suppliedclass, mode_t cmode,
					   <span class="enscript-type">struct</span> cprotect **tmpentry)
{
	<span class="enscript-type">int</span> isdir = 0;
	<span class="enscript-type">struct</span> cprotect *entry = NULL;
	uint32_t target_class = hfsmp-&gt;default_cp_class;
	suppliedclass = CP_CLASS(suppliedclass);

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_running_cp_major_vers == 0) {
		panic (<span class="enscript-string">&quot;CP: major vers not set in mount!&quot;</span>);
	}
	
	<span class="enscript-keyword">if</span> (S_ISDIR (cmode))  {
		isdir = 1;
	}

	<span class="enscript-comment">/* Decide the target class.  Input argument takes priority. */</span>
	<span class="enscript-keyword">if</span> (cp_is_valid_class (isdir, suppliedclass)) {
		<span class="enscript-comment">/* caller supplies -1 if it was not specified so we will default to the mount point value */</span>
		target_class = suppliedclass;
		<span class="enscript-comment">/*
		 * One exception, F is never valid for a directory
		 * because its children may inherit and userland will be
		 * unable to read/write to the files.
		 */</span>
		<span class="enscript-keyword">if</span> (isdir) {
			<span class="enscript-keyword">if</span> (target_class == PROTECTION_CLASS_F) {
				*tmpentry = NULL;
				<span class="enscript-keyword">return</span> EINVAL;
			}
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 
		 * If no valid class was supplied, behave differently depending on whether or not
		 * the item being created is a file or directory.
		 * 
		 * for FILE:
		 * 		If parent directory has a non-zero class, use that.
		 * 		If parent directory has a zero class (not set), then attempt to
		 *		apply the mount point default.
		 * 
		 * for DIRECTORY:
		 *		Directories always inherit from the parent; if the parent
		 * 		has a NONE class set, then we can continue to use that.
		 */</span>
		<span class="enscript-keyword">if</span> ((dcp) &amp;&amp; (dcp-&gt;c_cpentry)) {
			uint32_t parentclass = CP_CLASS(dcp-&gt;c_cpentry-&gt;cp_pclass);
			<span class="enscript-comment">/* If the parent class is not valid, default to the mount point value */</span>
			<span class="enscript-keyword">if</span> (cp_is_valid_class(1, parentclass)) {
				<span class="enscript-keyword">if</span> (isdir) {
					target_class = parentclass;	
				}
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parentclass != PROTECTION_CLASS_DIR_NONE) {
					<span class="enscript-comment">/* files can inherit so long as it's not NONE */</span>
					target_class = parentclass;
				}
			}
			<span class="enscript-comment">/* Otherwise, we already defaulted to the mount point's default */</span>
		}
	}

	<span class="enscript-comment">/* Generate the cprotect to vend out */</span>
	entry = cp_entry_alloc(NULL, 0, 0, NULL);
	<span class="enscript-keyword">if</span> (entry == NULL) {
		*tmpentry = NULL;
		<span class="enscript-keyword">return</span> ENOMEM;
	}	

	<span class="enscript-comment">/* 
	 * We don't have keys yet, so fill in what we can.  At this point
	 * this blob has no keys and it has no backing xattr.  We just know the
	 * target class.
	 */</span>
	entry-&gt;cp_flags = CP_NO_XATTR;
	<span class="enscript-comment">/* Note this is only the effective class */</span>
	entry-&gt;cp_pclass = target_class;
	*tmpentry = entry;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Set up an initial key/class pair for a disassociated cprotect entry.
 * This function is used to generate transient keys that will never be
 * written to disk.  We use class F for this since it provides the exact
 * semantics that are needed here.  Because we never attach this blob to
 * a cnode directly, we take a pointer to the cprotect struct.
 *
 * This function is primarily used in the HFS FS truncation codepath
 * where we may rely on AES symmetry to relocate encrypted data from
 * one spot in the disk to another.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cpx_gentempkeys</span>(cpx_t *pcpx, __unused <span class="enscript-type">struct</span> hfsmount *hfsmp)
{
	cpx_t cpx = cpx_alloc(CP_MAX_KEYSIZE);

	cpx_set_key_len(cpx, CP_MAX_KEYSIZE);
	read_random(cpx_key(cpx), CP_MAX_KEYSIZE);
	cpx_set_use_offset_for_iv(cpx, true);

	*pcpx = cpx;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Tear down and clear a cprotect blob for a closing file.
 * Called at hfs_reclaim_cnode: cnode is locked exclusive.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cp_entry_destroy</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cprotect *entry_ptr)
{
	<span class="enscript-keyword">if</span> (entry_ptr == NULL) {
		<span class="enscript-comment">/* nothing to clean up */</span>
		<span class="enscript-keyword">return</span>;
	}
	cp_entry_dealloc(hfsmp, entry_ptr);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_fs_protected</span> (mount_t mnt) 
{
	<span class="enscript-keyword">return</span> (vfs_flags(mnt) &amp; MNT_CPROTECT);
}


<span class="enscript-comment">/*
 * Return a pointer to underlying cnode if there is one for this vnode.
 * Done without taking cnode lock, inspecting only vnode state.
 */</span>
<span class="enscript-type">struct</span> cnode *
<span class="enscript-function-name">cp_get_protected_cnode</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-keyword">if</span> (!cp_vnode_is_eligible(vp)) {
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-keyword">if</span> (!cp_fs_protected(VTOVFS(vp))) {
		<span class="enscript-comment">/* mount point doesn't support it */</span>
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> cnode*) vp-&gt;v_data;
}


<span class="enscript-comment">/*
 * Sets *class to persistent class associated with vnode,
 * or returns error.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_vnode_getclass</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *class)
{
	<span class="enscript-type">struct</span> cprotect *entry;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">int</span> took_truncate_lock = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;

	<span class="enscript-comment">/* Is this an interesting vp? */</span>
	<span class="enscript-keyword">if</span> (!cp_vnode_is_eligible (vp)) {
		<span class="enscript-keyword">return</span> EBADF;
	}

	<span class="enscript-comment">/* Is the mount point formatted for content protection? */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected(VTOVFS(vp))) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	cp = VTOC(vp);
	hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/*
	 * Take the truncate lock up-front in shared mode because we may need
	 * to manipulate the CP blob. Pend lock events until we're done here.
	 */</span>
	hfs_lock_truncate (cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	took_truncate_lock = 1;

	<span class="enscript-comment">/*
	 * We take only the shared cnode lock up-front.  If it turns out that
	 * we need to manipulate the CP blob to write a key out, drop the
	 * shared cnode lock and acquire an exclusive lock.
	 */</span>
	error = hfs_lock(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (error) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* pull the class from the live entry */</span>
	entry = cp-&gt;c_cpentry;

	<span class="enscript-keyword">if</span> (entry == NULL) {
		panic(<span class="enscript-string">&quot;Content Protection: uninitialized cnode %p&quot;</span>, cp);
	}
	
	<span class="enscript-comment">/* Note that we may not have keys yet, but we know the target class. */</span>

	<span class="enscript-keyword">if</span> (error == 0) {
		*class = CP_CLASS(entry-&gt;cp_pclass);
	}

	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}

	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Sets persistent class for this file or directory.
 * If vnode cannot be protected (system file, non-regular file, non-hfs), EBADF.
 * If the new class can't be accessed now, EPERM.
 * Otherwise, record class and re-wrap key if the mount point is content-protected.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_vnode_setclass</span>(<span class="enscript-type">struct</span> vnode *vp, uint32_t newclass)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cprotect *entry = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> took_truncate_lock = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;
	<span class="enscript-type">int</span> isdir = 0;

	<span class="enscript-keyword">if</span> (vnode_isdir (vp)) {
		isdir = 1;
	}

	<span class="enscript-comment">/* Ensure we only use the effective class here */</span>
	newclass = CP_CLASS(newclass);

	<span class="enscript-keyword">if</span> (!cp_is_valid_class(isdir, newclass)) {
		printf(<span class="enscript-string">&quot;hfs: CP: cp_setclass called with invalid class %d\n&quot;</span>, newclass);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* Is this an interesting vp? */</span>
	<span class="enscript-keyword">if</span> (!cp_vnode_is_eligible(vp)) {
		<span class="enscript-keyword">return</span> EBADF;
	}

	<span class="enscript-comment">/* Is the mount point formatted for content protection? */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected(VTOVFS(vp))) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	hfsmp = VTOHFS(vp);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		<span class="enscript-keyword">return</span> EROFS;
	}

	<span class="enscript-comment">/*
	 * Take the cnode truncate lock exclusive because we want to manipulate the
	 * CP blob. The lock-event handling code is doing the same.  This also forces
	 * all pending IOs to drain before we can re-write the persistent and cache keys.
	 */</span>
	cp = VTOC(vp);
	hfs_lock_truncate (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	took_truncate_lock = 1;

	<span class="enscript-comment">/*
	 * The truncate lock is not sufficient to guarantee the CP blob
	 * isn't being used.  We must wait for existing writes to finish.
	 */</span>
	vnode_waitforwrites(vp, 0, 0, 0, <span class="enscript-string">&quot;cp_vnode_setclass&quot;</span>);

	<span class="enscript-keyword">if</span> (hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	entry = cp-&gt;c_cpentry;
	<span class="enscript-keyword">if</span> (entry == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* 
	 * re-wrap per-file key with new class.  
	 * Generate an entirely new key if switching to F. 
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isreg(vp)) {
		<span class="enscript-comment">/*
		 * The vnode is a file.  Before proceeding with the re-wrap, we need
		 * to unwrap the keys before proceeding.  This is to ensure that 
		 * the destination class's properties still work appropriately for the
		 * target class (since B allows I/O but an unwrap prior to the next unlock
		 * will not be allowed).
		 */</span>
		<span class="enscript-keyword">if</span> (!cpx_has_key(&amp;entry-&gt;cp_keys.cpkp_cpx)) {
			error = cp_restore_keys (entry, hfsmp, cp);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-keyword">if</span> (newclass == PROTECTION_CLASS_F) {
			<span class="enscript-comment">/* Verify that file is blockless if switching to class F */</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_datafork-&gt;ff_size &gt; 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			cp_key_pair_t *cpkp;
			cprotect_t new_entry = cp_entry_alloc(NULL, 0, CP_MAX_KEYSIZE, &amp;cpkp);

			<span class="enscript-keyword">if</span> (!new_entry) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* newclass is only the effective class */</span>
			new_entry-&gt;cp_pclass = newclass;
			new_entry-&gt;cp_key_os_version = cp_os_version();
			new_entry-&gt;cp_key_revision = cp_next_key_revision(entry-&gt;cp_key_revision);

			cpx_t cpx = cpkp_cpx(cpkp);

			<span class="enscript-comment">/* Class F files are not wrapped, so they continue to use MAX_KEYSIZE */</span>
			cpx_set_key_len(cpx, CP_MAX_KEYSIZE);
			read_random (cpx_key(cpx), CP_MAX_KEYSIZE);

			cp_replace_entry(hfsmp, cp, new_entry);

			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* Deny the setclass if file is to be moved from F to something else */</span>
		<span class="enscript-keyword">if</span> (entry-&gt;cp_pclass == PROTECTION_CLASS_F) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (!cpkp_has_pers_key(&amp;entry-&gt;cp_keys)) {
			<span class="enscript-type">struct</span> cprotect *new_entry = NULL;
			<span class="enscript-comment">/*
			 * We want to fail if we can't wrap to the target class. By not setting
			 * CP_KEYWRAP_DIFFCLASS, we tell keygeneration that if it can't wrap
			 * to 'newclass' then error out.
			 */</span>
			uint32_t flags = 0;
			error = cp_generate_keys (hfsmp, cp, newclass, flags,  &amp;new_entry);
			<span class="enscript-keyword">if</span> (error == 0) {
				cp_replace_entry (hfsmp, cp, new_entry);
			}
			<span class="enscript-comment">/* Bypass the setxattr code below since generate_keys does it for us */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		cprotect_t new_entry;
		error = cp_rewrap(cp, hfsmp, &amp;newclass, &amp;entry-&gt;cp_keys, entry,
						  (cp_new_alloc_fn)cp_entry_alloc, (<span class="enscript-type">void</span> **)&amp;new_entry);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* we didn't have perms to set this class. leave file as-is and error out */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}


		new_entry-&gt;cp_pclass = newclass;

		cp_replace_entry(hfsmp, cp, new_entry);
		entry = new_entry;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-comment">/* For directories, just update the pclass.  newclass is only effective class */</span>
		entry-&gt;cp_pclass = newclass;
		error = 0;	
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* anything else, just error out */</span>
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;	
	}
	
	<span class="enscript-comment">/* 
	 * We get here if the new class was F, or if we were re-wrapping a cprotect that already
	 * existed. If the keys were never generated, then they'll skip the setxattr calls.
	 */</span>

	error = cp_setxattr(cp, cp-&gt;c_cpentry, VTOHFS(vp), 0, XATTR_REPLACE);
	<span class="enscript-keyword">if</span> (error == ENOATTR) {
		error = cp_setxattr(cp, cp-&gt;c_cpentry, VTOHFS(vp), 0, XATTR_CREATE);
	}

<span class="enscript-reference">out</span>:

	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);
	}
	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">int</span> <span class="enscript-function-name">cp_vnode_transcode</span>(vnode_t vp, <span class="enscript-type">void</span> *key, <span class="enscript-type">unsigned</span> *len)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> cprotect *entry = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> took_truncate_lock = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;

	<span class="enscript-comment">/* Structures passed between HFS and AKS */</span>
	cp_cred_s access_in;
	cp_wrapped_key_s wrapped_key_in, wrapped_key_out;

	<span class="enscript-comment">/* Is this an interesting vp? */</span>
	<span class="enscript-keyword">if</span> (!cp_vnode_is_eligible(vp)) {
		<span class="enscript-keyword">return</span> EBADF;
	}

	<span class="enscript-comment">/* Is the mount point formatted for content protection? */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected(VTOVFS(vp))) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	cp = VTOC(vp);
	hfsmp = VTOHFS(vp);

	<span class="enscript-comment">/*
	 * Take the cnode truncate lock exclusive because we want to manipulate the
	 * CP blob. The lock-event handling code is doing the same.  This also forces
	 * all pending IOs to drain before we can re-write the persistent and cache keys.
	 */</span>
	hfs_lock_truncate (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	took_truncate_lock = 1;

	<span class="enscript-keyword">if</span> (hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	entry = cp-&gt;c_cpentry;
	<span class="enscript-keyword">if</span> (entry == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Send the per-file key in wrapped form for re-wrap with the current class information
	 * Send NULLs in the output parameters of the wrapper() and AKS will do the rest.
	 * Don't need to process any outputs, so just clear the locks and pass along the error. */</span>
	<span class="enscript-keyword">if</span> (vnode_isreg(vp)) {

		<span class="enscript-comment">/* Picked up the following from cp_wrap().
		 * If needed, more comments available there. */</span>

		<span class="enscript-keyword">if</span> (CP_CLASS(entry-&gt;cp_pclass) == PROTECTION_CLASS_F) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		cp_init_access(&amp;access_in, cp);

		bzero(&amp;wrapped_key_in, <span class="enscript-keyword">sizeof</span>(wrapped_key_in));
		bzero(&amp;wrapped_key_out, <span class="enscript-keyword">sizeof</span>(wrapped_key_out));

		cp_key_pair_t *cpkp = &amp;entry-&gt;cp_keys;


		wrapped_key_in.key = cpkp_pers_key(cpkp);
		wrapped_key_in.key_len = cpkp_pers_key_len(cpkp);

		<span class="enscript-keyword">if</span> (!wrapped_key_in.key_len) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* Use the actual persistent class when talking to AKS */</span>
		wrapped_key_in.dp_class = entry-&gt;cp_pclass;
		wrapped_key_out.key = key;
		wrapped_key_out.key_len = *len;

		error = g_cp_wrap_func.backup_key(&amp;access_in,
						&amp;wrapped_key_in,
						&amp;wrapped_key_out);

		<span class="enscript-keyword">if</span>(error)
			error = EPERM;
		<span class="enscript-keyword">else</span>
			*len = wrapped_key_out.key_len;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);
	}
	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Check permission for the given operation (read, write) on this node.
 * Additionally, if the node needs work, do it:
 * - create a new key for the file if one hasn't been set before
 * - write out the xattr if it hasn't already been saved
 * - unwrap the key if needed
 *
 * Takes cnode lock, and upgrades to exclusive if modifying cprotect.
 *
 * Note that this function does *NOT* take the cnode truncate lock.  This is because
 * the thread calling us may already have the truncate lock.  It is not necessary
 * because either we successfully finish this function before the keys are tossed
 * and the IO will fail, or the keys are tossed and then this function will fail.
 * Either way, the cnode lock still ultimately guards the keys.  We only rely on the
 * truncate lock to protect us against tossing the keys as a cluster call is in-flight.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_handle_vnop</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> vnop, <span class="enscript-type">int</span> ioflag)
{
	<span class="enscript-type">struct</span> cprotect *entry;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;
	<span class="enscript-type">struct</span> cnode *cp = NULL;

	<span class="enscript-comment">/*
	 * First, do validation against the vnode before proceeding any further:
	 * Is this vnode originating from a valid content-protected filesystem ?
	 */</span>
	<span class="enscript-keyword">if</span> (cp_vnode_is_eligible(vp) == 0) {
		<span class="enscript-comment">/*
		 * It is either not HFS or not a file/dir.  Just return success. This is a valid
		 * case if servicing i/o against another filesystem type from VFS
		 */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (cp_fs_protected (VTOVFS(vp)) == 0) {
		<span class="enscript-comment">/*
		 * The underlying filesystem does not support content protection.  This is also
		 * a valid case.  Simply return success.
		 */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * At this point, we know we have a HFS vnode that backs a file or directory on a
	 * filesystem that supports content protection
	 */</span>
	cp = VTOC(vp);

	<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">return</span> error;
	}

	entry = cp-&gt;c_cpentry;

	<span class="enscript-keyword">if</span> (entry == NULL) {
		<span class="enscript-comment">/*
		 * If this cnode is not content protected, simply return success.
		 * Note that this function is called by all I/O-based call sites
		 * when CONFIG_PROTECT is enabled during XNU building.
		 */</span>

		<span class="enscript-comment">/* 
		 * All files should have cprotect structs.  It's possible to encounter
		 * a directory from a V2.0 CP system but all files should have protection
		 * EAs
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isreg(vp)) {
			error = EPERM;
		}

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	vp = CTOV(cp, 0);
	<span class="enscript-keyword">if</span> (vp == NULL) {
		<span class="enscript-comment">/* is it a rsrc */</span>
		vp = CTOV(cp,1);
		<span class="enscript-keyword">if</span> (vp == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> ((error = cp_check_access(cp, hfsmp, vnop))) {
		<span class="enscript-comment">/* check for raw encrypted access before bailing out */</span>
		<span class="enscript-keyword">if</span> ((ioflag &amp; IO_ENCRYPTED)
			&amp;&amp; (vnop == CP_READ_ACCESS)) {
			<span class="enscript-comment">/*
			 * read access only + asking for the raw encrypted bytes
			 * is legitimate, so reset the error value to 0
			 */</span>
			error = 0;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!ISSET(entry-&gt;cp_flags, CP_NO_XATTR)) {
		<span class="enscript-keyword">if</span> (!S_ISREG(cp-&gt;c_mode))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-comment">// If we have a persistent key and the cached key, we're done
</span>		<span class="enscript-keyword">if</span> (!cp_needs_pers_key(entry)
			&amp;&amp; cpx_has_key(cpkp_cpx(&amp;entry-&gt;cp_keys))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* upgrade to exclusive lock */</span>
	<span class="enscript-keyword">if</span> (lck_rw_lock_shared_to_exclusive(&amp;cp-&gt;c_rwlock) == FALSE) {
		<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
			<span class="enscript-keyword">return</span> error;
		}
	} <span class="enscript-keyword">else</span> {
		cp-&gt;c_lockowner = current_thread();
	}

	<span class="enscript-comment">/* generate new keys if none have ever been saved */</span>
	<span class="enscript-keyword">if</span> (cp_needs_pers_key(entry)) {
		<span class="enscript-type">struct</span> cprotect *newentry = NULL;
		<span class="enscript-comment">/* 
		 * It's ok if this ends up being wrapped in a different class than 'pclass'.
		 * class modification is OK here. 
		 */</span>		
		uint32_t flags = CP_KEYWRAP_DIFFCLASS;

		error = cp_generate_keys (hfsmp, cp, CP_CLASS(cp-&gt;c_cpentry-&gt;cp_pclass), flags, &amp;newentry);	
		<span class="enscript-keyword">if</span> (error == 0) {
			cp_replace_entry (hfsmp, cp, newentry);
			entry = newentry;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* unwrap keys if needed */</span>
	<span class="enscript-keyword">if</span> (!cpx_has_key(cpkp_cpx(&amp;entry-&gt;cp_keys))) {
		<span class="enscript-keyword">if</span> ((vnop == CP_READ_ACCESS) &amp;&amp; (ioflag &amp; IO_ENCRYPTED)) {
			<span class="enscript-comment">/* no need to try to restore keys; they are not going to be used */</span>
			error = 0;
		}
		<span class="enscript-keyword">else</span> {
			error = cp_restore_keys(entry, hfsmp, cp);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	}

	<span class="enscript-comment">/* write out the xattr if it's new */</span>
	<span class="enscript-keyword">if</span> (entry-&gt;cp_flags &amp; CP_NO_XATTR)
		error = cp_setxattr(cp, entry, VTOHFS(cp-&gt;c_vp), 0, XATTR_CREATE);

<span class="enscript-reference">out</span>:

	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_TMPDBG</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_log_eperm</span> (<span class="enscript-type">struct</span> vnode* vp, <span class="enscript-type">int</span> pclass, boolean_t create) {
	<span class="enscript-type">char</span> procname[256] = {};
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fname = <span class="enscript-string">&quot;unknown&quot;</span>;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *dbgop = <span class="enscript-string">&quot;open&quot;</span>;

	<span class="enscript-type">int</span> ppid = proc_selfpid();
	<span class="enscript-comment">/* selfname does a strlcpy so we're OK */</span>
	proc_selfname(procname, <span class="enscript-keyword">sizeof</span>(procname));
	<span class="enscript-keyword">if</span> (vp &amp;&amp; vp-&gt;v_name) {
		<span class="enscript-comment">/* steal from the namecache */</span>
		fname = vp-&gt;v_name;
	}

	<span class="enscript-keyword">if</span> (create) {
		dbgop = <span class="enscript-string">&quot;create&quot;</span>;	
	}
	
	printf(<span class="enscript-string">&quot;proc %s (pid %d) class %d, op: %s failure @ file %s\n&quot;</span>, procname, ppid, pclass, dbgop, fname);
}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_handle_open</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> mode)
{
	<span class="enscript-type">struct</span> cnode *cp = NULL ;
	<span class="enscript-type">struct</span> cprotect *entry = NULL;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* If vnode not eligible, just return success */</span>
	<span class="enscript-keyword">if</span> (!cp_vnode_is_eligible(vp)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* If mount point not properly set up, then also return success */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected(VTOVFS(vp))) {
		<span class="enscript-keyword">return</span> 0;
	}

	cp = VTOC(vp);

	<span class="enscript-comment">// Allow if raw encrypted mode requested
</span>	<span class="enscript-keyword">if</span> (ISSET(mode, FENCRYPTED)) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (ISSET(mode, FUNENCRYPTED)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* We know the vnode is in a valid state. Acquire cnode and validate */</span>
	hfsmp = VTOHFS(vp);

	<span class="enscript-keyword">if</span> ((error = hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">return</span> error;
	}

	entry = cp-&gt;c_cpentry;
	<span class="enscript-keyword">if</span> (entry == NULL) {
		<span class="enscript-comment">/* 
		 * If the mount is protected and we couldn't get a cprotect for this vnode,
		 * then it's not valid for opening.
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isreg(vp)) {
			error = EPERM;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (!S_ISREG(cp-&gt;c_mode))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Does the cnode have keys yet?  If not, then generate them.
	 */</span>
	<span class="enscript-keyword">if</span> (cp_needs_pers_key(entry)) {
		<span class="enscript-type">struct</span> cprotect *newentry = NULL;
		<span class="enscript-comment">/* Allow the keybag to override our class preferences */</span>
		uint32_t flags = CP_KEYWRAP_DIFFCLASS;
		error = cp_generate_keys (hfsmp, cp, CP_CLASS(cp-&gt;c_cpentry-&gt;cp_pclass), flags, &amp;newentry);
		<span class="enscript-keyword">if</span> (error == 0) {
			cp_replace_entry (hfsmp, cp, newentry);
			entry = newentry;
		}	
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}	

	<span class="enscript-comment">/*
	 * We want to minimize the number of unwraps that we'll have to do since 
	 * the cost can vary, depending on the platform we're running. 
	 */</span>
	<span class="enscript-keyword">switch</span> (CP_CLASS(entry-&gt;cp_pclass)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROTECTION_CLASS_B</span>:
			<span class="enscript-keyword">if</span> (mode &amp; O_CREAT) {
				<span class="enscript-comment">/* 
				 * Class B always allows creation.  Since O_CREAT was passed through
				 * we infer that this was a newly created vnode/cnode.  Even though a potential
				 * race exists when multiple threads attempt to create/open a particular
				 * file, only one can &quot;win&quot; and actually create it.  VFS will unset the
				 * O_CREAT bit on the loser.	 
				 * 
				 * Note that skipping the unwrap check here is not a security issue -- 
				 * we have to unwrap the key permanently upon the first I/O.
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (cpx_has_key(cpkp_cpx(&amp;entry-&gt;cp_keys)) &amp;&amp; !ISSET(mode, FENCRYPTED)) {
				<span class="enscript-comment">/*
				 * For a class B file, attempt the unwrap if we have the key in
				 * core already. 
				 * The device could have just transitioned into the lock state, and 
				 * this vnode may not yet have been purged from the vnode cache (which would
				 * remove the keys). 
				 */</span>
				cp_cred_s access_in;
				cp_wrapped_key_s wrapped_key_in;

				cp_init_access(&amp;access_in, cp);
				bzero(&amp;wrapped_key_in, <span class="enscript-keyword">sizeof</span>(wrapped_key_in));
				wrapped_key_in.key = cpkp_pers_key(&amp;entry-&gt;cp_keys);
				wrapped_key_in.key_len = cpkp_pers_key_len(&amp;entry-&gt;cp_keys);
				<span class="enscript-comment">/* Use the persistent class when talking to AKS */</span>
				wrapped_key_in.dp_class = entry-&gt;cp_pclass;
				error = g_cp_wrap_func.unwrapper(&amp;access_in, &amp;wrapped_key_in, NULL);
				<span class="enscript-keyword">if</span> (error) {
					error = EPERM;
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* otherwise, fall through to attempt the unwrap/restore */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROTECTION_CLASS_A</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROTECTION_CLASS_C</span>:
			<span class="enscript-comment">/*
			 * At this point, we know that we need to attempt an unwrap if needed; we want
			 * to makes sure that open(2) fails properly if the device is either just-locked
			 * or never made it past first unlock.  Since the keybag serializes access to the
			 * unwrapping keys for us and only calls our VFS callback once they've been purged, 
			 * we will get here in two cases:
			 * 
			 * A) we're in a window before the wrapping keys are purged; this is OK since when they get 
			 * purged, the vnode will get flushed if needed.
			 * 
			 * B) The keys are already gone.  In this case, the restore_keys call below will fail. 
			 *
			 * Since this function is bypassed entirely if we're opening a raw encrypted file, 
			 * we can always attempt the restore.
			 */</span>
			<span class="enscript-keyword">if</span> (!cpx_has_key(cpkp_cpx(&amp;entry-&gt;cp_keys))) {
				error = cp_restore_keys(entry, hfsmp, cp);
			}
	
			<span class="enscript-keyword">if</span> (error) {
				error = EPERM;
			}
	
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROTECTION_CLASS_D</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_TMPDBG</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_cp_verbose) &amp;&amp; (error == EPERM)) {
		cp_log_eperm (vp, CP_CLASS(entry-&gt;cp_pclass), false);
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

	hfs_unlock(cp);
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * cp_getrootxattr:
 * Gets the EA we set on the root folder (fileid 1) to get information about the
 * version of Content Protection that was used to write to this filesystem.
 * Note that all multi-byte fields are written to disk little endian so they must be
 * converted to native endian-ness as needed.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_getrootxattr</span>(<span class="enscript-type">struct</span> hfsmount* hfsmp, <span class="enscript-type">struct</span> cp_root_xattr *outxattr) 
{
	uio_t   auio;
	<span class="enscript-type">char</span>    uio_buf[UIO_SIZEOF(1)];
	<span class="enscript-type">void</span>	*buf;

	<span class="enscript-comment">/*
	 * We allow for an extra 64 bytes to cater for upgrades.  This wouldn't
	 * be necessary if the xattr routines just returned what we asked for.
	 */</span>
	size_t attrsize = roundup(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_root_xattr) + 64, 64);

	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> vnop_getxattr_args args;

	<span class="enscript-keyword">if</span> (!outxattr) {
		panic(<span class="enscript-string">&quot;Content Protection: cp_xattr called with xattr == NULL&quot;</span>);
	}

	MALLOC(buf, <span class="enscript-type">void</span> *, attrsize, M_TEMP, M_WAITOK);

	auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(buf), attrsize);

	args.a_desc = NULL; <span class="enscript-comment">// unused
</span>	args.a_vp = NULL; <span class="enscript-comment">//unused since we're writing EA to root folder.
</span>	args.a_name = CONTENT_PROTECTION_XATTR_NAME;
	args.a_uio = auio;
	args.a_size = &amp;attrsize;
	args.a_options = XATTR_REPLACE;
	args.a_context = NULL; <span class="enscript-comment">// unused
</span>
	error = hfs_getxattr_internal(NULL, &amp;args, hfsmp, 1);

	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (attrsize &lt; CP_ROOT_XATTR_MIN_LEN) {
		error = HFS_EINCONSISTENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cp_root_xattr *xattr = buf;

	bzero(outxattr, <span class="enscript-keyword">sizeof</span>(*outxattr));

	<span class="enscript-comment">/* Now convert the multi-byte fields to native endianness */</span>
	outxattr-&gt;major_version = OSSwapLittleToHostInt16(xattr-&gt;major_version);
	outxattr-&gt;minor_version = OSSwapLittleToHostInt16(xattr-&gt;minor_version);
	outxattr-&gt;flags = OSSwapLittleToHostInt64(xattr-&gt;flags);

	<span class="enscript-keyword">if</span> (outxattr-&gt;major_version &gt;= CP_VERS_5) {
		<span class="enscript-keyword">if</span> (attrsize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_root_xattr)) {
			error = HFS_EINCONSISTENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

<span class="enscript-reference">out</span>:
	uio_free(auio);
	FREE(buf, M_TEMP);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * cp_setrootxattr:
 * Sets the EA we set on the root folder (fileid 1) to get information about the
 * version of Content Protection that was used to write to this filesystem.
 * Note that all multi-byte fields are written to disk little endian so they must be
 * converted to little endian as needed.
 *
 * This will be written to the disk when it detects the EA is not there, or when we need
 * to make a modification to the on-disk version that can be done in-place.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_setrootxattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cp_root_xattr *newxattr)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> vnop_setxattr_args args;

	args.a_desc = NULL;
	args.a_vp = NULL;
	args.a_name = CONTENT_PROTECTION_XATTR_NAME;
	args.a_uio = NULL; <span class="enscript-comment">//pass data ptr instead
</span>	args.a_options = 0;
	args.a_context = NULL; <span class="enscript-comment">//no context needed, only done from mount.
</span>
	<span class="enscript-type">const</span> uint32_t flags = newxattr-&gt;flags;

	<span class="enscript-comment">/* Now convert the multi-byte fields to little endian before writing to disk. */</span>
	newxattr-&gt;flags = OSSwapHostToLittleInt64(newxattr-&gt;flags);

	<span class="enscript-type">int</span> xattr_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_root_xattr);


	newxattr-&gt;major_version = OSSwapHostToLittleInt16(newxattr-&gt;major_version);
	newxattr-&gt;minor_version = OSSwapHostToLittleInt16(newxattr-&gt;minor_version);

	error = hfs_setxattr_internal(NULL, (caddr_t)newxattr,
			xattr_size, &amp;args, hfsmp, 1);

	<span class="enscript-keyword">if</span> (!error) {
		hfsmp-&gt;cproot_flags = flags;
	}

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * Stores new xattr data on the cnode.
 * cnode lock held exclusive (if available).
 *
 * This function is also invoked during file creation.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_setxattr</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cprotect *entry, <span class="enscript-type">struct</span> hfsmount *hfsmp,
				uint32_t fileid, <span class="enscript-type">int</span> options)
{
	<span class="enscript-type">int</span> error = 0;
	cp_key_pair_t *cpkp = &amp;entry-&gt;cp_keys;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) {
		<span class="enscript-keyword">return</span> EROFS;
	}

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_running_cp_major_vers &lt; CP_CURRENT_VERS) {
		<span class="enscript-comment">// Upgrade
</span>		printf(<span class="enscript-string">&quot;hfs: upgrading to cp version %u\n&quot;</span>, CP_CURRENT_VERS);

		<span class="enscript-type">struct</span> cp_root_xattr root_xattr;

		error = cp_getrootxattr(hfsmp, &amp;root_xattr);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;

		root_xattr.major_version = CP_CURRENT_VERS;
		root_xattr.minor_version = CP_MINOR_VERS;

		error = cp_setrootxattr(hfsmp, &amp;root_xattr);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;

		hfsmp-&gt;hfs_running_cp_major_vers = CP_CURRENT_VERS;
	}

	<span class="enscript-type">struct</span> cp_xattr_v5 *xattr;
	MALLOC(xattr, <span class="enscript-type">struct</span> cp_xattr_v5 *, <span class="enscript-keyword">sizeof</span>(*xattr), M_TEMP, M_WAITOK);

	xattr-&gt;xattr_major_version	= OSSwapHostToLittleConstInt16(CP_VERS_5);
	xattr-&gt;xattr_minor_version	= OSSwapHostToLittleConstInt16(CP_MINOR_VERS);
	xattr-&gt;flags				= 0;
	xattr-&gt;persistent_class		= OSSwapHostToLittleInt32(entry-&gt;cp_pclass);
	xattr-&gt;key_os_version		= OSSwapHostToLittleInt32(entry-&gt;cp_key_os_version);
	xattr-&gt;key_revision			= OSSwapHostToLittleInt16(entry-&gt;cp_key_revision);

	uint16_t key_len = cpkp_pers_key_len(cpkp);
	xattr-&gt;key_len	= OSSwapHostToLittleInt16(key_len);
	memcpy(xattr-&gt;persistent_key, cpkp_pers_key(cpkp), key_len);

	size_t xattr_len = offsetof(<span class="enscript-type">struct</span> cp_xattr_v5, persistent_key) + key_len;


	<span class="enscript-type">struct</span> vnop_setxattr_args args = {
		.a_vp		= cp ? cp-&gt;c_vp : NULL,
		.a_name		= CONTENT_PROTECTION_XATTR_NAME,
		.a_options	= options,
		.a_context	= vfs_context_current(),
	};

	error = hfs_setxattr_internal(cp, xattr, xattr_len, &amp;args, hfsmp, fileid);

	FREE(xattr, M_TEMP);

	<span class="enscript-keyword">if</span> (error == 0 ) {
		entry-&gt;cp_flags &amp;= ~CP_NO_XATTR;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Used by an fcntl to query the underlying FS for its content protection version #
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_get_root_major_vers</span>(vnode_t vp, uint32_t *level) 
{
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;
	<span class="enscript-type">struct</span> mount *mp = NULL;

	mp = VTOVFS(vp);

	<span class="enscript-comment">/* check if it supports content protection */</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected(mp) == 0) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	hfsmp = VFSTOHFS(mp);
	<span class="enscript-comment">/* figure out the level */</span>

	err = cp_root_major_vers(mp);

	<span class="enscript-keyword">if</span> (err == 0) {
		*level = hfsmp-&gt;hfs_running_cp_major_vers;
	}
	<span class="enscript-comment">/* in error case, cp_root_major_vers will just return EINVAL. Use that */</span>

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/* Used by fcntl to query default protection level of FS */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_get_default_level</span> (<span class="enscript-type">struct</span> vnode *vp, uint32_t *level) {
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;
	<span class="enscript-type">struct</span> mount *mp = NULL;

	mp = VTOVFS(vp);

	<span class="enscript-comment">/* check if it supports content protection */</span>
	<span class="enscript-keyword">if</span> (cp_fs_protected(mp) == 0) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	hfsmp = VFSTOHFS(mp);
	<span class="enscript-comment">/* figure out the default */</span>

	*level = hfsmp-&gt;default_cp_class;
	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/********************
 * Private Functions
 *******************/</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_root_major_vers</span>(mount_t mp)
{
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">struct</span> cp_root_xattr xattr;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = NULL;

	hfsmp = vfs_fsprivate(mp);
	err = cp_getrootxattr (hfsmp, &amp;xattr);

	<span class="enscript-keyword">if</span> (err == 0) {
		hfsmp-&gt;hfs_running_cp_major_vers = xattr.major_version;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_vnode_is_eligible</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-keyword">return</span> ((vp-&gt;v_op == hfs_vnodeop_p) &amp;&amp;
			(!vnode_issystem(vp)) &amp;&amp;
			(vnode_isreg(vp) || vnode_isdir(vp)));
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_is_valid_class</span>(<span class="enscript-type">int</span> isdir, int32_t protectionclass)
{
	<span class="enscript-comment">/* 
	 * The valid protection classes are from 0 -&gt; N
	 * We use a signed argument to detect unassigned values from 
	 * directory entry creation time in HFS.
	 */</span>
	<span class="enscript-keyword">if</span> (isdir) {
		<span class="enscript-comment">/* Directories are not allowed to have F, but they can have &quot;NONE&quot; */</span>
		<span class="enscript-keyword">return</span> ((protectionclass &gt;= PROTECTION_CLASS_DIR_NONE) &amp;&amp; 
				(protectionclass &lt;= PROTECTION_CLASS_D));
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> ((protectionclass &gt;= PROTECTION_CLASS_A) &amp;&amp;
				(protectionclass &lt;= PROTECTION_CLASS_F));
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t cp_magic1 = 0x7b727063;	<span class="enscript-comment">// cpr{
</span><span class="enscript-type">static</span> <span class="enscript-type">const</span> uint32_t cp_magic2 = 0x7270637d;	<span class="enscript-comment">// }cpr
</span>#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> cprotect *
<span class="enscript-function-name">cp_entry_alloc</span>(cprotect_t old, uint16_t pers_key_len,
			   uint16_t cached_key_len, cp_key_pair_t **pcpkp)
{
	<span class="enscript-type">struct</span> cprotect *cp_entry;

	<span class="enscript-keyword">if</span> (pers_key_len &gt; CP_MAX_WRAPPEDKEYSIZE)
		<span class="enscript-keyword">return</span> (NULL);

	size_t size = (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cprotect) - <span class="enscript-keyword">sizeof</span>(cp_key_pair_t)
				   + cpkp_size(pers_key_len, cached_key_len));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	size += 4;	<span class="enscript-comment">// Extra for magic2
</span>#<span class="enscript-reference">endif</span>

	MALLOC(cp_entry, <span class="enscript-type">struct</span> cprotect *, size, M_TEMP, M_WAITOK);

	<span class="enscript-keyword">if</span> (old) {
		memcpy(cp_entry, old, offsetof(<span class="enscript-type">struct</span> cprotect, cp_keys));

	} <span class="enscript-keyword">else</span> {
		bzero(cp_entry, offsetof(<span class="enscript-type">struct</span> cprotect, cp_keys));
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	cp_entry-&gt;cp_magic1 = cp_magic1;
	*PTR_ADD(uint32_t *, cp_entry, size - 4) = cp_magic2;
#<span class="enscript-reference">endif</span>

	cpkp_init(&amp;cp_entry-&gt;cp_keys, pers_key_len, cached_key_len);

	<span class="enscript-comment">/*
	 * If we've been passed the old entry, then we are in the process of
	 * rewrapping in which case we need to copy the cached key.  This is
	 * important for class B files when the device is locked because we
	 * won't be able to unwrap whilst in this state, yet we still need the
	 * unwrapped key.
	 */</span>
	<span class="enscript-keyword">if</span> (old)
		cpx_copy(cpkp_cpx(&amp;old-&gt;cp_keys), cpkp_cpx(&amp;cp_entry-&gt;cp_keys));

	<span class="enscript-keyword">if</span> (pcpkp)
		*pcpkp = &amp;cp_entry-&gt;cp_keys;

	<span class="enscript-keyword">return</span> cp_entry;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cp_entry_dealloc</span>(__unused hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cprotect *entry)
{

	cpkp_flush(&amp;entry-&gt;cp_keys);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	assert(entry-&gt;cp_magic1 == cp_magic1);
	assert(*PTR_ADD(uint32_t *, entry, (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cprotect) - <span class="enscript-keyword">sizeof</span>(cp_key_pair_t)
										+ cpkp_sizex(&amp;entry-&gt;cp_keys) == cp_magic2)));
#<span class="enscript-reference">endif</span>

	FREE(entry, M_TEMP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cp_read_xattr_v4</span>(__unused hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cp_xattr_v4 *xattr,
							size_t xattr_len, cprotect_t *pcpr, cp_getxattr_options_t options)
{
	<span class="enscript-comment">/* Endian swap the multi-byte fields into host endianness from L.E. */</span>
	xattr-&gt;xattr_major_version = OSSwapLittleToHostInt16(xattr-&gt;xattr_major_version);
	xattr-&gt;xattr_minor_version = OSSwapLittleToHostInt16(xattr-&gt;xattr_minor_version);
	xattr-&gt;key_size = OSSwapLittleToHostInt32(xattr-&gt;key_size);
	xattr-&gt;flags = OSSwapLittleToHostInt32(xattr-&gt;flags);
	xattr-&gt;persistent_class = OSSwapLittleToHostInt32(xattr-&gt;persistent_class);
	xattr-&gt;key_os_version = OSSwapLittleToHostInt32(xattr-&gt;key_os_version);

	<span class="enscript-comment">/*
	 * Prevent a buffer overflow, and validate the key length obtained from the
	 * EA. If it's too big, then bail out, because the EA can't be trusted at this
	 * point.
	 */</span>
	<span class="enscript-keyword">if</span> (xattr-&gt;key_size &gt; CP_MAX_WRAPPEDKEYSIZE)
		<span class="enscript-keyword">return</span> HFS_EINCONSISTENT;

	size_t min_len = offsetof(<span class="enscript-type">struct</span> cp_xattr_v4, persistent_key) + xattr-&gt;key_size;
	<span class="enscript-keyword">if</span> (xattr_len &lt; min_len)
		<span class="enscript-keyword">return</span> HFS_EINCONSISTENT;

	<span class="enscript-comment">/*
	 * Class F files have no backing key; their keylength should be 0,
	 * though they should have the proper flags set.
	 *
	 * A request to instantiate a CP for a class F file should result
	 * in a bzero'd cp that just says class F, with key_flushed set.
	 */</span>
	<span class="enscript-keyword">if</span> (CP_CLASS(xattr-&gt;persistent_class) == PROTECTION_CLASS_F
		|| ISSET(xattr-&gt;flags, CP_XAF_NEEDS_KEYS)) {
		xattr-&gt;key_size = 0;
	}

	<span class="enscript-comment">/* set up entry with information from xattr */</span>
	cp_key_pair_t *cpkp;
	cprotect_t entry;
	
	<span class="enscript-keyword">if</span> (ISSET(options, CP_GET_XATTR_BASIC_INFO)) {
		<span class="enscript-comment">/* caller passed in a pre-allocated structure to get the basic info */</span>
		entry = *pcpr;
		bzero(entry, offsetof(<span class="enscript-type">struct</span> cprotect, cp_keys));
	}
	<span class="enscript-keyword">else</span> {
		entry = cp_entry_alloc(NULL, xattr-&gt;key_size, CP_MAX_CACHEBUFLEN, &amp;cpkp);
	}

	entry-&gt;cp_pclass = xattr-&gt;persistent_class;
	entry-&gt;cp_key_os_version = xattr-&gt;key_os_version;


	<span class="enscript-keyword">if</span> (!ISSET(options, CP_GET_XATTR_BASIC_INFO)) {
		<span class="enscript-keyword">if</span> (xattr-&gt;key_size) {
			cpkp_set_pers_key_len(cpkp, xattr-&gt;key_size);
			memcpy(cpkp_pers_key(cpkp), xattr-&gt;persistent_key, xattr-&gt;key_size);
		}

		*pcpr = entry;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (xattr-&gt;key_size) {
		SET(entry-&gt;cp_flags, CP_HAS_A_KEY);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_read_xattr_v5</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cp_xattr_v5 *xattr,
					 size_t xattr_len, cprotect_t *pcpr, cp_getxattr_options_t options)
{
	<span class="enscript-keyword">if</span> (xattr-&gt;xattr_major_version == OSSwapHostToLittleConstInt16(CP_VERS_4)) {
		<span class="enscript-keyword">return</span> cp_read_xattr_v4(hfsmp, (<span class="enscript-type">struct</span> cp_xattr_v4 *)xattr, xattr_len, pcpr, options);
	}

	xattr-&gt;xattr_major_version	= OSSwapLittleToHostInt16(xattr-&gt;xattr_major_version);

	<span class="enscript-keyword">if</span> (xattr-&gt;xattr_major_version != CP_VERS_5) {
		printf(<span class="enscript-string">&quot;hfs: cp_getxattr: unsupported xattr version %d\n&quot;</span>,
			   xattr-&gt;xattr_major_version);
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	size_t min_len = offsetof(<span class="enscript-type">struct</span> cp_xattr_v5, persistent_key);

	<span class="enscript-keyword">if</span> (xattr_len &lt; min_len)
		<span class="enscript-keyword">return</span> HFS_EINCONSISTENT;

	xattr-&gt;xattr_minor_version	= OSSwapLittleToHostInt16(xattr-&gt;xattr_minor_version);
	xattr-&gt;flags				= OSSwapLittleToHostInt32(xattr-&gt;flags);
	xattr-&gt;persistent_class		= OSSwapLittleToHostInt32(xattr-&gt;persistent_class);
	xattr-&gt;key_os_version		= OSSwapLittleToHostInt32(xattr-&gt;key_os_version);
	xattr-&gt;key_revision			= OSSwapLittleToHostInt16(xattr-&gt;key_revision);
	xattr-&gt;key_len				= OSSwapLittleToHostInt16(xattr-&gt;key_len);

	uint16_t pers_key_len = xattr-&gt;key_len;

	min_len += pers_key_len;
	<span class="enscript-keyword">if</span> (xattr_len &lt; min_len)
		<span class="enscript-keyword">return</span> HFS_EINCONSISTENT;


	cp_key_pair_t *cpkp;
	cprotect_t entry;
	
	<span class="enscript-comment">/* 
	 * If option CP_GET_XATTR_BASIC_INFO is set, we only return basic
	 * information about the file's protection (and not the key) and
	 * we store the result in the structure the caller passed to us.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(options, CP_GET_XATTR_BASIC_INFO)) {
		entry = *pcpr;
		bzero(entry, offsetof(<span class="enscript-type">struct</span> cprotect, cp_keys));
	} <span class="enscript-keyword">else</span> {
		entry = cp_entry_alloc(NULL, xattr-&gt;key_len, CP_MAX_CACHEBUFLEN, &amp;cpkp);
	}

	entry-&gt;cp_pclass			= xattr-&gt;persistent_class;
	entry-&gt;cp_key_os_version	= xattr-&gt;key_os_version;
	entry-&gt;cp_key_revision		= xattr-&gt;key_revision;

	<span class="enscript-keyword">if</span> (!ISSET(options, CP_GET_XATTR_BASIC_INFO)) {
		<span class="enscript-keyword">if</span> (xattr-&gt;key_len) {
			cpkp_set_pers_key_len(cpkp, xattr-&gt;key_len);
			memcpy(cpkp_pers_key(cpkp), xattr-&gt;persistent_key, xattr-&gt;key_len);
		}


		*pcpr = entry;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (xattr-&gt;key_len) {
		SET(entry-&gt;cp_flags, CP_HAS_A_KEY);
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Initializes a new cprotect entry with xattr data from the cnode.
 * cnode lock held shared
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_getxattr</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> hfsmount *hfsmp, cprotect_t *outentry)
{
	size_t xattr_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cp_xattr_v5);
	<span class="enscript-type">struct</span> cp_xattr_v5 *xattr;

	MALLOC (xattr, <span class="enscript-type">struct</span> cp_xattr_v5 *, xattr_len,
			M_TEMP, M_WAITOK);

	<span class="enscript-type">int</span> error = hfs_xattr_read(cp-&gt;c_vp, CONTENT_PROTECTION_XATTR_NAME,
							   xattr, &amp;xattr_len);

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (xattr_len &lt; CP_XATTR_MIN_LEN)
			error = HFS_EINCONSISTENT;
		<span class="enscript-keyword">else</span>
			error = cp_read_xattr_v5(hfsmp, xattr, xattr_len, outentry, 0);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (error &amp;&amp; error != ENOATTR) {
		printf(<span class="enscript-string">&quot;cp_getxattr: bad cp xattr (%d):\n&quot;</span>, error);
		<span class="enscript-keyword">for</span> (size_t i = 0; i &lt; xattr_len; ++i)
			printf(<span class="enscript-string">&quot;%02x &quot;</span>, ((uint8_t *)xattr)[i]);
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
#<span class="enscript-reference">endif</span>

	FREE(xattr, M_TEMP);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * If permitted, restore entry's unwrapped key from the persistent key.
 * If not, clear key and set CP_KEY_FLUSHED.
 * cnode lock held exclusive
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_restore_keys</span>(<span class="enscript-type">struct</span> cprotect *entry, <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-type">int</span> error = 0;

 	error = cp_unwrap(hfsmp, entry, cp);
	<span class="enscript-keyword">if</span> (error) {
		cp_flush_cached_keys(entry);
		error = EPERM;
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_lock_vfs_callback</span>(mount_t mp, <span class="enscript-type">void</span> *arg) 
{

	<span class="enscript-comment">/* Use a pointer-width integer field for casting */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> new_state;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;

	<span class="enscript-comment">/*
	 * When iterating the various mount points that may
	 * be present on a content-protected device, we need to skip
	 * those that do not have it enabled.
	 */</span>
	<span class="enscript-keyword">if</span> (!cp_fs_protected(mp)) {
		<span class="enscript-keyword">return</span> 0;
	}
	new_state = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) arg;
	
	hfsmp = VFSTOHFS(mp);

	hfs_lock_mount(hfsmp);
	<span class="enscript-comment">/* this loses all of the upper bytes of precision; that's OK */</span>
	hfsmp-&gt;hfs_cp_lock_state = (uint8_t) new_state;
	hfs_unlock_mount(hfsmp);

	<span class="enscript-keyword">if</span> (new_state == CP_LOCKED_STATE) { 
		<span class="enscript-comment">/* 
		 * We respond only to lock events.  Since cprotect structs
		 * decrypt/restore keys lazily, the unlock events don't
		 * actually cause anything to happen.
		 */</span>
		<span class="enscript-keyword">return</span> vnode_iterate(mp, 0, cp_lock_vnode_callback, arg);
	}
	<span class="enscript-comment">/* Otherwise just return 0. */</span>
	<span class="enscript-keyword">return</span> 0;

}


<span class="enscript-comment">/*
 * Deny access to protected files if keys have been locked.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_check_access</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> vnop __unused)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* 
	 * For now it's OK to examine the state variable here without
	 * holding the HFS lock.  This is only a short-circuit; if the state
	 * transitions (or is in transition) after we examine this field, we'd
	 * have to handle that anyway. 
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_cp_lock_state == CP_UNLOCKED_STATE) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (!cp-&gt;c_cpentry) {
		<span class="enscript-comment">/* unprotected node */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (!S_ISREG(cp-&gt;c_mode)) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* Deny all access for class A files */</span>
	<span class="enscript-keyword">switch</span> (CP_CLASS(cp-&gt;c_cpentry-&gt;cp_pclass)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROTECTION_CLASS_A</span>: {
			error = EPERM;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			error = 0;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Respond to a lock or unlock event.
 * On lock: clear out keys from memory, then flush file contents.
 * On unlock: nothing (function not called).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_lock_vnode_callback</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">void</span> *arg)
{
	cnode_t *cp = NULL;
	<span class="enscript-type">struct</span> cprotect *entry = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> locked = 1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> action = 0;
	<span class="enscript-type">int</span> took_truncate_lock = 0;

	error = vnode_getwithref (vp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	cp = VTOC(vp);

	<span class="enscript-comment">/*
	 * When cleaning cnodes due to a lock event, we must
	 * take the truncate lock AND the cnode lock.  By taking
	 * the truncate lock here, we force (nearly) all pending IOs
	 * to drain before we can acquire the truncate lock.  All HFS cluster
	 * io calls except for swapfile IO need to acquire the truncate lock
	 * prior to calling into the cluster layer.
	 */</span>
	hfs_lock_truncate (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	took_truncate_lock = 1;

	hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

	entry = cp-&gt;c_cpentry;
	<span class="enscript-keyword">if</span> (!entry) {
		<span class="enscript-comment">/* unprotected vnode: not a regular file */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	action = (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) arg;
	<span class="enscript-keyword">switch</span> (action) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CP_LOCKED_STATE</span>: {
			vfs_context_t ctx;
			<span class="enscript-keyword">if</span> (CP_CLASS(entry-&gt;cp_pclass) != PROTECTION_CLASS_A ||
				vnode_isdir(vp)) {
				<span class="enscript-comment">/*
				 * There is no change at lock for other classes than A.
				 * B is kept in memory for writing, and class F (for VM) does
				 * not have a wrapped key, so there is no work needed for
				 * wrapping/unwrapping.
				 *
				 * Note that 'class F' is relevant here because if
				 * hfs_vnop_strategy does not take the cnode lock
				 * to protect the cp blob across IO operations, we rely
				 * implicitly on the truncate lock to be held when doing IO.
				 * The only case where the truncate lock is not held is during
				 * swapfile IO because HFS just funnels the VNOP_PAGEOUT
				 * directly to cluster_pageout.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* Before doing anything else, zero-fill sparse ranges as needed */</span>
			ctx = vfs_context_current();
			(<span class="enscript-type">void</span>) hfs_filedone (vp, ctx, 0);

			<span class="enscript-comment">/* first, sync back dirty pages */</span>
			hfs_unlock (cp);
			ubc_msync (vp, 0, ubc_getsize(vp), NULL, UBC_PUSHALL | UBC_INVALIDATE | UBC_SYNC);
			hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

			<span class="enscript-comment">/* flush keys:
			 * There was a concern here(9206856) about flushing keys before nand layer is done using them.
			 * But since we are using ubc_msync with UBC_SYNC, it blocks until all IO is completed.
			 * Once IOFS caches or is done with these keys, it calls the completion routine in IOSF.
			 * Which in turn calls buf_biodone() and eventually unblocks ubc_msync()
			 * Also verified that the cached data in IOFS is overwritten by other data, and there
			 * is no key leakage in that layer.
			 */</span>

			cp_flush_cached_keys(entry);

			<span class="enscript-comment">/* some write may have arrived in the mean time. dump those pages */</span>
			hfs_unlock(cp);
			locked = 0;

			ubc_msync (vp, 0, ubc_getsize(vp), NULL, UBC_INVALIDATE | UBC_SYNC);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CP_UNLOCKED_STATE</span>: {
			<span class="enscript-comment">/* no-op */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;Content Protection: unknown lock action %lu\n&quot;</span>, action);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (locked) {
		hfs_unlock(cp);
	}

	<span class="enscript-keyword">if</span> (took_truncate_lock) {
		hfs_unlock_truncate (cp, HFS_LOCK_DEFAULT);
	}

	vnode_put (vp);
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/* 
 * cp_rewrap:
 *
 * Generate a new wrapped key based on the existing cache key.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_rewrap</span>(<span class="enscript-type">struct</span> cnode *cp, __unused hfsmount_t *hfsmp,
		  cp_key_class_t *newclass, cp_key_pair_t *cpkp, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *old_holder,
		  cp_new_alloc_fn alloc_fn, <span class="enscript-type">void</span> **pholder)
{
	<span class="enscript-type">struct</span> cprotect *entry = cp-&gt;c_cpentry;

	uint8_t new_persistent_key[CP_MAX_WRAPPEDKEYSIZE];
	size_t keylen = CP_MAX_WRAPPEDKEYSIZE;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">const</span> cp_key_class_t key_class = CP_CLASS(*newclass);

	<span class="enscript-comment">/* Structures passed between HFS and AKS */</span>
	cp_cred_s access_in;
	cp_wrapped_key_s wrapped_key_in;
	cp_wrapped_key_s wrapped_key_out;

	<span class="enscript-comment">/*
	 * PROTECTION_CLASS_F is in-use by VM swapfile; it represents a transient
	 * key that is only good as long as the file is open.  There is no
	 * wrapped key, so there isn't anything to wrap.
	 */</span>
	<span class="enscript-keyword">if</span> (key_class == PROTECTION_CLASS_F) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	cp_init_access(&amp;access_in, cp);

	bzero(&amp;wrapped_key_in, <span class="enscript-keyword">sizeof</span>(wrapped_key_in));
	wrapped_key_in.key = cpkp_pers_key(cpkp);
	wrapped_key_in.key_len = cpkp_pers_key_len(cpkp);
	<span class="enscript-comment">/* Use the persistent class when talking to AKS */</span>
	wrapped_key_in.dp_class = entry-&gt;cp_pclass;

	bzero(&amp;wrapped_key_out, <span class="enscript-keyword">sizeof</span>(wrapped_key_out));
	wrapped_key_out.key = new_persistent_key;
	wrapped_key_out.key_len = keylen;

	<span class="enscript-comment">/*
	 * inode is passed here to find the backup bag wrapped blob
	 * from userspace.  This lookup will occur shortly after creation
	 * and only if the file still exists.  Beyond this lookup the
	 * inode is not used.  Technically there is a race, we practically
	 * don't lose.
	 */</span>
	error = g_cp_wrap_func.rewrapper(&amp;access_in,
			key_class, <span class="enscript-comment">/* new class */</span>
			&amp;wrapped_key_in,
			&amp;wrapped_key_out);

	keylen = wrapped_key_out.key_len;

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * Verify that AKS returned to us a wrapped key of the 
		 * target class requested.   
		 */</span>
		<span class="enscript-comment">/* Get the effective class here */</span>
		cp_key_class_t effective = CP_CLASS(wrapped_key_out.dp_class);
		<span class="enscript-keyword">if</span> (effective != key_class) {
			<span class="enscript-comment">/* 
			 * Fail the operation if defaults or some other enforcement
			 * dictated that the class be wrapped differently. 
			 */</span>

			<span class="enscript-comment">/* TODO: Invalidate the key when 12170074 unblocked */</span>
			<span class="enscript-keyword">return</span> EPERM;
		}

		<span class="enscript-comment">/* Allocate a new cpentry */</span>
		cp_key_pair_t *new_cpkp;
		*pholder = alloc_fn(old_holder, keylen, CP_MAX_CACHEBUFLEN, &amp;new_cpkp);

		<span class="enscript-comment">/* copy the new key into the entry */</span>
		cpkp_set_pers_key_len(new_cpkp, keylen);
		memcpy(cpkp_pers_key(new_cpkp), new_persistent_key, keylen);

		<span class="enscript-comment">/* Actually record/store what AKS reported back, not the effective class stored in newclass */</span>
		*newclass = wrapped_key_out.dp_class;
	}
	<span class="enscript-keyword">else</span> {
		error = EPERM;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cpkp_unwrap</span>(cnode_t *cp, cp_key_class_t key_class, cp_key_pair_t *cpkp)
{
	<span class="enscript-type">int</span> error = 0;
	uint8_t iv_key[CP_IV_KEYSIZE];
	cpx_t cpx = cpkp_cpx(cpkp);

	<span class="enscript-comment">/* Structures passed between HFS and AKS */</span>
	cp_cred_s access_in;
	cp_wrapped_key_s wrapped_key_in;
	cp_raw_key_s key_out;

	cp_init_access(&amp;access_in, cp);

	bzero(&amp;wrapped_key_in, <span class="enscript-keyword">sizeof</span>(wrapped_key_in));
	wrapped_key_in.key = cpkp_pers_key(cpkp);
	wrapped_key_in.key_len = cpkp_max_pers_key_len(cpkp);
	<span class="enscript-comment">/* Use the persistent class when talking to AKS */</span>
	wrapped_key_in.dp_class = key_class;

	bzero(&amp;key_out, <span class="enscript-keyword">sizeof</span>(key_out));
	key_out.iv_key = iv_key;
	key_out.key = cpx_key(cpx);
	<span class="enscript-comment">/*
	 * The unwrapper should validate/set the key length for
	 * the IV key length and the cache key length, however we need
	 * to supply the correct buffer length so that AKS knows how
	 * many bytes it has to work with.
	 */</span>
	key_out.iv_key_len = CP_IV_KEYSIZE;
	key_out.key_len = cpx_max_key_len(cpx);

	error = g_cp_wrap_func.unwrapper(&amp;access_in, &amp;wrapped_key_in, &amp;key_out);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (key_out.key_len == 0 || key_out.key_len &gt; CP_MAX_CACHEBUFLEN) {
			panic (<span class="enscript-string">&quot;cp_unwrap: invalid key length! (%ul)\n&quot;</span>, key_out.key_len);
		}

		<span class="enscript-keyword">if</span> (key_out.iv_key_len != CP_IV_KEYSIZE)
			panic (<span class="enscript-string">&quot;cp_unwrap: invalid iv key length! (%ul)\n&quot;</span>, key_out.iv_key_len);

		cpx_set_key_len(cpx, key_out.key_len);

		cpx_set_aes_iv_key(cpx, iv_key);
		cpx_set_is_sep_wrapped_key(cpx, ISSET(key_out.flags, CP_RAW_KEY_WRAPPEDKEY));
	} <span class="enscript-keyword">else</span> {
		error = EPERM;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cp_unwrap</span>(__unused <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cprotect *entry, <span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-comment">/*
	 * PROTECTION_CLASS_F is in-use by VM swapfile; it represents a transient
	 * key that is only good as long as the file is open.  There is no
	 * wrapped key, so there isn't anything to unwrap.
	 */</span>
	<span class="enscript-keyword">if</span> (CP_CLASS(entry-&gt;cp_pclass) == PROTECTION_CLASS_F) {
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-type">int</span> error = cpkp_unwrap(cp, entry-&gt;cp_pclass, &amp;entry-&gt;cp_keys);


	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * cp_generate_keys
 *
 * Take a cnode that has already been initialized and establish persistent and
 * cache keys for it at this time. Note that at the time this is called, the
 * directory entry has already been created and we are holding the cnode lock
 * on 'cp'.
 * 
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cp_generate_keys</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp, cp_key_class_t targetclass,
		uint32_t keyflags, <span class="enscript-type">struct</span> cprotect **newentry) 
{

	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> cprotect *newcp = NULL;
	*newentry = NULL;

	<span class="enscript-comment">/* Target class must be an effective class only */</span>
	targetclass = CP_CLASS(targetclass);

	<span class="enscript-comment">/* Validate that it has a cprotect already */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry == NULL) {
		<span class="enscript-comment">/* We can't do anything if it shouldn't be protected. */</span>
		<span class="enscript-keyword">return</span> 0;
	}	

	<span class="enscript-comment">/* Asserts for the underlying cprotect */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry-&gt;cp_flags &amp; CP_NO_XATTR) {
		<span class="enscript-comment">/* should already have an xattr by this point. */</span>
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (S_ISREG(cp-&gt;c_mode)) {
		<span class="enscript-keyword">if</span> (!cp_needs_pers_key(cp-&gt;c_cpentry)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	cp_key_revision_t key_revision = cp_initial_key_revision(hfsmp);

	error = cp_new (&amp;targetclass, hfsmp, cp, cp-&gt;c_mode, keyflags, key_revision,
					(cp_new_alloc_fn)cp_entry_alloc, (<span class="enscript-type">void</span> **)&amp;newcp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* 
		 * Key generation failed. This is not necessarily fatal
		 * since the device could have transitioned into the lock 
		 * state before we called this.  
		 */</span>	
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	newcp-&gt;cp_pclass			= targetclass;
	newcp-&gt;cp_key_os_version	= cp_os_version();
	newcp-&gt;cp_key_revision		= key_revision;

	<span class="enscript-comment">/*
	 * If we got here, then we have a new cprotect.
	 * Attempt to write the new one out.
	 */</span>
	error = cp_setxattr (cp, newcp, hfsmp, cp-&gt;c_fileid, XATTR_REPLACE);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* Tear down the new cprotect; Tell MKB that it's invalid. Bail out */</span>
		<span class="enscript-comment">/* TODO: rdar://12170074 needs to be fixed before we can tell MKB */</span>
		<span class="enscript-keyword">if</span> (newcp) {
			cp_entry_destroy(hfsmp, newcp);
		}	
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* 
	 * If we get here then we can assert that:
	 * 1) generated wrapped/unwrapped keys.
	 * 2) wrote the new keys to disk.
	 * 3) cprotect is ready to go.
	 */</span>

	*newentry = newcp;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;

}

<span class="enscript-type">void</span> <span class="enscript-function-name">cp_replace_entry</span> (hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cprotect *newentry)
{
	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry) {

		cp_entry_destroy (hfsmp, cp-&gt;c_cpentry);
	}
	cp-&gt;c_cpentry = newentry;
	newentry-&gt;cp_backing_cnode = cp;

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * cp_new
 *
 * Given a double-pointer to a cprotect, generate keys (either in-kernel or from keystore),
 * allocate a cprotect, and vend it back to the caller.
 * 
 * Additionally, decide if keys are even needed -- directories get cprotect data structures
 * but they do not have keys.
 *
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cp_new</span>(cp_key_class_t *newclass_eff, __unused <span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode *cp,
	   mode_t cmode, int32_t keyflags, cp_key_revision_t key_revision,
	   cp_new_alloc_fn alloc_fn, <span class="enscript-type">void</span> **pholder)
{
	<span class="enscript-type">int</span> error = 0;
	uint8_t new_key[CP_MAX_CACHEBUFLEN];
	size_t new_key_len = CP_MAX_CACHEBUFLEN;  <span class="enscript-comment">/* AKS tell us the proper key length, how much of this is used */</span>
	uint8_t new_persistent_key[CP_MAX_WRAPPEDKEYSIZE];
	size_t new_persistent_len = CP_MAX_WRAPPEDKEYSIZE;
	uint8_t iv_key[CP_IV_KEYSIZE];
	size_t iv_key_len = CP_IV_KEYSIZE;
	<span class="enscript-type">int</span> iswrapped = 0;
	cp_key_class_t key_class = CP_CLASS(*newclass_eff);

	<span class="enscript-comment">/* Structures passed between HFS and AKS */</span>
	cp_cred_s access_in;
	cp_wrapped_key_s wrapped_key_out;
	cp_raw_key_s key_out;

	<span class="enscript-keyword">if</span> (are_wraps_initialized == false) {
		printf(<span class="enscript-string">&quot;hfs: cp_new: wrap/gen functions not yet set\n&quot;</span>);
		<span class="enscript-keyword">return</span> ENXIO;
	}

	<span class="enscript-comment">/* Sanity check that it's a file or directory here */</span>
	<span class="enscript-keyword">if</span> (!(S_ISREG(cmode)) &amp;&amp; !(S_ISDIR(cmode))) {
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-comment">/*
	 * Step 1: Generate Keys if needed.
	 * 
	 * For class F files, the kernel provides the key.
	 * PROTECTION_CLASS_F is in-use by VM swapfile; it represents a transient
	 * key that is only good as long as the file is open.  There is no
	 * wrapped key, so there isn't anything to wrap.
	 *
	 * For class A-&gt;D files, the key store provides the key 
	 * 
	 * For Directories, we only give them a class ; no keys.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISDIR (cmode)) {
		<span class="enscript-comment">/* Directories */</span>
		new_persistent_len = 0;
		new_key_len = 0;

		error = 0;
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Must be a file */</span>         
		<span class="enscript-keyword">if</span> (key_class == PROTECTION_CLASS_F) {
			<span class="enscript-comment">/* class F files are not wrapped; they can still use the max key size */</span>
			new_key_len = CP_MAX_KEYSIZE;
			read_random (&amp;new_key[0], new_key_len);
			new_persistent_len = 0;

			error = 0;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * The keystore is provided the file ID so that it can associate
			 * the wrapped backup blob with this key from userspace. This 
			 * lookup occurs after successful file creation.  Beyond this, the
			 * file ID is not used.  Note that there is a potential race here if
			 * the file ID is re-used.  
			 */</span>
			cp_init_access(&amp;access_in, cp);
		
			bzero(&amp;key_out, <span class="enscript-keyword">sizeof</span>(key_out));
			key_out.key = new_key;
			key_out.iv_key = iv_key;
			<span class="enscript-comment">/* 
			 * AKS will override our key length fields, but we need to supply
			 * the length of the buffer in those length fields so that 
			 * AKS knows hoa many bytes it has to work with.
			 */</span>
			key_out.key_len = new_key_len;
			key_out.iv_key_len = iv_key_len;

			bzero(&amp;wrapped_key_out, <span class="enscript-keyword">sizeof</span>(wrapped_key_out));
			wrapped_key_out.key = new_persistent_key;
			wrapped_key_out.key_len = new_persistent_len;

			access_in.key_revision = key_revision;

			error = g_cp_wrap_func.new_key(&amp;access_in,
					key_class,
					&amp;key_out,
					&amp;wrapped_key_out);

			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/* keybag returned failure */</span>
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cpnew_fail</span>;
			}

			<span class="enscript-comment">/* Now sanity-check the output from new_key */</span>
			<span class="enscript-keyword">if</span> (key_out.key_len == 0 || key_out.key_len &gt; CP_MAX_CACHEBUFLEN) {
				panic (<span class="enscript-string">&quot;cp_new: invalid key length! (%ul) \n&quot;</span>, key_out.key_len);
			}

			<span class="enscript-keyword">if</span> (key_out.iv_key_len != CP_IV_KEYSIZE) {
				panic (<span class="enscript-string">&quot;cp_new: invalid iv key length! (%ul) \n&quot;</span>, key_out.iv_key_len);
			}	
		
			<span class="enscript-comment">/* 
			 * AKS is allowed to override our preferences and wrap with a 
			 * different class key for policy reasons. If we were told that 
			 * any class other than the one specified is unacceptable then error out 
			 * if that occurred.  Check that the effective class returned by 
			 * AKS is the same as our effective new class 
			 */</span>
			<span class="enscript-keyword">if</span> (CP_CLASS(wrapped_key_out.dp_class) != key_class) {
				<span class="enscript-keyword">if</span> (!ISSET(keyflags, CP_KEYWRAP_DIFFCLASS)) {
					error = EPERM;
					<span class="enscript-comment">/* TODO: When 12170074 fixed, release/invalidate the key! */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">cpnew_fail</span>;
				}
			}

			*newclass_eff = wrapped_key_out.dp_class;
			new_key_len = key_out.key_len;
			iv_key_len = key_out.iv_key_len;
			new_persistent_len = wrapped_key_out.key_len;

			<span class="enscript-comment">/* Is the key a SEP wrapped key? */</span>
			<span class="enscript-keyword">if</span> (key_out.flags &amp; CP_RAW_KEY_WRAPPEDKEY) {
				iswrapped = 1;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Step 2: allocate cprotect and initialize it.
	 */</span>

	cp_key_pair_t *cpkp;
	*pholder = alloc_fn(NULL, new_persistent_len, new_key_len, &amp;cpkp);
	<span class="enscript-keyword">if</span> (*pholder == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-comment">/* Copy the cache key &amp; IV keys into place if needed. */</span>
	<span class="enscript-keyword">if</span> (new_key_len &gt; 0) {
		cpx_t cpx = cpkp_cpx(cpkp);

		cpx_set_key_len(cpx, new_key_len);
		memcpy(cpx_key(cpx), new_key, new_key_len);

		<span class="enscript-comment">/* Initialize the IV key */</span>
		<span class="enscript-keyword">if</span> (key_class != PROTECTION_CLASS_F)
			cpx_set_aes_iv_key(cpx, iv_key);

		cpx_set_is_sep_wrapped_key(cpx, iswrapped);
	}
	<span class="enscript-keyword">if</span> (new_persistent_len &gt; 0) {
		cpkp_set_pers_key_len(cpkp, new_persistent_len);
		memcpy(cpkp_pers_key(cpkp), new_persistent_key, new_persistent_len);
	}

<span class="enscript-reference">cpnew_fail</span>:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_TMPDBG</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_cp_verbose) &amp;&amp; (error == EPERM)) {
		<span class="enscript-comment">/* Only introspect the data fork */</span>
		cp_log_eperm (cp-&gt;c_vp, *newclass_eff, true);
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* Initialize the cp_cred_t structure passed to AKS */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_init_access</span>(cp_cred_t access, <span class="enscript-type">struct</span> cnode *cp)
{
	vfs_context_t context = vfs_context_current();
	kauth_cred_t cred = vfs_context_ucred(context);
	proc_t proc = vfs_context_proc(context);

	bzero(access, <span class="enscript-keyword">sizeof</span>(*access));

	<span class="enscript-comment">/* Note: HFS uses 32-bit fileID, even though inode is a 64-bit value */</span>
	access-&gt;inode = cp-&gt;c_fileid;
	access-&gt;pid = proc_pid(proc);
	access-&gt;uid = kauth_cred_getuid(cred);

	<span class="enscript-keyword">if</span> (cp-&gt;c_cpentry)
		access-&gt;key_revision = cp-&gt;c_cpentry-&gt;cp_key_revision;

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Parses versions of the form 12A316, i.e. &lt;major&gt;&lt;minor&gt;&lt;revision&gt; and
 * returns a uint32_t in the form 0xaabbcccc where aa = &lt;major&gt;, 
 * bb = &lt;ASCII char&gt;, cccc = &lt;revision&gt;.
 */</span>
<span class="enscript-type">static</span> cp_key_os_version_t <span class="enscript-function-name">parse_os_version</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p = osversion;

	<span class="enscript-type">int</span> a = 0;
	<span class="enscript-keyword">while</span> (*p &gt;= <span class="enscript-string">'0'</span> &amp;&amp; *p &lt;= <span class="enscript-string">'9'</span>) {
		a = a * 10 + *p - <span class="enscript-string">'0'</span>;
		++p;
	}

	<span class="enscript-keyword">if</span> (!a)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-type">int</span> b = *p++;
	<span class="enscript-keyword">if</span> (!b)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-type">int</span> c = 0;
	<span class="enscript-keyword">while</span> (*p &gt;= <span class="enscript-string">'0'</span> &amp;&amp; *p &lt;= <span class="enscript-string">'9'</span>) {
		c = c * 10 + *p - <span class="enscript-string">'0'</span>;
		++p;
	}

	<span class="enscript-keyword">if</span> (!c)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">return</span> (a &amp; 0xff) &lt;&lt; 24 | b &lt;&lt; 16 | (c &amp; 0xffff);
}

cp_key_os_version_t <span class="enscript-function-name">cp_os_version</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">static</span> cp_key_os_version_t cp_os_version;

	<span class="enscript-keyword">if</span> (cp_os_version)
		<span class="enscript-keyword">return</span> cp_os_version;

	<span class="enscript-keyword">if</span> (!osversion[0])
		<span class="enscript-keyword">return</span> 0;

	cp_os_version = parse_os_version();
	<span class="enscript-keyword">if</span> (!cp_os_version) {
		printf(<span class="enscript-string">&quot;cp_os_version: unable to parse osversion `%s'\n&quot;</span>, osversion);
		cp_os_version = 1;
	}

	<span class="enscript-keyword">return</span> cp_os_version;
}


errno_t <span class="enscript-function-name">cp_handle_strategy</span>(buf_t bp)
{
	vnode_t vp = buf_vnode(bp);
	cnode_t *cp = NULL;

	<span class="enscript-keyword">if</span> (bufattr_rawencrypted(buf_attr(bp))
		|| !(cp = cp_get_protected_cnode(vp))
		|| !cp-&gt;c_cpentry) {
		<span class="enscript-comment">// Nothing to do
</span>		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * For filesystem resize, we may not have access to the underlying
	 * file's cache key for whatever reason (device may be locked).
	 * However, we do not need it since we are going to use the
	 * temporary HFS-wide resize key which is generated once we start
	 * relocating file content.  If this file's I/O should be done
	 * using the resize key, it will have been supplied already, so do
	 * not attach the file's cp blob to the buffer.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_cpentry-&gt;cp_flags, CP_RELOCATION_INFLIGHT))
		<span class="enscript-keyword">return</span> 0;

	{
		<span class="enscript-comment">// Fast path
</span>		cpx_t cpx = cpkp_cpx(&amp;cp-&gt;c_cpentry-&gt;cp_keys);

		<span class="enscript-keyword">if</span> (cpx_has_key(cpx)) {
			bufattr_setcpx(buf_attr(bp), cpx);
			<span class="enscript-keyword">return</span> 0;
		}
	}

	<span class="enscript-comment">/*
	 * We rely mostly (see note below) upon the truncate lock to
	 * protect the CP cache key from getting tossed prior to our IO
	 * finishing here.  Nearly all cluster io calls to manipulate file
	 * payload from HFS take the truncate lock before calling into the
	 * cluster layer to ensure the file size does not change, or that
	 * they have exclusive right to change the EOF of the file.  That
	 * same guarantee protects us here since the code that deals with
	 * CP lock events must now take the truncate lock before doing
	 * anything.
	 *
	 * If you want to change content protection structures, then the
	 * truncate lock is not sufficient; you must take the truncate
	 * lock and then wait for outstanding writes to complete.  This is
	 * necessary because asynchronous I/O only holds the truncate lock
	 * whilst I/O is being queued.
	 *
	 * One exception should be the VM swapfile IO, because HFS will
	 * funnel the VNOP_PAGEOUT directly into a cluster_pageout call
	 * for the swapfile code only without holding the truncate lock.
	 * This is because individual swapfiles are maintained at
	 * fixed-length sizes by the VM code.  In non-swapfile IO we use
	 * PAGEOUT_V2 semantics which allow us to create our own UPL and
	 * thus take the truncate lock before calling into the cluster
	 * layer.  In that case, however, we are not concerned with the CP
	 * blob being wiped out in the middle of the IO because there
	 * isn't anything to toss; the VM swapfile key stays in-core as
	 * long as the file is open.
	 */</span>

	off_rsrc_t off_rsrc = off_rsrc_make(buf_lblkno(bp) * GetLogicalBlockSize(vp),
										VNODE_IS_RSRC(vp));
	cp_io_params_t io_params;


	<span class="enscript-comment">/*
	 * We want to take the cnode lock here and because the vnode write
	 * count is a pseudo-lock, we need to do something to preserve
	 * lock ordering; the cnode lock comes before the write count.
	 * Ideally, the write count would be incremented after the
	 * strategy routine returns, but that becomes complicated if the
	 * strategy routine where to call buf_iodone before returning.
	 * For now, we drop the write count here and then pick it up again
	 * later.
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(buf_flags(bp), B_READ) &amp;&amp; !ISSET(buf_flags(bp), B_RAW))
		vnode_writedone(vp);

	hfs_lock_always(cp, HFS_SHARED_LOCK);
	cp_io_params(VTOHFS(vp), cp-&gt;c_cpentry, off_rsrc,
				 ISSET(buf_flags(bp), B_READ) ? VNODE_READ : VNODE_WRITE,
				 &amp;io_params);
	hfs_unlock(cp);

	<span class="enscript-comment">/*
	 * Last chance: If this data protected I/O does not have unwrapped
	 * keys present, then try to get them.  We already know that it
	 * should, by this point.
	 */</span>
	<span class="enscript-keyword">if</span> (!cpx_has_key(io_params.cpx)) {
		<span class="enscript-type">int</span> io_op = ( (buf_flags(bp) &amp; B_READ) ? CP_READ_ACCESS : CP_WRITE_ACCESS);
		errno_t error = cp_handle_vnop(vp, io_op, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/*
			 * We have to be careful here.  By this point in the I/O
			 * path, VM or the cluster engine has prepared a buf_t
			 * with the proper file offsets and all the rest, so
			 * simply erroring out will result in us leaking this
			 * particular buf_t.  We need to properly decorate the
			 * buf_t just as buf_strategy would so as to make it
			 * appear that the I/O errored out with the particular
			 * error code.
			 */</span>
			<span class="enscript-keyword">if</span> (!ISSET(buf_flags(bp), B_READ) &amp;&amp; !ISSET(buf_flags(bp), B_RAW))
				vnode_startwrite(vp);
			buf_seterror (bp, error);
			buf_biodone(bp);
			<span class="enscript-keyword">return</span> error;
		}

		hfs_lock_always(cp, HFS_SHARED_LOCK);
		cp_io_params(VTOHFS(vp), cp-&gt;c_cpentry, off_rsrc,
					 ISSET(buf_flags(bp), B_READ) ? VNODE_READ : VNODE_WRITE,
					 &amp;io_params);
		hfs_unlock(cp);
	}

	assert(buf_count(bp) &lt;= io_params.max_len);
	bufattr_setcpx(buf_attr(bp), io_params.cpx);

	<span class="enscript-keyword">if</span> (!ISSET(buf_flags(bp), B_READ) &amp;&amp; !ISSET(buf_flags(bp), B_RAW))
		vnode_startwrite(vp);

	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">else</span> // !<span class="enscript-variable-name">CONFIG_PROTECT</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_key_store_action</span>(<span class="enscript-type">int</span> action __unused)
{
	<span class="enscript-keyword">return</span> ENOTSUP;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">cp_register_wraps</span>(cp_wrap_func_t key_store_func __unused)
{
	<span class="enscript-keyword">return</span> ENOTSUP;
}

size_t <span class="enscript-function-name">cpx_size</span>(__unused size_t key_size)
{
	<span class="enscript-keyword">return</span> 0;
}

cpx_t <span class="enscript-function-name">cpx_alloc</span>(__unused size_t key_size)
{
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_free</span>(__unused cpx_t cpx)
{
}

bool <span class="enscript-function-name">cpx_is_sep_wrapped_key</span>(__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_is_sep_wrapped_key</span>(__unused <span class="enscript-type">struct</span> cpx *cpx, __unused bool v)
{
}

bool <span class="enscript-function-name">cpx_use_offset_for_iv</span>(__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_use_offset_for_iv</span>(__unused <span class="enscript-type">struct</span> cpx *cpx, __unused bool v)
{
}

uint16_t <span class="enscript-function-name">cpx_key_len</span>(__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">cpx_set_key_len</span>(__unused <span class="enscript-type">struct</span> cpx *cpx, __unused uint16_t key_len)
{
}

<span class="enscript-type">void</span> *<span class="enscript-function-name">cpx_key</span>(__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cpx *cpx)
{
	<span class="enscript-keyword">return</span> NULL;
}

aes_encrypt_ctx *<span class="enscript-function-name">cpx_iv_aes_ctx</span>(__unused cpx_t cpx)
{
	<span class="enscript-keyword">return</span> NULL;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_PROTECT */</span>
</pre>
<hr />
</body></html>