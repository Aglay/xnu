<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_catalog.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_catalog.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_catalog.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_format.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_endian.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesInternal.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/BTreesPrivate.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfscommon/headers/HFSUnicodeWrappers.h&quot;</span>


<span class="enscript-comment">/*
 * Initialization of an FSBufferDescriptor structure.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BDINIT</span>(bd, addr) { \
	(bd).bufferAddress = (addr); \
	(bd).itemSize = <span class="enscript-keyword">sizeof</span>(*(addr)); \
	(bd).itemCount = 1; \
}


<span class="enscript-type">struct</span> btobj {
	BTreeIterator		iterator;
	HFSPlusCatalogKey 	key;
	CatalogRecord		data;
};

<span class="enscript-type">struct</span> update_state {
	<span class="enscript-type">struct</span> cat_desc *	s_desc;	
	<span class="enscript-type">struct</span> cat_attr *	s_attr;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *	s_datafork;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *	s_rsrcfork;
	<span class="enscript-type">struct</span> hfsmount *	s_hfsmp;
};

<span class="enscript-type">struct</span> position_state {
	<span class="enscript-type">int</span>        error;
	u_int32_t  count;
	u_int32_t  index;
	u_int32_t  parentID;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
};

<span class="enscript-comment">/* Map file mode type to directory entry types */</span>
u_char modetodirtype[16] = {
	DT_REG, DT_FIFO, DT_CHR, DT_UNKNOWN,
	DT_DIR, DT_UNKNOWN, DT_BLK, DT_UNKNOWN,
	DT_REG, DT_UNKNOWN, DT_LNK, DT_UNKNOWN,
	DT_SOCK, DT_UNKNOWN, DT_WHT, DT_UNKNOWN
};
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MODE_TO_DT</span>(mode)  (modetodirtype[((mode) &amp; S_IFMT) &gt;&gt; 12])


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOOKUP_SYSFILE</span>	0x1	<span class="enscript-comment">/* If set, allow lookup of system files */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOOKUP_HARDLINK</span>	0x2	<span class="enscript-comment">/* If set, allow lookup of hard link records and not resolve the hard links */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOOKUP_CASESENSITIVE</span>	0x4	<span class="enscript-comment">/* If set, verify results of a file/directory record match input case */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookupbykey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, CatalogKey *keyp, <span class="enscript-type">int</span> flags, u_int32_t hint, <span class="enscript-type">int</span> wantrsrc,
                  <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp, cnid_t *desc_cnid);

<span class="enscript-type">int</span> <span class="enscript-function-name">cat_lookupmangled</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">int</span> wantrsrc,
                  <span class="enscript-type">struct</span> cat_desc *outdescp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp);

<span class="enscript-comment">/* Internal catalog support routines */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_findposition</span>(<span class="enscript-type">const</span> CatalogKey *ckp, <span class="enscript-type">const</span> CatalogRecord *crp,
                            <span class="enscript-type">struct</span> position_state *state);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">resolvelinkid</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t linkref, ino_t *ino);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">getkey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, CatalogKey * key);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">buildkey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp,
			HFSPlusCatalogKey *key, <span class="enscript-type">int</span> retry);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">buildthreadkey</span>(HFSCatalogNodeID parentID, <span class="enscript-type">int</span> std_hfs, CatalogKey *key);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">buildrecord</span>(<span class="enscript-type">struct</span> cat_attr *attrp, cnid_t cnid, <span class="enscript-type">int</span> std_hfs, u_int32_t encoding, CatalogRecord *crp, u_int32_t *recordSize);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">catrec_update</span>(<span class="enscript-type">const</span> CatalogKey *ckp, CatalogRecord *crp, <span class="enscript-type">struct</span> update_state *state);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">builddesc</span>(<span class="enscript-type">const</span> HFSPlusCatalogKey *key, cnid_t cnid, u_int32_t hint, u_int32_t encoding,
			<span class="enscript-type">int</span> isdir, <span class="enscript-type">struct</span> cat_desc *descp);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">getbsdattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp, <span class="enscript-type">struct</span> cat_attr * attrp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">promotekey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> HFSCatalogKey *hfskey, HFSPlusCatalogKey *keyp, u_int32_t *encoding);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">promotefork</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFile *file, <span class="enscript-type">int</span> resource, <span class="enscript-type">struct</span> cat_fork * forkp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">promoteattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> CatalogRecord *dataPtr, <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> cnid_t <span class="enscript-function-name">getcnid</span>(<span class="enscript-type">const</span> CatalogRecord *crp);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">getencoding</span>(<span class="enscript-type">const</span> CatalogRecord *crp);
<span class="enscript-type">static</span> cnid_t <span class="enscript-function-name">getparentcnid</span>(<span class="enscript-type">const</span> CatalogRecord *recp);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">isadir</span>(<span class="enscript-type">const</span> CatalogRecord *crp);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">buildthread</span>(<span class="enscript-type">void</span> *keyp, <span class="enscript-type">void</span> *recp, <span class="enscript-type">int</span> std_hfs, <span class="enscript-type">int</span> directory);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_makealias</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t inode_num, <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cat_update_internal</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> update_hardlink, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dataforkp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *rsrcforkp);



<span class="enscript-comment">/* HFS ID Hashtable Functions */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IDHASH</span>(hfsmp, inum) (&amp;hfsmp-&gt;hfs_idhashtbl[(inum) &amp; hfsmp-&gt;hfs_idhash])

<span class="enscript-comment">/* Initialize the HFS ID hash table */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_idhash_init</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	<span class="enscript-comment">/* secured by catalog lock so no lock init needed */</span>
	hfsmp-&gt;hfs_idhashtbl = hashinit(HFS_IDHASH_DEFAULT, M_HFSMNT, &amp;hfsmp-&gt;hfs_idhash);	
}

<span class="enscript-comment">/* Free the HFS ID hash table */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_idhash_destroy</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp) {
	<span class="enscript-comment">/* during failed mounts &amp; unmounts */</span>
	FREE(hfsmp-&gt;hfs_idhashtbl, M_HFSMNT);
}

<span class="enscript-comment">/*
from hfs_catalog.h:
typedef struct cat_preflightid {
	cnid_t fileid;
	LIST_ENTRY(cat_preflightid) id_hash;
} cat_preflightid_t;

from hfs.h:
  u_long hfs_idhash; / size of cnid/fileid hash table -1 /
  LIST_HEAD(idhashhead, cat_preflightid) *hfs_idhashtbl; / base of ID hash /
*/</span>

<span class="enscript-comment">/* 
 * Check the run-time ID hashtable.  
 * 
 * The catalog lock must be held (like other functions in this file).
 *
 * Returns: 
 * 		1 if the ID is in the hash table.
 *		0 if the ID is not in the hash table
 */</span> 
<span class="enscript-type">int</span> <span class="enscript-function-name">cat_check_idhash</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t test_fileid) {

	cat_preflightid_t *preflight;
	<span class="enscript-type">int</span> found = 0;

	<span class="enscript-keyword">for</span> (preflight = IDHASH(hfsmp, test_fileid)-&gt;lh_first; preflight ; preflight = preflight-&gt;id_hash.le_next) {
		<span class="enscript-keyword">if</span> (preflight-&gt;fileid == test_fileid) {
			found = 1;
			<span class="enscript-keyword">break</span>;	
		}
	}

	<span class="enscript-keyword">return</span> found;   	
}

<span class="enscript-comment">/* Insert the supplied preflight into the ID hash table */</span> 
<span class="enscript-type">int</span> <span class="enscript-function-name">cat_insert_idhash</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cat_preflightid_t *preflight) {

	<span class="enscript-keyword">if</span> (preflight) {
		LIST_INSERT_HEAD(IDHASH(hfsmp, (preflight-&gt;fileid)), preflight, id_hash);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">return</span> -1;
}


<span class="enscript-comment">/* Remove the data structure with the specified ID from the hashtable */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">cat_remove_idhash</span> (cat_preflightid_t *preflight) {
	
	<span class="enscript-keyword">if</span> ((preflight) &amp;&amp; ((preflight-&gt;id_hash.le_next || preflight-&gt;id_hash.le_prev))) {
		LIST_REMOVE (preflight, id_hash);
		preflight-&gt;id_hash.le_next = NULL;
		preflight-&gt;id_hash.le_prev = NULL;

		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">/*
 * Acquire a new CNID for use.  
 * 
 * This is slightly more complicated than just pulling the value from the
 * hfsmount data structure.  We need to validate that the ID is not in-use
 * even if we've not wrapped around and that there are not any lingering
 * or orphaned fileIDs for this ID. 
 *
 * Also validate that there are not any pending insertions into the
 * catalog by checking the ID hash table. 
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">cat_acquire_cnid</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t *new_cnid) 
{
	uint32_t nextCNID;
	<span class="enscript-type">struct</span> BTreeIterator *iterator;
	FSBufferDescriptor btdata;
	uint16_t datasize;
	CatalogRecord *recp;
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> std_hfs;
	<span class="enscript-type">int</span> wrapped = 0;

	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);
	<span class="enscript-comment">/*
	 * Get the next CNID. We can change it since we hold the catalog lock.
	 */</span>
<span class="enscript-reference">nextid</span>:
	nextCNID = hfsmp-&gt;vcbNxtCNID;
	<span class="enscript-keyword">if</span> (nextCNID == 0xFFFFFFFF) {
		<span class="enscript-keyword">if</span> (std_hfs) {
			<span class="enscript-keyword">return</span> (ENOSPC);
		} <span class="enscript-keyword">else</span> {
			wrapped++;
			<span class="enscript-keyword">if</span> (wrapped &gt; 1) {
				<span class="enscript-comment">/* don't allow more than one wrap-around */</span>
				<span class="enscript-keyword">return</span> ENOSPC;
			}
			hfs_lock_mount (hfsmp);
			hfsmp-&gt;vcbNxtCNID = kHFSFirstUserCatalogNodeID;
			hfsmp-&gt;vcbAtrb |= kHFSCatalogNodeIDsReusedMask;
			hfs_unlock_mount (hfsmp);
		}
	} <span class="enscript-keyword">else</span> {
		hfsmp-&gt;vcbNxtCNID++;
	}
	hfs_note_header_minor_change(hfsmp);

	<span class="enscript-comment">/* First check that there are not any entries pending in the hash table with this ID */</span>
	<span class="enscript-keyword">if</span> (cat_check_idhash (hfsmp, nextCNID)) {
		<span class="enscript-comment">/* Someone wants to insert this into the catalog but hasn't done so yet. Skip it */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextid</span>;
	}

	<span class="enscript-comment">/* Check to see if a thread record exists for the target ID we just got */</span>
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	buildthreadkey(nextCNID, std_hfs, (CatalogKey *)&amp;iterator-&gt;key);

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);

	result = BTSearchRecord(hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork, iterator, &amp;btdata, &amp;datasize, iterator);
	FREE (recp, M_TEMP);
	FREE (iterator, M_TEMP);

	<span class="enscript-keyword">if</span> (result == btNotFound) {
		<span class="enscript-comment">/* Good.  File ID was not in use. Move on to checking EA B-Tree */</span>
		result = file_attribute_exist (hfsmp, nextCNID);
		<span class="enscript-keyword">if</span> (result == EEXIST) {
			<span class="enscript-comment">/* This CNID has orphaned EAs.  Skip it and move on to the next one */</span>
			result = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextid</span>;
		}
		<span class="enscript-keyword">if</span> (result) {
			<span class="enscript-comment">/* For any other error, return the result */</span>
			<span class="enscript-keyword">return</span> result;
		}

		<span class="enscript-comment">/*
		 * Now validate that there are no lingering cnodes with this ID.  If a cnode
		 * has been removed on-disk (marked C_NOEXISTS), but has not yet been reclaimed,
		 * then it will still have an entry in the cnode hash table.  This means that
		 * a subsequent lookup will find THAT entry and believe this one has been deleted
		 * prematurely.  If there is a lingering cnode, then just skip this entry and move on.
		 * 
		 * Note that we pass (existence_only == 1) argument to hfs_chash_snoop.
		 */</span>
		<span class="enscript-keyword">if</span> (!std_hfs &amp;&amp; (hfsmp-&gt;vcbAtrb &amp; kHFSCatalogNodeIDsReusedMask)) {
			<span class="enscript-keyword">if</span> (hfs_chash_snoop (hfsmp, nextCNID, 1, NULL, NULL) == 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextid</span>;
			}
		}

		<span class="enscript-comment">/* 
		 * If we get here, then we didn't see any thread records, orphaned EAs, 
	     * or stale cnodes. This ID is safe to vend out.
		 */</span>
		*new_cnid = nextCNID;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result == noErr) {
		<span class="enscript-comment">/* move on to the next ID */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextid</span>;
	}	
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* For any other situation, just bail out */</span>
		<span class="enscript-keyword">return</span> EIO; 
	}

	<span class="enscript-keyword">return</span> 0;	

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_preflight</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, catops_t ops, cat_cookie_t *cookie, __unused proc_t p)
{
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_cp-&gt;c_lockowner != current_thread())
		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);
	 
	result = BTReserveSpace(hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork, ops, (<span class="enscript-type">void</span>*)cookie);

	<span class="enscript-keyword">if</span> (lockflags)
		hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">cat_postflight</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cat_cookie_t *cookie, __unused proc_t p)
{
	<span class="enscript-type">int</span> lockflags = 0;

	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_cp-&gt;c_lockowner != current_thread())
		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

	(<span class="enscript-type">void</span>) BTReleaseReserve(hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork, (<span class="enscript-type">void</span>*)cookie);

	<span class="enscript-keyword">if</span> (lockflags)
		hfs_systemfile_unlock(hfsmp, lockflags);
}

__private_extern__ 
<span class="enscript-type">void</span>
<span class="enscript-function-name">cat_convertattr</span>(
	<span class="enscript-type">struct</span> hfsmount *hfsmp,
	CatalogRecord * recp,
	<span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">struct</span> cat_fork *datafp,
	<span class="enscript-type">struct</span> cat_fork *rsrcfp)
{
	<span class="enscript-type">int</span> std_hfs = HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord;

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		getbsdattr(hfsmp, (<span class="enscript-type">struct</span> HFSPlusCatalogFile *)recp, attrp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> HFSPlusCatalogFile cnoderec;

		promoteattr(hfsmp, recp, &amp;cnoderec);
		getbsdattr(hfsmp, &amp;cnoderec, attrp);
	} 
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (isadir(recp)) {
		bzero(datafp, <span class="enscript-keyword">sizeof</span>(*datafp));
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (std_hfs) {
		promotefork(hfsmp, (HFSCatalogFile *)&amp;recp-&gt;hfsFile, 0, datafp);
		promotefork(hfsmp, (HFSCatalogFile *)&amp;recp-&gt;hfsFile, 1, rsrcfp);
	} 
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Convert the data fork. */</span>
		datafp-&gt;cf_size = recp-&gt;hfsPlusFile.dataFork.logicalSize;
		datafp-&gt;cf_new_size = 0;
		datafp-&gt;cf_blocks = recp-&gt;hfsPlusFile.dataFork.totalBlocks;
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfc_stage == HFC_RECORDING) &amp;&amp;
		    (attrp-&gt;ca_atime &gt;= hfsmp-&gt;hfc_timebase)) {
			datafp-&gt;cf_bytesread =
				recp-&gt;hfsPlusFile.dataFork.clumpSize *
				HFSTOVCB(hfsmp)-&gt;blockSize;
		} <span class="enscript-keyword">else</span> {
			datafp-&gt;cf_bytesread = 0;
		}
		datafp-&gt;cf_vblocks = 0;
		bcopy(&amp;recp-&gt;hfsPlusFile.dataFork.extents[0],
		      &amp;datafp-&gt;cf_extents[0], <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));

		<span class="enscript-comment">/* Convert the resource fork. */</span>
		rsrcfp-&gt;cf_size = recp-&gt;hfsPlusFile.resourceFork.logicalSize;
		rsrcfp-&gt;cf_new_size = 0;
		rsrcfp-&gt;cf_blocks = recp-&gt;hfsPlusFile.resourceFork.totalBlocks;
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfc_stage == HFC_RECORDING) &amp;&amp;
		    (attrp-&gt;ca_atime &gt;= hfsmp-&gt;hfc_timebase)) {
			datafp-&gt;cf_bytesread =
				recp-&gt;hfsPlusFile.resourceFork.clumpSize *
				HFSTOVCB(hfsmp)-&gt;blockSize;
		} <span class="enscript-keyword">else</span> {
			datafp-&gt;cf_bytesread = 0;
		}
		rsrcfp-&gt;cf_vblocks = 0;
		bcopy(&amp;recp-&gt;hfsPlusFile.resourceFork.extents[0],
		      &amp;rsrcfp-&gt;cf_extents[0], <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
	}
}

<span class="enscript-comment">/*
 * Convert a raw catalog key and record into an in-core catalog descriptor.
 *
 * Note: The caller is responsible for releasing the catalog descriptor.
 */</span>
__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_convertkey</span>(
	<span class="enscript-type">struct</span> hfsmount *hfsmp,
	CatalogKey *key,
	CatalogRecord * recp,
	<span class="enscript-type">struct</span> cat_desc *descp)
{
	<span class="enscript-type">int</span> std_hfs = HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord;
	HFSPlusCatalogKey * pluskey = NULL;
	u_int32_t encoding;
	cnid_t cnid = 0;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		pluskey = (HFSPlusCatalogKey *)key;
		encoding = getencoding(recp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
		promotekey(hfsmp, (HFSCatalogKey *)key, pluskey, &amp;encoding);
	}
#<span class="enscript-reference">endif</span>
  
	<span class="enscript-comment">/* Get the CNID before calling builddesc.  Need to error check it. */</span>
	cnid = getcnid(recp);
	<span class="enscript-keyword">if</span> (cnid == 0) {
		<span class="enscript-comment">/* If ths CNID == 0, it's invalid. Mark as corrupt */</span>
		hfs_mark_inconsistent (hfsmp, HFS_INCONSISTENCY_DETECTED);
		err = EINVAL;
	}
	<span class="enscript-keyword">else</span> {
		builddesc(pluskey, cnid, 0, encoding, isadir(recp), descp);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (std_hfs) {
		FREE(pluskey, M_TEMP);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * cat_releasedesc
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">cat_releasedesc</span>(<span class="enscript-type">struct</span> cat_desc *descp)
{
	<span class="enscript-type">const</span> u_int8_t * name;

	<span class="enscript-keyword">if</span> (descp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((descp-&gt;cd_flags &amp; CD_HASBUF) &amp;&amp;
	    (descp-&gt;cd_nameptr != NULL)) {
	    	name = descp-&gt;cd_nameptr;
		descp-&gt;cd_nameptr = NULL;
		descp-&gt;cd_namelen = 0;
		vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)name);
	}
	descp-&gt;cd_nameptr = NULL;
	descp-&gt;cd_namelen = 0;
	descp-&gt;cd_flags &amp;= ~CD_HASBUF;
}

<span class="enscript-comment">/*
 * These Catalog functions allow access to the HFS Catalog (database).
 * The catalog b-tree lock must be acquired before calling any of these routines.
 */</span>

<span class="enscript-comment">/*
 * cat_lookup - lookup a catalog node using a cnode descriptor
 *
 * Note: The caller is responsible for releasing the output
 * catalog descriptor (when supplied outdescp is non-null).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">int</span> wantrsrc, <span class="enscript-type">int</span> force_casesensitive_lookup,
             <span class="enscript-type">struct</span> cat_desc *outdescp, <span class="enscript-type">struct</span> cat_attr *attrp,
             <span class="enscript-type">struct</span> cat_fork *forkp, cnid_t *desc_cnid)
{
	CatalogKey * keyp;
	<span class="enscript-type">int</span> std_hfs;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> flags;

	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);
	flags = force_casesensitive_lookup ? HFS_LOOKUP_CASESENSITIVE : 0;

	MALLOC(keyp, CatalogKey *, <span class="enscript-keyword">sizeof</span>(CatalogKey), M_TEMP, M_WAITOK);

	result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)keyp, 1);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	result = cat_lookupbykey(hfsmp, keyp, flags, descp-&gt;cd_hint, wantrsrc, outdescp, attrp, forkp, desc_cnid);
	
	<span class="enscript-keyword">if</span> (result == ENOENT) {
		<span class="enscript-keyword">if</span> (!std_hfs) {
			<span class="enscript-type">struct</span> cat_desc temp_desc;
			<span class="enscript-keyword">if</span> (outdescp == NULL) {
				bzero(&amp;temp_desc, <span class="enscript-keyword">sizeof</span>(temp_desc));
				outdescp = &amp;temp_desc;
			}
			result = cat_lookupmangled(hfsmp, descp, wantrsrc, outdescp, attrp, forkp);
			<span class="enscript-keyword">if</span> (desc_cnid) {
			    *desc_cnid = outdescp-&gt;cd_cnid;
			}
			<span class="enscript-keyword">if</span> (outdescp == &amp;temp_desc) {
				<span class="enscript-comment">/* Release the local copy of desc */</span>
				cat_releasedesc(outdescp);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_encoding != kTextEncodingMacRoman) {
		<span class="enscript-comment">//	make MacRoman key from utf-8
</span>		<span class="enscript-comment">//	result = cat_lookupbykey(hfsmp, keyp, descp-&gt;cd_hint, attrp, forkp);
</span>		<span class="enscript-comment">//	update desc text encoding so that other catalog ops succeed
</span>		}
	}
<span class="enscript-reference">exit</span>:	
	FREE(keyp, M_TEMP);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_insertfilethread</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp)
{
	<span class="enscript-type">struct</span> BTreeIterator *iterator;
	<span class="enscript-type">struct</span> FSBufferDescriptor file_data;
	<span class="enscript-type">struct</span> HFSCatalogFile file_rec;
	u_int16_t datasize;
	FCB *fcb;
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (HFSTOVCB(hfsmp)-&gt;vcbSigWord != kHFSSigWord)
		<span class="enscript-keyword">return</span> (EINVAL);

	fcb = GetFileControlBlock(HFSTOVCB(hfsmp)-&gt;catalogRefNum);

	MALLOC(iterator, BTreeIterator *, 2 * <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(&amp;iterator[0], 2* <span class="enscript-keyword">sizeof</span>(*iterator));
	result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)&amp;iterator[0].key, 0);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	BDINIT(file_data, &amp;file_rec);
	result = BTSearchRecord(fcb, &amp;iterator[0], &amp;file_data, &amp;datasize, &amp;iterator[0]);
	<span class="enscript-keyword">if</span> (result) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-keyword">if</span> (file_rec.recordType != kHFSFileRecord) {
		result = EISDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> ((file_rec.flags &amp; kHFSThreadExistsMask) == 0) {
		<span class="enscript-type">struct</span> FSBufferDescriptor thread_data;
		<span class="enscript-type">struct</span> HFSCatalogThread thread_rec;

		file_rec.flags |= kHFSThreadExistsMask;
		BDINIT(thread_data, &amp;thread_rec);
		thread_data.itemSize = buildthread(&amp;iterator[0].key, &amp;thread_rec, 1, 0);
		buildthreadkey(file_rec.fileID, 1, (CatalogKey *)&amp;iterator[1].key);
	
		result = BTInsertRecord(fcb, &amp;iterator[1], &amp;thread_data, thread_data.itemSize);
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	
		(<span class="enscript-type">void</span>) BTReplaceRecord(fcb, &amp;iterator[0], &amp;file_data, datasize);
		(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	}	
<span class="enscript-reference">exit</span>:
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_findname - obtain a descriptor from cnid
 *
 * Only a thread lookup is performed.
 *
 * Note: The caller is responsible for releasing the output
 * catalog descriptor (when supplied outdescp is non-null).

 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_findname</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, <span class="enscript-type">struct</span> cat_desc *outdescp)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator;
	FSBufferDescriptor btdata;
	CatalogKey * keyp;
	CatalogRecord * recp;
	<span class="enscript-type">int</span> isdir;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> std_hfs;

	isdir = 0;
	std_hfs = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	buildthreadkey(cnid, std_hfs, (CatalogKey *)&amp;iterator-&gt;key);
	iterator-&gt;hint.nodeNum = 0;

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);

	result = BTSearchRecord(VTOF(hfsmp-&gt;hfs_catalog_vp), iterator, &amp;btdata, NULL, NULL);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Turn thread record into a cnode key (in place). */</span>
	<span class="enscript-keyword">switch</span> (recp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderThreadRecord</span>:
			isdir = 1;
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileThreadRecord</span>:
			keyp = (CatalogKey *)((<span class="enscript-type">char</span> *)&amp;recp-&gt;hfsThread.reserved + 6);
			keyp-&gt;hfs.keyLength = kHFSCatalogKeyMinimumLength + keyp-&gt;hfs.nodeName[0];
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderThreadRecord</span>:
			isdir = 1;
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileThreadRecord</span>:
			keyp = (CatalogKey *)&amp;recp-&gt;hfsPlusThread.reserved;
			keyp-&gt;hfsPlus.keyLength = kHFSPlusCatalogKeyMinimumLength +
				(keyp-&gt;hfsPlus.nodeName.length * 2);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			result = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		builddesc((HFSPlusCatalogKey *)keyp, cnid, 0, 0, isdir, outdescp);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		HFSPlusCatalogKey * pluskey = NULL;
		u_int32_t encoding;

		MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
		promotekey(hfsmp, &amp;keyp-&gt;hfs, pluskey, &amp;encoding);
		builddesc(pluskey, cnid, 0, encoding, isdir, outdescp);
		FREE(pluskey, M_TEMP);
	}
#<span class="enscript-reference">endif</span>	

<span class="enscript-reference">exit</span>:
	FREE(recp, M_TEMP);
	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-comment">/*
 * cat_idlookup - lookup a catalog node using a cnode id
 *
 * Note: The caller is responsible for releasing the output
 * catalog descriptor (when supplied outdescp is non-null).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_idlookup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, <span class="enscript-type">int</span> allow_system_files, <span class="enscript-type">int</span> wantrsrc,
    <span class="enscript-type">struct</span> cat_desc *outdescp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator;
	FSBufferDescriptor btdata;
	u_int16_t	datasize;
	CatalogKey * keyp;
	CatalogRecord * recp;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> std_hfs;

	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	buildthreadkey(cnid, std_hfs, (CatalogKey *)&amp;iterator-&gt;key);

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);

	result = BTSearchRecord(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), iterator,
				&amp;btdata, &amp;datasize, iterator);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Turn thread record into a cnode key (in place) */</span>
	<span class="enscript-keyword">switch</span> (recp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileThreadRecord</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderThreadRecord</span>:
			keyp = (CatalogKey *)((<span class="enscript-type">char</span> *)&amp;recp-&gt;hfsThread.reserved + 6);

			<span class="enscript-comment">/* check for NULL name */</span>
			<span class="enscript-keyword">if</span> (keyp-&gt;hfs.nodeName[0] == 0) {
				result = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}

			keyp-&gt;hfs.keyLength = kHFSCatalogKeyMinimumLength + keyp-&gt;hfs.nodeName[0];
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileThreadRecord</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderThreadRecord</span>:
			keyp = (CatalogKey *)&amp;recp-&gt;hfsPlusThread.reserved;

			<span class="enscript-comment">/* check for NULL name */</span>
			<span class="enscript-keyword">if</span> (keyp-&gt;hfsPlus.nodeName.length == 0) {
				result = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}

			keyp-&gt;hfsPlus.keyLength = kHFSPlusCatalogKeyMinimumLength +
				(keyp-&gt;hfsPlus.nodeName.length * 2);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			result = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	result = cat_lookupbykey(hfsmp, keyp, 
			((allow_system_files != 0) ? HFS_LOOKUP_SYSFILE : 0), 
			0, wantrsrc, outdescp, attrp, forkp, NULL);
	<span class="enscript-comment">/* No corresponding file/folder record found for a thread record,
	 * mark the volume inconsistent.
	 */</span>
	<span class="enscript-keyword">if</span> (result == 0 &amp;&amp; outdescp) {
		cnid_t dcnid = outdescp-&gt;cd_cnid;
		<span class="enscript-comment">/*
		 * Just for sanity's case, let's make sure that
		 * the key in the thread matches the key in the record.
		 */</span>
		<span class="enscript-keyword">if</span> (cnid != dcnid) {
			printf(<span class="enscript-string">&quot;hfs: cat_idlookup: Requested cnid (%d / %08x) != dcnid (%d / %08x)\n&quot;</span>, cnid, cnid, dcnid, dcnid);
			result = ENOENT;
		}
	}
<span class="enscript-reference">exit</span>:
	FREE(recp, M_TEMP);
	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_lookupmangled - lookup a catalog node using a mangled name
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookupmangled</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">int</span> wantrsrc,
                  <span class="enscript-type">struct</span> cat_desc *outdescp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp)
{
	cnid_t fileID;
	u_int32_t prefixlen;
	<span class="enscript-type">int</span> result;
	u_int8_t utf8[NAME_MAX + 1];
	u_int32_t utf8len;
	u_int16_t unicode[kHFSPlusMaxFileNameChars + 1];
	size_t unicodelen;
	
	<span class="enscript-keyword">if</span> (wantrsrc)
		<span class="enscript-keyword">return</span> (ENOENT);

	fileID = GetEmbeddedFileID(descp-&gt;cd_nameptr, descp-&gt;cd_namelen, &amp;prefixlen);
	<span class="enscript-keyword">if</span> (fileID &lt; (cnid_t)kHFSFirstUserCatalogNodeID)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">if</span> (fileID == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
		fileID == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid ||
		fileID == hfsmp-&gt;hfs_jnlfileid ||
		fileID == hfsmp-&gt;hfs_jnlinfoblkid) {
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	result = cat_idlookup(hfsmp, fileID, 0, 0, outdescp, attrp, forkp);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">return</span> (ENOENT);
	<span class="enscript-comment">/* It must be in the correct directory */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_parentcnid != outdescp-&gt;cd_parentcnid)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">falsematch</span>;

	<span class="enscript-comment">/*
	 * Compare the mangled version of file name looked up from the 
	 * disk with the mangled name provided by the user.  Note that 
	 * this comparison is case-sensitive, which should be fine
	 * since we're trying to prevent user space from constructing
	 * a mangled name that differs from the one they'd get from the
	 * file system.
	 */</span>
	result = utf8_decodestr(outdescp-&gt;cd_nameptr, outdescp-&gt;cd_namelen,
			unicode, &amp;unicodelen, <span class="enscript-keyword">sizeof</span>(unicode), <span class="enscript-string">':'</span>, 0);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">falsematch</span>;
	}
	result = ConvertUnicodeToUTF8Mangled(unicodelen, unicode, 
			<span class="enscript-keyword">sizeof</span>(utf8), &amp;utf8len, utf8, fileID);
	<span class="enscript-keyword">if</span> ((result != 0) || 
	    ((u_int16_t)descp-&gt;cd_namelen != utf8len) ||
	    (bcmp(descp-&gt;cd_nameptr, utf8, utf8len) != 0)) { 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">falsematch</span>;
	}

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">falsematch</span>:
	cat_releasedesc(outdescp);
	<span class="enscript-keyword">return</span> (ENOENT);
}


<span class="enscript-comment">/*
 * cat_lookupbykey - lookup a catalog node using a cnode key
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookupbykey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, CatalogKey *keyp, <span class="enscript-type">int</span> flags, u_int32_t hint, <span class="enscript-type">int</span> wantrsrc,
                  <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp, cnid_t *desc_cnid)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator;
	FSBufferDescriptor btdata;
	CatalogRecord * recp;
	u_int16_t  datasize;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> std_hfs;
	u_int32_t ilink = 0;
	cnid_t cnid = 0;
	u_int32_t encoding = 0;
	cnid_t parentid = 0;

	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	iterator-&gt;hint.nodeNum = hint;
	bcopy(keyp, &amp;iterator-&gt;key, <span class="enscript-keyword">sizeof</span>(CatalogKey));

	result = BTSearchRecord(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), iterator,
				&amp;btdata, &amp;datasize, iterator);
	<span class="enscript-keyword">if</span> (result) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Save the cnid, parentid, and encoding now in case there's a hard link or inode */</span>
	cnid = getcnid(recp);
	<span class="enscript-keyword">if</span> (cnid == 0) {
		<span class="enscript-comment">/* CNID of 0 is invalid.  Mark as corrupt */</span>
		hfs_mark_inconsistent (hfsmp, HFS_INCONSISTENCY_DETECTED);
		result = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		parentid = keyp-&gt;hfsPlus.parentID;
	}
	
	encoding = getencoding(recp);
	hint = iterator-&gt;hint.nodeNum;

	<span class="enscript-comment">/* Hide the journal files (if any) */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;jnl || ((HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY))) &amp;&amp;
		((cnid == hfsmp-&gt;hfs_jnlfileid) || (cnid == hfsmp-&gt;hfs_jnlinfoblkid)) &amp;&amp;
		 !(flags &amp; HFS_LOOKUP_SYSFILE)) {
		result = ERESERVEDNAME;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (!std_hfs &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_CASE_SENSITIVE)) {
		<span class="enscript-comment">/* Make sure the case of the file was correct if requested */</span>
		<span class="enscript-keyword">if</span> (flags &amp; HFS_LOOKUP_CASESENSITIVE) {
			<span class="enscript-keyword">if</span> (0 != cat_binarykeycompare(&amp;keyp-&gt;hfsPlus, (HFSPlusCatalogKey *)&amp;iterator-&gt;key)) {
				result = ERESERVEDNAME;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		}
	}
	
	<span class="enscript-comment">/*
	 * When a hardlink link is encountered, auto resolve it.
	 *
	 * The catalog record will change, and possibly its type.
	 */</span>
	<span class="enscript-keyword">if</span> (!std_hfs
	    &amp;&amp; (attrp || forkp) 
	    &amp;&amp; (recp-&gt;recordType == kHFSPlusFileRecord)
	    &amp;&amp; ((to_bsd_time(recp-&gt;hfsPlusFile.createDate) == (time_t)hfsmp-&gt;hfs_itime) ||
	        (to_bsd_time(recp-&gt;hfsPlusFile.createDate) == (time_t)hfsmp-&gt;hfs_metadata_createdate))) {
		<span class="enscript-type">int</span> isdirlink = 0;
		<span class="enscript-type">int</span> isfilelink = 0;

		<span class="enscript-keyword">if</span> ((SWAP_BE32(recp-&gt;hfsPlusFile.userInfo.fdType) == kHardLinkFileType) &amp;&amp;
		    (SWAP_BE32(recp-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSPlusCreator)) {
			isfilelink = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((recp-&gt;hfsPlusFile.flags &amp; kHFSHasLinkChainMask) &amp;&amp; 
		           (SWAP_BE32(recp-&gt;hfsPlusFile.userInfo.fdType) == kHFSAliasType) &amp;&amp; 
			   (SWAP_BE32(recp-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSAliasCreator)) {
			isdirlink = 1;
		}
		<span class="enscript-keyword">if</span> ((isfilelink || isdirlink) &amp;&amp; !(flags &amp; HFS_LOOKUP_HARDLINK)) {
			ilink = recp-&gt;hfsPlusFile.hl_linkReference;
			(<span class="enscript-type">void</span>) cat_resolvelink(hfsmp, ilink, isdirlink, (<span class="enscript-type">struct</span> HFSPlusCatalogFile *)recp);
		}
	}

	<span class="enscript-keyword">if</span> (attrp != NULL) { 
		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			getbsdattr(hfsmp, (<span class="enscript-type">struct</span> HFSPlusCatalogFile *)recp, attrp);
			<span class="enscript-keyword">if</span> (ilink) {
				<span class="enscript-comment">/* Update the inode number for this hard link */</span>
				attrp-&gt;ca_linkref = ilink;
			}
			
			<span class="enscript-comment">/* 
			 * Set kHFSHasLinkChainBit for hard links, and reset it for all 
			 * other items.  Also set linkCount to 1 for regular files.
			 *
			 * Due to some bug (rdar://8505977), some regular files can have 
			 * kHFSHasLinkChainBit set and linkCount more than 1 even if they 
			 * are not really hard links.  The runtime code should not consider 
			 * these files has hard links.  Therefore we reset the kHFSHasLinkChainBit 
			 * and linkCount for regular file before we vend it out.  This might 
			 * also result in repairing the bad files on disk, if the corresponding 
			 * file is modified and updated on disk.  
			 */</span>
			<span class="enscript-keyword">if</span> (ilink) {
				<span class="enscript-comment">/* This is a hard link and the link count bit was not set */</span>
				<span class="enscript-keyword">if</span> (!(attrp-&gt;ca_recflags &amp; kHFSHasLinkChainMask)) {
					printf (<span class="enscript-string">&quot;hfs: set hardlink bit on vol=%s cnid=%u inoid=%u\n&quot;</span>, hfsmp-&gt;vcbVN, cnid, ilink);
					attrp-&gt;ca_recflags |= kHFSHasLinkChainMask;
				}
			} <span class="enscript-keyword">else</span> { 
				<span class="enscript-comment">/* Make sure that this non-hard link (regular) record is not 
				 * an inode record that was looked up and we do not end up 
				 * reseting the hard link bit on it.
				 */</span>
				<span class="enscript-keyword">if</span> ((parentid != hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) &amp;&amp; 
				    (parentid != hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid)) {
					<span class="enscript-comment">/* This is not a hard link or inode and the link count bit was set */</span>
					<span class="enscript-keyword">if</span> (attrp-&gt;ca_recflags &amp; kHFSHasLinkChainMask) {
						printf (<span class="enscript-string">&quot;hfs: clear hardlink bit on vol=%s cnid=%u\n&quot;</span>, hfsmp-&gt;vcbVN, cnid);
						attrp-&gt;ca_recflags &amp;= ~kHFSHasLinkChainMask;
					}
					<span class="enscript-comment">/* This is a regular file and the link count was more than 1 */</span>
					<span class="enscript-keyword">if</span> (S_ISREG(attrp-&gt;ca_mode) &amp;&amp; (attrp-&gt;ca_linkcount &gt; 1)) {
						printf (<span class="enscript-string">&quot;hfs: set linkcount=1 on vol=%s cnid=%u old=%u\n&quot;</span>, hfsmp-&gt;vcbVN, cnid, attrp-&gt;ca_linkcount);
						attrp-&gt;ca_linkcount = 1;
					}
				}
			}
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> HFSPlusCatalogFile cnoderec;

			promoteattr(hfsmp, recp, &amp;cnoderec);
			getbsdattr(hfsmp, &amp;cnoderec, attrp);	
		}
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">if</span> (forkp != NULL) {
		<span class="enscript-keyword">if</span> (isadir(recp)) {
			bzero(forkp, <span class="enscript-keyword">sizeof</span>(*forkp));
		} 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (std_hfs) {
			promotefork(hfsmp, (HFSCatalogFile *)&amp;recp-&gt;hfsFile, wantrsrc, forkp);
		} 
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wantrsrc) {
			<span class="enscript-comment">/* Convert the resource fork. */</span>
			forkp-&gt;cf_size = recp-&gt;hfsPlusFile.resourceFork.logicalSize;
			forkp-&gt;cf_new_size = 0;
			forkp-&gt;cf_blocks = recp-&gt;hfsPlusFile.resourceFork.totalBlocks;
			<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfc_stage == HFC_RECORDING) &amp;&amp;
			    (to_bsd_time(recp-&gt;hfsPlusFile.accessDate) &gt;= hfsmp-&gt;hfc_timebase)) {
				forkp-&gt;cf_bytesread =
					recp-&gt;hfsPlusFile.resourceFork.clumpSize *
					HFSTOVCB(hfsmp)-&gt;blockSize;
			} <span class="enscript-keyword">else</span> {
				forkp-&gt;cf_bytesread = 0;
			}
			forkp-&gt;cf_vblocks = 0;
			bcopy(&amp;recp-&gt;hfsPlusFile.resourceFork.extents[0],
			      &amp;forkp-&gt;cf_extents[0], <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> i;
			u_int32_t validblks;

			<span class="enscript-comment">/* Convert the data fork. */</span>
			forkp-&gt;cf_size = recp-&gt;hfsPlusFile.dataFork.logicalSize;
			forkp-&gt;cf_new_size = 0;
			forkp-&gt;cf_blocks = recp-&gt;hfsPlusFile.dataFork.totalBlocks;
			<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfc_stage == HFC_RECORDING) &amp;&amp;
			    (to_bsd_time(recp-&gt;hfsPlusFile.accessDate) &gt;= hfsmp-&gt;hfc_timebase)) {
				forkp-&gt;cf_bytesread =
					recp-&gt;hfsPlusFile.dataFork.clumpSize *
					HFSTOVCB(hfsmp)-&gt;blockSize;
			} <span class="enscript-keyword">else</span> {
				forkp-&gt;cf_bytesread = 0;
			}
			forkp-&gt;cf_vblocks = 0;
			bcopy(&amp;recp-&gt;hfsPlusFile.dataFork.extents[0],
			      &amp;forkp-&gt;cf_extents[0], <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));

			<span class="enscript-comment">/* Validate the fork's resident extents. */</span>
			validblks = 0;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSPlusExtentDensity; ++i) {
				<span class="enscript-keyword">if</span> (forkp-&gt;cf_extents[i].startBlock + forkp-&gt;cf_extents[i].blockCount &gt;= hfsmp-&gt;totalBlocks) {
					<span class="enscript-comment">/* Suppress any bad extents so a remove can succeed. */</span>
					forkp-&gt;cf_extents[i].startBlock = 0;
					forkp-&gt;cf_extents[i].blockCount = 0;
					<span class="enscript-comment">/* Disable writes */</span>
					<span class="enscript-keyword">if</span> (attrp != NULL) {
						attrp-&gt;ca_mode &amp;= S_IFMT | S_IRUSR | S_IRGRP | S_IROTH;
					}
				} <span class="enscript-keyword">else</span> {
					validblks += forkp-&gt;cf_extents[i].blockCount;
				}
			}
			<span class="enscript-comment">/* Adjust for any missing blocks. */</span>
			<span class="enscript-keyword">if</span> ((validblks &lt; forkp-&gt;cf_blocks) &amp;&amp; (forkp-&gt;cf_extents[7].blockCount == 0)) {
				off_t psize;

				<span class="enscript-comment">/* 
				 * This is technically a volume corruption. 
				 * If the total number of blocks calculated by iterating + summing
				 * the extents in the resident extent records, is less than that 
				 * which is reported in the catalog entry, we should force a fsck.  
				 * Only modifying ca_blocks here is not guaranteed to make it out 
				 * to disk; it is a runtime-only field. 
				 * 
				 * Note that we could have gotten into this state if we had invalid ranges 
				 * that existed in borrowed blocks that somehow made it out to disk. 
				 * The cnode's on disk block count should never be greater 
				 * than that which is in its extent records.
				 */</span>

				(<span class="enscript-type">void</span>) hfs_mark_inconsistent (hfsmp, HFS_INCONSISTENCY_DETECTED);

				forkp-&gt;cf_blocks = validblks;
				<span class="enscript-keyword">if</span> (attrp != NULL) {
					attrp-&gt;ca_blocks = validblks + recp-&gt;hfsPlusFile.resourceFork.totalBlocks;
				}
				psize = (off_t)validblks * (off_t)hfsmp-&gt;blockSize;
				<span class="enscript-keyword">if</span> (psize &lt; forkp-&gt;cf_size) {
					forkp-&gt;cf_size = psize;
				}

			}
		}
	}
	<span class="enscript-keyword">if</span> (descp != NULL) {
		HFSPlusCatalogKey * pluskey = NULL;

		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			pluskey = (HFSPlusCatalogKey *)&amp;iterator-&gt;key;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
			promotekey(hfsmp, (HFSCatalogKey *)&amp;iterator-&gt;key, pluskey, &amp;encoding);
	
		}
#<span class="enscript-reference">endif</span>	
	
		builddesc(pluskey, cnid, hint, encoding, isadir(recp), descp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">if</span> (std_hfs) {
			FREE(pluskey, M_TEMP);
		}
#<span class="enscript-reference">endif</span>

	}

	<span class="enscript-keyword">if</span> (desc_cnid != NULL) {
	    *desc_cnid = cnid;
	}
<span class="enscript-reference">exit</span>:
	FREE(iterator, M_TEMP);
	FREE(recp, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_create - create a node in the catalog
 *
 * NOTE: both the catalog file and attribute file locks must
 *       be held before calling this function.
 *
 * The caller is responsible for releasing the output
 * catalog descriptor (when supplied outdescp is non-null).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_create</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t new_fileid, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">struct</span> cat_desc *out_descp)
{
	FCB * fcb;
	<span class="enscript-type">struct</span> btobj * bto;
	FSBufferDescriptor btdata;
	u_int32_t datalen;
	<span class="enscript-type">int</span> std_hfs;
	<span class="enscript-type">int</span> result = 0;
	u_int32_t encoding = kTextEncodingMacRoman;
	<span class="enscript-type">int</span> modeformat;

	modeformat = attrp-&gt;ca_mode &amp; S_IFMT;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	std_hfs = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);

	<span class="enscript-comment">/* The caller is expected to reserve a CNID before calling this function! */</span>
	
	<span class="enscript-comment">/* Get space for iterator, key and data */</span>	
	MALLOC(bto, <span class="enscript-type">struct</span> btobj *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> btobj), M_TEMP, M_WAITOK);
	bto-&gt;iterator.hint.nodeNum = 0;

	result = buildkey(hfsmp, descp, &amp;bto-&gt;key, 0);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-keyword">if</span> (!std_hfs) {
		encoding = hfs_pickencoding(bto-&gt;key.nodeName.unicode,
			bto-&gt;key.nodeName.length);
		hfs_setencodingbits(hfsmp, encoding);
	}

	<span class="enscript-comment">/*
	 * Insert the thread record first
	 */</span>
	<span class="enscript-keyword">if</span> (!std_hfs || (modeformat == S_IFDIR)) {
		datalen = buildthread((<span class="enscript-type">void</span>*)&amp;bto-&gt;key, &amp;bto-&gt;data, std_hfs,
				S_ISDIR(attrp-&gt;ca_mode));
		btdata.bufferAddress = &amp;bto-&gt;data;
		btdata.itemSize = datalen;
		btdata.itemCount = 1;
		
		<span class="enscript-comment">/* Caller asserts the following:
		 *	1) this CNID is not in use by any orphaned EAs 
		 *  2) There are no lingering cnodes (removed on-disk but still in-core) with this CNID
		 *  3) There are no thread or catalog records for this ID 
		 */</span>		 
		buildthreadkey(new_fileid, std_hfs, (CatalogKey *) &amp;bto-&gt;iterator.key);
		result = BTInsertRecord(fcb, &amp;bto-&gt;iterator, &amp;btdata, datalen);
		<span class="enscript-keyword">if</span> (result) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Now insert the file/directory record
	 */</span>
	buildrecord(attrp, new_fileid, std_hfs, encoding, &amp;bto-&gt;data, &amp;datalen);
	btdata.bufferAddress = &amp;bto-&gt;data;
	btdata.itemSize = datalen;
	btdata.itemCount = 1;
	
	bcopy(&amp;bto-&gt;key, &amp;bto-&gt;iterator.key, <span class="enscript-keyword">sizeof</span>(bto-&gt;key));

	result = BTInsertRecord(fcb, &amp;bto-&gt;iterator, &amp;btdata, datalen);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (result == btExists)
			result = EEXIST;

		<span class="enscript-comment">/* Back out the thread record */</span>
		<span class="enscript-keyword">if</span> (!std_hfs || S_ISDIR(attrp-&gt;ca_mode)) {
			buildthreadkey(new_fileid, std_hfs, (CatalogKey *)&amp;bto-&gt;iterator.key);
			<span class="enscript-keyword">if</span> (BTDeleteRecord(fcb, &amp;bto-&gt;iterator)) {
				<span class="enscript-comment">/* Error on deleting extra thread record, mark 
				 * volume inconsistent 
				 */</span>
				printf (<span class="enscript-string">&quot;hfs: cat_create() failed to delete thread record id=%u on vol=%s\n&quot;</span>, new_fileid, hfsmp-&gt;vcbVN);
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
			}
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/*
	 * Insert was successful, update name, parent and volume
	 */</span>
	<span class="enscript-keyword">if</span> (out_descp != NULL) {
		HFSPlusCatalogKey * pluskey = NULL;

		<span class="enscript-keyword">if</span> (std_hfs == 0) {
			pluskey = (HFSPlusCatalogKey *)&amp;bto-&gt;iterator.key;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
			promotekey(hfsmp, (HFSCatalogKey *)&amp;bto-&gt;iterator.key, pluskey, &amp;encoding);
		} 
#<span class="enscript-reference">endif</span>

		builddesc(pluskey, new_fileid, bto-&gt;iterator.hint.nodeNum,
			encoding, S_ISDIR(attrp-&gt;ca_mode), out_descp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">if</span> (std_hfs) {
			FREE(pluskey, M_TEMP);
		}
#<span class="enscript-reference">endif</span>

	}
	attrp-&gt;ca_fileid = new_fileid;

<span class="enscript-reference">exit</span>:
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	FREE(bto, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cnode_rename - rename a catalog node
 *
 * Assumes that the target's directory exists.
 *
 * Order of B-tree operations:
 *	1. BTSearchRecord(from_cnode, &amp;data);
 *	2. BTInsertRecord(to_cnode, &amp;data);
 *	3. BTDeleteRecord(from_cnode);
 *	4. BTDeleteRecord(from_thread);
 *	5. BTInsertRecord(to_thread);
 *
 * Note: The caller is responsible for releasing the output
 * catalog descriptor (when supplied out_cdp is non-null).
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">cat_rename</span> (
	<span class="enscript-type">struct</span> hfsmount * hfsmp,
	<span class="enscript-type">struct</span> cat_desc * from_cdp,
	<span class="enscript-type">struct</span> cat_desc * todir_cdp,
	<span class="enscript-type">struct</span> cat_desc * to_cdp,
	<span class="enscript-type">struct</span> cat_desc * out_cdp )
{
	<span class="enscript-type">struct</span> BTreeIterator * to_iterator = NULL;
	<span class="enscript-type">struct</span> BTreeIterator * from_iterator = NULL;
	FSBufferDescriptor btdata;
	CatalogRecord * recp = NULL;
	HFSPlusCatalogKey * to_key;
	ExtendedVCB * vcb;
	FCB * fcb;
	u_int16_t	datasize;
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> sourcegone = 0;
	<span class="enscript-type">int</span> skipthread = 0;
	<span class="enscript-type">int</span> directory = from_cdp-&gt;cd_flags &amp; CD_ISDIR;
	<span class="enscript-type">int</span> is_dirlink = 0;
	<span class="enscript-type">int</span> std_hfs;
	u_int32_t encoding = 0;

	vcb = HFSTOVCB(hfsmp);
	fcb = GetFileControlBlock(vcb-&gt;catalogRefNum);
	std_hfs = (vcb-&gt;vcbSigWord == kHFSSigWord);

	<span class="enscript-keyword">if</span> (from_cdp-&gt;cd_namelen == 0 || to_cdp-&gt;cd_namelen == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	MALLOC(from_iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*from_iterator), M_TEMP, M_WAITOK);
	bzero(from_iterator, <span class="enscript-keyword">sizeof</span>(*from_iterator));
	<span class="enscript-keyword">if</span> ((result = buildkey(hfsmp, from_cdp, (HFSPlusCatalogKey *)&amp;from_iterator-&gt;key, 0)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;	

	MALLOC(to_iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*to_iterator), M_TEMP, M_WAITOK);
	bzero(to_iterator, <span class="enscript-keyword">sizeof</span>(*to_iterator));
	<span class="enscript-keyword">if</span> ((result = buildkey(hfsmp, to_cdp, (HFSPlusCatalogKey *)&amp;to_iterator-&gt;key, 0)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;	

	to_key = (HFSPlusCatalogKey *)&amp;to_iterator-&gt;key;
	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);

	<span class="enscript-comment">/*
	 * When moving a directory, make sure its a valid move.
	 */</span>
	<span class="enscript-keyword">if</span> (directory &amp;&amp; (from_cdp-&gt;cd_parentcnid != to_cdp-&gt;cd_parentcnid)) {
		<span class="enscript-type">struct</span> BTreeIterator *dir_iterator = NULL;

		cnid_t cnid = from_cdp-&gt;cd_cnid;
		cnid_t pathcnid = todir_cdp-&gt;cd_parentcnid;
	
		<span class="enscript-comment">/* First check the obvious ones */</span>
		<span class="enscript-keyword">if</span> (cnid == fsRtDirID  ||
		    cnid == to_cdp-&gt;cd_parentcnid  ||
		    cnid == pathcnid) {
			result = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		<span class="enscript-comment">/* now allocate the dir_iterator */</span>
		MALLOC (dir_iterator, <span class="enscript-type">struct</span> BTreeIterator*, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> BTreeIterator), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (dir_iterator == NULL) {
			<span class="enscript-keyword">return</span> ENOMEM; 
		}
		bzero(dir_iterator, <span class="enscript-keyword">sizeof</span>(*dir_iterator));
			
		<span class="enscript-comment">/*
		 * Traverse destination path all the way back to the root
		 * making sure that source directory is not encountered.
		 *
		 */</span>
		<span class="enscript-keyword">while</span> (pathcnid &gt; fsRtDirID) {
			buildthreadkey(pathcnid, std_hfs, (CatalogKey *)&amp;dir_iterator-&gt;key);
			result = BTSearchRecord(fcb, dir_iterator, &amp;btdata, &amp;datasize, NULL);
			<span class="enscript-keyword">if</span> (result) {
				FREE(dir_iterator, M_TEMP);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
			pathcnid = getparentcnid(recp);
			<span class="enscript-keyword">if</span> (pathcnid == cnid || pathcnid == 0) {
				result = EINVAL;
				FREE(dir_iterator, M_TEMP);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		}
		FREE(dir_iterator, M_TEMP);
	}

	<span class="enscript-comment">/*
	 * Step 1: Find cnode data at old location
	 */</span>
	result = BTSearchRecord(fcb, from_iterator, &amp;btdata,
				&amp;datasize, from_iterator);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (std_hfs || (result != btNotFound)) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-type">struct</span> cat_desc temp_desc;

		<span class="enscript-comment">/* Probably the node has mangled name */</span>
		result = cat_lookupmangled(hfsmp, from_cdp, 0, &amp;temp_desc, NULL, NULL); 
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/* The file has mangled name.  Search the cnode data using full name */</span>
		bzero(from_iterator, <span class="enscript-keyword">sizeof</span>(*from_iterator));
		result = buildkey(hfsmp, &amp;temp_desc, (HFSPlusCatalogKey *)&amp;from_iterator-&gt;key, 0);
		<span class="enscript-keyword">if</span> (result) {
			cat_releasedesc(&amp;temp_desc);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		result = BTSearchRecord(fcb, from_iterator, &amp;btdata, &amp;datasize, from_iterator);
		<span class="enscript-keyword">if</span> (result) {
			cat_releasedesc(&amp;temp_desc);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		cat_releasedesc(&amp;temp_desc);
	}

	<span class="enscript-comment">/* Check if the source is directory hard link.  We do not change 
	 * directory flag because it is later used to initialize result descp
	 */</span>
	<span class="enscript-keyword">if</span> ((!std_hfs) &amp;&amp; 
	    (directory) &amp;&amp; 
	    (recp-&gt;recordType == kHFSPlusFileRecord) &amp;&amp;
	    (recp-&gt;hfsPlusFile.flags &amp; kHFSHasLinkChainMask)) {
	    	is_dirlink  = 1;
	}

	<span class="enscript-comment">/*
	 * Update the text encoding (on disk and in descriptor).
	 *
	 * Note that hardlink inodes don't require a text encoding hint.
	 */</span>
	<span class="enscript-keyword">if</span> (!std_hfs &amp;&amp;
	    todir_cdp-&gt;cd_parentcnid != hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid &amp;&amp;
	    todir_cdp-&gt;cd_parentcnid != hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
		encoding = hfs_pickencoding(to_key-&gt;nodeName.unicode, to_key-&gt;nodeName.length);
		hfs_setencodingbits(hfsmp, encoding);
		recp-&gt;hfsPlusFile.textEncoding = encoding;
		<span class="enscript-keyword">if</span> (out_cdp)
			out_cdp-&gt;cd_encoding = encoding;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (std_hfs &amp;&amp; !directory &amp;&amp;
	    !(recp-&gt;hfsFile.flags &amp; kHFSThreadExistsMask)) {
		skipthread = 1;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * If the keys are identical then there's nothing left to do!
	 *
	 * update the hint and exit
	 *
	 */</span>
	<span class="enscript-keyword">if</span> (std_hfs &amp;&amp; hfskeycompare(to_key, iter-&gt;key) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;	
	<span class="enscript-keyword">if</span> (!std_hfs &amp;&amp; hfspluskeycompare(to_key, iter-&gt;key) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;	
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Step 2: Insert cnode at new location */</span>
	result = BTInsertRecord(fcb, to_iterator, &amp;btdata, datasize);
	<span class="enscript-keyword">if</span> (result == btExists) {
		<span class="enscript-type">int</span> fromtype = recp-&gt;recordType;
		cnid_t cnid = 0;

		<span class="enscript-keyword">if</span> (from_cdp-&gt;cd_parentcnid != to_cdp-&gt;cd_parentcnid)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; <span class="enscript-comment">/* EEXIST */</span>

		<span class="enscript-comment">/* Find cnode data at new location */</span>
		result = BTSearchRecord(fcb, to_iterator, &amp;btdata, &amp;datasize, NULL);
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		
		<span class="enscript-comment">/* Get the CNID after calling searchrecord */</span>
		cnid  = getcnid (recp);
		<span class="enscript-keyword">if</span> (cnid == 0) {
			hfs_mark_inconsistent(hfsmp, HFS_INCONSISTENCY_DETECTED);
			result = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-keyword">if</span> ((fromtype != recp-&gt;recordType) ||
		    (from_cdp-&gt;cd_cnid != cnid)) {
			result = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>; <span class="enscript-comment">/* EEXIST */</span>
		}
		<span class="enscript-comment">/* The old name is a case variant and must be removed */</span>
		result = BTDeleteRecord(fcb, from_iterator);
		<span class="enscript-keyword">if</span> (result)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-comment">/* Insert cnode (now that case duplicate is gone) */</span>
		result = BTInsertRecord(fcb, to_iterator, &amp;btdata, datasize);
		<span class="enscript-keyword">if</span> (result) {
			<span class="enscript-comment">/* Try and restore original before leaving */</span>
		    <span class="enscript-comment">// XXXdbg
</span>		    #<span class="enscript-keyword">if</span> 1
		       {
		       	<span class="enscript-type">int</span> err;
			err = BTInsertRecord(fcb, from_iterator, &amp;btdata, datasize);
			<span class="enscript-keyword">if</span> (err) {
				printf(<span class="enscript-string">&quot;hfs: cat_create: could not undo (BTInsert = %d)\n&quot;</span>, err);
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
				result = err;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		       }
		    #<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>) BTInsertRecord(fcb, from_iterator, &amp;btdata, datasize);
		    #endif
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		sourcegone = 1;
	}
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Step 3: Remove cnode from old location */</span>
	<span class="enscript-keyword">if</span> (!sourcegone) {
		result = BTDeleteRecord(fcb, from_iterator);
		<span class="enscript-keyword">if</span> (result) {
			<span class="enscript-comment">/* Try and delete new record before leaving */</span>
		  <span class="enscript-comment">// XXXdbg
</span>		  #<span class="enscript-keyword">if</span> 1
		     {
		     	<span class="enscript-type">int</span> err;
			err = BTDeleteRecord(fcb, to_iterator);
			<span class="enscript-keyword">if</span> (err) {
				printf(<span class="enscript-string">&quot;hfs: cat_create: could not undo (BTDelete = %d)\n&quot;</span>, err);
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
				result = err;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		     }			
		  #<span class="enscript-keyword">else</span>
			(<span class="enscript-type">void</span>) BTDeleteRecord(fcb, to_iterator);
		  #endif
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	<span class="enscript-comment">/* #### POINT OF NO RETURN #### */</span>

	<span class="enscript-comment">/*
	 * Step 4: Remove cnode's old thread record
	 */</span>
	buildthreadkey(from_cdp-&gt;cd_cnid, std_hfs, (CatalogKey *)&amp;from_iterator-&gt;key);
	(<span class="enscript-type">void</span>) BTDeleteRecord(fcb, from_iterator);

	<span class="enscript-comment">/*
	 * Step 5: Insert cnode's new thread record
	 * (optional for HFS files)
	 */</span>
	<span class="enscript-keyword">if</span> (!skipthread) {
		<span class="enscript-comment">/* For directory hard links, always create a file thread 
		 * record.  For everything else, use the directory flag.
		 */</span>
		<span class="enscript-keyword">if</span> (is_dirlink) {
			datasize = buildthread(&amp;to_iterator-&gt;key, recp, std_hfs, false);
		} <span class="enscript-keyword">else</span> {
			datasize = buildthread(&amp;to_iterator-&gt;key, recp, std_hfs, directory);
		}
		btdata.itemSize = datasize;
		buildthreadkey(from_cdp-&gt;cd_cnid, std_hfs, (CatalogKey *)&amp;from_iterator-&gt;key);
		result = BTInsertRecord(fcb, from_iterator, &amp;btdata, datasize);
	}

	<span class="enscript-keyword">if</span> (out_cdp) {
		HFSPlusCatalogKey * pluskey = NULL;

		<span class="enscript-keyword">if</span> (std_hfs == 0) {	
			pluskey = (HFSPlusCatalogKey *)&amp;to_iterator-&gt;key;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">else</span> {
			MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
			promotekey(hfsmp, (HFSCatalogKey *)&amp;to_iterator-&gt;key, pluskey, &amp;encoding);

			<span class="enscript-comment">/* Save the real encoding hint in the Finder Info (field 4). */</span>
			<span class="enscript-keyword">if</span> (directory &amp;&amp; from_cdp-&gt;cd_cnid == kHFSRootFolderID) {
				u_int32_t realhint;

				realhint = hfs_pickencoding(pluskey-&gt;nodeName.unicode, pluskey-&gt;nodeName.length);
				vcb-&gt;vcbFndrInfo[4] = SET_HFS_TEXT_ENCODING(realhint);
			}
		}
#<span class="enscript-reference">endif</span>

		builddesc(pluskey, from_cdp-&gt;cd_cnid, to_iterator-&gt;hint.nodeNum,
			encoding, directory, out_cdp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
		<span class="enscript-keyword">if</span> (std_hfs) {
			FREE(pluskey, M_TEMP);
		}
#<span class="enscript-reference">endif</span>

	}
<span class="enscript-reference">exit</span>:
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	<span class="enscript-keyword">if</span> (from_iterator)
		FREE(from_iterator, M_TEMP);
	<span class="enscript-keyword">if</span> (to_iterator)
		FREE(to_iterator, M_TEMP);
	<span class="enscript-keyword">if</span> (recp)
		FREE(recp, M_TEMP);
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_delete - delete a node from the catalog
 *
 * Order of B-tree operations:
 *	1. BTDeleteRecord(cnode);
 *	2. BTDeleteRecord(thread);
 *	3. BTUpdateRecord(parent);
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_delete</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp)
{
	FCB * fcb;
	BTreeIterator *iterator;
	cnid_t cnid;
	<span class="enscript-type">int</span> std_hfs;
	<span class="enscript-type">int</span> result;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	std_hfs = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);

	<span class="enscript-comment">/* Preflight check:
	 *
	 * The root directory cannot be deleted
	 * A directory must be empty
	 * A file must be zero length (no blocks)
	 */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_cnid &lt; kHFSFirstUserCatalogNodeID ||
	    descp-&gt;cd_parentcnid == kHFSRootParentID)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* XXX Preflight Missing */</span>
	
	<span class="enscript-comment">/* Borrow the btcb iterator since we have an exclusive catalog lock. */</span>	
	iterator = &amp;((BTreeControlBlockPtr)(fcb-&gt;ff_sysfileinfo))-&gt;iterator;
	iterator-&gt;hint.nodeNum = 0;

	<span class="enscript-comment">/*
	 * Derive a key from either the file ID (for a virtual inode)
	 * or the descriptor.
	 */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_namelen == 0) {
	    result = getkey(hfsmp, attrp-&gt;ca_fileid, (CatalogKey *)&amp;iterator-&gt;key);
	    cnid = attrp-&gt;ca_fileid;
	} <span class="enscript-keyword">else</span> {
		result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0);
		cnid = descp-&gt;cd_cnid;
	}
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Delete record */</span>
	result = BTDeleteRecord(fcb, iterator);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (std_hfs || (result != btNotFound))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

		<span class="enscript-type">struct</span> cat_desc temp_desc;
		
		<span class="enscript-comment">/* Probably the node has mangled name */</span>
		result = cat_lookupmangled(hfsmp, descp, 0, &amp;temp_desc, attrp, NULL); 
		<span class="enscript-keyword">if</span> (result) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		
		<span class="enscript-comment">/* The file has mangled name.  Delete the file using full name  */</span>
		bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
		result = buildkey(hfsmp, &amp;temp_desc, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0);
		cnid = temp_desc.cd_cnid;
		<span class="enscript-keyword">if</span> (result) {
			cat_releasedesc(&amp;temp_desc);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		result = BTDeleteRecord(fcb, iterator);
		<span class="enscript-keyword">if</span> (result) { 
			cat_releasedesc(&amp;temp_desc);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		cat_releasedesc(&amp;temp_desc);
	}

	<span class="enscript-comment">/* Delete thread record.  On error, mark volume inconsistent */</span>
	buildthreadkey(cnid, std_hfs, (CatalogKey *)&amp;iterator-&gt;key);
	<span class="enscript-keyword">if</span> (BTDeleteRecord(fcb, iterator)) {
		<span class="enscript-keyword">if</span> (!std_hfs) {
			printf (<span class="enscript-string">&quot;hfs: cat_delete() failed to delete thread record id=%u on vol=%s\n&quot;</span>, cnid, hfsmp-&gt;vcbVN);
			hfs_mark_inconsistent(hfsmp, HFS_OP_INCOMPLETE);
		}
	}

<span class="enscript-reference">exit</span>:
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_update_internal - update the catalog node described by descp
 * using the data from attrp and forkp.  
 * If update_hardlink is true, the hard link catalog record is updated
 * and not the inode catalog record. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cat_update_internal</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> update_hardlink, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dataforkp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *rsrcforkp)
{
	FCB * fcb;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> update_state state;
	<span class="enscript-type">int</span> result;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	state.s_desc = descp;
	state.s_attr = attrp;
	state.s_datafork = dataforkp;
	state.s_rsrcfork = rsrcforkp;
	state.s_hfsmp = hfsmp;

	<span class="enscript-comment">/* Borrow the btcb iterator since we have an exclusive catalog lock. */</span>	
	iterator = &amp;((BTreeControlBlockPtr)(fcb-&gt;ff_sysfileinfo))-&gt;iterator;

	<span class="enscript-comment">/*
	 * For open-deleted files we need to do a lookup by cnid
	 * (using thread rec).
	 *
	 * For hard links and if not requested by caller, the target 
	 * of the update is the inode itself (not the link record) 
	 * so a lookup by fileid (i.e. thread rec) is needed.
	 */</span>
	<span class="enscript-keyword">if</span> ((update_hardlink == false) &amp;&amp; 
	    ((descp-&gt;cd_cnid != attrp-&gt;ca_fileid) ||
	     (descp-&gt;cd_namelen == 0) ||
	     (attrp-&gt;ca_recflags &amp; kHFSHasLinkChainMask))) {
		result = getkey(hfsmp, attrp-&gt;ca_fileid, (CatalogKey *)&amp;iterator-&gt;key);
	} <span class="enscript-keyword">else</span> {
		result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0);
	}
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Pass a node hint */</span>
	iterator-&gt;hint.nodeNum = descp-&gt;cd_hint;

	result = BTUpdateRecord(fcb, iterator,
	                        (IterateCallBackProcPtr)catrec_update, &amp;state);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Update the node hint. */</span>
	descp-&gt;cd_hint = iterator-&gt;hint.nodeNum;

<span class="enscript-reference">exit</span>:
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-comment">/*
 * cat_update - update the catalog node described by descp
 * using the data from attrp and forkp. 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_update</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *dataforkp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *rsrcforkp)
{
	<span class="enscript-keyword">return</span> cat_update_internal(hfsmp, false, descp, attrp, dataforkp, rsrcforkp);
}

<span class="enscript-comment">/*
 * catrec_update - Update the fields of a catalog record
 * This is called from within BTUpdateRecord.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">catrec_update</span>(<span class="enscript-type">const</span> CatalogKey *ckp, CatalogRecord *crp, <span class="enscript-type">struct</span> update_state *state)
{
	<span class="enscript-type">struct</span> cat_desc *descp;
	<span class="enscript-type">struct</span> cat_attr *attrp;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *forkp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">long</span> blksize;

	descp   = state-&gt;s_desc;
	attrp   = state-&gt;s_attr;
	hfsmp   = state-&gt;s_hfsmp;
	blksize = HFSTOVCB(hfsmp)-&gt;blockSize;

	<span class="enscript-keyword">switch</span> (crp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderRecord</span>: {
		HFSCatalogFolder *dir;
		
		dir = (<span class="enscript-type">struct</span> HFSCatalogFolder *)crp;
		<span class="enscript-comment">/* Do a quick sanity check */</span>
		<span class="enscript-keyword">if</span> ((ckp-&gt;hfs.parentID != descp-&gt;cd_parentcnid) ||
		    (dir-&gt;folderID != descp-&gt;cd_cnid))
			<span class="enscript-keyword">return</span> (btNotFound);
		dir-&gt;valence    = attrp-&gt;ca_entries;
		dir-&gt;createDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_itime));
		dir-&gt;modifyDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_mtime));
		dir-&gt;backupDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_btime));
		bcopy(&amp;attrp-&gt;ca_finderinfo[0], &amp;dir-&gt;userInfo, 16);
		bcopy(&amp;attrp-&gt;ca_finderinfo[16], &amp;dir-&gt;finderInfo, 16);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileRecord</span>: {
		HFSCatalogFile *file;
		<span class="enscript-type">int</span> i;

		file = (<span class="enscript-type">struct</span> HFSCatalogFile *)crp;
		<span class="enscript-comment">/* Do a quick sanity check */</span>
		<span class="enscript-keyword">if</span> ((ckp-&gt;hfs.parentID != descp-&gt;cd_parentcnid) ||
		    (file-&gt;fileID != attrp-&gt;ca_fileid))
			<span class="enscript-keyword">return</span> (btNotFound);
		file-&gt;createDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_itime));
		file-&gt;modifyDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_mtime));
		file-&gt;backupDate = UTCToLocal(to_hfs_time(attrp-&gt;ca_btime));
		bcopy(&amp;attrp-&gt;ca_finderinfo[0], &amp;file-&gt;userInfo, 16);
		bcopy(&amp;attrp-&gt;ca_finderinfo[16], &amp;file-&gt;finderInfo, 16);
		<span class="enscript-keyword">if</span> (state-&gt;s_rsrcfork) {
			forkp = state-&gt;s_rsrcfork;
			file-&gt;rsrcLogicalSize  = forkp-&gt;cf_size;
			file-&gt;rsrcPhysicalSize = forkp-&gt;cf_blocks * blksize;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSExtentDensity; ++i) {
				file-&gt;rsrcExtents[i].startBlock =
					(u_int16_t)forkp-&gt;cf_extents[i].startBlock;
				file-&gt;rsrcExtents[i].blockCount =
					(u_int16_t)forkp-&gt;cf_extents[i].blockCount;
			}
		}
		<span class="enscript-keyword">if</span> (state-&gt;s_datafork) {
			forkp = state-&gt;s_datafork;
			file-&gt;dataLogicalSize  = forkp-&gt;cf_size;
			file-&gt;dataPhysicalSize = forkp-&gt;cf_blocks * blksize;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; kHFSExtentDensity; ++i) {
				file-&gt;dataExtents[i].startBlock =
					(u_int16_t)forkp-&gt;cf_extents[i].startBlock;
				file-&gt;dataExtents[i].blockCount =
					(u_int16_t)forkp-&gt;cf_extents[i].blockCount;
			}
		}

		<span class="enscript-comment">/* Synchronize the lock state */</span>
		<span class="enscript-keyword">if</span> (attrp-&gt;ca_flags &amp; (SF_IMMUTABLE | UF_IMMUTABLE))
			file-&gt;flags |= kHFSFileLockedMask;
		<span class="enscript-keyword">else</span>
			file-&gt;flags &amp;= ~kHFSFileLockedMask;
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderRecord</span>: {
		HFSPlusCatalogFolder *dir;
		
		dir = (<span class="enscript-type">struct</span> HFSPlusCatalogFolder *)crp;
		<span class="enscript-comment">/* Do a quick sanity check */</span>
		<span class="enscript-keyword">if</span> (dir-&gt;folderID != attrp-&gt;ca_fileid) {
			printf(<span class="enscript-string">&quot;hfs: catrec_update: id %d != %d, vol=%s\n&quot;</span>, dir-&gt;folderID, attrp-&gt;ca_fileid, hfsmp-&gt;vcbVN);
			<span class="enscript-keyword">return</span> (btNotFound);
		}
		dir-&gt;flags            = attrp-&gt;ca_recflags;
		dir-&gt;valence          = attrp-&gt;ca_entries;
		dir-&gt;createDate       = to_hfs_time(attrp-&gt;ca_itime);
		dir-&gt;contentModDate   = to_hfs_time(attrp-&gt;ca_mtime);
		dir-&gt;backupDate       = to_hfs_time(attrp-&gt;ca_btime);
		dir-&gt;accessDate       = to_hfs_time(attrp-&gt;ca_atime);
		attrp-&gt;ca_atimeondisk = attrp-&gt;ca_atime;	
		dir-&gt;attributeModDate = to_hfs_time(attrp-&gt;ca_ctime);
		<span class="enscript-comment">/* Note: directory hardlink inodes don't require a text encoding hint. */</span>
		<span class="enscript-keyword">if</span> (ckp-&gt;hfsPlus.parentID != hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
			dir-&gt;textEncoding = descp-&gt;cd_encoding;
		}
		dir-&gt;folderCount      = attrp-&gt;ca_dircount;
		bcopy(&amp;attrp-&gt;ca_finderinfo[0], &amp;dir-&gt;userInfo, 32);
		<span class="enscript-comment">/*
		 * Update the BSD Info if it was already initialized on
		 * disk or if the runtime values have been modified.
		 *
		 * If the BSD info was already initialized, but
		 * MNT_UNKNOWNPERMISSIONS is set, then the runtime IDs are
		 * probably different than what was on disk.  We don't want
		 * to overwrite the on-disk values (so if we turn off
		 * MNT_UNKNOWNPERMISSIONS, the old IDs get used again).
		 * This way, we can still change fields like the mode or
		 * dates even when MNT_UNKNOWNPERMISSIONS is set.
		 *
		 * Note that if MNT_UNKNOWNPERMISSIONS is set, hfs_chown
		 * won't change the uid or gid from their defaults.  So, if
		 * the BSD info wasn't set, and the runtime values are not
		 * default, then what changed was the mode or flags.  We
		 * have to set the uid and gid to something, so use the
		 * supplied values (which will be default), which has the
		 * same effect as creating a new file while
		 * MNT_UNKNOWNPERMISSIONS is set.
		 */</span>
		<span class="enscript-keyword">if</span> ((dir-&gt;bsdInfo.fileMode != 0) ||
		    (attrp-&gt;ca_flags != 0) ||
		    (attrp-&gt;ca_uid != hfsmp-&gt;hfs_uid) ||
		    (attrp-&gt;ca_gid != hfsmp-&gt;hfs_gid) ||
		    ((attrp-&gt;ca_mode &amp; ALLPERMS) !=
		     (hfsmp-&gt;hfs_dir_mask &amp; ACCESSPERMS))) {
			<span class="enscript-keyword">if</span> ((dir-&gt;bsdInfo.fileMode == 0) ||
			    (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(HFSTOVFS(hfsmp))) &amp; MNT_UNKNOWNPERMISSIONS) == 0) {
				dir-&gt;bsdInfo.ownerID = attrp-&gt;ca_uid;
				dir-&gt;bsdInfo.groupID = attrp-&gt;ca_gid;
			}
			dir-&gt;bsdInfo.ownerFlags = attrp-&gt;ca_flags &amp; 0x000000FF;
			dir-&gt;bsdInfo.adminFlags = attrp-&gt;ca_flags &gt;&gt; 16;
			dir-&gt;bsdInfo.fileMode   = attrp-&gt;ca_mode;
			<span class="enscript-comment">/* A directory hardlink has a link count. */</span>
			<span class="enscript-keyword">if</span> (attrp-&gt;ca_linkcount &gt; 1 || dir-&gt;hl_linkCount &gt; 1) {
				dir-&gt;hl_linkCount = attrp-&gt;ca_linkcount;
			}
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileRecord</span>: {
		HFSPlusCatalogFile *file;
		<span class="enscript-type">int</span> is_dirlink; 
		
		file = (<span class="enscript-type">struct</span> HFSPlusCatalogFile *)crp;
		<span class="enscript-comment">/* Do a quick sanity check */</span>
		<span class="enscript-keyword">if</span> (file-&gt;fileID != attrp-&gt;ca_fileid)
			<span class="enscript-keyword">return</span> (btNotFound);
		file-&gt;flags            = attrp-&gt;ca_recflags;
		file-&gt;createDate       = to_hfs_time(attrp-&gt;ca_itime);
		file-&gt;contentModDate   = to_hfs_time(attrp-&gt;ca_mtime);
		file-&gt;backupDate       = to_hfs_time(attrp-&gt;ca_btime);
		file-&gt;accessDate       = to_hfs_time(attrp-&gt;ca_atime);
		attrp-&gt;ca_atimeondisk  = attrp-&gt;ca_atime;	
		file-&gt;attributeModDate = to_hfs_time(attrp-&gt;ca_ctime);
		<span class="enscript-comment">/*
		 * Note: file hardlink inodes don't require a text encoding
		 * hint, but they do have a first link value.
		 */</span>
		<span class="enscript-keyword">if</span> (ckp-&gt;hfsPlus.parentID == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) {
			file-&gt;hl_firstLinkID = attrp-&gt;ca_firstlink;
		} <span class="enscript-keyword">else</span> {
			file-&gt;textEncoding = descp-&gt;cd_encoding;
		}
		bcopy(&amp;attrp-&gt;ca_finderinfo[0], &amp;file-&gt;userInfo, 32);
		<span class="enscript-comment">/*
		 * Update the BSD Info if it was already initialized on
		 * disk or if the runtime values have been modified.
		 *
		 * If the BSD info was already initialized, but
		 * MNT_UNKNOWNPERMISSIONS is set, then the runtime IDs are
		 * probably different than what was on disk.  We don't want
		 * to overwrite the on-disk values (so if we turn off
		 * MNT_UNKNOWNPERMISSIONS, the old IDs get used again).
		 * This way, we can still change fields like the mode or
		 * dates even when MNT_UNKNOWNPERMISSIONS is set.
		 *
		 * Note that if MNT_UNKNOWNPERMISSIONS is set, hfs_chown
		 * won't change the uid or gid from their defaults.  So, if
		 * the BSD info wasn't set, and the runtime values are not
		 * default, then what changed was the mode or flags.  We
		 * have to set the uid and gid to something, so use the
		 * supplied values (which will be default), which has the
		 * same effect as creating a new file while
		 * MNT_UNKNOWNPERMISSIONS is set.
		 *
		 * Do not modify bsdInfo for directory hard link records.
		 * They are set during creation and are not modifiable, so just 
		 * leave them alone. 
		 */</span>
		is_dirlink = (file-&gt;flags &amp; kHFSHasLinkChainMask) &amp;&amp;     
			     (SWAP_BE32(file-&gt;userInfo.fdType) == kHFSAliasType) &amp;&amp; 
			     (SWAP_BE32(file-&gt;userInfo.fdCreator) == kHFSAliasCreator);

		<span class="enscript-keyword">if</span> (!is_dirlink &amp;&amp; 
		    ((file-&gt;bsdInfo.fileMode != 0) ||
		     (attrp-&gt;ca_flags != 0) ||
		     (attrp-&gt;ca_uid != hfsmp-&gt;hfs_uid) ||
		     (attrp-&gt;ca_gid != hfsmp-&gt;hfs_gid) ||
		     ((attrp-&gt;ca_mode &amp; ALLPERMS) !=
		      (hfsmp-&gt;hfs_file_mask &amp; ACCESSPERMS)))) {
			<span class="enscript-keyword">if</span> ((file-&gt;bsdInfo.fileMode == 0) ||
			    (((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)vfs_flags(HFSTOVFS(hfsmp))) &amp; MNT_UNKNOWNPERMISSIONS) == 0) {
				file-&gt;bsdInfo.ownerID = attrp-&gt;ca_uid;
				file-&gt;bsdInfo.groupID = attrp-&gt;ca_gid;
			}
			file-&gt;bsdInfo.ownerFlags = attrp-&gt;ca_flags &amp; 0x000000FF;
			file-&gt;bsdInfo.adminFlags = attrp-&gt;ca_flags &gt;&gt; 16;
			file-&gt;bsdInfo.fileMode   = attrp-&gt;ca_mode;
		}
		<span class="enscript-keyword">if</span> (state-&gt;s_rsrcfork) {
			forkp = state-&gt;s_rsrcfork;
			file-&gt;resourceFork.logicalSize = forkp-&gt;cf_size;
			file-&gt;resourceFork.totalBlocks = forkp-&gt;cf_blocks;
			bcopy(&amp;forkp-&gt;cf_extents[0], &amp;file-&gt;resourceFork.extents,
				<span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
			<span class="enscript-comment">/* Push blocks read to disk */</span>
			file-&gt;resourceFork.clumpSize =
					howmany(forkp-&gt;cf_bytesread, blksize);
		}
		<span class="enscript-keyword">if</span> (state-&gt;s_datafork) {
			forkp = state-&gt;s_datafork;
			file-&gt;dataFork.logicalSize = forkp-&gt;cf_size;
			file-&gt;dataFork.totalBlocks = forkp-&gt;cf_blocks;
			bcopy(&amp;forkp-&gt;cf_extents[0], &amp;file-&gt;dataFork.extents,
				<span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
			<span class="enscript-comment">/* Push blocks read to disk */</span>
			file-&gt;dataFork.clumpSize =
					howmany(forkp-&gt;cf_bytesread, blksize);
		}

		<span class="enscript-keyword">if</span> ((file-&gt;resourceFork.extents[0].startBlock != 0) &amp;&amp;
		    (file-&gt;resourceFork.extents[0].startBlock ==
		     file-&gt;dataFork.extents[0].startBlock)) {
			panic(<span class="enscript-string">&quot;hfs: catrec_update: rsrc fork == data fork&quot;</span>);
		}

		<span class="enscript-comment">/* Synchronize the lock state */</span>
		<span class="enscript-keyword">if</span> (attrp-&gt;ca_flags &amp; (SF_IMMUTABLE | UF_IMMUTABLE))
			file-&gt;flags |= kHFSFileLockedMask;
		<span class="enscript-keyword">else</span>
			file-&gt;flags &amp;= ~kHFSFileLockedMask;

		<span class="enscript-comment">/* Push out special field if necessary */</span>
		<span class="enscript-keyword">if</span> (S_ISBLK(attrp-&gt;ca_mode) || S_ISCHR(attrp-&gt;ca_mode)) {
			file-&gt;bsdInfo.special.rawDevice = attrp-&gt;ca_rdev;
		} 
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* 
			 * Protect against the degenerate case where the descriptor contains the
			 * raw inode ID in its CNID field.  If the HFSPlusCatalogFile record indicates
			 * the linkcount was greater than 1 (the default value), then it must have become
			 * a hardlink.  In this case, update the linkcount from the cat_attr passed in.
			 */</span>
			<span class="enscript-keyword">if</span> ((descp-&gt;cd_cnid != attrp-&gt;ca_fileid) || (attrp-&gt;ca_linkcount &gt; 1 ) ||
				(file-&gt;hl_linkCount &gt; 1)) {
				file-&gt;hl_linkCount = attrp-&gt;ca_linkcount;
			}
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (btNotFound);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* This function sets kHFSHasChildLinkBit in a directory hierarchy in the 
 * catalog btree of given cnid by walking up the parent chain till it reaches 
 * either the root folder, or the private metadata directory for storing 
 * directory hard links.  This function updates the corresponding in-core 
 * cnode, if any, and the directory record in the catalog btree.
 * On success, returns zero.  On failure, returns non-zero value.
 */</span>
__private_extern__
<span class="enscript-type">int</span> 
<span class="enscript-function-name">cat_set_childlinkbit</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> lockflags = 0;
	<span class="enscript-type">struct</span> cat_desc desc;
	<span class="enscript-type">struct</span> cat_attr attr;

	<span class="enscript-keyword">while</span> ((cnid != kHFSRootFolderID) &amp;&amp; (cnid != kHFSRootParentID) &amp;&amp;
	       (cnid != hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid)) {
		<span class="enscript-comment">/* Update the bit in corresponding cnode, if any, in the hash.
		 * If the cnode has the bit already set, stop the traversal.
		 */</span>
		retval = hfs_chash_set_childlinkbit(hfsmp, cnid);
		<span class="enscript-keyword">if</span> (retval == 0) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Update the catalog record on disk if either cnode was not
		 * found in the hash, or if a cnode was found and the cnode 
		 * did not have the bit set previously.
		 */</span>
		retval = hfs_start_transaction(hfsmp);
		<span class="enscript-keyword">if</span> (retval) {
			<span class="enscript-keyword">break</span>;
		}
		lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_EXCLUSIVE_LOCK);

		<span class="enscript-comment">/* Look up our catalog folder record */</span>
		retval = cat_idlookup(hfsmp, cnid, 0, 0, &amp;desc, &amp;attr, NULL);
		<span class="enscript-keyword">if</span> (retval) {
			hfs_systemfile_unlock(hfsmp, lockflags);
			hfs_end_transaction(hfsmp);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* Update the bit in the catalog record */</span>
		attr.ca_recflags |= kHFSHasChildLinkMask;
		retval = cat_update(hfsmp, &amp;desc, &amp;attr, NULL, NULL);
		<span class="enscript-keyword">if</span> (retval) {
			hfs_systemfile_unlock(hfsmp, lockflags);
			hfs_end_transaction(hfsmp);
			cat_releasedesc(&amp;desc);
			<span class="enscript-keyword">break</span>;
		}

		hfs_systemfile_unlock(hfsmp, lockflags);
		hfs_end_transaction(hfsmp);

		cnid = desc.cd_parentcnid;
		cat_releasedesc(&amp;desc);
	}

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-comment">/* This function traverses the parent directory hierarchy from the given 
 * directory to one level below root directory and checks if any of its 
 * ancestors is - 
 * 	1. A directory hard link.  
 * 	2. The 'pointed at' directory.
 * If any of these conditions fail or an internal error is encountered 
 * during look up of the catalog record, this function returns non-zero value.
 */</span>
__private_extern__
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_check_link_ancestry</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, cnid_t pointed_at_cnid)
{
	HFSPlusCatalogKey *keyp;
	BTreeIterator *ip;
	FSBufferDescriptor btdata;
	HFSPlusCatalogFolder folder;
	FCB *fcb;
	<span class="enscript-type">int</span> invalid;
	<span class="enscript-type">int</span> result;

	invalid = 0;
	BDINIT(btdata, &amp;folder);
	MALLOC(ip, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*ip), M_TEMP, M_WAITOK);
	keyp = (HFSPlusCatalogKey *)&amp;ip-&gt;key;
	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	<span class="enscript-keyword">while</span> (cnid != kHFSRootParentID) {
		<span class="enscript-comment">/* Check if the 'pointed at' directory is an ancestor */</span>
		<span class="enscript-keyword">if</span> (pointed_at_cnid == cnid) {
			invalid = 1;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((result = getkey(hfsmp, cnid, (CatalogKey *)keyp))) {
			printf(<span class="enscript-string">&quot;hfs: cat_check_link_ancestry: getkey failed id=%u, vol=%s\n&quot;</span>, cnid, hfsmp-&gt;vcbVN);
			invalid = 1;  <span class="enscript-comment">/* On errors, assume an invalid parent */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((result = BTSearchRecord(fcb, ip, &amp;btdata, NULL, NULL))) {
			printf(<span class="enscript-string">&quot;hfs: cat_check_link_ancestry: cannot find id=%u, vol=%s\n&quot;</span>, cnid, hfsmp-&gt;vcbVN);
			invalid = 1;  <span class="enscript-comment">/* On errors, assume an invalid parent */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Check if this ancestor is a directory hard link */</span>
		<span class="enscript-keyword">if</span> (folder.flags &amp; kHFSHasLinkChainMask) {
			invalid = 1;
			<span class="enscript-keyword">break</span>;
		}
		cnid = keyp-&gt;parentID;
	}
	FREE(ip, M_TEMP);
	<span class="enscript-keyword">return</span> (invalid);
}


<span class="enscript-comment">/*
 * update_siblinglinks_callback - update a link's chain
 */</span>

<span class="enscript-type">struct</span> linkupdate_state {
	cnid_t filelinkid;
	cnid_t prevlinkid;
	cnid_t nextlinkid;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">update_siblinglinks_callback</span>(__unused <span class="enscript-type">const</span> CatalogKey *ckp, CatalogRecord *crp, <span class="enscript-type">struct</span> linkupdate_state *state)
{
	HFSPlusCatalogFile *file;

	<span class="enscript-keyword">if</span> (crp-&gt;recordType != kHFSPlusFileRecord) {
		printf(<span class="enscript-string">&quot;hfs: update_siblinglinks_callback: unexpected rec type %d\n&quot;</span>, crp-&gt;recordType);
		<span class="enscript-keyword">return</span> (btNotFound);
	}

	file = (<span class="enscript-type">struct</span> HFSPlusCatalogFile *)crp;
	<span class="enscript-keyword">if</span> (file-&gt;flags &amp; kHFSHasLinkChainMask) {
		<span class="enscript-keyword">if</span> (state-&gt;prevlinkid != HFS_IGNORABLE_LINK) {
			file-&gt;hl_prevLinkID = state-&gt;prevlinkid;
		}
		<span class="enscript-keyword">if</span> (state-&gt;nextlinkid != HFS_IGNORABLE_LINK) {
			file-&gt;hl_nextLinkID = state-&gt;nextlinkid;
		}
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;hfs: update_siblinglinks_callback: file %d isn't a chain\n&quot;</span>, file-&gt;fileID);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * cat_update_siblinglinks - update a link's chain
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_update_siblinglinks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t linkfileid, cnid_t prevlinkid, cnid_t nextlinkid)
{
	FCB * fcb;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> linkupdate_state state;
	<span class="enscript-type">int</span> result;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	state.filelinkid = linkfileid;
	state.prevlinkid = prevlinkid;
	state.nextlinkid = nextlinkid;

	<span class="enscript-comment">/* Create an iterator for use by us temporarily */</span>
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	
	result = getkey(hfsmp, linkfileid, (CatalogKey *)&amp;iterator-&gt;key);
	<span class="enscript-keyword">if</span> (result == 0) {
		result = BTUpdateRecord(fcb, iterator, (IterateCallBackProcPtr)update_siblinglinks_callback, &amp;state);
		(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;hfs: cat_update_siblinglinks: couldn't resolve cnid=%d, vol=%s\n&quot;</span>, linkfileid, hfsmp-&gt;vcbVN);
	}
	
	FREE (iterator, M_TEMP);
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-comment">/*
 * cat_lookuplink - lookup a link by it's name
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookuplink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, cnid_t *linkfileid, cnid_t *prevlinkid,  cnid_t *nextlinkid)
{
	FCB * fcb;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	<span class="enscript-type">struct</span> HFSPlusCatalogFile file;
	<span class="enscript-type">int</span> result;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	<span class="enscript-comment">/* Create an iterator for use by us temporarily */</span>
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));

	<span class="enscript-keyword">if</span> ((result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	BDINIT(btdata, &amp;file);

	<span class="enscript-keyword">if</span> ((result = BTSearchRecord(fcb, iterator, &amp;btdata, NULL, NULL))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-keyword">if</span> (file.recordType != kHFSPlusFileRecord) {
		result = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	*linkfileid = file.fileID;

	<span class="enscript-keyword">if</span> (file.flags &amp; kHFSHasLinkChainMask) {
		*prevlinkid = file.hl_prevLinkID;
		*nextlinkid = file.hl_nextLinkID;
	} <span class="enscript-keyword">else</span> {
		*prevlinkid = 0;
		*nextlinkid = 0;
	}
<span class="enscript-reference">exit</span>:
	FREE(iterator, M_TEMP);
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_lookup_siblinglinks - lookup previous and next link ID for link using its cnid
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookup_siblinglinks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t linkfileid, cnid_t *prevlinkid,  cnid_t *nextlinkid)
{
	FCB * fcb;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	<span class="enscript-type">struct</span> HFSPlusCatalogFile file;
	<span class="enscript-type">int</span> result;

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	<span class="enscript-comment">/* Create an iterator for use by us temporarily */</span>
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	
	<span class="enscript-keyword">if</span> ((result = getkey(hfsmp, linkfileid, (CatalogKey *)&amp;iterator-&gt;key))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	BDINIT(btdata, &amp;file);

	<span class="enscript-keyword">if</span> ((result = BTSearchRecord(fcb, iterator, &amp;btdata, NULL, NULL))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-comment">/* The prev/next chain is only valid when kHFSHasLinkChainMask is set. */</span>
	<span class="enscript-keyword">if</span> (file.flags &amp; kHFSHasLinkChainMask) {
		cnid_t parent;

		parent = ((HFSPlusCatalogKey *)&amp;iterator-&gt;key)-&gt;parentID;

		<span class="enscript-comment">/* directory inodes don't have a chain (its in an EA) */</span>
		<span class="enscript-keyword">if</span> (parent == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
			result = ENOLINK;  <span class="enscript-comment">/* signal to caller to get head of list */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parent == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) {
			*prevlinkid = 0;
			*nextlinkid = file.hl_firstLinkID;
		} <span class="enscript-keyword">else</span> {
			*prevlinkid = file.hl_prevLinkID;
			*nextlinkid = file.hl_nextLinkID;
		}
	} <span class="enscript-keyword">else</span> {
		*prevlinkid = 0;
		*nextlinkid = 0;
	}
<span class="enscript-reference">exit</span>:
	FREE(iterator, M_TEMP);		
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_lookup_lastlink - find the last sibling link in the chain (no &quot;next&quot; ptr)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookup_lastlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t linkfileid, 
		cnid_t *lastlink, <span class="enscript-type">struct</span> cat_desc *cdesc)
{
	FCB * fcb;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	<span class="enscript-type">struct</span> HFSPlusCatalogFile file;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> itercount = 0;
	<span class="enscript-type">int</span> foundlast = 0;
	cnid_t currentlink = linkfileid;
	
	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	
	<span class="enscript-comment">/* Create an iterator for use by us temporarily */</span>
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);

	<span class="enscript-keyword">while</span> ((foundlast == 0) &amp;&amp; (itercount &lt; HFS_LINK_MAX )) {
		itercount++;
		bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));

		<span class="enscript-keyword">if</span> ((result = getkey(hfsmp, currentlink, (CatalogKey *)&amp;iterator-&gt;key))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		BDINIT(btdata, &amp;file);

		<span class="enscript-keyword">if</span> ((result = BTSearchRecord(fcb, iterator, &amp;btdata, NULL, NULL))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/* The prev/next chain is only valid when kHFSHasLinkChainMask is set. */</span>
		<span class="enscript-keyword">if</span> (file.flags &amp; kHFSHasLinkChainMask) {
			cnid_t parent;

			parent = ((HFSPlusCatalogKey *)&amp;iterator-&gt;key)-&gt;parentID;
			<span class="enscript-comment">/* 
			 * The raw inode for a directory hardlink doesn't have a chain.
			 * Its link information lives in an EA. 
			 */</span>
			<span class="enscript-keyword">if</span> (parent == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
				<span class="enscript-comment">/* We don't iterate to find the oldest directory hardlink. */</span>
				result = ENOLINK; 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			} 
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (parent == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) {
				<span class="enscript-comment">/* Raw inode for file hardlink (the base inode) */</span>
				currentlink = file.hl_firstLinkID;
			
				<span class="enscript-comment">/* 
				 * One minor special-casing here is necessary.
				 * If our ID brought us to the raw hardlink inode, and it does
				 * not have any siblings, then it's an open-unlinked file, and we
				 * should not proceed any further.
				 */</span> 
				<span class="enscript-keyword">if</span> (currentlink == 0) {
					result = ENOLINK;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
				}
			} 
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Otherwise, this item's parent is a legitimate directory in the namespace */</span>
				<span class="enscript-keyword">if</span> (file.hl_nextLinkID == 0) {
					<span class="enscript-comment">/* If nextLinkID is 0, then we found the end; no more hardlinks */</span>
					foundlast = 1;
					*lastlink = currentlink;
					<span class="enscript-comment">/* 
					 * Since we had to construct a catalog key to do this lookup
					 * we still hold it in-hand.  We might as well use it to build 
					 * the descriptor that the caller asked for.
					 */</span>
					builddesc ((HFSPlusCatalogKey*)&amp;iterator-&gt;key, currentlink, 0, 0, 0, cdesc);
					<span class="enscript-keyword">break</span>;
				}

				currentlink = file.hl_nextLinkID;
			}
		} 
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Sorry, can't help you without a link chain */</span>
			result = ENOLINK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}
<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/* If we didn't find what we were looking for, zero out the args */</span>
	<span class="enscript-keyword">if</span> (foundlast == 0) {
		<span class="enscript-keyword">if</span> (cdesc) {
			bzero (cdesc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));
		}
		<span class="enscript-keyword">if</span> (lastlink) {
			*lastlink = 0;
		}
	}

	FREE(iterator, M_TEMP);		
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * cat_createlink - create a link in the catalog
 *
 * The following cat_attr fields are expected to be set:
 *	 ca_linkref
 *	 ca_itime
 *	 ca_mode (S_IFREG)
 *	 ca_recflags
 *	 ca_flags
 *	 ca_finderinfo (type and creator)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_createlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp,
               cnid_t nextlinkid, cnid_t *linkfileid)
{
	FCB * fcb;
	<span class="enscript-type">struct</span> btobj * bto;
	FSBufferDescriptor btdata;
	HFSPlusForkData *rsrcforkp;
	u_int32_t nextCNID;
	u_int32_t datalen;
	u_int32_t encoding;
	<span class="enscript-type">int</span> thread_inserted = 0;
	<span class="enscript-type">int</span> alias_allocated = 0;
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> std_hfs;

	std_hfs = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);

	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	<span class="enscript-comment">/*
	 * Get the next CNID.  Note that we are currently holding catalog lock.
	 */</span>
	result = cat_acquire_cnid(hfsmp, &amp;nextCNID);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">return</span> result;
	}

	<span class="enscript-comment">/* Get space for iterator, key and data */</span>	
	MALLOC(bto, <span class="enscript-type">struct</span> btobj *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> btobj), M_TEMP, M_WAITOK);
	bto-&gt;iterator.hint.nodeNum = 0;
	rsrcforkp = &amp;bto-&gt;data.hfsPlusFile.resourceFork;

	result = buildkey(hfsmp, descp, &amp;bto-&gt;key, 0);
	<span class="enscript-keyword">if</span> (result) {
		printf(<span class="enscript-string">&quot;hfs: cat_createlink: err %d from buildkey\n&quot;</span>, result);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* This is our only chance to set the encoding (other than a rename). */</span>
	encoding = hfs_pickencoding(bto-&gt;key.nodeName.unicode, bto-&gt;key.nodeName.length);

	<span class="enscript-comment">/* 
	 * Insert the thread record first.
	 */</span>
	datalen = buildthread((<span class="enscript-type">void</span>*)&amp;bto-&gt;key, &amp;bto-&gt;data, 0, 0);
	btdata.bufferAddress = &amp;bto-&gt;data;
	btdata.itemSize = datalen;
	btdata.itemCount = 1;

	buildthreadkey(nextCNID, 0, (CatalogKey *) &amp;bto-&gt;iterator.key);
	result = BTInsertRecord(fcb, &amp;bto-&gt;iterator, &amp;btdata, datalen);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	thread_inserted = 1;

	<span class="enscript-comment">/*
	 * Now insert the link record.
	 */</span>
	buildrecord(attrp, nextCNID, 0, encoding, &amp;bto-&gt;data, &amp;datalen);
	
	bto-&gt;data.hfsPlusFile.hl_prevLinkID = 0;
	bto-&gt;data.hfsPlusFile.hl_nextLinkID = nextlinkid;
	bto-&gt;data.hfsPlusFile.hl_linkReference = attrp-&gt;ca_linkref;

	<span class="enscript-comment">/* For directory hard links, create alias in resource fork */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_flags &amp; CD_ISDIR) {
		<span class="enscript-keyword">if</span> ((result = cat_makealias(hfsmp, attrp-&gt;ca_linkref, &amp;bto-&gt;data.hfsPlusFile))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		alias_allocated = 1;
	}
	btdata.bufferAddress = &amp;bto-&gt;data;
	btdata.itemSize = datalen;
	btdata.itemCount = 1;
	
	bcopy(&amp;bto-&gt;key, &amp;bto-&gt;iterator.key, <span class="enscript-keyword">sizeof</span>(bto-&gt;key));

	result = BTInsertRecord(fcb, &amp;bto-&gt;iterator, &amp;btdata, datalen);
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (result == btExists)
			result = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	<span class="enscript-keyword">if</span> (linkfileid != NULL) {
		*linkfileid = nextCNID;
	}
<span class="enscript-reference">exit</span>:	
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (thread_inserted) {
			printf(<span class="enscript-string">&quot;hfs: cat_createlink: BTInsertRecord err=%d, vol=%s\n&quot;</span>, MacToVFSError(result), hfsmp-&gt;vcbVN);

			buildthreadkey(nextCNID, 0, (CatalogKey *)&amp;bto-&gt;iterator.key);
			<span class="enscript-keyword">if</span> (BTDeleteRecord(fcb, &amp;bto-&gt;iterator)) {
				printf(<span class="enscript-string">&quot;hfs: cat_createlink() failed to delete thread record on volume %s\n&quot;</span>, hfsmp-&gt;vcbVN);
				hfs_mark_inconsistent(hfsmp, HFS_ROLLBACK_FAILED);
			}
		}
		<span class="enscript-keyword">if</span> (alias_allocated &amp;&amp; rsrcforkp-&gt;extents[0].startBlock != 0) {
			(<span class="enscript-type">void</span>) BlockDeallocate(hfsmp, rsrcforkp-&gt;extents[0].startBlock,
					       rsrcforkp-&gt;extents[0].blockCount, 0);
			rsrcforkp-&gt;extents[0].startBlock = 0;
			rsrcforkp-&gt;extents[0].blockCount = 0;
		}
	}
	(<span class="enscript-type">void</span>) BTFlushPath(fcb);
	FREE(bto, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-comment">/* Directory hard links are visible as aliases on pre-Leopard systems and 
 * as normal directories on Leopard or later.  All directory hard link aliases 
 * have the same resource fork content except for the three uniquely 
 * identifying values that are updated in the resource fork data when the alias 
 * is created.  The following array is the constant resource fork data used 
 * only for creating directory hard link aliases.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> hfs_dirlink_alias_rsrc[] = {
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x9e, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x32, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x9a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9a, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x2b,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x01, 0x9e, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x32, 0x00, 0x00, 0x61, 0x6c, 0x69, 0x73,
	0x00, 0x00, 0x00, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

<span class="enscript-comment">/* Constants for directory hard link alias */</span>
<span class="enscript-type">enum</span> {
	<span class="enscript-comment">/* Size of resource fork data array for directory hard link alias */</span>
	kHFSAliasSize                = 0x1d0,

	<span class="enscript-comment">/* Volume type for ejectable devices like disk image */</span>
	kHFSAliasVolTypeEjectable    = 0x5,

	<span class="enscript-comment">/* Offset for volume create date, in Mac OS local time */</span>
	kHFSAliasVolCreateDateOffset = 0x12a,

	<span class="enscript-comment">/* Offset for the type of volume */</span>
	kHFSAliasVolTypeOffset       = 0x130,

	<span class="enscript-comment">/* Offset for folder ID of the parent directory of the directory inode */</span>
	kHFSAliasParentIDOffset      = 0x132,

	<span class="enscript-comment">/* Offset for folder ID of the directory inode */</span>
	kHFSAliasTargetIDOffset	     = 0x176,
};

<span class="enscript-comment">/* Create and write an alias that points at the directory represented by given
 * inode number on the same volume.  Directory hard links are visible as 
 * aliases in pre-Leopard systems and this function creates these aliases.  
 *
 * Note: This code is very specific to creating alias for the purpose 
 * of directory hard links only, and should not be generalized.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cat_makealias</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t inode_num, <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp)
{
	<span class="enscript-type">struct</span> buf *bp;
	daddr64_t blkno;
	u_int32_t blkcount;
	<span class="enscript-type">int</span> blksize;
	<span class="enscript-type">int</span> sectorsize;
	<span class="enscript-type">int</span> result;
	HFSPlusForkData *rsrcforkp;
	<span class="enscript-type">char</span> *alias;
	uint32_t *valptr;

	rsrcforkp = &amp;(crp-&gt;resourceFork);

	blksize = hfsmp-&gt;blockSize;
	blkcount = howmany(kHFSAliasSize, blksize);
	sectorsize = hfsmp-&gt;hfs_logical_block_size;
	bzero(rsrcforkp, <span class="enscript-keyword">sizeof</span>(HFSPlusForkData));

	<span class="enscript-comment">/* Allocate some disk space for the alias content. */</span>
	result = BlockAllocate(hfsmp, 0, blkcount, blkcount, 
			       HFS_ALLOC_FORCECONTIG | HFS_ALLOC_METAZONE, 
	                       &amp;rsrcforkp-&gt;extents[0].startBlock,
	                       &amp;rsrcforkp-&gt;extents[0].blockCount);
	<span class="enscript-comment">/* Did it fail with an out of space error? If so, re-try and allow journal flushing. */</span>
	<span class="enscript-keyword">if</span> (result == dskFulErr ) {	
		result = BlockAllocate(hfsmp, 0, blkcount, blkcount, 
			       HFS_ALLOC_FORCECONTIG | HFS_ALLOC_METAZONE | HFS_ALLOC_FLUSHTXN, 
	                       &amp;rsrcforkp-&gt;extents[0].startBlock,
	                       &amp;rsrcforkp-&gt;extents[0].blockCount);
	}
	<span class="enscript-keyword">if</span> (result) {
		rsrcforkp-&gt;extents[0].startBlock = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* Acquire a buffer cache block for our block. */</span>
	blkno = ((u_int64_t)rsrcforkp-&gt;extents[0].startBlock * (u_int64_t)blksize) / sectorsize;
	blkno += hfsmp-&gt;hfsPlusIOPosOffset / sectorsize;

	bp = buf_getblk(hfsmp-&gt;hfs_devvp, blkno, roundup(kHFSAliasSize, hfsmp-&gt;hfs_logical_block_size), 0, 0, BLK_META);
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_start(hfsmp-&gt;jnl, bp);
	}

	<span class="enscript-comment">/* Generate alias content */</span>
	alias = (<span class="enscript-type">char</span> *)buf_dataptr(bp);
	bzero(alias, buf_size(bp));
	bcopy(hfs_dirlink_alias_rsrc, alias, kHFSAliasSize);

	<span class="enscript-comment">/* Set the volume create date, local time in Mac OS format */</span>
	valptr = (uint32_t *)(alias + kHFSAliasVolCreateDateOffset);
	*valptr = OSSwapHostToBigInt32(hfsmp-&gt;localCreateDate);

	<span class="enscript-comment">/* If the file system is on a virtual device like disk image, 
	 * update the volume type to be ejectable device.  
	 */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_VIRTUAL_DEVICE) {
		*(uint16_t *)(alias + kHFSAliasVolTypeOffset) = 
		OSSwapHostToBigInt16(kHFSAliasVolTypeEjectable);
	}

	<span class="enscript-comment">/* Set id of the parent of the target directory */</span>
	valptr = (uint32_t *)(alias + kHFSAliasParentIDOffset);
	*valptr = OSSwapHostToBigInt32(hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid);

	<span class="enscript-comment">/* Set id of the target directory */</span>
	valptr = (uint32_t *)(alias + kHFSAliasTargetIDOffset);
	*valptr = OSSwapHostToBigInt32(inode_num);

	<span class="enscript-comment">/* Write alias content to disk. */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl) {
		journal_modify_block_end(hfsmp-&gt;jnl, bp, NULL, NULL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result = buf_bwrite(bp))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-comment">/* Finish initializing the fork data. */</span>
	rsrcforkp-&gt;logicalSize = kHFSAliasSize;
	rsrcforkp-&gt;totalBlocks = rsrcforkp-&gt;extents[0].blockCount;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (result &amp;&amp; rsrcforkp-&gt;extents[0].startBlock != 0) {
		(<span class="enscript-type">void</span>) BlockDeallocate(hfsmp, rsrcforkp-&gt;extents[0].startBlock, rsrcforkp-&gt;extents[0].blockCount, 0);
		rsrcforkp-&gt;extents[0].startBlock = 0;
		rsrcforkp-&gt;extents[0].blockCount = 0;
		rsrcforkp-&gt;logicalSize = 0;
		rsrcforkp-&gt;totalBlocks = 0;
	}
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * cat_deletelink - delete a link from the catalog
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_deletelink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp)
{
	<span class="enscript-type">struct</span> HFSPlusCatalogFile file;
	<span class="enscript-type">struct</span> cat_attr cattr;
	uint32_t totalBlocks;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> result;

	bzero(&amp;file, <span class="enscript-keyword">sizeof</span> (file));
	bzero(&amp;cattr, <span class="enscript-keyword">sizeof</span> (cattr));
	cattr.ca_fileid = descp-&gt;cd_cnid;

	<span class="enscript-comment">/* Directory links have alias content to remove. */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_flags &amp; CD_ISDIR) {
		FCB * fcb;
		BTreeIterator * iterator;
		<span class="enscript-type">struct</span> FSBufferDescriptor btdata;
	
		fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;
	
		<span class="enscript-comment">/* Borrow the btcb iterator since we have an exclusive catalog lock. */</span>	
		iterator = &amp;((BTreeControlBlockPtr)(fcb-&gt;ff_sysfileinfo))-&gt;iterator;
		iterator-&gt;hint.nodeNum = 0;
	
		<span class="enscript-keyword">if</span> ((result = buildkey(hfsmp, descp, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		BDINIT(btdata, &amp;file);
	
		<span class="enscript-keyword">if</span> ((result = BTSearchRecord(fcb, iterator, &amp;btdata, NULL, NULL))) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	}

	result = cat_delete(hfsmp, descp, &amp;cattr);
	
	<span class="enscript-keyword">if</span> ((result == 0) &amp;&amp; 
	    (descp-&gt;cd_flags &amp; CD_ISDIR) &amp;&amp; 
	    (file.recordType == kHFSPlusFileRecord)) {

		totalBlocks = file.resourceFork.totalBlocks;

		<span class="enscript-keyword">for</span> (i = 0; (i &lt; 8) &amp;&amp; (totalBlocks &gt; 0); i++) {
			<span class="enscript-keyword">if</span> ((file.resourceFork.extents[i].blockCount == 0) &amp;&amp;
			    (file.resourceFork.extents[i].startBlock == 0)) {
				<span class="enscript-keyword">break</span>;
			}

			(<span class="enscript-type">void</span>) BlockDeallocate(hfsmp, 
				file.resourceFork.extents[i].startBlock, 
				file.resourceFork.extents[i].blockCount, 0);

			totalBlocks -= file.resourceFork.extents[i].blockCount;
			file.resourceFork.extents[i].startBlock = 0;
			file.resourceFork.extents[i].blockCount = 0;
		}
	}
<span class="enscript-reference">exit</span>:	
	<span class="enscript-keyword">return</span> (result);
}


<span class="enscript-comment">/*
 * Callback to collect directory entries.
 * Called with readattr_state for each item in a directory.
 */</span>
<span class="enscript-type">struct</span> readattr_state {
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">struct</span> cat_entrylist *list;
	cnid_t	dir_cnid;
	<span class="enscript-type">int</span> stdhfs;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> reached_eof;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getentriesattr_callback</span>(<span class="enscript-type">const</span> CatalogKey *key, <span class="enscript-type">const</span> CatalogRecord *rec,
             <span class="enscript-type">struct</span> readattr_state *state)
{
	<span class="enscript-type">struct</span> cat_entrylist *list = state-&gt;list;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = state-&gt;hfsmp;
	<span class="enscript-type">struct</span> cat_entry *cep;
	cnid_t parentcnid;

	<span class="enscript-keyword">if</span> (list-&gt;realentries &gt;= list-&gt;maxentries)
		<span class="enscript-keyword">return</span> (0);  <span class="enscript-comment">/* stop */</span>
	
	parentcnid = state-&gt;stdhfs ? key-&gt;hfs.parentID : key-&gt;hfsPlus.parentID;

	<span class="enscript-keyword">switch</span>(rec-&gt;recordType) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileRecord</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileRecord</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (parentcnid != state-&gt;dir_cnid) {
			state-&gt;error = ENOENT;
			state-&gt;reached_eof = 1;
			<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		state-&gt;error = ENOENT;
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
	}

	<span class="enscript-comment">/* Hide the private system directories and journal files */</span>
	<span class="enscript-keyword">if</span> (parentcnid == kHFSRootFolderID) {
		<span class="enscript-keyword">if</span> (rec-&gt;recordType == kHFSPlusFolderRecord) {
			<span class="enscript-keyword">if</span> (rec-&gt;hfsPlusFolder.folderID == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
			    rec-&gt;hfsPlusFolder.folderID == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
			    	list-&gt;skipentries++;
				<span class="enscript-keyword">return</span> (1);	<span class="enscript-comment">/* continue */</span>
			}
		}
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;jnl || ((HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY))) &amp;&amp;
		    (rec-&gt;recordType == kHFSPlusFileRecord) &amp;&amp;
		    ((rec-&gt;hfsPlusFile.fileID == hfsmp-&gt;hfs_jnlfileid) ||
		     (rec-&gt;hfsPlusFile.fileID == hfsmp-&gt;hfs_jnlinfoblkid))) {
			list-&gt;skipentries++;
			<span class="enscript-keyword">return</span> (1);	<span class="enscript-comment">/* continue */</span>
		}
	}

	cep = &amp;list-&gt;entry[list-&gt;realentries++];
 
	<span class="enscript-keyword">if</span> (state-&gt;stdhfs == 0) {
		getbsdattr(hfsmp, (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSPlusCatalogFile *)rec, &amp;cep-&gt;ce_attr);
		builddesc((<span class="enscript-type">const</span> HFSPlusCatalogKey *)key, getcnid(rec), 0, getencoding(rec),
				isadir(rec), &amp;cep-&gt;ce_desc);

		<span class="enscript-keyword">if</span> (rec-&gt;recordType == kHFSPlusFileRecord) {
			cep-&gt;ce_datasize = rec-&gt;hfsPlusFile.dataFork.logicalSize;
			cep-&gt;ce_datablks = rec-&gt;hfsPlusFile.dataFork.totalBlocks;
			cep-&gt;ce_rsrcsize = rec-&gt;hfsPlusFile.resourceFork.logicalSize;
			cep-&gt;ce_rsrcblks = rec-&gt;hfsPlusFile.resourceFork.totalBlocks;

			<span class="enscript-comment">/* Save link reference for later processing. */</span>
			<span class="enscript-keyword">if</span> ((SWAP_BE32(rec-&gt;hfsPlusFile.userInfo.fdType) == kHardLinkFileType) &amp;&amp;
					(SWAP_BE32(rec-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSPlusCreator)) {
				cep-&gt;ce_attr.ca_linkref = rec-&gt;hfsPlusFile.bsdInfo.special.iNodeNum;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rec-&gt;hfsPlusFile.flags &amp; kHFSHasLinkChainMask) &amp;&amp; 
					(SWAP_BE32(rec-&gt;hfsPlusFile.userInfo.fdType) == kHFSAliasType) &amp;&amp; 
					(SWAP_BE32(rec-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSAliasCreator)) {
				cep-&gt;ce_attr.ca_linkref = rec-&gt;hfsPlusFile.bsdInfo.special.iNodeNum;
			}
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> HFSPlusCatalogFile cnoderec;
		HFSPlusCatalogKey * pluskey;
		u_int32_t encoding;

		promoteattr(hfsmp, rec, &amp;cnoderec);
		getbsdattr(hfsmp, &amp;cnoderec, &amp;cep-&gt;ce_attr);

		MALLOC(pluskey, HFSPlusCatalogKey *, <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogKey), M_TEMP, M_WAITOK);
		promotekey(hfsmp, (<span class="enscript-type">const</span> HFSCatalogKey *)key, pluskey, &amp;encoding);
		builddesc(pluskey, getcnid(rec), 0, encoding, isadir(rec), &amp;cep-&gt;ce_desc);
		FREE(pluskey, M_TEMP);

		<span class="enscript-keyword">if</span> (rec-&gt;recordType == kHFSFileRecord) {
			<span class="enscript-type">int</span> blksize = HFSTOVCB(hfsmp)-&gt;blockSize;

			cep-&gt;ce_datasize = rec-&gt;hfsFile.dataLogicalSize;
			cep-&gt;ce_datablks = rec-&gt;hfsFile.dataPhysicalSize / blksize;
			cep-&gt;ce_rsrcsize = rec-&gt;hfsFile.rsrcLogicalSize;
			cep-&gt;ce_rsrcblks = rec-&gt;hfsFile.rsrcPhysicalSize / blksize;
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (list-&gt;realentries &lt; list-&gt;maxentries);
}

<span class="enscript-comment">/*
 * Pack a cat_entrylist buffer with attributes from the catalog
 *
 * Note: index is zero relative
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_getentriesattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, directoryhint_t *dirhint, <span class="enscript-type">struct</span> cat_entrylist *ce_list, <span class="enscript-type">int</span> *reachedeof)
{
	FCB* fcb;
	CatalogKey * key;
	BTreeIterator * iterator;
	<span class="enscript-type">struct</span> readattr_state state;
	cnid_t parentcnid;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> std_hfs;
	<span class="enscript-type">int</span> index;
	<span class="enscript-type">int</span> have_key;
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">int</span> reached_eof = 0;

	ce_list-&gt;realentries = 0;

	fcb = GetFileControlBlock(HFSTOVCB(hfsmp)-&gt;catalogRefNum);
	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);
	parentcnid = dirhint-&gt;dh_desc.cd_parentcnid;

	bzero (&amp;state, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> readattr_state));

	state.hfsmp = hfsmp;
	state.list = ce_list;
	state.dir_cnid = parentcnid;
	state.stdhfs = std_hfs;
	state.error = 0;

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	key = (CatalogKey *)&amp;iterator-&gt;key;
	have_key = 0;
	iterator-&gt;hint.nodeNum = dirhint-&gt;dh_desc.cd_hint;
	index = dirhint-&gt;dh_index + 1;

	<span class="enscript-comment">/*
	 * Attempt to build a key from cached filename
	 */</span>
	<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_namelen != 0) {
		<span class="enscript-keyword">if</span> (buildkey(hfsmp, &amp;dirhint-&gt;dh_desc, (HFSPlusCatalogKey *)key, 0) == 0) {
			have_key = 1;
		}
	}

	<span class="enscript-comment">/*
	 * If the last entry wasn't cached then position the btree iterator
	 */</span>
	<span class="enscript-keyword">if</span> ((index == 0) || !have_key) {
		<span class="enscript-comment">/*
		 * Position the iterator at the directory's thread record.
		 * (i.e. just before the first entry)
		 */</span>
		buildthreadkey(dirhint-&gt;dh_desc.cd_parentcnid, (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD), key);
		result = BTSearchRecord(fcb, iterator, NULL, NULL, iterator);
		<span class="enscript-keyword">if</span> (result) {
			result = MacToVFSError(result);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
	
		<span class="enscript-comment">/*
		 * Iterate until we reach the entry just
		 * before the one we want to start with.
		 */</span>
		<span class="enscript-keyword">if</span> (index &gt; 0) {
			<span class="enscript-type">struct</span> position_state ps;

			ps.error = 0;
			ps.count = 0;
			ps.index = index;
			ps.parentID = dirhint-&gt;dh_desc.cd_parentcnid;
			ps.hfsmp = hfsmp;

			result = BTIterateRecords(fcb, kBTreeNextRecord, iterator,
			                          (IterateCallBackProcPtr)cat_findposition, &amp;ps);
			<span class="enscript-keyword">if</span> (ps.error)
				result = ps.error;
			<span class="enscript-keyword">else</span>
				result = MacToVFSError(result);
			
			<span class="enscript-keyword">if</span> (result) {
				<span class="enscript-comment">/*
				* Note: the index may now point to EOF if the directory
				* was modified in between system calls. We will return
				* ENOENT from cat_findposition if this is the case, and
				* when we bail out with an error, our caller (hfs_readdirattr_internal)
				* will suppress the error and indicate EOF to its caller.
				*/</span>
				result = MacToVFSError(result);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		}
	}

	<span class="enscript-comment">/* Fill list with entries starting at iterator-&gt;key. */</span>
	result = BTIterateRecords(fcb, kBTreeNextRecord, iterator,
			(IterateCallBackProcPtr)getentriesattr_callback, &amp;state);

	<span class="enscript-keyword">if</span> (state.error) {
		result = state.error;
		reached_eof = state.reached_eof;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ce_list-&gt;realentries == 0) {
		result = ENOENT;
		reached_eof = 1;
	}
	<span class="enscript-keyword">else</span> {
		result = MacToVFSError(result);
	}

	<span class="enscript-keyword">if</span> (std_hfs)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/*
	 *  Resolve any hard links.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)ce_list-&gt;realentries; ++i) {
		<span class="enscript-type">struct</span> FndrFileInfo *fip;
		<span class="enscript-type">struct</span> cat_entry *cep;
		<span class="enscript-type">struct</span> HFSPlusCatalogFile filerec;
		<span class="enscript-type">int</span> isdirlink = 0;
		<span class="enscript-type">int</span> isfilelink = 0;

		cep = &amp;ce_list-&gt;entry[i];
		<span class="enscript-keyword">if</span> (cep-&gt;ce_attr.ca_linkref == 0)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* Note: Finder info is still in Big Endian */</span>
		fip = (<span class="enscript-type">struct</span> FndrFileInfo *)&amp;cep-&gt;ce_attr.ca_finderinfo;

		<span class="enscript-keyword">if</span> (S_ISREG(cep-&gt;ce_attr.ca_mode) &amp;&amp;
		    (SWAP_BE32(fip-&gt;fdType) == kHardLinkFileType) &amp;&amp;
		    (SWAP_BE32(fip-&gt;fdCreator) == kHFSPlusCreator)) {
			isfilelink = 1;
		}
		<span class="enscript-keyword">if</span> (S_ISREG(cep-&gt;ce_attr.ca_mode) &amp;&amp;
		    (SWAP_BE32(fip-&gt;fdType) == kHFSAliasType) &amp;&amp;
		    (SWAP_BE32(fip-&gt;fdCreator) == kHFSAliasCreator) &amp;&amp;
		    (cep-&gt;ce_attr.ca_recflags &amp; kHFSHasLinkChainMask)) {
			isdirlink = 1;
		}
		<span class="enscript-keyword">if</span> (isfilelink || isdirlink) {
			<span class="enscript-keyword">if</span> (cat_resolvelink(hfsmp, cep-&gt;ce_attr.ca_linkref, isdirlink, &amp;filerec) != 0)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* Repack entry from inode record. */</span>
			getbsdattr(hfsmp, &amp;filerec, &amp;cep-&gt;ce_attr);		
			cep-&gt;ce_datasize = filerec.dataFork.logicalSize;
			cep-&gt;ce_datablks = filerec.dataFork.totalBlocks;
			cep-&gt;ce_rsrcsize = filerec.resourceFork.logicalSize;
			cep-&gt;ce_rsrcblks = filerec.resourceFork.totalBlocks;
		}
	}

<span class="enscript-reference">exit</span>:
	FREE(iterator, M_TEMP);
	*reachedeof = reached_eof;
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SMALL_DIRENTRY_SIZE</span>  (int)(sizeof(struct dirent) - (MAXNAMLEN + 1) + 8)

<span class="enscript-comment">/*
 * Callback to pack directory entries.
 * Called with packdirentry_state for each item in a directory.
 */</span>

<span class="enscript-comment">/* Hard link information collected during cat_getdirentries. */</span>
<span class="enscript-type">struct</span> linkinfo {
	u_int32_t       link_ref;
	user_addr_t  dirent_addr;
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> linkinfo linkinfo_t;

<span class="enscript-comment">/* State information for the getdirentries_callback function. */</span>
<span class="enscript-type">struct</span> packdirentry_state {
	<span class="enscript-type">int</span>            cbs_flags;		<span class="enscript-comment">/* VNODE_READDIR_* flags */</span>
	u_int32_t      cbs_parentID;
	u_int32_t      cbs_index;
	uio_t	       cbs_uio;
	ExtendedVCB *  cbs_hfsmp;
	<span class="enscript-type">int</span>            cbs_result;
	int32_t        cbs_nlinks;
	int32_t        cbs_maxlinks;
	linkinfo_t *   cbs_linkinfo;
	<span class="enscript-type">struct</span> cat_desc * cbs_desc;
	u_int8_t        * cbs_namebuf;
	<span class="enscript-comment">/*
	 * The following fields are only used for NFS readdir, which
	 * uses the next file id as the seek offset of each entry.
	 */</span>
	<span class="enscript-type">struct</span> direntry * cbs_direntry;
	<span class="enscript-type">struct</span> direntry * cbs_prevdirentry;
	u_int32_t      cbs_previlinkref;
	Boolean        cbs_hasprevdirentry;
	Boolean        cbs_eof;
};

<span class="enscript-comment">/*
 * getdirentries callback for HFS Plus directories.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentries_callback</span>(<span class="enscript-type">const</span> CatalogKey *ckp, <span class="enscript-type">const</span> CatalogRecord *crp,
                 <span class="enscript-type">struct</span> packdirentry_state *state)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">const</span> CatalogName *cnp;
	cnid_t curID;
	OSErr result;
	<span class="enscript-type">struct</span> dirent catent;
	<span class="enscript-type">struct</span> direntry * entry = NULL;
	time_t itime;
	u_int32_t ilinkref = 0;
	u_int32_t curlinkref = 0;
	cnid_t  cnid;
	<span class="enscript-type">int</span> hide = 0;
	u_int8_t type = DT_UNKNOWN;
	u_int8_t is_mangled = 0;
	u_int8_t is_link = 0;
	u_int8_t *nameptr;
	user_addr_t uiobase = USER_ADDR_NULL;
	size_t namelen = 0;
	size_t maxnamelen;
	size_t uiosize = 0;
	caddr_t uioaddr;
	Boolean stop_after_pack = false;
	
	hfsmp = state-&gt;cbs_hfsmp;
	curID = ckp-&gt;hfsPlus.parentID;

	<span class="enscript-comment">/* We're done when parent directory changes */</span>
	<span class="enscript-keyword">if</span> (state-&gt;cbs_parentID != curID) {
		<span class="enscript-comment">/*
		 * If the parent ID is different from curID this means we've hit
		 * the EOF for the directory.  To help future callers, we mark
		 * the cbs_eof boolean.  However, we should only mark the EOF 
		 * boolean if we're about to return from this function. 
		 *
		 * This is because this callback function does its own uiomove
		 * to get the data to userspace.  If we set the boolean before determining
		 * whether or not the current entry has enough room to write its
		 * data to userland, we could fool the callers of this catalog function
		 * into thinking they've hit EOF earlier than they really would have.
		 * In that case, we'd know that we have more entries to process and
		 * send to userland, but we didn't have enough room.  
		 * 
		 * To be safe, we mark cbs_eof here ONLY for the cases where we know we're 
		 * about to return and won't write any new data back
		 * to userland.  In the stop_after_pack case, we'll set this boolean
		 * regardless, so it's slightly safer to let that logic mark the boolean,
		 * especially since it's closer to the return of this function.
		 */</span>		 
			
		<span class="enscript-keyword">if</span> (state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) {
			<span class="enscript-comment">/* The last record has not been returned yet, so we 
			 * want to stop after packing the last item 
			 */</span>
			<span class="enscript-keyword">if</span> (state-&gt;cbs_hasprevdirentry) { 
				stop_after_pack = true;
			} <span class="enscript-keyword">else</span> {
				state-&gt;cbs_eof = true;
				state-&gt;cbs_result = ENOENT;
				<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
			}				
		} <span class="enscript-keyword">else</span> {
			state-&gt;cbs_eof = true;
			state-&gt;cbs_result = ENOENT;
			<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
		}
	}

	<span class="enscript-keyword">if</span> (state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) {
		entry = state-&gt;cbs_direntry;
		nameptr = (u_int8_t *)&amp;entry-&gt;d_name[0];
		<span class="enscript-keyword">if</span> (state-&gt;cbs_flags &amp; VNODE_READDIR_NAMEMAX) {
			<span class="enscript-comment">/*
			 * The NFS server sometimes needs to make filenames fit in
			 * NAME_MAX bytes (since its client may not be able to
			 * handle a longer name).  In that case, NFS will ask us
			 * to mangle the name to keep it short enough.
			 */</span>
			maxnamelen = NAME_MAX + 1;
		} <span class="enscript-keyword">else</span> {
			maxnamelen = <span class="enscript-keyword">sizeof</span>(entry-&gt;d_name);
		}
	} <span class="enscript-keyword">else</span> {
		nameptr = (u_int8_t *)&amp;catent.d_name[0];
		maxnamelen = <span class="enscript-keyword">sizeof</span>(catent.d_name);
	}

	<span class="enscript-keyword">if</span> ((state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) &amp;&amp; stop_after_pack) {
		<span class="enscript-comment">/* The last item returns a non-zero invalid cookie */</span>
		cnid = INT_MAX;		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span>(crp-&gt;recordType) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderRecord</span>:
			type = DT_DIR;
			cnid = crp-&gt;hfsPlusFolder.folderID;
			<span class="enscript-comment">/* Hide our private system directories. */</span>
			<span class="enscript-keyword">if</span> (curID == kHFSRootFolderID) {
				<span class="enscript-keyword">if</span> (cnid == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid ||
				    cnid == hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid) {
					hide = 1;
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileRecord</span>:
			itime = to_bsd_time(crp-&gt;hfsPlusFile.createDate);
			type = MODE_TO_DT(crp-&gt;hfsPlusFile.bsdInfo.fileMode);
			cnid = crp-&gt;hfsPlusFile.fileID;
			<span class="enscript-comment">/*
			 * When a hardlink link is encountered save its link ref.
			 */</span>
			<span class="enscript-keyword">if</span> ((SWAP_BE32(crp-&gt;hfsPlusFile.userInfo.fdType) == kHardLinkFileType) &amp;&amp;
				(SWAP_BE32(crp-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSPlusCreator) &amp;&amp;
				((itime == (time_t)hfsmp-&gt;hfs_itime) ||
				 (itime == (time_t)hfsmp-&gt;hfs_metadata_createdate))) {
				<span class="enscript-comment">/* If link ref is inode's file id then use it directly. */</span>
				<span class="enscript-keyword">if</span> (crp-&gt;hfsPlusFile.flags &amp; kHFSHasLinkChainMask) {
					cnid = crp-&gt;hfsPlusFile.hl_linkReference;
				} <span class="enscript-keyword">else</span> {
					ilinkref = crp-&gt;hfsPlusFile.hl_linkReference;
				}
				is_link =1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((SWAP_BE32(crp-&gt;hfsPlusFile.userInfo.fdType) == kHFSAliasType) &amp;&amp;
				(SWAP_BE32(crp-&gt;hfsPlusFile.userInfo.fdCreator) == kHFSAliasCreator) &amp;&amp;
				(crp-&gt;hfsPlusFile.flags &amp; kHFSHasLinkChainMask) &amp;&amp;
				(crp-&gt;hfsPlusFile.hl_linkReference &gt;= kHFSFirstUserCatalogNodeID) &amp;&amp;
				((itime == (time_t)hfsmp-&gt;hfs_itime) ||
				 (itime == (time_t)hfsmp-&gt;hfs_metadata_createdate))) {
				<span class="enscript-comment">/* A directory's link resolves to a directory. */</span>
				type = DT_DIR;
				<span class="enscript-comment">/* A directory's link ref is always inode's file id. */</span>
				cnid = crp-&gt;hfsPlusFile.hl_linkReference;
				is_link = 1;
			}
			<span class="enscript-comment">/* Hide the journal files */</span>
			<span class="enscript-keyword">if</span> ((curID == kHFSRootFolderID) &amp;&amp;
				((hfsmp-&gt;jnl || ((HFSTOVCB(hfsmp)-&gt;vcbAtrb &amp; kHFSVolumeJournaledMask) &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY)))) &amp;&amp;
				((cnid == hfsmp-&gt;hfs_jnlfileid) ||
				 (cnid == hfsmp-&gt;hfs_jnlinfoblkid))) {
				hide = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
		};

		cnp = (<span class="enscript-type">const</span> CatalogName*) &amp;ckp-&gt;hfsPlus.nodeName;

		namelen = cnp-&gt;ustr.length;
		<span class="enscript-comment">/*
		 * For MacRoman encoded names, assume that its ascii and
		 * convert it directly in an attempt to avoid the more
		 * expensive utf8_encodestr conversion.
		 */</span>
		<span class="enscript-keyword">if</span> ((namelen &lt; maxnamelen) &amp;&amp; (crp-&gt;hfsPlusFile.textEncoding == 0)) {
			<span class="enscript-type">int</span> i;
			u_int16_t ch;
			<span class="enscript-type">const</span> u_int16_t *chp;

			chp = &amp;cnp-&gt;ustr.unicode[0];
			<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)namelen; ++i) {
				ch = *chp++;
				<span class="enscript-keyword">if</span> (ch &gt; 0x007f || ch == 0x0000) {
					<span class="enscript-comment">/* Perform expensive utf8_encodestr conversion */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">encodestr</span>;
				}
				nameptr[i] = (ch == <span class="enscript-string">'/'</span>) ? <span class="enscript-string">':'</span> : (u_int8_t)ch;
			}
			nameptr[namelen] = <span class="enscript-string">'\0'</span>;
			result = 0;
		} <span class="enscript-keyword">else</span> {
<span class="enscript-reference">encodestr</span>:
			result = utf8_encodestr(cnp-&gt;ustr.unicode, namelen * <span class="enscript-keyword">sizeof</span>(UniChar),
						nameptr, &amp;namelen, maxnamelen, <span class="enscript-string">':'</span>, 0);
		}

		<span class="enscript-comment">/* Check result returned from encoding the filename to utf8 */</span>
		<span class="enscript-keyword">if</span> (result == ENAMETOOLONG) {
			<span class="enscript-comment">/* 
			 * If we were looking at a catalog record for a hardlink (not the inode),
			 * then we want to use its link ID as opposed to the inode ID for 
			 * a mangled name.  For all other cases, they are the same.  Note that
			 * due to the way directory hardlinks are implemented, the actual link
			 * is going to be counted as a file record, so we can catch both
			 * with is_link.
			 */</span>
			cnid_t linkid = cnid;
			<span class="enscript-keyword">if</span> (is_link) {
				linkid =  crp-&gt;hfsPlusFile.fileID;
			}

			result = ConvertUnicodeToUTF8Mangled(cnp-&gt;ustr.length * <span class="enscript-keyword">sizeof</span>(UniChar),
							     cnp-&gt;ustr.unicode, maxnamelen,
							     (ByteCount*)&amp;namelen, nameptr, linkid);		
			is_mangled = 1;
		}
	}

	<span class="enscript-keyword">if</span> (state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) {
		<span class="enscript-comment">/*
		 * The index is 1 relative and includes &quot;.&quot; and &quot;..&quot;
		 *
		 * Also stuff the cnid in the upper 32 bits of the cookie.
		 * The cookie is stored to the previous entry, which will
		 * be packed and copied this time
		 */</span>
		state-&gt;cbs_prevdirentry-&gt;d_seekoff = (state-&gt;cbs_index + 3) | ((u_int64_t)cnid &lt;&lt; 32);
		uiosize = state-&gt;cbs_prevdirentry-&gt;d_reclen;
		uioaddr = (caddr_t) state-&gt;cbs_prevdirentry;
	} <span class="enscript-keyword">else</span> {
		catent.d_type = type;
		catent.d_namlen = namelen;
		catent.d_reclen = uiosize = STD_DIRENT_LEN(namelen);
		<span class="enscript-keyword">if</span> (hide)
			catent.d_fileno = 0;  <span class="enscript-comment">/* file number = 0 means skip entry */</span>
		<span class="enscript-keyword">else</span>
			catent.d_fileno = cnid;
		uioaddr = (caddr_t) &amp;catent;
	}

	<span class="enscript-comment">/* Save current base address for post processing of hard-links. */</span>
	<span class="enscript-keyword">if</span> (ilinkref || state-&gt;cbs_previlinkref) {
		uiobase = uio_curriovbase(state-&gt;cbs_uio);
	}
	<span class="enscript-comment">/* If this entry won't fit then we're done */</span>
	<span class="enscript-keyword">if</span> ((uiosize &gt; (user_size_t)uio_resid(state-&gt;cbs_uio)) ||
	    (ilinkref != 0 &amp;&amp; state-&gt;cbs_nlinks == state-&gt;cbs_maxlinks)) {
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
	}

	<span class="enscript-keyword">if</span> (!(state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) || state-&gt;cbs_hasprevdirentry) {
		state-&gt;cbs_result = uiomove(uioaddr, uiosize, state-&gt;cbs_uio);
		<span class="enscript-keyword">if</span> (state-&gt;cbs_result == 0) {
			++state-&gt;cbs_index;

			<span class="enscript-comment">/* Remember previous entry */</span>
			state-&gt;cbs_desc-&gt;cd_cnid = cnid;
			<span class="enscript-keyword">if</span> (type == DT_DIR) {
				state-&gt;cbs_desc-&gt;cd_flags |= CD_ISDIR;
			} <span class="enscript-keyword">else</span> {
				state-&gt;cbs_desc-&gt;cd_flags &amp;= ~CD_ISDIR;
			}
			<span class="enscript-keyword">if</span> (state-&gt;cbs_desc-&gt;cd_nameptr != NULL) {
				state-&gt;cbs_desc-&gt;cd_namelen = 0;
			}
#<span class="enscript-reference">if</span> 0
			state-&gt;cbs_desc-&gt;cd_encoding = xxxx;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (!is_mangled) {
				state-&gt;cbs_desc-&gt;cd_namelen = namelen;
				bcopy(nameptr, state-&gt;cbs_namebuf, namelen + 1);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Store unmangled name for the directory hint else it will 
				 * restart readdir at the last location again 
				 */</span>
				u_int8_t *new_nameptr;
				size_t bufsize;
				size_t tmp_namelen = 0;
			
				cnp = (<span class="enscript-type">const</span> CatalogName *)&amp;ckp-&gt;hfsPlus.nodeName;
				bufsize = 1 + utf8_encodelen(cnp-&gt;ustr.unicode,
				                             cnp-&gt;ustr.length * <span class="enscript-keyword">sizeof</span>(UniChar),
				                             <span class="enscript-string">':'</span>, 0);
				MALLOC(new_nameptr, u_int8_t *, bufsize, M_TEMP, M_WAITOK);
				result = utf8_encodestr(cnp-&gt;ustr.unicode,
				                        cnp-&gt;ustr.length * <span class="enscript-keyword">sizeof</span>(UniChar),
				                        new_nameptr, &amp;tmp_namelen, bufsize, <span class="enscript-string">':'</span>, 0);
			
				state-&gt;cbs_desc-&gt;cd_namelen = tmp_namelen;
				bcopy(new_nameptr, state-&gt;cbs_namebuf, tmp_namelen + 1);
			
				FREE(new_nameptr, M_TEMP);
			} 
		}
		<span class="enscript-keyword">if</span> (state-&gt;cbs_hasprevdirentry) {
			curlinkref = ilinkref;               <span class="enscript-comment">/* save current */</span>
			ilinkref = state-&gt;cbs_previlinkref;  <span class="enscript-comment">/* use previous */</span>
		}
		<span class="enscript-comment">/*
		 * Record any hard links for post processing.
		 */</span>
		<span class="enscript-keyword">if</span> ((ilinkref != 0) &amp;&amp;
			(state-&gt;cbs_result == 0) &amp;&amp;
			(state-&gt;cbs_nlinks &lt; state-&gt;cbs_maxlinks)) {
			state-&gt;cbs_linkinfo[state-&gt;cbs_nlinks].dirent_addr = uiobase;
			state-&gt;cbs_linkinfo[state-&gt;cbs_nlinks].link_ref = ilinkref;
			state-&gt;cbs_nlinks++;
		}
		<span class="enscript-keyword">if</span> (state-&gt;cbs_hasprevdirentry) {
			ilinkref = curlinkref;   <span class="enscript-comment">/* restore current */</span>
		}
	}

	<span class="enscript-comment">/* Fill the direntry to be used the next time */</span>
	<span class="enscript-keyword">if</span> (state-&gt;cbs_flags &amp; VNODE_READDIR_EXTENDED) {	
		<span class="enscript-keyword">if</span> (stop_after_pack) {
			state-&gt;cbs_eof = true;
			<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
		}
		entry-&gt;d_type = type;
		entry-&gt;d_namlen = namelen;
		entry-&gt;d_reclen = EXT_DIRENT_LEN(namelen);
		<span class="enscript-keyword">if</span> (hide) {
			<span class="enscript-comment">/* File number = 0 means skip entry */</span>
			entry-&gt;d_fileno = 0;  
		} <span class="enscript-keyword">else</span> {
			entry-&gt;d_fileno = cnid;
		}
		<span class="enscript-comment">/* swap the current and previous entry */</span>
		<span class="enscript-type">struct</span> direntry * tmp;
		tmp = state-&gt;cbs_direntry;
		state-&gt;cbs_direntry = state-&gt;cbs_prevdirentry;
		state-&gt;cbs_prevdirentry = tmp;
		state-&gt;cbs_hasprevdirentry = true;
		state-&gt;cbs_previlinkref = ilinkref;
	}

	<span class="enscript-comment">/* Continue iteration if there's room */</span>
	<span class="enscript-keyword">return</span> (state-&gt;cbs_result == 0  &amp;&amp;
		uio_resid(state-&gt;cbs_uio) &gt;= SMALL_DIRENTRY_SIZE);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-comment">/*
 * getdirentries callback for standard HFS (non HFS+) directories.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getdirentries_std_callback</span>(<span class="enscript-type">const</span> CatalogKey *ckp, <span class="enscript-type">const</span> CatalogRecord *crp,
                           <span class="enscript-type">struct</span> packdirentry_state *state)
{
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	<span class="enscript-type">const</span> CatalogName *cnp;
	cnid_t curID;
	OSErr result;
	<span class="enscript-type">struct</span> dirent catent;
	cnid_t  cnid;
	u_int8_t type = DT_UNKNOWN;
	u_int8_t *nameptr;
	size_t namelen = 0;
	size_t maxnamelen;
	size_t uiosize = 0;
	caddr_t uioaddr;
	
	hfsmp = state-&gt;cbs_hfsmp;

	curID = ckp-&gt;hfs.parentID;

	<span class="enscript-comment">/* We're done when parent directory changes */</span>
	<span class="enscript-keyword">if</span> (state-&gt;cbs_parentID != curID) {
		state-&gt;cbs_result = ENOENT;
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
	}

	nameptr = (u_int8_t *)&amp;catent.d_name[0];
	maxnamelen = <span class="enscript-keyword">sizeof</span>(catent.d_name);

	<span class="enscript-keyword">switch</span>(crp-&gt;recordType) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderRecord</span>:
		type = DT_DIR;
		cnid = crp-&gt;hfsFolder.folderID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileRecord</span>:
		type = DT_REG;
		cnid = crp-&gt;hfsFile.fileID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
	};

	cnp = (<span class="enscript-type">const</span> CatalogName*) ckp-&gt;hfs.nodeName;
	result = hfs_to_utf8(hfsmp, cnp-&gt;pstr, maxnamelen, (ByteCount *)&amp;namelen, nameptr);
	<span class="enscript-comment">/*
	 * When an HFS name cannot be encoded with the current
	 * volume encoding we use MacRoman as a fallback.
	 */</span>
	<span class="enscript-keyword">if</span> (result) {
		result = mac_roman_to_utf8(cnp-&gt;pstr, maxnamelen, (ByteCount *)&amp;namelen, nameptr);
	}
	catent.d_type = type;
	catent.d_namlen = namelen;
	catent.d_reclen = uiosize = STD_DIRENT_LEN(namelen);
	catent.d_fileno = cnid;
	uioaddr = (caddr_t) &amp;catent;

	<span class="enscript-comment">/* If this entry won't fit then we're done */</span>
	<span class="enscript-keyword">if</span> (uiosize &gt; (user_size_t)uio_resid(state-&gt;cbs_uio)) {
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* stop */</span>
	}

	state-&gt;cbs_result = uiomove(uioaddr, uiosize, state-&gt;cbs_uio);
	<span class="enscript-keyword">if</span> (state-&gt;cbs_result == 0) {
		++state-&gt;cbs_index;

		<span class="enscript-comment">/* Remember previous entry */</span>
		state-&gt;cbs_desc-&gt;cd_cnid = cnid;
		<span class="enscript-keyword">if</span> (type == DT_DIR) {
			state-&gt;cbs_desc-&gt;cd_flags |= CD_ISDIR;
		} <span class="enscript-keyword">else</span> {
			state-&gt;cbs_desc-&gt;cd_flags &amp;= ~CD_ISDIR;
		}
		<span class="enscript-keyword">if</span> (state-&gt;cbs_desc-&gt;cd_nameptr != NULL) {
			state-&gt;cbs_desc-&gt;cd_namelen = 0;
		}
		state-&gt;cbs_desc-&gt;cd_namelen = namelen;
		bcopy(nameptr, state-&gt;cbs_namebuf, namelen + 1);
	}

	<span class="enscript-comment">/* Continue iteration if there's room */</span>
	<span class="enscript-keyword">return</span> (state-&gt;cbs_result == 0  &amp;&amp; uio_resid(state-&gt;cbs_uio) &gt;= SMALL_DIRENTRY_SIZE);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Pack a uio buffer with directory entries from the catalog
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_getdirentries</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t entrycnt, directoryhint_t *dirhint,
				  uio_t uio, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> * items, <span class="enscript-type">int</span> * eofflag)
{
	FCB* fcb;
	BTreeIterator * iterator;
	CatalogKey * key;
	<span class="enscript-type">struct</span> packdirentry_state state;
	<span class="enscript-type">void</span> * buffer;
	<span class="enscript-type">int</span> bufsize;
	<span class="enscript-type">int</span> maxlinks;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> index;
	<span class="enscript-type">int</span> have_key;
	<span class="enscript-type">int</span> extended;
	
	extended = flags &amp; VNODE_READDIR_EXTENDED;
	
	<span class="enscript-keyword">if</span> (extended &amp;&amp; (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD)) {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	fcb = hfsmp-&gt;hfs_catalog_cp-&gt;c_datafork;

	<span class="enscript-comment">/*
	 * Get a buffer for link info array, btree iterator and a direntry:
	 */</span>
	maxlinks = MIN(entrycnt, (u_int32_t)(uio_resid(uio) / SMALL_DIRENTRY_SIZE));
	bufsize = MAXPATHLEN + (maxlinks * <span class="enscript-keyword">sizeof</span>(linkinfo_t)) + <span class="enscript-keyword">sizeof</span>(*iterator);
	<span class="enscript-keyword">if</span> (extended) {
		bufsize += 2*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> direntry);
	}
	MALLOC(buffer, <span class="enscript-type">void</span> *, bufsize, M_TEMP, M_WAITOK);
	bzero(buffer, bufsize);

	state.cbs_flags = flags;
	state.cbs_hasprevdirentry = false;
	state.cbs_previlinkref = 0;
	state.cbs_nlinks = 0;
	state.cbs_maxlinks = maxlinks;
	state.cbs_linkinfo = (linkinfo_t *)((<span class="enscript-type">char</span> *)buffer + MAXPATHLEN);
	<span class="enscript-comment">/*
	 * We need to set cbs_eof to false regardless of whether or not the
	 * control flow is actually in the extended case, since we use this
	 * field to track whether or not we've returned EOF from the iterator function.
	 */</span>
	state.cbs_eof = false;
	
	iterator = (BTreeIterator *) ((<span class="enscript-type">char</span> *)state.cbs_linkinfo + (maxlinks * <span class="enscript-keyword">sizeof</span>(linkinfo_t)));
	key = (CatalogKey *)&amp;iterator-&gt;key;
	have_key = 0;
	index = dirhint-&gt;dh_index + 1;
	<span class="enscript-keyword">if</span> (extended) {
		state.cbs_direntry = (<span class="enscript-type">struct</span> direntry *)((<span class="enscript-type">char</span> *)iterator + <span class="enscript-keyword">sizeof</span>(BTreeIterator));
		state.cbs_prevdirentry = state.cbs_direntry + 1;
	}
	<span class="enscript-comment">/*
	 * Attempt to build a key from cached filename
	 */</span>
	<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_namelen != 0) {
		<span class="enscript-keyword">if</span> (buildkey(hfsmp, &amp;dirhint-&gt;dh_desc, (HFSPlusCatalogKey *)key, 0) == 0) {
			iterator-&gt;hint.nodeNum = dirhint-&gt;dh_desc.cd_hint;
			have_key = 1;
		}
	}

	<span class="enscript-keyword">if</span> (index == 0 &amp;&amp; dirhint-&gt;dh_threadhint != 0) {
		<span class="enscript-comment">/*
		 * Position the iterator at the directory's thread record.
		 * (i.e. just before the first entry)
		 */</span>
		buildthreadkey(dirhint-&gt;dh_desc.cd_parentcnid, (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD), key);
		iterator-&gt;hint.nodeNum = dirhint-&gt;dh_threadhint;
		iterator-&gt;hint.index = 0;
		have_key = 1;
	}

	<span class="enscript-comment">/*
	 * If the last entry wasn't cached then position the btree iterator
	 */</span>
	<span class="enscript-keyword">if</span> (!have_key) {
		<span class="enscript-comment">/*
		 * Position the iterator at the directory's thread record.
		 * (i.e. just before the first entry)
		 */</span>
		buildthreadkey(dirhint-&gt;dh_desc.cd_parentcnid, (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD), key);
		result = BTSearchRecord(fcb, iterator, NULL, NULL, iterator);
		<span class="enscript-keyword">if</span> (result) {
			result = MacToVFSError(result);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
		}
		<span class="enscript-keyword">if</span> (index == 0) {
			dirhint-&gt;dh_threadhint = iterator-&gt;hint.nodeNum;
		}
		<span class="enscript-comment">/*
		 * Iterate until we reach the entry just
		 * before the one we want to start with.
		 */</span>
		<span class="enscript-keyword">if</span> (index &gt; 0) {
			<span class="enscript-type">struct</span> position_state ps;

			ps.error = 0;
			ps.count = 0;
			ps.index = index;
			ps.parentID = dirhint-&gt;dh_desc.cd_parentcnid;
			ps.hfsmp = hfsmp;

			result = BTIterateRecords(fcb, kBTreeNextRecord, iterator,
			                          (IterateCallBackProcPtr)cat_findposition, &amp;ps);
			<span class="enscript-keyword">if</span> (ps.error)
				result = ps.error;
			<span class="enscript-keyword">else</span>
				result = MacToVFSError(result);
			<span class="enscript-keyword">if</span> (result) {
				result = MacToVFSError(result);
				<span class="enscript-keyword">if</span> (result == ENOENT) {
					<span class="enscript-comment">/*
					 * ENOENT means we've hit the EOF.
					 * suppress the error, and set the eof flag.
					 */</span>
					result = 0;
					dirhint-&gt;dh_desc.cd_flags |= CD_EOF;
					*eofflag = 1;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
		}
	}

	state.cbs_index = index;
	state.cbs_hfsmp = hfsmp;
	state.cbs_uio = uio;
	state.cbs_desc = &amp;dirhint-&gt;dh_desc;
	state.cbs_namebuf = (u_int8_t *)buffer;
	state.cbs_result = 0;
	state.cbs_parentID = dirhint-&gt;dh_desc.cd_parentcnid;

	<span class="enscript-comment">/* Use a temporary buffer to hold intermediate descriptor names. */</span>
	<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_namelen &gt; 0 &amp;&amp; dirhint-&gt;dh_desc.cd_nameptr != NULL) {
		bcopy(dirhint-&gt;dh_desc.cd_nameptr, buffer, dirhint-&gt;dh_desc.cd_namelen+1);
		<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_flags &amp; CD_HASBUF) {
			dirhint-&gt;dh_desc.cd_flags &amp;= ~CD_HASBUF;
			vfs_removename((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)dirhint-&gt;dh_desc.cd_nameptr);
		}
	}
	dirhint-&gt;dh_desc.cd_nameptr = (u_int8_t *)buffer;

	<span class="enscript-type">enum</span> BTreeIterationOperations op;
	<span class="enscript-keyword">if</span> (extended &amp;&amp; index != 0 &amp;&amp; have_key)
		op = kBTreeCurrentRecord;
	<span class="enscript-keyword">else</span>
		op = kBTreeNextRecord;

	<span class="enscript-comment">/*
	 * Process as many entries as possible starting at iterator-&gt;key.
	 */</span>
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
		<span class="enscript-comment">/* HFS+ */</span>
		result = BTIterateRecords(fcb, op, iterator,
	                          (IterateCallBackProcPtr)getdirentries_callback, &amp;state);
	
		<span class="enscript-comment">/* For extended calls, every call to getdirentries_callback() 
		 * transfers the previous directory entry found to the user 
		 * buffer.  Therefore when BTIterateRecords reaches the end of 
		 * Catalog BTree, call getdirentries_callback() again with 
		 * dummy values to copy the last directory entry stored in 
		 * packdirentry_state 
		 */</span>
		<span class="enscript-keyword">if</span> (extended &amp;&amp; (result == fsBTRecordNotFoundErr)) {
			CatalogKey ckp;
			CatalogRecord crp;

			bzero(&amp;ckp, <span class="enscript-keyword">sizeof</span>(ckp));
			bzero(&amp;crp, <span class="enscript-keyword">sizeof</span>(crp));

			result = getdirentries_callback(&amp;ckp, &amp;crp, &amp;state);
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* HFS (standard) */</span>
		result = BTIterateRecords(fcb, op, iterator,
	                          (IterateCallBackProcPtr)getdirentries_std_callback, &amp;state);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Note that state.cbs_index is still valid on errors */</span>
	*items = state.cbs_index - index;
	index = state.cbs_index;

	<span class="enscript-comment">/*
	 * Also note that cbs_eof is set in all cases if we ever hit EOF
	 * during the enumeration by the catalog callback.  Mark the directory's hint
	 * descriptor as having hit EOF.
	 */</span>

	<span class="enscript-keyword">if</span> (state.cbs_eof) {
		dirhint-&gt;dh_desc.cd_flags |= CD_EOF;
		*eofflag = 1;
	}
	
	<span class="enscript-comment">/* Finish updating the catalog iterator. */</span>
	dirhint-&gt;dh_desc.cd_hint = iterator-&gt;hint.nodeNum;
	dirhint-&gt;dh_desc.cd_flags |= CD_DECOMPOSED;
	dirhint-&gt;dh_index = index - 1;
	
	<span class="enscript-comment">/* Fix up the name. */</span>
	<span class="enscript-keyword">if</span> (dirhint-&gt;dh_desc.cd_namelen &gt; 0) {
		dirhint-&gt;dh_desc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)vfs_addname((<span class="enscript-type">char</span> *)buffer, dirhint-&gt;dh_desc.cd_namelen, 0, 0);
		dirhint-&gt;dh_desc.cd_flags |= CD_HASBUF;
	} <span class="enscript-keyword">else</span> {
		dirhint-&gt;dh_desc.cd_nameptr = NULL;
		dirhint-&gt;dh_desc.cd_namelen = 0;
	}
	
	<span class="enscript-comment">/*
	 * Post process any hard links to get the real file id.
	 */</span>
	<span class="enscript-keyword">if</span> (state.cbs_nlinks &gt; 0) {
		ino_t fileid = 0;
		user_addr_t address;
		<span class="enscript-type">int</span> i;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; state.cbs_nlinks; ++i) {
			<span class="enscript-keyword">if</span> (resolvelinkid(hfsmp, state.cbs_linkinfo[i].link_ref, &amp;fileid) != 0)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* This assumes that d_ino is always first field. */</span>
			address = state.cbs_linkinfo[i].dirent_addr;
			<span class="enscript-keyword">if</span> (address == (user_addr_t)0)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (uio_isuserspace(uio)) {
				<span class="enscript-keyword">if</span> (extended) {
					ino64_t fileid_64 = (ino64_t)fileid;
					(<span class="enscript-type">void</span>) copyout(&amp;fileid_64, address, <span class="enscript-keyword">sizeof</span>(fileid_64));
				} <span class="enscript-keyword">else</span> {
					(<span class="enscript-type">void</span>) copyout(&amp;fileid, address, <span class="enscript-keyword">sizeof</span>(fileid));
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* system space */</span> {
				<span class="enscript-keyword">if</span> (extended) {
					ino64_t fileid_64 = (ino64_t)fileid;
					bcopy(&amp;fileid_64, (<span class="enscript-type">void</span>*) CAST_DOWN(caddr_t, address), <span class="enscript-keyword">sizeof</span>(fileid_64));
				} <span class="enscript-keyword">else</span> {
					bcopy(&amp;fileid, (<span class="enscript-type">void</span>*) CAST_DOWN(caddr_t, address), <span class="enscript-keyword">sizeof</span>(fileid));
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (state.cbs_result)
		result = state.cbs_result;
	<span class="enscript-keyword">else</span>
		result = MacToVFSError(result);

	<span class="enscript-keyword">if</span> (result == ENOENT) {
		result = 0;
	}

<span class="enscript-reference">cleanup</span>:
	FREE(buffer, M_TEMP);
	
	<span class="enscript-keyword">return</span> (result);
}


<span class="enscript-comment">/*
 * Callback to establish directory position.
 * Called with position_state for each item in a directory.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cat_findposition</span>(<span class="enscript-type">const</span> CatalogKey *ckp, <span class="enscript-type">const</span> CatalogRecord *crp,
                 <span class="enscript-type">struct</span> position_state *state)
{
	cnid_t curID = 0;

	<span class="enscript-keyword">if</span> ((state-&gt;hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0) {
		curID = ckp-&gt;hfsPlus.parentID;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		curID = ckp-&gt;hfs.parentID;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Make sure parent directory didn't change */</span>
	<span class="enscript-keyword">if</span> (state-&gt;parentID != curID) {
		<span class="enscript-comment">/*
		 * The parent ID is different from curID this means we've hit
		 * the EOF for the directory.
		 */</span>
		state-&gt;error = ENOENT;
		<span class="enscript-keyword">return</span> (0);  <span class="enscript-comment">/* stop */</span>
	}

	<span class="enscript-comment">/* Count this entry */</span>
	<span class="enscript-keyword">switch</span>(crp-&gt;recordType) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileRecord</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileRecord</span>:
#<span class="enscript-reference">endif</span>
		++state-&gt;count;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;hfs: cat_findposition: invalid record type %d in dir %d\n&quot;</span>,
			crp-&gt;recordType, curID);
		state-&gt;error = EINVAL;
		<span class="enscript-keyword">return</span> (0);  <span class="enscript-comment">/* stop */</span>
	};

	<span class="enscript-keyword">return</span> (state-&gt;count &lt; state-&gt;index);
}


<span class="enscript-comment">/*
 * cat_binarykeycompare - compare two HFS Plus catalog keys.

 * The name portion of the key is compared using a 16-bit binary comparison. 
 * This is called from the b-tree code.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_binarykeycompare</span>(HFSPlusCatalogKey *searchKey, HFSPlusCatalogKey *trialKey)
{
	u_int32_t searchParentID, trialParentID;
	<span class="enscript-type">int</span> result;

	searchParentID = searchKey-&gt;parentID;
	trialParentID = trialKey-&gt;parentID;
	result = 0;
	
	<span class="enscript-keyword">if</span> (searchParentID &gt; trialParentID) {
		++result;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchParentID &lt; trialParentID) {
		--result;
	} <span class="enscript-keyword">else</span> {
		u_int16_t * str1 = &amp;searchKey-&gt;nodeName.unicode[0];
		u_int16_t * str2 = &amp;trialKey-&gt;nodeName.unicode[0];
		<span class="enscript-type">int</span> length1 = searchKey-&gt;nodeName.length;
		<span class="enscript-type">int</span> length2 = trialKey-&gt;nodeName.length;

		result = UnicodeBinaryCompare (str1, length1, str2, length2);
	}

	<span class="enscript-keyword">return</span> result;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-comment">/*
 * Compare two standard HFS catalog keys
 *
 * Result: +n  search key &gt; trial key
 *          0  search key = trial key
 *         -n  search key &lt; trial key
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">CompareCatalogKeys</span>(HFSCatalogKey *searchKey, HFSCatalogKey *trialKey)
{
	cnid_t searchParentID, trialParentID;
	<span class="enscript-type">int</span> result;

	searchParentID = searchKey-&gt;parentID;
	trialParentID = trialKey-&gt;parentID;

	<span class="enscript-keyword">if</span> (searchParentID &gt; trialParentID)
		result = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchParentID &lt; trialParentID)
		result = -1;
	<span class="enscript-keyword">else</span> <span class="enscript-comment">/* parent dirID's are equal, compare names */</span>
		result = FastRelString(searchKey-&gt;nodeName, trialKey-&gt;nodeName);

	<span class="enscript-keyword">return</span> result;
}
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * Compare two HFS+ catalog keys
 *
 * Result: +n  search key &gt; trial key
 *          0  search key = trial key
 *         -n  search key &lt; trial key
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">CompareExtendedCatalogKeys</span>(HFSPlusCatalogKey *searchKey, HFSPlusCatalogKey *trialKey)
{
	cnid_t searchParentID, trialParentID;
	<span class="enscript-type">int</span> result;

	searchParentID = searchKey-&gt;parentID;
	trialParentID = trialKey-&gt;parentID;
	
	<span class="enscript-keyword">if</span> (searchParentID &gt; trialParentID) {
		result = 1;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (searchParentID &lt; trialParentID) {
		result = -1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* parent node ID's are equal, compare names */</span>
		<span class="enscript-keyword">if</span> ( searchKey-&gt;nodeName.length == 0 || trialKey-&gt;nodeName.length == 0 )
			result = searchKey-&gt;nodeName.length - trialKey-&gt;nodeName.length;
		<span class="enscript-keyword">else</span>
			result = FastUnicodeCompare(&amp;searchKey-&gt;nodeName.unicode[0],
			                            searchKey-&gt;nodeName.length,
			                            &amp;trialKey-&gt;nodeName.unicode[0],
			                            trialKey-&gt;nodeName.length);
	}

	<span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*
 * buildkey - build a Catalog b-tree key from a cnode descriptor
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">buildkey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cat_desc *descp,
	HFSPlusCatalogKey *key, <span class="enscript-type">int</span> retry)
{
	<span class="enscript-type">int</span> std_hfs = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);
	<span class="enscript-type">int</span> utf8_flags = UTF_ESCAPE_ILLEGAL;
	<span class="enscript-type">int</span> result = 0;
	size_t unicodeBytes = 0;
	
	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		retry = 0;
	}

	<span class="enscript-keyword">if</span> (descp-&gt;cd_namelen == 0 || descp-&gt;cd_nameptr[0] == <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span> (EINVAL);  <span class="enscript-comment">/* invalid name */</span>

	key-&gt;parentID = descp-&gt;cd_parentcnid;
	key-&gt;nodeName.length = 0;
	<span class="enscript-comment">/*
	 * Convert filename from UTF-8 into Unicode
	 */</span>
	
	<span class="enscript-keyword">if</span> ((descp-&gt;cd_flags &amp; CD_DECOMPOSED) == 0)
		utf8_flags |= UTF_DECOMPOSED;
	result = utf8_decodestr(descp-&gt;cd_nameptr, descp-&gt;cd_namelen,
		key-&gt;nodeName.unicode, &amp;unicodeBytes,
		<span class="enscript-keyword">sizeof</span>(key-&gt;nodeName.unicode), <span class="enscript-string">':'</span>, utf8_flags);
	key-&gt;nodeName.length = unicodeBytes / <span class="enscript-keyword">sizeof</span>(UniChar);
	key-&gt;keyLength = kHFSPlusCatalogKeyMinimumLength + unicodeBytes;
	<span class="enscript-keyword">if</span> (result) {
		<span class="enscript-keyword">if</span> (result != ENAMETOOLONG)
			result = EINVAL;  <span class="enscript-comment">/* name has invalid characters */</span>
		<span class="enscript-keyword">return</span> (result);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-comment">/*
	 * For HFS volumes convert to an HFS compatible key
	 *
	 * XXX need to save the encoding that succeeded
	 */</span>
	<span class="enscript-keyword">if</span> (std_hfs) {
		HFSCatalogKey hfskey;

		bzero(&amp;hfskey, <span class="enscript-keyword">sizeof</span>(hfskey));
		hfskey.keyLength = kHFSCatalogKeyMinimumLength;
		hfskey.parentID = key-&gt;parentID;
		hfskey.nodeName[0] = 0;
		<span class="enscript-keyword">if</span> (key-&gt;nodeName.length &gt; 0) {
			<span class="enscript-type">int</span> res;
			<span class="enscript-keyword">if</span> ((res = unicode_to_hfs(HFSTOVCB(hfsmp),
				key-&gt;nodeName.length * 2,
				key-&gt;nodeName.unicode,
				&amp;hfskey.nodeName[0], retry)) != 0) {
				<span class="enscript-keyword">if</span> (res != ENAMETOOLONG)
					res = EINVAL;

				<span class="enscript-keyword">return</span> res;
			}
			hfskey.keyLength += hfskey.nodeName[0];
		}
		bcopy(&amp;hfskey, key, <span class="enscript-keyword">sizeof</span>(hfskey));
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (0);
 }


<span class="enscript-comment">/*
 * Resolve hard link reference to obtain the inode record.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_resolvelink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t linkref, <span class="enscript-type">int</span> isdirlink, <span class="enscript-type">struct</span> HFSPlusCatalogFile *recp)
{
	FSBufferDescriptor btdata;
	<span class="enscript-type">struct</span> BTreeIterator *iterator;
	<span class="enscript-type">struct</span> cat_desc idesc;
	<span class="enscript-type">char</span> inodename[32];
	cnid_t parentcnid;
	<span class="enscript-type">int</span> result = 0;

	BDINIT(btdata, recp);

	<span class="enscript-keyword">if</span> (isdirlink) {
		MAKE_DIRINODE_NAME(inodename, <span class="enscript-keyword">sizeof</span>(inodename), (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)linkref);
		parentcnid = hfsmp-&gt;hfs_private_desc[DIR_HARDLINKS].cd_cnid;
	} <span class="enscript-keyword">else</span> {
		MAKE_INODE_NAME(inodename, <span class="enscript-keyword">sizeof</span>(inodename), (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)linkref);
		parentcnid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
	}

	<span class="enscript-comment">/* Get space for iterator */</span>	
	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));

	<span class="enscript-comment">/* Build a descriptor for private dir. */</span>	
	idesc.cd_parentcnid = parentcnid;
	idesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)inodename;
	idesc.cd_namelen = strlen(inodename);
	idesc.cd_flags = 0;
	idesc.cd_hint = 0;
	idesc.cd_encoding = 0;
	(<span class="enscript-type">void</span>) buildkey(hfsmp, &amp;idesc, (HFSPlusCatalogKey *)&amp;iterator-&gt;key, 0);

	result = BTSearchRecord(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), iterator,
				&amp;btdata, NULL, NULL);

	<span class="enscript-keyword">if</span> (result == 0) {
		<span class="enscript-comment">/* Make sure there's a reference */</span>
		<span class="enscript-keyword">if</span> (recp-&gt;hl_linkCount == 0)
			recp-&gt;hl_linkCount = 2;
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;hfs: cat_resolvelink: can't find inode=%s on vol=%s\n&quot;</span>, inodename, hfsmp-&gt;vcbVN);
	}

	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> (result ? ENOENT : 0);
}

<span class="enscript-comment">/*
 * Resolve hard link reference to obtain the inode number.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">resolvelinkid</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t linkref, ino_t *ino)
{
	<span class="enscript-type">struct</span> HFSPlusCatalogFile record;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Since we know resolvelinkid is only called from
	 * cat_getdirentries, we can assume that only file
	 * hardlinks need to be resolved (cat_getdirentries
	 * can resolve directory hardlinks in place).
	 */</span>
	error = cat_resolvelink(hfsmp, linkref, 0, &amp;record);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (record.fileID == 0)
			error = ENOENT;
		<span class="enscript-keyword">else</span>
			*ino = record.fileID;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * getkey - get a key from id by doing a thread lookup
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">getkey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, CatalogKey * key)
{
	<span class="enscript-type">struct</span> BTreeIterator * iterator;
	FSBufferDescriptor btdata;
	u_int16_t	datasize;
	CatalogKey * keyp;
	CatalogRecord * recp;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> std_hfs;

	std_hfs = (HFSTOVCB(hfsmp)-&gt;vcbSigWord == kHFSSigWord);

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	buildthreadkey(cnid, std_hfs, (CatalogKey *)&amp;iterator-&gt;key);

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	BDINIT(btdata, recp);

	result = BTSearchRecord(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), iterator,
				&amp;btdata, &amp;datasize, iterator);
	<span class="enscript-keyword">if</span> (result)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;

	<span class="enscript-comment">/* Turn thread record into a cnode key (in place) */</span>
	<span class="enscript-keyword">switch</span> (recp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileThreadRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderThreadRecord</span>:
		keyp = (CatalogKey *)((<span class="enscript-type">char</span> *)&amp;recp-&gt;hfsThread.reserved + 6);
		keyp-&gt;hfs.keyLength = kHFSCatalogKeyMinimumLength + keyp-&gt;hfs.nodeName[0];
		bcopy(keyp, key, keyp-&gt;hfs.keyLength + 1);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileThreadRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderThreadRecord</span>:
		keyp = (CatalogKey *)&amp;recp-&gt;hfsPlusThread.reserved;
		keyp-&gt;hfsPlus.keyLength = kHFSPlusCatalogKeyMinimumLength +
		                          (keyp-&gt;hfsPlus.nodeName.length * 2);
		bcopy(keyp, key, keyp-&gt;hfsPlus.keyLength + 2);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		result = ENOENT;
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">exit</span>:
	FREE(iterator, M_TEMP);
	FREE(recp, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(result);
}

<span class="enscript-comment">/*
 * getkeyplusattr - From id, fetch the key and the bsd attrs for a file/dir (could pass
 * null arguments to cat_idlookup instead, but we save around 10% by not building the 
 * cat_desc here). Both key and attrp must point to real structures.
 *
 * The key's parent id is the only part of the key expected to be used by the caller.
 * The name portion of the key may not always be valid (ie in the case of a hard link).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_getkeyplusattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t cnid, CatalogKey * key, <span class="enscript-type">struct</span> cat_attr *attrp)
{
	<span class="enscript-type">int</span> result;

	result = getkey(hfsmp, cnid, key);
       
	<span class="enscript-keyword">if</span> (result == 0) {
		result = cat_lookupbykey(hfsmp, key, 0, 0, 0, NULL, attrp, NULL, NULL);
	}
	<span class="enscript-comment">/*
	 * Check for a raw file hardlink inode.
	 * Fix up the parent id in the key if necessary.
	 * Only hard links created by Mac OS X 10.5 or later can be resolved here.
	 */</span>
	<span class="enscript-keyword">if</span> ((result == 0) &amp;&amp;
	    (key-&gt;hfsPlus.parentID == hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid) &amp;&amp;
	    (attrp-&gt;ca_recflags &amp; kHFSHasLinkChainMask)) {
		cnid_t nextlinkid = 0;
		cnid_t prevlinkid = 0;
		<span class="enscript-type">struct</span> cat_desc linkdesc;

		<span class="enscript-comment">/*
		 * Pick up the first link in the chain and get a descriptor for it.
		 * This allows blind bulk access checks to work for hardlinks.
		 */</span>
		<span class="enscript-keyword">if</span> ((cat_lookup_siblinglinks(hfsmp, cnid, &amp;prevlinkid,  &amp;nextlinkid) == 0) &amp;&amp;
		    (nextlinkid != 0)) {
			<span class="enscript-keyword">if</span> (cat_findname(hfsmp, nextlinkid, &amp;linkdesc) == 0) {
				key-&gt;hfsPlus.parentID = linkdesc.cd_parentcnid;
				cat_releasedesc(&amp;linkdesc);
			}
		}	
	}
	<span class="enscript-keyword">return</span> MacToVFSError(result);
}


<span class="enscript-comment">/*
 * buildrecord - build a default catalog directory or file record
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buildrecord</span>(<span class="enscript-type">struct</span> cat_attr *attrp, cnid_t cnid, <span class="enscript-type">int</span> std_hfs, u_int32_t encoding,
            CatalogRecord *crp, u_int32_t *recordSize)
{
	<span class="enscript-type">int</span> type = attrp-&gt;ca_mode &amp; S_IFMT;
	u_int32_t createtime = to_hfs_time(attrp-&gt;ca_itime);

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		<span class="enscript-type">struct</span> HFSPlusBSDInfo * bsdp = NULL;

		<span class="enscript-keyword">if</span> (type == S_IFDIR) {
			crp-&gt;recordType = kHFSPlusFolderRecord;
			crp-&gt;hfsPlusFolder.flags = attrp-&gt;ca_recflags;
			crp-&gt;hfsPlusFolder.valence = 0;
			crp-&gt;hfsPlusFolder.folderID = cnid;	
			crp-&gt;hfsPlusFolder.createDate = createtime;
			crp-&gt;hfsPlusFolder.contentModDate = createtime;
			crp-&gt;hfsPlusFolder.attributeModDate = createtime;
			crp-&gt;hfsPlusFolder.accessDate = createtime;
			crp-&gt;hfsPlusFolder.backupDate = 0;
			crp-&gt;hfsPlusFolder.textEncoding = encoding;
			crp-&gt;hfsPlusFolder.folderCount = 0;
			bcopy(attrp-&gt;ca_finderinfo, &amp;crp-&gt;hfsPlusFolder.userInfo, 32);
			bsdp = &amp;crp-&gt;hfsPlusFolder.bsdInfo;
			bsdp-&gt;special.linkCount = 1;
			*recordSize = <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogFolder);
		} <span class="enscript-keyword">else</span> {
			crp-&gt;recordType = kHFSPlusFileRecord;
			crp-&gt;hfsPlusFile.flags = attrp-&gt;ca_recflags;
			crp-&gt;hfsPlusFile.reserved1 = 0;
			crp-&gt;hfsPlusFile.fileID = cnid;
			crp-&gt;hfsPlusFile.createDate = createtime;
			crp-&gt;hfsPlusFile.contentModDate = createtime;
			crp-&gt;hfsPlusFile.accessDate = createtime;
			crp-&gt;hfsPlusFile.attributeModDate = createtime;
			crp-&gt;hfsPlusFile.backupDate = 0;
			crp-&gt;hfsPlusFile.textEncoding = encoding;
			crp-&gt;hfsPlusFile.reserved2 = 0;
			bcopy(attrp-&gt;ca_finderinfo, &amp;crp-&gt;hfsPlusFile.userInfo, 32);
			bsdp = &amp;crp-&gt;hfsPlusFile.bsdInfo;
			<span class="enscript-comment">/* BLK/CHR need to save the device info */</span>
			<span class="enscript-keyword">if</span> (type == S_IFBLK || type == S_IFCHR) {
				bsdp-&gt;special.rawDevice = attrp-&gt;ca_rdev;
			} <span class="enscript-keyword">else</span> {
				bsdp-&gt;special.linkCount = 1;
			}
			bzero(&amp;crp-&gt;hfsPlusFile.dataFork, 2*<span class="enscript-keyword">sizeof</span>(HFSPlusForkData));
			*recordSize = <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogFile);
		}
		bsdp-&gt;ownerID    = attrp-&gt;ca_uid;
		bsdp-&gt;groupID    = attrp-&gt;ca_gid;
		bsdp-&gt;fileMode   = attrp-&gt;ca_mode;
		bsdp-&gt;adminFlags = attrp-&gt;ca_flags &gt;&gt; 16;
		bsdp-&gt;ownerFlags = attrp-&gt;ca_flags &amp; 0x000000FF;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		createtime = UTCToLocal(createtime);
		<span class="enscript-keyword">if</span> (type == S_IFDIR) {
			bzero(crp, <span class="enscript-keyword">sizeof</span>(HFSCatalogFolder));
			crp-&gt;recordType = kHFSFolderRecord;
			crp-&gt;hfsFolder.folderID = cnid;
			crp-&gt;hfsFolder.createDate = createtime;
			crp-&gt;hfsFolder.modifyDate = createtime;
			bcopy(attrp-&gt;ca_finderinfo, &amp;crp-&gt;hfsFolder.userInfo, 32);
			*recordSize = <span class="enscript-keyword">sizeof</span>(HFSCatalogFolder);
		} <span class="enscript-keyword">else</span> {
			bzero(crp, <span class="enscript-keyword">sizeof</span>(HFSCatalogFile));
			crp-&gt;recordType = kHFSFileRecord;
			crp-&gt;hfsFile.fileID = cnid;
			crp-&gt;hfsFile.createDate = createtime;
			crp-&gt;hfsFile.modifyDate = createtime;
			bcopy(attrp-&gt;ca_finderinfo, &amp;crp-&gt;hfsFile.userInfo, 16);
			bcopy(&amp;attrp-&gt;ca_finderinfo[16], &amp;crp-&gt;hfsFile.finderInfo, 16);
			*recordSize = <span class="enscript-keyword">sizeof</span>(HFSCatalogFile);
		}
	}
#<span class="enscript-reference">endif</span>

}


<span class="enscript-comment">/*
 * builddesc - build a cnode descriptor from an HFS+ key
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">builddesc</span>(<span class="enscript-type">const</span> HFSPlusCatalogKey *key, cnid_t cnid, u_int32_t hint, u_int32_t encoding,
	<span class="enscript-type">int</span> isdir, <span class="enscript-type">struct</span> cat_desc *descp)
{
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> * nameptr;
	size_t bufsize;
	size_t utf8len;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> tmpbuff[128];

	<span class="enscript-comment">/* guess a size... */</span>
	bufsize = (3 * key-&gt;nodeName.length) + 1;
	<span class="enscript-keyword">if</span> (bufsize &gt;= <span class="enscript-keyword">sizeof</span>(tmpbuff) - 1) {
	    MALLOC(nameptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, bufsize, M_TEMP, M_WAITOK);
	} <span class="enscript-keyword">else</span> {
	    nameptr = &amp;tmpbuff[0];
	}

	result = utf8_encodestr(key-&gt;nodeName.unicode,
			key-&gt;nodeName.length * <span class="enscript-keyword">sizeof</span>(UniChar),
			nameptr, (size_t *)&amp;utf8len,
			bufsize, <span class="enscript-string">':'</span>, 0);

	<span class="enscript-keyword">if</span> (result == ENAMETOOLONG) {
		bufsize = 1 + utf8_encodelen(key-&gt;nodeName.unicode,
		                             key-&gt;nodeName.length * <span class="enscript-keyword">sizeof</span>(UniChar),
		                             <span class="enscript-string">':'</span>, 0);
		FREE(nameptr, M_TEMP);
		MALLOC(nameptr, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, bufsize, M_TEMP, M_WAITOK);

		result = utf8_encodestr(key-&gt;nodeName.unicode,
		                        key-&gt;nodeName.length * <span class="enscript-keyword">sizeof</span>(UniChar),
		                        nameptr, (size_t *)&amp;utf8len,
		                        bufsize, <span class="enscript-string">':'</span>, 0);
	}
	descp-&gt;cd_parentcnid = key-&gt;parentID;
	descp-&gt;cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)vfs_addname((<span class="enscript-type">char</span> *)nameptr, utf8len, 0, 0);
	descp-&gt;cd_namelen = utf8len;
	descp-&gt;cd_cnid = cnid;
	descp-&gt;cd_hint = hint;
	descp-&gt;cd_flags = CD_DECOMPOSED | CD_HASBUF;
	<span class="enscript-keyword">if</span> (isdir)
		descp-&gt;cd_flags |= CD_ISDIR;	
	descp-&gt;cd_encoding = encoding;
	<span class="enscript-keyword">if</span> (nameptr != &amp;tmpbuff[0]) {
	    FREE(nameptr, M_TEMP);
	}
	<span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*
 * getbsdattr - get attributes in bsd format
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">getbsdattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp, <span class="enscript-type">struct</span> cat_attr * attrp)
{
	<span class="enscript-type">int</span> isDirectory = (crp-&gt;recordType == kHFSPlusFolderRecord);
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSPlusBSDInfo *bsd = &amp;crp-&gt;bsdInfo;

	attrp-&gt;ca_recflags = crp-&gt;flags;
	attrp-&gt;ca_atime = to_bsd_time(crp-&gt;accessDate);
	attrp-&gt;ca_atimeondisk = attrp-&gt;ca_atime;	
	attrp-&gt;ca_mtime = to_bsd_time(crp-&gt;contentModDate);
	attrp-&gt;ca_ctime = to_bsd_time(crp-&gt;attributeModDate);
	attrp-&gt;ca_itime = to_bsd_time(crp-&gt;createDate);
	attrp-&gt;ca_btime = to_bsd_time(crp-&gt;backupDate);

	<span class="enscript-keyword">if</span> ((bsd-&gt;fileMode &amp; S_IFMT) == 0) {
		attrp-&gt;ca_flags = 0;
		attrp-&gt;ca_uid = hfsmp-&gt;hfs_uid;
		attrp-&gt;ca_gid = hfsmp-&gt;hfs_gid;
		<span class="enscript-keyword">if</span> (isDirectory) {
			attrp-&gt;ca_mode = S_IFDIR | (hfsmp-&gt;hfs_dir_mask &amp; ACCESSPERMS);
		} <span class="enscript-keyword">else</span> {
			attrp-&gt;ca_mode = S_IFREG | (hfsmp-&gt;hfs_file_mask &amp; ACCESSPERMS);
		}
		attrp-&gt;ca_linkcount = 1;
		attrp-&gt;ca_rdev = 0;
	} <span class="enscript-keyword">else</span> {
		attrp-&gt;ca_linkcount = 1;  <span class="enscript-comment">/* may be overridden below */</span>
		attrp-&gt;ca_rdev = 0;
		attrp-&gt;ca_uid = bsd-&gt;ownerID;
		attrp-&gt;ca_gid = bsd-&gt;groupID;
		attrp-&gt;ca_flags = bsd-&gt;ownerFlags | (bsd-&gt;adminFlags &lt;&lt; 16);
		attrp-&gt;ca_mode = (mode_t)bsd-&gt;fileMode;
		<span class="enscript-keyword">switch</span> (attrp-&gt;ca_mode &amp; S_IFMT) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFCHR</span>: <span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFBLK</span>:
			attrp-&gt;ca_rdev = bsd-&gt;special.rawDevice;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFIFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFSOCK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFDIR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">S_IFREG</span>:
			<span class="enscript-comment">/* Pick up the hard link count */</span>
			<span class="enscript-keyword">if</span> (bsd-&gt;special.linkCount &gt; 0)
				attrp-&gt;ca_linkcount = bsd-&gt;special.linkCount;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 *  Override the permissions as determined by the mount auguments
		 *  in ALMOST the same way unset permissions are treated but keep
		 *  track of whether or not the file or folder is hfs locked
		 *  by leaving the h_pflags field unchanged from what was unpacked
		 *  out of the catalog.
		 */</span>
		<span class="enscript-comment">/*
		 * This code was used to do UID translation with MNT_IGNORE_OWNERS
		 * (aka MNT_UNKNOWNPERMISSIONS) at the HFS layer.  It's largely done
		 * at the VFS layer, so there is no need to do it here now; this also
		 * allows VFS to let root see the real UIDs.
		 *
		 * if (((unsigned int)vfs_flags(HFSTOVFS(hfsmp))) &amp; MNT_UNKNOWNPERMISSIONS) {
		 * 	attrp-&gt;ca_uid = hfsmp-&gt;hfs_uid;
		 * 	attrp-&gt;ca_gid = hfsmp-&gt;hfs_gid;
		 * }
		 */</span>
	}

	<span class="enscript-keyword">if</span> (isDirectory) {
		<span class="enscript-keyword">if</span> (!S_ISDIR(attrp-&gt;ca_mode)) {
			attrp-&gt;ca_mode &amp;= ~S_IFMT;
			attrp-&gt;ca_mode |= S_IFDIR;
		}
		attrp-&gt;ca_entries = ((<span class="enscript-type">const</span> HFSPlusCatalogFolder *)crp)-&gt;valence;
		attrp-&gt;ca_dircount = ((hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT) &amp;&amp; (attrp-&gt;ca_recflags &amp; kHFSHasFolderCountMask)) ?
					     ((<span class="enscript-type">const</span> HFSPlusCatalogFolder *)crp)-&gt;folderCount : 0;
			
		<span class="enscript-comment">/* Keep UF_HIDDEN bit in sync with Finder Info's invisible bit */</span>
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">const</span> HFSPlusCatalogFolder *)crp)-&gt;userInfo.frFlags &amp; OSSwapHostToBigConstInt16(kFinderInvisibleMask))
			attrp-&gt;ca_flags |= UF_HIDDEN;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Keep IMMUTABLE bits in sync with HFS locked flag */</span>
		<span class="enscript-keyword">if</span> (crp-&gt;flags &amp; kHFSFileLockedMask) {
			<span class="enscript-comment">/* The file's supposed to be locked:
			   Make sure at least one of the IMMUTABLE bits is set: */</span>
			<span class="enscript-keyword">if</span> ((attrp-&gt;ca_flags &amp; (SF_IMMUTABLE | UF_IMMUTABLE)) == 0)
				attrp-&gt;ca_flags |= UF_IMMUTABLE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* The file's supposed to be unlocked: */</span>
			attrp-&gt;ca_flags &amp;= ~(SF_IMMUTABLE | UF_IMMUTABLE);
		}
		<span class="enscript-comment">/* Keep UF_HIDDEN bit in sync with Finder Info's invisible bit */</span>
		<span class="enscript-keyword">if</span> (crp-&gt;userInfo.fdFlags &amp; OSSwapHostToBigConstInt16(kFinderInvisibleMask))
			attrp-&gt;ca_flags |= UF_HIDDEN;
		<span class="enscript-comment">/* get total blocks (both forks) */</span>
		attrp-&gt;ca_blocks = crp-&gt;dataFork.totalBlocks + crp-&gt;resourceFork.totalBlocks;

		<span class="enscript-comment">/* On HFS+ the ThreadExists flag must always be set. */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) == 0)
			attrp-&gt;ca_recflags |= kHFSThreadExistsMask;

		<span class="enscript-comment">/* Pick up the hardlink first link, if any. */</span>
		attrp-&gt;ca_firstlink = (attrp-&gt;ca_recflags &amp; kHFSHasLinkChainMask) ? crp-&gt;hl_firstLinkID : 0;
	}
	
	attrp-&gt;ca_fileid = crp-&gt;fileID;

	bcopy(&amp;crp-&gt;userInfo, attrp-&gt;ca_finderinfo, 32);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-comment">/*
 * promotekey - promote hfs key to hfs plus key
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">promotekey</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> HFSCatalogKey *hfskey,
           HFSPlusCatalogKey *keyp, u_int32_t *encoding)
{
	hfs_to_unicode_func_t hfs_get_unicode = hfsmp-&gt;hfs_get_unicode;
	u_int32_t uniCount;
	<span class="enscript-type">int</span> error;

	*encoding = hfsmp-&gt;hfs_encoding;

	error = hfs_get_unicode(hfskey-&gt;nodeName, keyp-&gt;nodeName.unicode,
	                        kHFSPlusMaxFileNameChars, &amp;uniCount);
	<span class="enscript-comment">/*
	 * When an HFS name cannot be encoded with the current
	 * encoding use MacRoman as a fallback.
	 */</span>
	<span class="enscript-keyword">if</span> (error &amp;&amp; hfsmp-&gt;hfs_encoding != kTextEncodingMacRoman) {
		*encoding = 0;
		(<span class="enscript-type">void</span>) mac_roman_to_unicode(hfskey-&gt;nodeName,
		                            keyp-&gt;nodeName.unicode,
		                            kHFSPlusMaxFileNameChars,
		                            &amp;uniCount);
	}

	keyp-&gt;nodeName.length = uniCount;
	keyp-&gt;parentID = hfskey-&gt;parentID;
}

<span class="enscript-comment">/*
 * promotefork - promote hfs fork info to hfs plus
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">promotefork</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFile *filep,
            <span class="enscript-type">int</span> resource, <span class="enscript-type">struct</span> cat_fork * forkp)
{
	<span class="enscript-type">struct</span> HFSPlusExtentDescriptor *xp;
	u_int32_t blocksize = HFSTOVCB(hfsmp)-&gt;blockSize;

	bzero(forkp, <span class="enscript-keyword">sizeof</span>(*forkp));
	xp = &amp;forkp-&gt;cf_extents[0];
	<span class="enscript-keyword">if</span> (resource) {
		forkp-&gt;cf_size = filep-&gt;rsrcLogicalSize;
		forkp-&gt;cf_blocks = filep-&gt;rsrcPhysicalSize / blocksize;
		forkp-&gt;cf_bytesread = 0;
		forkp-&gt;cf_vblocks = 0;
		xp[0].startBlock = (u_int32_t)filep-&gt;rsrcExtents[0].startBlock;
		xp[0].blockCount = (u_int32_t)filep-&gt;rsrcExtents[0].blockCount;
		xp[1].startBlock = (u_int32_t)filep-&gt;rsrcExtents[1].startBlock;
		xp[1].blockCount = (u_int32_t)filep-&gt;rsrcExtents[1].blockCount;
		xp[2].startBlock = (u_int32_t)filep-&gt;rsrcExtents[2].startBlock;
		xp[2].blockCount = (u_int32_t)filep-&gt;rsrcExtents[2].blockCount;
	} <span class="enscript-keyword">else</span> {
		forkp-&gt;cf_size = filep-&gt;dataLogicalSize;
		forkp-&gt;cf_blocks = filep-&gt;dataPhysicalSize / blocksize;
		forkp-&gt;cf_bytesread = 0;
		forkp-&gt;cf_vblocks = 0;
		xp[0].startBlock = (u_int32_t)filep-&gt;dataExtents[0].startBlock;
		xp[0].blockCount = (u_int32_t)filep-&gt;dataExtents[0].blockCount;
		xp[1].startBlock = (u_int32_t)filep-&gt;dataExtents[1].startBlock;
		xp[1].blockCount = (u_int32_t)filep-&gt;dataExtents[1].blockCount;
		xp[2].startBlock = (u_int32_t)filep-&gt;dataExtents[2].startBlock;
		xp[2].blockCount = (u_int32_t)filep-&gt;dataExtents[2].blockCount;
	}
}

<span class="enscript-comment">/*
 * promoteattr - promote standard hfs catalog attributes to hfs plus
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">promoteattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> CatalogRecord *dataPtr, <span class="enscript-type">struct</span> HFSPlusCatalogFile *crp)
{
	u_int32_t blocksize = HFSTOVCB(hfsmp)-&gt;blockSize;

	<span class="enscript-keyword">if</span> (dataPtr-&gt;recordType == kHFSFolderRecord) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFolder * folder;

		folder = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFolder *) dataPtr;
		crp-&gt;recordType       = kHFSPlusFolderRecord;
		crp-&gt;flags            = folder-&gt;flags;
		crp-&gt;fileID           = folder-&gt;folderID;
		crp-&gt;createDate       = LocalToUTC(folder-&gt;createDate);
		crp-&gt;contentModDate   = LocalToUTC(folder-&gt;modifyDate);
		crp-&gt;backupDate       = LocalToUTC(folder-&gt;backupDate);
		crp-&gt;reserved1        = folder-&gt;valence;
		crp-&gt;reserved2        = 0;
		bcopy(&amp;folder-&gt;userInfo, &amp;crp-&gt;userInfo, 32);
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* file */</span> {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFile * file;

		file = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> HFSCatalogFile *) dataPtr;
		crp-&gt;recordType       = kHFSPlusFileRecord;
		crp-&gt;flags            = file-&gt;flags;
		crp-&gt;fileID           = file-&gt;fileID;
		crp-&gt;createDate       = LocalToUTC(file-&gt;createDate);
		crp-&gt;contentModDate   = LocalToUTC(file-&gt;modifyDate);
		crp-&gt;backupDate       = LocalToUTC(file-&gt;backupDate);
		crp-&gt;reserved1        = 0;
		crp-&gt;reserved2        = 0;
		bcopy(&amp;file-&gt;userInfo, &amp;crp-&gt;userInfo, 16);
		bcopy(&amp;file-&gt;finderInfo, &amp;crp-&gt;finderInfo, 16);
		crp-&gt;dataFork.totalBlocks = file-&gt;dataPhysicalSize / blocksize;
		crp-&gt;resourceFork.totalBlocks = file-&gt;rsrcPhysicalSize / blocksize;
	}
	crp-&gt;textEncoding = 0;
	crp-&gt;attributeModDate = crp-&gt;contentModDate;
	crp-&gt;accessDate = crp-&gt;contentModDate;
	bzero(&amp;crp-&gt;bsdInfo, <span class="enscript-keyword">sizeof</span>(HFSPlusBSDInfo));
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Build a catalog node thread record from a catalog key
 * and return the size of the record.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">buildthread</span>(<span class="enscript-type">void</span> *keyp, <span class="enscript-type">void</span> *recp, <span class="enscript-type">int</span> std_hfs, <span class="enscript-type">int</span> directory)
{
	<span class="enscript-type">int</span> size = 0;

	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		HFSPlusCatalogKey *key = (HFSPlusCatalogKey *)keyp;
		HFSPlusCatalogThread *rec = (HFSPlusCatalogThread *)recp;

		size = <span class="enscript-keyword">sizeof</span>(HFSPlusCatalogThread);
		<span class="enscript-keyword">if</span> (directory)
			rec-&gt;recordType = kHFSPlusFolderThreadRecord;
		<span class="enscript-keyword">else</span>
			rec-&gt;recordType = kHFSPlusFileThreadRecord;
		rec-&gt;reserved = 0;
		rec-&gt;parentID = key-&gt;parentID;			
		bcopy(&amp;key-&gt;nodeName, &amp;rec-&gt;nodeName,
			<span class="enscript-keyword">sizeof</span>(UniChar) * (key-&gt;nodeName.length + 1));

		<span class="enscript-comment">/* HFS Plus has variable sized thread records */</span>
		size -= (<span class="enscript-keyword">sizeof</span>(rec-&gt;nodeName.unicode) -
			  (rec-&gt;nodeName.length * <span class="enscript-keyword">sizeof</span>(UniChar)));

	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		HFSCatalogKey *key = (HFSCatalogKey *)keyp;
		HFSCatalogThread *rec = (HFSCatalogThread *)recp;

		size = <span class="enscript-keyword">sizeof</span>(HFSCatalogThread);
		bzero(rec, size);
		<span class="enscript-keyword">if</span> (directory)
			rec-&gt;recordType = kHFSFolderThreadRecord;
		<span class="enscript-keyword">else</span>
			rec-&gt;recordType = kHFSFileThreadRecord;
		rec-&gt;parentID = key-&gt;parentID;
		bcopy(key-&gt;nodeName, rec-&gt;nodeName, key-&gt;nodeName[0]+1);

	} 
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (size);
}

<span class="enscript-comment">/*
 * Build a catalog node thread key.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">buildthreadkey</span>(HFSCatalogNodeID parentID, <span class="enscript-type">int</span> std_hfs, CatalogKey *key)
{
	<span class="enscript-keyword">if</span> (std_hfs == 0) {
		key-&gt;hfsPlus.keyLength = kHFSPlusCatalogKeyMinimumLength;
		key-&gt;hfsPlus.parentID = parentID;
		key-&gt;hfsPlus.nodeName.length = 0;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> {
		key-&gt;hfs.keyLength = kHFSCatalogKeyMinimumLength;
		key-&gt;hfs.reserved = 0;
		key-&gt;hfs.parentID = parentID;
		key-&gt;hfs.nodeName[0] = 0;
	}
#<span class="enscript-reference">endif</span>

}

<span class="enscript-comment">/*
 * Extract the text encoding from a catalog node record.
 */</span>
<span class="enscript-type">static</span> u_int32_t 
<span class="enscript-function-name">getencoding</span>(<span class="enscript-type">const</span> CatalogRecord *crp)
{
	u_int32_t encoding;

	<span class="enscript-keyword">if</span> (crp-&gt;recordType == kHFSPlusFolderRecord)
		encoding = crp-&gt;hfsPlusFolder.textEncoding;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (crp-&gt;recordType == kHFSPlusFileRecord)
		encoding = crp-&gt;hfsPlusFile.textEncoding;
	<span class="enscript-keyword">else</span>
		encoding = 0;

	<span class="enscript-keyword">return</span> (encoding);
}

<span class="enscript-comment">/*
 * Extract the CNID from a catalog node record.
 */</span>
<span class="enscript-type">static</span> cnid_t 
<span class="enscript-function-name">getcnid</span>(<span class="enscript-type">const</span> CatalogRecord *crp)
{
	cnid_t cnid = 0;

	<span class="enscript-keyword">switch</span> (crp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderRecord</span>:
		cnid = crp-&gt;hfsFolder.folderID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileRecord</span>:
		cnid = crp-&gt;hfsFile.fileID;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderRecord</span>:
		cnid = crp-&gt;hfsPlusFolder.folderID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileRecord</span>:
		cnid = crp-&gt;hfsPlusFile.fileID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;hfs: getcnid: unknown recordType=%d\n&quot;</span>, crp-&gt;recordType);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (cnid);
}

<span class="enscript-comment">/*
 * Extract the parent ID from a catalog node record.
 */</span>
<span class="enscript-type">static</span> cnid_t 
<span class="enscript-function-name">getparentcnid</span>(<span class="enscript-type">const</span> CatalogRecord *recp)
{
	cnid_t cnid = 0;

	<span class="enscript-keyword">switch</span> (recp-&gt;recordType) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFileThreadRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSFolderThreadRecord</span>:
		cnid = recp-&gt;hfsThread.parentID;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFileThreadRecord</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kHFSPlusFolderThreadRecord</span>:
		cnid = recp-&gt;hfsPlusThread.parentID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;hfs: getparentcnid: unknown recordType (crp @ %p)\n&quot;</span>, recp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (cnid);
}

<span class="enscript-comment">/*
 * Determine if a catalog node record is a directory.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">isadir</span>(<span class="enscript-type">const</span> CatalogRecord *crp)
{
	<span class="enscript-keyword">if</span> (crp-&gt;recordType == kHFSPlusFolderRecord) {
		<span class="enscript-keyword">return</span> 1;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">if</span> (crp-&gt;recordType == kHFSFolderRecord) {
		<span class="enscript-keyword">return</span> 1;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * cat_lookup_dirlink - lookup a catalog record for directory hard link 
 * (not inode) using catalog record id.  Note that this function does 
 * NOT resolve directory hard link to its directory inode and return 
 * the link record.
 *
 * Note: The caller is responsible for releasing the output catalog 
 * descriptor (when supplied outdescp is non-null).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_lookup_dirlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t dirlink_id, 
		u_int8_t forktype, <span class="enscript-type">struct</span> cat_desc *outdescp, 
		<span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp)
{
	<span class="enscript-type">struct</span> BTreeIterator *iterator = NULL;
	FSBufferDescriptor btdata;
	u_int16_t datasize;
	CatalogKey *keyp;
	CatalogRecord *recp = NULL;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* No directory hard links on standard HFS */</span>
	<span class="enscript-keyword">if</span> (hfsmp-&gt;vcbSigWord == kHFSSigWord) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	MALLOC(iterator, BTreeIterator *, <span class="enscript-keyword">sizeof</span>(*iterator), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (iterator == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero(iterator, <span class="enscript-keyword">sizeof</span>(*iterator));
	buildthreadkey(dirlink_id, 1, (CatalogKey *)&amp;iterator-&gt;key);

	MALLOC(recp, CatalogRecord *, <span class="enscript-keyword">sizeof</span>(CatalogRecord), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (recp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	BDINIT(btdata, recp);

	error = BTSearchRecord(VTOF(HFSTOVCB(hfsmp)-&gt;catalogRefNum), iterator,
				&amp;btdata, &amp;datasize, iterator);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* Directory hard links are catalog file record */</span>
	<span class="enscript-keyword">if</span> (recp-&gt;recordType != kHFSPlusFileThreadRecord) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	keyp = (CatalogKey *)&amp;recp-&gt;hfsPlusThread.reserved;
	keyp-&gt;hfsPlus.keyLength = kHFSPlusCatalogKeyMinimumLength +
				  (keyp-&gt;hfsPlus.nodeName.length * 2);
	<span class="enscript-keyword">if</span> (forktype == kHFSResourceForkType) {
		<span class="enscript-comment">/* Lookup resource fork for directory hard link */</span>
		error = cat_lookupbykey(hfsmp, keyp, HFS_LOOKUP_HARDLINK, 0, true, outdescp, attrp, forkp, NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Lookup data fork, if any, for directory hard link */</span>
		error = cat_lookupbykey(hfsmp, keyp, HFS_LOOKUP_HARDLINK, 0, false, outdescp, attrp, forkp, NULL);
	}
	<span class="enscript-keyword">if</span> (error) {
		printf (<span class="enscript-string">&quot;hfs: cat_lookup_dirlink(): Error looking up file record for id=%u (error=%d)\n&quot;</span>, dirlink_id, error);
		hfs_mark_inconsistent(hfsmp, HFS_INCONSISTENCY_DETECTED);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* Just for sanity, make sure that id in catalog record and thread record match */</span>
	<span class="enscript-keyword">if</span> ((outdescp != NULL) &amp;&amp; (dirlink_id != outdescp-&gt;cd_cnid)) {
		printf (<span class="enscript-string">&quot;hfs: cat_lookup_dirlink(): Requested cnid=%u != found_cnid=%u\n&quot;</span>, dirlink_id, outdescp-&gt;cd_cnid);
		hfs_mark_inconsistent(hfsmp, HFS_INCONSISTENCY_DETECTED);
		error = ENOENT;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (recp) {
		FREE(recp, M_TEMP);
	}
	FREE(iterator, M_TEMP);

	<span class="enscript-keyword">return</span> MacToVFSError(error);
}

<span class="enscript-comment">/*
 * cnode_update_dirlink - update the catalog node for directory hard link 
 * described by descp using the data from attrp and forkp.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cat_update_dirlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int8_t forktype, 
		<span class="enscript-type">struct</span> cat_desc *descp, <span class="enscript-type">struct</span> cat_attr *attrp, <span class="enscript-type">struct</span> cat_fork *forkp)
{
	<span class="enscript-keyword">if</span> (forktype == kHFSResourceForkType) {
		<span class="enscript-keyword">return</span> cat_update_internal(hfsmp, true, descp, attrp, NULL, forkp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> cat_update_internal(hfsmp, true, descp, attrp, forkp, NULL);
	} 
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_fork_copy</span>(<span class="enscript-type">struct</span> cat_fork *dst, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *src,
				   HFSPlusExtentDescriptor *extents)
{
	<span class="enscript-comment">/* Copy everything but the extents into the dest fork */</span>
	memcpy(dst, src, offsetof(<span class="enscript-type">struct</span> cat_fork, cf_extents));
	<span class="enscript-comment">/* Then copy the supplied extents into the fork */</span>
	memcpy(dst-&gt;cf_extents, extents, <span class="enscript-keyword">sizeof</span>(HFSPlusExtentRecord));
}
</pre>
<hr />
</body></html>