<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__HFS__</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__HFS__</span>

<span class="enscript-comment">/* If set to 1, enables the code to allocate blocks from the start 
 * of the disk instead of the nextAllocation for sparse devices like 
 * sparse disk images or sparsebundle images.  The free extent cache 
 * for such volumes is also maintained based on the start block instead 
 * of number of contiguous allocation blocks.  These devices prefer 
 * allocation of blocks near the start of the disk to avoid the 
 * increasing the image size, but it can also result in file fragmentation. 
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span> 1

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span> 1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_TMPDBG</span> 0

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_journal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_format.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_catalog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_cnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_macos_defs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_encodings.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_hotfiles.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_fsctl.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
<span class="enscript-comment">/* Forward declare the cprotect struct */</span>
<span class="enscript-type">struct</span> cprotect;


#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 *	Just reported via MIG interface.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VERSION_STRING</span>	<span class="enscript-string">&quot;hfs-2 (4-12-99)&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LINK_MAX</span>	32767

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MAX_DEFERED_ALLOC</span>	(1024*1024)

<span class="enscript-comment">// 400 megs is a &quot;big&quot; file (i.e. one that when deleted
</span><span class="enscript-comment">// would touch enough data that we should break it into
</span><span class="enscript-comment">// multiple separate transactions)
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_BIGFILE_SIZE</span> (400LL * 1024LL * 1024LL)


<span class="enscript-type">enum</span> { kMDBSize = 512 };				<span class="enscript-comment">/* Size of I/O transfer to read entire MDB */</span>

<span class="enscript-type">enum</span> { kMasterDirectoryBlock = 2 };			<span class="enscript-comment">/* MDB offset on disk in 512-byte blocks */</span>
<span class="enscript-type">enum</span> { kMDBOffset = kMasterDirectoryBlock * 512 };	<span class="enscript-comment">/* MDB offset on disk in bytes */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kRootDirID</span> kHFSRootFolderID


<span class="enscript-comment">/* number of locked buffer caches to hold for b-tree meta data */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMaxLockedMetaBuffers</span>		32		

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> timezone gTimeZone;


<span class="enscript-comment">/* How many free extents to cache per volume */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kMaxFreeExtents</span>		10

<span class="enscript-comment">/* The maximum time hfs locks can be held while performing hfs statistics gathering */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_FSINFO_MAX_LOCKHELD_TIME</span>	20 * 1000000ULL	<span class="enscript-comment">/* at most 20 milliseconds. */</span>

<span class="enscript-comment">/*
 * HFS_MINFREE gives the minimum acceptable percentage
 * of file system blocks which may be free (but this
 * minimum will never exceed HFS_MAXRESERVE bytes). If
 * the free block count drops below this level only the
 * superuser may continue to allocate blocks.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MINFREE</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_MAXRESERVE</span>		((u_int64_t)(250*1024*1024))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_BT_MAXRESERVE</span>	((u_int64_t)(10*1024*1024))

<span class="enscript-comment">/*
 * The system distinguishes between the desirable low-disk
 * notifiaction levels for root volumes and non-root volumes.
 * The various thresholds are computed as a fraction of the
 * volume size, all capped at a certain fixed level
 */</span>
 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTVERYLOWDISKTRIGGERFRACTION</span> 5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTVERYLOWDISKTRIGGERLEVEL</span> ((u_int64_t)(512*1024*1024))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTLOWDISKTRIGGERFRACTION</span> 10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTLOWDISKTRIGGERLEVEL</span> ((u_int64_t)(1024*1024*1024))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTLOWDISKSHUTOFFFRACTION</span> 11
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ROOTLOWDISKSHUTOFFLEVEL</span> ((u_int64_t)(1024*1024*1024 + 250*1024*1024))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_VERYLOWDISKTRIGGERFRACTION</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_VERYLOWDISKTRIGGERLEVEL</span> ((u_int64_t)(100*1024*1024))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOWDISKTRIGGERFRACTION</span> 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOWDISKTRIGGERLEVEL</span> ((u_int64_t)(150*1024*1024))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOWDISKSHUTOFFFRACTION</span> 3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_LOWDISKSHUTOFFLEVEL</span> ((u_int64_t)(200*1024*1024))

<span class="enscript-comment">/* Internal Data structures*/</span>

<span class="enscript-comment">/* This structure describes the HFS specific mount structure data. */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> hfsmount {
	u_int32_t     hfs_flags;              <span class="enscript-comment">/* see below */</span>

	<span class="enscript-comment">/* Physical Description */</span>
	u_int32_t     hfs_logical_block_size;	<span class="enscript-comment">/* Logical block size of the disk as reported by ioctl(DKIOCGETBLOCKSIZE), always a multiple of 512 */</span>
	daddr64_t     hfs_logical_block_count;  <span class="enscript-comment">/* Number of logical blocks on the disk, as reported by ioctl(DKIOCGETBLOCKCOUNT) */</span>
	u_int64_t     hfs_logical_bytes;	<span class="enscript-comment">/* Number of bytes on the disk device this HFS is mounted on (blockcount * blocksize) */</span>
	<span class="enscript-comment">/*
	 * Regarding the two AVH sector fields below: 
	 * Under normal circumstances, the filesystem's notion of the &quot;right&quot; location for the AVH is such that
	 * the partition and filesystem's are in sync.  However, during a filesystem resize, HFS proactively
	 * writes a new AVH at the end of the filesystem, assuming that the partition will be resized accordingly.
	 *
	 * However, it is not technically a corruption if the partition size is never modified.  As a result, we need
	 * to keep two copies of the AVH around &quot;just in case&quot; the partition size is not modified.
	 */</span>
	daddr64_t	hfs_partition_avh_sector;	<span class="enscript-comment">/* location of Alt VH w.r.t partition size */</span>
	daddr64_t	hfs_fs_avh_sector;	<span class="enscript-comment">/* location of Alt VH w.r.t filesystem size */</span>

	u_int32_t     hfs_physical_block_size;	<span class="enscript-comment">/* Physical block size of the disk as reported by ioctl(DKIOCGETPHYSICALBLOCKSIZE) */</span> 
	u_int32_t     hfs_log_per_phys;		<span class="enscript-comment">/* Number of logical blocks per physical block size */</span>

	<span class="enscript-comment">/* Access to VFS and devices */</span>
	<span class="enscript-type">struct</span> mount		*hfs_mp;				<span class="enscript-comment">/* filesystem vfs structure */</span>
	<span class="enscript-type">struct</span> vnode		*hfs_devvp;				<span class="enscript-comment">/* block device mounted vnode */</span>
	<span class="enscript-type">struct</span> vnode *		hfs_extents_vp;
	<span class="enscript-type">struct</span> vnode *		hfs_catalog_vp;
	<span class="enscript-type">struct</span> vnode *		hfs_allocation_vp;
	<span class="enscript-type">struct</span> vnode *		hfs_attribute_vp;
	<span class="enscript-type">struct</span> vnode *		hfs_startup_vp;
	<span class="enscript-type">struct</span> vnode *		hfs_attrdata_vp;   <span class="enscript-comment">/* pseudo file */</span>
	<span class="enscript-type">struct</span> cnode *		hfs_extents_cp;
	<span class="enscript-type">struct</span> cnode *		hfs_catalog_cp;
	<span class="enscript-type">struct</span> cnode *		hfs_allocation_cp;
	<span class="enscript-type">struct</span> cnode *		hfs_attribute_cp;
	<span class="enscript-type">struct</span> cnode *		hfs_startup_cp;
	dev_t			hfs_raw_dev;			<span class="enscript-comment">/* device mounted */</span>
	u_int32_t		hfs_logBlockSize;		<span class="enscript-comment">/* Size of buffer cache buffer for I/O */</span>
	
	<span class="enscript-comment">/* Default values for HFS standard and non-init access */</span>
	uid_t         hfs_uid;            <span class="enscript-comment">/* uid to set as owner of the files */</span>
	gid_t         hfs_gid;            <span class="enscript-comment">/* gid to set as owner of the files */</span>
	mode_t        hfs_dir_mask;       <span class="enscript-comment">/* mask to and with directory protection bits */</span>
	mode_t        hfs_file_mask;      <span class="enscript-comment">/* mask to and with file protection bits */</span>
	u_int32_t        hfs_encoding;       <span class="enscript-comment">/* Default encoding for non hfs+ volumes */</span>	

	<span class="enscript-comment">/* Persistent fields (on disk, dynamic) */</span>
	time_t        hfs_mtime;          <span class="enscript-comment">/* file system last modification time */</span>
	u_int32_t     hfs_filecount;      <span class="enscript-comment">/* number of files in file system */</span>
	u_int32_t     hfs_dircount;       <span class="enscript-comment">/* number of directories in file system */</span>
	u_int32_t     freeBlocks;	  	  <span class="enscript-comment">/* free allocation blocks */</span>
	u_int32_t	  reclaimBlocks;	  <span class="enscript-comment">/* number of blocks we are reclaiming during resize */</span>
	u_int32_t	  tentativeBlocks;	  <span class="enscript-comment">/* tentative allocation blocks -- see note below */</span>
	u_int32_t     nextAllocation;	  <span class="enscript-comment">/* start of next allocation search */</span>
	u_int32_t     sparseAllocation;   <span class="enscript-comment">/* start of allocations for sparse devices */</span>
	u_int32_t     vcbNxtCNID;         <span class="enscript-comment">/* next unused catalog node ID - protected by catalog lock */</span>
	u_int32_t     vcbWrCnt;           <span class="enscript-comment">/* file system write count */</span>
	u_int64_t     encodingsBitmap;    <span class="enscript-comment">/* in-use encodings */</span>
	u_int16_t     vcbNmFls;           <span class="enscript-comment">/* HFS Only - root dir file count */</span>
	u_int16_t     vcbNmRtDirs;        <span class="enscript-comment">/* HFS Only - root dir directory count */</span>

	<span class="enscript-comment">/* Persistent fields (on disk, static) */</span>
	u_int16_t 			vcbSigWord;

	<span class="enscript-comment">// Volume will be inconsistent if header is not flushed
</span>	bool				hfs_header_dirty;

	<span class="enscript-comment">// Volume header is dirty, but won't be inconsistent if not flushed
</span>	bool				hfs_header_minor_change;

	u_int32_t 			vcbAtrb;
	u_int32_t 			vcbJinfoBlock;
	u_int32_t 			localCreateDate;<span class="enscript-comment">/* volume create time from volume header (For HFS+, value is in local time) */</span>
	time_t				hfs_itime;	<span class="enscript-comment">/* file system creation time (creation date of the root folder) */</span>
	time_t				hfs_btime;	<span class="enscript-comment">/* file system last backup time */</span>
	u_int32_t 			blockSize;	<span class="enscript-comment">/* size of allocation blocks */</span>
	u_int32_t 			totalBlocks;	<span class="enscript-comment">/* total allocation blocks */</span>
	u_int32_t			allocLimit;	<span class="enscript-comment">/* Do not allocate this block or beyond */</span>
	<span class="enscript-comment">/*
	 * NOTE: When resizing a volume to make it smaller, allocLimit is set to the allocation
	 * block number which will contain the new alternate volume header.  At all other times,
	 * allocLimit is set to totalBlocks.  The allocation code uses allocLimit instead of
	 * totalBlocks to limit which blocks may be allocated, so that during a resize, we don't
	 * put new content into the blocks we're trying to truncate away.
	 */</span>
	int32_t 			vcbClpSiz;
	u_int32_t     vcbFndrInfo[8];
	int16_t 			vcbVBMSt;		<span class="enscript-comment">/* HFS only */</span>
	int16_t 			vcbAlBlSt;		<span class="enscript-comment">/* HFS only */</span>

	<span class="enscript-comment">/* vcb stuff */</span>
	u_int8_t		 	vcbVN[256];		<span class="enscript-comment">/* volume name in UTF-8 */</span>
	u_int32_t	 		volumeNameEncodingHint;
	u_int32_t 			hfsPlusIOPosOffset;	<span class="enscript-comment">/* Disk block where HFS+ starts */</span>
	u_int32_t 			vcbVBMIOSize;		<span class="enscript-comment">/* volume bitmap I/O size */</span>
	
	<span class="enscript-comment">/* cache of largest known free extents */</span>
	u_int32_t			vcbFreeExtCnt;
	HFSPlusExtentDescriptor vcbFreeExt[kMaxFreeExtents];
	lck_spin_t			vcbFreeExtLock;
	
	<span class="enscript-comment">/* Summary Table */</span>
	u_int8_t			*hfs_summary_table; <span class="enscript-comment">/* Each bit is 1 vcbVBMIOSize of bitmap, byte indexed */</span>
	u_int32_t			hfs_summary_size;	<span class="enscript-comment">/* number of BITS in summary table defined above (not bytes!) */</span>
	u_int32_t			hfs_summary_bytes;	<span class="enscript-comment">/* number of BYTES in summary table */</span>
	
	u_int32_t 			scan_var;			<span class="enscript-comment">/* For initializing the summary table */</span>


	u_int32_t		reserveBlocks;		<span class="enscript-comment">/* free block reserve */</span>
	u_int32_t		loanedBlocks;		<span class="enscript-comment">/* blocks on loan for delayed allocations */</span>
	u_int32_t		lockedBlocks;		<span class="enscript-comment">/* blocks reserved and locked */</span>

	<span class="enscript-comment">/*
	 * HFS+ Private system directories (two). Any access
	 * (besides looking at the cd_cnid) requires holding
	 * the Catalog File lock.
	 */</span>
	<span class="enscript-type">struct</span> cat_desc     hfs_private_desc[2];
	<span class="enscript-type">struct</span> cat_attr     hfs_private_attr[2];

	u_int32_t		hfs_metadata_createdate;
	hfs_to_unicode_func_t	hfs_get_unicode;
	unicode_to_hfs_func_t	hfs_get_hfsname;
 
	<span class="enscript-comment">/* Quota variables: */</span>
	<span class="enscript-type">struct</span> quotafile	hfs_qfiles[MAXQUOTAS];    <span class="enscript-comment">/* quota files */</span>

	<span class="enscript-comment">/* Journaling variables: */</span>
	<span class="enscript-type">struct</span> journal      *jnl;           <span class="enscript-comment">// the journal for this volume (if one exists)
</span>	<span class="enscript-type">struct</span> vnode        *jvp;           <span class="enscript-comment">// device where the journal lives (may be equal to devvp)
</span>	u_int32_t            jnl_start;     <span class="enscript-comment">// start block of the journal file (so we don't delete it)
</span>	u_int32_t            jnl_size;
	u_int32_t            hfs_jnlfileid;
	u_int32_t            hfs_jnlinfoblkid;
	lck_rw_t	     	 hfs_global_lock;
	thread_t			 hfs_global_lockowner;
	u_int32_t            hfs_transaction_nesting;

	<span class="enscript-comment">/* Notification variables: */</span>
	u_int32_t		hfs_notification_conditions;
	u_int32_t		hfs_freespace_notify_dangerlimit;
	u_int32_t		hfs_freespace_notify_warninglimit;
	u_int32_t		hfs_freespace_notify_desiredlevel;

	<span class="enscript-comment">/* time mounted and last mounted mod time &quot;snapshot&quot; */</span>
	time_t		hfs_mount_time;
	time_t 		hfs_last_mounted_mtime;

	<span class="enscript-comment">/* Metadata allocation zone variables: */</span>
	u_int32_t	hfs_metazone_start;
	u_int32_t	hfs_metazone_end;
	u_int32_t	hfs_hotfile_start;
	u_int32_t	hfs_hotfile_end;
        u_int32_t       hfs_min_alloc_start;
	u_int32_t       hfs_freed_block_count;
	u_int64_t       hfs_cs_hotfile_size;     <span class="enscript-comment">// in bytes
</span>	<span class="enscript-type">int</span>		hfs_hotfile_freeblks;
	<span class="enscript-type">int</span>             hfs_hotfile_blk_adjust;
	<span class="enscript-type">int</span>		hfs_hotfile_maxblks;
	<span class="enscript-type">int</span>		hfs_overflow_maxblks;
	<span class="enscript-type">int</span>		hfs_catalog_maxblks;

	<span class="enscript-comment">/* Hot File Clustering variables: */</span>
	lck_mtx_t       hfc_mutex;      <span class="enscript-comment">/* serialize hot file stages */</span>
	<span class="enscript-type">enum</span> hfc_stage  hfc_stage;      <span class="enscript-comment">/* what are we up to... */</span>
	time_t		hfc_timebase;   <span class="enscript-comment">/* recording period start time */</span>
	time_t		hfc_timeout;    <span class="enscript-comment">/* recording period stop time */</span>
	<span class="enscript-type">void</span> *		hfc_recdata;    <span class="enscript-comment">/* recording data (opaque) */</span>
	uint32_t	hfc_maxfiles;   <span class="enscript-comment">/* maximum files to track */</span>
	<span class="enscript-type">struct</span> vnode *  hfc_filevp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_SPARSE_DEV</span>
	<span class="enscript-comment">/* Sparse device variables: */</span>
	<span class="enscript-type">struct</span> vnode * hfs_backingfs_rootvp;
	u_int32_t      hfs_last_backingstatfs;
	u_int32_t      hfs_sparsebandblks;
	u_int64_t      hfs_backingfs_maxblocks;
#<span class="enscript-reference">endif</span>
	size_t         hfs_max_inline_attrsize;

	lck_mtx_t      hfs_mutex;      <span class="enscript-comment">/* protects access to hfsmount data */</span>

	uint32_t       hfs_syncers;	<span class="enscript-comment">// Count of the number of syncers running
</span>	<span class="enscript-type">enum</span> {
		HFS_THAWED,
		HFS_WANT_TO_FREEZE,	<span class="enscript-comment">// This state stops hfs_sync from starting
</span>		HFS_FREEZING,		<span class="enscript-comment">// We're in this state whilst we're flushing
</span>		HFS_FROZEN			<span class="enscript-comment">// Everything gets blocked in hfs_lock_global
</span>	} hfs_freeze_state;
	<span class="enscript-type">union</span> {
		<span class="enscript-comment">/*
		 * When we're freezing (HFS_FREEZING) but not yet
		 * frozen (HFS_FROZEN), we record the freezing thread
		 * so that we stop other threads from taking locks,
		 * but allow the freezing thread. 
		 */</span>
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> thread *hfs_freezing_thread;
		<span class="enscript-comment">/*
		 * Once we have frozen (HFS_FROZEN), we record the
		 * process so that if it dies, we can automatically
		 * unfreeze. 
		 */</span>
		proc_t hfs_freezing_proc;
	};

	thread_t		hfs_downgrading_thread; <span class="enscript-comment">/* thread who's downgrading to rdonly */</span>

	<span class="enscript-comment">/* Resize variables: */</span>
	u_int32_t		hfs_resize_blocksmoved;
	u_int32_t		hfs_resize_totalblocks;
	u_int32_t		hfs_resize_progress;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* Data Protection fields */</span>
	cpx_t			hfs_resize_cpx;
	u_int16_t		hfs_running_cp_major_vers;
	uint32_t		default_cp_class; <span class="enscript-comment">/* default effective class value */</span>
	uint64_t		cproot_flags;
	uint8_t			cp_crypto_generation; 
	uint8_t			hfs_cp_lock_state;  <span class="enscript-comment">/* per-mount device lock state info */</span> 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_TMPDBG</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
	boolean_t		hfs_cp_verbose;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Per mount cnode hash variables: */</span>
	lck_mtx_t      hfs_chash_mutex;	<span class="enscript-comment">/* protects access to cnode hash table */</span>
	u_long         hfs_cnodehash;	<span class="enscript-comment">/* size of cnode hash table - 1 */</span>
	LIST_HEAD(cnodehashhead, cnode) *hfs_cnodehashtbl;	<span class="enscript-comment">/* base of cnode hash */</span>
					
	<span class="enscript-comment">/* Per mount fileid hash variables  (protected by catalog lock!) */</span>
	u_long hfs_idhash; <span class="enscript-comment">/* size of cnid/fileid hash table -1 */</span>
	LIST_HEAD(idhashhead, cat_preflightid) *hfs_idhashtbl; <span class="enscript-comment">/* base of ID hash */</span>

    <span class="enscript-comment">// Records the oldest outstanding sync request
</span>    <span class="enscript-type">struct</span> timeval	hfs_sync_req_oldest;

    <span class="enscript-comment">// Records whether a sync has been queued or is in progress
</span>	boolean_t		hfs_sync_incomplete;

	thread_call_t   hfs_syncer;	       <span class="enscript-comment">// removeable devices get sync'ed by this guy
</span>
    <span class="enscript-comment">/* Records the syncer thread so that we can avoid the syncer
       queing more syncs. */</span>
    thread_t		hfs_syncer_thread;

    <span class="enscript-comment">// Not currently used except for debugging purposes
</span>	uint32_t        hfs_active_threads;

	<span class="enscript-type">enum</span> {
		<span class="enscript-comment">// These are indices into the array below
</span>
		<span class="enscript-comment">// Tentative ranges can be claimed back at any time
</span>		HFS_TENTATIVE_BLOCKS	= 0,

		<span class="enscript-comment">// Locked ranges cannot be claimed back, but the allocation
</span>		<span class="enscript-comment">// won't have been written to disk yet
</span>		HFS_LOCKED_BLOCKS		= 1,
	};
	<span class="enscript-comment">// These lists are not sorted like a range list usually is
</span>	<span class="enscript-type">struct</span> rl_head hfs_reserved_ranges[2];
} hfsmount_t;

<span class="enscript-comment">/*
 * HFS_META_DELAY is a duration (in usecs) used for triggering the 
 * hfs_syncer() routine. We will back off if writes are in 
 * progress, but...
 * HFS_MAX_META_DELAY is the maximum time we will allow the
 * syncer to be delayed.
 */</span>
<span class="enscript-type">enum</span> {
    HFS_META_DELAY     = 100  * 1000,	<span class="enscript-comment">// 0.1 secs
</span>    HFS_MAX_META_DELAY = 5000 * 1000	<span class="enscript-comment">// 5 secs
</span>};

<span class="enscript-type">typedef</span> hfsmount_t  ExtendedVCB;

<span class="enscript-comment">/* Aliases for legacy (Mac OS 9) field names */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vcbLsMod</span>           hfs_mtime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vcbVolBkUp</span>         hfs_btime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">extentsRefNum</span>      hfs_extents_vp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">catalogRefNum</span>      hfs_catalog_vp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">allocationsRefNum</span>  hfs_allocation_vp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vcbFilCnt</span>          hfs_filecount
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">vcbDirCnt</span>          hfs_dircount

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">MarkVCBDirty</span>(hfsmount_t *hfsmp)
{ 
	hfsmp-&gt;hfs_header_dirty = true;
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">MarkVCBClean</span>(hfsmount_t *hfsmp)
{
	hfsmp-&gt;hfs_header_dirty = false;
	hfsmp-&gt;hfs_header_minor_change = false;
}

<span class="enscript-type">static</span> inline bool <span class="enscript-function-name">IsVCBDirty</span>(ExtendedVCB *vcb)
{
	<span class="enscript-keyword">return</span> vcb-&gt;hfs_header_minor_change || vcb-&gt;hfs_header_dirty;
}

<span class="enscript-comment">// Header is changed but won't be inconsistent if we don't write it
</span><span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_note_header_minor_change</span>(hfsmount_t *hfsmp)
{
	hfsmp-&gt;hfs_header_minor_change = true;
}

<span class="enscript-comment">// Must header be flushed for volume to be consistent?
</span><span class="enscript-type">static</span> inline bool <span class="enscript-function-name">hfs_header_needs_flushing</span>(hfsmount_t *hfsmp)
{
	<span class="enscript-keyword">return</span> (hfsmp-&gt;hfs_header_dirty
			|| ISSET(hfsmp-&gt;hfs_catalog_cp-&gt;c_flag, C_MODIFIED)
			|| ISSET(hfsmp-&gt;hfs_extents_cp-&gt;c_flag, C_MODIFIED)
			|| (hfsmp-&gt;hfs_attribute_cp
				&amp;&amp; ISSET(hfsmp-&gt;hfs_attribute_cp-&gt;c_flag, C_MODIFIED))
			|| (hfsmp-&gt;hfs_allocation_cp
				&amp;&amp; ISSET(hfsmp-&gt;hfs_allocation_cp-&gt;c_flag, C_MODIFIED))
			|| (hfsmp-&gt;hfs_startup_cp
				&amp;&amp; ISSET(hfsmp-&gt;hfs_startup_cp-&gt;c_flag, C_MODIFIED)));
}

<span class="enscript-comment">/*
 * There are two private directories in HFS+.
 *
 * One contains inodes for files that are hardlinked or open/unlinked.
 * The other contains inodes for directories that are hardlinked.
 */</span>
<span class="enscript-type">enum</span> privdirtype {FILE_HARDLINKS, DIR_HARDLINKS};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ALLOCATOR_SCAN_INFLIGHT</span>	0x0001  	<span class="enscript-comment">/* scan started */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_ALLOCATOR_SCAN_COMPLETED</span> 0x0002		<span class="enscript-comment">/* initial scan was completed */</span>

<span class="enscript-comment">/* HFS mount point flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_READ_ONLY</span>             0x00001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_UNKNOWN_PERMS</span>         0x00002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_WRITEABLE_MEDIA</span>       0x00004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CLEANED_ORPHANS</span>       0x00008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_X</span>                     0x00010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CASE_SENSITIVE</span>        0x00020
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_STANDARD</span>              0x00040
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_METADATA_ZONE</span>         0x00080
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_FRAGMENTED_FREESPACE</span>  0x00100
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_NEED_JNL_RESET</span>        0x00200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_HAS_SPARSE_DEVICE</span>     0x00400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_RESIZE_IN_PROGRESS</span>    0x00800
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_QUOTAS</span>                0x01000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CREATING_BTREE</span>        0x02000
<span class="enscript-comment">/* When set, do not update nextAllocation in the mount structure */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SKIP_UPDATE_NEXT_ALLOCATION</span> 0x04000	
<span class="enscript-comment">/* When set, the file system supports extent-based extended attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_XATTR_EXTENTS</span>         0x08000	
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">HFS_FOLDERCOUNT</span>           0x10000
<span class="enscript-comment">/* When set, the file system exists on a virtual device, like disk image */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_VIRTUAL_DEVICE</span>        0x20000
<span class="enscript-comment">/* When set, we're in hfs_changefs, so hfs_sync should do nothing. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_IN_CHANGEFS</span>           0x40000
<span class="enscript-comment">/* When set, we are in process of downgrading or have downgraded to read-only, 
 * so hfs_start_transaction should return EROFS.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_RDONLY_DOWNGRADE</span>      0x80000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_DID_CONTIG_SCAN</span>      0x100000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_UNMAP</span>                0x200000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SSD</span>                  0x400000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SUMMARY_TABLE</span>        0x800000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CS</span>                  0x1000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CS_METADATA_PIN</span>     0x2000000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CS_HOTFILE_PIN</span>      0x4000000	<span class="enscript-comment">/* cooperative fusion (enables a hotfile variant) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_FEATURE_BARRIER</span>     0x8000000	<span class="enscript-comment">/* device supports barrier-only flush */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_CS_SWAPFILE_PIN</span>    0x10000000

<span class="enscript-comment">/* Macro to update next allocation block in the HFS mount structure.  If 
 * the HFS_SKIP_UPDATE_NEXT_ALLOCATION is set, do not update 
 * nextAllocation block.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_UPDATE_NEXT_ALLOCATION</span>(hfsmp, new_nextAllocation)			\
	{								\
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_SKIP_UPDATE_NEXT_ALLOCATION) == 0)\
			hfsmp-&gt;nextAllocation = new_nextAllocation;	\
	}								\

<span class="enscript-comment">/* Macro for incrementing and decrementing the folder count in a cnode 
 * attribute only if the HFS_FOLDERCOUNT bit is set in the mount flags 
 * and kHFSHasFolderCount bit is set in the cnode flags.  Currently these 
 * bits are only set for case sensitive HFS+ volumes.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">INC_FOLDERCOUNT</span>(hfsmp, cattr) 				\
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT) &amp;&amp;		\
	    (cattr.ca_recflags &amp; kHFSHasFolderCountMask)) { 	\
		cattr.ca_dircount++;				\
	}							\

#<span class="enscript-reference">define</span> <span class="enscript-function-name">DEC_FOLDERCOUNT</span>(hfsmp, cattr) 				\
	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT) &amp;&amp;		\
	    (cattr.ca_recflags &amp; kHFSHasFolderCountMask) &amp;&amp; 	\
	    (cattr.ca_dircount &gt; 0)) { 				\
		cattr.ca_dircount--;				\
	}							\

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> filefork FCB;

<span class="enscript-comment">/*
 * Macros for creating item names for our special/private directories.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_INODE_NAME</span>(name, size, linkno) \
	    (<span class="enscript-type">void</span>) snprintf((name), size, <span class="enscript-string">&quot;%s%d&quot;</span>, HFS_INODE_PREFIX, (linkno))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_INODE_PREFIX_LEN</span>	5

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_DIRINODE_NAME</span>(name, size, linkno) \
	    (<span class="enscript-type">void</span>) snprintf((name), size, <span class="enscript-string">&quot;%s%d&quot;</span>, HFS_DIRINODE_PREFIX, (linkno))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_DIRINODE_PREFIX_LEN</span>   4

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAKE_DELETED_NAME</span>(NAME, size, FID) \
	    (<span class="enscript-type">void</span>) snprintf((NAME), size, <span class="enscript-string">&quot;%s%d&quot;</span>, HFS_DELETE_PREFIX, (FID))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_DELETE_PREFIX_LEN</span>	4


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_AVERAGE_NAME_SIZE</span>	22
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AVERAGE_HFSDIRENTRY_SIZE</span>  (8+HFS_AVERAGE_NAME_SIZE+4)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">STD_DIRENT_LEN</span>(namlen) \
	((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dirent) - (NAME_MAX+1)) + (((namlen)+1 + 3) &amp;~ 3))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">EXT_DIRENT_LEN</span>(namlen) \
	((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> direntry) + (namlen) - (MAXPATHLEN-1) + 7) &amp; ~7)


<span class="enscript-type">enum</span> { kHFSPlusMaxFileNameBytes = kHFSPlusMaxFileNameChars * 3 };


<span class="enscript-comment">/* macro to determine if hfs or hfsplus */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ISHFSPLUS</span>(VCB) ((VCB)-&gt;vcbSigWord == kHFSPlusSigWord)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ISHFS</span>(VCB) ((VCB)-&gt;vcbSigWord == kHFSSigWord)


<span class="enscript-comment">/*
 * Various ways to acquire a VFS mount point pointer:
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOVFS</span>(VP)  vnode_mount((VP))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFSTOVFS</span>(HFSMP) ((HFSMP)-&gt;hfs_mp)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCBTOVFS</span>(VCB)   HFSTOVFS(VCB)

<span class="enscript-comment">/*
 * Various ways to acquire an HFS mount point pointer:
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOHFS</span>(VP)  ((struct hfsmount *)vfs_fsprivate(vnode_mount((VP))))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">VFSTOHFS</span>(MP)  ((struct hfsmount *)vfs_fsprivate((MP)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VCBTOHFS</span>(VCB) (VCB)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FCBTOHFS</span>(FCB)  ((struct hfsmount *)vfs_fsprivate(vnode_mount((FCB)-&gt;ff_cp-&gt;c_vp)))

<span class="enscript-comment">/*
 * Various ways to acquire a VCB (legacy) pointer:
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTOVCB</span>(VP)       VTOHFS(VP)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VFSTOVCB</span>(MP)     VFSTOHFS(MP)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFSTOVCB</span>(HFSMP)  (HFSMP)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FCBTOVCB</span>(FCB)    FCBTOHFS(FCB)


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">E_NONE</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kHFSBlockSize</span> 512

<span class="enscript-comment">/*
 * Macros for getting the MDB/VH sector and offset
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_PRI_SECTOR</span>(blksize)          (1024 / (blksize))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_PRI_OFFSET</span>(blksize)          ((blksize) &gt; 1024 ? 1024 : 0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_ALT_SECTOR</span>(blksize, blkcnt)  (((blkcnt) - 1) - (512 / (blksize)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_ALT_OFFSET</span>(blksize)          ((blksize) &gt; 1024 ? (blksize) - 1024 : 0)

<span class="enscript-comment">/* Convert the logical sector number to be aligned on physical block size boundary.  
 * We are assuming the partition is a multiple of physical block size.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HFS_PHYSBLK_ROUNDDOWN</span>(sector_num, log_per_phys)	((sector_num / log_per_phys) * log_per_phys)

<span class="enscript-comment">/*
 * HFS specific fcntl()'s
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_GET_BOOT_INFO</span>   (FCNTL_FS_SPECIFIC_BASE + 0x00004)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_SET_BOOT_INFO</span>   (FCNTL_FS_SPECIFIC_BASE + 0x00005)
<span class="enscript-comment">/* See HFSIOC_EXT_BULKACCESS and friends for HFS specific fsctls*/</span>



<span class="enscript-comment">/*
 *	This is the straight GMT conversion constant:
 *	00:00:00 January 1, 1970 - 00:00:00 January 1, 1904
 *	(3600 * 24 * ((365 * (1970 - 1904)) + (((1970 - 1904) / 4) + 1)))
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAC_GMT_FACTOR</span>		2082844800UL

<span class="enscript-type">static</span> inline <span class="enscript-function-name">__attribute__</span>((<span class="enscript-type">const</span>))
off_t <span class="enscript-function-name">hfs_blk_to_bytes</span>(uint32_t blk, uint32_t blk_size)
{
	<span class="enscript-keyword">return</span> (off_t)blk * blk_size; 		<span class="enscript-comment">// Avoid the overflow
</span>}

<span class="enscript-comment">/*
 * For now, we use EIO to indicate consistency issues.  It is safe to
 * return or assign an error value to HFS_EINCONSISTENT but it is
 * *not* safe to compare against it because EIO can be generated for
 * other reasons.  We take advantage of the fact that == has
 * left-to-right associativity and so any uses of:
 *
 *    if (error == HFS_EINCONSISTENT)
 *
 * will produce a compiler warning: &quot;comparison between pointer and
 * integer&quot;.
 *
 * Note that not everwhere is consistent with the use of
 * HFS_EINCONSISTENT.  Some places return EINVAL, EIO directly or
 * other error codes.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_EINCONSISTENT</span>		(void *)0 == (void *)0 ? EIO : EIO

<span class="enscript-comment">/*****************************************************************************
	FUNCTION PROTOTYPES 
******************************************************************************/</span>

<span class="enscript-comment">/*****************************************************************************
	hfs_vnop_xxx functions from different files 
******************************************************************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_readdirattr</span>(<span class="enscript-type">struct</span> vnop_readdirattr_args *);  <span class="enscript-comment">/* in hfs_attrlist.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_getattrlistbulk</span>(<span class="enscript-type">struct</span> vnop_getattrlistbulk_args *);  <span class="enscript-comment">/* in hfs_attrlist.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_inactive</span>(<span class="enscript-type">struct</span> vnop_inactive_args *);        <span class="enscript-comment">/* in hfs_cnode.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_reclaim</span>(<span class="enscript-type">struct</span> vnop_reclaim_args *);          <span class="enscript-comment">/* in hfs_cnode.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_set_backingstore</span> (<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> val);				<span class="enscript-comment">/* in hfs_cnode.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_is_backingstore</span> (<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *val);		<span class="enscript-comment">/* in hfs_cnode.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_link</span>(<span class="enscript-type">struct</span> vnop_link_args *);                <span class="enscript-comment">/* in hfs_link.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_lookup</span>(<span class="enscript-type">struct</span> vnop_lookup_args *);            <span class="enscript-comment">/* in hfs_lookup.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_search</span>(<span class="enscript-type">struct</span> vnop_searchfs_args *);          <span class="enscript-comment">/* in hfs_search.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_read</span>(<span class="enscript-type">struct</span> vnop_read_args *);           <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_write</span>(<span class="enscript-type">struct</span> vnop_write_args *);         <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_ioctl</span>(<span class="enscript-type">struct</span> vnop_ioctl_args *);         <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_select</span>(<span class="enscript-type">struct</span> vnop_select_args *);       <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_strategy</span>(<span class="enscript-type">struct</span> vnop_strategy_args *);   <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_allocate</span>(<span class="enscript-type">struct</span> vnop_allocate_args *);   <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_pagein</span>(<span class="enscript-type">struct</span> vnop_pagein_args *);       <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_pageout</span>(<span class="enscript-type">struct</span> vnop_pageout_args *);     <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_bwrite</span>(<span class="enscript-type">struct</span> vnop_bwrite_args *);       <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_blktooff</span>(<span class="enscript-type">struct</span> vnop_blktooff_args *);   <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_offtoblk</span>(<span class="enscript-type">struct</span> vnop_offtoblk_args *);   <span class="enscript-comment">/* in hfs_readwrite.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_blockmap</span>(<span class="enscript-type">struct</span> vnop_blockmap_args *);   <span class="enscript-comment">/* in hfs_readwrite.c */</span>
errno_t <span class="enscript-function-name">hfs_flush_invalid_ranges</span>(vnode_t vp);		  <span class="enscript-comment">/* in hfs_readwrite.c */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_getxattr</span>(<span class="enscript-type">struct</span> vnop_getxattr_args *);        <span class="enscript-comment">/* in hfs_xattr.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_setxattr</span>(<span class="enscript-type">struct</span> vnop_setxattr_args *);        <span class="enscript-comment">/* in hfs_xattr.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_removexattr</span>(<span class="enscript-type">struct</span> vnop_removexattr_args *);  <span class="enscript-comment">/* in hfs_xattr.c */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_listxattr</span>(<span class="enscript-type">struct</span> vnop_listxattr_args *);      <span class="enscript-comment">/* in hfs_xattr.c */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_getnamedstream</span>(<span class="enscript-type">struct</span> vnop_getnamedstream_args*);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_makenamedstream</span>(<span class="enscript-type">struct</span> vnop_makenamedstream_args*);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vnop_removenamedstream</span>(<span class="enscript-type">struct</span> vnop_removenamedstream_args*);
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*****************************************************************************
	Functions from MacOSStubs.c
******************************************************************************/</span>
time_t <span class="enscript-function-name">to_bsd_time</span>(u_int32_t hfs_time);

u_int32_t <span class="enscript-function-name">to_hfs_time</span>(time_t bsd_time);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_encodinghint.c
******************************************************************************/</span>
u_int32_t <span class="enscript-function-name">hfs_pickencoding</span>(<span class="enscript-type">const</span> u_int16_t *src, <span class="enscript-type">int</span> len);

u_int32_t <span class="enscript-function-name">hfs_getencodingbias</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_setencodingbias</span>(u_int32_t bias);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_encodings.c
******************************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_converterinit</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_relconverter</span> (u_int32_t encoding);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getconverter</span>(u_int32_t encoding, hfs_to_unicode_func_t *get_unicode,
		     unicode_to_hfs_func_t *get_hfsname);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_to_utf8</span>(ExtendedVCB *vcb, <span class="enscript-type">const</span> Str31 hfs_str, ByteCount maxDstLen,
		ByteCount *actualDstLen, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>* dstStr);

<span class="enscript-type">int</span> <span class="enscript-function-name">utf8_to_hfs</span>(ExtendedVCB *vcb, ByteCount srcLen, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>* srcStr,
		Str31 dstStr);

<span class="enscript-type">int</span> <span class="enscript-function-name">mac_roman_to_utf8</span>(<span class="enscript-type">const</span> Str31 hfs_str, ByteCount maxDstLen, ByteCount *actualDstLen,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>* dstStr);

<span class="enscript-type">int</span> <span class="enscript-function-name">utf8_to_mac_roman</span>(ByteCount srcLen, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>* srcStr, Str31 dstStr);

<span class="enscript-type">int</span> <span class="enscript-function-name">mac_roman_to_unicode</span>(<span class="enscript-type">const</span> Str31 hfs_str, UniChar *uni_str, u_int32_t maxCharLen, u_int32_t *usedCharLen);

<span class="enscript-type">int</span> <span class="enscript-function-name">unicode_to_hfs</span>(ExtendedVCB *vcb, ByteCount srcLen, u_int16_t* srcStr, Str31 dstStr, <span class="enscript-type">int</span> retry);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_notifications.c
******************************************************************************/</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_generate_volume_notifications</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_readwrite.c
******************************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_relocate</span>(<span class="enscript-type">struct</span>  vnode *, u_int32_t, kauth_cred_t, <span class="enscript-type">struct</span>  proc *);

<span class="enscript-comment">/* flags for hfs_pin_block_range() and hfs_pin_vnode() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_PIN_IT</span>       0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_UNPIN_IT</span>     0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_TEMP_PIN</span>     0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_EVICT_PIN</span>    0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_DATALESS_PIN</span> 0x0010

<span class="enscript-comment">//
</span><span class="enscript-comment">// pin/un-pin an explicit range of blocks to the &quot;fast&quot; (usually ssd) device
</span><span class="enscript-comment">//
</span><span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_block_range</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> pin_state, uint32_t start_block, uint32_t nblocks, vfs_context_t ctx);

<span class="enscript-comment">//
</span><span class="enscript-comment">// pin/un-pin all the extents belonging to a vnode.
</span><span class="enscript-comment">// also, if it is non-null, &quot;num_blocks_pinned&quot; returns the number of blocks pin/unpinned by the function
</span><span class="enscript-comment">//
</span><span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_vnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> pin_state, uint32_t *num_blocks_pinned, vfs_context_t ctx);


<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_pin_overflow_extents</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileid, uint8_t forktype, uint32_t *pinned);
                                     

<span class="enscript-comment">/* Flags for HFS truncate */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_TRUNCATE_SKIPTIMES</span>  	0x00000002 <span class="enscript-comment">/* implied by skipupdate; it is a subset */</span>
											

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_truncate</span>(<span class="enscript-type">struct</span> vnode *, off_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, vfs_context_t);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_release_storage</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> filefork *datafork, 
								<span class="enscript-type">struct</span> filefork *rsrcfork,  u_int32_t fileid);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_prepare_release_storage</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_bmap</span>(<span class="enscript-type">struct</span> vnode *, daddr_t, <span class="enscript-type">struct</span> vnode **, daddr64_t *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *);

<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">hfs_ubc_setsize</span>(vnode_t vp, off_t len, bool have_cnode_lock);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_resize.c 
******************************************************************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_extendfs</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int64_t newsize, vfs_context_t context);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_truncatefs</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int64_t newsize, vfs_context_t context);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_vfsops.c
******************************************************************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_mountroot</span>(mount_t mp, vnode_t rvp, vfs_context_t context);

<span class="enscript-comment">/* used as a callback by the journaling code */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_sync_metadata</span>(<span class="enscript-type">void</span> *arg);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vget</span>(<span class="enscript-type">struct</span> hfsmount *, cnid_t, <span class="enscript-type">struct</span> vnode **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_setencodingbits</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t encoding);

<span class="enscript-type">enum</span> volop {VOL_UPDATE, VOL_MKDIR, VOL_RMDIR, VOL_MKFILE, VOL_RMFILE};
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_volupdate</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">enum</span> volop op, <span class="enscript-type">int</span> inroot);

<span class="enscript-type">enum</span> {
	HFS_FVH_WAIT					= 0x0001,
	HFS_FVH_WRITE_ALT				= 0x0002,
	HFS_FVH_FLUSH_IF_DIRTY			= 0x0004,
};
<span class="enscript-type">typedef</span> uint32_t hfs_flush_volume_header_options_t;
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_flushvolumeheader</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, hfs_flush_volume_header_options_t);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_extendfs</span>(<span class="enscript-type">struct</span> hfsmount *, u_int64_t, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_truncatefs</span>(<span class="enscript-type">struct</span> hfsmount *, u_int64_t, vfs_context_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_resize_progress</span>(<span class="enscript-type">struct</span> hfsmount *, u_int32_t *);

<span class="enscript-comment">/* If a runtime corruption is detected, mark the volume inconsistent 
 * bit in the volume attributes.
 */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	HFS_INCONSISTENCY_DETECTED,

	<span class="enscript-comment">// Used when unable to rollback an operation that failed
</span>	HFS_ROLLBACK_FAILED,

	<span class="enscript-comment">// Used when the latter part of an operation failed, but we chose not to roll back
</span>	HFS_OP_INCOMPLETE,

	<span class="enscript-comment">// Used when someone told us to force an fsck on next mount
</span>	HFS_FSCK_FORCED,
} hfs_inconsistency_reason_t;

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_mark_inconsistent</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp,
						   hfs_inconsistency_reason_t reason);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_scan_blocks</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_vfsutils.c
******************************************************************************/</span>
u_int32_t <span class="enscript-function-name">BestBlockSizeFit</span>(u_int32_t allocationBlockSize,
                               u_int32_t blockSizeLimit,
                               u_int32_t baseMultiple);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
OSErr	hfs_MountHFSVolume(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSMasterDirectoryBlock *mdb,
		<span class="enscript-type">struct</span> proc *p);
#<span class="enscript-reference">endif</span>
OSErr	hfs_MountHFSPlusVolume(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp,
		off_t embeddedOffset, u_int64_t disksize, <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">void</span> *args, kauth_cred_t cred);

OSErr <span class="enscript-function-name">hfs_ValidateHFSPlusVolumeHeader</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfsUnmount</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> proc *p);

<span class="enscript-type">extern</span> bool <span class="enscript-function-name">overflow_extents</span>(<span class="enscript-type">struct</span> filefork *fp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_owner_rights</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uid_t cnode_uid, kauth_cred_t cred,
		<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> invokesuperuserstatus);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">check_for_tracked_file</span>(<span class="enscript-type">struct</span> vnode *vp, time_t ctime, uint64_t op_type, <span class="enscript-type">void</span> *arg);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">check_for_dataless_file</span>(<span class="enscript-type">struct</span> vnode *vp, uint64_t op_type);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_generate_document_id</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t *docid);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_pin_fs_metadata</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/* Return information about number of metadata blocks for volume */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getinfo_metadata_blocks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> hfsinfo_metadata *hinfo);

<span class="enscript-comment">/*
 * Journal lock function prototypes
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_lock_global</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">enum</span> hfs_locktype locktype);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlock_global</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/* HFS mount lock/unlock prototypes */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_lock_mount</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_unlock_mount</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);


<span class="enscript-comment">/* HFS System file locking */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_CATALOG</span>     0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_EXTENTS</span>     0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_BITMAP</span>      0x0004
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_ATTRIBUTE</span>   0x0008
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_STARTUP</span>	0x0010
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_VM_PRIV</span>	0x0020
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SFL_VALIDMASK</span>   (SFL_CATALOG | SFL_EXTENTS | SFL_BITMAP | SFL_ATTRIBUTE | SFL_STARTUP | SFL_VM_PRIV)

<span class="enscript-type">extern</span> u_int32_t  <span class="enscript-function-name">GetFileInfo</span>(ExtendedVCB *vcb, u_int32_t dirid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name,
						   <span class="enscript-type">struct</span> cat_attr *fattr, <span class="enscript-type">struct</span> cat_fork *forkinfo);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_remove_orphans</span>(<span class="enscript-type">struct</span> hfsmount *);

u_int32_t <span class="enscript-function-name">GetLogicalBlockSize</span>(<span class="enscript-type">struct</span> vnode *vp);

<span class="enscript-type">extern</span> u_int32_t <span class="enscript-function-name">hfs_freeblks</span>(<span class="enscript-type">struct</span> hfsmount * hfsmp, <span class="enscript-type">int</span> wantreserve);

<span class="enscript-type">short</span> <span class="enscript-function-name">MacToVFSError</span>(OSErr err);

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_metadatazone_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">int</span> disable);

<span class="enscript-comment">/* HFS directory hint functions. */</span>
<span class="enscript-type">extern</span> directoryhint_t * <span class="enscript-function-name">hfs_getdirhint</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_reldirhint</span>(<span class="enscript-type">struct</span> cnode *, directoryhint_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_reldirhints</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_insertdirhint</span>(<span class="enscript-type">struct</span> cnode *, directoryhint_t *);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_namecmp</span>(<span class="enscript-type">const</span> u_int8_t *str1, size_t len1, <span class="enscript-type">const</span> u_int8_t *str2, size_t len2);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>     <span class="enscript-function-name">hfs_early_journal_init</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, HFSPlusVolumeHeader *vhp,
			   <span class="enscript-type">void</span> *_args, off_t embeddedOffset, daddr64_t mdb_offset,
			   HFSMasterDirectoryBlock *mdbp, kauth_cred_t cred);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_virtualmetafile</span>(<span class="enscript-type">struct</span> cnode *);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_start_transaction</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_end_transaction</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_journal_lock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_journal_unlock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_lock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_unlock</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_wait</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_wakeup</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_syncer_queue</span>(thread_call_t syncer);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_sync_ejectable</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> hfs_flush_mode {
	HFS_FLUSH_JOURNAL,              <span class="enscript-comment">// Flush journal
</span>	HFS_FLUSH_JOURNAL_META,         <span class="enscript-comment">// Flush journal and metadata blocks
</span>	HFS_FLUSH_FULL,                 <span class="enscript-comment">// Flush journal and does a cache flush
</span>	HFS_FLUSH_CACHE,                <span class="enscript-comment">// Flush track cache to media
</span>	HFS_FLUSH_BARRIER,              <span class="enscript-comment">// Barrier-only flush to ensure write order
</span>	HFS_FLUSH_JOURNAL_BARRIER       <span class="enscript-comment">// Flush journal with barrier
</span>} hfs_flush_mode_t;

<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">hfs_flush</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, hfs_flush_mode_t mode);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_trim_callback</span>(<span class="enscript-type">void</span> *arg, uint32_t extent_count, <span class="enscript-type">const</span> dk_extent_t *extents);

<span class="enscript-comment">/* Erase unused Catalog nodes due to &lt;rdar://problem/6947811&gt;. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_erase_unused_nodes</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">hfs_usecs_to_deadline</span>(uint64_t usecs);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_freeze</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_thaw</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> proc *process);


<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_vnops.c
******************************************************************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_write_access</span>(<span class="enscript-type">struct</span> vnode *vp, kauth_cred_t cred, <span class="enscript-type">struct</span> proc *p, Boolean considerFlags);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_chmod</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> mode, kauth_cred_t cred, <span class="enscript-type">struct</span> proc *p);

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_chown</span>(<span class="enscript-type">struct</span> vnode *vp, uid_t uid, gid_t gid, kauth_cred_t cred, <span class="enscript-type">struct</span> proc *p);

#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">kMaxSecsForFsync</span>	5
#<span class="enscript-reference">define</span>  <span class="enscript-variable-name">HFS_SYNCTRANS</span>		1
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_btsync</span>(<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> sync_transaction);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">replace_desc</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">struct</span> cat_desc *cdp);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_vgetrsrc</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *vp,
						<span class="enscript-type">struct</span> vnode **rvpp);

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	<span class="enscript-comment">// Push all modifications to disk (including minor ones)
</span>	HFS_UPDATE_FORCE = 0x01,
} hfs_update_options_t;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_update</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">int</span> options);

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> hfs_sync_mode {
	HFS_FSYNC,
	HFS_FSYNC_FULL,
	HFS_FSYNC_BARRIER
} hfs_fsync_mode_t;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_fsync</span>(<span class="enscript-type">struct</span> vnode *, <span class="enscript-type">int</span>, hfs_fsync_mode_t, <span class="enscript-type">struct</span> proc *);

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *
<span class="enscript-function-name">hfs_prepare_fork_for_update</span>(filefork_t *ff,
							<span class="enscript-type">const</span> <span class="enscript-type">struct</span> cat_fork *cf,
							<span class="enscript-type">struct</span> cat_fork *cf_buf,
							uint32_t block_size);

<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_xattr.c
******************************************************************************/</span>

<span class="enscript-comment">/* 
 * Maximum extended attribute size supported for all extended attributes except  
 * resource fork and finder info.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_XATTR_MAXSIZE</span>	INT32_MAX

<span class="enscript-comment">/* Number of bits used to represent maximum extended attribute size */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HFS_XATTR_SIZE_BITS</span>	31

<span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_attrkeycompare</span>(HFSPlusAttrKey *searchKey, HFSPlusAttrKey *trialKey);
<span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_buildattrkey</span>(u_int32_t fileID, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *attrname, HFSPlusAttrKey *key);
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_xattr_init</span>(<span class="enscript-type">struct</span> hfsmount * hfsmp);
<span class="enscript-type">int</span> <span class="enscript-function-name">file_attribute_exist</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, uint32_t fileID);
<span class="enscript-type">int</span> <span class="enscript-function-name">init_attrdata_vnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_xattr_read</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">void</span> *data, size_t *size);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_getxattr_internal</span>(cnode_t *, <span class="enscript-type">struct</span> vnop_getxattr_args *,
                          <span class="enscript-type">struct</span> hfsmount *, u_int32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_xattr_write</span>(vnode_t vp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *data, size_t size);
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_setxattr_internal</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *, size_t, 
                          <span class="enscript-type">struct</span> vnop_setxattr_args *, <span class="enscript-type">struct</span> hfsmount *, u_int32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_removeallattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t fileid, 
							 bool *open_transaction);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_set_volxattr</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> xattrtype, <span class="enscript-type">int</span> state);



<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_link.c
******************************************************************************/</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_unlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> vnode *vp,
                       <span class="enscript-type">struct</span> componentname *cnp, <span class="enscript-type">int</span> skip_reserve);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_lookup_siblinglinks</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t linkfileid,
                           cnid_t *prevlinkid,  cnid_t *nextlinkid);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">hfs_lookup_lastlink</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, cnid_t linkfileid,
                           cnid_t *nextlinkid, <span class="enscript-type">struct</span> cat_desc *cdesc);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_privatedir_init</span>(<span class="enscript-type">struct</span> hfsmount *, <span class="enscript-type">enum</span> privdirtype);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_savelinkorigin</span>(cnode_t *cp, cnid_t parentcnid);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_relorigins</span>(<span class="enscript-type">struct</span> cnode *cp);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_relorigin</span>(<span class="enscript-type">struct</span> cnode *cp, cnid_t parentcnid);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>   <span class="enscript-function-name">hfs_haslinkorigin</span>(cnode_t *cp);
<span class="enscript-type">extern</span> cnid_t  <span class="enscript-function-name">hfs_currentparent</span>(cnode_t *cp, bool have_lock);
<span class="enscript-type">extern</span> cnid_t  <span class="enscript-function-name">hfs_currentcnid</span>(cnode_t *cp);
errno_t <span class="enscript-function-name">hfs_first_link</span>(hfsmount_t *hfsmp, cnode_t *cp, cnid_t *link_id);


<span class="enscript-comment">/*****************************************************************************
	Functions from VolumeAllocation.c
 ******************************************************************************/</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_isallocated</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startingBlock, u_int32_t numBlocks);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_count_allocated</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, u_int32_t startBlock, 
		u_int32_t numBlocks, u_int32_t *alloc_count);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_isrbtree_active</span> (<span class="enscript-type">struct</span> hfsmount *hfsmp);

<span class="enscript-comment">/*****************************************************************************
	Functions from hfs_fsinfo.c
 ******************************************************************************/</span>
<span class="enscript-type">extern</span> errno_t <span class="enscript-function-name">hfs_get_fsinfo</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">void</span> *a_data);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">hfs_fsinfo_data_add</span>(<span class="enscript-type">struct</span> hfs_fsinfo_data *fsinfo, uint64_t entry);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __HFS__ */</span>
</pre>
<hr />
</body></html>