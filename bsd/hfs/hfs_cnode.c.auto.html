<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>hfs_cnode.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">hfs_cnode.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2002-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_catalog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_cnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_format.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs_cprotect.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> prtactive;

<span class="enscript-type">extern</span> lck_attr_t *  hfs_lock_attr;
<span class="enscript-type">extern</span> lck_grp_t *  hfs_mutex_group;
<span class="enscript-type">extern</span> lck_grp_t *  hfs_rwlock_group;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>  <span class="enscript-function-name">hfs_reclaim_cnode</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cnode *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_cnode_teardown</span> (<span class="enscript-type">struct</span> vnode *vp, vfs_context_t ctx, <span class="enscript-type">int</span> reclaim);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_isordered</span>(<span class="enscript-type">struct</span> cnode *, <span class="enscript-type">struct</span> cnode *);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">hfs_removefile_callback</span>(<span class="enscript-type">struct</span> buf *bp, <span class="enscript-type">void</span> *hfsmp);


__inline__ <span class="enscript-type">int</span> hfs_checkdeleted (<span class="enscript-type">struct</span> cnode *cp) {
	<span class="enscript-keyword">return</span> ((cp-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS)) ? ENOENT : 0);	
}

<span class="enscript-comment">/*
 * Function used by a special fcntl() that decorates a cnode/vnode that
 * indicates it is backing another filesystem, like a disk image.
 *
 * the argument 'val' indicates whether or not to set the bit in the cnode flags
 * 
 * Returns non-zero on failure. 0 on success 
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_set_backingstore</span> (<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> val) {
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">int</span> err = 0;
	
	cp = VTOC(vp);
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp) &amp;&amp; !vnode_isdir(vp)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* lock the cnode */</span>
	err = hfs_lock (cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (err) {
		<span class="enscript-keyword">return</span> err;
	}
	
	<span class="enscript-keyword">if</span> (val) {
		cp-&gt;c_flag |= C_BACKINGSTORE;
	}
	<span class="enscript-keyword">else</span> {
		cp-&gt;c_flag &amp;= ~C_BACKINGSTORE;
	}

	<span class="enscript-comment">/* unlock everything */</span>
	hfs_unlock (cp);

	<span class="enscript-keyword">return</span> err;
}

<span class="enscript-comment">/*
 * Function used by a special fcntl() that check to see if a cnode/vnode
 * indicates it is backing another filesystem, like a disk image.
 *
 * the argument 'val' is an output argument for whether or not the bit is set
 * 
 * Returns non-zero on failure. 0 on success 
 */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_is_backingstore</span> (<span class="enscript-type">struct</span> vnode *vp, <span class="enscript-type">int</span> *val) {
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-keyword">if</span> (!vnode_isreg(vp) &amp;&amp; !vnode_isdir(vp)) {
		*val = 0;
		<span class="enscript-keyword">return</span> 0;
	}

	cp = VTOC(vp);

	<span class="enscript-comment">/* lock the cnode */</span>
	err = hfs_lock (cp, HFS_SHARED_LOCK, HFS_LOCK_DEFAULT);
	<span class="enscript-keyword">if</span> (err) {
		<span class="enscript-keyword">return</span> err;
	}

	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_BACKINGSTORE) {
		*val = 1;
	}	
	<span class="enscript-keyword">else</span> {
		*val = 0;
	}

	<span class="enscript-comment">/* unlock everything */</span>
	hfs_unlock (cp);

	<span class="enscript-keyword">return</span> err;
}


<span class="enscript-comment">/*
 * hfs_cnode_teardown
 *
 * This is an internal function that is invoked from both hfs_vnop_inactive
 * and hfs_vnop_reclaim.  As VNOP_INACTIVE is not necessarily called from vnodes
 * being recycled and reclaimed, it is important that we do any post-processing
 * necessary for the cnode in both places.  Important tasks include things such as
 * releasing the blocks from an open-unlinked file when all references to it have dropped,
 * and handling resource forks separately from data forks.
 *
 * Note that we take only the vnode as an argument here (rather than the cnode).
 * Recall that each cnode supports two forks (rsrc/data), and we can always get the right
 * cnode from either of the vnodes, but the reverse is not true -- we can't determine which
 * vnode we need to reclaim if only the cnode is supplied. 
 *
 * This function is idempotent and safe to call from both hfs_vnop_inactive and hfs_vnop_reclaim
 * if both are invoked right after the other.  In the second call, most of this function's if()
 * conditions will fail, since they apply generally to cnodes still marked with C_DELETED.  
 * As a quick check to see if this function is necessary, determine if the cnode is already
 * marked C_NOEXISTS.  If it is, then it is safe to skip this function.  The only tasks that 
 * remain for cnodes marked in such a fashion is to teardown their fork references and 
 * release all directory hints and hardlink origins.  However, both of those are done 
 * in hfs_vnop_reclaim.  hfs_update, by definition, is not necessary if the cnode's catalog
 * entry is no longer there.  
 *
 * 'reclaim' argument specifies whether or not we were called from hfs_vnop_reclaim.  If we are
 * invoked from hfs_vnop_reclaim, we can not call functions that cluster_push since the UBC info 
 * is totally gone by that point.
 *
 * Assumes that both truncate and cnode locks for 'cp' are held.
 */</span>
<span class="enscript-type">static</span> 
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_cnode_teardown</span> (<span class="enscript-type">struct</span> vnode *vp, vfs_context_t ctx, <span class="enscript-type">int</span> reclaim) 
{
	<span class="enscript-type">int</span> forkcount = 0;
	<span class="enscript-type">enum</span> vtype v_type;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">int</span> error = 0;
	bool started_tr = false;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ctx);
	<span class="enscript-type">int</span> truncated = 0;
    cat_cookie_t cookie;
    <span class="enscript-type">int</span> cat_reserve = 0;
    <span class="enscript-type">int</span> lockflags;
	<span class="enscript-type">int</span> ea_error = 0;
	
	v_type = vnode_vtype(vp);
	cp = VTOC(vp);
	
	<span class="enscript-keyword">if</span> (cp-&gt;c_datafork) {
		++forkcount;
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork) {
		++forkcount;
	}

	<span class="enscript-comment">/* 
	 * Push file data out for normal files that haven't been evicted from 
	 * the namespace.  We only do this if this function was not called from reclaim,
	 * because by that point the UBC information has been totally torn down.  
	 * 
	 * There should also be no way that a normal file that has NOT been deleted from 
	 * the namespace to skip INACTIVE and go straight to RECLAIM.  That race only happens
	 * when the file becomes open-unlinked. 
	 */</span>
	<span class="enscript-keyword">if</span> ((v_type == VREG) &amp;&amp; 
		(!ISSET(cp-&gt;c_flag, C_DELETED)) &amp;&amp; 
		(!ISSET(cp-&gt;c_flag, C_NOEXISTS)) &amp;&amp;
		(VTOF(vp)-&gt;ff_blocks) &amp;&amp;
		(reclaim == 0)) {
		<span class="enscript-comment">/* 
		 * If we're called from hfs_vnop_inactive, all this means is at the time
		 * the logic for deciding to call this function, there were not any lingering
		 * mmap/fd references for this file.  However, there is nothing preventing the system
		 * from creating a new reference in between the time that logic was checked
		 * and we entered hfs_vnop_inactive.  As a result, the only time we can guarantee
		 * that there aren't any references is during vnop_reclaim.
		 */</span>
		hfs_filedone(vp, ctx, 0);
	}

	<span class="enscript-comment">/* 
	 * Remove any directory hints or cached origins
	 */</span>
	<span class="enscript-keyword">if</span> (v_type == VDIR) {
		hfs_reldirhints(cp, 0);
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_HARDLINK) {
		hfs_relorigins(cp);
	}

	<span class="enscript-comment">/*
	 * -- Handle open unlinked files --
	 *
	 * If the vnode is in use, it means a force unmount is in progress
	 * in which case we defer cleaning up until either we come back
	 * through here via hfs_vnop_reclaim, at which point the UBC
	 * information will have been torn down and the vnode might no
	 * longer be in use, or if it's still in use, it will get cleaned
	 * up when next remounted.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_flag, C_DELETED) &amp;&amp; !vnode_isinuse(vp, 0)) {
		<span class="enscript-comment">/*
		 * This check is slightly complicated.  We should only truncate data 
		 * in very specific cases for open-unlinked files.  This is because
		 * we want to ensure that the resource fork continues to be available
		 * if the caller has the data fork open.  However, this is not symmetric; 
		 * someone who has the resource fork open need not be able to access the data
		 * fork once the data fork has gone inactive.
		 * 
		 * If we're the last fork, then we have cleaning up to do.
		 * 
		 * A) last fork, and vp == c_vp
		 *	Truncate away own fork data. If rsrc fork is not in core, truncate it too.
		 *
		 * B) last fork, and vp == c_rsrc_vp
		 *	Truncate ourselves, assume data fork has been cleaned due to C).
		 *
		 * If we're not the last fork, then things are a little different:
		 *
		 * C) not the last fork, vp == c_vp
		 *	Truncate ourselves.  Once the file has gone out of the namespace,
		 *	it cannot be further opened.  Further access to the rsrc fork may 
		 *	continue, however.
		 *
		 * D) not the last fork, vp == c_rsrc_vp
		 *	Don't enter the block below, just clean up vnode and push it out of core.
		 */</span>
	
		<span class="enscript-keyword">if</span> ((v_type == VREG || v_type == VLNK) &amp;&amp; 
				((forkcount == 1) || (!VNODE_IS_RSRC(vp)))) {
				
			<span class="enscript-comment">/* Truncate away our own fork data. (Case A, B, C above) */</span>
			<span class="enscript-keyword">if</span> (VTOF(vp)-&gt;ff_blocks != 0) {
				<span class="enscript-comment">/*
				 * SYMLINKS only:
				 *
				 * Encapsulate the entire change (including truncating the link) in 
				 * nested transactions if we are modifying a symlink, because we know that its
				 * file length will be at most 4k, and we can fit both the truncation and 
				 * any relevant bitmap changes into a single journal transaction.  We also want
				 * the kill_block code to execute in the same transaction so that any dirty symlink
				 * blocks will not be written. Otherwise, rely on
				 * hfs_truncate doing its own transactions to ensure that we don't blow up
				 * the journal.
				 */</span> 
				<span class="enscript-keyword">if</span> (!started_tr &amp;&amp; (v_type == VLNK)) {
					<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
						error = EINVAL;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
					}
					<span class="enscript-keyword">else</span> {
						started_tr = true;
					}
				}

				<span class="enscript-comment">/*
				 * At this point, we have decided that this cnode is
				 * suitable for full removal.  We are about to deallocate
				 * its blocks and remove its entry from the catalog. 
				 * If it was a symlink, then it's possible that the operation
				 * which created it is still in the current transaction group
				 * due to coalescing.  Take action here to kill the data blocks
				 * of the symlink out of the journal before moving to 
				 * deallocate the blocks.  We need to be in the middle of
				 * a transaction before calling buf_iterate like this.
				 * 
				 * Note: we have to kill any potential symlink buffers out of 
				 * the journal prior to deallocating their blocks.  This is so 
				 * that we don't race with another thread that may be doing an 
				 * an allocation concurrently and pick up these blocks. It could
				 * generate I/O against them which could go out ahead of our journal
				 * transaction.
				 */</span>

				<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; vnode_islnk(vp)) {
					buf_iterate(vp, hfs_removefile_callback, BUF_SKIP_NONLOCKED, (<span class="enscript-type">void</span> *)hfsmp);
				}


				<span class="enscript-comment">/*
				 * This truncate call (and the one below) is fine from VNOP_RECLAIM's 
				 * context because we're only removing blocks, not zero-filling new 
				 * ones.  The C_DELETED check above makes things much simpler. 
				 */</span>
				error = hfs_truncate(vp, (off_t)0, IO_NDELAY, 0, ctx);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				truncated = 1;

				<span class="enscript-comment">/* (SYMLINKS ONLY): Close/End our transaction after truncating the file record */</span>
				<span class="enscript-keyword">if</span> (started_tr) {
					hfs_end_transaction(hfsmp);
					started_tr = false;
				}

			}
			
			<span class="enscript-comment">/* 
			 * Truncate away the resource fork, if we represent the data fork and
			 * it is the last fork.  That means, by definition, the rsrc fork is not in 
			 * core.  To avoid bringing a vnode into core for the sole purpose of deleting the
			 * data in the resource fork, we call cat_lookup directly, then hfs_release_storage
			 * to get rid of the resource fork's data. Note that because we are holding the 
			 * cnode lock, it is impossible for a competing thread to create the resource fork
			 * vnode from underneath us while we do this.
			 * 
			 * This is invoked via case A above only.
			 */</span>
			<span class="enscript-keyword">if</span> ((cp-&gt;c_blocks &gt; 0) &amp;&amp; (forkcount == 1) &amp;&amp; (vp != cp-&gt;c_rsrc_vp)) {
				<span class="enscript-type">struct</span> cat_lookup_buffer *lookup_rsrc = NULL;
				<span class="enscript-type">struct</span> cat_desc *desc_ptr = NULL;
				lockflags = 0;

				MALLOC(lookup_rsrc, <span class="enscript-type">struct</span> cat_lookup_buffer*, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cat_lookup_buffer), M_TEMP, M_WAITOK);
				<span class="enscript-keyword">if</span> (lookup_rsrc == NULL) {
					printf(<span class="enscript-string">&quot;hfs_cnode_teardown: ENOMEM from MALLOC\n&quot;</span>);
					error = ENOMEM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				<span class="enscript-keyword">else</span> {
					bzero (lookup_rsrc, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cat_lookup_buffer));
				}

				<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_namelen == 0) {
					<span class="enscript-comment">/* Initialize the rsrc descriptor for lookup if necessary*/</span>
					MAKE_DELETED_NAME (lookup_rsrc-&gt;lookup_name, HFS_TEMPLOOKUP_NAMELEN, cp-&gt;c_fileid);
					
					lookup_rsrc-&gt;lookup_desc.cd_nameptr = (<span class="enscript-type">const</span> uint8_t*) lookup_rsrc-&gt;lookup_name;
					lookup_rsrc-&gt;lookup_desc.cd_namelen = strlen (lookup_rsrc-&gt;lookup_name);
					lookup_rsrc-&gt;lookup_desc.cd_parentcnid = hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS].cd_cnid;
					lookup_rsrc-&gt;lookup_desc.cd_cnid = cp-&gt;c_cnid;	
					
					desc_ptr = &amp;lookup_rsrc-&gt;lookup_desc;
				}
				<span class="enscript-keyword">else</span> {
					desc_ptr = &amp;cp-&gt;c_desc;	
				}

				lockflags = hfs_systemfile_lock (hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

				error = cat_lookup (hfsmp, desc_ptr, 1, 0, (<span class="enscript-type">struct</span> cat_desc *) NULL, 
						(<span class="enscript-type">struct</span> cat_attr*) NULL, &amp;lookup_rsrc-&gt;lookup_fork.ff_data, NULL);

				hfs_systemfile_unlock (hfsmp, lockflags);
				
				<span class="enscript-keyword">if</span> (error) {
					FREE (lookup_rsrc, M_TEMP);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}

				<span class="enscript-comment">/*
				 * Make the filefork in our temporary struct look like a real 
				 * filefork.  Fill in the cp, sysfileinfo and rangelist fields..
				 */</span>
				rl_init (&amp;lookup_rsrc-&gt;lookup_fork.ff_invalidranges);
				lookup_rsrc-&gt;lookup_fork.ff_cp = cp;

				<span class="enscript-comment">/* 
				 * If there were no errors, then we have the catalog's fork information 
				 * for the resource fork in question.  Go ahead and delete the data in it now.
				 */</span>

				error = hfs_release_storage (hfsmp, NULL, &amp;lookup_rsrc-&gt;lookup_fork, cp-&gt;c_fileid);
				FREE(lookup_rsrc, M_TEMP);

				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}

				<span class="enscript-comment">/*
				 * This fileid's resource fork extents have now been fully deleted on-disk
				 * and this CNID is no longer valid. At this point, we should be able to
				 * zero out cp-&gt;c_blocks to indicate there is no data left in this file.
				 */</span>
				cp-&gt;c_blocks = 0;
			}
		}

		<span class="enscript-comment">/*
		 * If we represent the last fork (or none in the case of a dir), 
		 * and the cnode has become open-unlinked...
		 *
		 * We check c_blocks here because it is possible in the force
		 * unmount case for the data fork to be in use but the resource
		 * fork to not be in use in which case we will truncate the 
		 * resource fork, but not the data fork.  It will get cleaned
		 * up upon next mount.
		 */</span>
		<span class="enscript-keyword">if</span> (forkcount &lt;= 1 &amp;&amp; !cp-&gt;c_blocks) {
			<span class="enscript-comment">/*
			 * If it has EA's, then we need to get rid of them.
			 *
			 * Note that this must happen outside of any other transactions
			 * because it starts/ends its own transactions and grabs its
			 * own locks.  This is to prevent a file with a lot of attributes
			 * from creating a transaction that is too large (which panics).
			 */</span>
			<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_attr.ca_recflags, kHFSHasAttributesMask))
				ea_error = hfs_removeallattr(hfsmp, cp-&gt;c_fileid, &amp;started_tr);

			<span class="enscript-comment">/*
			 * Remove the cnode's catalog entry and release all blocks it
			 * may have been using.
			 */</span>

			<span class="enscript-comment">/*
			 * Mark cnode in transit so that no one can get this 
			 * cnode from cnode hash.
			 */</span>
			<span class="enscript-comment">// hfs_chash_mark_in_transit(hfsmp, cp);
</span>			<span class="enscript-comment">// XXXdbg - remove the cnode from the hash table since it's deleted
</span>			<span class="enscript-comment">//          otherwise someone could go to sleep on the cnode and not
</span>			<span class="enscript-comment">//          be woken up until this vnode gets recycled which could be
</span>			<span class="enscript-comment">//          a very long time...
</span>			hfs_chashremove(hfsmp, cp);
			
			cp-&gt;c_flag |= C_NOEXISTS;   <span class="enscript-comment">// XXXdbg
</span>			cp-&gt;c_rdev = 0;
			
			<span class="enscript-keyword">if</span> (!started_tr) {
				<span class="enscript-keyword">if</span> (hfs_start_transaction(hfsmp) != 0) {
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				started_tr = true;
			}
			
			<span class="enscript-comment">/*
			 * Reserve some space in the Catalog file.
			 */</span>
			<span class="enscript-keyword">if</span> ((error = cat_preflight(hfsmp, CAT_DELETE, &amp;cookie, p))) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			cat_reserve = 1;
			
			lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG | SFL_ATTRIBUTE, HFS_EXCLUSIVE_LOCK);
			
			<span class="enscript-keyword">if</span> (cp-&gt;c_blocks &gt; 0) {
				printf(<span class="enscript-string">&quot;hfs_inactive: deleting non-empty%sfile %d, &quot;</span>
					   <span class="enscript-string">&quot;blks %d\n&quot;</span>, VNODE_IS_RSRC(vp) ? <span class="enscript-string">&quot; rsrc &quot;</span> : <span class="enscript-string">&quot; &quot;</span>,
					   (<span class="enscript-type">int</span>)cp-&gt;c_fileid, (<span class="enscript-type">int</span>)cp-&gt;c_blocks);
			}
			
			<span class="enscript-comment">//
</span>			<span class="enscript-comment">// release the name pointer in the descriptor so that
</span>			<span class="enscript-comment">// cat_delete() will use the file-id to do the deletion.
</span>			<span class="enscript-comment">// in the case of hard links this is imperative (in the
</span>			<span class="enscript-comment">// case of regular files the fileid and cnid are the
</span>			<span class="enscript-comment">// same so it doesn't matter).
</span>			<span class="enscript-comment">//
</span>			cat_releasedesc(&amp;cp-&gt;c_desc);
			
			<span class="enscript-comment">/*
			 * The descriptor name may be zero,
			 * in which case the fileid is used.
			 */</span>
			error = cat_delete(hfsmp, &amp;cp-&gt;c_desc, &amp;cp-&gt;c_attr);
			
			<span class="enscript-keyword">if</span> (error &amp;&amp; truncated &amp;&amp; (error != ENXIO)) {
				printf(<span class="enscript-string">&quot;hfs_inactive: couldn't delete a truncated file!&quot;</span>);
			}
			
			<span class="enscript-comment">/* Update HFS Private Data dir */</span>
			<span class="enscript-keyword">if</span> (error == 0) {
				hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS].ca_entries--;
				<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
					DEC_FOLDERCOUNT(hfsmp, hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS]);
				}
				(<span class="enscript-type">void</span>)cat_update(hfsmp, &amp;hfsmp-&gt;hfs_private_desc[FILE_HARDLINKS],
								 &amp;hfsmp-&gt;hfs_private_attr[FILE_HARDLINKS], NULL, NULL);
			}
			
			hfs_systemfile_unlock(hfsmp, lockflags);
			
			<span class="enscript-keyword">if</span> (error) {			
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			
	#<span class="enscript-keyword">if</span> QUOTA
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS)
				(<span class="enscript-type">void</span>)hfs_chkiq(cp, -1, NOCRED, 0);
	#endif <span class="enscript-comment">/* QUOTA */</span>
			
			<span class="enscript-comment">/* Already set C_NOEXISTS at the beginning of this block */</span>
			cp-&gt;c_flag &amp;= ~C_DELETED;
			cp-&gt;c_touch_chgtime = TRUE;
			cp-&gt;c_touch_modtime = TRUE;
			
			<span class="enscript-keyword">if</span> (error == 0)
				hfs_volupdate(hfsmp, (v_type == VDIR) ? VOL_RMDIR : VOL_RMFILE, 0);
		}
	} <span class="enscript-comment">// if &lt;open unlinked&gt;
</span>
	hfs_update(vp, reclaim ? HFS_UPDATE_FORCE : 0);

	<span class="enscript-comment">/*
	 * Since we are about to finish what might be an inactive call, propagate
	 * any remaining modified or touch bits from the cnode to the vnode.  This
	 * serves as a hint to vnode recycling that we shouldn't recycle this vnode
	 * synchronously.
	 *
	 * For now, if the node *only* has a dirty atime, we don't mark
	 * the vnode as dirty.  VFS's asynchronous recycling can actually
	 * lead to worse performance than having it synchronous.  When VFS
	 * is fixed to be more performant, we can be more honest about
	 * marking vnodes as dirty when it's only the atime that's dirty.
	 */</span>
	<span class="enscript-keyword">if</span> (hfs_is_dirty(cp) == HFS_DIRTY || ISSET(cp-&gt;c_flag, C_DELETED)) {
		vnode_setdirty(vp);
	} <span class="enscript-keyword">else</span> {
		vnode_cleardirty(vp);
	}
        
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (cat_reserve)
        cat_postflight(hfsmp, &amp;cookie, p);
	
    <span class="enscript-keyword">if</span> (started_tr) {
        hfs_end_transaction(hfsmp);
        started_tr = false;
    }

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * hfs_vnop_inactive
 *
 * The last usecount on the vnode has gone away, so we need to tear down
 * any remaining data still residing in the cnode.  If necessary, write out
 * remaining blocks or delete the cnode's entry in the catalog.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_inactive</span>(<span class="enscript-type">struct</span> vnop_inactive_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> took_trunc_lock = 0;
	<span class="enscript-type">enum</span> vtype v_type;
	
	v_type = vnode_vtype(vp);
	cp = VTOC(vp);

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) || vnode_issystem(vp) ||
	    (hfsmp-&gt;hfs_freezing_proc == p)) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">inactive_done</span>;
	}	
	
	<span class="enscript-comment">/*
	 * For safety, do NOT call vnode_recycle from inside this function.  This can cause 
	 * problems in the following scenario:
	 * 
	 * vnode_create -&gt; vnode_reclaim_internal -&gt; vclean -&gt; VNOP_INACTIVE
	 * 
	 * If we're being invoked as a result of a reclaim that was already in-flight, then we
	 * cannot call vnode_recycle again.  Being in reclaim means that there are no usecounts or
	 * iocounts by definition.  As a result, if we were to call vnode_recycle, it would immediately
	 * try to re-enter reclaim again and panic.  
	 *
	 * Currently, there are three things that can cause us (VNOP_INACTIVE) to get called.
	 * 1) last usecount goes away on the vnode (vnode_rele)
	 * 2) last iocount goes away on a vnode that previously had usecounts but didn't have 
	 * 		vnode_recycle called (vnode_put)
	 * 3) vclean by way of reclaim
	 *
	 * In this function we would generally want to call vnode_recycle to speed things 
	 * along to ensure that we don't leak blocks due to open-unlinked files.  However, by 
	 * virtue of being in this function already, we can call hfs_cnode_teardown, which 
	 * will release blocks held by open-unlinked files, and mark them C_NOEXISTS so that 
	 * there's no entry in the catalog and no backing store anymore.  If that's the case, 
	 * then we really don't care all that much when the vnode actually goes through reclaim.
	 * Further, the HFS VNOPs that manipulated the namespace in order to create the open-
	 * unlinked file in the first place should have already called vnode_recycle on the vnode
	 * to guarantee that it would go through reclaim in a speedy way.
	 */</span>
	
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NOEXISTS) {
		<span class="enscript-comment">/* 
		 * If the cnode has already had its cat entry removed, then 
		 * just skip to the end. We don't need to do anything here.
		 */</span>
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">inactive_done</span>;
	}
	
	<span class="enscript-keyword">if</span> ((v_type == VREG || v_type == VLNK)) {
		hfs_lock_truncate(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_DEFAULT);
		took_trunc_lock = 1;
	}
	
	(<span class="enscript-type">void</span>) hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);
	
	<span class="enscript-comment">/* 
	 * Call cnode_teardown to push out dirty blocks to disk, release open-unlinked
	 * files' blocks from being in use, and move the cnode from C_DELETED to C_NOEXISTS.
	 */</span>
	error = hfs_cnode_teardown (vp, ap-&gt;a_context, 0);

    <span class="enscript-comment">/*
     * Drop the truncate lock before unlocking the cnode
     * (which can potentially perform a vnode_put and
     * recycle the vnode which in turn might require the
     * truncate lock)
     */</span>
	<span class="enscript-keyword">if</span> (took_trunc_lock) {
	    hfs_unlock_truncate(cp, HFS_LOCK_DEFAULT);
	}

	hfs_unlock(cp);
	
<span class="enscript-reference">inactive_done</span>: 
	
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * File clean-up (zero fill and shrink peof).
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_filedone</span>(<span class="enscript-type">struct</span> vnode *vp, vfs_context_t context,
			 hfs_file_done_opts_t opts)
{
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp;
	<span class="enscript-type">struct</span> hfsmount *hfsmp;
	off_t leof;
	u_int32_t blks, blocksize;

	cp = VTOC(vp);
	fp = VTOF(vp);
	hfsmp = VTOHFS(vp);
	leof = fp-&gt;ff_size;

	<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) || (fp-&gt;ff_blocks == 0))
		<span class="enscript-keyword">return</span> (0);

	hfs_flush_invalid_ranges(vp);

	blocksize = VTOVCB(vp)-&gt;blockSize;
	blks = leof / blocksize;
	<span class="enscript-keyword">if</span> (((off_t)blks * (off_t)blocksize) != leof)
		blks++;
	<span class="enscript-comment">/*
	 * Shrink the peof to the smallest size neccessary to contain the leof.
	 */</span>
	<span class="enscript-keyword">if</span> (blks &lt; fp-&gt;ff_blocks) {
		(<span class="enscript-type">void</span>) hfs_truncate(vp, leof, IO_NDELAY, HFS_TRUNCATE_SKIPTIMES, context);
	}

	<span class="enscript-keyword">if</span> (!ISSET(opts, HFS_FILE_DONE_NO_SYNC)) {
		hfs_unlock(cp);
		cluster_push(vp, IO_CLOSE);
		hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

		<span class="enscript-comment">/*
		 * If the hfs_truncate didn't happen to flush the vnode's
		 * information out to disk, force it to be updated now that
		 * all invalid ranges have been zero-filled and validated:
		 */</span>
		hfs_update(vp, 0);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Reclaim a cnode so that it can be used for other purposes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_vnop_reclaim</span>(<span class="enscript-type">struct</span> vnop_reclaim_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> cnode *cp;
	<span class="enscript-type">struct</span> filefork *fp = NULL;
	<span class="enscript-type">struct</span> filefork *altfp = NULL;
	<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">int</span> reclaim_cnode = 0;
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">enum</span> vtype v_type;
	
	v_type = vnode_vtype(vp);
	cp = VTOC(vp);
	
	<span class="enscript-comment">/* 
	 * We don't take the truncate lock since by the time reclaim comes along,
	 * all dirty pages have been synced and nobody should be competing
	 * with us for this thread.
	 */</span>
	(<span class="enscript-type">void</span>) hfs_lock(cp, HFS_EXCLUSIVE_LOCK, HFS_LOCK_ALLOW_NOEXISTS);

	<span class="enscript-comment">/* 
	 * Sync to disk any remaining data in the cnode/vnode.  This includes
	 * a call to hfs_update if the cnode has outbound data.
	 * 
	 * If C_NOEXISTS is set on the cnode, then there's nothing teardown needs to do
	 * because the catalog entry for this cnode is already gone.
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(cp-&gt;c_flag, C_NOEXISTS)) {
		err = hfs_cnode_teardown(vp, ctx, 1);
	}

	<span class="enscript-comment">/*
	 * Keep track of an inactive hot file.  Don't bother on ssd's since
	 * the tracking is done differently (it's done at read() time)
	 */</span>
	<span class="enscript-keyword">if</span> (!vnode_isdir(vp) &amp;&amp;
	    !vnode_issystem(vp) &amp;&amp;
	    !(cp-&gt;c_flag &amp; (C_DELETED | C_NOEXISTS)) &amp;&amp;
	    !(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) {
  		(<span class="enscript-type">void</span>) hfs_addhotfile(vp);
	}
	vnode_removefsref(vp);

	<span class="enscript-comment">/*
	 * Find file fork for this vnode (if any)
	 * Also check if another fork is active
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_vp == vp) {
	        fp = cp-&gt;c_datafork;
		altfp = cp-&gt;c_rsrcfork;

		cp-&gt;c_datafork = NULL;
		cp-&gt;c_vp = NULL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp == vp) {
	        fp = cp-&gt;c_rsrcfork;
		altfp = cp-&gt;c_datafork;

		cp-&gt;c_rsrcfork = NULL;
		cp-&gt;c_rsrc_vp = NULL;
	} <span class="enscript-keyword">else</span> {
	        panic(<span class="enscript-string">&quot;hfs_vnop_reclaim: vp points to wrong cnode (vp=%p cp-&gt;c_vp=%p cp-&gt;c_rsrc_vp=%p)\n&quot;</span>, vp, cp-&gt;c_vp, cp-&gt;c_rsrc_vp);
	}
	<span class="enscript-comment">/*
	 * On the last fork, remove the cnode from its hash chain.
	 */</span>
	<span class="enscript-keyword">if</span> (altfp == NULL) {
		<span class="enscript-comment">/* If we can't remove it then the cnode must persist! */</span>
		<span class="enscript-keyword">if</span> (hfs_chashremove(hfsmp, cp) == 0)
			reclaim_cnode = 1;
		<span class="enscript-comment">/* 
		 * Remove any directory hints
		 */</span>
		<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
			hfs_reldirhints(cp, 0);
		}
		
		<span class="enscript-keyword">if</span>(cp-&gt;c_flag &amp; C_HARDLINK) {
			hfs_relorigins(cp);
		}
	}
	<span class="enscript-comment">/* Release the file fork and related data */</span>
	<span class="enscript-keyword">if</span> (fp) {
		<span class="enscript-comment">/* Dump cached symlink data */</span>
		<span class="enscript-keyword">if</span> (vnode_islnk(vp) &amp;&amp; (fp-&gt;ff_symlinkptr != NULL)) {
			FREE(fp-&gt;ff_symlinkptr, M_TEMP);
		}
		rl_remove_all(&amp;fp-&gt;ff_invalidranges);
		FREE_ZONE(fp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
	}

	<span class="enscript-comment">/* 
	 * If there was only one active fork then we can release the cnode.
	 */</span>
	<span class="enscript-keyword">if</span> (reclaim_cnode) {
		hfs_chashwakeup(hfsmp, cp, H_ALLOC | H_TRANSIT);
		hfs_unlock(cp);
		hfs_reclaim_cnode(hfsmp, cp);
	} 
	<span class="enscript-keyword">else</span>  {
		<span class="enscript-comment">/* 
		 * cnode in use.  If it is a directory, it could have 
		 * no live forks. Just release the lock.
		 */</span>
		hfs_unlock(cp);
	}

	vnode_clearfsnode(vp);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**hfs_vnodeop_p) (<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**hfs_specop_p)  (<span class="enscript-type">void</span> *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**hfs_fifoop_p)  (<span class="enscript-type">void</span> *);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (**hfs_std_vnodeop_p) (<span class="enscript-type">void</span> *);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * hfs_getnewvnode - get new default vnode
 *
 * The vnode is returned with an iocount and the cnode locked.  
 * The cnode of the parent vnode 'dvp' may or may not be locked, depending on 
 * the circumstances.   The cnode in question (if acquiring the resource fork),
 * may also already be locked at the time we enter this function.
 *
 * Note that there are both input and output flag arguments to this function.  
 * If one of the input flags (specifically, GNV_USE_VP), is set, then 
 * hfs_getnewvnode will use the parameter *vpp, which is traditionally only 
 * an output parameter, as both an input and output parameter.  It will use 
 * the vnode provided in the output, and pass it to vnode_create with the 
 * proper flavor so that a new vnode is _NOT_ created on our behalf when 
 * we dispatch to VFS.  This may be important in various HFS vnode creation
 * routines, such a create or get-resource-fork, because we risk deadlock if
 * jetsam is involved.
 *
 * Deadlock potential exists if jetsam is synchronously invoked while we are waiting
 * for a vnode to be recycled in order to give it the identity we want.  If jetsam
 * happens to target a process for termination that is blocked in-kernel, waiting to 
 * acquire the cnode lock on our parent 'dvp', while our current thread has it locked, 
 * neither side will make forward progress and the watchdog timer will eventually fire. 
 * To prevent this, a caller of hfs_getnewvnode may choose to proactively force 
 * any necessary vnode reclamation/recycling while it is not holding any locks and 
 * thus not prone to deadlock.  If this is the case, GNV_USE_VP will be set and
 * the parameter will be used as described above. 
 *
 *  !!! &lt;NOTE&gt; !!!!
 * In circumstances when GNV_USE_VP is set, this function _MUST_ clean up and either consume
 * or dispose of the provided vnode. We funnel all errors to a single return value so that
 * if provided_vp is still non-NULL, then we will dispose of the vnode. This will occur in
 * all error cases of this function --  anywhere we zero/NULL out the *vpp parameter. It may 
 * also occur if the current thread raced with another to create the same vnode, and we 
 * find the entry already present in the cnode hash.
 * !!! &lt;/NOTE&gt; !!!
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_getnewvnode</span>(
	<span class="enscript-type">struct</span> hfsmount *hfsmp,
	<span class="enscript-type">struct</span> vnode *dvp,
	<span class="enscript-type">struct</span> componentname *cnp,
	<span class="enscript-type">struct</span> cat_desc *descp,
	<span class="enscript-type">int</span> flags,
	<span class="enscript-type">struct</span> cat_attr *attrp,
	<span class="enscript-type">struct</span> cat_fork *forkp,
	<span class="enscript-type">struct</span> vnode **vpp,
	<span class="enscript-type">int</span> *out_flags)
{
	<span class="enscript-type">struct</span> mount *mp = HFSTOVFS(hfsmp);
	<span class="enscript-type">struct</span> vnode *vp = NULL;
	<span class="enscript-type">struct</span> vnode **cvpp;
	<span class="enscript-type">struct</span> vnode *tvp = NULLVP;
	<span class="enscript-type">struct</span> cnode *cp = NULL;
	<span class="enscript-type">struct</span> filefork *fp = NULL;
	<span class="enscript-type">int</span> hfs_standard = 0;
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> issystemfile;
	<span class="enscript-type">int</span> wantrsrc;
	<span class="enscript-type">int</span> hflags = 0;
	<span class="enscript-type">int</span> need_update_identity = 0;
	<span class="enscript-type">struct</span> vnode_fsparam vfsp;
	<span class="enscript-type">enum</span> vtype vtype;

	<span class="enscript-type">struct</span> vnode *provided_vp = NULL;


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> i;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
	
	hfs_standard = (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD);

	<span class="enscript-keyword">if</span> (flags &amp; GNV_USE_VP) {
		<span class="enscript-comment">/* Store the provided VP for later use */</span>
		provided_vp = *vpp;
	}

	<span class="enscript-comment">/* Zero out the vpp regardless of provided input */</span>
	*vpp = NULL;

	<span class="enscript-comment">/* Zero out the out_flags */</span>
	*out_flags = 0;

	<span class="enscript-keyword">if</span> (attrp-&gt;ca_fileid == 0) {
		retval = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">FIFO</span>
	<span class="enscript-keyword">if</span> (IFTOVT(attrp-&gt;ca_mode) == VFIFO) {
		retval = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !FIFO */</span>
	vtype = IFTOVT(attrp-&gt;ca_mode);
	issystemfile = (descp-&gt;cd_flags &amp; CD_ISMETA) &amp;&amp; (vtype == VREG);
	wantrsrc = flags &amp; GNV_WANTRSRC;

	<span class="enscript-comment">/* Sanity check the vtype and mode */</span>
	<span class="enscript-keyword">if</span> (vtype == VBAD) {
		<span class="enscript-comment">/* Mark the FS as corrupt and bail out */</span>
		hfs_mark_inconsistent(hfsmp, HFS_INCONSISTENCY_DETECTED);
		retval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}
	
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
	<span class="enscript-comment">/*
	 * The only case where it's permissible to hold the parent cnode
	 * lock is during a create operation (hfs_makenode) or when
	 * we don't need the cnode lock (GNV_SKIPLOCK).
	 */</span>
	<span class="enscript-keyword">if</span> ((dvp != NULL) &amp;&amp;
	    (flags &amp; (GNV_CREATE | GNV_SKIPLOCK)) == 0 &amp;&amp;
	    VTOC(dvp)-&gt;c_lockowner == current_thread()) {
		panic(<span class="enscript-string">&quot;hfs_getnewvnode: unexpected hold of parent cnode %p&quot;</span>, VTOC(dvp));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>

	<span class="enscript-comment">/*
	 * Get a cnode (new or existing)
	 */</span>
	cp = hfs_chash_getcnode(hfsmp, attrp-&gt;ca_fileid, vpp, wantrsrc, 
							(flags &amp; GNV_SKIPLOCK), out_flags, &amp;hflags);

	<span class="enscript-comment">/*
	 * If the id is no longer valid for lookups we'll get back a NULL cp.
	 */</span>
	<span class="enscript-keyword">if</span> (cp == NULL) {
		retval = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}
	<span class="enscript-comment">/*
	 * We may have been provided a vnode via 
	 * GNV_USE_VP.  In this case, we have raced with
	 * a 2nd thread to create the target vnode. The provided
	 * vnode that was passed in will be dealt with at the 
	 * end of the function, as we don't zero out the field
	 * until we're ready to pass responsibility to VFS. 
	 */</span>


	<span class="enscript-comment">/* 
	 * If we get a cnode/vnode pair out of hfs_chash_getcnode, then update the 
	 * descriptor in the cnode as needed if the cnode represents a hardlink.  
	 * We want the caller to get the most up-to-date copy of the descriptor
	 * as possible. However, we only do anything here if there was a valid vnode.
	 * If there isn't a vnode, then the cnode is brand new and needs to be initialized
	 * as it doesn't have a descriptor or cat_attr yet.
	 * 
	 * If we are about to replace the descriptor with the user-supplied one, then validate
	 * that the descriptor correctly acknowledges this item is a hardlink.  We could be
	 * subject to a race where the calling thread invoked cat_lookup, got a valid lookup 
	 * result but the file was not yet a hardlink. With sufficient delay between there
	 * and here, we might accidentally copy in the raw inode ID into the descriptor in the
	 * call below.  If the descriptor's CNID is the same as the fileID then it must
	 * not yet have been a hardlink when the lookup occurred.
	 */</span>
	
	<span class="enscript-keyword">if</span> (!(hfs_checkdeleted(cp))) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// If the bytes of the filename in the descp do not match the bytes in the
</span>		<span class="enscript-comment">// cnp (and we're not looking up the resource fork), then we want to update
</span>		<span class="enscript-comment">// the vnode identity to contain the bytes that HFS stores so that when an
</span>		<span class="enscript-comment">// fsevent gets generated, it has the correct filename.  otherwise daemons
</span>		<span class="enscript-comment">// that match filenames produced by fsevents with filenames they have stored
</span>		<span class="enscript-comment">// elsewhere (e.g. bladerunner, backupd, mds), the filenames will not match.
</span>		<span class="enscript-comment">// See: &lt;rdar://problem/8044697&gt; FSEvents doesn't always decompose diacritical unicode chars in the paths of the changed directories
</span>		<span class="enscript-comment">// for more details.
</span>		<span class="enscript-comment">//
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CN_WANTSRSRCFORK</span>
		<span class="enscript-keyword">if</span> (*vpp &amp;&amp; cnp &amp;&amp; cnp-&gt;cn_nameptr &amp;&amp; !(cnp-&gt;cn_flags &amp; CN_WANTSRSRCFORK) &amp;&amp; descp &amp;&amp; descp-&gt;cd_nameptr &amp;&amp; strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cnp-&gt;cn_nameptr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)descp-&gt;cd_nameptr, descp-&gt;cd_namelen) != 0) {
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (*vpp &amp;&amp; cnp &amp;&amp; cnp-&gt;cn_nameptr &amp;&amp; descp &amp;&amp; descp-&gt;cd_nameptr &amp;&amp; strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cnp-&gt;cn_nameptr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)descp-&gt;cd_nameptr, descp-&gt;cd_namelen) != 0) {
#<span class="enscript-reference">endif</span>
			vnode_update_identity (*vpp, dvp, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)descp-&gt;cd_nameptr, descp-&gt;cd_namelen, 0, VNODE_UPDATE_NAME);
		}
		<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_HARDLINK) &amp;&amp; descp-&gt;cd_nameptr &amp;&amp; descp-&gt;cd_namelen &gt; 0) {
			<span class="enscript-comment">/* If cnode is uninitialized, its c_attr will be zeroed out; cnids wont match. */</span>
			<span class="enscript-keyword">if</span> ((descp-&gt;cd_cnid == cp-&gt;c_attr.ca_fileid)  &amp;&amp;
					(attrp-&gt;ca_linkcount != cp-&gt;c_attr.ca_linkcount)){
				
				<span class="enscript-keyword">if</span> ((flags &amp; GNV_SKIPLOCK) == 0) {
					<span class="enscript-comment">/* 
					 * Then we took the lock. Drop it before calling
					 * vnode_put, which may invoke hfs_vnop_inactive and need to take 
					 * the cnode lock again.
					 */</span>
					hfs_unlock(cp);
				}
				
				<span class="enscript-comment">/* 
				 * Emit ERECYCLE and GNV_CAT_ATTRCHANGED to 
				 * force a re-drive in the lookup routine.  
				 * Drop the iocount on the vnode obtained from 
				 * chash_getcnode if needed. 
				 */</span>	
				<span class="enscript-keyword">if</span> (*vpp != NULL) {
					vnode_put (*vpp);
					*vpp = NULL;
				}
				
				<span class="enscript-comment">/*
				 * If we raced with VNOP_RECLAIM for this vnode, the hash code could
				 * have observed it after the c_vp or c_rsrc_vp fields had been torn down;
				 * the hash code peeks at those fields without holding the cnode lock because
				 * it needs to be fast.  As a result, we may have set H_ATTACH in the chash
				 * call above.  Since we're bailing out, unset whatever flags we just set, and
				 * wake up all waiters for this cnode.
				 */</span>
				<span class="enscript-keyword">if</span> (hflags) {
					hfs_chashwakeup(hfsmp, cp, hflags);
				}
				
				*out_flags = GNV_CAT_ATTRCHANGED;
				retval = ERECYCLE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * Otherwise, CNID != fileid. Go ahead and copy in the new descriptor. 
				 *
				 * Replacing the descriptor here is fine because we looked up the item without
				 * a vnode in hand before.  If a vnode existed, its identity must be attached to this
				 * item.  We are not susceptible to the lookup fastpath issue at this point.
				 */</span>
				replace_desc(cp, descp);

				<span class="enscript-comment">/*
				 * This item was a hardlink, and its name needed to be updated. By replacing the 
				 * descriptor above, we've now updated the cnode's internal representation of
				 * its link ID/CNID, parent ID, and its name.  However, VFS must now be alerted
				 * to the fact that this vnode now has a new parent, since we cannot guarantee
				 * that the new link lived in the same directory as the alternative name for
				 * this item.  
				 */</span>
				<span class="enscript-keyword">if</span> ((*vpp != NULL) &amp;&amp; (cnp || cp-&gt;c_desc.cd_nameptr)) {
					<span class="enscript-comment">/* we could be requesting the rsrc of a hardlink file... */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CN_WANTSRSRCFORK</span>
					<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_nameptr &amp;&amp; (cnp == NULL || !(cnp-&gt;cn_flags &amp; CN_WANTSRSRCFORK))) {
#<span class="enscript-reference">else</span>
					<span class="enscript-keyword">if</span> (cp-&gt;c_desc.cd_nameptr) {
#<span class="enscript-reference">endif</span>
						<span class="enscript-comment">//
</span>						<span class="enscript-comment">// Update the identity with what we have stored on disk as
</span>						<span class="enscript-comment">// the name of this file.  This is related to:
</span>						<span class="enscript-comment">//    &lt;rdar://problem/8044697&gt; FSEvents doesn't always decompose diacritical unicode chars in the paths of the changed directories
</span>						<span class="enscript-comment">//
</span>						vnode_update_identity (*vpp, dvp, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr, cp-&gt;c_desc.cd_namelen, 0,
							       (VNODE_UPDATE_PARENT | VNODE_UPDATE_NAME));
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cnp) {
						vnode_update_identity (*vpp, dvp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, cnp-&gt;cn_hash,
								       (VNODE_UPDATE_PARENT | VNODE_UPDATE_NAME));
					}
				}
			}
		}
	}
	
	<span class="enscript-comment">/* 
	 * At this point, we have performed hardlink and open-unlinked checks
	 * above.  We have now validated the state of the vnode that was given back
	 * to us from the cnode hash code and find it safe to return. 
	 */</span>
	<span class="enscript-keyword">if</span> (*vpp != NULL) {
		retval = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}

	<span class="enscript-comment">/*
	 * If this is a new cnode then initialize it.
	 */</span>
	<span class="enscript-keyword">if</span> (ISSET(cp-&gt;c_hflag, H_ALLOC)) {
		lck_rw_init(&amp;cp-&gt;c_truncatelock, hfs_rwlock_group, hfs_lock_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		cp-&gt;c_decmp = NULL;
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* Make sure its still valid (ie exists on disk). */</span>
		<span class="enscript-keyword">if</span> (!(flags &amp; GNV_CREATE)) {
			<span class="enscript-type">int</span> error = 0;
			<span class="enscript-keyword">if</span> (!hfs_valid_cnode (hfsmp, dvp, (wantrsrc ? NULL : cnp), cp-&gt;c_fileid, attrp, &amp;error)) {
				hfs_chash_abort(hfsmp, cp);
				<span class="enscript-keyword">if</span> ((flags &amp; GNV_SKIPLOCK) == 0) {
					hfs_unlock(cp);
				}
				hfs_reclaim_cnode(hfsmp, cp);
				*vpp = NULL;
				<span class="enscript-comment">/* 
				 * If we hit this case, that means that the entry was there in the catalog when
				 * we did a cat_lookup earlier.  Think hfs_lookup.  However, in between the time
				 * that we checked the catalog and the time we went to get a vnode/cnode for it,
				 * it had been removed from the namespace and the vnode totally reclaimed.  As a result,
				 * it's not there in the catalog during the check in hfs_valid_cnode and we bubble out
				 * an ENOENT.  To indicate to the caller that they should really double-check the
				 * entry (it could have been renamed over and gotten a new fileid), we mark a bit
				 * in the output flags.
				 */</span>
				<span class="enscript-keyword">if</span> (error == ENOENT) {
					*out_flags = GNV_CAT_DELETED;
					retval = ENOENT;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
				}

				<span class="enscript-comment">/*
				 * Also, we need to protect the cat_attr acquired during hfs_lookup and passed into
				 * this function as an argument because the catalog may have changed w.r.t hardlink
				 * link counts and the firstlink field.  If that validation check fails, then let 
				 * lookup re-drive itself to get valid/consistent data with the same failure condition below.
				 */</span>
				<span class="enscript-keyword">if</span> (error == ERECYCLE) {
					*out_flags = GNV_CAT_ATTRCHANGED;
					retval = ERECYCLE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
				}
			}
		}
		bcopy(attrp, &amp;cp-&gt;c_attr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_attr));
		bcopy(descp, &amp;cp-&gt;c_desc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_desc));

		<span class="enscript-comment">/* The name was inherited so clear descriptor state... */</span>
		descp-&gt;cd_namelen = 0;
		descp-&gt;cd_nameptr = NULL;
		descp-&gt;cd_flags &amp;= ~CD_HASBUF;

		<span class="enscript-comment">/* Tag hardlinks */</span>
		<span class="enscript-keyword">if</span> ((vtype == VREG || vtype == VDIR
			 || vtype == VSOCK || vtype == VFIFO)
			&amp;&amp; (descp-&gt;cd_cnid != attrp-&gt;ca_fileid
				|| ISSET(attrp-&gt;ca_recflags, kHFSHasLinkChainMask))) {
			cp-&gt;c_flag |= C_HARDLINK;
		}
		<span class="enscript-comment">/*
		 * Fix-up dir link counts.
		 *
		 * Earlier versions of Leopard used ca_linkcount for posix
		 * nlink support (effectively the sub-directory count + 2).
		 * That is now accomplished using the ca_dircount field with
		 * the corresponding kHFSHasFolderCountMask flag.
		 *
		 * For directories the ca_linkcount is the true link count,
		 * tracking the number of actual hardlinks to a directory.
		 *
		 * We only do this if the mount has HFS_FOLDERCOUNT set;
		 * at the moment, we only set that for HFSX volumes.
		 */</span>
		<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_FOLDERCOUNT) &amp;&amp; 
		    (vtype == VDIR) &amp;&amp;
		    !(attrp-&gt;ca_recflags &amp; kHFSHasFolderCountMask) &amp;&amp;
		    (cp-&gt;c_attr.ca_linkcount &gt; 1)) {
			<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_entries == 0)
				cp-&gt;c_attr.ca_dircount = 0;
			<span class="enscript-keyword">else</span>
				cp-&gt;c_attr.ca_dircount = cp-&gt;c_attr.ca_linkcount - 2;

			cp-&gt;c_attr.ca_linkcount = 1;
			cp-&gt;c_attr.ca_recflags |= kHFSHasFolderCountMask;
			<span class="enscript-keyword">if</span> ( !(hfsmp-&gt;hfs_flags &amp; HFS_READ_ONLY) )
				cp-&gt;c_flag |= C_MODIFIED;
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
		<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_QUOTAS) {
			<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++)
				cp-&gt;c_dquot[i] = NODQUOT;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>
		<span class="enscript-comment">/* Mark the output flag that we're vending a new cnode */</span>
		*out_flags |= GNV_NEW_CNODE;
	}

	<span class="enscript-keyword">if</span> (vtype == VDIR) {
	        <span class="enscript-keyword">if</span> (cp-&gt;c_vp != NULL)
		        panic(<span class="enscript-string">&quot;hfs_getnewvnode: orphaned vnode (data)&quot;</span>);
		cvpp = &amp;cp-&gt;c_vp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (forkp &amp;&amp; attrp-&gt;ca_blocks &lt; forkp-&gt;cf_blocks)
			panic(<span class="enscript-string">&quot;hfs_getnewvnode: bad ca_blocks (too small)&quot;</span>);
		<span class="enscript-comment">/*
		 * Allocate and initialize a file fork...
		 */</span>
		MALLOC_ZONE(fp, <span class="enscript-type">struct</span> filefork *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork),
			M_HFSFORK, M_WAITOK);
		fp-&gt;ff_cp = cp;
		<span class="enscript-keyword">if</span> (forkp)
			bcopy(forkp, &amp;fp-&gt;ff_data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_fork));
		<span class="enscript-keyword">else</span>
			bzero(&amp;fp-&gt;ff_data, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cat_fork));
		rl_init(&amp;fp-&gt;ff_invalidranges);
		fp-&gt;ff_sysfileinfo = 0;

		<span class="enscript-keyword">if</span> (wantrsrc) {
			<span class="enscript-keyword">if</span> (cp-&gt;c_rsrcfork != NULL)
				panic(<span class="enscript-string">&quot;hfs_getnewvnode: orphaned rsrc fork&quot;</span>);
			<span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp != NULL)
			        panic(<span class="enscript-string">&quot;hfs_getnewvnode: orphaned vnode (rsrc)&quot;</span>);
			cp-&gt;c_rsrcfork = fp;
			cvpp = &amp;cp-&gt;c_rsrc_vp;
			<span class="enscript-keyword">if</span> ( (tvp = cp-&gt;c_vp) != NULLVP )
			        cp-&gt;c_flag |= C_NEED_DVNODE_PUT;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (cp-&gt;c_datafork != NULL)
				panic(<span class="enscript-string">&quot;hfs_getnewvnode: orphaned data fork&quot;</span>);
			<span class="enscript-keyword">if</span> (cp-&gt;c_vp != NULL)
			        panic(<span class="enscript-string">&quot;hfs_getnewvnode: orphaned vnode (data)&quot;</span>);
			cp-&gt;c_datafork = fp;
			cvpp = &amp;cp-&gt;c_vp;
			<span class="enscript-keyword">if</span> ( (tvp = cp-&gt;c_rsrc_vp) != NULLVP)
			        cp-&gt;c_flag |= C_NEED_RVNODE_PUT;
		}
	}
	<span class="enscript-keyword">if</span> (tvp != NULLVP) {
	        <span class="enscript-comment">/*
		 * grab an iocount on the vnode we weren't
		 * interested in (i.e. we want the resource fork
		 * but the cnode already has the data fork)
		 * to prevent it from being
		 * recycled by us when we call vnode_create
		 * which will result in a deadlock when we
		 * try to take the cnode lock in hfs_vnop_fsync or
		 * hfs_vnop_reclaim... vnode_get can be called here
		 * because we already hold the cnode lock which will
		 * prevent the vnode from changing identity until
		 * we drop it.. vnode_get will not block waiting for
		 * a change of state... however, it will return an
		 * error if the current iocount == 0 and we've already
		 * started to terminate the vnode... we don't need/want to
		 * grab an iocount in the case since we can't cause
		 * the fileystem to be re-entered on this thread for this vp
		 *
		 * the matching vnode_put will happen in hfs_unlock
		 * after we've dropped the cnode lock
		 */</span>
	        <span class="enscript-keyword">if</span> ( vnode_get(tvp) != 0)
		        cp-&gt;c_flag &amp;= ~(C_NEED_RVNODE_PUT | C_NEED_DVNODE_PUT);
	}
	vfsp.vnfs_mp = mp;
	vfsp.vnfs_vtype = vtype;
	vfsp.vnfs_str = <span class="enscript-string">&quot;hfs&quot;</span>;
	<span class="enscript-keyword">if</span> ((cp-&gt;c_flag &amp; C_HARDLINK) &amp;&amp; (vtype == VDIR)) {
		vfsp.vnfs_dvp = NULL;  <span class="enscript-comment">/* no parent for me! */</span>
		vfsp.vnfs_cnp = NULL;  <span class="enscript-comment">/* no name for me! */</span>
	} <span class="enscript-keyword">else</span> {
		vfsp.vnfs_dvp = dvp;
		vfsp.vnfs_cnp = cnp;
	}

	vfsp.vnfs_fsnode = cp;

	<span class="enscript-comment">/*
	 * Special Case HFS Standard VNOPs from HFS+, since
	 * HFS standard is readonly/deprecated as of 10.6 
	 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
	<span class="enscript-keyword">if</span> (vtype == VFIFO ) 
		vfsp.vnfs_vops = hfs_fifoop_p;
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (vtype == VBLK || vtype == VCHR)
		vfsp.vnfs_vops = hfs_specop_p;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfs_standard)
		vfsp.vnfs_vops = hfs_std_vnodeop_p;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">else</span> 
		vfsp.vnfs_vops = hfs_vnodeop_p;

	<span class="enscript-keyword">if</span> (vtype == VBLK || vtype == VCHR)
		vfsp.vnfs_rdev = attrp-&gt;ca_rdev;
	<span class="enscript-keyword">else</span>
		vfsp.vnfs_rdev = 0;

	<span class="enscript-keyword">if</span> (forkp) 
		vfsp.vnfs_filesize = forkp-&gt;cf_size;
	<span class="enscript-keyword">else</span>
		vfsp.vnfs_filesize = 0;

	vfsp.vnfs_flags = VNFS_ADDFSREF;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CN_WANTSRSRCFORK</span>
	<span class="enscript-keyword">if</span> (cnp &amp;&amp; cnp-&gt;cn_nameptr &amp;&amp; !(cnp-&gt;cn_flags &amp; CN_WANTSRSRCFORK) &amp;&amp; cp-&gt;c_desc.cd_nameptr &amp;&amp; strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cnp-&gt;cn_nameptr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr, cp-&gt;c_desc.cd_namelen) != 0) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (cnp &amp;&amp; cnp-&gt;cn_nameptr &amp;&amp; cp-&gt;c_desc.cd_nameptr &amp;&amp; strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cnp-&gt;cn_nameptr, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr, cp-&gt;c_desc.cd_namelen) != 0) {
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// We don't want VFS to add an entry for this vnode because the name in the
</span>		<span class="enscript-comment">// cnp does not match the bytes stored on disk for this file.  Instead we'll
</span>		<span class="enscript-comment">// update the identity later after the vnode is created and we'll do so with
</span>		<span class="enscript-comment">// the correct bytes for this filename.  For more details, see:
</span>		<span class="enscript-comment">//   &lt;rdar://problem/8044697&gt; FSEvents doesn't always decompose diacritical unicode chars in the paths of the changed directories
</span>		<span class="enscript-comment">//
</span>		vfsp.vnfs_flags |= VNFS_NOCACHE;
		need_update_identity = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dvp == NULLVP || cnp == NULL || !(cnp-&gt;cn_flags &amp; MAKEENTRY) || (flags &amp; GNV_NOCACHE)) {
		vfsp.vnfs_flags |= VNFS_NOCACHE;
	}

	<span class="enscript-comment">/* Tag system files */</span>
	vfsp.vnfs_marksystem = issystemfile;

	<span class="enscript-comment">/* Tag root directory */</span>
	<span class="enscript-keyword">if</span> (descp-&gt;cd_cnid == kHFSRootFolderID)
		vfsp.vnfs_markroot = 1;
	<span class="enscript-keyword">else</span>	
		vfsp.vnfs_markroot = 0;
	
	<span class="enscript-comment">/*
	 * If provided_vp was non-NULL, then it is an already-allocated (but not 
	 * initialized) vnode. We simply need to initialize it to this identity.  
	 * If it was NULL, then assume that we need to call vnode_create with the 
	 * normal arguments/types.
	 */</span> 
	<span class="enscript-keyword">if</span> (provided_vp) {
		vp = provided_vp;
		<span class="enscript-comment">/* 
		 * After we assign the value of provided_vp into 'vp' (so that it can be
		 * mutated safely by vnode_initialize), we can NULL it out.  At this point, the disposal
		 * and handling of the provided vnode will be the responsibility of VFS, which will
		 * clean it up and vnode_put it properly if vnode_initialize fails. 
		 */</span>
		provided_vp = NULL;

		retval = vnode_initialize (VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, &amp;vp);
		<span class="enscript-comment">/* See error handling below for resolving provided_vp */</span>
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Do a standard vnode_create */</span>
		retval = vnode_create (VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, &amp;vp);
	}

	<span class="enscript-comment">/* 
	 * We used a local variable to hold the result of vnode_create/vnode_initialize so that
	 * on error cases in vnode_create we won't accidentally harm the cnode's fields
	 */</span>
	
	<span class="enscript-keyword">if</span> (retval) {
		<span class="enscript-comment">/* Clean up if we encountered an error */</span>	
		<span class="enscript-keyword">if</span> (fp) {
			<span class="enscript-keyword">if</span> (fp == cp-&gt;c_datafork)
				cp-&gt;c_datafork = NULL;
			<span class="enscript-keyword">else</span>
				cp-&gt;c_rsrcfork = NULL;

			FREE_ZONE(fp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> filefork), M_HFSFORK);
		}
		<span class="enscript-comment">/*
		 * If this is a newly created cnode or a vnode reclaim
		 * occurred during the attachment, then cleanup the cnode.
		 */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_vp == NULL) &amp;&amp; (cp-&gt;c_rsrc_vp == NULL)) {
			hfs_chash_abort(hfsmp, cp);
			hfs_reclaim_cnode(hfsmp, cp);
		} 
		<span class="enscript-keyword">else</span> {
			hfs_chashwakeup(hfsmp, cp, H_ALLOC | H_ATTACH);
			<span class="enscript-keyword">if</span> ((flags &amp; GNV_SKIPLOCK) == 0){
				hfs_unlock(cp);
			}
		}
		*vpp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gnv_exit</span>;
	}

	<span class="enscript-comment">/* If no error, then assign the value into the cnode's fields  */</span>	
	*cvpp = vp;

	vnode_settag(vp, VT_HFS);
	<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_HARDLINK) {
		vnode_setmultipath(vp);
	}

	<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_recflags &amp; kHFSFastDevCandidateMask) {
		vnode_setfastdevicecandidate(vp);
	}

	<span class="enscript-keyword">if</span> (cp-&gt;c_attr.ca_recflags &amp; kHFSAutoCandidateMask) {
		vnode_setautocandidate(vp);
	}




	<span class="enscript-keyword">if</span> (vp &amp;&amp; need_update_identity) {
		<span class="enscript-comment">//
</span>		<span class="enscript-comment">// As above, update the name of the vnode if the bytes stored in hfs do not match
</span>		<span class="enscript-comment">// the bytes in the cnp.  See this radar:
</span>		<span class="enscript-comment">//    &lt;rdar://problem/8044697&gt; FSEvents doesn't always decompose diacritical unicode chars in the paths of the changed directories
</span>		<span class="enscript-comment">// for more details.
</span>		<span class="enscript-comment">//
</span>		vnode_update_identity (vp, dvp, (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cp-&gt;c_desc.cd_nameptr, cp-&gt;c_desc.cd_namelen, 0, VNODE_UPDATE_NAME);
	}

	<span class="enscript-comment">/*
	 * Tag resource fork vnodes as needing an VNOP_INACTIVE
	 * so that any deferred removes (open unlinked files)
	 * have the chance to process the resource fork.
	 */</span>
	<span class="enscript-keyword">if</span> (VNODE_IS_RSRC(vp)) {
		<span class="enscript-type">int</span> err;

		KERNEL_DEBUG_CONSTANT(HFSDBG_GETNEWVNODE, VM_KERNEL_ADDRPERM(cp-&gt;c_vp), VM_KERNEL_ADDRPERM(cp-&gt;c_rsrc_vp), 0, 0, 0);

		<span class="enscript-comment">/* Force VL_NEEDINACTIVE on this vnode */</span>
		err = vnode_ref(vp);
		<span class="enscript-keyword">if</span> (err == 0) {
			vnode_rele(vp);
		}
	}
	hfs_chashwakeup(hfsmp, cp, H_ALLOC | H_ATTACH);

	<span class="enscript-comment">/*
	 * Stop tracking an active hot file.
	 */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; GNV_CREATE) &amp;&amp; (vtype != VDIR) &amp;&amp; !issystemfile &amp;&amp; !(hfsmp-&gt;hfs_flags &amp; HFS_CS_HOTFILE_PIN)) {
		(<span class="enscript-type">void</span>) hfs_removehotfile(vp);
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	<span class="enscript-comment">/* Initialize the cp data structures. The key should be in place now. */</span>
	<span class="enscript-keyword">if</span> (!issystemfile &amp;&amp; (*out_flags &amp; GNV_NEW_CNODE)) {
		cp_entry_init(cp, mp);
	}
#<span class="enscript-reference">endif</span>

	*vpp = vp;
	retval = 0;

<span class="enscript-reference">gnv_exit</span>:
	<span class="enscript-keyword">if</span> (provided_vp) {
		<span class="enscript-comment">/* Release our empty vnode if it was not used */</span>
		vnode_put (provided_vp);
	}
	<span class="enscript-keyword">return</span> retval;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_reclaim_cnode</span>(hfsmount_t *hfsmp, <span class="enscript-type">struct</span> cnode *cp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">QUOTA</span>
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAXQUOTAS; i++) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_dquot[i] != NODQUOT) {
			dqreclaim(cp-&gt;c_dquot[i]);
			cp-&gt;c_dquot[i] = NODQUOT;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* QUOTA */</span>

	<span class="enscript-comment">/* 
	 * If the descriptor has a name then release it
	 */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;c_desc.cd_flags &amp; CD_HASBUF) &amp;&amp; (cp-&gt;c_desc.cd_nameptr != 0)) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *nameptr;

		nameptr = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *) cp-&gt;c_desc.cd_nameptr;
		cp-&gt;c_desc.cd_nameptr = 0;
		cp-&gt;c_desc.cd_flags &amp;= ~CD_HASBUF;
		cp-&gt;c_desc.cd_namelen = 0;
		vfs_removename(nameptr);
	}
	
	<span class="enscript-comment">/*
	 * We only call this function if we are in hfs_vnop_reclaim and 
	 * attempting to reclaim a cnode with only one live fork.  Because the vnode
	 * went through reclaim, any future attempts to use this item will have to
	 * go through lookup again, which will need to create a new vnode.  Thus,
	 * destroying the locks below is safe.
	 */</span>	
	
	lck_rw_destroy(&amp;cp-&gt;c_rwlock, hfs_rwlock_group);
	lck_rw_destroy(&amp;cp-&gt;c_truncatelock, hfs_rwlock_group);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_decmp) {
		decmpfs_cnode_destroy(cp-&gt;c_decmp);
		FREE_ZONE(cp-&gt;c_decmp, <span class="enscript-keyword">sizeof</span>(*(cp-&gt;c_decmp)), M_DECMPFS_CNODE);
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	cp_entry_destroy(hfsmp, cp-&gt;c_cpentry);
	cp-&gt;c_cpentry = NULL;
#<span class="enscript-reference">else</span>
	(<span class="enscript-type">void</span>)hfsmp;	<span class="enscript-comment">// Prevent compiler warning
</span>#<span class="enscript-reference">endif</span>

	bzero(cp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cnode));
	FREE_ZONE(cp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cnode), M_HFSNODE);
}


<span class="enscript-comment">/*
 * hfs_valid_cnode
 *
 * This function is used to validate data that is stored in-core against what is contained
 * in the catalog.  Common uses include validating that the parent-child relationship still exist
 * for a specific directory entry (guaranteeing it has not been renamed into a different spot) at
 * the point of the check.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_valid_cnode</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">struct</span> componentname *cnp, 
		cnid_t cnid, <span class="enscript-type">struct</span> cat_attr *cattr, <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> cat_attr attr;
	<span class="enscript-type">struct</span> cat_desc cndesc;
	<span class="enscript-type">int</span> stillvalid = 0;
	<span class="enscript-type">int</span> lockflags;

	<span class="enscript-comment">/* System files are always valid */</span>
	<span class="enscript-keyword">if</span> (cnid &lt; kHFSFirstUserCatalogNodeID) {
		*error = 0;
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-comment">/* XXX optimization:  check write count in dvp */</span>

	lockflags = hfs_systemfile_lock(hfsmp, SFL_CATALOG, HFS_SHARED_LOCK);

	<span class="enscript-keyword">if</span> (dvp &amp;&amp; cnp) {
		<span class="enscript-type">int</span> lookup = 0;
		<span class="enscript-type">struct</span> cat_fork fork;
		bzero(&amp;cndesc, <span class="enscript-keyword">sizeof</span>(cndesc));
		cndesc.cd_nameptr = (<span class="enscript-type">const</span> u_int8_t *)cnp-&gt;cn_nameptr;
		cndesc.cd_namelen = cnp-&gt;cn_namelen;
		cndesc.cd_parentcnid = VTOC(dvp)-&gt;c_fileid;
		cndesc.cd_hint = VTOC(dvp)-&gt;c_childhint;

		<span class="enscript-comment">/* 
		 * We have to be careful when calling cat_lookup.  The result argument
		 * 'attr' may get different results based on whether or not you ask
		 * for the filefork to be supplied as output.  This is because cat_lookupbykey
		 * will attempt to do basic validation/smoke tests against the resident
		 * extents if there are no overflow extent records, but it needs someplace
		 * in memory to store the on-disk fork structures.
		 *
		 * Since hfs_lookup calls cat_lookup with a filefork argument, we should
		 * do the same here, to verify that block count differences are not
		 * due to calling the function with different styles.  cat_lookupbykey
		 * will request the volume be fsck'd if there is true on-disk corruption
		 * where the number of blocks does not match the number generated by 
		 * summing the number of blocks in the resident extents.
		 */</span>
		
		lookup = cat_lookup (hfsmp, &amp;cndesc, 0, 0, NULL, &amp;attr, &amp;fork, NULL);

		<span class="enscript-keyword">if</span> ((lookup == 0) &amp;&amp; (cnid == attr.ca_fileid)) {
			stillvalid = 1;
			*error = 0;
		}
		<span class="enscript-keyword">else</span> {
			*error = ENOENT;
		}
	
		<span class="enscript-comment">/*
		 * In hfs_getnewvnode, we may encounter a time-of-check vs. time-of-vnode creation 
		 * race.  Specifically, if there is no vnode/cnode pair for the directory entry 
		 * being looked up, we have to go to the catalog.  But since we don't hold any locks (aside
		 * from the dvp in 'shared' mode) there is nothing to protect us against the catalog record
		 * changing in between the time we do the cat_lookup there and the time we re-grab the 
		 * catalog lock above to do another cat_lookup. 
		 * 
		 * However, we need to check more than just the CNID and parent-child name relationships above.  
		 * Hardlinks can suffer the same race in the following scenario:  Suppose we do a 
		 * cat_lookup, and find a leaf record and a raw inode for a hardlink.  Now, we have 
		 * the cat_attr in hand (passed in above).  But in between then and now, the vnode was 
		 * created by a competing hfs_getnewvnode call, and is manipulated and reclaimed before we get 
		 * a chance to do anything.  This is possible if there are a lot of threads thrashing around
		 * with the cnode hash.  In this case, if we don't check/validate the cat_attr in-hand, we will
		 * blindly stuff it into the cnode, which will make the in-core data inconsistent with what is 
		 * on disk.  So validate the cat_attr below, if required.  This race cannot happen if the cnode/vnode
		 * already exists, as it does in the case of rename and delete. 
		 */</span> 
		<span class="enscript-keyword">if</span> (stillvalid &amp;&amp; cattr != NULL) {
			<span class="enscript-keyword">if</span> (cattr-&gt;ca_linkcount != attr.ca_linkcount) {
				stillvalid = 0;
				*error = ERECYCLE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">notvalid</span>;
			}
			
			<span class="enscript-keyword">if</span> (cattr-&gt;ca_union1.cau_linkref != attr.ca_union1.cau_linkref) {
				stillvalid = 0;
				*error = ERECYCLE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">notvalid</span>;
			}

			<span class="enscript-keyword">if</span> (cattr-&gt;ca_union3.cau_firstlink != attr.ca_union3.cau_firstlink) {
				stillvalid = 0;
				*error = ERECYCLE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">notvalid</span>;
			}

			<span class="enscript-keyword">if</span> (cattr-&gt;ca_union2.cau_blocks != attr.ca_union2.cau_blocks) {
				stillvalid = 0;
				*error = ERECYCLE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">notvalid</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (cat_idlookup(hfsmp, cnid, 0, 0, NULL, NULL, NULL) == 0) {
			stillvalid = 1;
			*error = 0;
		}
		<span class="enscript-keyword">else</span> {
			*error = ENOENT;
		}
	}
<span class="enscript-reference">notvalid</span>:
	hfs_systemfile_unlock(hfsmp, lockflags);

	<span class="enscript-keyword">return</span> (stillvalid);
}


<span class="enscript-comment">/*
 * Per HI and Finder requirements, HFS should add in the
 * date/time that a particular directory entry was added 
 * to the containing directory. 
 * This is stored in the extended Finder Info for the 
 * item in question.
 *
 * Note that this field is also set explicitly in the hfs_vnop_setxattr code.
 * We must ignore user attempts to set this part of the finderinfo, and
 * so we need to save a local copy of the date added, write in the user 
 * finderinfo, then stuff the value back in.  
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_write_dateadded</span> (<span class="enscript-type">struct</span> cat_attr *attrp, u_int32_t dateadded) {
	u_int8_t *finfo = NULL;

	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = (u_int8_t*)attrp-&gt;ca_finderinfo;
	finfo = finfo + 16;

	<span class="enscript-comment">/* 
	 * Make sure to write it out as big endian, since that's how
	 * finder info is defined.  
	 * 
	 * NOTE: This is a Unix-epoch timestamp, not a HFS/Traditional Mac timestamp.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISREG(attrp-&gt;ca_mode)) {
		<span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		extinfo-&gt;date_added = OSSwapHostToBigInt32(dateadded);
		attrp-&gt;ca_recflags |= kHFSHasDateAddedMask; 
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (S_ISDIR(attrp-&gt;ca_mode)) {
		<span class="enscript-type">struct</span> FndrExtendedDirInfo *extinfo = (<span class="enscript-type">struct</span> FndrExtendedDirInfo *)finfo;
		extinfo-&gt;date_added = OSSwapHostToBigInt32(dateadded);		
				attrp-&gt;ca_recflags |= kHFSHasDateAddedMask; 
	}
	<span class="enscript-comment">/* If it were neither directory/file, then we'd bail out */</span>
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">hfs_get_dateadded_internal</span>(<span class="enscript-type">const</span> uint8_t *finderinfo, mode_t mode)
{
	<span class="enscript-type">const</span> uint8_t *finfo = NULL;
	u_int32_t dateadded = 0;



	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = finderinfo + 16;

	<span class="enscript-comment">/* 
	 * FinderInfo is written out in big endian... make sure to convert it to host
	 * native before we use it.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISREG(mode)) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		dateadded = OSSwapBigToHostInt32 (extinfo-&gt;date_added);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (S_ISDIR(mode)) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedDirInfo *extinfo = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedDirInfo *)finfo;
		dateadded = OSSwapBigToHostInt32 (extinfo-&gt;date_added);
	}

	<span class="enscript-keyword">return</span> dateadded;
}

u_int32_t
<span class="enscript-function-name">hfs_get_dateadded</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	<span class="enscript-keyword">if</span> ((cp-&gt;c_attr.ca_recflags &amp; kHFSHasDateAddedMask) == 0) {
		<span class="enscript-comment">/* Date added was never set.  Return 0. */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (hfs_get_dateadded_internal((u_int8_t*)cp-&gt;c_finderinfo,
	    cp-&gt;c_attr.ca_mode));
}

u_int32_t
<span class="enscript-function-name">hfs_get_dateadded_from_blob</span>(<span class="enscript-type">const</span> uint8_t *finderinfo, mode_t mode)
{
	<span class="enscript-keyword">return</span> (hfs_get_dateadded_internal(finderinfo, mode));
}

<span class="enscript-comment">/*
 * Per HI and Finder requirements, HFS maintains a &quot;write/generation
 * count&quot; for each file that is incremented on any write &amp; pageout.
 * It should start at 1 to reserve &quot;0&quot; as a special value.  If it
 * should ever wrap around, it will skip using 0.
 *
 * Note that finderinfo is manipulated in hfs_vnop_setxattr and care
 * is and should be taken to ignore user attempts to set the part of
 * the finderinfo that records the generation counter.
 *
 * Any change to the generation counter *must* not be visible before
 * the change that caused it (for obvious reasons), and given the
 * limitations of our current architecture, the change to the
 * generation counter may occur some time afterwards (particularly in
 * the case where a file is mapped writable---more on that below).
 *
 * We make no guarantees about the consistency of a file.  In other
 * words, a reader that is operating concurrently with a writer might
 * see some, but not all of writer's changes, and the generation
 * counter will *not* necessarily tell you this has happened.  To
 * enforce consistency, clients must make their own arrangements
 * e.g. use file locking.
 *
 * We treat files that are mapped writable as a special case: when
 * that happens, clients requesting the generation count will be told
 * it has a generation count of zero and they use that knowledge as a
 * hint that the file is changing and it therefore might be prudent to
 * wait until it is no longer mapped writable.  Clients should *not*
 * rely on this behaviour however; we might decide that it's better
 * for us to publish the fact that a file is mapped writable via
 * alternate means and return the generation counter when it is mapped
 * writable as it still has some, albeit limited, use.  We reserve the
 * right to make this change.
 *
 * Lastly, it's important to realise that because data and metadata
 * take different paths through the system, it's possible upon crash
 * or sudden power loss and after a restart, that a change may be
 * visible to the rest of the system without a corresponding change to
 * the generation counter.  The reverse may also be true, but for all
 * practical applications this shouldn't be an issue.
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_write_gencount</span> (<span class="enscript-type">struct</span> cat_attr *attrp, uint32_t gencount) {
	u_int8_t *finfo = NULL;

	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = (u_int8_t*)attrp-&gt;ca_finderinfo;
	finfo = finfo + 16;

	<span class="enscript-comment">/* 
	 * Make sure to write it out as big endian, since that's how
	 * finder info is defined.  
	 *
	 * Generation count is only supported for files.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISREG(attrp-&gt;ca_mode)) {
		<span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		extinfo-&gt;write_gen_counter = OSSwapHostToBigInt32(gencount);
	}

	<span class="enscript-comment">/* If it were neither directory/file, then we'd bail out */</span>
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Increase the gen count by 1; if it wraps around to 0, increment by
 * two.  The cnode *must* be locked exclusively by the caller.  
 *
 * You may think holding the lock is unnecessary because we only need
 * to change the counter, but consider this sequence of events: thread
 * A calls hfs_incr_gencount and the generation counter is 2 upon
 * entry.  A context switch occurs and thread B increments the counter
 * to 3, thread C now gets the generation counter (for whatever
 * purpose), and then another thread makes another change and the
 * generation counter is incremented again---it's now 4.  Now thread A
 * continues and it sets the generation counter back to 3.  So you can
 * see, thread C would miss the change that caused the generation
 * counter to increment to 4 and for this reason the cnode *must*
 * always be locked exclusively.
 */</span>
uint32_t <span class="enscript-function-name">hfs_incr_gencount</span> (<span class="enscript-type">struct</span> cnode *cp) {
	u_int8_t *finfo = NULL;
	u_int32_t gcount = 0;

	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = (u_int8_t*)cp-&gt;c_finderinfo;
	finfo = finfo + 16;

	<span class="enscript-comment">/* 
	 * FinderInfo is written out in big endian... make sure to convert it to host
	 * native before we use it.
	 *
	 * NOTE: the write_gen_counter is stored in the same location in both the
	 *       FndrExtendedFileInfo and FndrExtendedDirInfo structs (it's the
	 *       last 32-bit word) so it is safe to have one code path here.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISDIR(cp-&gt;c_attr.ca_mode) || S_ISREG(cp-&gt;c_attr.ca_mode)) {
		<span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		gcount = OSSwapBigToHostInt32 (extinfo-&gt;write_gen_counter);

		<span class="enscript-comment">/* Was it zero to begin with (file originated in 10.8 or earlier?) */</span>
		<span class="enscript-keyword">if</span> (gcount == 0) {
			gcount++;
		}

		<span class="enscript-comment">/* now bump it */</span>
		gcount++;

		<span class="enscript-comment">/* Did it wrap around ? */</span>
		<span class="enscript-keyword">if</span> (gcount == 0) {
			gcount++;
		}
		extinfo-&gt;write_gen_counter = OSSwapHostToBigInt32 (gcount);

		SET(cp-&gt;c_flag, C_MINOR_MOD);
	}
	<span class="enscript-keyword">else</span> {
		gcount = 0;
	}	

	<span class="enscript-keyword">return</span> gcount;
}

<span class="enscript-comment">/*
 * There is no need for any locks here (other than an iocount on an
 * associated vnode) because reading and writing an aligned 32 bit
 * integer should be atomic on all platforms we support.
 */</span>
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">hfs_get_gencount_internal</span>(<span class="enscript-type">const</span> uint8_t *finderinfo, mode_t mode)
{
	<span class="enscript-type">const</span> uint8_t *finfo = NULL;
	u_int32_t gcount = 0;

	<span class="enscript-comment">/* overlay the FinderInfo to the correct pointer, and advance */</span>
	finfo = finderinfo;
	finfo = finfo + 16;

	<span class="enscript-comment">/* 
	 * FinderInfo is written out in big endian... make sure to convert it to host
	 * native before we use it.
	 *
	 * NOTE: the write_gen_counter is stored in the same location in both the
	 *       FndrExtendedFileInfo and FndrExtendedDirInfo structs (it's the
	 *       last 32-bit word) so it is safe to have one code path here.
	 */</span>
	<span class="enscript-keyword">if</span> (S_ISDIR(mode) || S_ISREG(mode)) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *extinfo = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> FndrExtendedFileInfo *)finfo;
		gcount = OSSwapBigToHostInt32 (extinfo-&gt;write_gen_counter);
		
		<span class="enscript-comment">/* 
		 * Is it zero?  File might originate in 10.8 or earlier. We lie and bump it to 1,
		 * since the incrementer code is able to handle this case and will double-increment
		 * for us.
		 */</span>
		<span class="enscript-keyword">if</span> (gcount == 0) {
			gcount++;	
		}
	}

	<span class="enscript-keyword">return</span> gcount;
}

<span class="enscript-comment">/* Getter for the gen count */</span>
u_int32_t <span class="enscript-function-name">hfs_get_gencount</span> (<span class="enscript-type">struct</span> cnode *cp) {
	<span class="enscript-keyword">return</span> hfs_get_gencount_internal(cp-&gt;c_finderinfo, cp-&gt;c_attr.ca_mode);
}

<span class="enscript-comment">/* Getter for the gen count from a buffer (currently pointer to finderinfo)*/</span>
u_int32_t <span class="enscript-function-name">hfs_get_gencount_from_blob</span> (<span class="enscript-type">const</span> uint8_t *finfoblob, mode_t mode) {
	<span class="enscript-keyword">return</span> hfs_get_gencount_internal(finfoblob, mode);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_clear_might_be_dirty_flag</span>(cnode_t *cp)
{
	<span class="enscript-comment">/*
	 * If we're about to touch both mtime and ctime, we can clear the
	 * C_MIGHT_BE_DIRTY_FROM_MAPPING since we can guarantee that
	 * subsequent page-outs can only be for data made dirty before
	 * now.
	 */</span>
	CLR(cp-&gt;c_flag, C_MIGHT_BE_DIRTY_FROM_MAPPING);
}

<span class="enscript-comment">/*
 * Touch cnode times based on c_touch_xxx flags
 *
 * cnode must be locked exclusive
 *
 * This will also update the volume modify time
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_touchtimes</span>(<span class="enscript-type">struct</span> hfsmount *hfsmp, <span class="enscript-type">struct</span> cnode* cp)
{
	vfs_context_t ctx;

	<span class="enscript-keyword">if</span> (ISSET(hfsmp-&gt;hfs_flags, HFS_READ_ONLY) || ISSET(cp-&gt;c_flag, C_NOEXISTS)) {
		cp-&gt;c_touch_acctime = FALSE;
		cp-&gt;c_touch_chgtime = FALSE;
		cp-&gt;c_touch_modtime = FALSE;
		CLR(cp-&gt;c_flag, C_NEEDS_DATEADDED);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) {
	<span class="enscript-comment">/* HFS Standard doesn't support access times */</span>
		cp-&gt;c_touch_acctime = FALSE;
	}
#<span class="enscript-reference">endif</span>

	ctx = vfs_context_current();
	<span class="enscript-comment">/*
	 * Skip access time updates if:
	 *	. MNT_NOATIME is set
	 *	. a file system freeze is in progress
	 *	. a file system resize is in progress
	 *	. the vnode associated with this cnode is marked for rapid aging
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime) {
		<span class="enscript-keyword">if</span> ((vfs_flags(hfsmp-&gt;hfs_mp) &amp; MNT_NOATIME) ||
		    hfsmp-&gt;hfs_freeze_state != HFS_THAWED ||
		    (hfsmp-&gt;hfs_flags &amp; HFS_RESIZE_IN_PROGRESS) ||
		    (cp-&gt;c_vp &amp;&amp; ((vnode_israge(cp-&gt;c_vp) || (vfs_ctx_skipatime(ctx)))))) {
				
			cp-&gt;c_touch_acctime = FALSE;
		}
	}
	<span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime || cp-&gt;c_touch_chgtime || 
		cp-&gt;c_touch_modtime || (cp-&gt;c_flag &amp; C_NEEDS_DATEADDED)) {
		<span class="enscript-type">struct</span> timeval tv;
		<span class="enscript-type">int</span> touchvol = 0;

		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_modtime &amp;&amp; cp-&gt;c_touch_chgtime)
			hfs_clear_might_be_dirty_flag(cp);

		microtime(&amp;tv);
		    
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_acctime) {
			<span class="enscript-comment">/*
			 * When the access time is the only thing changing, we
			 * won't necessarily write it to disk immediately.  We
			 * only do the atime update at vnode recycle time, when
			 * fsync is called or when there's another reason to write
			 * to the metadata.
			 */</span>
			cp-&gt;c_atime = tv.tv_sec;
			cp-&gt;c_touch_acctime = FALSE;
		}
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_modtime) {
			cp-&gt;c_touch_modtime = FALSE;
			time_t new_time = tv.tv_sec;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_HFS_STD</span>
			<span class="enscript-comment">/*
			 * HFS dates that WE set must be adjusted for DST
			 */</span>
			<span class="enscript-keyword">if</span> ((hfsmp-&gt;hfs_flags &amp; HFS_STANDARD) &amp;&amp; gTimeZone.tz_dsttime) {
				new_time += 3600;
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (cp-&gt;c_mtime != new_time) {
				cp-&gt;c_mtime = new_time;
				cp-&gt;c_flag |= C_MINOR_MOD;
				touchvol = 1;
			}
		}
		<span class="enscript-keyword">if</span> (cp-&gt;c_touch_chgtime) {
			cp-&gt;c_touch_chgtime = FALSE;
			<span class="enscript-keyword">if</span> (cp-&gt;c_ctime != tv.tv_sec) {
				cp-&gt;c_ctime = tv.tv_sec;
				cp-&gt;c_flag |= C_MINOR_MOD;
				touchvol = 1;
			}
		}

		<span class="enscript-keyword">if</span> (cp-&gt;c_flag &amp; C_NEEDS_DATEADDED) {
			hfs_write_dateadded (&amp;(cp-&gt;c_attr), tv.tv_sec);
			cp-&gt;c_flag |= C_MINOR_MOD;
			<span class="enscript-comment">/* untwiddle the bit */</span>
			cp-&gt;c_flag &amp;= ~C_NEEDS_DATEADDED;
			touchvol = 1;
		}

		<span class="enscript-comment">/* Touch the volume modtime if needed */</span>
		<span class="enscript-keyword">if</span> (touchvol) {
			hfs_note_header_minor_change(hfsmp);
			HFSTOVCB(hfsmp)-&gt;vcbLsMod = tv.tv_sec;
		}
	}
}

<span class="enscript-comment">// Use this if you don't want to check the return code
</span><span class="enscript-type">void</span> <span class="enscript-function-name">hfs_lock_always</span>(cnode_t *cp, <span class="enscript-type">enum</span> hfs_locktype locktype)
{
	hfs_lock(cp, locktype, HFS_LOCK_ALWAYS);
}

<span class="enscript-comment">/*
 * Lock a cnode.
 * N.B. If you add any failure cases, *make* sure hfs_lock_always works
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_lock</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">enum</span> hfs_locktype locktype, <span class="enscript-type">enum</span> hfs_lockflags flags)
{
	thread_t thread = current_thread();

	<span class="enscript-keyword">if</span> (cp-&gt;c_lockowner == thread) {
		<span class="enscript-comment">/*
		 * Only the extents and bitmap files support lock recursion
		 * here.  The other system files support lock recursion in
		 * hfs_systemfile_lock.  Eventually, we should change to
		 * handle recursion solely in hfs_systemfile_lock.
		 */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_fileid == kHFSExtentsFileID) ||
		    (cp-&gt;c_fileid == kHFSAllocationFileID)) {
			cp-&gt;c_syslockcount++;
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;hfs_lock: locking against myself!&quot;</span>);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (locktype == HFS_SHARED_LOCK) {
		lck_rw_lock_shared(&amp;cp-&gt;c_rwlock);
		cp-&gt;c_lockowner = HFS_SHARED_OWNER;

	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* HFS_EXCLUSIVE_LOCK */</span>
		lck_rw_lock_exclusive(&amp;cp-&gt;c_rwlock);
		cp-&gt;c_lockowner = thread;

		<span class="enscript-comment">/* Only the extents and bitmap files support lock recursion. */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;c_fileid == kHFSExtentsFileID) ||
		    (cp-&gt;c_fileid == kHFSAllocationFileID)) {
			cp-&gt;c_syslockcount = 1;
		}
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HFS_CHECK_LOCK_ORDER</span>
	<span class="enscript-comment">/*
	 * Regular cnodes (non-system files) cannot be locked
	 * while holding the journal lock or a system file lock.
	 */</span>
	<span class="enscript-keyword">if</span> (!(cp-&gt;c_desc.cd_flags &amp; CD_ISMETA) &amp;&amp;
            ((cp-&gt;c_fileid &gt; kHFSFirstUserCatalogNodeID) || (cp-&gt;c_fileid == kHFSRootFolderID))) {
		vnode_t vp = NULLVP;

		<span class="enscript-comment">/* Find corresponding vnode. */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_vp != NULLVP &amp;&amp; VTOC(cp-&gt;c_vp) == cp) {
			vp = cp-&gt;c_vp;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;c_rsrc_vp != NULLVP &amp;&amp; VTOC(cp-&gt;c_rsrc_vp) == cp) {
			vp = cp-&gt;c_rsrc_vp;
		}
		<span class="enscript-keyword">if</span> (vp != NULLVP) {
			<span class="enscript-type">struct</span> hfsmount *hfsmp = VTOHFS(vp);

			<span class="enscript-keyword">if</span> (hfsmp-&gt;jnl &amp;&amp; (journal_owner(hfsmp-&gt;jnl) == thread)) {
				<span class="enscript-comment">/* This will eventually be a panic here. */</span>
				printf(<span class="enscript-string">&quot;hfs_lock: bad lock order (cnode after journal)\n&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_catalog_cp &amp;&amp; hfsmp-&gt;hfs_catalog_cp-&gt;c_lockowner == thread) {
				panic(<span class="enscript-string">&quot;hfs_lock: bad lock order (cnode after catalog)&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_attribute_cp &amp;&amp; hfsmp-&gt;hfs_attribute_cp-&gt;c_lockowner == thread) {
				panic(<span class="enscript-string">&quot;hfs_lock: bad lock order (cnode after attribute)&quot;</span>);
			}
			<span class="enscript-keyword">if</span> (hfsmp-&gt;hfs_extents_cp &amp;&amp; hfsmp-&gt;hfs_extents_cp-&gt;c_lockowner == thread) {
				panic(<span class="enscript-string">&quot;hfs_lock: bad lock order (cnode after extents)&quot;</span>);
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_CHECK_LOCK_ORDER */</span>
	
	<span class="enscript-comment">/*
	 * Skip cnodes for regular files that no longer exist 
	 * (marked deleted, catalog entry gone).
	 */</span>
	<span class="enscript-keyword">if</span> (((flags &amp; HFS_LOCK_ALLOW_NOEXISTS) == 0) &amp;&amp; 
	    ((cp-&gt;c_desc.cd_flags &amp; CD_ISMETA) == 0) &amp;&amp;
	    (cp-&gt;c_flag &amp; C_NOEXISTS)) {
		hfs_unlock(cp);
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	<span class="enscript-keyword">return</span> (0);
}

bool <span class="enscript-function-name">hfs_lock_upgrade</span>(cnode_t *cp)
{
	<span class="enscript-keyword">if</span> (lck_rw_lock_shared_to_exclusive(&amp;cp-&gt;c_rwlock)) {
		cp-&gt;c_lockowner = current_thread();
		<span class="enscript-keyword">return</span> true;
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> false;
}

<span class="enscript-comment">/*
 * Lock a pair of cnodes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_lockpair</span>(<span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2, <span class="enscript-type">enum</span> hfs_locktype locktype)
{
	<span class="enscript-type">struct</span> cnode *first, *last;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * If cnodes match then just lock one.
	 */</span>
	<span class="enscript-keyword">if</span> (cp1 == cp2) {
		<span class="enscript-keyword">return</span> hfs_lock(cp1, locktype, HFS_LOCK_DEFAULT);
	}

	<span class="enscript-comment">/*
	 * Lock in cnode address order.
	 */</span>
	<span class="enscript-keyword">if</span> (cp1 &lt; cp2) {
		first = cp1;
		last = cp2;
	} <span class="enscript-keyword">else</span> {
		first = cp2;
		last = cp1;
	}

	<span class="enscript-keyword">if</span> ( (error = hfs_lock(first, locktype, HFS_LOCK_DEFAULT))) {
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> ( (error = hfs_lock(last, locktype, HFS_LOCK_DEFAULT))) {
		hfs_unlock(first);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Check ordering of two cnodes. Return true if they are are in-order.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_isordered</span>(<span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2)
{
	<span class="enscript-keyword">if</span> (cp1 == cp2)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (cp1 == NULL || cp2 == (<span class="enscript-type">struct</span> cnode *)0xffffffff)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (cp2 == NULL || cp1 == (<span class="enscript-type">struct</span> cnode *)0xffffffff)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/*
	 * Locking order is cnode address order.
	 */</span>
	<span class="enscript-keyword">return</span> (cp1 &lt; cp2);
}

<span class="enscript-comment">/*
 * Acquire 4 cnode locks.
 *   - locked in cnode address order (lesser address first).
 *   - all or none of the locks are taken
 *   - only one lock taken per cnode (dup cnodes are skipped)
 *   - some of the cnode pointers may be null
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hfs_lockfour</span>(<span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2, <span class="enscript-type">struct</span> cnode *cp3,
             <span class="enscript-type">struct</span> cnode *cp4, <span class="enscript-type">enum</span> hfs_locktype locktype, <span class="enscript-type">struct</span> cnode **error_cnode)
{
	<span class="enscript-type">struct</span> cnode * a[3];
	<span class="enscript-type">struct</span> cnode * b[3];
	<span class="enscript-type">struct</span> cnode * list[4];
	<span class="enscript-type">struct</span> cnode * tmp;
	<span class="enscript-type">int</span> i, j, k;
	<span class="enscript-type">int</span> error;
	<span class="enscript-keyword">if</span> (error_cnode) {
		*error_cnode = NULL;
	}

	<span class="enscript-keyword">if</span> (hfs_isordered(cp1, cp2)) {
		a[0] = cp1; a[1] = cp2;
	} <span class="enscript-keyword">else</span> {
		a[0] = cp2; a[1] = cp1;
	}
	<span class="enscript-keyword">if</span> (hfs_isordered(cp3, cp4)) {
		b[0] = cp3; b[1] = cp4;
	} <span class="enscript-keyword">else</span> {
		b[0] = cp4; b[1] = cp3;
	}
	a[2] = (<span class="enscript-type">struct</span> cnode *)0xffffffff;  <span class="enscript-comment">/* sentinel value */</span>
	b[2] = (<span class="enscript-type">struct</span> cnode *)0xffffffff;  <span class="enscript-comment">/* sentinel value */</span>

	<span class="enscript-comment">/*
	 * Build the lock list, skipping over duplicates
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0, j = 0, k = 0; (i &lt; 2 || j &lt; 2); ) {
		tmp = hfs_isordered(a[i], b[j]) ? a[i++] : b[j++];
		<span class="enscript-keyword">if</span> (k == 0 || tmp != list[k-1])
			list[k++] = tmp;
	}

	<span class="enscript-comment">/*
	 * Now we can lock using list[0 - k].
	 * Skip over NULL entries.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; k; ++i) {
		<span class="enscript-keyword">if</span> (list[i])
			<span class="enscript-keyword">if</span> ((error = hfs_lock(list[i], locktype, HFS_LOCK_DEFAULT))) {
				<span class="enscript-comment">/* Only stuff error_cnode if requested */</span>
				<span class="enscript-keyword">if</span> (error_cnode) {
					*error_cnode = list[i];
				}
				<span class="enscript-comment">/* Drop any locks we acquired. */</span>
				<span class="enscript-keyword">while</span> (--i &gt;= 0) {
					<span class="enscript-keyword">if</span> (list[i])
						hfs_unlock(list[i]);
				}
				<span class="enscript-keyword">return</span> (error);
			}
	}
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Unlock a cnode.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_unlock</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	vnode_t rvp = NULLVP;
	vnode_t vp = NULLVP;
	u_int32_t c_flag;

	<span class="enscript-comment">/*
	 * Only the extents and bitmap file's support lock recursion.
	 */</span>
	<span class="enscript-keyword">if</span> ((cp-&gt;c_fileid == kHFSExtentsFileID) ||
	    (cp-&gt;c_fileid == kHFSAllocationFileID)) {
		<span class="enscript-keyword">if</span> (--cp-&gt;c_syslockcount &gt; 0) {
			<span class="enscript-keyword">return</span>;
		}
	}

	<span class="enscript-type">const</span> thread_t thread = current_thread();

	<span class="enscript-keyword">if</span> (cp-&gt;c_lockowner == thread) {
		c_flag = cp-&gt;c_flag;

		<span class="enscript-comment">// If we have the truncate lock, we must defer the puts
</span>		<span class="enscript-keyword">if</span> (cp-&gt;c_truncatelockowner == thread) {
			<span class="enscript-keyword">if</span> (ISSET(c_flag, C_NEED_DVNODE_PUT)
				&amp;&amp; !cp-&gt;c_need_dvnode_put_after_truncate_unlock) {
				CLR(c_flag, C_NEED_DVNODE_PUT);
				cp-&gt;c_need_dvnode_put_after_truncate_unlock = true;
			}
			<span class="enscript-keyword">if</span> (ISSET(c_flag, C_NEED_RVNODE_PUT)
				&amp;&amp; !cp-&gt;c_need_rvnode_put_after_truncate_unlock) {
				CLR(c_flag, C_NEED_RVNODE_PUT);
				cp-&gt;c_need_rvnode_put_after_truncate_unlock = true;
			}
		}

		CLR(cp-&gt;c_flag, (C_NEED_DATA_SETSIZE | C_NEED_RSRC_SETSIZE
						 | C_NEED_DVNODE_PUT | C_NEED_RVNODE_PUT));

		<span class="enscript-keyword">if</span> (c_flag &amp; (C_NEED_DVNODE_PUT | C_NEED_DATA_SETSIZE)) {
	        vp = cp-&gt;c_vp;
		}
		<span class="enscript-keyword">if</span> (c_flag &amp; (C_NEED_RVNODE_PUT | C_NEED_RSRC_SETSIZE)) {
	        rvp = cp-&gt;c_rsrc_vp;
		}

	    cp-&gt;c_lockowner = NULL;
	    lck_rw_unlock_exclusive(&amp;cp-&gt;c_rwlock);
	} <span class="enscript-keyword">else</span> {
	    lck_rw_unlock_shared(&amp;cp-&gt;c_rwlock);
	}

	<span class="enscript-comment">/* Perform any vnode post processing after cnode lock is dropped. */</span>
	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-keyword">if</span> (c_flag &amp; C_NEED_DATA_SETSIZE) {
			ubc_setsize(vp, VTOF(vp)-&gt;ff_size);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
			<span class="enscript-comment">/*
			 * If this is a compressed file, we need to reset the
			 * compression state.  We will have set the size to zero
			 * above and it will get fixed up later (in exactly the
			 * same way that new vnodes are fixed up).  Note that we
			 * should only be able to get here if the truncate lock is
			 * held exclusively and so we do the reset when that's
			 * unlocked.
			 */</span>
			decmpfs_cnode *dp = VTOCMP(vp);
			<span class="enscript-keyword">if</span> (dp &amp;&amp; decmpfs_cnode_get_vnode_state(dp) != FILE_TYPE_UNKNOWN)
				cp-&gt;c_need_decmpfs_reset = true;
#<span class="enscript-reference">endif</span>
		}
		<span class="enscript-keyword">if</span> (c_flag &amp; C_NEED_DVNODE_PUT)
			vnode_put(vp);
	}
	<span class="enscript-keyword">if</span> (rvp) {
		<span class="enscript-keyword">if</span> (c_flag &amp; C_NEED_RSRC_SETSIZE)
			ubc_setsize(rvp, VTOF(rvp)-&gt;ff_size);
		<span class="enscript-keyword">if</span> (c_flag &amp; C_NEED_RVNODE_PUT)
	        	vnode_put(rvp);
	}
}

<span class="enscript-comment">/*
 * Unlock a pair of cnodes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_unlockpair</span>(<span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2)
{
	hfs_unlock(cp1);
	<span class="enscript-keyword">if</span> (cp2 != cp1)
		hfs_unlock(cp2);
}

<span class="enscript-comment">/*
 * Unlock a group of cnodes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_unlockfour</span>(<span class="enscript-type">struct</span> cnode *cp1, <span class="enscript-type">struct</span> cnode *cp2, <span class="enscript-type">struct</span> cnode *cp3, <span class="enscript-type">struct</span> cnode *cp4)
{
	<span class="enscript-type">struct</span> cnode * list[4];
	<span class="enscript-type">int</span> i, k = 0;

	<span class="enscript-keyword">if</span> (cp1) {
		hfs_unlock(cp1);
		list[k++] = cp1;
	}
	<span class="enscript-keyword">if</span> (cp2) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; k; ++i) {
			<span class="enscript-keyword">if</span> (list[i] == cp2)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip1</span>;
		}
		hfs_unlock(cp2);
		list[k++] = cp2;
	}
<span class="enscript-reference">skip1</span>:
	<span class="enscript-keyword">if</span> (cp3) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; k; ++i) {
			<span class="enscript-keyword">if</span> (list[i] == cp3)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip2</span>;
		}
		hfs_unlock(cp3);
		list[k++] = cp3;
	}
<span class="enscript-reference">skip2</span>:
	<span class="enscript-keyword">if</span> (cp4) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; k; ++i) {
			<span class="enscript-keyword">if</span> (list[i] == cp4)
				<span class="enscript-keyword">return</span>;
		}
		hfs_unlock(cp4);
	}
}


<span class="enscript-comment">/*
 * Protect a cnode against a truncation.
 *
 * Used mainly by read/write since they don't hold the
 * cnode lock across calls to the cluster layer.
 *
 * The process doing a truncation must take the lock
 * exclusive. The read/write processes can take it
 * shared.  The locktype argument is the same as supplied to
 * hfs_lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_lock_truncate</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">enum</span> hfs_locktype locktype, <span class="enscript-type">enum</span> hfs_lockflags flags)
{
	thread_t thread = current_thread();

	<span class="enscript-keyword">if</span> (cp-&gt;c_truncatelockowner == thread) {
		<span class="enscript-comment">/* 
		 * Ignore grabbing the lock if it the current thread already 
		 * holds exclusive lock.
		 * 
		 * This is needed on the hfs_vnop_pagein path where we need to ensure
		 * the file does not change sizes while we are paging in.  However,
		 * we may already hold the lock exclusive due to another 
		 * VNOP from earlier in the call stack.  So if we already hold 
		 * the truncate lock exclusive, allow it to proceed, but ONLY if 
		 * it's in the recursive case.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; HFS_LOCK_SKIP_IF_EXCLUSIVE) == 0) {
			panic(<span class="enscript-string">&quot;hfs_lock_truncate: cnode %p locked!&quot;</span>, cp);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (locktype == HFS_SHARED_LOCK) {
		lck_rw_lock_shared(&amp;cp-&gt;c_truncatelock);
		cp-&gt;c_truncatelockowner = HFS_SHARED_OWNER;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* HFS_EXCLUSIVE_LOCK */</span>
		lck_rw_lock_exclusive(&amp;cp-&gt;c_truncatelock);
		cp-&gt;c_truncatelockowner = thread;
	}
}

bool <span class="enscript-function-name">hfs_truncate_lock_upgrade</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	assert(cp-&gt;c_truncatelockowner == HFS_SHARED_OWNER);
	<span class="enscript-keyword">if</span> (!lck_rw_lock_shared_to_exclusive(&amp;cp-&gt;c_truncatelock))
		<span class="enscript-keyword">return</span> false;
	cp-&gt;c_truncatelockowner = current_thread();
	<span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">hfs_truncate_lock_downgrade</span>(<span class="enscript-type">struct</span> cnode *cp)
{
	assert(cp-&gt;c_truncatelockowner == current_thread());
	lck_rw_lock_exclusive_to_shared(&amp;cp-&gt;c_truncatelock);
	cp-&gt;c_truncatelockowner = HFS_SHARED_OWNER;
}

<span class="enscript-comment">/*
 * Attempt to get the truncate lock.  If it cannot be acquired, error out.
 * This function is needed in the degenerate hfs_vnop_pagein during force unmount
 * case.  To prevent deadlocks while a VM copy object is moving pages, HFS vnop pagein will
 * temporarily need to disable V2 semantics.  
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">hfs_try_trunclock</span> (<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">enum</span> hfs_locktype locktype, <span class="enscript-type">enum</span> hfs_lockflags flags)
{
	thread_t thread = current_thread();
	boolean_t didlock = false;

	<span class="enscript-keyword">if</span> (cp-&gt;c_truncatelockowner == thread) {
		<span class="enscript-comment">/* 
		 * Ignore grabbing the lock if the current thread already 
		 * holds exclusive lock.
		 * 
		 * This is needed on the hfs_vnop_pagein path where we need to ensure
		 * the file does not change sizes while we are paging in.  However,
		 * we may already hold the lock exclusive due to another 
		 * VNOP from earlier in the call stack.  So if we already hold 
		 * the truncate lock exclusive, allow it to proceed, but ONLY if 
		 * it's in the recursive case.
		 */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; HFS_LOCK_SKIP_IF_EXCLUSIVE) == 0) {
			panic(<span class="enscript-string">&quot;hfs_lock_truncate: cnode %p locked!&quot;</span>, cp);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (locktype == HFS_SHARED_LOCK) {
		didlock = lck_rw_try_lock(&amp;cp-&gt;c_truncatelock, LCK_RW_TYPE_SHARED);
		<span class="enscript-keyword">if</span> (didlock) {
			cp-&gt;c_truncatelockowner = HFS_SHARED_OWNER;
		}
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* HFS_EXCLUSIVE_LOCK */</span>
		didlock = lck_rw_try_lock (&amp;cp-&gt;c_truncatelock, LCK_RW_TYPE_EXCLUSIVE);
		<span class="enscript-keyword">if</span> (didlock) {
			cp-&gt;c_truncatelockowner = thread;
		}
	}
	
	<span class="enscript-keyword">return</span> didlock;
}


<span class="enscript-comment">/*
 * Unlock the truncate lock, which protects against size changes.
 * 
 * If HFS_LOCK_SKIP_IF_EXCLUSIVE flag was set, it means that a previous 
 * hfs_lock_truncate() might have skipped grabbing a lock because 
 * the current thread was already holding the lock exclusive and 
 * we may need to return from this function without actually unlocking 
 * the truncate lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">hfs_unlock_truncate</span>(<span class="enscript-type">struct</span> cnode *cp, <span class="enscript-type">enum</span> hfs_lockflags flags)
{
	thread_t thread = current_thread();	

	<span class="enscript-comment">/*
	 * If HFS_LOCK_SKIP_IF_EXCLUSIVE is set in the flags AND the current 
	 * lock owner of the truncate lock is our current thread, then 
	 * we must have skipped taking the lock earlier by in 
	 * hfs_lock_truncate() by setting HFS_LOCK_SKIP_IF_EXCLUSIVE in the 
	 * flags (as the current thread was current lock owner).
	 *
	 * If HFS_LOCK_SKIP_IF_EXCLUSIVE is not set (most of the time) then 
	 * we check the lockowner field to infer whether the lock was taken 
	 * exclusively or shared in order to know what underlying lock 
	 * routine to call. 
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; HFS_LOCK_SKIP_IF_EXCLUSIVE) {
		<span class="enscript-keyword">if</span> (cp-&gt;c_truncatelockowner == thread) {
			<span class="enscript-keyword">return</span>;	
		}
	}

	<span class="enscript-comment">/* HFS_LOCK_EXCLUSIVE */</span>
	<span class="enscript-keyword">if</span> (thread == cp-&gt;c_truncatelockowner) {
		vnode_t vp = NULL, rvp = NULL;

		<span class="enscript-comment">/*
		 * If there are pending set sizes, the cnode lock should be dropped
		 * first.
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		assert(!(cp-&gt;c_lockowner == thread
				 &amp;&amp; ISSET(cp-&gt;c_flag, C_NEED_DATA_SETSIZE | C_NEED_RSRC_SETSIZE)));
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEVELOPMENT</span>
		<span class="enscript-keyword">if</span> (cp-&gt;c_lockowner == thread
			&amp;&amp; ISSET(cp-&gt;c_flag, C_NEED_DATA_SETSIZE | C_NEED_RSRC_SETSIZE)) {
			printf(<span class="enscript-string">&quot;hfs: hfs_unlock_truncate called with C_NEED_DATA/RSRC_SETSIZE set (caller: 0x%llx)\n&quot;</span>,
				   (uint64_t)VM_KERNEL_UNSLIDE(__builtin_return_address(0)));
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (cp-&gt;c_need_dvnode_put_after_truncate_unlock) {
			vp = cp-&gt;c_vp;
			cp-&gt;c_need_dvnode_put_after_truncate_unlock = false;
		}
		<span class="enscript-keyword">if</span> (cp-&gt;c_need_rvnode_put_after_truncate_unlock) {
			rvp = cp-&gt;c_rsrc_vp;
			cp-&gt;c_need_rvnode_put_after_truncate_unlock = false;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		bool reset_decmpfs = cp-&gt;c_need_decmpfs_reset;
		cp-&gt;c_need_decmpfs_reset = false;
#<span class="enscript-reference">endif</span>

		cp-&gt;c_truncatelockowner = NULL;
		lck_rw_unlock_exclusive(&amp;cp-&gt;c_truncatelock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HFS_COMPRESSION</span>
		<span class="enscript-keyword">if</span> (reset_decmpfs) {
			decmpfs_cnode *dp = cp-&gt;c_decmp;
			<span class="enscript-keyword">if</span> (dp &amp;&amp; decmpfs_cnode_get_vnode_state(dp) != FILE_TYPE_UNKNOWN)
				decmpfs_cnode_set_vnode_state(dp, FILE_TYPE_UNKNOWN, 0);
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">// Do the puts now
</span>		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);
		<span class="enscript-keyword">if</span> (rvp)
			vnode_put(rvp);
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* HFS_LOCK_SHARED */</span>
		lck_rw_unlock_shared(&amp;cp-&gt;c_truncatelock);
	}
}
</pre>
<hr />
</body></html>