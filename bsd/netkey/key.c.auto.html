<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>key.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">key.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netkey/key.c,v 1.16.2.13 2002/07/24 18:17:40 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: key.c,v 1.191 2001/06/27 10:46:49 sakane Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * This code is referd to RFC 2367
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/endian.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/raw_cb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfkeyv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keydb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keysock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key_debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipcomp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipcomp6.h&gt;</span>
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/* randomness */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/random.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FULLMASK</span>	0xff

lck_grp_t         *sadb_mutex_grp;
lck_grp_attr_t    *sadb_mutex_grp_attr;
lck_attr_t        *sadb_mutex_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(, sadb_mutex_data);
lck_mtx_t         *sadb_mutex = &amp;sadb_mutex_data;

lck_grp_t         *pfkey_stat_mutex_grp;
lck_grp_attr_t    *pfkey_stat_mutex_grp_attr;
lck_attr_t        *pfkey_stat_mutex_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(, pfkey_stat_mutex_data);
lck_mtx_t         *pfkey_stat_mutex = &amp;pfkey_stat_mutex_data;

<span class="enscript-comment">/*
 * Note on SA reference counting:
 * - SAs that are not in DEAD state will have (total external reference + 1)
 *   following value in reference count field.  they cannot be freed and are
 *   referenced from SA header.
 * - SAs that are in DEAD state will have (total external reference)
 *   in reference count field.  they are ready to be freed.  reference from
 *   SA header will be removed in key_delsav(), when the reference count
 *   field hits 0 (= no external reference other than from SA header.
 */</span>

u_int32_t key_debug_level = 0; <span class="enscript-comment">//### our sysctl is not dynamic
</span><span class="enscript-type">static</span> <span class="enscript-type">int</span> key_timehandler_running = 0;
<span class="enscript-type">static</span> u_int key_spi_trycnt = 1000;
<span class="enscript-type">static</span> u_int32_t key_spi_minval = 0x100;
<span class="enscript-type">static</span> u_int32_t key_spi_maxval = 0x0fffffff;	<span class="enscript-comment">/* XXX */</span>
<span class="enscript-type">static</span> u_int32_t policy_id = 0;
<span class="enscript-type">static</span> u_int key_int_random = 60;	<span class="enscript-comment">/*interval to initialize randseed,1(m)*/</span>
<span class="enscript-type">static</span> u_int key_larval_lifetime = 30;	<span class="enscript-comment">/* interval to expire acquiring, 30(s)*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> key_blockacq_count = 10;	<span class="enscript-comment">/* counter for blocking SADB_ACQUIRE.*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> key_blockacq_lifetime = 20;	<span class="enscript-comment">/* lifetime for blocking SADB_ACQUIRE.*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> key_preferred_oldsa = 0;	<span class="enscript-comment">/* preferred old sa rather than new sa.*/</span>
__private_extern__ <span class="enscript-type">int</span> natt_keepalive_interval = 20;	<span class="enscript-comment">/* interval between natt keepalives.*/</span>
__private_extern__ <span class="enscript-type">int</span> ipsec_policy_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipsec_sav_count = 0;

<span class="enscript-type">static</span> u_int32_t acq_seq = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> key_tick_init_random = 0;
__private_extern__ u_int32_t natt_now = 0;

<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_sptree, secpolicy) sptree[IPSEC_DIR_MAX];	<span class="enscript-comment">/* SPD */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_sahtree, secashead) sahtree;			<span class="enscript-comment">/* SAD */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_regtree, secreg) regtree[SADB_SATYPE_MAX + 1];
<span class="enscript-comment">/* registed list */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SPIHASHSIZE</span>	128
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SPIHASH</span>(x)	(((x) ^ ((x) &gt;&gt; 16)) % SPIHASHSIZE)
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_spihash, secasvar) spihash[SPIHASHSIZE];

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_acqtree, secacq) acqtree;		<span class="enscript-comment">/* acquiring list */</span>
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(_spacqtree, secspacq) spacqtree;	<span class="enscript-comment">/* SP acquiring list */</span>

<span class="enscript-type">struct</span> key_cb key_cb;

<span class="enscript-comment">/* search order for SAs */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int saorder_state_valid_prefer_old[] = {
	SADB_SASTATE_DYING, SADB_SASTATE_MATURE,
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int saorder_state_valid_prefer_new[] = {
	SADB_SASTATE_MATURE, SADB_SASTATE_DYING,
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int saorder_state_alive[] = {
	<span class="enscript-comment">/* except DEAD */</span>
	SADB_SASTATE_MATURE, SADB_SASTATE_DYING, SADB_SASTATE_LARVAL
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> u_int saorder_state_any[] = {
	SADB_SASTATE_MATURE, SADB_SASTATE_DYING,
	SADB_SASTATE_LARVAL, SADB_SASTATE_DEAD
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> minsize[] = {
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg),	<span class="enscript-comment">/* SADB_EXT_RESERVED */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa),		<span class="enscript-comment">/* SADB_EXT_SA */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_CURRENT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_HARD */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_SOFT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_EXT_ADDRESS_SRC */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_EXT_ADDRESS_DST */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_EXT_ADDRESS_PROXY */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key),	<span class="enscript-comment">/* SADB_EXT_KEY_AUTH */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key),	<span class="enscript-comment">/* SADB_EXT_KEY_ENCRYPT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident),	<span class="enscript-comment">/* SADB_EXT_IDENTITY_SRC */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident),	<span class="enscript-comment">/* SADB_EXT_IDENTITY_DST */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sens),	<span class="enscript-comment">/* SADB_EXT_SENSITIVITY */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_prop),	<span class="enscript-comment">/* SADB_EXT_PROPOSAL */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_supported),	<span class="enscript-comment">/* SADB_EXT_SUPPORTED_AUTH */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_supported),	<span class="enscript-comment">/* SADB_EXT_SUPPORTED_ENCRYPT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_spirange),	<span class="enscript-comment">/* SADB_EXT_SPIRANGE */</span>
	0,				<span class="enscript-comment">/* SADB_X_EXT_KMPRIVATE */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy),	<span class="enscript-comment">/* SADB_X_EXT_POLICY */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_sa2),	<span class="enscript-comment">/* SADB_X_SA2 */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_session_id), <span class="enscript-comment">/* SADB_EXT_SESSION_ID */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sastat),     <span class="enscript-comment">/* SADB_EXT_SASTAT */</span>
    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif), <span class="enscript-comment">/* SADB_X_EXT_IPSECIF */</span>
    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_SRC_START */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_SRC_END */</span>
    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_DST_START */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_DST_END */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_EXT_MIGRATE_ADDRESS_SRC */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address),	<span class="enscript-comment">/* SADB_EXT_MIGRATE_ADDRESS_DST */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif),  <span class="enscript-comment">/* SADB_X_EXT_MIGRATE_IPSECIF */</span>
};
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">int</span> maxsize[] = {
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg),	<span class="enscript-comment">/* SADB_EXT_RESERVED */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa_2),		<span class="enscript-comment">/* SADB_EXT_SA */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_CURRENT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_HARD */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime),	<span class="enscript-comment">/* SADB_EXT_LIFETIME_SOFT */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_ADDRESS_SRC */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_ADDRESS_DST */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_ADDRESS_PROXY */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_KEY_AUTH */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_KEY_ENCRYPT */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_IDENTITY_SRC */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_IDENTITY_DST */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_SENSITIVITY */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_PROPOSAL */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_SUPPORTED_AUTH */</span>
	0,				<span class="enscript-comment">/* SADB_EXT_SUPPORTED_ENCRYPT */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_spirange),	<span class="enscript-comment">/* SADB_EXT_SPIRANGE */</span>
	0,				<span class="enscript-comment">/* SADB_X_EXT_KMPRIVATE */</span>
	0,				<span class="enscript-comment">/* SADB_X_EXT_POLICY */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_sa2),	<span class="enscript-comment">/* SADB_X_SA2 */</span>
	0,                              <span class="enscript-comment">/* SADB_EXT_SESSION_ID */</span>
	0,                              <span class="enscript-comment">/* SADB_EXT_SASTAT */</span>
    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif), <span class="enscript-comment">/* SADB_X_EXT_IPSECIF */</span>
    0,              <span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_SRC_START */</span>
	0,              <span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_SRC_END */</span>
    0,              <span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_DST_START */</span>
	0,              <span class="enscript-comment">/* SADB_X_EXT_ADDR_RANGE_DST_END */</span>
	0,              <span class="enscript-comment">/* SADB_EXT_MIGRATE_ADDRESS_SRC */</span>
	0,              <span class="enscript-comment">/* SADB_EXT_MIGRATE_ADDRESS_DST */</span>
	<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif), <span class="enscript-comment">/* SADB_X_EXT_MIGRATE_IPSECIF */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipsec_esp_keymin = 256;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipsec_esp_auth = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ipsec_ah_keymin = 128;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_key);
<span class="enscript-comment">/* Thread safe: no accumulated state */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_DEBUG_LEVEL,	debug,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_debug_level,	0,	<span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/* max count of trial for the decision of spi value */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_SPI_TRY,		spi_trycnt,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_spi_trycnt,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* minimum spi value to allocate automatically. */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_SPI_MIN_VALUE,	spi_minval,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_spi_minval,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* maximun spi value to allocate automatically. */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_SPI_MAX_VALUE,	spi_maxval,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_spi_maxval,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* interval to initialize randseed */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_RANDOM_INT,	int_random,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_int_random,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* lifetime for larval SA; thread safe due to &gt; compare */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_LARVAL_LIFETIME,	larval_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_larval_lifetime,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* counter for blocking to send SADB_ACQUIRE to IKEd */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_BLOCKACQ_COUNT,	blockacq_count,	CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_blockacq_count,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* lifetime for blocking to send SADB_ACQUIRE to IKEd: Thread safe, &gt; compare */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_BLOCKACQ_LIFETIME,	blockacq_lifetime, CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;key_blockacq_lifetime,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* ESP auth */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_ESP_AUTH,	esp_auth, CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;ipsec_esp_auth,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* minimum ESP key length */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_ESP_KEYMIN,	esp_keymin, CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;ipsec_esp_keymin,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* minimum AH key length */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_AH_KEYMIN,	ah_keymin, CTLFLAG_RW | CTLFLAG_LOCKED, \
		   &amp;ipsec_ah_keymin,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* perfered old SA rather than new SA */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_PREFERED_OLDSA,	prefered_oldsa, CTLFLAG_RW | CTLFLAG_LOCKED,\
		   &amp;key_preferred_oldsa,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* time between NATT keepalives in seconds, 0 disabled  */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_key, KEYCTL_NATT_KEEPALIVE_INTERVAL, natt_keepalive_interval, CTLFLAG_RW | CTLFLAG_LOCKED,\
		   &amp;natt_keepalive_interval,	0,	<span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* PF_KEY statistics */</span>
<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_key, KEYCTL_PFKEYSTAT, pfkeystat, CTLFLAG_RD | CTLFLAG_LOCKED,\
			  &amp;pfkeystat, pfkeystat, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">LIST_FOREACH</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LIST_FOREACH</span>(elm, head, field)                                     \
<span class="enscript-function-name">for</span> (elm = LIST_FIRST(head); elm; elm = LIST_NEXT(elm, field))
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">__LIST_CHAINED</span>(elm) \
(!((elm)-&gt;chain.le_next == NULL &amp;&amp; (elm)-&gt;chain.le_prev == NULL))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LIST_INSERT_TAIL</span>(head, elm, type, field) \
<span class="enscript-keyword">do</span> {\
<span class="enscript-type">struct</span> type *curelm = LIST_FIRST(head); \
<span class="enscript-function-name">if</span> (curelm == NULL) {\
<span class="enscript-function-name">LIST_INSERT_HEAD</span>(head, elm, field); \
} <span class="enscript-keyword">else</span> { \
<span class="enscript-function-name">while</span> (LIST_NEXT(curelm, field)) \
curelm = LIST_NEXT(curelm, field);\
<span class="enscript-function-name">LIST_INSERT_AFTER</span>(curelm, elm, field);\
}\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">KEY_CHKSASTATE</span>(head, sav, name) \
<span class="enscript-keyword">do</span> { \
<span class="enscript-function-name">if</span> ((head) != (sav)) {						\
<span class="enscript-function-name">ipseclog</span>((LOG_DEBUG, <span class="enscript-string">&quot;%s: state mismatched (TREE=%d SA=%d)\n&quot;</span>, \
(name), (head), (sav)));			\
<span class="enscript-keyword">continue</span>;						\
}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">KEY_CHKSPDIR</span>(head, sp, name) \
<span class="enscript-keyword">do</span> { \
<span class="enscript-function-name">if</span> ((head) != (sp)) {						\
<span class="enscript-function-name">ipseclog</span>((LOG_DEBUG, <span class="enscript-string">&quot;%s: direction mismatched (TREE=%d SP=%d), &quot;</span> \
<span class="enscript-string">&quot;anyway continue.\n&quot;</span>,				\
(name), (head), (sp)));				\
}								\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">if</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KMALLOC_WAIT</span>(p, t, n)                                                     \
((p) = (t) _MALLOC((u_int32_t)(n), M_SECA, M_WAITOK))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KMALLOC_NOWAIT</span>(p, t, n)                                              \
((p) = (t) _MALLOC((u_int32_t)(n), M_SECA, M_NOWAIT))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KFREE</span>(p)                                                             \
<span class="enscript-function-name">_FREE</span>((caddr_t)(p), M_SECA);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KMALLOC_WAIT</span>(p, t, n) \
<span class="enscript-keyword">do</span> { \
((p) = (t)_MALLOC((u_int32_t)(n), M_SECA, M_WAITOK));             \
<span class="enscript-function-name">printf</span>(<span class="enscript-string">&quot;%s %d: %p &lt;- KMALLOC_WAIT(%s, %d)\n&quot;</span>,                             \
__FILE__, __LINE__, (p), #t, n);                             \
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KMALLOC_NOWAIT</span>(p, t, n) \
<span class="enscript-keyword">do</span> { \
((p) = (t)_MALLOC((u_int32_t)(n), M_SECA, M_NOWAIT));             \
<span class="enscript-function-name">printf</span>(<span class="enscript-string">&quot;%s %d: %p &lt;- KMALLOC_NOWAIT(%s, %d)\n&quot;</span>,                             \
__FILE__, __LINE__, (p), #t, n);                             \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">KFREE</span>(p)                                                             \
<span class="enscript-keyword">do</span> {                                                                 \
<span class="enscript-function-name">printf</span>(<span class="enscript-string">&quot;%s %d: %p -&gt; KFREE()\n&quot;</span>, __FILE__, __LINE__, (p));   \
<span class="enscript-function-name">_FREE</span>((caddr_t)(p), M_SECA);                                  \
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * set parameters into secpolicyindex buffer.
 * Must allocate secpolicyindex buffer passed to this function.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KEY_SETSECSPIDX</span>(_dir, s, d, ps, pd, ulp, ifp, s_s, s_e, d_s, d_e, idx) \
<span class="enscript-keyword">do</span> { \
<span class="enscript-function-name">bzero</span>((idx), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secpolicyindex));                         \
(idx)-&gt;dir = (_dir);                                                 \
(idx)-&gt;prefs = (ps);                                                 \
(idx)-&gt;prefd = (pd);                                                 \
(idx)-&gt;ul_proto = (ulp);                                             \
(idx)-&gt;internal_if = (ifp);                                          \
<span class="enscript-function-name">if</span> (s) bcopy((s), &amp;(idx)-&gt;src, ((<span class="enscript-type">struct</span> sockaddr *)(s))-&gt;sa_len);    \
<span class="enscript-function-name">if</span> (d) bcopy((d), &amp;(idx)-&gt;dst, ((<span class="enscript-type">struct</span> sockaddr *)(d))-&gt;sa_len);    \
<span class="enscript-function-name">if</span> (s_s) bcopy((s_s), &amp;(idx)-&gt;src_range.start, ((<span class="enscript-type">struct</span> sockaddr *)(s_s))-&gt;sa_len);   \
<span class="enscript-function-name">if</span> (s_e) bcopy((s_e), &amp;(idx)-&gt;src_range.end, ((<span class="enscript-type">struct</span> sockaddr *)(s_e))-&gt;sa_len);     \
<span class="enscript-function-name">if</span> (d_s) bcopy((d_s), &amp;(idx)-&gt;dst_range.start, ((<span class="enscript-type">struct</span> sockaddr *)(d_s))-&gt;sa_len);   \
<span class="enscript-function-name">if</span> (d_e) bcopy((d_e), &amp;(idx)-&gt;dst_range.end, ((<span class="enscript-type">struct</span> sockaddr *)(d_e))-&gt;sa_len);     \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * set parameters into secasindex buffer.
 * Must allocate secasindex buffer before calling this function.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KEY_SETSECASIDX</span>(p, m, r, s, d, ifi, idx) \
<span class="enscript-keyword">do</span> { \
<span class="enscript-function-name">bzero</span>((idx), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasindex));                             \
(idx)-&gt;proto = (p);                                                  \
(idx)-&gt;mode = (m);                                                   \
(idx)-&gt;reqid = (r);                                                  \
<span class="enscript-function-name">bcopy</span>((s), &amp;(idx)-&gt;src, ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *)(s))-&gt;sa_len);           \
<span class="enscript-function-name">bcopy</span>((d), &amp;(idx)-&gt;dst, ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *)(d))-&gt;sa_len);           \
(idx)-&gt;ipsec_ifindex = (ifi);										\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* key statistics */</span>
<span class="enscript-type">struct</span> _keystat {
	u_int32_t getspi_count; <span class="enscript-comment">/* the avarage of count to try to get new SPI */</span>
} keystat;

<span class="enscript-type">struct</span> sadb_msghdr {
	<span class="enscript-type">struct</span> sadb_msg *msg;
	<span class="enscript-type">struct</span> sadb_ext *ext[SADB_EXT_MAX + 1];
	<span class="enscript-type">int</span> extoff[SADB_EXT_MAX + 1];
	<span class="enscript-type">int</span> extlen[SADB_EXT_MAX + 1];
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *<span class="enscript-function-name">__key_getspbyid</span>(u_int32_t id);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_do_allocsa_policy</span>(<span class="enscript-type">struct</span> secashead *, u_int, u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_do_get_translated_port</span>(<span class="enscript-type">struct</span> secashead *, <span class="enscript-type">struct</span> secasvar *, u_int);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">key_delsp</span>(<span class="enscript-type">struct</span> secpolicy *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *<span class="enscript-function-name">key_getsp</span>(<span class="enscript-type">struct</span> secpolicyindex *);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">key_newreqid</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_gather_mbuf</span>(<span class="enscript-type">struct</span> mbuf *,
									<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spdadd</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">key_getnewspid</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spddelete</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spddelete2</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spdenable</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spddisable</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spdget</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spdflush</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spddump</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setdumpsp</span>(<span class="enscript-type">struct</span> secpolicy *,
								  u_int8_t, u_int32_t, u_int32_t);
<span class="enscript-type">static</span> u_int <span class="enscript-function-name">key_getspreqmsglen</span>(<span class="enscript-type">struct</span> secpolicy *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_spdexpire</span>(<span class="enscript-type">struct</span> secpolicy *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secashead *<span class="enscript-function-name">key_newsah</span>(<span class="enscript-type">struct</span> secasindex *, ifnet_t, u_int, u_int8_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_newsav</span>(<span class="enscript-type">struct</span> mbuf *,
								   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *, <span class="enscript-type">struct</span> secashead *, <span class="enscript-type">int</span> *,
								   <span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secashead *<span class="enscript-function-name">key_getsah</span>(<span class="enscript-type">struct</span> secasindex *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_checkspidup</span>(<span class="enscript-type">struct</span> secasindex *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> key_setspi <span class="enscript-function-name">__P</span>((<span class="enscript-type">struct</span> secasvar *, u_int32_t));
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_getsavbyspi</span>(<span class="enscript-type">struct</span> secashead *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_setsaval</span>(<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">struct</span> mbuf *,
						<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_mature</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setdumpsa</span>(<span class="enscript-type">struct</span> secasvar *, u_int8_t,
								  u_int8_t, u_int32_t, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbmsg</span>(u_int8_t, u_int16_t, u_int8_t,
								   u_int32_t, pid_t, u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbsa</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbaddr</span>(u_int16_t,
									<span class="enscript-type">struct</span> sockaddr *, u_int8_t, u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbipsecif</span>(ifnet_t, ifnet_t, ifnet_t, <span class="enscript-type">int</span>);
#<span class="enscript-reference">if</span> 0
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbident</span>(u_int16_t, u_int16_t, caddr_t,
									 <span class="enscript-type">int</span>, u_int64_t);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbxsa2</span>(u_int8_t, u_int32_t, u_int32_t, u_int16_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_setsadbxpolicy</span>(u_int16_t, u_int8_t,
									   u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *<span class="enscript-function-name">key_newbuf</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, u_int);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_ismyaddr6</span>(<span class="enscript-type">struct</span> sockaddr_in6 *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">key_update_natt_keepalive_timestamp</span>(<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">struct</span> secasvar *);

<span class="enscript-comment">/* flags for key_cmpsaidx() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CMP_HEAD</span>	0x1	<span class="enscript-comment">/* protocol, addresses. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CMP_PORT</span>	0x2	<span class="enscript-comment">/* additionally HEAD, reqid, mode. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CMP_REQID</span>	0x4	<span class="enscript-comment">/* additionally HEAD, reqid. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CMP_MODE</span>        0x8       <span class="enscript-comment">/* additionally mode. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CMP_EXACTLY</span>	0xF	<span class="enscript-comment">/* all elements. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_cmpsaidx</span>(<span class="enscript-type">struct</span> secasindex *, <span class="enscript-type">struct</span> secasindex *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_cmpspidx_exactly</span>(<span class="enscript-type">struct</span> secpolicyindex *,
								<span class="enscript-type">struct</span> secpolicyindex *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_cmpspidx_withmask</span>(<span class="enscript-type">struct</span> secpolicyindex *,
								 <span class="enscript-type">struct</span> secpolicyindex *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_sockaddrcmp</span>(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_is_addr_in_range</span>(<span class="enscript-type">struct</span> sockaddr_storage *, <span class="enscript-type">struct</span> secpolicyaddrrange *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_bbcmp</span>(caddr_t, caddr_t, u_int);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">key_srandom</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> u_int16_t <span class="enscript-function-name">key_satype2proto</span>(u_int8_t);
<span class="enscript-type">static</span> u_int8_t <span class="enscript-function-name">key_proto2satype</span>(u_int16_t);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_getspi</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">key_do_getnewspi</span>(<span class="enscript-type">struct</span> sadb_spirange *, <span class="enscript-type">struct</span> secasindex *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_update</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_getsavbyseq</span>(<span class="enscript-type">struct</span> secashead *, u_int32_t);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_add</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_setident</span>(<span class="enscript-type">struct</span> secashead *, <span class="enscript-type">struct</span> mbuf *,
						<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_getmsgbuf_x1</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_delete</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_get</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">key_getcomb_setlifetime</span>(<span class="enscript-type">struct</span> sadb_comb *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_getcomb_esp</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_getcomb_ah</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_getcomb_ipcomp</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_getprop</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> secasindex *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_acquire</span>(<span class="enscript-type">struct</span> secasindex *, <span class="enscript-type">struct</span> secpolicy *);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *<span class="enscript-function-name">key_newacq</span>(<span class="enscript-type">struct</span> secasindex *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *<span class="enscript-function-name">key_getacq</span>(<span class="enscript-type">struct</span> secasindex *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *<span class="enscript-function-name">key_getacqbyseq</span>(u_int32_t);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secspacq *<span class="enscript-function-name">key_newspacq</span>(<span class="enscript-type">struct</span> secpolicyindex *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secspacq *<span class="enscript-function-name">key_getspacq</span>(<span class="enscript-type">struct</span> secpolicyindex *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_acquire2</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_register</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_expire</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_flush</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_dump</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_promisc</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
					   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_senderror</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_validate_ext</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_ext *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_align</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">key_alloc_mbuf</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_getsastat</span> (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_migrate</span> (<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_setsaval2</span>(<span class="enscript-type">struct</span> secasvar      *sav,
						 u_int8_t              satype,
						 u_int8_t              alg_auth,
						 u_int8_t              alg_enc,
						 u_int32_t             flags,
						 u_int8_t              replay,
						 <span class="enscript-type">struct</span> sadb_key      *key_auth,
						 u_int16_t             key_auth_len,
						 <span class="enscript-type">struct</span> sadb_key      *key_enc,
						 u_int16_t             key_enc_len,
						 u_int16_t             natt_port,
						 u_int32_t             seq,
						 u_int32_t             spi,
						 u_int32_t             pid,
						 <span class="enscript-type">struct</span> sadb_lifetime *lifetime_hard,
						 <span class="enscript-type">struct</span> sadb_lifetime *lifetime_soft);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> esp_udp_encap_port;
<span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_send_natt_keepalive</span>(<span class="enscript-type">struct</span> secasvar *sav);
bool <span class="enscript-function-name">ipsec_fill_offload_frame</span>(ifnet_t ifp, <span class="enscript-type">struct</span> secasvar *sav, <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frame, size_t frame_data_offset);
u_int32_t <span class="enscript-function-name">key_fill_offload_frames_for_savs</span> (ifnet_t ifp, <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array, u_int32_t frames_array_count, size_t frame_data_offset);

<span class="enscript-type">void</span> <span class="enscript-function-name">key_init</span>(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);

<span class="enscript-comment">/*
 * PF_KEY init
 * setup locks, call raw_init(), and then init timer and associated data
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_init</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> key_initialized = 0;
	<span class="enscript-type">int</span> i;
	
	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	_CASSERT(PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) &lt;= _MHLEN);
	
	<span class="enscript-keyword">if</span> (key_initialized)
		<span class="enscript-keyword">return</span>;
	key_initialized = 1;

	sadb_mutex_grp_attr = lck_grp_attr_alloc_init();
	sadb_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;sadb&quot;</span>, sadb_mutex_grp_attr);
	sadb_mutex_attr = lck_attr_alloc_init();
	
	lck_mtx_init(sadb_mutex, sadb_mutex_grp, sadb_mutex_attr);

	pfkey_stat_mutex_grp_attr = lck_grp_attr_alloc_init();
	pfkey_stat_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;pfkey_stat&quot;</span>, pfkey_stat_mutex_grp_attr);
	pfkey_stat_mutex_attr = lck_attr_alloc_init();
	
	lck_mtx_init(pfkey_stat_mutex, pfkey_stat_mutex_grp, pfkey_stat_mutex_attr);
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; SPIHASHSIZE; i++)
		LIST_INIT(&amp;spihash[i]);
	
	raw_init(pp, dp);
	
	bzero((caddr_t)&amp;key_cb, <span class="enscript-keyword">sizeof</span>(key_cb));

	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPSEC_DIR_MAX; i++) {
		LIST_INIT(&amp;sptree[i]);
	}
	ipsec_policy_count = 0;
	
	LIST_INIT(&amp;sahtree);
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= SADB_SATYPE_MAX; i++) {
		LIST_INIT(&amp;regtree[i]);
	}
	ipsec_sav_count = 0;
	
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
	LIST_INIT(&amp;acqtree);
#<span class="enscript-reference">endif</span>
	LIST_INIT(&amp;spacqtree);
	
	<span class="enscript-comment">/* system default */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	ip4_def_policy.policy = IPSEC_POLICY_NONE;
	ip4_def_policy.refcnt++;	<span class="enscript-comment">/*never reclaim this*/</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	ip6_def_policy.policy = IPSEC_POLICY_NONE;
	ip6_def_policy.refcnt++;	<span class="enscript-comment">/*never reclaim this*/</span>
#<span class="enscript-reference">endif</span>
	
	key_timehandler_running = 0;
	
	<span class="enscript-comment">/* initialize key statistics */</span>
	keystat.getspi_count = 1;
	
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__APPLE__</span>
	printf(<span class="enscript-string">&quot;IPsec: Initialized Security Association Processing.\n&quot;</span>);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_start_timehandler</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* must be called while locked */</span>
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (key_timehandler_running == 0) {
		key_timehandler_running = 1;
		(<span class="enscript-type">void</span>)timeout((<span class="enscript-type">void</span> *)key_timehandler, (<span class="enscript-type">void</span> *)0, hz);
	}
	
	<span class="enscript-comment">/* Turn off the ipsec bypass */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		ipsec_bypass = 0;
}

<span class="enscript-comment">/* %%% IPsec policy management */</span>
<span class="enscript-comment">/*
 * allocating a SP for OUTBOUND or INBOUND packet.
 * Must call key_freesp() later.
 * OUT:	NULL:	not found
 *	others:	found and return the pointer.
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_allocsp</span>(
			<span class="enscript-type">struct</span> secpolicyindex *spidx,
			u_int dir)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">struct</span> timeval tv;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (spidx == NULL)
		panic(<span class="enscript-string">&quot;key_allocsp: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* check direction */</span>
	<span class="enscript-keyword">switch</span> (dir) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;key_allocsp: Invalid direction is passed.\n&quot;</span>);
	}
	
	<span class="enscript-comment">/* get a SP entry */</span>
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
			 printf(<span class="enscript-string">&quot;*** objects\n&quot;</span>);
			 kdebug_secpolicyindex(spidx));
	
	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sp, &amp;sptree[dir], chain) {
		KEYDEBUG(KEYDEBUG_IPSEC_DATA,
				 printf(<span class="enscript-string">&quot;*** in SPD\n&quot;</span>);
				 kdebug_secpolicyindex(&amp;sp-&gt;spidx));
		
		<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* If the policy is disabled, skip */</span>
		<span class="enscript-keyword">if</span> (sp-&gt;disabled &gt; 0)
			<span class="enscript-keyword">continue</span>;
        
        <span class="enscript-comment">/* If the incoming spidx specifies bound if,
         ignore unbound policies*/</span>
        <span class="enscript-keyword">if</span> (spidx-&gt;internal_if != NULL
            &amp;&amp; (sp-&gt;spidx.internal_if == NULL || sp-&gt;ipsec_if == NULL))
            <span class="enscript-keyword">continue</span>;
        
		<span class="enscript-keyword">if</span> (key_cmpspidx_withmask(&amp;sp-&gt;spidx, spidx))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
	
<span class="enscript-reference">found</span>:
	
	<span class="enscript-comment">/* found a SPD entry */</span>
	microtime(&amp;tv);
	sp-&gt;lastused = tv.tv_sec;
	sp-&gt;refcnt++;
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-comment">/* sanity check */</span>
	KEY_CHKSPDIR(sp-&gt;spidx.dir, dir, <span class="enscript-string">&quot;key_allocsp&quot;</span>);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP key_allocsp cause refcnt++:%d SP:0x%llx\n&quot;</span>,
	    sp-&gt;refcnt, (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	<span class="enscript-keyword">return</span> sp;
}

<span class="enscript-comment">/*
 * return a policy that matches this particular inbound packet.
 * XXX slow
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_gettunnel</span>(
			  <span class="enscript-type">struct</span> sockaddr *osrc,
			  <span class="enscript-type">struct</span> sockaddr *odst,
			  <span class="enscript-type">struct</span> sockaddr *isrc,
			  <span class="enscript-type">struct</span> sockaddr *idst)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> dir = IPSEC_DIR_INBOUND;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">struct</span> ipsecrequest *r1, *r2, *p;
	<span class="enscript-type">struct</span> sockaddr *os, *od, *is, *id;
	<span class="enscript-type">struct</span> secpolicyindex spidx;
	
	<span class="enscript-keyword">if</span> (isrc-&gt;sa_family != idst-&gt;sa_family) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;protocol family mismatched %d != %d\n.&quot;</span>,
				  isrc-&gt;sa_family, idst-&gt;sa_family));
		<span class="enscript-keyword">return</span> NULL;
	}
	
	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sp, &amp;sptree[dir], chain) {
		<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		
		r1 = r2 = NULL;
		<span class="enscript-keyword">for</span> (p = sp-&gt;req; p; p = p-&gt;next) {
			<span class="enscript-keyword">if</span> (p-&gt;saidx.mode != IPSEC_MODE_TUNNEL)
				<span class="enscript-keyword">continue</span>;
			
			r1 = r2;
			r2 = p;
			
			<span class="enscript-keyword">if</span> (!r1) {
				<span class="enscript-comment">/* here we look at address matches only */</span>
				spidx = sp-&gt;spidx;
				<span class="enscript-keyword">if</span> (isrc-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span>(spidx.src) ||
				    idst-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span>(spidx.dst))
					<span class="enscript-keyword">continue</span>;
				bcopy(isrc, &amp;spidx.src, isrc-&gt;sa_len);
				bcopy(idst, &amp;spidx.dst, idst-&gt;sa_len);
				<span class="enscript-keyword">if</span> (!key_cmpspidx_withmask(&amp;sp-&gt;spidx, &amp;spidx))
					<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span> {
				is = (<span class="enscript-type">struct</span> sockaddr *)&amp;r1-&gt;saidx.src;
				id = (<span class="enscript-type">struct</span> sockaddr *)&amp;r1-&gt;saidx.dst;
				<span class="enscript-keyword">if</span> (key_sockaddrcmp(is, isrc, 0) ||
				    key_sockaddrcmp(id, idst, 0))
					<span class="enscript-keyword">continue</span>;
			}
			
			os = (<span class="enscript-type">struct</span> sockaddr *)&amp;r2-&gt;saidx.src;
			od = (<span class="enscript-type">struct</span> sockaddr *)&amp;r2-&gt;saidx.dst;
			<span class="enscript-keyword">if</span> (key_sockaddrcmp(os, osrc, 0) ||
			    key_sockaddrcmp(od, odst, 0))
				<span class="enscript-keyword">continue</span>;
			
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
	
<span class="enscript-reference">found</span>:
	microtime(&amp;tv);
	sp-&gt;lastused = tv.tv_sec;
	sp-&gt;refcnt++;
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> sp;
}

<span class="enscript-type">struct</span> secasvar *<span class="enscript-function-name">key_alloc_outbound_sav_for_interface</span>(ifnet_t interface, <span class="enscript-type">int</span> family)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int stateidx;
	u_int state;
	<span class="enscript-type">const</span> u_int *saorder_state_valid;
	<span class="enscript-type">int</span> arraysize;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	u_int16_t dstport;
    
	<span class="enscript-keyword">if</span> (interface == NULL)
        <span class="enscript-keyword">return</span> NULL;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	lck_mtx_lock(sadb_mutex);
	
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;ipsec_if == interface &amp;&amp;
			(family == AF_INET6 || family == AF_INET) &amp;&amp;
			sah-&gt;dir == IPSEC_DIR_OUTBOUND) {
			<span class="enscript-comment">/* This SAH is linked to the IPSec interface, and the right family. We found it! */</span>
			<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
				saorder_state_valid = saorder_state_valid_prefer_old;
				arraysize = _ARRAYLEN(saorder_state_valid_prefer_old);
			} <span class="enscript-keyword">else</span> {
				saorder_state_valid = saorder_state_valid_prefer_new;
				arraysize = _ARRAYLEN(saorder_state_valid_prefer_new);
			}
			
			sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;sah-&gt;saidx.dst;
			dstport = sin-&gt;sin_port;
			<span class="enscript-keyword">if</span> (sah-&gt;saidx.mode == IPSEC_MODE_TRANSPORT)
				sin-&gt;sin_port = IPSEC_PORT_ANY;
			
			<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; arraysize; stateidx++) {
				state = saorder_state_valid[stateidx];
				sav = key_do_allocsa_policy(sah, state, dstport);
				<span class="enscript-keyword">if</span> (sav != NULL) {
					lck_mtx_unlock(sadb_mutex);
					<span class="enscript-keyword">return</span> sav;
				}
			}
			
			<span class="enscript-keyword">break</span>;
		}
	}
	
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * allocating an SA entry for an *OUTBOUND* packet.
 * checking each request entries in SP, and acquire an SA if need.
 * OUT:	0: there are valid requests.
 *	ENOENT: policy may be valid, but SA with REQUIRE is on acquiring.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_checkrequest</span>(
				 <span class="enscript-type">struct</span> ipsecrequest *isr,
				 <span class="enscript-type">struct</span> secasindex *saidx,
				 <span class="enscript-type">struct</span> secasvar **sav)
{
	u_int level;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	*sav = NULL;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (isr == NULL || saidx == NULL)
		panic(<span class="enscript-string">&quot;key_checkrequest: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* check mode */</span>
	<span class="enscript-keyword">switch</span> (saidx-&gt;mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_TRANSPORT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_TUNNEL</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_ANY</span>:
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;key_checkrequest: Invalid policy defined.\n&quot;</span>);
	}
	
	<span class="enscript-comment">/* get current level */</span>
	level = ipsec_get_reqlevel(isr);
	
	
	<span class="enscript-comment">/*
	 * key_allocsa_policy should allocate the oldest SA available.
	 * See key_do_allocsa_policy(), and draft-jenkins-ipsec-rekeying-03.txt.
	 */</span>
	<span class="enscript-keyword">if</span> (*sav == NULL)
		*sav = key_allocsa_policy(saidx);
	
	<span class="enscript-comment">/* When there is SA. */</span>
	<span class="enscript-keyword">if</span> (*sav != NULL)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-comment">/* There is no SA.
	 *
	 * Remove dst port - used for special natt support - don't call
	 * key_acquire with it.
	 */</span>
	<span class="enscript-keyword">if</span> (saidx-&gt;mode == IPSEC_MODE_TRANSPORT) {
		sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx-&gt;dst;
		sin-&gt;sin_port = IPSEC_PORT_ANY;
	}
	<span class="enscript-keyword">if</span> ((error = key_acquire(saidx, isr-&gt;sp)) != 0) {
		<span class="enscript-comment">/* XXX What should I do ? */</span>
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_checkrequest: error %d returned &quot;</span>
				  <span class="enscript-string">&quot;from key_acquire.\n&quot;</span>, error));
		<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-keyword">return</span> level == IPSEC_LEVEL_REQUIRE ? ENOENT : 0;
}

<span class="enscript-comment">/*
 * allocating a SA for policy entry from SAD.
 * NOTE: searching SAD of aliving state.
 * OUT:	NULL:	not found.
 *	others:	found and return the pointer.
 */</span>
u_int32_t sah_search_calls = 0;
u_int32_t sah_search_count = 0;
<span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_allocsa_policy</span>(
				   <span class="enscript-type">struct</span> secasindex *saidx)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int stateidx, state;
	<span class="enscript-type">const</span> u_int *saorder_state_valid;
	<span class="enscript-type">int</span> arraysize;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	u_int16_t	dstport;
	
	lck_mtx_lock(sadb_mutex);
	sah_search_calls++;
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		sah_search_count++;
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, saidx, CMP_MODE | CMP_REQID))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
	
<span class="enscript-reference">found</span>:
	
	<span class="enscript-comment">/*
	 * search a valid state list for outbound packet.
	 * This search order is important.
	 */</span>
	<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
		saorder_state_valid = saorder_state_valid_prefer_old;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_old);
	} <span class="enscript-keyword">else</span> {
		saorder_state_valid = saorder_state_valid_prefer_new;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_new);
	}
	
	
	sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx-&gt;dst;
	dstport = sin-&gt;sin_port;
	<span class="enscript-keyword">if</span> (saidx-&gt;mode == IPSEC_MODE_TRANSPORT)
		sin-&gt;sin_port = IPSEC_PORT_ANY;
	
	<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; arraysize; stateidx++) {
		
		state = saorder_state_valid[stateidx];
		
		sav = key_do_allocsa_policy(sah, state, dstport);
		<span class="enscript-keyword">if</span> (sav != NULL) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> sav;
		}
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_send_delete</span> (<span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">struct</span> mbuf *m, *result;
	u_int8_t satype;
	
	key_sa_chgstate(sav, SADB_SASTATE_DEAD);
	
	<span class="enscript-keyword">if</span> ((satype = key_proto2satype(sav-&gt;sah-&gt;saidx.proto)) == 0)
		panic(<span class="enscript-string">&quot;key_do_allocsa_policy: invalid proto is passed.\n&quot;</span>);
	
	m = key_setsadbmsg(SADB_DELETE, 0,
					   satype, 0, 0, sav-&gt;refcnt - 1);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
	result = m;
	
	<span class="enscript-comment">/* set sadb_address for saidx's. */</span>
	m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src,
						sav-&gt;sah-&gt;saidx.src.ss_len &lt;&lt; 3,
						IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
	m_cat(result, m);
	
	<span class="enscript-comment">/* set sadb_address for saidx's. */</span>
	m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst,
						sav-&gt;sah-&gt;saidx.src.ss_len &lt;&lt; 3,
						IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
	m_cat(result, m);
	
	<span class="enscript-comment">/* create SA extension */</span>
	m = key_setsadbsa(sav);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
	m_cat(result, m);
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result,
						  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">if</span> (key_sendup_mbuf(NULL, result,
						KEY_SENDUP_REGISTERED))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgfail</span>;
<span class="enscript-reference">msgfail</span>:
	key_freesav(sav, KEY_SADB_LOCKED);
}

<span class="enscript-comment">/*
 * searching SAD with direction, protocol, mode and state.
 * called by key_allocsa_policy().
 * OUT:
 *	NULL	: not found
 *	others	: found, pointer to a SA.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_do_allocsa_policy</span>(
					  <span class="enscript-type">struct</span> secashead *sah,
					  u_int state,
					  u_int16_t dstport)
{
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav, *candidate, *natt_candidate, *no_natt_candidate, *d;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* initialize */</span>
	candidate = NULL;
	natt_candidate = NULL;
	no_natt_candidate = NULL;
	
	<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[state]);
	     sav != NULL;
	     sav = nextsav) {
		
		nextsav = LIST_NEXT(sav, chain);
		
		<span class="enscript-comment">/* sanity check */</span>
		KEY_CHKSASTATE(sav-&gt;state, state, <span class="enscript-string">&quot;key_do_allocsa_policy&quot;</span>);
		
		<span class="enscript-keyword">if</span> (sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL &amp;&amp; dstport &amp;&amp;
		    ((sav-&gt;flags &amp; SADB_X_EXT_NATT) != 0) &amp;&amp;
		    ntohs(dstport) != sav-&gt;remote_ike_port)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (sah-&gt;saidx.mode == IPSEC_MODE_TRANSPORT &amp;&amp;
		    ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0) &amp;&amp;
		    ntohs(dstport) != sav-&gt;remote_ike_port)
			<span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* skip this one - not a match - or not UDP */</span>
		
		<span class="enscript-keyword">if</span> ((sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL &amp;&amp;
		     ((sav-&gt;flags &amp; SADB_X_EXT_NATT) != 0)) ||
		    (sah-&gt;saidx.mode == IPSEC_MODE_TRANSPORT &amp;&amp;
		     ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0))) {
				<span class="enscript-keyword">if</span> (natt_candidate == NULL) {
					natt_candidate = sav;
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span>
					candidate = natt_candidate;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (no_natt_candidate == NULL) {
					no_natt_candidate = sav;
					<span class="enscript-keyword">continue</span>;
				} <span class="enscript-keyword">else</span>
					candidate = no_natt_candidate;
			}
		
		<span class="enscript-comment">/* Which SA is the better ? */</span>
		
		<span class="enscript-comment">/* sanity check 2 */</span>
		<span class="enscript-keyword">if</span> (candidate-&gt;lft_c == NULL || sav-&gt;lft_c == NULL)
			panic(<span class="enscript-string">&quot;key_do_allocsa_policy: &quot;</span>
				  <span class="enscript-string">&quot;lifetime_current is NULL.\n&quot;</span>);
		
		<span class="enscript-comment">/* What the best method is to compare ? */</span>
		<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
			<span class="enscript-keyword">if</span> (candidate-&gt;lft_c-&gt;sadb_lifetime_addtime &gt;
				sav-&gt;lft_c-&gt;sadb_lifetime_addtime) {
				<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0)
					natt_candidate = sav;
				<span class="enscript-keyword">else</span>
					no_natt_candidate = sav;
			}
			<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/*NOTREACHED*/</span>
		}
		
		<span class="enscript-comment">/* prefered new sa rather than old sa */</span>
		<span class="enscript-keyword">if</span> (candidate-&gt;lft_c-&gt;sadb_lifetime_addtime &lt;
			sav-&gt;lft_c-&gt;sadb_lifetime_addtime) {
			d = candidate;
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0)
				natt_candidate = sav;
			<span class="enscript-keyword">else</span>
				no_natt_candidate = sav;
		} <span class="enscript-keyword">else</span>
			d = sav;
		
		<span class="enscript-comment">/*
		 * prepared to delete the SA when there is more
		 * suitable candidate and the lifetime of the SA is not
		 * permanent.
		 */</span>
		<span class="enscript-keyword">if</span> (d-&gt;lft_c-&gt;sadb_lifetime_addtime != 0) {
			key_send_delete(d);
		}
	}
	
	<span class="enscript-comment">/* choose latest if both types present */</span>
	<span class="enscript-keyword">if</span> (natt_candidate == NULL)
		candidate = no_natt_candidate;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (no_natt_candidate == NULL)
		candidate = natt_candidate;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL &amp;&amp; dstport)
		candidate = natt_candidate;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (natt_candidate-&gt;lft_c-&gt;sadb_lifetime_addtime &gt;
			 no_natt_candidate-&gt;lft_c-&gt;sadb_lifetime_addtime)
		candidate = natt_candidate;
	<span class="enscript-keyword">else</span>
		candidate = no_natt_candidate;
	
	<span class="enscript-keyword">if</span> (candidate) {
		candidate-&gt;refcnt++;
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
		    printf(<span class="enscript-string">&quot;DP allocsa_policy cause &quot;</span>
		    <span class="enscript-string">&quot;refcnt++:%d SA:0x%llx\n&quot;</span>, candidate-&gt;refcnt,
		    (uint64_t)VM_KERNEL_ADDRPERM(candidate)));
	}
	<span class="enscript-keyword">return</span> candidate;
}

<span class="enscript-comment">/*
 * allocating a SA entry for a *INBOUND* packet.
 * Must call key_freesav() later.
 * OUT: positive:	pointer to a sav.
 *	NULL:		not found, or error occurred.
 *
 * In the comparison, source address will be ignored for RFC2401 conformance.
 * To quote, from section 4.1:
 *	A security association is uniquely identified by a triple consisting
 *	of a Security Parameter Index (SPI), an IP Destination Address, and a
 *	security protocol (AH or ESP) identifier.
 * Note that, however, we do need to keep source address in IPsec SA.
 * IKE specification and PF_KEY specification do assume that we
 * keep source address in IPsec SA.  We see a tricky situation here.
 */</span>
<span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_allocsa</span>(
			u_int family,
			caddr_t src,
			caddr_t dst,
			u_int proto,
			u_int32_t spi)
{
	<span class="enscript-type">struct</span> secasvar *sav, *match;
	u_int stateidx, state, tmpidx, matchidx;
	<span class="enscript-type">struct</span> sockaddr_in sin;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">const</span> u_int *saorder_state_valid;
	<span class="enscript-type">int</span> arraysize;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (src == NULL || dst == NULL)
		panic(<span class="enscript-string">&quot;key_allocsa: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/*
	 * when both systems employ similar strategy to use a SA.
	 * the search order is important even in the inbound case.
	 */</span>
	<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
		saorder_state_valid = saorder_state_valid_prefer_old;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_old);
	} <span class="enscript-keyword">else</span> {
		saorder_state_valid = saorder_state_valid_prefer_new;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_new);
	}
	
	<span class="enscript-comment">/*
	 * searching SAD.
	 * XXX: to be checked internal IP header somewhere.  Also when
	 * IPsec tunnel packet is received.  But ESP tunnel mode is
	 * encrypted so we can't check internal IP header.
	 */</span>
	<span class="enscript-comment">/*
	 * search a valid state list for inbound packet.
	 * the search order is not important.
	 */</span>
	match = NULL;
	matchidx = arraysize;
	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sav, &amp;spihash[SPIHASH(spi)], spihash) {
		<span class="enscript-keyword">if</span> (sav-&gt;spi != spi)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (proto != sav-&gt;sah-&gt;saidx.proto)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (family != sav-&gt;sah-&gt;saidx.src.ss_family ||
		    family != sav-&gt;sah-&gt;saidx.dst.ss_family)
			<span class="enscript-keyword">continue</span>;
		tmpidx = arraysize;
		<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; matchidx; stateidx++) {
			state = saorder_state_valid[stateidx];
			<span class="enscript-keyword">if</span> (sav-&gt;state == state) {
				tmpidx = stateidx;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (tmpidx &gt;= matchidx)
			<span class="enscript-keyword">continue</span>;
		
#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* don't check src */</span>
		<span class="enscript-comment">/* check src address */</span>
		<span class="enscript-keyword">switch</span> (family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				bzero(&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
				sin.sin_family = AF_INET;
				sin.sin_len = <span class="enscript-keyword">sizeof</span>(sin);
				bcopy(src, &amp;sin.sin_addr,
					  <span class="enscript-keyword">sizeof</span>(sin.sin_addr));
				<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr*)&amp;sin,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src, 0) != 0)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span>(sin6));
				sin6.sin6_family = AF_INET6;
				sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(sin6);
				bcopy(src, &amp;sin6.sin6_addr,
					  <span class="enscript-keyword">sizeof</span>(sin6.sin6_addr));
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6.sin6_addr)) {
					<span class="enscript-comment">/* kame fake scopeid */</span>
					sin6.sin6_scope_id =
					ntohs(sin6.sin6_addr.s6_addr16[1]);
					sin6.sin6_addr.s6_addr16[1] = 0;
				}
				<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr*)&amp;sin6,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src, 0) != 0)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_allocsa: &quot;</span>
						  <span class="enscript-string">&quot;unknown address family=%d.\n&quot;</span>,
						  family));
				<span class="enscript-keyword">continue</span>;
		}
		
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* check dst address */</span>
		<span class="enscript-keyword">switch</span> (family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				bzero(&amp;sin, <span class="enscript-keyword">sizeof</span>(sin));
				sin.sin_family = AF_INET;
				sin.sin_len = <span class="enscript-keyword">sizeof</span>(sin);
				bcopy(dst, &amp;sin.sin_addr,
					  <span class="enscript-keyword">sizeof</span>(sin.sin_addr));
				<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr*)&amp;sin,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst, 0) != 0)
					<span class="enscript-keyword">continue</span>;
				
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span>(sin6));
				sin6.sin6_family = AF_INET6;
				sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(sin6);
				bcopy(dst, &amp;sin6.sin6_addr,
					  <span class="enscript-keyword">sizeof</span>(sin6.sin6_addr));
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6.sin6_addr)) {
					<span class="enscript-comment">/* kame fake scopeid */</span>
					sin6.sin6_scope_id =
					ntohs(sin6.sin6_addr.s6_addr16[1]);
					sin6.sin6_addr.s6_addr16[1] = 0;
				}
				<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr*)&amp;sin6,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst, 0) != 0)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_allocsa: &quot;</span>
						  <span class="enscript-string">&quot;unknown address family=%d.\n&quot;</span>, family));
				<span class="enscript-keyword">continue</span>;
		}
		
		match = sav;
		matchidx = tmpidx;
	}
	<span class="enscript-keyword">if</span> (match)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	
	<span class="enscript-comment">/* not found */</span>
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> NULL;
	
<span class="enscript-reference">found</span>:
	match-&gt;refcnt++;
	lck_mtx_unlock(sadb_mutex);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP allocsa cause refcnt++:%d SA:0x%llx\n&quot;</span>,
	    match-&gt;refcnt, (uint64_t)VM_KERNEL_ADDRPERM(match)));
	<span class="enscript-keyword">return</span> match;
}

u_int16_t
<span class="enscript-function-name">key_natt_get_translated_port</span>(
							 <span class="enscript-type">struct</span> secasvar *outsav)
{
	
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	u_int stateidx, state;
	<span class="enscript-type">const</span> u_int *saorder_state_valid;
	<span class="enscript-type">int</span> arraysize;
	
	<span class="enscript-comment">/* get sa for incoming */</span>
	saidx.mode = outsav-&gt;sah-&gt;saidx.mode;
	saidx.reqid = 0;
	saidx.proto = outsav-&gt;sah-&gt;saidx.proto;
	bcopy(&amp;outsav-&gt;sah-&gt;saidx.src, &amp;saidx.dst, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
	bcopy(&amp;outsav-&gt;sah-&gt;saidx.dst, &amp;saidx.src, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
	
	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx, CMP_MODE))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">found</span>:
	<span class="enscript-comment">/*
	 * Found sah - now go thru list of SAs and find
	 * matching remote ike port.  If found - set
	 * sav-&gt;natt_encapsulated_src_port and return the port.
	 */</span>
	<span class="enscript-comment">/*
	 * search a valid state list for outbound packet.
	 * This search order is important.
	 */</span>
	<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
		saorder_state_valid = saorder_state_valid_prefer_old;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_old);
	} <span class="enscript-keyword">else</span> {
		saorder_state_valid = saorder_state_valid_prefer_new;
		arraysize = _ARRAYLEN(saorder_state_valid_prefer_new);
	}
	
	<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; arraysize; stateidx++) {
		state = saorder_state_valid[stateidx];
		<span class="enscript-keyword">if</span> (key_do_get_translated_port(sah, outsav, state)) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> outsav-&gt;natt_encapsulated_src_port;
		}
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_do_get_translated_port</span>(
						   <span class="enscript-type">struct</span> secashead *sah,
						   <span class="enscript-type">struct</span> secasvar *outsav,
						   u_int state)
{
	<span class="enscript-type">struct</span> secasvar *currsav, *nextsav, *candidate;
	
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* initilize */</span>
	candidate = NULL;
	
	<span class="enscript-keyword">for</span> (currsav = LIST_FIRST(&amp;sah-&gt;savtree[state]);
	     currsav != NULL;
	     currsav = nextsav) {
		
		nextsav = LIST_NEXT(currsav, chain);
		
		<span class="enscript-comment">/* sanity check */</span>
		KEY_CHKSASTATE(currsav-&gt;state, state, <span class="enscript-string">&quot;key_do_get_translated_port&quot;</span>);
		
		<span class="enscript-keyword">if</span> ((currsav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) == 0 ||
			currsav-&gt;remote_ike_port != outsav-&gt;remote_ike_port)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (candidate == NULL) {
			candidate = currsav;
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-comment">/* Which SA is the better ? */</span>
		
		<span class="enscript-comment">/* sanity check 2 */</span>
		<span class="enscript-keyword">if</span> (candidate-&gt;lft_c == NULL || currsav-&gt;lft_c == NULL)
			panic(<span class="enscript-string">&quot;key_do_get_translated_port: &quot;</span>
				  <span class="enscript-string">&quot;lifetime_current is NULL.\n&quot;</span>);
		
		<span class="enscript-comment">/* What the best method is to compare ? */</span>
		<span class="enscript-keyword">if</span> (key_preferred_oldsa) {
			<span class="enscript-keyword">if</span> (candidate-&gt;lft_c-&gt;sadb_lifetime_addtime &gt;
				currsav-&gt;lft_c-&gt;sadb_lifetime_addtime) {
				candidate = currsav;
			}
			<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/*NOTREACHED*/</span>
		}
		
		<span class="enscript-comment">/* prefered new sa rather than old sa */</span>
		<span class="enscript-keyword">if</span> (candidate-&gt;lft_c-&gt;sadb_lifetime_addtime &lt;
			currsav-&gt;lft_c-&gt;sadb_lifetime_addtime)
			candidate = currsav;
	}
	
	<span class="enscript-keyword">if</span> (candidate) {
		outsav-&gt;natt_encapsulated_src_port = candidate-&gt;natt_encapsulated_src_port;
		<span class="enscript-keyword">return</span> 1;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Must be called after calling key_allocsp().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_freesp</span>(
		   <span class="enscript-type">struct</span> secpolicy *sp,
		   <span class="enscript-type">int</span> locked)
{
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sp == NULL)
		panic(<span class="enscript-string">&quot;key_freesp: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	sp-&gt;refcnt--;
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP freesp cause refcnt--:%d SP:0x%llx\n&quot;</span>,
	    sp-&gt;refcnt, (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	
	<span class="enscript-keyword">if</span> (sp-&gt;refcnt == 0)
		key_delsp(sp);
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Must be called after calling key_allocsa().
 * This function is called by key_freesp() to free some SA allocated
 * for a policy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_freesav</span>(
			<span class="enscript-type">struct</span> secasvar *sav,
			<span class="enscript-type">int</span> locked)
{
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;key_freesav: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	sav-&gt;refcnt--;
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP freesav cause refcnt--:%d SA:0x%llx SPI %u\n&quot;</span>,
	    sav-&gt;refcnt, (uint64_t)VM_KERNEL_ADDRPERM(sav),
	    (u_int32_t)ntohl(sav-&gt;spi)));
	
	<span class="enscript-keyword">if</span> (sav-&gt;refcnt == 0)
		key_delsav(sav);
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* %%% SPD management */</span>
<span class="enscript-comment">/*
 * free security policy entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_delsp</span>(
		  <span class="enscript-type">struct</span> secpolicy *sp)
{
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sp == NULL)
		panic(<span class="enscript-string">&quot;key_delsp: NULL pointer is passed.\n&quot;</span>);
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	sp-&gt;state = IPSEC_SPSTATE_DEAD;
	
	<span class="enscript-keyword">if</span> (sp-&gt;refcnt &gt; 0)
		<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* can't free */</span>
	
	<span class="enscript-comment">/* remove from SP index */</span>
	<span class="enscript-keyword">if</span> (__LIST_CHAINED(sp)) {
		LIST_REMOVE(sp, chain);
		ipsec_policy_count--;
	}
	
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.internal_if) {
        ifnet_release(sp-&gt;spidx.internal_if);
        sp-&gt;spidx.internal_if = NULL;
    }
    
    <span class="enscript-keyword">if</span> (sp-&gt;ipsec_if) {
        ifnet_release(sp-&gt;ipsec_if);
        sp-&gt;ipsec_if = NULL;
    }
    
    <span class="enscript-keyword">if</span> (sp-&gt;outgoing_if) {
        ifnet_release(sp-&gt;outgoing_if);
        sp-&gt;outgoing_if = NULL;
    }
	
    {
		<span class="enscript-type">struct</span> ipsecrequest *isr = sp-&gt;req, *nextisr;
		
		<span class="enscript-keyword">while</span> (isr != NULL) {
			nextisr = isr-&gt;next;
			KFREE(isr);
			isr = nextisr;
    	}
	}
	keydb_delsecpolicy(sp);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * search SPD
 * OUT:	NULL	: not found
 *	others	: found, pointer to a SP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_getsp</span>(
		  <span class="enscript-type">struct</span> secpolicyindex *spidx)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (spidx == NULL)
		panic(<span class="enscript-string">&quot;key_getsp: NULL pointer is passed.\n&quot;</span>);
	
	LIST_FOREACH(sp, &amp;sptree[spidx-&gt;dir], chain) {
		<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpspidx_exactly(spidx, &amp;sp-&gt;spidx)) {
			sp-&gt;refcnt++;
			<span class="enscript-keyword">return</span> sp;
		}
	}
	
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * get SP by index.
 * OUT:	NULL	: not found
 *	others	: found, pointer to a SP.
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_getspbyid</span>(
			  u_int32_t id)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
	
    lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
    
    lck_mtx_lock(sadb_mutex);
    sp = __key_getspbyid(id);
    lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">return</span> sp;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">__key_getspbyid</span>(u_int32_t id)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
    
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
    
	LIST_FOREACH(sp, &amp;sptree[IPSEC_DIR_INBOUND], chain) {
		<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (sp-&gt;id == id) {
			sp-&gt;refcnt++;
			<span class="enscript-keyword">return</span> sp;
		}
	}
    
	LIST_FOREACH(sp, &amp;sptree[IPSEC_DIR_OUTBOUND], chain) {
		<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (sp-&gt;id == id) {
			sp-&gt;refcnt++;
			<span class="enscript-keyword">return</span> sp;
		}
	}
    
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_newsp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> secpolicy *newsp = NULL;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	newsp = keydb_newsecpolicy();
	<span class="enscript-keyword">if</span> (!newsp)
		<span class="enscript-keyword">return</span> newsp;
	
	newsp-&gt;refcnt = 1;
	newsp-&gt;req = NULL;
	
	<span class="enscript-keyword">return</span> newsp;
}

<span class="enscript-comment">/*
 * create secpolicy structure from sadb_x_policy structure.
 * NOTE: `state', `secpolicyindex' in secpolicy structure are not set,
 * so must be set properly later.
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">key_msg2sp</span>(
		   <span class="enscript-type">struct</span> sadb_x_policy *xpl0,
		   size_t len,
		   <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> secpolicy *newsp;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (xpl0 == NULL)
		panic(<span class="enscript-string">&quot;key_msg2sp: NULL pointer was passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*xpl0))
		panic(<span class="enscript-string">&quot;key_msg2sp: invalid length.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (len != PFKEY_EXTLEN(xpl0)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: Invalid msg length.\n&quot;</span>));
		*error = EINVAL;
		<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-keyword">if</span> ((newsp = key_newsp()) == NULL) {
		*error = ENOBUFS;
		<span class="enscript-keyword">return</span> NULL;
	}
	
	newsp-&gt;spidx.dir = xpl0-&gt;sadb_x_policy_dir;
	newsp-&gt;policy = xpl0-&gt;sadb_x_policy_type;
	
	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (xpl0-&gt;sadb_x_policy_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
			newsp-&gt;req = NULL;
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
	    {
			<span class="enscript-type">int</span> tlen;
			<span class="enscript-type">struct</span> sadb_x_ipsecrequest *xisr;
			<span class="enscript-type">struct</span> ipsecrequest **p_isr = &amp;newsp-&gt;req;
			
			<span class="enscript-comment">/* validity check */</span>
			<span class="enscript-keyword">if</span> (PFKEY_EXTLEN(xpl0) &lt; <span class="enscript-keyword">sizeof</span>(*xpl0)) {
				ipseclog((LOG_DEBUG,
						  <span class="enscript-string">&quot;key_msg2sp: Invalid msg length.\n&quot;</span>));
				key_freesp(newsp, KEY_SADB_UNLOCKED);
				*error = EINVAL;
				<span class="enscript-keyword">return</span> NULL;
			}
			
			tlen = PFKEY_EXTLEN(xpl0) - <span class="enscript-keyword">sizeof</span>(*xpl0);
			xisr = (<span class="enscript-type">struct</span> sadb_x_ipsecrequest *)(xpl0 + 1);
			
			<span class="enscript-keyword">while</span> (tlen &gt; 0) {
				
				<span class="enscript-comment">/* length check */</span>
				<span class="enscript-keyword">if</span> (xisr-&gt;sadb_x_ipsecrequest_len &lt; <span class="enscript-keyword">sizeof</span>(*xisr)) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: &quot;</span>
							  <span class="enscript-string">&quot;invalid ipsecrequest length.\n&quot;</span>));
					key_freesp(newsp, KEY_SADB_UNLOCKED);
					*error = EINVAL;
					<span class="enscript-keyword">return</span> NULL;
				}
				
				<span class="enscript-comment">/* allocate request buffer */</span>
				KMALLOC_WAIT(*p_isr, <span class="enscript-type">struct</span> ipsecrequest *, <span class="enscript-keyword">sizeof</span>(**p_isr));
				<span class="enscript-keyword">if</span> ((*p_isr) == NULL) {
					ipseclog((LOG_DEBUG,
							  <span class="enscript-string">&quot;key_msg2sp: No more memory.\n&quot;</span>));
					key_freesp(newsp, KEY_SADB_UNLOCKED);
					*error = ENOBUFS;
					<span class="enscript-keyword">return</span> NULL;
				}
				bzero(*p_isr, <span class="enscript-keyword">sizeof</span>(**p_isr));
				
				<span class="enscript-comment">/* set values */</span>
				(*p_isr)-&gt;next = NULL;
				
				<span class="enscript-keyword">switch</span> (xisr-&gt;sadb_x_ipsecrequest_proto) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
						<span class="enscript-keyword">break</span>;
					<span class="enscript-reference">default</span>:
						ipseclog((LOG_DEBUG,
								  <span class="enscript-string">&quot;key_msg2sp: invalid proto type=%u\n&quot;</span>,
								  xisr-&gt;sadb_x_ipsecrequest_proto));
						key_freesp(newsp, KEY_SADB_UNLOCKED);
						*error = EPROTONOSUPPORT;
						<span class="enscript-keyword">return</span> NULL;
				}
				(*p_isr)-&gt;saidx.proto = xisr-&gt;sadb_x_ipsecrequest_proto;
				
				<span class="enscript-keyword">switch</span> (xisr-&gt;sadb_x_ipsecrequest_mode) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_TRANSPORT</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_TUNNEL</span>:
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_MODE_ANY</span>:
					<span class="enscript-reference">default</span>:
						ipseclog((LOG_DEBUG,
								  <span class="enscript-string">&quot;key_msg2sp: invalid mode=%u\n&quot;</span>,
								  xisr-&gt;sadb_x_ipsecrequest_mode));
						key_freesp(newsp, KEY_SADB_UNLOCKED);
						*error = EINVAL;
						<span class="enscript-keyword">return</span> NULL;
				}
				(*p_isr)-&gt;saidx.mode = xisr-&gt;sadb_x_ipsecrequest_mode;
				
				<span class="enscript-keyword">switch</span> (xisr-&gt;sadb_x_ipsecrequest_level) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_DEFAULT</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_USE</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_REQUIRE</span>:
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_UNIQUE</span>:
						<span class="enscript-comment">/* validity check */</span>
						<span class="enscript-comment">/*
						 * If range violation of reqid, kernel will
						 * update it, don't refuse it.
						 */</span>
						<span class="enscript-keyword">if</span> (xisr-&gt;sadb_x_ipsecrequest_reqid
							&gt; IPSEC_MANUAL_REQID_MAX) {
							ipseclog((LOG_DEBUG,
									  <span class="enscript-string">&quot;key_msg2sp: reqid=%d range &quot;</span>
									  <span class="enscript-string">&quot;violation, updated by kernel.\n&quot;</span>,
									  xisr-&gt;sadb_x_ipsecrequest_reqid));
							xisr-&gt;sadb_x_ipsecrequest_reqid = 0;
						}
						
						<span class="enscript-comment">/* allocate new reqid id if reqid is zero. */</span>
						<span class="enscript-keyword">if</span> (xisr-&gt;sadb_x_ipsecrequest_reqid == 0) {
							u_int32_t reqid;
							<span class="enscript-keyword">if</span> ((reqid = key_newreqid()) == 0) {
								key_freesp(newsp, KEY_SADB_UNLOCKED);
								*error = ENOBUFS;
								<span class="enscript-keyword">return</span> NULL;
							}
							(*p_isr)-&gt;saidx.reqid = reqid;
							xisr-&gt;sadb_x_ipsecrequest_reqid = reqid;
						} <span class="enscript-keyword">else</span> {
							<span class="enscript-comment">/* set it for manual keying. */</span>
							(*p_isr)-&gt;saidx.reqid =
							xisr-&gt;sadb_x_ipsecrequest_reqid;
						}
						<span class="enscript-keyword">break</span>;
						
					<span class="enscript-reference">default</span>:
						ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: invalid level=%u\n&quot;</span>,
								  xisr-&gt;sadb_x_ipsecrequest_level));
						key_freesp(newsp, KEY_SADB_UNLOCKED);
						*error = EINVAL;
						<span class="enscript-keyword">return</span> NULL;
				}
				(*p_isr)-&gt;level = xisr-&gt;sadb_x_ipsecrequest_level;
				
				<span class="enscript-comment">/* set IP addresses if there */</span>
				<span class="enscript-keyword">if</span> (xisr-&gt;sadb_x_ipsecrequest_len &gt; <span class="enscript-keyword">sizeof</span>(*xisr)) {
					<span class="enscript-type">struct</span> sockaddr *paddr;
					
					paddr = (<span class="enscript-type">struct</span> sockaddr *)(xisr + 1);
					
					<span class="enscript-comment">/* validity check */</span>
					<span class="enscript-keyword">if</span> (paddr-&gt;sa_len
						&gt; <span class="enscript-keyword">sizeof</span>((*p_isr)-&gt;saidx.src)) {
						ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: invalid request &quot;</span>
								  <span class="enscript-string">&quot;address length.\n&quot;</span>));
						key_freesp(newsp, KEY_SADB_UNLOCKED);
						*error = EINVAL;
						<span class="enscript-keyword">return</span> NULL;
					}
					bcopy(paddr, &amp;(*p_isr)-&gt;saidx.src,
						  paddr-&gt;sa_len);
					
					paddr = (<span class="enscript-type">struct</span> sockaddr *)((caddr_t)paddr
												+ paddr-&gt;sa_len);
					
					<span class="enscript-comment">/* validity check */</span>
					<span class="enscript-keyword">if</span> (paddr-&gt;sa_len
						&gt; <span class="enscript-keyword">sizeof</span>((*p_isr)-&gt;saidx.dst)) {
						ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: invalid request &quot;</span>
								  <span class="enscript-string">&quot;address length.\n&quot;</span>));
						key_freesp(newsp, KEY_SADB_UNLOCKED);
						*error = EINVAL;
						<span class="enscript-keyword">return</span> NULL;
					}
					bcopy(paddr, &amp;(*p_isr)-&gt;saidx.dst,
						  paddr-&gt;sa_len);
				}
				
				(*p_isr)-&gt;sp = newsp;
				
				<span class="enscript-comment">/* initialization for the next. */</span>
				p_isr = &amp;(*p_isr)-&gt;next;
				tlen -= xisr-&gt;sadb_x_ipsecrequest_len;
				
				<span class="enscript-comment">/* validity check */</span>
				<span class="enscript-keyword">if</span> (tlen &lt; 0) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: becoming tlen &lt; 0.\n&quot;</span>));
					key_freesp(newsp, KEY_SADB_UNLOCKED);
					*error = EINVAL;
					<span class="enscript-keyword">return</span> NULL;
				}
				
				xisr = (<span class="enscript-type">struct</span> sadb_x_ipsecrequest *)(<span class="enscript-type">void</span> *)
			    ((caddr_t)xisr + xisr-&gt;sadb_x_ipsecrequest_len);
			}
	    }
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_msg2sp: invalid policy type.\n&quot;</span>));
			key_freesp(newsp, KEY_SADB_UNLOCKED);
			*error = EINVAL;
			<span class="enscript-keyword">return</span> NULL;
	}
	
	*error = 0;
	<span class="enscript-keyword">return</span> newsp;
}

<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">key_newreqid</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-type">static</span> u_int32_t auto_reqid = IPSEC_MANUAL_REQID_MAX + 1;
	<span class="enscript-type">int</span> done = 0;
	
	<span class="enscript-comment">/* The reqid must be limited to 16 bits because the PF_KEY message format only uses
	 16 bits for this field.  Once it becomes larger than 16 bits - ipsec fails to
	 work anymore. Changing the PF_KEY message format would introduce compatibility
	 issues. This code now tests to see if the tentative reqid is in use */</span>
	
	<span class="enscript-keyword">while</span> (!done) {
		<span class="enscript-type">struct</span> secpolicy *sp;
		<span class="enscript-type">struct</span> ipsecrequest *isr;
		<span class="enscript-type">int</span> dir;
		
		auto_reqid = (auto_reqid == 0xFFFF
					  ? IPSEC_MANUAL_REQID_MAX + 1 : auto_reqid + 1);
		
		<span class="enscript-comment">/* check for uniqueness */</span>
		done = 1;
		<span class="enscript-keyword">for</span> (dir = 0; dir &lt; IPSEC_DIR_MAX; dir++) {
			LIST_FOREACH(sp, &amp;sptree[dir], chain) {
				<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {
					<span class="enscript-keyword">if</span> (isr-&gt;saidx.reqid == auto_reqid) {
						done = 0;
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">if</span> (done == 0)
					<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (done == 0)
				<span class="enscript-keyword">break</span>;
		}
	}
	
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> auto_reqid;
}

<span class="enscript-comment">/*
 * copy secpolicy struct to sadb_x_policy structure indicated.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_sp2msg</span>(
		   <span class="enscript-type">struct</span> secpolicy *sp)
{
	<span class="enscript-type">struct</span> sadb_x_policy *xpl;
	<span class="enscript-type">int</span> tlen;
	caddr_t p;
	<span class="enscript-type">struct</span> mbuf *m;
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (sp == NULL)
		panic(<span class="enscript-string">&quot;key_sp2msg: NULL pointer was passed.\n&quot;</span>);
	
	tlen = key_getspreqmsglen(sp);
	
	m = key_alloc_mbuf(tlen);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	m-&gt;m_len = tlen;
	m-&gt;m_next = NULL;
	xpl = mtod(m, <span class="enscript-type">struct</span> sadb_x_policy *);
	bzero(xpl, tlen);
	
	xpl-&gt;sadb_x_policy_len = PFKEY_UNIT64(tlen);
	xpl-&gt;sadb_x_policy_exttype = SADB_X_EXT_POLICY;
	xpl-&gt;sadb_x_policy_type = sp-&gt;policy;
	xpl-&gt;sadb_x_policy_dir = sp-&gt;spidx.dir;
	xpl-&gt;sadb_x_policy_id = sp-&gt;id;
	p = (caddr_t)xpl + <span class="enscript-keyword">sizeof</span>(*xpl);
	
	<span class="enscript-comment">/* if is the policy for ipsec ? */</span>
	<span class="enscript-keyword">if</span> (sp-&gt;policy == IPSEC_POLICY_IPSEC) {
		<span class="enscript-type">struct</span> sadb_x_ipsecrequest *xisr;
		<span class="enscript-type">struct</span> ipsecrequest *isr;
		
		<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {
			
			xisr = (<span class="enscript-type">struct</span> sadb_x_ipsecrequest *)(<span class="enscript-type">void</span> *)p;
			
			xisr-&gt;sadb_x_ipsecrequest_proto = isr-&gt;saidx.proto;
			xisr-&gt;sadb_x_ipsecrequest_mode = isr-&gt;saidx.mode;
			xisr-&gt;sadb_x_ipsecrequest_level = isr-&gt;level;
			xisr-&gt;sadb_x_ipsecrequest_reqid = isr-&gt;saidx.reqid;
			
			p += <span class="enscript-keyword">sizeof</span>(*xisr);
			bcopy(&amp;isr-&gt;saidx.src, p, isr-&gt;saidx.src.ss_len);
			p += isr-&gt;saidx.src.ss_len;
			bcopy(&amp;isr-&gt;saidx.dst, p, isr-&gt;saidx.dst.ss_len);
			p += isr-&gt;saidx.src.ss_len;
			
			xisr-&gt;sadb_x_ipsecrequest_len =
			PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*xisr)
						 + isr-&gt;saidx.src.ss_len
						 + isr-&gt;saidx.dst.ss_len);
		}
	}
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/* m will not be freed nor modified */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_gather_mbuf</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp,
				<span class="enscript-type">int</span> ndeep, <span class="enscript-type">int</span> nitem, <span class="enscript-type">int</span> *items)
{
	<span class="enscript-type">int</span> idx;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> mbuf *result = NULL, *n;
	<span class="enscript-type">int</span> len;
	
	<span class="enscript-keyword">if</span> (m == NULL || mhp == NULL)
		panic(<span class="enscript-string">&quot;null pointer passed to key_gather&quot;</span>);
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nitem; i++) {
		idx = items[i];
		<span class="enscript-keyword">if</span> (idx &lt; 0 || idx &gt; SADB_EXT_MAX)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		<span class="enscript-comment">/* don't attempt to pull empty extension */</span>
		<span class="enscript-keyword">if</span> (idx == SADB_EXT_RESERVED &amp;&amp; mhp-&gt;msg == NULL)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (idx != SADB_EXT_RESERVED  &amp;&amp;
		    (mhp-&gt;ext[idx] == NULL || mhp-&gt;extlen[idx] == 0))
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (idx == SADB_EXT_RESERVED) {
			len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			MGETHDR(n, M_WAITOK, MT_DATA); <span class="enscript-comment">// sadb_msg len &lt; MHLEN - enforced by _CASSERT
</span>			<span class="enscript-keyword">if</span> (!n)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			n-&gt;m_len = len;
			n-&gt;m_next = NULL;
			m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg),
					   mtod(n, caddr_t));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i &lt; ndeep) {
			len = mhp-&gt;extlen[idx];
			n = key_alloc_mbuf(len);
			<span class="enscript-keyword">if</span> (!n || n-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
				<span class="enscript-keyword">if</span> (n)
					m_freem(n);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			m_copydata(m, mhp-&gt;extoff[idx], mhp-&gt;extlen[idx],
					   mtod(n, caddr_t));
		} <span class="enscript-keyword">else</span> {
			n = m_copym(m, mhp-&gt;extoff[idx], mhp-&gt;extlen[idx],
						M_WAITOK);
		}
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		
		<span class="enscript-keyword">if</span> (result)
			m_cat(result, n);
		<span class="enscript-keyword">else</span>
			result = n;
	}
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) != 0) {
		result-&gt;m_pkthdr.len = 0;
		<span class="enscript-keyword">for</span> (n = result; n; n = n-&gt;m_next)
			result-&gt;m_pkthdr.len += n-&gt;m_len;
	}
	
	<span class="enscript-keyword">return</span> result;
	
<span class="enscript-reference">fail</span>:
	m_freem(result);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * SADB_X_SPDADD, SADB_X_SPDSETIDX or SADB_X_SPDUPDATE processing
 * add a entry to SP database, when received
 *   &lt;base, address(SD), (lifetime(H),) policy&gt;
 * from the user(?).
 * Adding to SP database,
 * and send
 *   &lt;base, address(SD), (lifetime(H),) policy&gt;
 * to the socket which was send.
 *
 * SPDADD set a unique policy entry.
 * SPDSETIDX like SPDADD without a part of policy requests.
 * SPDUPDATE replace a unique policy entry.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdadd</span>(
		   <span class="enscript-type">struct</span> socket *so,
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0, *src1, *dst1;
	<span class="enscript-type">struct</span> sadb_x_policy *xpl0, *xpl;
	<span class="enscript-type">struct</span> sadb_lifetime *lft = NULL;
	<span class="enscript-type">struct</span> secpolicyindex spidx;
	<span class="enscript-type">struct</span> secpolicy *newsp;
	<span class="enscript-type">struct</span> timeval tv;
    ifnet_t internal_if = NULL;
    <span class="enscript-type">char</span> *outgoing_if = NULL;
    <span class="enscript-type">char</span> *ipsec_if = NULL;
    <span class="enscript-type">struct</span> sadb_x_ipsecif *ipsecifopts = NULL;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> use_src_range = 0;
	<span class="enscript-type">int</span> use_dst_range = 0;
	<span class="enscript-type">int</span> init_disabled = 0;
	<span class="enscript-type">int</span> address_family, address_len;
    
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spdadd: NULL pointer is passed.\n&quot;</span>);
    
    <span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_START] != NULL &amp;&amp; mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_END] != NULL) {
        use_src_range = 1;
    }
    <span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_START] != NULL &amp;&amp; mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_END] != NULL) {
        use_dst_range = 1;
    }
    
	<span class="enscript-keyword">if</span> ((!use_src_range &amp;&amp; mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL) ||
        (!use_dst_range &amp;&amp; mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL) ||
	    mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> ((use_src_range &amp;&amp; (mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_SRC_START] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)
                           || mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_SRC_END] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address))) ||
        (!use_src_range &amp;&amp; mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) ||
        (use_dst_range &amp;&amp; (mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_DST_START] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)
                           || mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_DST_END] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address))) ||
        (!use_dst_range &amp;&amp; mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_LIFETIME_HARD] != NULL) {
		<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_LIFETIME_HARD]
			&lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: invalid message is passed.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
		lft = (<span class="enscript-type">struct</span> sadb_lifetime *)
		(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_LIFETIME_HARD];
	}
    <span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_IPSECIF] != NULL) {
        <span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_X_EXT_IPSECIF] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif)) {
            ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: invalid message is passed.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
        }
    }
	
    <span class="enscript-keyword">if</span> (use_src_range) {
        src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_START];
        src1 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_END];
    } <span class="enscript-keyword">else</span> {
        src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_SRC];
    }
    <span class="enscript-keyword">if</span> (use_dst_range) {
        dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_START];
        dst1 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_END];
    } <span class="enscript-keyword">else</span> {
        dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_DST];
    }
	xpl0 = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY];
    ipsecifopts = (<span class="enscript-type">struct</span> sadb_x_ipsecif *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_IPSECIF];
    
    <span class="enscript-comment">/* check addresses */</span>
    address_family = ((<span class="enscript-type">struct</span> sockaddr *)(src0 + 1))-&gt;sa_family;
    address_len = ((<span class="enscript-type">struct</span> sockaddr *)(src0 + 1))-&gt;sa_len;
    <span class="enscript-keyword">if</span> (use_src_range) {
        <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(src1+ 1))-&gt;sa_family != address_family ||
            ((<span class="enscript-type">struct</span> sockaddr *)(src1+ 1))-&gt;sa_len != address_len) {
            <span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
        }
    }
    <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(dst0+ 1))-&gt;sa_family != address_family ||
        ((<span class="enscript-type">struct</span> sockaddr *)(dst0+ 1))-&gt;sa_len != address_len) {
        <span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
    }
    <span class="enscript-keyword">if</span> (use_dst_range) {
        <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(dst1+ 1))-&gt;sa_family != address_family ||
            ((<span class="enscript-type">struct</span> sockaddr *)(dst1+ 1))-&gt;sa_len != address_len) {
            <span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
        }
    }
    
    <span class="enscript-comment">/* checking the direction. */</span>
	<span class="enscript-keyword">switch</span> (xpl0-&gt;sadb_x_policy_dir) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: Invalid SP direction.\n&quot;</span>));
            mhp-&gt;msg-&gt;sadb_msg_errno = EINVAL;
            <span class="enscript-keyword">return</span> 0;
	}
    
    <span class="enscript-comment">/* check policy */</span>
	<span class="enscript-comment">/* key_spdadd() accepts DISCARD, NONE and IPSEC. */</span>
	<span class="enscript-keyword">if</span> (xpl0-&gt;sadb_x_policy_type == IPSEC_POLICY_ENTRUST
        || xpl0-&gt;sadb_x_policy_type == IPSEC_POLICY_BYPASS) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: Invalid policy type.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
    
	<span class="enscript-comment">/* policy requests are mandatory when action is ipsec. */</span>
    <span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_type != SADB_X_SPDSETIDX
        &amp;&amp; xpl0-&gt;sadb_x_policy_type == IPSEC_POLICY_IPSEC
        &amp;&amp; mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt;= <span class="enscript-keyword">sizeof</span>(*xpl0)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: some policy requests part required.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
    
    <span class="enscript-comment">/* Process interfaces */</span>
    <span class="enscript-keyword">if</span> (ipsecifopts != NULL) {
        <span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_internal_if[0]) {
            ifnet_find_by_name(ipsecifopts-&gt;sadb_x_ipsecif_internal_if, &amp;internal_if);
        }
        <span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_outgoing_if[0]) {
            outgoing_if = ipsecifopts-&gt;sadb_x_ipsecif_outgoing_if;
        }
        <span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_ipsec_if[0]) {
            ipsec_if = ipsecifopts-&gt;sadb_x_ipsecif_ipsec_if;
        }
		init_disabled = ipsecifopts-&gt;sadb_x_ipsecif_init_disabled;
    }
	
	<span class="enscript-comment">/* make secindex */</span>
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECSPIDX(xpl0-&gt;sadb_x_policy_dir,
	                src0 + 1,
	                dst0 + 1,
	                src0-&gt;sadb_address_prefixlen,
	                dst0-&gt;sadb_address_prefixlen,
	                src0-&gt;sadb_address_proto,
                    internal_if,
                    use_src_range ? src0 + 1 : NULL,
                    use_src_range ? src1 + 1 : NULL,
                    use_dst_range ? dst0 + 1 : NULL,
                    use_dst_range ? dst1 + 1 : NULL,
	                &amp;spidx);
	
	<span class="enscript-comment">/*
	 * checking there is SP already or not.
	 * SPDUPDATE doesn't depend on whether there is a SP or not.
	 * If the type is either SPDADD or SPDSETIDX AND a SP is found,
	 * then error.
	 */</span>
	lck_mtx_lock(sadb_mutex);
	newsp = key_getsp(&amp;spidx);
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_type == SADB_X_SPDUPDATE) {
		<span class="enscript-keyword">if</span> (newsp) {
			newsp-&gt;state = IPSEC_SPSTATE_DEAD;
			key_freesp(newsp, KEY_SADB_LOCKED);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (newsp != NULL) {
			key_freesp(newsp, KEY_SADB_LOCKED);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdadd: a SP entry exists already.\n&quot;</span>));
			lck_mtx_unlock(sadb_mutex);
            <span class="enscript-keyword">if</span> (internal_if) {
                ifnet_release(internal_if);
                internal_if = NULL;
            }
			<span class="enscript-keyword">return</span> key_senderror(so, m, EEXIST);
		}
	}
	lck_mtx_unlock(sadb_mutex);
    
	<span class="enscript-comment">/* allocation new SP entry */</span>
	<span class="enscript-keyword">if</span> ((newsp = key_msg2sp(xpl0, PFKEY_EXTLEN(xpl0), &amp;error)) == NULL) {
        <span class="enscript-keyword">if</span> (internal_if) {
            ifnet_release(internal_if);
            internal_if = NULL;
        }
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-keyword">if</span> ((newsp-&gt;id = key_getnewspid()) == 0) {
		keydb_delsecpolicy(newsp);
        <span class="enscript-keyword">if</span> (internal_if) {
            ifnet_release(internal_if);
            internal_if = NULL;
        }
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
	}
    
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECSPIDX(xpl0-&gt;sadb_x_policy_dir,
	                src0 + 1,
	                dst0 + 1,
	                src0-&gt;sadb_address_prefixlen,
	                dst0-&gt;sadb_address_prefixlen,
	                src0-&gt;sadb_address_proto,
                    internal_if,
                    use_src_range ? src0 + 1 : NULL,
                    use_src_range ? src1 + 1 : NULL,
                    use_dst_range ? dst0 + 1 : NULL,
                    use_dst_range ? dst1 + 1 : NULL,
	                &amp;newsp-&gt;spidx);
	
#<span class="enscript-reference">if</span> 1
	<span class="enscript-comment">/*
	 * allow IPv6 over IPv4 tunnels using ESP -
	 * otherwise reject if inner and outer address families not equal
	 */</span>
	<span class="enscript-keyword">if</span> (newsp-&gt;req &amp;&amp; newsp-&gt;req-&gt;saidx.src.ss_family) {
		<span class="enscript-type">struct</span> sockaddr *sa;
		sa = (<span class="enscript-type">struct</span> sockaddr *)(src0 + 1);
		<span class="enscript-keyword">if</span> (sa-&gt;sa_family != newsp-&gt;req-&gt;saidx.src.ss_family) {
			<span class="enscript-keyword">if</span> (newsp-&gt;req-&gt;saidx.mode != IPSEC_MODE_TUNNEL || newsp-&gt;req-&gt;saidx.proto != IPPROTO_ESP
			    || sa-&gt;sa_family != AF_INET6 || newsp-&gt;req-&gt;saidx.src.ss_family != AF_INET) {
				keydb_delsecpolicy(newsp);
                <span class="enscript-keyword">if</span> (internal_if) {
                    ifnet_release(internal_if);
                    internal_if = NULL;
                }
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			}
		}
	}
	<span class="enscript-keyword">if</span> (newsp-&gt;req &amp;&amp; newsp-&gt;req-&gt;saidx.dst.ss_family) {
		<span class="enscript-type">struct</span> sockaddr *sa;
		sa = (<span class="enscript-type">struct</span> sockaddr *)(dst0 + 1);
		<span class="enscript-keyword">if</span> (sa-&gt;sa_family != newsp-&gt;req-&gt;saidx.dst.ss_family) {
			<span class="enscript-keyword">if</span> (newsp-&gt;req-&gt;saidx.mode != IPSEC_MODE_TUNNEL || newsp-&gt;req-&gt;saidx.proto != IPPROTO_ESP
			    || sa-&gt;sa_family != AF_INET6 || newsp-&gt;req-&gt;saidx.dst.ss_family != AF_INET) {
				keydb_delsecpolicy(newsp);
                <span class="enscript-keyword">if</span> (internal_if) {
                    ifnet_release(internal_if);
                    internal_if = NULL;
                }
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			}
		}
	}
#<span class="enscript-reference">endif</span>
	
	microtime(&amp;tv);
	newsp-&gt;created = tv.tv_sec;
	newsp-&gt;lastused = tv.tv_sec;
	newsp-&gt;lifetime = lft ? lft-&gt;sadb_lifetime_addtime : 0;
	newsp-&gt;validtime = lft ? lft-&gt;sadb_lifetime_usetime : 0;
	
    <span class="enscript-keyword">if</span> (outgoing_if != NULL) {
        ifnet_find_by_name(outgoing_if, &amp;newsp-&gt;outgoing_if);
    }
    <span class="enscript-keyword">if</span> (ipsec_if != NULL) {
        ifnet_find_by_name(ipsec_if, &amp;newsp-&gt;ipsec_if);
    }
	<span class="enscript-keyword">if</span> (init_disabled &gt; 0) {
		newsp-&gt;disabled = 1;
	}
    
	newsp-&gt;refcnt = 1;	<span class="enscript-comment">/* do not reclaim until I say I do */</span>
	newsp-&gt;state = IPSEC_SPSTATE_ALIVE;
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/*
	 * policies of type generate should be at the end of the SPD
	 * because they function as default discard policies
	 * Don't start timehandler for generate policies
	 */</span>
	<span class="enscript-keyword">if</span> (newsp-&gt;policy == IPSEC_POLICY_GENERATE) 
		LIST_INSERT_TAIL(&amp;sptree[newsp-&gt;spidx.dir], newsp, secpolicy, chain);
	<span class="enscript-keyword">else</span> {  <span class="enscript-comment">/* XXX until we have policy ordering in the kernel */</span>
		<span class="enscript-type">struct</span> secpolicy *tmpsp;
		
		LIST_FOREACH(tmpsp, &amp;sptree[newsp-&gt;spidx.dir], chain)
		<span class="enscript-keyword">if</span> (tmpsp-&gt;policy == IPSEC_POLICY_GENERATE)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (tmpsp)
			LIST_INSERT_BEFORE(tmpsp, newsp, chain);
		<span class="enscript-keyword">else</span>
			LIST_INSERT_TAIL(&amp;sptree[newsp-&gt;spidx.dir], newsp, secpolicy, chain);
		key_start_timehandler();
	}
	
	ipsec_policy_count++;
	<span class="enscript-comment">/* Turn off the ipsec bypass */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		ipsec_bypass = 0;
	
	<span class="enscript-comment">/* delete the entry in spacqtree */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_type == SADB_X_SPDUPDATE) {
		<span class="enscript-type">struct</span> secspacq *spacq;
		<span class="enscript-keyword">if</span> ((spacq = key_getspacq(&amp;spidx)) != NULL) {
			<span class="enscript-comment">/* reset counter in order to deletion by timehandler. */</span>
			microtime(&amp;tv);
			spacq-&gt;created = tv.tv_sec;
			spacq-&gt;count = 0;
		}
    }
	lck_mtx_unlock(sadb_mutex);
	
    {
		<span class="enscript-type">struct</span> mbuf *n, *mpolicy;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> off;
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		<span class="enscript-keyword">if</span> (lft) {
			<span class="enscript-type">int</span>	mbufItems[] = {SADB_EXT_RESERVED, SADB_X_EXT_POLICY,
				SADB_EXT_LIFETIME_HARD, SADB_EXT_ADDRESS_SRC,
				SADB_EXT_ADDRESS_DST, SADB_X_EXT_ADDR_RANGE_SRC_START, SADB_X_EXT_ADDR_RANGE_SRC_END,
				SADB_X_EXT_ADDR_RANGE_DST_START, SADB_X_EXT_ADDR_RANGE_DST_END};
			n = key_gather_mbuf(m, mhp, 2, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span>	mbufItems[] = {SADB_EXT_RESERVED, SADB_X_EXT_POLICY,
				SADB_EXT_ADDRESS_SRC, SADB_EXT_ADDRESS_DST,
				SADB_X_EXT_ADDR_RANGE_SRC_START, SADB_X_EXT_ADDR_RANGE_SRC_END,
				SADB_X_EXT_ADDR_RANGE_DST_START, SADB_X_EXT_ADDR_RANGE_DST_END};
			n = key_gather_mbuf(m, mhp, 2, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		}
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(*newmsg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(*newmsg));
			<span class="enscript-keyword">if</span> (!n)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		off = 0;
		mpolicy = m_pulldown(n, PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)),
							 <span class="enscript-keyword">sizeof</span>(*xpl), &amp;off);
		<span class="enscript-keyword">if</span> (mpolicy == NULL) {
			<span class="enscript-comment">/* n is already freed */</span>
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		xpl = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)(mtod(mpolicy, caddr_t) + off);
		<span class="enscript-keyword">if</span> (xpl-&gt;sadb_x_policy_exttype != SADB_X_EXT_POLICY) {
			m_freem(n);
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
		xpl-&gt;sadb_x_policy_id = newsp-&gt;id;
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/*
 * get new policy id.
 * OUT:
 *	0:	failure.
 *	others: success.
 */</span>
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">key_getnewspid</span>(<span class="enscript-type">void</span>)
{
	u_int32_t newid = 0;
	<span class="enscript-type">int</span> count = key_spi_trycnt;	<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	<span class="enscript-comment">/* when requesting to allocate spi ranged */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">while</span> (count--) {
		newid = (policy_id = (policy_id == ~0 ? 1 : policy_id + 1));
		
		<span class="enscript-keyword">if</span> ((sp = __key_getspbyid(newid)) == NULL)
			<span class="enscript-keyword">break</span>;
		
		key_freesp(sp, KEY_SADB_LOCKED);
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">if</span> (count == 0 || newid == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_getnewspid: to allocate policy id is failed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-keyword">return</span> newid;
}

<span class="enscript-comment">/*
 * SADB_SPDDELETE processing
 * receive
 *   &lt;base, address(SD), policy(*)&gt;
 * from the user(?), and set SADB_SASTATE_DEAD,
 * and send,
 *   &lt;base, address(SD), policy(*)&gt;
 * to the ikmpd.
 * policy(*) including direction of policy.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spddelete</span>(
			  <span class="enscript-type">struct</span> socket *so,
			  <span class="enscript-type">struct</span> mbuf *m,
			  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0, *src1, *dst1;
	<span class="enscript-type">struct</span> sadb_x_policy *xpl0;
	<span class="enscript-type">struct</span> secpolicyindex spidx;
	<span class="enscript-type">struct</span> secpolicy *sp;
    ifnet_t internal_if = NULL;
    <span class="enscript-type">struct</span> sadb_x_ipsecif *ipsecifopts = NULL;
    <span class="enscript-type">int</span> use_src_range = 0;
    <span class="enscript-type">int</span> use_dst_range = 0;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
    
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spddelete: NULL pointer is passed.\n&quot;</span>);
	
    <span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_START] != NULL &amp;&amp; mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_END] != NULL) {
        use_src_range = 1;
    }
    <span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_START] != NULL &amp;&amp; mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_END] != NULL) {
        use_dst_range = 1;
    }
    
	<span class="enscript-keyword">if</span> ((!use_src_range &amp;&amp; mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL) ||
        (!use_dst_range &amp;&amp; mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL) ||
	    mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> ((use_src_range &amp;&amp; (mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_SRC_START] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)
                           || mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_SRC_END] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address))) ||
        (!use_src_range &amp;&amp; mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) ||
        (use_dst_range &amp;&amp; (mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_DST_START] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)
                           || mhp-&gt;extlen[SADB_X_EXT_ADDR_RANGE_DST_END] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address))) ||
        (!use_dst_range &amp;&amp; mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
    <span class="enscript-keyword">if</span> (use_src_range) {
        src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_START];
        src1 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_SRC_END];
    } <span class="enscript-keyword">else</span> {
        src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_SRC];
    }
    <span class="enscript-keyword">if</span> (use_dst_range) {
        dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_START];
        dst1 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_X_EXT_ADDR_RANGE_DST_END];
    } <span class="enscript-keyword">else</span> {
        dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_DST];
    }
	xpl0 = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY];
    ipsecifopts = (<span class="enscript-type">struct</span> sadb_x_ipsecif *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_IPSECIF];
    
    <span class="enscript-comment">/* checking the direction. */</span>
	<span class="enscript-keyword">switch</span> (xpl0-&gt;sadb_x_policy_dir) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete: Invalid SP direction.\n&quot;</span>));
            <span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
    
    <span class="enscript-comment">/* Process interfaces */</span>
    <span class="enscript-keyword">if</span> (ipsecifopts != NULL) {
        <span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_internal_if[0]) {
            ifnet_find_by_name(ipsecifopts-&gt;sadb_x_ipsecif_internal_if, &amp;internal_if);
        }
    }
	
	<span class="enscript-comment">/* make secindex */</span>
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECSPIDX(xpl0-&gt;sadb_x_policy_dir,
	                src0 + 1,
	                dst0 + 1,
	                src0-&gt;sadb_address_prefixlen,
	                dst0-&gt;sadb_address_prefixlen,
	                src0-&gt;sadb_address_proto,
                    internal_if,
                    use_src_range ? src0 + 1 : NULL,
                    use_src_range ? src1 + 1 : NULL,
                    use_dst_range ? dst0 + 1 : NULL,
                    use_dst_range ? dst1 + 1 : NULL,
	                &amp;spidx);
	
	<span class="enscript-comment">/* Is there SP in SPD ? */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((sp = key_getsp(&amp;spidx)) == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete: no SP found.\n&quot;</span>));
		lck_mtx_unlock(sadb_mutex);
        <span class="enscript-keyword">if</span> (internal_if) {
            ifnet_release(internal_if);
            internal_if = NULL;
        }
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
    <span class="enscript-keyword">if</span> (internal_if) {
        ifnet_release(internal_if);
        internal_if = NULL;
    }
    
	<span class="enscript-comment">/* save policy id to buffer to be returned. */</span>
	xpl0-&gt;sadb_x_policy_id = sp-&gt;id;
	
	sp-&gt;state = IPSEC_SPSTATE_DEAD;
	key_freesp(sp, KEY_SADB_LOCKED);
	lck_mtx_unlock(sadb_mutex);
	
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span>	mbufItems[] = {SADB_EXT_RESERVED, SADB_X_EXT_POLICY,
			SADB_EXT_ADDRESS_SRC, SADB_EXT_ADDRESS_DST,
			SADB_X_EXT_ADDR_RANGE_SRC_START, SADB_X_EXT_ADDR_RANGE_SRC_END,
			SADB_X_EXT_ADDR_RANGE_DST_START, SADB_X_EXT_ADDR_RANGE_DST_END};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/*
 * SADB_SPDDELETE2 processing
 * receive
 *   &lt;base, policy(*)&gt;
 * from the user(?), and set SADB_SASTATE_DEAD,
 * and send,
 *   &lt;base, policy(*)&gt;
 * to the ikmpd.
 * policy(*) including direction of policy.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spddelete2</span>(
			   <span class="enscript-type">struct</span> socket *so,
			   <span class="enscript-type">struct</span> mbuf *m,
			   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	u_int32_t id;
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spddelete2: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete2: invalid message is passed.\n&quot;</span>));
		key_senderror(so, m, EINVAL);
		<span class="enscript-keyword">return</span> 0;
	}
	
	id = ((<span class="enscript-type">struct</span> sadb_x_policy *)
		  (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY])-&gt;sadb_x_policy_id;
	
	<span class="enscript-comment">/* Is there SP in SPD ? */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((sp = __key_getspbyid(id)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddelete2: no SP found id:%u.\n&quot;</span>, id));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	sp-&gt;state = IPSEC_SPSTATE_DEAD;
	key_freesp(sp, KEY_SADB_LOCKED);
	lck_mtx_unlock(sadb_mutex);
	
    {
		<span class="enscript-type">struct</span> mbuf *n, *nn;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> off, len;
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		
		<span class="enscript-keyword">if</span> (len &gt; MCLBYTES)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		MGETHDR(n, M_WAITOK, MT_DATA);
		<span class="enscript-keyword">if</span> (n &amp;&amp; len &gt; MHLEN) {
			MCLGET(n, M_WAITOK);
			<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
				m_freem(n);
				n = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		n-&gt;m_len = len;
		n-&gt;m_next = NULL;
		off = 0;
		
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg), mtod(n, caddr_t) + off);
		off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (off != len)
			panic(<span class="enscript-string">&quot;length inconsistency in key_spddelete2&quot;</span>);
#<span class="enscript-reference">endif</span>
		
		n-&gt;m_next = m_copym(m, mhp-&gt;extoff[SADB_X_EXT_POLICY],
							mhp-&gt;extlen[SADB_X_EXT_POLICY], M_WAITOK);
		<span class="enscript-keyword">if</span> (!n-&gt;m_next) {
			m_freem(n);
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		
		n-&gt;m_pkthdr.len = 0;
		<span class="enscript-keyword">for</span> (nn = n; nn; nn = nn-&gt;m_next)
			n-&gt;m_pkthdr.len += nn-&gt;m_len;
		
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdenable</span>(
			  <span class="enscript-type">struct</span> socket *so,
			  <span class="enscript-type">struct</span> mbuf *m,
			  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	u_int32_t id;
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spdenable: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdenable: invalid message is passed.\n&quot;</span>));
		key_senderror(so, m, EINVAL);
		<span class="enscript-keyword">return</span> 0;
	}
	
	id = ((<span class="enscript-type">struct</span> sadb_x_policy *)
		  (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY])-&gt;sadb_x_policy_id;
	
	<span class="enscript-comment">/* Is there SP in SPD ? */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((sp = __key_getspbyid(id)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdenable: no SP found id:%u.\n&quot;</span>, id));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	sp-&gt;disabled = 0;
	lck_mtx_unlock(sadb_mutex);
	
	{
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_X_EXT_POLICY};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spddisable</span>(
			   <span class="enscript-type">struct</span> socket *so,
			   <span class="enscript-type">struct</span> mbuf *m,
			   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	u_int32_t id;
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spddisable: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddisable: invalid message is passed.\n&quot;</span>));
		key_senderror(so, m, EINVAL);
		<span class="enscript-keyword">return</span> 0;
	}
	
	id = ((<span class="enscript-type">struct</span> sadb_x_policy *)
		  (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY])-&gt;sadb_x_policy_id;
	
	<span class="enscript-comment">/* Is there SP in SPD ? */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((sp = __key_getspbyid(id)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddisable: no SP found id:%u.\n&quot;</span>, id));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	sp-&gt;disabled = 1;
	lck_mtx_unlock(sadb_mutex);
	
	{
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_X_EXT_POLICY};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/*
 * SADB_X_GET processing
 * receive
 *   &lt;base, policy(*)&gt;
 * from the user(?),
 * and send,
 *   &lt;base, address(SD), policy&gt;
 * to the ikmpd.
 * policy(*) including direction of policy.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdget</span>(
		   <span class="enscript-type">struct</span> socket *so,
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	u_int32_t id;
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">struct</span> mbuf *n;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spdget: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_POLICY] == NULL ||
	    mhp-&gt;extlen[SADB_X_EXT_POLICY] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdget: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	id = ((<span class="enscript-type">struct</span> sadb_x_policy *)
		  (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_POLICY])-&gt;sadb_x_policy_id;
	
	<span class="enscript-comment">/* Is there SP in SPD ? */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((sp = __key_getspbyid(id)) == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdget: no SP found id:%u.\n&quot;</span>, id));
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	lck_mtx_unlock(sadb_mutex);
	n = key_setdumpsp(sp, SADB_X_SPDGET, 0, mhp-&gt;msg-&gt;sadb_msg_pid);
	<span class="enscript-keyword">if</span> (n != NULL) {
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ONE);
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
}

<span class="enscript-comment">/*
 * SADB_X_SPDACQUIRE processing.
 * Acquire policy and SA(s) for a *OUTBOUND* packet.
 * send
 *   &lt;base, policy(*)&gt;
 * to KMD, and expect to receive
 *   &lt;base&gt; with SADB_X_SPDACQUIRE if error occurred,
 * or
 *   &lt;base, policy&gt;
 * with SADB_X_SPDUPDATE from KMD by PF_KEY.
 * policy(*) is without policy requests.
 *
 *    0     : succeed
 *    others: error number
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdacquire</span>(
			   <span class="enscript-type">struct</span> secpolicy *sp)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m;
	<span class="enscript-type">struct</span> secspacq *newspacq;
	<span class="enscript-type">int</span> error;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sp == NULL)
		panic(<span class="enscript-string">&quot;key_spdacquire: NULL pointer is passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (sp-&gt;req != NULL)
		panic(<span class="enscript-string">&quot;key_spdacquire: called but there is request.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (sp-&gt;policy != IPSEC_POLICY_IPSEC)
		panic(<span class="enscript-string">&quot;key_spdacquire: policy mismathed. IPsec is expected.\n&quot;</span>);
	
	<span class="enscript-comment">/* get a entry to check whether sent message or not. */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((newspacq = key_getspacq(&amp;sp-&gt;spidx)) != NULL) {
		<span class="enscript-keyword">if</span> (key_blockacq_count &lt; newspacq-&gt;count) {
			<span class="enscript-comment">/* reset counter and do send message. */</span>
			newspacq-&gt;count = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* increment counter and do nothing. */</span>
			newspacq-&gt;count++;
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 0;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* make new entry for blocking to send SADB_ACQUIRE. */</span>
		<span class="enscript-keyword">if</span> ((newspacq = key_newspacq(&amp;sp-&gt;spidx)) == NULL) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		<span class="enscript-comment">/* add to acqtree */</span>
		LIST_INSERT_HEAD(&amp;spacqtree, newspacq, chain);
		key_start_timehandler();
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
	m = key_setsadbmsg(SADB_X_SPDACQUIRE, 0, 0, 0, 0, 0);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	result = m;
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(NULL, m, KEY_SENDUP_REGISTERED);
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_freem(result);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * SADB_SPDFLUSH processing
 * receive
 *   &lt;base&gt;
 * from the user, and free all entries in secpctree.
 * and send,
 *   &lt;base&gt;
 * to the user.
 * NOTE: what to do is only marking SADB_SASTATE_DEAD.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdflush</span>(
			 <span class="enscript-type">struct</span> socket *so,
			 <span class="enscript-type">struct</span> mbuf *m,
			 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_msg *newmsg;
	<span class="enscript-type">struct</span> secpolicy *sp;
	u_int dir;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spdflush: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (m-&gt;m_len != PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)))
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">for</span> (dir = 0; dir &lt; IPSEC_DIR_MAX; dir++) {
		LIST_FOREACH(sp, &amp;sptree[dir], chain) {
			sp-&gt;state = IPSEC_SPSTATE_DEAD;
		}
	}
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg) &gt; m-&gt;m_len + M_TRAILINGSPACE(m)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spdflush: No more memory.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
	}
	
	<span class="enscript-keyword">if</span> (m-&gt;m_next)
		m_freem(m-&gt;m_next);
	m-&gt;m_next = NULL;
	m-&gt;m_pkthdr.len = m-&gt;m_len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
	newmsg = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	newmsg-&gt;sadb_msg_errno = 0;
	newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(m-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ALL);
}

<span class="enscript-comment">/*
 * SADB_SPDDUMP processing
 * receive
 *   &lt;base&gt;
 * from the user, and dump all SP leaves
 * and send,
 *   &lt;base&gt; .....
 * to the ikmpd.
 *
 * m will always be freed.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spddump</span>(
			<span class="enscript-type">struct</span> socket *so,
			<span class="enscript-type">struct</span> mbuf *m,
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> secpolicy *sp, **spbuf = NULL, **sp_ptr;
	<span class="enscript-type">int</span> cnt = 0, bufcount;
	u_int dir;
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">int</span> error = 0;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_spddump: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> ((bufcount = ipsec_policy_count) == 0) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bufcount += 256;	<span class="enscript-comment">/* extra */</span>
	KMALLOC_WAIT(spbuf, <span class="enscript-type">struct</span> secpolicy**, bufcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secpolicy*));
	<span class="enscript-keyword">if</span> (spbuf == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_spddump: No more memory.\n&quot;</span>));
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* search SPD entry, make list. */</span>
	sp_ptr = spbuf;
	<span class="enscript-keyword">for</span> (dir = 0; dir &lt; IPSEC_DIR_MAX; dir++) {
		LIST_FOREACH(sp, &amp;sptree[dir], chain) {
			<span class="enscript-keyword">if</span> (cnt == bufcount)
				<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* buffer full */</span>
			*sp_ptr++ = sp;
			sp-&gt;refcnt++;
			cnt++;
		}
	}
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (cnt == 0) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	
	sp_ptr = spbuf;
	<span class="enscript-keyword">while</span> (cnt) {
		--cnt;
		n = key_setdumpsp(*sp_ptr++, SADB_X_SPDDUMP, cnt,
						  mhp-&gt;msg-&gt;sadb_msg_pid);
		
		<span class="enscript-keyword">if</span> (n)
			key_sendup_mbuf(so, n, KEY_SENDUP_ONE);
	}
	
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">while</span> (sp_ptr &gt; spbuf)
		key_freesp(*(--sp_ptr), KEY_SADB_LOCKED);
	lck_mtx_unlock(sadb_mutex);
	
<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (spbuf)
		KFREE(spbuf);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	
	m_freem(m);
	<span class="enscript-keyword">return</span> 0;
	
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setdumpsp</span>(
			  <span class="enscript-type">struct</span> secpolicy *sp,
			  u_int8_t type,
			  u_int32_t seq,
			  u_int32_t pid)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m;
	
	m = key_setsadbmsg(type, 0, SADB_SATYPE_UNSPEC, seq, pid, sp-&gt;refcnt);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	result = m;
	
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.src_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.start, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.end, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
							(<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src, sp-&gt;spidx.prefs,
							sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
	
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.dst_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.start, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.end, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
							(<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst, sp-&gt;spidx.prefd,
							sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
    
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.internal_if || sp-&gt;outgoing_if || sp-&gt;ipsec_if || sp-&gt;disabled) {
        m = key_setsadbipsecif(sp-&gt;spidx.internal_if, sp-&gt;outgoing_if, sp-&gt;ipsec_if, sp-&gt;disabled);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
	
	m = key_sp2msg(sp);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	m_cat(result, m);
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> result;
	
<span class="enscript-reference">fail</span>:
	m_freem(result);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * get PFKEY message length for security policy and request.
 */</span>
<span class="enscript-type">static</span> u_int
<span class="enscript-function-name">key_getspreqmsglen</span>(
				   <span class="enscript-type">struct</span> secpolicy *sp)
{
	u_int tlen;
	
	tlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy);
	
	<span class="enscript-comment">/* if is the policy for ipsec ? */</span>
	<span class="enscript-keyword">if</span> (sp-&gt;policy != IPSEC_POLICY_IPSEC)
		<span class="enscript-keyword">return</span> tlen;
	
	<span class="enscript-comment">/* get length of ipsec requests */</span>
    {
		<span class="enscript-type">struct</span> ipsecrequest *isr;
		<span class="enscript-type">int</span> len;
		
		<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {
			len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecrequest)
			+ isr-&gt;saidx.src.ss_len
			+ isr-&gt;saidx.dst.ss_len;
			
			tlen += PFKEY_ALIGN8(len);
		}
    }
	
	<span class="enscript-keyword">return</span> tlen;
}

<span class="enscript-comment">/*
 * SADB_SPDEXPIRE processing
 * send
 *   &lt;base, address(SD), lifetime(CH), policy&gt;
 * to KMD by PF_KEY.
 *
 * OUT:	0	: succeed
 *	others	: error number
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_spdexpire</span>(
			  <span class="enscript-type">struct</span> secpolicy *sp)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m;
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">int</span> error = EINVAL;
	<span class="enscript-type">struct</span> sadb_lifetime *lt;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sp == NULL)
		panic(<span class="enscript-string">&quot;key_spdexpire: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* set msg header */</span>
	m = key_setsadbmsg(SADB_X_SPDEXPIRE, 0, 0, 0, 0, 0);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	result = m;
	
	<span class="enscript-comment">/* create lifetime extension (current and hard) */</span>
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*lt)) * 2;
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	bzero(mtod(m, caddr_t), len);
	lt = mtod(m, <span class="enscript-type">struct</span> sadb_lifetime *);
	lt-&gt;sadb_lifetime_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	lt-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
	lt-&gt;sadb_lifetime_allocations = 0;
	lt-&gt;sadb_lifetime_bytes = 0;
	lt-&gt;sadb_lifetime_addtime = sp-&gt;created;
	lt-&gt;sadb_lifetime_usetime = sp-&gt;lastused;
	lt = (<span class="enscript-type">struct</span> sadb_lifetime *)(<span class="enscript-type">void</span> *)(mtod(m, caddr_t) + len / 2);
	lt-&gt;sadb_lifetime_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	lt-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
	lt-&gt;sadb_lifetime_allocations = 0;
	lt-&gt;sadb_lifetime_bytes = 0;
	lt-&gt;sadb_lifetime_addtime = sp-&gt;lifetime;
	lt-&gt;sadb_lifetime_usetime = sp-&gt;validtime;
	m_cat(result, m);
	
    <span class="enscript-comment">/* set sadb_address(es) for source */</span>
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.src_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.start, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.end, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
    }
    
    <span class="enscript-comment">/* set sadb_address(es) for dest */</span>
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.dst_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.start, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.end, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m) {
            error = ENOBUFS;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
        m_cat(result, m);
    }
	
	<span class="enscript-comment">/* set secpolicy */</span>
	m = key_sp2msg(sp);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(NULL, result, KEY_SENDUP_REGISTERED);
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_freem(result);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* %%% SAD management */</span>
<span class="enscript-comment">/*
 * allocating a memory for new SA head, and copy from the values of mhp.
 * OUT:	NULL	: failure due to the lack of memory.
 *	others	: pointer to new SA head.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secashead *
<span class="enscript-function-name">key_newsah</span>(<span class="enscript-type">struct</span> secasindex *saidx,
		   ifnet_t ipsec_if,
		   u_int outgoing_if,
		   u_int8_t dir)
{
	<span class="enscript-type">struct</span> secashead *newsah;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (saidx == NULL)
		panic(<span class="enscript-string">&quot;key_newsaidx: NULL pointer is passed.\n&quot;</span>);
	
	newsah = keydb_newsecashead();
	<span class="enscript-keyword">if</span> (newsah == NULL)
		<span class="enscript-keyword">return</span> NULL;
	
	bcopy(saidx, &amp;newsah-&gt;saidx, <span class="enscript-keyword">sizeof</span>(newsah-&gt;saidx));
	
	<span class="enscript-comment">/* remove the ports */</span>
	<span class="enscript-keyword">switch</span> (saidx-&gt;src.ss_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			((<span class="enscript-type">struct</span> sockaddr_in *)(&amp;newsah-&gt;saidx.src))-&gt;sin_port = IPSEC_PORT_ANY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			((<span class="enscript-type">struct</span> sockaddr_in6 *)(&amp;newsah-&gt;saidx.src))-&gt;sin6_port = IPSEC_PORT_ANY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">switch</span> (saidx-&gt;dst.ss_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			((<span class="enscript-type">struct</span> sockaddr_in *)(&amp;newsah-&gt;saidx.dst))-&gt;sin_port = IPSEC_PORT_ANY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			((<span class="enscript-type">struct</span> sockaddr_in6 *)(&amp;newsah-&gt;saidx.dst))-&gt;sin6_port = IPSEC_PORT_ANY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}
	
	newsah-&gt;outgoing_if = outgoing_if;
	<span class="enscript-keyword">if</span> (ipsec_if) {
		ifnet_reference(ipsec_if);
		newsah-&gt;ipsec_if = ipsec_if;
	}
	newsah-&gt;dir = dir;
	<span class="enscript-comment">/* add to saidxtree */</span>
	newsah-&gt;state = SADB_SASTATE_MATURE;
	LIST_INSERT_HEAD(&amp;sahtree, newsah, chain);
	key_start_timehandler();

	<span class="enscript-keyword">return</span>(newsah);
}

<span class="enscript-comment">/*
 * delete SA index and all SA registerd.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_delsah</span>(
		   <span class="enscript-type">struct</span> secashead *sah)
{
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
	u_int stateidx, state;
	<span class="enscript-type">int</span> zombie = 0;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sah == NULL)
		panic(<span class="enscript-string">&quot;key_delsah: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* searching all SA registerd in the secindex. */</span>
	<span class="enscript-keyword">for</span> (stateidx = 0;
	     stateidx &lt; _ARRAYLEN(saorder_state_any);
	     stateidx++) {
		
		state = saorder_state_any[stateidx];
		<span class="enscript-keyword">for</span> (sav = (<span class="enscript-type">struct</span> secasvar *)LIST_FIRST(&amp;sah-&gt;savtree[state]);
		     sav != NULL;
		     sav = nextsav) {
			
			nextsav = LIST_NEXT(sav, chain);
			
			<span class="enscript-keyword">if</span> (sav-&gt;refcnt &gt; 0) {
				<span class="enscript-comment">/* give up to delete this sa */</span>
				zombie++;
				<span class="enscript-keyword">continue</span>;
			}
			
			<span class="enscript-comment">/* sanity check */</span>
			KEY_CHKSASTATE(state, sav-&gt;state, <span class="enscript-string">&quot;key_delsah&quot;</span>);
			
			key_freesav(sav, KEY_SADB_LOCKED);
			
			<span class="enscript-comment">/* remove back pointer */</span>
			sav-&gt;sah = NULL;
			sav = NULL;
		}
	}
	
	<span class="enscript-comment">/* don't delete sah only if there are savs. */</span>
	<span class="enscript-keyword">if</span> (zombie)
		<span class="enscript-keyword">return</span>;
	
	ROUTE_RELEASE(&amp;sah-&gt;sa_route);
    
	<span class="enscript-keyword">if</span> (sah-&gt;ipsec_if) {
		ifnet_release(sah-&gt;ipsec_if);
		sah-&gt;ipsec_if = NULL;
	}
	
    <span class="enscript-keyword">if</span> (sah-&gt;idents) {
        KFREE(sah-&gt;idents);
    }
    
    <span class="enscript-keyword">if</span> (sah-&gt;identd) {
        KFREE(sah-&gt;identd);
    }
	
	<span class="enscript-comment">/* remove from tree of SA index */</span>
	<span class="enscript-keyword">if</span> (__LIST_CHAINED(sah))
		LIST_REMOVE(sah, chain);
	
	KFREE(sah);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * allocating a new SA with LARVAL state.  key_add() and key_getspi() call,
 * and copy the values of mhp into new buffer.
 * When SAD message type is GETSPI:
 *	to set sequence number from acq_seq++,
 *	to set zero to SPI.
 *	not to call key_setsava().
 * OUT:	NULL	: fail
 *	others	: pointer to new secasvar.
 *
 * does not modify mbuf.  does not free mbuf on error.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_newsav</span>(
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp,
		   <span class="enscript-type">struct</span> secashead *sah,
		   <span class="enscript-type">int</span> *errp,
		   <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> secasvar *newsav;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa *xsa;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || mhp == NULL || mhp-&gt;msg == NULL || sah == NULL)
		panic(<span class="enscript-string">&quot;key_newsa: NULL pointer is passed.\n&quot;</span>);
	
	KMALLOC_NOWAIT(newsav, <span class="enscript-type">struct</span> secasvar *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
	<span class="enscript-keyword">if</span> (newsav == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(newsav, <span class="enscript-type">struct</span> secasvar *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (newsav == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: No more memory.\n&quot;</span>));
			*errp = ENOBUFS;
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	bzero((caddr_t)newsav, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
	
	<span class="enscript-keyword">switch</span> (mhp-&gt;msg-&gt;sadb_msg_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_GETSPI</span>:
			key_setspi(newsav, 0);
			
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
			<span class="enscript-comment">/* sync sequence number */</span>
			<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_seq == 0)
				newsav-&gt;seq =
				(acq_seq = (acq_seq == ~0 ? 1 : ++acq_seq));
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
				newsav-&gt;seq = mhp-&gt;msg-&gt;sadb_msg_seq;
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_ADD</span>:
			<span class="enscript-comment">/* sanity check */</span>
			<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL) {
				key_delsav(newsav);
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: invalid message is passed.\n&quot;</span>));
				*errp = EINVAL;
				<span class="enscript-keyword">return</span> NULL;
			}
			xsa = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
			key_setspi(newsav, xsa-&gt;sadb_sa_spi);
			newsav-&gt;seq = mhp-&gt;msg-&gt;sadb_msg_seq;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			key_delsav(newsav);
			*errp = EINVAL;
			<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_SA2] != NULL) {
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sadb_x_sa2 *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_alwaysexpire)
			newsav-&gt;always_expire = 1;
		newsav-&gt;flags2 = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_flags;
		<span class="enscript-keyword">if</span> (newsav-&gt;flags2 &amp; SADB_X_EXT_SA2_DELETE_ON_DETACH) {
			newsav-&gt;so = so;
		}
	}
	
	<span class="enscript-comment">/* copy sav values */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_type != SADB_GETSPI) {
		*errp = key_setsaval(newsav, m, mhp);
		<span class="enscript-keyword">if</span> (*errp) {
			key_delsav(newsav);
			<span class="enscript-keyword">return</span> NULL;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* For get SPI, if has a hard lifetime, apply */</span>
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_lifetime *lft0;
		<span class="enscript-type">struct</span> timeval tv;
		
		lft0 = (<span class="enscript-type">struct</span> sadb_lifetime *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_LIFETIME_HARD];
		<span class="enscript-keyword">if</span> (lft0 != NULL) {
			<span class="enscript-comment">/* make lifetime for CURRENT */</span>
			KMALLOC_NOWAIT(newsav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
						   <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
			<span class="enscript-keyword">if</span> (newsav-&gt;lft_c == NULL) {
				lck_mtx_unlock(sadb_mutex);
				KMALLOC_WAIT(newsav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
							 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
				lck_mtx_lock(sadb_mutex);
				<span class="enscript-keyword">if</span> (newsav-&gt;lft_c == NULL) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: No more memory.\n&quot;</span>));
					key_delsav(newsav);
					*errp = ENOBUFS;
					<span class="enscript-keyword">return</span> NULL;
				}
			}
			
			microtime(&amp;tv);
			
			newsav-&gt;lft_c-&gt;sadb_lifetime_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
			newsav-&gt;lft_c-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
			newsav-&gt;lft_c-&gt;sadb_lifetime_allocations = 0;
			newsav-&gt;lft_c-&gt;sadb_lifetime_bytes = 0;
			newsav-&gt;lft_c-&gt;sadb_lifetime_addtime = tv.tv_sec;
			newsav-&gt;lft_c-&gt;sadb_lifetime_usetime = 0;
			
			<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_LIFETIME_HARD] &lt; <span class="enscript-keyword">sizeof</span>(*lft0)) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: invalid hard lifetime ext len.\n&quot;</span>));
				key_delsav(newsav);
				*errp = EINVAL;
				<span class="enscript-keyword">return</span> NULL;
			}
			newsav-&gt;lft_h = (<span class="enscript-type">struct</span> sadb_lifetime *)key_newbuf(lft0, <span class="enscript-keyword">sizeof</span>(*lft0));
			<span class="enscript-keyword">if</span> (newsav-&gt;lft_h == NULL) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: No more memory.\n&quot;</span>));
				key_delsav(newsav);
				*errp = ENOBUFS;
				<span class="enscript-keyword">return</span> NULL;
			}
		}
	}
	
	<span class="enscript-comment">/* reset created */</span>
    {
		<span class="enscript-type">struct</span> timeval tv;
		microtime(&amp;tv);
		newsav-&gt;created = tv.tv_sec;
    }
	
	newsav-&gt;pid = mhp-&gt;msg-&gt;sadb_msg_pid;
	
	<span class="enscript-comment">/* add to satree */</span>
	newsav-&gt;sah = sah;
	newsav-&gt;refcnt = 1;
	newsav-&gt;state = SADB_SASTATE_LARVAL;
	LIST_INSERT_TAIL(&amp;sah-&gt;savtree[SADB_SASTATE_LARVAL], newsav,
					 secasvar, chain);
	ipsec_sav_count++;
	
	<span class="enscript-keyword">return</span> newsav;
}

<span class="enscript-comment">/*
 * allocating a new SA with LARVAL state.  key_add() and key_getspi() call,
 * and copy the values passed into new buffer.
 * When SAD message type is GETSPI:
 *	to set sequence number from acq_seq++,
 *	to set zero to SPI.
 *	not to call key_setsava().
 * OUT:	NULL	: fail
 *	others	: pointer to new secasvar.
 */</span>
<span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_newsav2</span>(<span class="enscript-type">struct</span> secashead     *sah,
			u_int8_t              satype,
			u_int8_t              alg_auth,
			u_int8_t              alg_enc,
			u_int32_t             flags,
			u_int8_t              replay,
			<span class="enscript-type">struct</span> sadb_key      *key_auth,
			u_int16_t             key_auth_len,
			<span class="enscript-type">struct</span> sadb_key      *key_enc,
			u_int16_t             key_enc_len,
			u_int16_t             natt_port,
			u_int32_t             seq,
			u_int32_t             spi,
			u_int32_t             pid,
			<span class="enscript-type">struct</span> sadb_lifetime *lifetime_hard,
			<span class="enscript-type">struct</span> sadb_lifetime *lifetime_soft)
{
	<span class="enscript-type">struct</span> secasvar *newsav;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sah == NULL)
		panic(<span class="enscript-string">&quot;key_newsa: NULL pointer is passed.\n&quot;</span>);
	
	KMALLOC_NOWAIT(newsav, <span class="enscript-type">struct</span> secasvar *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
	<span class="enscript-keyword">if</span> (newsav == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(newsav, <span class="enscript-type">struct</span> secasvar *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (newsav == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newsa: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	bzero((caddr_t)newsav, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar));
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
	<span class="enscript-comment">/* sync sequence number */</span>
	<span class="enscript-keyword">if</span> (seq == 0)
		newsav-&gt;seq = (acq_seq = (acq_seq == ~0 ? 1 : ++acq_seq));
	<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		newsav-&gt;seq = seq;
	key_setspi(newsav, spi);
	
	<span class="enscript-keyword">if</span> (key_setsaval2(newsav,
					  satype,
					  alg_auth,
					  alg_enc,
					  flags,
					  replay,
					  key_auth,
					  key_auth_len,
					  key_enc,
					  key_enc_len,
					  natt_port,
					  seq,
					  spi,
					  pid,
					  lifetime_hard,
					  lifetime_soft)) {
		key_delsav(newsav);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-comment">/* reset created */</span>
    {
		<span class="enscript-type">struct</span> timeval tv;
		microtime(&amp;tv);
		newsav-&gt;created = tv.tv_sec;
    }
	
	newsav-&gt;pid = pid;
	
	<span class="enscript-comment">/* add to satree */</span>
	newsav-&gt;sah = sah;
	newsav-&gt;refcnt = 1;
	<span class="enscript-keyword">if</span> (spi &amp;&amp; key_auth &amp;&amp; key_auth_len &amp;&amp; key_enc &amp;&amp; key_enc_len) {
		newsav-&gt;state = SADB_SASTATE_MATURE;
		LIST_INSERT_TAIL(&amp;sah-&gt;savtree[SADB_SASTATE_MATURE], newsav,
						 secasvar, chain);
	} <span class="enscript-keyword">else</span> {
		newsav-&gt;state = SADB_SASTATE_LARVAL;
		LIST_INSERT_TAIL(&amp;sah-&gt;savtree[SADB_SASTATE_LARVAL], newsav,
						 secasvar, chain);
	}
	ipsec_sav_count++;
	
	<span class="enscript-keyword">return</span> newsav;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_migratesav</span>(<span class="enscript-type">struct</span> secasvar *sav,
			   <span class="enscript-type">struct</span> secashead *newsah)
{
	<span class="enscript-keyword">if</span> (sav == NULL || newsah == NULL || sav-&gt;state != SADB_SASTATE_MATURE) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-comment">/* remove from SA header */</span>
	<span class="enscript-keyword">if</span> (__LIST_CHAINED(sav))
		LIST_REMOVE(sav, chain);
	
	sav-&gt;sah = newsah;
	LIST_INSERT_TAIL(&amp;newsah-&gt;savtree[SADB_SASTATE_MATURE], sav, secasvar, chain);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * free() SA variable entry.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_delsav</span>(
		   <span class="enscript-type">struct</span> secasvar *sav)
{
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;key_delsav: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (sav-&gt;refcnt &gt; 0)
		<span class="enscript-keyword">return</span>;		<span class="enscript-comment">/* can't free */</span>
	
	<span class="enscript-comment">/* remove from SA header */</span>
	<span class="enscript-keyword">if</span> (__LIST_CHAINED(sav))
		LIST_REMOVE(sav, chain);
	ipsec_sav_count--;
	
	<span class="enscript-keyword">if</span> (sav-&gt;spihash.le_prev || sav-&gt;spihash.le_next)
		LIST_REMOVE(sav, spihash);
	
	<span class="enscript-keyword">if</span> (sav-&gt;key_auth != NULL) {
		bzero(_KEYBUF(sav-&gt;key_auth), _KEYLEN(sav-&gt;key_auth));
		KFREE(sav-&gt;key_auth);
		sav-&gt;key_auth = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;key_enc != NULL) {
		bzero(_KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc));
		KFREE(sav-&gt;key_enc);
		sav-&gt;key_enc = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;sched) {
		bzero(sav-&gt;sched, sav-&gt;schedlen);
		KFREE(sav-&gt;sched);
		sav-&gt;sched = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;replay != NULL) {
		keydb_delsecreplay(sav-&gt;replay);
		sav-&gt;replay = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_c != NULL) {
		KFREE(sav-&gt;lft_c);
		sav-&gt;lft_c = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_h != NULL) {
		KFREE(sav-&gt;lft_h);
		sav-&gt;lft_h = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_s != NULL) {
		KFREE(sav-&gt;lft_s);
		sav-&gt;lft_s = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;iv != NULL) {
		KFREE(sav-&gt;iv);
		sav-&gt;iv = NULL;
	}
	
	KFREE(sav);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * search SAD.
 * OUT:
 *	NULL	: not found
 *	others	: found, pointer to a SA.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secashead *
<span class="enscript-function-name">key_getsah</span>(<span class="enscript-type">struct</span> secasindex *saidx)
{
	<span class="enscript-type">struct</span> secashead *sah;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, saidx, CMP_REQID))
			<span class="enscript-keyword">return</span> sah;
	}
	
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">struct</span> secashead *
<span class="enscript-function-name">key_newsah2</span> (<span class="enscript-type">struct</span> secasindex *saidx,
			 u_int8_t           dir)
{
	<span class="enscript-type">struct</span> secashead *sah;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	sah = key_getsah(saidx);
	<span class="enscript-keyword">if</span> (!sah) {
		<span class="enscript-keyword">return</span>(key_newsah(saidx, NULL, 0, dir));
	}
	<span class="enscript-keyword">return</span> sah;
}

<span class="enscript-comment">/*
 * check not to be duplicated SPI.
 * NOTE: this function is too slow due to searching all SAD.
 * OUT:
 *	NULL	: not found
 *	others	: found, pointer to a SA.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_checkspidup</span>(
				<span class="enscript-type">struct</span> secasindex *saidx,
				u_int32_t spi)
{
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int stateidx, state;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* check address family */</span>
	<span class="enscript-keyword">if</span> (saidx-&gt;src.ss_family != saidx-&gt;dst.ss_family) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_checkspidup: address family mismatched.\n&quot;</span>));
		<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-comment">/* check all SAD */</span>
	LIST_FOREACH(sav, &amp;spihash[SPIHASH(spi)], spihash) {
		<span class="enscript-keyword">if</span> (sav-&gt;spi != spi)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">for</span> (stateidx = 0;
		     stateidx &lt; _ARRAYLEN(saorder_state_alive);
		     stateidx++) {
			state = saorder_state_alive[stateidx];
			<span class="enscript-keyword">if</span> (sav-&gt;state == state &amp;&amp;
			    key_ismyaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst))
				<span class="enscript-keyword">return</span> sav;
		}
	}
	
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_setspi</span>(
		   <span class="enscript-type">struct</span> secasvar *sav,
		   u_int32_t spi)
{
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	sav-&gt;spi = spi;
	<span class="enscript-keyword">if</span> (sav-&gt;spihash.le_prev || sav-&gt;spihash.le_next)
		LIST_REMOVE(sav, spihash);
	LIST_INSERT_HEAD(&amp;spihash[SPIHASH(spi)], sav, spihash);
}


<span class="enscript-comment">/*
 * search SAD litmited alive SA, protocol, SPI.
 * OUT:
 *	NULL	: not found
 *	others	: found, pointer to a SA.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_getsavbyspi</span>(
				<span class="enscript-type">struct</span> secashead *sah,
				u_int32_t spi)
{
	<span class="enscript-type">struct</span> secasvar *sav, *match;
	u_int stateidx, state, matchidx;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	match = NULL;
	matchidx = _ARRAYLEN(saorder_state_alive);
	LIST_FOREACH(sav, &amp;spihash[SPIHASH(spi)], spihash) {
		<span class="enscript-keyword">if</span> (sav-&gt;spi != spi)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (sav-&gt;sah != sah)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; matchidx; stateidx++) {
			state = saorder_state_alive[stateidx];
			<span class="enscript-keyword">if</span> (sav-&gt;state == state) {
				match = sav;
				matchidx = stateidx;
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	
	<span class="enscript-keyword">return</span> match;
}

<span class="enscript-comment">/*
 * copy SA values from PF_KEY message except *SPI, SEQ, PID, STATE and TYPE*.
 * You must update these if need.
 * OUT:	0:	success.
 *	!0:	failure.
 *
 * does not modify mbuf.  does not free mbuf on error.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_setsaval</span>(
			 <span class="enscript-type">struct</span> secasvar *sav,
			 <span class="enscript-type">struct</span> mbuf *m,
			 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timeval tv;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_setsaval: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* initialization */</span>
	sav-&gt;replay = NULL;
	sav-&gt;key_auth = NULL;
	sav-&gt;key_enc = NULL;
	sav-&gt;sched = NULL;
	sav-&gt;schedlen = 0;
	sav-&gt;iv = NULL;
	sav-&gt;lft_c = NULL;
	sav-&gt;lft_h = NULL;
	sav-&gt;lft_s = NULL;
	sav-&gt;remote_ike_port = 0;
	sav-&gt;natt_last_activity = natt_now;
	sav-&gt;natt_encapsulated_src_port = 0;
	
	<span class="enscript-comment">/* SA */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] != NULL) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa *sa0;
		
		sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
		<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(*sa0)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid message size.\n&quot;</span>));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		
		sav-&gt;alg_auth = sa0-&gt;sadb_sa_auth;
		sav-&gt;alg_enc = sa0-&gt;sadb_sa_encrypt;
		sav-&gt;flags = sa0-&gt;sadb_sa_flags;
		
		<span class="enscript-comment">/*
		 * Verify that a nat-traversal port was specified if
		 * the nat-traversal flag is set.
		 */</span>
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) != 0) {
			<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa_2) ||
				((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_port == 0) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: natt port not set.\n&quot;</span>));
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			sav-&gt;remote_ike_port = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_port;
			sav-&gt;natt_interval = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_interval;
			sav-&gt;natt_offload_interval = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_offload_interval;
		}
		
		<span class="enscript-comment">/*
		 * Verify if SADB_X_EXT_NATT_MULTIPLEUSERS flag is set that
		 * SADB_X_EXT_NATT is set and SADB_X_EXT_NATT_KEEPALIVE is not
		 * set (we're not behind nat) - otherwise clear it.
		 */</span>
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0)
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) == 0 ||
				(sav-&gt;flags &amp; SADB_X_EXT_NATT_KEEPALIVE) != 0)
				sav-&gt;flags &amp;= ~SADB_X_EXT_NATT_MULTIPLEUSERS;
		
		<span class="enscript-comment">/* replay window */</span>
		<span class="enscript-keyword">if</span> ((sa0-&gt;sadb_sa_flags &amp; SADB_X_EXT_OLD) == 0) {
			sav-&gt;replay = keydb_newsecreplay(sa0-&gt;sadb_sa_replay);
			<span class="enscript-keyword">if</span> (sav-&gt;replay == NULL) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
		}
	}
	
	<span class="enscript-comment">/* Authentication keys */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_KEY_AUTH] != NULL) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_key *key0;
		<span class="enscript-type">int</span> len;
		
		key0 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_key *)mhp-&gt;ext[SADB_EXT_KEY_AUTH];
		len = mhp-&gt;extlen[SADB_EXT_KEY_AUTH];
		
		error = 0;
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*key0)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid auth key ext len. len = %d\n&quot;</span>, len));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">switch</span> (mhp-&gt;msg-&gt;sadb_msg_satype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_AH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_ESP</span>:
				<span class="enscript-keyword">if</span> (len == PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key)) &amp;&amp;
					sav-&gt;alg_auth != SADB_X_AALG_NULL)
					error = EINVAL;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SATYPE_IPCOMP</span>:
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (error) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid key_auth values.\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		
		sav-&gt;key_auth = (<span class="enscript-type">struct</span> sadb_key *)key_newbuf(key0, len);
		<span class="enscript-keyword">if</span> (sav-&gt;key_auth == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	<span class="enscript-comment">/* Encryption key */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_KEY_ENCRYPT] != NULL) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_key *key0;
		<span class="enscript-type">int</span> len;
		
		key0 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_key *)mhp-&gt;ext[SADB_EXT_KEY_ENCRYPT];
		len = mhp-&gt;extlen[SADB_EXT_KEY_ENCRYPT];
		
		error = 0;
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*key0)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid encryption key ext len. len = %d\n&quot;</span>, len));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">switch</span> (mhp-&gt;msg-&gt;sadb_msg_satype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_ESP</span>:
				<span class="enscript-keyword">if</span> (len == PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key)) &amp;&amp;
					sav-&gt;alg_enc != SADB_EALG_NULL) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid ESP algorithm.\n&quot;</span>));
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				sav-&gt;key_enc = (<span class="enscript-type">struct</span> sadb_key *)key_newbuf(key0, len);
				<span class="enscript-keyword">if</span> (sav-&gt;key_enc == NULL) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SATYPE_IPCOMP</span>:
				<span class="enscript-keyword">if</span> (len != PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key)))
					error = EINVAL;
				sav-&gt;key_enc = NULL;	<span class="enscript-comment">/*just in case*/</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_AH</span>:
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (error) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid key_enc value.\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	<span class="enscript-comment">/* set iv */</span>
	sav-&gt;ivlen = 0;
	
	<span class="enscript-keyword">switch</span> (mhp-&gt;msg-&gt;sadb_msg_satype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
			algo = esp_algorithm_lookup(sav-&gt;alg_enc);
			<span class="enscript-keyword">if</span> (algo &amp;&amp; algo-&gt;ivlen)
				sav-&gt;ivlen = (*algo-&gt;ivlen)(algo, sav);
			<span class="enscript-keyword">if</span> (sav-&gt;ivlen == 0)
				<span class="enscript-keyword">break</span>;
			KMALLOC_NOWAIT(sav-&gt;iv, caddr_t, sav-&gt;ivlen);
			<span class="enscript-keyword">if</span> (sav-&gt;iv == 0) {
				lck_mtx_unlock(sadb_mutex);
				KMALLOC_WAIT(sav-&gt;iv, caddr_t, sav-&gt;ivlen);
				lck_mtx_lock(sadb_mutex);
				<span class="enscript-keyword">if</span> (sav-&gt;iv == 0) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
			}
			
			<span class="enscript-comment">/* initialize */</span>
			key_randomfill(sav-&gt;iv, sav-&gt;ivlen);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_AH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SATYPE_IPCOMP</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid SA type.\n&quot;</span>));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-comment">/* reset created */</span>
	microtime(&amp;tv);
	sav-&gt;created = tv.tv_sec;
	
	<span class="enscript-comment">/* make lifetime for CURRENT */</span>
	KMALLOC_NOWAIT(sav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
				   <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(sav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
					 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	    lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	microtime(&amp;tv);
	
	sav-&gt;lft_c-&gt;sadb_lifetime_len =
	PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	sav-&gt;lft_c-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
	sav-&gt;lft_c-&gt;sadb_lifetime_allocations = 0;
	sav-&gt;lft_c-&gt;sadb_lifetime_bytes = 0;
	sav-&gt;lft_c-&gt;sadb_lifetime_addtime = tv.tv_sec;
	sav-&gt;lft_c-&gt;sadb_lifetime_usetime = 0;
	
	<span class="enscript-comment">/* lifetimes for HARD and SOFT */</span>
    {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_lifetime *lft0;
		
		lft0 = (<span class="enscript-type">struct</span> sadb_lifetime *)
	    (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_LIFETIME_HARD];
		<span class="enscript-keyword">if</span> (lft0 != NULL) {
			<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_LIFETIME_HARD] &lt; <span class="enscript-keyword">sizeof</span>(*lft0)) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid hard lifetime ext len.\n&quot;</span>));
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			sav-&gt;lft_h = (<span class="enscript-type">struct</span> sadb_lifetime *)key_newbuf(lft0,
															<span class="enscript-keyword">sizeof</span>(*lft0));
			<span class="enscript-keyword">if</span> (sav-&gt;lft_h == NULL) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			<span class="enscript-comment">/* to be initialize ? */</span>
		}
		
		lft0 = (<span class="enscript-type">struct</span> sadb_lifetime *)
	    (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_LIFETIME_SOFT];
		<span class="enscript-keyword">if</span> (lft0 != NULL) {
			<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_LIFETIME_SOFT] &lt; <span class="enscript-keyword">sizeof</span>(*lft0)) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: invalid soft lifetime ext len.\n&quot;</span>));
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			sav-&gt;lft_s = (<span class="enscript-type">struct</span> sadb_lifetime *)key_newbuf(lft0,
															<span class="enscript-keyword">sizeof</span>(*lft0));
			<span class="enscript-keyword">if</span> (sav-&gt;lft_s == NULL) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			<span class="enscript-comment">/* to be initialize ? */</span>
		}
    }
	
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">/* initialization */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;replay != NULL) {
		keydb_delsecreplay(sav-&gt;replay);
		sav-&gt;replay = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;key_auth != NULL) {
		bzero(_KEYBUF(sav-&gt;key_auth), _KEYLEN(sav-&gt;key_auth));
		KFREE(sav-&gt;key_auth);
		sav-&gt;key_auth = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;key_enc != NULL) {
		bzero(_KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc));
		KFREE(sav-&gt;key_enc);
		sav-&gt;key_enc = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;sched) {
		bzero(sav-&gt;sched, sav-&gt;schedlen);
		KFREE(sav-&gt;sched);
		sav-&gt;sched = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;iv != NULL) {
		KFREE(sav-&gt;iv);
		sav-&gt;iv = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_c != NULL) {
		KFREE(sav-&gt;lft_c);
		sav-&gt;lft_c = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_h != NULL) {
		KFREE(sav-&gt;lft_h);
		sav-&gt;lft_h = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_s != NULL) {
		KFREE(sav-&gt;lft_s);
		sav-&gt;lft_s = NULL;
	}
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * copy SA values from PF_KEY message except *SPI, SEQ, PID, STATE and TYPE*.
 * You must update these if need.
 * OUT:	0:	success.
 *	!0:	failure.
 *
 * does not modify mbuf.  does not free mbuf on error.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_setsaval2</span>(<span class="enscript-type">struct</span> secasvar      *sav,
			  u_int8_t              satype,
			  u_int8_t              alg_auth,
			  u_int8_t              alg_enc,
			  u_int32_t             flags,
			  u_int8_t              replay,
			  <span class="enscript-type">struct</span> sadb_key      *key_auth,
			  u_int16_t             key_auth_len,
			  <span class="enscript-type">struct</span> sadb_key      *key_enc,
			  u_int16_t             key_enc_len,
			  u_int16_t             natt_port,
			  u_int32_t             seq,
			  u_int32_t             spi,
			  u_int32_t             pid,
			  <span class="enscript-type">struct</span> sadb_lifetime *lifetime_hard,
			  <span class="enscript-type">struct</span> sadb_lifetime *lifetime_soft)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timeval tv;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* initialization */</span>
	sav-&gt;replay = NULL;
	sav-&gt;key_auth = NULL;
	sav-&gt;key_enc = NULL;
	sav-&gt;sched = NULL;
	sav-&gt;schedlen = 0;
	sav-&gt;iv = NULL;
	sav-&gt;lft_c = NULL;
	sav-&gt;lft_h = NULL;
	sav-&gt;lft_s = NULL;
	sav-&gt;remote_ike_port = 0;
	sav-&gt;natt_last_activity = natt_now;
	sav-&gt;natt_encapsulated_src_port = 0;
	
	sav-&gt;alg_auth = alg_auth;
	sav-&gt;alg_enc = alg_enc;
	sav-&gt;flags = flags;
	sav-&gt;pid = pid;
	sav-&gt;seq = seq;
	key_setspi(sav, htonl(spi));
	
	<span class="enscript-comment">/*
	 * Verify that a nat-traversal port was specified if
	 * the nat-traversal flag is set.
	 */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) != 0) {
		<span class="enscript-keyword">if</span> (natt_port == 0) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval2: natt port not set.\n&quot;</span>));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		sav-&gt;remote_ike_port = natt_port;
	}
	
	<span class="enscript-comment">/*
	 * Verify if SADB_X_EXT_NATT_MULTIPLEUSERS flag is set that
	 * SADB_X_EXT_NATT is set and SADB_X_EXT_NATT_KEEPALIVE is not
	 * set (we're not behind nat) - otherwise clear it.
	 */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0)
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) == 0 ||
			(sav-&gt;flags &amp; SADB_X_EXT_NATT_KEEPALIVE) != 0)
			sav-&gt;flags &amp;= ~SADB_X_EXT_NATT_MULTIPLEUSERS;
	
	<span class="enscript-comment">/* replay window */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; SADB_X_EXT_OLD) == 0) {
		sav-&gt;replay = keydb_newsecreplay(replay);
		<span class="enscript-keyword">if</span> (sav-&gt;replay == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	<span class="enscript-comment">/* Authentication keys */</span>
	sav-&gt;key_auth = (__typeof__(sav-&gt;key_auth))key_newbuf(key_auth, key_auth_len);
	<span class="enscript-keyword">if</span> (sav-&gt;key_auth == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-comment">/* Encryption key */</span>
	sav-&gt;key_enc = (__typeof__(sav-&gt;key_enc))key_newbuf(key_enc, key_enc_len);
	<span class="enscript-keyword">if</span> (sav-&gt;key_enc == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-comment">/* set iv */</span>
	sav-&gt;ivlen = 0;
	
	<span class="enscript-keyword">if</span> (satype == SADB_SATYPE_ESP) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		algo = esp_algorithm_lookup(sav-&gt;alg_enc);
		<span class="enscript-keyword">if</span> (algo &amp;&amp; algo-&gt;ivlen)
			sav-&gt;ivlen = (*algo-&gt;ivlen)(algo, sav);
		<span class="enscript-keyword">if</span> (sav-&gt;ivlen != 0) {
			KMALLOC_NOWAIT(sav-&gt;iv, caddr_t, sav-&gt;ivlen);
			<span class="enscript-keyword">if</span> (sav-&gt;iv == 0) {
				lck_mtx_unlock(sadb_mutex);
				KMALLOC_WAIT(sav-&gt;iv, caddr_t, sav-&gt;ivlen);
				lck_mtx_lock(sadb_mutex);
				<span class="enscript-keyword">if</span> (sav-&gt;iv == 0) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
			}
			<span class="enscript-comment">/* initialize */</span>
			key_randomfill(sav-&gt;iv, sav-&gt;ivlen);
		}
#<span class="enscript-reference">endif</span>
	}
	
	<span class="enscript-comment">/* reset created */</span>
	microtime(&amp;tv);
	sav-&gt;created = tv.tv_sec;
	
	<span class="enscript-comment">/* make lifetime for CURRENT */</span>
	KMALLOC_NOWAIT(sav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
				   <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(sav-&gt;lft_c, <span class="enscript-type">struct</span> sadb_lifetime *,
					 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	    lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	microtime(&amp;tv);
	
	sav-&gt;lft_c-&gt;sadb_lifetime_len =
	PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	sav-&gt;lft_c-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
	sav-&gt;lft_c-&gt;sadb_lifetime_allocations = 0;
	sav-&gt;lft_c-&gt;sadb_lifetime_bytes = 0;
	sav-&gt;lft_c-&gt;sadb_lifetime_addtime = tv.tv_sec;
	sav-&gt;lft_c-&gt;sadb_lifetime_usetime = 0;
	
	<span class="enscript-comment">/* lifetimes for HARD and SOFT */</span>
	sav-&gt;lft_h = (__typeof__(sav-&gt;lft_h))key_newbuf(lifetime_hard,
													<span class="enscript-keyword">sizeof</span>(*lifetime_hard));
	<span class="enscript-keyword">if</span> (sav-&gt;lft_h == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	sav-&gt;lft_s = (__typeof__(sav-&gt;lft_s))key_newbuf(lifetime_soft,
													<span class="enscript-keyword">sizeof</span>(*lifetime_soft));
	<span class="enscript-keyword">if</span> (sav-&gt;lft_s == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setsaval: No more memory.\n&quot;</span>));
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">/* initialization */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;replay != NULL) {
		keydb_delsecreplay(sav-&gt;replay);
		sav-&gt;replay = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;key_auth != NULL) {
		bzero(_KEYBUF(sav-&gt;key_auth), _KEYLEN(sav-&gt;key_auth));
		KFREE(sav-&gt;key_auth);
		sav-&gt;key_auth = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;key_enc != NULL) {
		bzero(_KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc));
		KFREE(sav-&gt;key_enc);
		sav-&gt;key_enc = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;sched) {
		bzero(sav-&gt;sched, sav-&gt;schedlen);
		KFREE(sav-&gt;sched);
		sav-&gt;sched = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;iv != NULL) {
		KFREE(sav-&gt;iv);
		sav-&gt;iv = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_c != NULL) {
		KFREE(sav-&gt;lft_c);
		sav-&gt;lft_c = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_h != NULL) {
		KFREE(sav-&gt;lft_h);
		sav-&gt;lft_h = NULL;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;lft_s != NULL) {
		KFREE(sav-&gt;lft_s);
		sav-&gt;lft_s = NULL;
	}
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * validation with a secasvar entry, and set SADB_SATYPE_MATURE.
 * OUT:	0:	valid
 *	other:	errno
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_mature</span>(
		   <span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">int</span> mature;
	<span class="enscript-type">int</span> checkmask = 0;	<span class="enscript-comment">/* 2^0: ealg  2^1: aalg  2^2: calg */</span>
	<span class="enscript-type">int</span> mustmask = 0;	<span class="enscript-comment">/* 2^0: ealg  2^1: aalg  2^2: calg */</span>
	
	mature = 0;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* check SPI value */</span>
	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			
			<span class="enscript-comment">/* No reason to test if this is &gt;= 0, because ntohl(sav-&gt;spi) is unsigned. */</span>
			<span class="enscript-keyword">if</span> (ntohl(sav-&gt;spi) &lt;= 255) {
				ipseclog((LOG_DEBUG,
						  <span class="enscript-string">&quot;key_mature: illegal range of SPI %u.\n&quot;</span>,
						  (u_int32_t)ntohl(sav-&gt;spi)));
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-comment">/* check satype */</span>
	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			<span class="enscript-comment">/* check flags */</span>
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD)
				&amp;&amp; (sav-&gt;flags &amp; SADB_X_EXT_DERIV)) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: &quot;</span>
						  <span class="enscript-string">&quot;invalid flag (derived) given to old-esp.\n&quot;</span>));
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">if</span> (sav-&gt;alg_auth == SADB_AALG_NONE)
				checkmask = 1;
			<span class="enscript-keyword">else</span>
				checkmask = 3;
			mustmask = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			<span class="enscript-comment">/* check flags */</span>
			<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: &quot;</span>
						  <span class="enscript-string">&quot;invalid flag (derived) given to AH SA.\n&quot;</span>));
				<span class="enscript-keyword">return</span> EINVAL;
			}
			<span class="enscript-keyword">if</span> (sav-&gt;alg_enc != SADB_EALG_NONE) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: &quot;</span>
						  <span class="enscript-string">&quot;protocol and algorithm mismated.\n&quot;</span>));
				<span class="enscript-keyword">return</span>(EINVAL);
			}
			checkmask = 2;
			mustmask = 2;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			<span class="enscript-keyword">if</span> (sav-&gt;alg_auth != SADB_AALG_NONE) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: &quot;</span>
						  <span class="enscript-string">&quot;protocol and algorithm mismated.\n&quot;</span>));
				<span class="enscript-keyword">return</span>(EINVAL);
			}
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_RAWCPI) == 0
				&amp;&amp; ntohl(sav-&gt;spi) &gt;= 0x10000) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: invalid cpi for IPComp.\n&quot;</span>));
				<span class="enscript-keyword">return</span>(EINVAL);
			}
			checkmask = 4;
			mustmask = 4;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: Invalid satype.\n&quot;</span>));
			<span class="enscript-keyword">return</span> EPROTONOSUPPORT;
	}
	
	<span class="enscript-comment">/* check authentication algorithm */</span>
	<span class="enscript-keyword">if</span> ((checkmask &amp; 2) != 0) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
		<span class="enscript-type">int</span> keylen;
		
		algo = ah_algorithm_lookup(sav-&gt;alg_auth);
		<span class="enscript-keyword">if</span> (!algo) {
			ipseclog((LOG_DEBUG,<span class="enscript-string">&quot;key_mature: &quot;</span>
					  <span class="enscript-string">&quot;unknown authentication algorithm.\n&quot;</span>));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		<span class="enscript-comment">/* algorithm-dependent check */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;key_auth)
			keylen = sav-&gt;key_auth-&gt;sadb_key_bits;
		<span class="enscript-keyword">else</span>
			keylen = 0;
		<span class="enscript-keyword">if</span> (keylen &lt; algo-&gt;keymin || algo-&gt;keymax &lt; keylen) {
			ipseclog((LOG_DEBUG,
					  <span class="enscript-string">&quot;key_mature: invalid AH key length %d &quot;</span>
					  <span class="enscript-string">&quot;(%d-%d allowed)\n&quot;</span>,
					  keylen, algo-&gt;keymin, algo-&gt;keymax));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		<span class="enscript-keyword">if</span> (algo-&gt;mature) {
			<span class="enscript-keyword">if</span> ((*algo-&gt;mature)(sav)) {
				<span class="enscript-comment">/* message generated in per-algorithm function*/</span>
				<span class="enscript-keyword">return</span> EINVAL;
			} <span class="enscript-keyword">else</span>
				mature = SADB_SATYPE_AH;
		}
		
		<span class="enscript-keyword">if</span> ((mustmask &amp; 2) != 0 &amp;&amp;  mature != SADB_SATYPE_AH) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: no satisfy algorithm for AH\n&quot;</span>));
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}
	
	<span class="enscript-comment">/* check encryption algorithm */</span>
	<span class="enscript-keyword">if</span> ((checkmask &amp; 1) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
		<span class="enscript-type">int</span> keylen;
		
		algo = esp_algorithm_lookup(sav-&gt;alg_enc);
		<span class="enscript-keyword">if</span> (!algo) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: unknown encryption algorithm.\n&quot;</span>));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		<span class="enscript-comment">/* algorithm-dependent check */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;key_enc)
			keylen = sav-&gt;key_enc-&gt;sadb_key_bits;
		<span class="enscript-keyword">else</span>
			keylen = 0;
		<span class="enscript-keyword">if</span> (keylen &lt; algo-&gt;keymin || algo-&gt;keymax &lt; keylen) {
			ipseclog((LOG_DEBUG,
					  <span class="enscript-string">&quot;key_mature: invalid ESP key length %d &quot;</span>
					  <span class="enscript-string">&quot;(%d-%d allowed)\n&quot;</span>,
					  keylen, algo-&gt;keymin, algo-&gt;keymax));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		<span class="enscript-keyword">if</span> (algo-&gt;mature) {
			<span class="enscript-keyword">if</span> ((*algo-&gt;mature)(sav)) {
				<span class="enscript-comment">/* message generated in per-algorithm function*/</span>
				<span class="enscript-keyword">return</span> EINVAL;
			} <span class="enscript-keyword">else</span>
				mature = SADB_SATYPE_ESP;
		}
		
		<span class="enscript-keyword">if</span> ((mustmask &amp; 1) != 0 &amp;&amp;  mature != SADB_SATYPE_ESP) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: no satisfy algorithm for ESP\n&quot;</span>));
			<span class="enscript-keyword">return</span> EINVAL;
		}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/*IPSEC_ESP*/</span>
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: ESP not supported in this configuration\n&quot;</span>));
		<span class="enscript-keyword">return</span> EINVAL;
#<span class="enscript-reference">endif</span>
	}
	
	<span class="enscript-comment">/* check compression algorithm */</span>
	<span class="enscript-keyword">if</span> ((checkmask &amp; 4) != 0) {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ipcomp_algorithm *algo;
		
		<span class="enscript-comment">/* algorithm-dependent check */</span>
		algo = ipcomp_algorithm_lookup(sav-&gt;alg_enc);
		<span class="enscript-keyword">if</span> (!algo) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_mature: unknown compression algorithm.\n&quot;</span>));
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}
	
	key_sa_chgstate(sav, SADB_SASTATE_MATURE);
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * subroutine for SADB_GET and SADB_DUMP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setdumpsa</span>(
			  <span class="enscript-type">struct</span> secasvar *sav,
			  u_int8_t type,
			  u_int8_t satype,
			  u_int32_t seq,
			  u_int32_t pid)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *tres = NULL, *m;
	<span class="enscript-type">int</span> l = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">void</span> *p;
	<span class="enscript-type">int</span> dumporder[] = {
		SADB_EXT_SA, SADB_X_EXT_SA2,
		SADB_EXT_LIFETIME_HARD, SADB_EXT_LIFETIME_SOFT,
		SADB_EXT_LIFETIME_CURRENT, SADB_EXT_ADDRESS_SRC,
		SADB_EXT_ADDRESS_DST, SADB_EXT_ADDRESS_PROXY, SADB_EXT_KEY_AUTH,
		SADB_EXT_KEY_ENCRYPT, SADB_EXT_IDENTITY_SRC,
		SADB_EXT_IDENTITY_DST, SADB_EXT_SENSITIVITY,
	};
	
	m = key_setsadbmsg(type, 0, satype, seq, pid, sav-&gt;refcnt);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	result = m;
	
	<span class="enscript-keyword">for</span> (i = <span class="enscript-keyword">sizeof</span>(dumporder)/<span class="enscript-keyword">sizeof</span>(dumporder[0]) - 1; i &gt;= 0; i--) {
		m = NULL;
		p = NULL;
		<span class="enscript-keyword">switch</span> (dumporder[i]) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SA</span>:
				m = key_setsadbsa(sav);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_SA2</span>:
				m = key_setsadbxsa2(sav-&gt;sah-&gt;saidx.mode,
									sav-&gt;replay ? sav-&gt;replay-&gt;count : 0,
									sav-&gt;sah-&gt;saidx.reqid,
									sav-&gt;flags2);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_SRC</span>:
				m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src,
									FULLMASK, IPSEC_ULPROTO_ANY);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_DST</span>:
				m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
									(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst,
									FULLMASK, IPSEC_ULPROTO_ANY);
				<span class="enscript-keyword">if</span> (!m)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_KEY_AUTH</span>:
				<span class="enscript-keyword">if</span> (!sav-&gt;key_auth)
					<span class="enscript-keyword">continue</span>;
				l = PFKEY_UNUNIT64(sav-&gt;key_auth-&gt;sadb_key_len);
				p = sav-&gt;key_auth;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_KEY_ENCRYPT</span>:
				<span class="enscript-keyword">if</span> (!sav-&gt;key_enc)
					<span class="enscript-keyword">continue</span>;
				l = PFKEY_UNUNIT64(sav-&gt;key_enc-&gt;sadb_key_len);
				p = sav-&gt;key_enc;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_CURRENT</span>:
				<span class="enscript-keyword">if</span> (!sav-&gt;lft_c)
					<span class="enscript-keyword">continue</span>;
				l = PFKEY_UNUNIT64(((<span class="enscript-type">struct</span> sadb_ext *)sav-&gt;lft_c)-&gt;sadb_ext_len);
				p = sav-&gt;lft_c;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_HARD</span>:
				<span class="enscript-keyword">if</span> (!sav-&gt;lft_h)
					<span class="enscript-keyword">continue</span>;
				l = PFKEY_UNUNIT64(((<span class="enscript-type">struct</span> sadb_ext *)sav-&gt;lft_h)-&gt;sadb_ext_len);
				p = sav-&gt;lft_h;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_SOFT</span>:
				<span class="enscript-keyword">if</span> (!sav-&gt;lft_s)
					<span class="enscript-keyword">continue</span>;
				l = PFKEY_UNUNIT64(((<span class="enscript-type">struct</span> sadb_ext *)sav-&gt;lft_s)-&gt;sadb_ext_len);
				p = sav-&gt;lft_s;
				<span class="enscript-keyword">break</span>;
				
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_PROXY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_SRC</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_DST</span>:
				<span class="enscript-comment">/* XXX: should we brought from SPD ? */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SENSITIVITY</span>:
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-keyword">if</span> ((!m &amp;&amp; !p) || (m &amp;&amp; p))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		<span class="enscript-keyword">if</span> (p &amp;&amp; tres) {
			M_PREPEND(tres, l, M_WAITOK, 1);
			<span class="enscript-keyword">if</span> (!tres)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			bcopy(p, mtod(tres, caddr_t), l);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (p) {
			m = key_alloc_mbuf(l);
			<span class="enscript-keyword">if</span> (!m)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			m_copyback(m, 0, l, p);
		}
		
		<span class="enscript-keyword">if</span> (tres)
			m_cat(m, tres);
		tres = m;
	}
	
	m_cat(result, tres);
	
	<span class="enscript-keyword">if</span> (sav-&gt;sah &amp;&amp; (sav-&gt;sah-&gt;outgoing_if || sav-&gt;sah-&gt;ipsec_if)) {
        m = key_setsadbipsecif(NULL, ifindex2ifnet[sav-&gt;sah-&gt;outgoing_if], sav-&gt;sah-&gt;ipsec_if, 0);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> result;
	
<span class="enscript-reference">fail</span>:
	m_freem(result);
	m_freem(tres);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * set data into sadb_msg.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbmsg</span>(
			   u_int8_t type,
			   u_int16_t tlen,
			   u_int8_t satype,
			   u_int32_t seq,
			   pid_t pid,
			   u_int16_t reserved)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_msg *p;
	<span class="enscript-type">int</span> len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
	<span class="enscript-keyword">if</span> (len &gt; MCLBYTES)
		<span class="enscript-keyword">return</span> NULL;
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m &amp;&amp; len &gt; MHLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
			m_freem(m);
			m = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">return</span> NULL;
	m-&gt;m_pkthdr.len = m-&gt;m_len = len;
	m-&gt;m_next = NULL;
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	
	bzero(p, len);
	p-&gt;sadb_msg_version = PF_KEY_V2;
	p-&gt;sadb_msg_type = type;
	p-&gt;sadb_msg_errno = 0;
	p-&gt;sadb_msg_satype = satype;
	p-&gt;sadb_msg_len = PFKEY_UNIT64(tlen);
	p-&gt;sadb_msg_reserved = reserved;
	p-&gt;sadb_msg_seq = seq;
	p-&gt;sadb_msg_pid = (u_int32_t)pid;
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * copy secasvar data into sadb_address.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbsa</span>(
			  <span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_sa *p;
	<span class="enscript-type">int</span> len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa));
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_sa *);
	
	bzero(p, len);
	p-&gt;sadb_sa_len = PFKEY_UNIT64(len);
	p-&gt;sadb_sa_exttype = SADB_EXT_SA;
	p-&gt;sadb_sa_spi = sav-&gt;spi;
	p-&gt;sadb_sa_replay = (sav-&gt;replay != NULL ? sav-&gt;replay-&gt;wsize : 0);
	p-&gt;sadb_sa_state = sav-&gt;state;
	p-&gt;sadb_sa_auth = sav-&gt;alg_auth;
	p-&gt;sadb_sa_encrypt = sav-&gt;alg_enc;
	p-&gt;sadb_sa_flags = sav-&gt;flags;
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * set data into sadb_address.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbaddr</span>(
				u_int16_t exttype,
				<span class="enscript-type">struct</span> sockaddr *saddr,
				u_int8_t prefixlen,
				u_int16_t ul_proto)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_address *p;
	size_t len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) +
	PFKEY_ALIGN8(saddr-&gt;sa_len);
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_address *);
	
	bzero(p, len);
	p-&gt;sadb_address_len = PFKEY_UNIT64(len);
	p-&gt;sadb_address_exttype = exttype;
	p-&gt;sadb_address_proto = ul_proto;
	<span class="enscript-keyword">if</span> (prefixlen == FULLMASK) {
		<span class="enscript-keyword">switch</span> (saddr-&gt;sa_family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				prefixlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) &lt;&lt; 3;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				prefixlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) &lt;&lt; 3;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				; <span class="enscript-comment">/*XXX*/</span>
		}
	}
	p-&gt;sadb_address_prefixlen = prefixlen;
	p-&gt;sadb_address_reserved = 0;
	
	bcopy(saddr,
		  mtod(m, caddr_t) + PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)),
		  saddr-&gt;sa_len);
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbipsecif</span>(ifnet_t internal_if,
                   ifnet_t outgoing_if,
                   ifnet_t ipsec_if,
                   <span class="enscript-type">int</span> init_disabled)
{
    <span class="enscript-type">struct</span> mbuf *m;
    <span class="enscript-type">struct</span> sadb_x_ipsecif *p;
	size_t len;
    
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_ipsecif));
    m = key_alloc_mbuf(len);
    <span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
    p = mtod(m, <span class="enscript-type">struct</span> sadb_x_ipsecif *);
    
	bzero(p, len);
    p-&gt;sadb_x_ipsecif_len = PFKEY_UNIT64(len);
	p-&gt;sadb_x_ipsecif_exttype = SADB_X_EXT_IPSECIF;
    
    <span class="enscript-keyword">if</span> (internal_if &amp;&amp; internal_if-&gt;if_xname)
        strlcpy(p-&gt;sadb_x_ipsecif_internal_if, internal_if-&gt;if_xname, IFXNAMSIZ);
    <span class="enscript-keyword">if</span> (outgoing_if &amp;&amp; outgoing_if-&gt;if_xname)
        strlcpy(p-&gt;sadb_x_ipsecif_outgoing_if, outgoing_if-&gt;if_xname, IFXNAMSIZ);
    <span class="enscript-keyword">if</span> (ipsec_if &amp;&amp; ipsec_if-&gt;if_xname)
        strlcpy(p-&gt;sadb_x_ipsecif_ipsec_if, ipsec_if-&gt;if_xname, IFXNAMSIZ);
    
	p-&gt;sadb_x_ipsecif_init_disabled = init_disabled;
    
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * set data into sadb_session_id
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbsession_id</span> (u_int64_t session_ids[])
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_session_id *p;
	size_t len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*p));
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, __typeof__(p));
	
	bzero(p, len);
	p-&gt;sadb_session_id_len = PFKEY_UNIT64(len);
	p-&gt;sadb_session_id_exttype = SADB_EXT_SESSION_ID;
	p-&gt;sadb_session_id_v[0] = session_ids[0];
	p-&gt;sadb_session_id_v[1] = session_ids[1];
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * copy stats data into sadb_sastat type.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbsastat</span> (u_int32_t      dir,
				   <span class="enscript-type">struct</span> sastat *stats,
				   u_int32_t      max_stats)
{
	<span class="enscript-type">struct</span> mbuf        *m;
	<span class="enscript-type">struct</span> sadb_sastat *p;
	<span class="enscript-type">int</span>                 list_len, len;
	
	<span class="enscript-keyword">if</span> (!stats) {
		<span class="enscript-keyword">return</span> NULL;
	}
	
	list_len = <span class="enscript-keyword">sizeof</span>(*stats) * max_stats;
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*p)) + PFKEY_ALIGN8(list_len);
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, __typeof__(p));
	
	bzero(p, len);
	p-&gt;sadb_sastat_len      = PFKEY_UNIT64(len);
	p-&gt;sadb_sastat_exttype  = SADB_EXT_SASTAT;
	p-&gt;sadb_sastat_dir      = dir;
	p-&gt;sadb_sastat_list_len = max_stats;
	<span class="enscript-keyword">if</span> (list_len) {
		bcopy(stats,
		      mtod(m, caddr_t) + PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*p)),
		      list_len);
	}
	
	<span class="enscript-keyword">return</span> m;
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * set data into sadb_ident.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbident</span>(
				 u_int16_t exttype,
				 u_int16_t idtype,
				 caddr_t string,
				 <span class="enscript-type">int</span> stringlen,
				 u_int64_t id)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_ident *p;
	size_t len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident)) + PFKEY_ALIGN8(stringlen);
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_ident *);
	
	bzero(p, len);
	p-&gt;sadb_ident_len = PFKEY_UNIT64(len);
	p-&gt;sadb_ident_exttype = exttype;
	p-&gt;sadb_ident_type = idtype;
	p-&gt;sadb_ident_reserved = 0;
	p-&gt;sadb_ident_id = id;
	
	bcopy(string,
		  mtod(m, caddr_t) + PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident)),
		  stringlen);
	
	<span class="enscript-keyword">return</span> m;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * set data into sadb_x_sa2.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbxsa2</span>(
				u_int8_t mode,
				u_int32_t seq,
				u_int32_t reqid,
				u_int16_t flags)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_x_sa2 *p;
	size_t len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_sa2));
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_x_sa2 *);
	
	bzero(p, len);
	p-&gt;sadb_x_sa2_len = PFKEY_UNIT64(len);
	p-&gt;sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	p-&gt;sadb_x_sa2_mode = mode;
	p-&gt;sadb_x_sa2_reserved1 = 0;
	p-&gt;sadb_x_sa2_reserved2 = 0;
	p-&gt;sadb_x_sa2_sequence = seq;
	p-&gt;sadb_x_sa2_reqid = reqid;
	p-&gt;sadb_x_sa2_flags = flags;
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * set data into sadb_x_policy
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setsadbxpolicy</span>(
				   u_int16_t type,
				   u_int8_t dir,
				   u_int32_t id)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> sadb_x_policy *p;
	size_t len;
	
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_x_policy));
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	p = mtod(m, <span class="enscript-type">struct</span> sadb_x_policy *);
	
	bzero(p, len);
	p-&gt;sadb_x_policy_len = PFKEY_UNIT64(len);
	p-&gt;sadb_x_policy_exttype = SADB_X_EXT_POLICY;
	p-&gt;sadb_x_policy_type = type;
	p-&gt;sadb_x_policy_dir = dir;
	p-&gt;sadb_x_policy_id = id;
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/* %%% utilities */</span>
<span class="enscript-comment">/*
 * copy a buffer into the new buffer allocated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">key_newbuf</span>(
		   <span class="enscript-type">const</span> <span class="enscript-type">void</span> *src,
		   u_int len)
{
	caddr_t new;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	KMALLOC_NOWAIT(new, caddr_t, len);
	<span class="enscript-keyword">if</span> (new == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(new, caddr_t, len);
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (new == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newbuf: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	bcopy(src, new, len);
	
	<span class="enscript-keyword">return</span> new;
}

<span class="enscript-comment">/* compare my own address
 * OUT:	1: true, i.e. my address.
 *	0: false
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_ismyaddr</span>(
			 <span class="enscript-type">struct</span> sockaddr *sa)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	<span class="enscript-type">struct</span> in_ifaddr *ia;
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sa == NULL)
		panic(<span class="enscript-string">&quot;key_ismyaddr: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">switch</span> (sa-&gt;sa_family) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			lck_rw_lock_shared(in_ifaddr_rwlock);
			sin = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)sa;
			<span class="enscript-keyword">for</span> (ia = in_ifaddrhead.tqh_first; ia;
				 ia = ia-&gt;ia_link.tqe_next) {
				IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> (sin-&gt;sin_family == ia-&gt;ia_addr.sin_family &amp;&amp;
					sin-&gt;sin_len == ia-&gt;ia_addr.sin_len &amp;&amp;
					sin-&gt;sin_addr.s_addr == ia-&gt;ia_addr.sin_addr.s_addr)
				{
					IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
					lck_rw_done(in_ifaddr_rwlock);
					<span class="enscript-keyword">return</span> 1;
				}
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			}
			lck_rw_done(in_ifaddr_rwlock);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">return</span> key_ismyaddr6((<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)sa);
#<span class="enscript-reference">endif</span>
	}
	
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * compare my own address for IPv6.
 * 1: ours
 * 0: other
 * NOTE: derived ip6_input() in KAME. This is necessary to modify more.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_ismyaddr6</span>(
			  <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> in6_multi *in6m;
	
	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;sin6,
							(<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_addr, 0) == 0) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			<span class="enscript-keyword">return</span> 1;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		
		<span class="enscript-comment">/*
		 * XXX Multicast
		 * XXX why do we care about multlicast here while we don't care
		 * about IPv4 multicast??
		 * XXX scope
		 */</span>
		in6m = NULL;
		in6_multihead_lock_shared();
		IN6_LOOKUP_MULTI(&amp;sin6-&gt;sin6_addr, ia-&gt;ia_ifp, in6m);
		in6_multihead_lock_done();
		<span class="enscript-keyword">if</span> (in6m != NULL) {
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			IN6M_REMREF(in6m);
			<span class="enscript-keyword">return</span> 1;
		}
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);
	
	<span class="enscript-comment">/* loopback, just for safety */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(&amp;sin6-&gt;sin6_addr))
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>

<span class="enscript-comment">/*
 * compare two secasindex structure.
 * flag can specify to compare 2 saidxes.
 * compare two secasindex structure without both mode and reqid.
 * don't compare port.
 * IN:
 *      saidx0: source, it can be in SAD.
 *      saidx1: object.
 * OUT:
 *      1 : equal
 *      0 : not equal
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_cmpsaidx</span>(
			 <span class="enscript-type">struct</span> secasindex *saidx0,
			 <span class="enscript-type">struct</span> secasindex *saidx1,
			 <span class="enscript-type">int</span> flag)
{
	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> (saidx0 == NULL &amp;&amp; saidx1 == NULL)
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">if</span> (saidx0 == NULL || saidx1 == NULL)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (saidx0-&gt;ipsec_ifindex != 0 &amp;&amp; saidx0-&gt;ipsec_ifindex != saidx1-&gt;ipsec_ifindex)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (saidx0-&gt;proto != saidx1-&gt;proto)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (flag == CMP_EXACTLY) {
		<span class="enscript-keyword">if</span> (saidx0-&gt;mode != saidx1-&gt;mode)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-keyword">if</span> (saidx0-&gt;reqid != saidx1-&gt;reqid)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-keyword">if</span> (bcmp(&amp;saidx0-&gt;src, &amp;saidx1-&gt;src, saidx0-&gt;src.ss_len) != 0 ||
		    bcmp(&amp;saidx0-&gt;dst, &amp;saidx1-&gt;dst, saidx0-&gt;dst.ss_len) != 0)
			<span class="enscript-keyword">return</span> 0;
	} <span class="enscript-keyword">else</span> {
		
		<span class="enscript-comment">/* CMP_MODE_REQID, CMP_REQID, CMP_HEAD */</span>
		<span class="enscript-keyword">if</span> (flag &amp; CMP_REQID) {
			<span class="enscript-comment">/*
			 * If reqid of SPD is non-zero, unique SA is required.
			 * The result must be of same reqid in this case.
			 */</span>
			<span class="enscript-keyword">if</span> (saidx1-&gt;reqid != 0 &amp;&amp; saidx0-&gt;reqid != saidx1-&gt;reqid)
				<span class="enscript-keyword">return</span> 0;
		}
		
		<span class="enscript-keyword">if</span> (flag &amp; CMP_MODE) {
			<span class="enscript-keyword">if</span> (saidx0-&gt;mode != IPSEC_MODE_ANY
				&amp;&amp; saidx0-&gt;mode != saidx1-&gt;mode)
				<span class="enscript-keyword">return</span> 0;
		}
		
		<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx0-&gt;src,
							(<span class="enscript-type">struct</span> sockaddr *)&amp;saidx1-&gt;src, flag &amp; CMP_PORT ? 1 : 0) != 0) {
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx0-&gt;dst,
							(<span class="enscript-type">struct</span> sockaddr *)&amp;saidx1-&gt;dst, flag &amp; CMP_PORT ? 1 : 0) != 0) {
			<span class="enscript-keyword">return</span> 0;
		}
	}
	
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * compare two secindex structure exactly.
 * IN:
 *	spidx0: source, it is often in SPD.
 *	spidx1: object, it is often from PFKEY message.
 * OUT:
 *	1 : equal
 *	0 : not equal
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_cmpspidx_exactly</span>(
					 <span class="enscript-type">struct</span> secpolicyindex *spidx0,
					 <span class="enscript-type">struct</span> secpolicyindex *spidx1)
{
	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> (spidx0 == NULL &amp;&amp; spidx1 == NULL)
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">if</span> (spidx0 == NULL || spidx1 == NULL)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (spidx0-&gt;prefs != spidx1-&gt;prefs
		|| spidx0-&gt;prefd != spidx1-&gt;prefd
		|| spidx0-&gt;ul_proto != spidx1-&gt;ul_proto
		|| spidx0-&gt;internal_if != spidx1-&gt;internal_if)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;src,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;src, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;dst,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;dst, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
    
    <span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;src_range.start,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;src_range.start, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
    <span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;src_range.end,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;src_range.end, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;dst_range.start,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;dst_range.start, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
    <span class="enscript-keyword">if</span> (key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)&amp;spidx0-&gt;dst_range.end,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;spidx1-&gt;dst_range.end, 1) != 0) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * compare two secindex structure with mask.
 * IN:
 *	spidx0: source, it is often in SPD.
 *	spidx1: object, it is often from IP header.
 * OUT:
 *	1 : equal
 *	0 : not equal
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_cmpspidx_withmask</span>(
					  <span class="enscript-type">struct</span> secpolicyindex *spidx0,
					  <span class="enscript-type">struct</span> secpolicyindex *spidx1)
{
    <span class="enscript-type">int</span> spidx0_src_is_range = 0;
    <span class="enscript-type">int</span> spidx0_dst_is_range = 0;
    
	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> (spidx0 == NULL &amp;&amp; spidx1 == NULL)
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">if</span> (spidx0 == NULL || spidx1 == NULL)
		<span class="enscript-keyword">return</span> 0;
	
    <span class="enscript-keyword">if</span> (spidx0-&gt;src_range.start.ss_len &gt; 0)
        spidx0_src_is_range = 1;
    
    <span class="enscript-keyword">if</span> (spidx0-&gt;dst_range.start.ss_len &gt; 0)
        spidx0_dst_is_range = 1;
    
	<span class="enscript-keyword">if</span> ((spidx0_src_is_range ? spidx0-&gt;src_range.start.ss_family : spidx0-&gt;src.ss_family) != spidx1-&gt;src.ss_family ||
	    (spidx0_dst_is_range ? spidx0-&gt;dst_range.start.ss_family : spidx0-&gt;dst.ss_family) != spidx1-&gt;dst.ss_family ||
	    (spidx0_src_is_range ? spidx0-&gt;src_range.start.ss_len : spidx0-&gt;src.ss_len) != spidx1-&gt;src.ss_len ||
	    (spidx0_dst_is_range ? spidx0-&gt;dst_range.start.ss_len : spidx0-&gt;dst.ss_len) != spidx1-&gt;dst.ss_len)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-comment">/* if spidx.ul_proto == IPSEC_ULPROTO_ANY, ignore. */</span>
	<span class="enscript-keyword">if</span> (spidx0-&gt;ul_proto != (u_int16_t)IPSEC_ULPROTO_ANY
		&amp;&amp; spidx0-&gt;ul_proto != spidx1-&gt;ul_proto)
		<span class="enscript-keyword">return</span> 0;
	
    <span class="enscript-comment">/* If spidx1 specifies interface, ignore src addr */</span>
    <span class="enscript-keyword">if</span> (spidx1-&gt;internal_if != NULL) {
        <span class="enscript-keyword">if</span> (spidx0-&gt;internal_if == NULL
            || spidx0-&gt;internal_if != spidx1-&gt;internal_if)
            <span class="enscript-keyword">return</span> 0;
        
        <span class="enscript-comment">/* Still check ports */</span>
        <span class="enscript-keyword">switch</span> (spidx0-&gt;src.ss_family) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
                <span class="enscript-keyword">if</span> (spidx0_src_is_range &amp;&amp;
                    (satosin(&amp;spidx1-&gt;src)-&gt;sin_port &lt; satosin(&amp;spidx0-&gt;src_range.start)-&gt;sin_port
                     || satosin(&amp;spidx1-&gt;src)-&gt;sin_port &gt; satosin(&amp;spidx0-&gt;src_range.end)-&gt;sin_port))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin(&amp;spidx0-&gt;src)-&gt;sin_port != IPSEC_PORT_ANY
						 &amp;&amp; satosin(&amp;spidx0-&gt;src)-&gt;sin_port !=
						 satosin(&amp;spidx1-&gt;src)-&gt;sin_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
                <span class="enscript-keyword">if</span> (spidx0_src_is_range &amp;&amp;
                    (satosin6(&amp;spidx1-&gt;src)-&gt;sin6_port &lt; satosin6(&amp;spidx0-&gt;src_range.start)-&gt;sin6_port
                     || satosin6(&amp;spidx1-&gt;src)-&gt;sin6_port &gt; satosin6(&amp;spidx0-&gt;src_range.end)-&gt;sin6_port))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin6(&amp;spidx0-&gt;src)-&gt;sin6_port != IPSEC_PORT_ANY
						 &amp;&amp; satosin6(&amp;spidx0-&gt;src)-&gt;sin6_port !=
						 satosin6(&amp;spidx1-&gt;src)-&gt;sin6_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                <span class="enscript-keyword">break</span>;
        }
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (spidx0_src_is_range) {
        <span class="enscript-keyword">if</span> (!key_is_addr_in_range(&amp;spidx1-&gt;src, &amp;spidx0-&gt;src_range))
            <span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">switch</span> (spidx0-&gt;src.ss_family) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
                <span class="enscript-keyword">if</span> (satosin(&amp;spidx0-&gt;src)-&gt;sin_port != IPSEC_PORT_ANY
					&amp;&amp; satosin(&amp;spidx0-&gt;src)-&gt;sin_port !=
                    satosin(&amp;spidx1-&gt;src)-&gt;sin_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">if</span> (!key_bbcmp((caddr_t)&amp;satosin(&amp;spidx0-&gt;src)-&gt;sin_addr,
							   (caddr_t)&amp;satosin(&amp;spidx1-&gt;src)-&gt;sin_addr, spidx0-&gt;prefs))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
                <span class="enscript-keyword">if</span> (satosin6(&amp;spidx0-&gt;src)-&gt;sin6_port != IPSEC_PORT_ANY
					&amp;&amp; satosin6(&amp;spidx0-&gt;src)-&gt;sin6_port !=
                    satosin6(&amp;spidx1-&gt;src)-&gt;sin6_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-comment">/*
                 * scope_id check. if sin6_scope_id is 0, we regard it
                 * as a wildcard scope, which matches any scope zone ID.
                 */</span>
                <span class="enscript-keyword">if</span> (satosin6(&amp;spidx0-&gt;src)-&gt;sin6_scope_id &amp;&amp;
                    satosin6(&amp;spidx1-&gt;src)-&gt;sin6_scope_id &amp;&amp;
                    satosin6(&amp;spidx0-&gt;src)-&gt;sin6_scope_id !=
                    satosin6(&amp;spidx1-&gt;src)-&gt;sin6_scope_id)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">if</span> (!key_bbcmp((caddr_t)&amp;satosin6(&amp;spidx0-&gt;src)-&gt;sin6_addr,
							   (caddr_t)&amp;satosin6(&amp;spidx1-&gt;src)-&gt;sin6_addr, spidx0-&gt;prefs))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                <span class="enscript-comment">/* XXX */</span>
                <span class="enscript-keyword">if</span> (bcmp(&amp;spidx0-&gt;src, &amp;spidx1-&gt;src, spidx0-&gt;src.ss_len) != 0)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
        }
    }
	
    <span class="enscript-keyword">if</span> (spidx0_dst_is_range) {
        <span class="enscript-keyword">if</span> (!key_is_addr_in_range(&amp;spidx1-&gt;dst, &amp;spidx0-&gt;dst_range))
            <span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">switch</span> (spidx0-&gt;dst.ss_family) {
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
                <span class="enscript-keyword">if</span> (satosin(&amp;spidx0-&gt;dst)-&gt;sin_port != IPSEC_PORT_ANY
					&amp;&amp; satosin(&amp;spidx0-&gt;dst)-&gt;sin_port !=
                    satosin(&amp;spidx1-&gt;dst)-&gt;sin_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">if</span> (!key_bbcmp((caddr_t)&amp;satosin(&amp;spidx0-&gt;dst)-&gt;sin_addr,
							   (caddr_t)&amp;satosin(&amp;spidx1-&gt;dst)-&gt;sin_addr, spidx0-&gt;prefd))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
                <span class="enscript-keyword">if</span> (satosin6(&amp;spidx0-&gt;dst)-&gt;sin6_port != IPSEC_PORT_ANY
					&amp;&amp; satosin6(&amp;spidx0-&gt;dst)-&gt;sin6_port !=
                    satosin6(&amp;spidx1-&gt;dst)-&gt;sin6_port)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-comment">/*
                 * scope_id check. if sin6_scope_id is 0, we regard it
                 * as a wildcard scope, which matches any scope zone ID.
                 */</span>
                <span class="enscript-keyword">if</span> (satosin6(&amp;spidx0-&gt;src)-&gt;sin6_scope_id &amp;&amp;
                    satosin6(&amp;spidx1-&gt;src)-&gt;sin6_scope_id &amp;&amp;
                    satosin6(&amp;spidx0-&gt;dst)-&gt;sin6_scope_id !=
                    satosin6(&amp;spidx1-&gt;dst)-&gt;sin6_scope_id)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">if</span> (!key_bbcmp((caddr_t)&amp;satosin6(&amp;spidx0-&gt;dst)-&gt;sin6_addr,
							   (caddr_t)&amp;satosin6(&amp;spidx1-&gt;dst)-&gt;sin6_addr, spidx0-&gt;prefd))
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
            <span class="enscript-reference">default</span>:
                <span class="enscript-comment">/* XXX */</span>
                <span class="enscript-keyword">if</span> (bcmp(&amp;spidx0-&gt;dst, &amp;spidx1-&gt;dst, spidx0-&gt;dst.ss_len) != 0)
                    <span class="enscript-keyword">return</span> 0;
                <span class="enscript-keyword">break</span>;
        }
    }
	
	<span class="enscript-comment">/* XXX Do we check other field ?  e.g. flowinfo */</span>
	
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_is_addr_in_range</span>(<span class="enscript-type">struct</span> sockaddr_storage *addr, <span class="enscript-type">struct</span> secpolicyaddrrange *addr_range)
{
    <span class="enscript-type">int</span> cmp = 0;
    
    <span class="enscript-keyword">if</span> (addr == NULL || addr_range == NULL)
        <span class="enscript-keyword">return</span> 0;
    
    <span class="enscript-comment">/* Must be greater than or equal to start */</span>
    cmp = key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)addr, (<span class="enscript-type">struct</span> sockaddr *)&amp;addr_range-&gt;start, 1);
    <span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != 1)
        <span class="enscript-keyword">return</span> 0;
	
    <span class="enscript-comment">/* Must be less than or equal to end */</span>
    cmp = key_sockaddrcmp((<span class="enscript-type">struct</span> sockaddr *)addr, (<span class="enscript-type">struct</span> sockaddr *)&amp;addr_range-&gt;end, 1);
    <span class="enscript-keyword">if</span> (cmp != 0 &amp;&amp; cmp != -1)
        <span class="enscript-keyword">return</span> 0;
	
    <span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 Return values:
 -1: sa1 &lt; sa2
 0: sa1 == sa2
 1: sa1 &gt; sa2
 2: Not comparable or error
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_sockaddrcmp</span>(
				<span class="enscript-type">struct</span> sockaddr *sa1,
				<span class="enscript-type">struct</span> sockaddr *sa2,
				<span class="enscript-type">int</span> port)
{
    <span class="enscript-type">int</span> result = 0;
    <span class="enscript-type">int</span> port_result = 0;
    
	<span class="enscript-keyword">if</span> (sa1-&gt;sa_family != sa2-&gt;sa_family || sa1-&gt;sa_len != sa2-&gt;sa_len)
		<span class="enscript-keyword">return</span> 2;
    
    <span class="enscript-keyword">if</span> (sa1-&gt;sa_len == 0)
        <span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">switch</span> (sa1-&gt;sa_family) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
            <span class="enscript-keyword">if</span> (sa1-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in))
                <span class="enscript-keyword">return</span> 2;
            
            result = memcmp(&amp;satosin(sa1)-&gt;sin_addr.s_addr, &amp;satosin(sa2)-&gt;sin_addr.s_addr, <span class="enscript-keyword">sizeof</span>(satosin(sa1)-&gt;sin_addr.s_addr));
            
            <span class="enscript-keyword">if</span> (port) {
                <span class="enscript-keyword">if</span> (satosin(sa1)-&gt;sin_port &lt; satosin(sa2)-&gt;sin_port) {
                    port_result = -1;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin(sa1)-&gt;sin_port &gt; satosin(sa2)-&gt;sin_port) {
                    port_result = 1;
                }
                
                <span class="enscript-keyword">if</span> (result == 0)
                    result = port_result;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result &gt; 0 &amp;&amp; port_result &lt; 0) || (result &lt; 0 &amp;&amp; port_result &gt; 0))
                    <span class="enscript-keyword">return</span> 2;
            }
			
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
            <span class="enscript-keyword">if</span> (sa1-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
                <span class="enscript-keyword">return</span> 2;	<span class="enscript-comment">/*EINVAL*/</span>
            
            <span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_scope_id !=
                satosin6(sa2)-&gt;sin6_scope_id) {
                <span class="enscript-keyword">return</span> 2;
            }
            
            result = memcmp(&amp;satosin6(sa1)-&gt;sin6_addr.s6_addr[0], &amp;satosin6(sa2)-&gt;sin6_addr.s6_addr[0], <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
            
            <span class="enscript-keyword">if</span> (port) {
                <span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_port &lt; satosin6(sa2)-&gt;sin6_port) {
                    port_result = -1;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (satosin6(sa1)-&gt;sin6_port &gt; satosin6(sa2)-&gt;sin6_port) {
                    port_result = 1;
                }
                
                <span class="enscript-keyword">if</span> (result == 0)
                    result = port_result;
                <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((result &gt; 0 &amp;&amp; port_result &lt; 0) || (result &lt; 0 &amp;&amp; port_result &gt; 0))
                    <span class="enscript-keyword">return</span> 2;
            }
            
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            result = memcmp(sa1, sa2, sa1-&gt;sa_len);
            <span class="enscript-keyword">break</span>;
	}
	
    <span class="enscript-keyword">if</span> (result &lt; 0) result = -1;
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result &gt; 0) result = 1;
    
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*
 * compare two buffers with mask.
 * IN:
 *	addr1: source
 *	addr2: object
 *	bits:  Number of bits to compare
 * OUT:
 *	1 : equal
 *	0 : not equal
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_bbcmp</span>(
		  caddr_t p1,
		  caddr_t p2,
		  u_int bits)
{
	u_int8_t mask;
	
	<span class="enscript-comment">/* XXX: This could be considerably faster if we compare a word
	 * at a time, but it is complicated on LSB Endian machines */</span>
	
	<span class="enscript-comment">/* Handle null pointers */</span>
	<span class="enscript-keyword">if</span> (p1 == NULL || p2 == NULL)
		<span class="enscript-keyword">return</span> (p1 == p2);
	
	<span class="enscript-keyword">while</span> (bits &gt;= 8) {
		<span class="enscript-keyword">if</span> (*p1++ != *p2++)
			<span class="enscript-keyword">return</span> 0;
		bits -= 8;
	}
	
	<span class="enscript-keyword">if</span> (bits &gt; 0) {
		mask = ~((1&lt;&lt;(8-bits))-1);
		<span class="enscript-keyword">if</span> ((*p1 &amp; mask) != (*p2 &amp; mask))
			<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">return</span> 1;	<span class="enscript-comment">/* Match! */</span>
}

<span class="enscript-comment">/*
 * time handler.
 * scanning SPD and SAD to check status for each entries,
 * and do to remove or to expire.
 * XXX: year 2038 problem may remain.
 */</span>
<span class="enscript-type">int</span> key_timehandler_debug = 0;
u_int32_t spd_count = 0, sah_count = 0, dead_sah_count = 0, empty_sah_count = 0, larval_sav_count = 0, mature_sav_count = 0, dying_sav_count = 0, dead_sav_count = 0;
u_int64_t total_sav_count = 0;
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_timehandler</span>(<span class="enscript-type">void</span>)
{
	u_int dir;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">struct</span> secpolicy **spbuf = NULL, **spptr = NULL;
	<span class="enscript-type">struct</span> secasvar **savexbuf = NULL, **savexptr = NULL;
	<span class="enscript-type">struct</span> secasvar **savkabuf = NULL, **savkaptr = NULL;
	<span class="enscript-type">int</span> spbufcount = 0, savbufcount = 0, spcount = 0, savexcount = 0, savkacount = 0, cnt;
	<span class="enscript-type">int</span> stop_handler = 1;  <span class="enscript-comment">/* stop the timehandler */</span>

	microtime(&amp;tv);
	
	<span class="enscript-comment">/* pre-allocate buffers before taking the lock */</span>
	<span class="enscript-comment">/* if allocation failures occur - portions of the processing will be skipped */</span>
	<span class="enscript-keyword">if</span> ((spbufcount = ipsec_policy_count) != 0) {
		spbufcount += 256;
		KMALLOC_WAIT(spbuf, <span class="enscript-type">struct</span> secpolicy **, spbufcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secpolicy *));
		<span class="enscript-keyword">if</span> (spbuf)
			spptr = spbuf;
	}
	<span class="enscript-keyword">if</span> ((savbufcount = ipsec_sav_count) != 0) {
		savbufcount += 512;
		KMALLOC_WAIT(savexbuf, <span class="enscript-type">struct</span> secasvar **, savbufcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar *));
		<span class="enscript-keyword">if</span> (savexbuf)
			savexptr = savexbuf;
		KMALLOC_WAIT(savkabuf, <span class="enscript-type">struct</span> secasvar **, savbufcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secasvar *));
		<span class="enscript-keyword">if</span> (savkabuf)
			savkaptr = savkabuf;
	}
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* SPD */</span>
	<span class="enscript-keyword">if</span> (spbuf) {
		
		<span class="enscript-type">struct</span> secpolicy *sp, *nextsp;
		
		<span class="enscript-keyword">for</span> (dir = 0; dir &lt; IPSEC_DIR_MAX; dir++) {
			<span class="enscript-keyword">for</span> (sp = LIST_FIRST(&amp;sptree[dir]);
			     sp != NULL;
			     sp = nextsp) {
				
				<span class="enscript-comment">/* don't prevent timehandler from stopping for generate policy */</span>
				<span class="enscript-keyword">if</span> (sp-&gt;policy != IPSEC_POLICY_GENERATE)
					stop_handler = 0;
				spd_count++;
				nextsp = LIST_NEXT(sp, chain);
				
				<span class="enscript-keyword">if</span> (sp-&gt;state == IPSEC_SPSTATE_DEAD) {
					key_freesp(sp, KEY_SADB_LOCKED);
					<span class="enscript-keyword">continue</span>;
				}
				
				<span class="enscript-keyword">if</span> (sp-&gt;lifetime == 0 &amp;&amp; sp-&gt;validtime == 0)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (spbuf &amp;&amp; spcount &lt; spbufcount) {
					<span class="enscript-comment">/* the deletion will occur next time */</span>
					<span class="enscript-keyword">if</span> ((sp-&gt;lifetime
					     &amp;&amp; tv.tv_sec - sp-&gt;created &gt; sp-&gt;lifetime)
					    || (sp-&gt;validtime
							&amp;&amp; tv.tv_sec - sp-&gt;lastused &gt; sp-&gt;validtime)) {
							<span class="enscript-comment">//key_spdexpire(sp);
</span>							sp-&gt;state = IPSEC_SPSTATE_DEAD;
							sp-&gt;refcnt++;
							*spptr++ = sp;
							spcount++;
						}
				}
			}
		}
	}
	
	<span class="enscript-comment">/* SAD */</span>
	{
		<span class="enscript-type">struct</span> secashead *sah, *nextsah;
		<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
		
		<span class="enscript-keyword">for</span> (sah = LIST_FIRST(&amp;sahtree);
			 sah != NULL;
			 sah = nextsah) {
			
			sah_count++;
			nextsah = LIST_NEXT(sah, chain);
			
			<span class="enscript-comment">/* if sah has been dead, then delete it and process next sah. */</span>
			<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD) {
				key_delsah(sah);
				dead_sah_count++;
				<span class="enscript-keyword">continue</span>;
			}
			
			<span class="enscript-keyword">if</span> (LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_LARVAL]) == NULL &amp;&amp;
			    LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_MATURE]) == NULL &amp;&amp;
			    LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_DYING]) == NULL &amp;&amp;
			    LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_DEAD]) == NULL) {
				key_delsah(sah);
				empty_sah_count++;
				<span class="enscript-keyword">continue</span>;
			}
			
			<span class="enscript-keyword">if</span> (savbufcount == 0) {
				<span class="enscript-keyword">continue</span>;
			}
			
			stop_handler = 0;
			
			<span class="enscript-comment">/* if LARVAL entry doesn't become MATURE, delete it. */</span>
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_LARVAL]);
				 sav != NULL;
				 sav = nextsav) {
				
				larval_sav_count++;
				total_sav_count++;
				nextsav = LIST_NEXT(sav, chain);
				
				<span class="enscript-keyword">if</span> (sav-&gt;lft_h != NULL) {
					<span class="enscript-comment">/* If a hard lifetime is defined for the LARVAL SA, use it */</span>
					<span class="enscript-keyword">if</span> (sav-&gt;lft_h-&gt;sadb_lifetime_addtime != 0
						&amp;&amp; tv.tv_sec - sav-&gt;created &gt; sav-&gt;lft_h-&gt;sadb_lifetime_addtime) {
						<span class="enscript-keyword">if</span> (sav-&gt;always_expire) {
							key_send_delete(sav);
							sav = NULL;
						} <span class="enscript-keyword">else</span> {
							key_sa_chgstate(sav, SADB_SASTATE_DEAD);
							key_freesav(sav, KEY_SADB_LOCKED);
							sav = NULL;
						}
					}
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (tv.tv_sec - sav-&gt;created &gt; key_larval_lifetime) {
						key_freesav(sav, KEY_SADB_LOCKED);
					}
				}
			}
			
			<span class="enscript-comment">/*
			 * If this is a NAT traversal SA with no activity,
			 * we need to send a keep alive.
			 *
			 * Performed outside of the loop before so we will
			 * only ever send one keepalive. The first SA on
			 * the list is the one that will be used for sending
			 * traffic, so this is the one we use for determining
			 * when to send the keepalive.
			 */</span>
			<span class="enscript-keyword">if</span> (savkabuf &amp;&amp; savkacount &lt; savbufcount) {
				sav = LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_MATURE]);	<span class="enscript-comment">//%%% should we check dying list if this is empty???
</span>				<span class="enscript-keyword">if</span> (sav &amp;&amp; (natt_keepalive_interval || sav-&gt;natt_interval) &amp;&amp;
					(sav-&gt;flags &amp; (SADB_X_EXT_NATT_KEEPALIVE | SADB_X_EXT_ESP_KEEPALIVE)) != 0) {
					sav-&gt;refcnt++;
					*savkaptr++ = sav;
					savkacount++;
				}
			}
			
			<span class="enscript-comment">/*
			 * check MATURE entry to start to send expire message
			 * whether or not.
			 */</span>
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_MATURE]);
				 sav != NULL;
				 sav = nextsav) {
				
				mature_sav_count++;
				total_sav_count++;
				nextsav = LIST_NEXT(sav, chain);
				
				<span class="enscript-comment">/* we don't need to check. */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;lft_s == NULL)
					<span class="enscript-keyword">continue</span>;
				
				<span class="enscript-comment">/* sanity check */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
					ipseclog((LOG_DEBUG,<span class="enscript-string">&quot;key_timehandler: &quot;</span>
							  <span class="enscript-string">&quot;There is no CURRENT time, why?\n&quot;</span>));
					<span class="enscript-keyword">continue</span>;
				}
				
				<span class="enscript-comment">/* check SOFT lifetime */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;lft_s-&gt;sadb_lifetime_addtime != 0
					&amp;&amp; tv.tv_sec - sav-&gt;created &gt; sav-&gt;lft_s-&gt;sadb_lifetime_addtime) {
					<span class="enscript-comment">/*
					 * If always_expire is set, expire. Otherwise,
					 * if the SA has not been used, delete immediately.
					 */</span>
					<span class="enscript-keyword">if</span> (sav-&gt;lft_c-&gt;sadb_lifetime_usetime == 0
						&amp;&amp; sav-&gt;always_expire == 0) {
						key_sa_chgstate(sav, SADB_SASTATE_DEAD);
						key_freesav(sav, KEY_SADB_LOCKED);
						sav = NULL;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (savexbuf &amp;&amp; savexcount &lt; savbufcount) {
						key_sa_chgstate(sav, SADB_SASTATE_DYING);
						sav-&gt;refcnt++;
						*savexptr++ = sav;
						savexcount++;
					}
				}
				
				<span class="enscript-comment">/* check SOFT lifetime by bytes */</span>
				<span class="enscript-comment">/*
				 * XXX I don't know the way to delete this SA
				 * when new SA is installed.  Caution when it's
				 * installed too big lifetime by time.
				 */</span>
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (savexbuf &amp;&amp; savexcount &lt; savbufcount
						 &amp;&amp; sav-&gt;lft_s-&gt;sadb_lifetime_bytes != 0
						 &amp;&amp; sav-&gt;lft_s-&gt;sadb_lifetime_bytes &lt; sav-&gt;lft_c-&gt;sadb_lifetime_bytes) {
					
					<span class="enscript-comment">/*
					 * XXX If we keep to send expire
					 * message in the status of
					 * DYING. Do remove below code.
					 */</span>
					<span class="enscript-comment">//key_expire(sav);
</span>					key_sa_chgstate(sav, SADB_SASTATE_DYING);
					sav-&gt;refcnt++;
					*savexptr++ = sav;
					savexcount++;
				}
			}
			
			<span class="enscript-comment">/* check DYING entry to change status to DEAD. */</span>
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_DYING]);
				 sav != NULL;
				 sav = nextsav) {
				
				dying_sav_count++;
				total_sav_count++;
				nextsav = LIST_NEXT(sav, chain);
				
				<span class="enscript-comment">/* we don't need to check. */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;lft_h == NULL)
					<span class="enscript-keyword">continue</span>;
				
				<span class="enscript-comment">/* sanity check */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;lft_c == NULL) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_timehandler: &quot;</span>
							  <span class="enscript-string">&quot;There is no CURRENT time, why?\n&quot;</span>));
					<span class="enscript-keyword">continue</span>;
				}
				
				<span class="enscript-keyword">if</span> (sav-&gt;lft_h-&gt;sadb_lifetime_addtime != 0
					&amp;&amp; tv.tv_sec - sav-&gt;created &gt; sav-&gt;lft_h-&gt;sadb_lifetime_addtime) {
					<span class="enscript-keyword">if</span> (sav-&gt;always_expire) {
						key_send_delete(sav);
						sav = NULL;
					} <span class="enscript-keyword">else</span> {
						key_sa_chgstate(sav, SADB_SASTATE_DEAD);
						key_freesav(sav, KEY_SADB_LOCKED);
						sav = NULL;
					}
				}
#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* XXX Should we keep to send expire message until HARD lifetime ? */</span>
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (savbuf &amp;&amp; savexcount &lt; savbufcount
						 &amp;&amp; sav-&gt;lft_s != NULL
						 &amp;&amp; sav-&gt;lft_s-&gt;sadb_lifetime_addtime != 0
						 &amp;&amp; tv.tv_sec - sav-&gt;created &gt; sav-&gt;lft_s-&gt;sadb_lifetime_addtime) {
					<span class="enscript-comment">/*
					 * XXX: should be checked to be
					 * installed the valid SA.
					 */</span>
					
					<span class="enscript-comment">/*
					 * If there is no SA then sending
					 * expire message.
					 */</span>
					<span class="enscript-comment">//key_expire(sav);
</span>					sav-&gt;refcnt++;
					*savexptr++ = sav;
					savexcount++;
				}
#<span class="enscript-reference">endif</span>
				<span class="enscript-comment">/* check HARD lifetime by bytes */</span>
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sav-&gt;lft_h-&gt;sadb_lifetime_bytes != 0
						 &amp;&amp; sav-&gt;lft_h-&gt;sadb_lifetime_bytes &lt; sav-&gt;lft_c-&gt;sadb_lifetime_bytes) {
					key_sa_chgstate(sav, SADB_SASTATE_DEAD);
					key_freesav(sav, KEY_SADB_LOCKED);
					sav = NULL;
				}
			}
			
			<span class="enscript-comment">/* delete entry in DEAD */</span>
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[SADB_SASTATE_DEAD]);
				 sav != NULL;
				 sav = nextsav) {
				
				dead_sav_count++;
				total_sav_count++;
				nextsav = LIST_NEXT(sav, chain);
				
				<span class="enscript-comment">/* sanity check */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_DEAD) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_timehandler: &quot;</span>
							  <span class="enscript-string">&quot;invalid sav-&gt;state &quot;</span>
							  <span class="enscript-string">&quot;(queue: %d SA: %d): &quot;</span>
							  <span class="enscript-string">&quot;kill it anyway\n&quot;</span>,
							  SADB_SASTATE_DEAD, sav-&gt;state));
				}
				
				<span class="enscript-comment">/*
				 * do not call key_freesav() here.
				 * sav should already be freed, and sav-&gt;refcnt
				 * shows other references to sav
				 * (such as from SPD).
				 */</span>
			}
		}
	}
	
	<span class="enscript-keyword">if</span> (++key_timehandler_debug &gt;= 300) {
		<span class="enscript-keyword">if</span> (key_debug_level) {
			printf(<span class="enscript-string">&quot;%s: total stats for %u calls\n&quot;</span>, __FUNCTION__, key_timehandler_debug);
			printf(<span class="enscript-string">&quot;%s: walked %u SPDs\n&quot;</span>, __FUNCTION__, spd_count);
			printf(<span class="enscript-string">&quot;%s: walked %llu SAs: LARVAL SAs %u, MATURE SAs %u, DYING SAs %u, DEAD SAs %u\n&quot;</span>, __FUNCTION__,
				   total_sav_count, larval_sav_count, mature_sav_count, dying_sav_count, dead_sav_count);
			printf(<span class="enscript-string">&quot;%s: walked %u SAHs: DEAD SAHs %u, EMPTY SAHs %u\n&quot;</span>, __FUNCTION__,
				   sah_count, dead_sah_count, empty_sah_count);
			<span class="enscript-keyword">if</span> (sah_search_calls) {
				printf(<span class="enscript-string">&quot;%s: SAH search cost %d iters per call\n&quot;</span>, __FUNCTION__,
					   (sah_search_count/sah_search_calls));
			}
		}
		spd_count = 0;
		sah_count = 0;
		dead_sah_count = 0;
		empty_sah_count = 0;
		larval_sav_count = 0;
		mature_sav_count = 0;
		dying_sav_count = 0;
		dead_sav_count = 0;
		total_sav_count = 0;
		sah_search_count = 0;
		sah_search_calls = 0;
		key_timehandler_debug = 0;
	}
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
	<span class="enscript-comment">/* ACQ tree */</span>
    {
		<span class="enscript-type">struct</span> secacq *acq, *nextacq;
		
		<span class="enscript-keyword">for</span> (acq = LIST_FIRST(&amp;acqtree);
			 acq != NULL;
			 acq = nextacq) {
			
			stop_handler = 0;
			nextacq = LIST_NEXT(acq, chain);
			
			<span class="enscript-keyword">if</span> (tv.tv_sec - acq-&gt;created &gt; key_blockacq_lifetime
				&amp;&amp; __LIST_CHAINED(acq)) {
				LIST_REMOVE(acq, chain);
				KFREE(acq);
			}
		}
    }
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* SP ACQ tree */</span>
    {
		<span class="enscript-type">struct</span> secspacq *acq, *nextacq;
		
		<span class="enscript-keyword">for</span> (acq = LIST_FIRST(&amp;spacqtree);
			 acq != NULL;
			 acq = nextacq) {
			
			stop_handler = 0;
			nextacq = LIST_NEXT(acq, chain);
			
			<span class="enscript-keyword">if</span> (tv.tv_sec - acq-&gt;created &gt; key_blockacq_lifetime
				&amp;&amp; __LIST_CHAINED(acq)) {
				LIST_REMOVE(acq, chain);
				KFREE(acq);
			}
		}
    }
	
	<span class="enscript-comment">/* initialize random seed */</span>
	<span class="enscript-keyword">if</span> (key_tick_init_random++ &gt; key_int_random) {
		key_tick_init_random = 0;
		key_srandom();
	}
	
	natt_now++;
	
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-comment">/* send messages outside of sadb_mutex */</span>
	<span class="enscript-keyword">if</span> (spbuf &amp;&amp; spcount &gt; 0) {
		cnt = spcount;
		<span class="enscript-keyword">while</span> (cnt--)
			key_spdexpire(*(--spptr));
	}
	<span class="enscript-keyword">if</span> (savkabuf &amp;&amp; savkacount &gt; 0) {
		<span class="enscript-type">struct</span> secasvar **savkaptr_sav = savkaptr;
		<span class="enscript-type">int</span>               cnt_send = savkacount;
		
		<span class="enscript-keyword">while</span> (cnt_send--) {
			<span class="enscript-keyword">if</span> (ipsec_send_natt_keepalive(*(--savkaptr))) {
				<span class="enscript-comment">// &lt;rdar://6768487&gt; iterate (all over again) and update timestamps
</span>				<span class="enscript-type">struct</span> secasvar **savkaptr_update = savkaptr_sav;
				<span class="enscript-type">int</span>               cnt_update = savkacount;
				<span class="enscript-keyword">while</span> (cnt_update--) {
					key_update_natt_keepalive_timestamp(*savkaptr,
														*(--savkaptr_update));
				}
			}
		}
	}
	<span class="enscript-keyword">if</span> (savexbuf &amp;&amp; savexcount &gt; 0) {
		cnt = savexcount;
		<span class="enscript-keyword">while</span> (cnt--)
			key_expire(*(--savexptr));
	}
	
	<span class="enscript-comment">/* decrement ref counts and free buffers */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (spbuf) {
		<span class="enscript-keyword">while</span> (spcount--)
			key_freesp(*spptr++, KEY_SADB_LOCKED);
		KFREE(spbuf);
	}
	<span class="enscript-keyword">if</span> (savkabuf) {
		<span class="enscript-keyword">while</span> (savkacount--)
			key_freesav(*savkaptr++, KEY_SADB_LOCKED);
		KFREE(savkabuf);
	}
	<span class="enscript-keyword">if</span> (savexbuf) {
		<span class="enscript-keyword">while</span> (savexcount--)
			key_freesav(*savexptr++, KEY_SADB_LOCKED);
		KFREE(savexbuf);
	}
	
	<span class="enscript-keyword">if</span> (stop_handler) {
		key_timehandler_running = 0;
		<span class="enscript-comment">/* Turn on the ipsec bypass */</span>
		ipsec_bypass = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* do exchange to tick time !! */</span>
		(<span class="enscript-type">void</span>)timeout((<span class="enscript-type">void</span> *)key_timehandler, (<span class="enscript-type">void</span> *)0, hz);
	}

	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * to initialize a seed for random()
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_srandom</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
	<span class="enscript-comment">/* Our PRNG is based on Yarrow and doesn't need to be seeded */</span>
	random();
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span> timeval tv;
	
	microtime(&amp;tv);
	
	srandom(tv.tv_usec);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">return</span>;
}

u_int32_t
<span class="enscript-function-name">key_random</span>(<span class="enscript-type">void</span>)
{
	u_int32_t value;
	
	key_randomfill(&amp;value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">return</span> value;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">key_randomfill</span>(
			   <span class="enscript-type">void</span> *p,
			   size_t l)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
	
	read_random(p, (u_int)l);
#<span class="enscript-reference">else</span>
	size_t n;
	u_int32_t v;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> warn = 1;
	
	n = 0;
	n = (size_t)read_random(p, (u_int)l);
	<span class="enscript-comment">/* last resort */</span>
	<span class="enscript-keyword">while</span> (n &lt; l) {
		v = random();
		bcopy(&amp;v, (u_int8_t *)p + n,
			  l - n &lt; <span class="enscript-keyword">sizeof</span>(v) ? l - n : <span class="enscript-keyword">sizeof</span>(v));
		n += <span class="enscript-keyword">sizeof</span>(v);
		
		<span class="enscript-keyword">if</span> (warn) {
			printf(<span class="enscript-string">&quot;WARNING: pseudo-random number generator &quot;</span>
				   <span class="enscript-string">&quot;used for IPsec processing\n&quot;</span>);
			warn = 0;
		}
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * map SADB_SATYPE_* to IPPROTO_*.
 * if satype == SADB_SATYPE then satype is mapped to ~0.
 * OUT:
 *	0: invalid satype.
 */</span>
<span class="enscript-type">static</span> u_int16_t
<span class="enscript-function-name">key_satype2proto</span>(
				 u_int8_t satype)
{
	<span class="enscript-keyword">switch</span> (satype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_UNSPEC</span>:
			<span class="enscript-keyword">return</span> IPSEC_PROTO_ANY;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_AH</span>:
			<span class="enscript-keyword">return</span> IPPROTO_AH;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_ESP</span>:
			<span class="enscript-keyword">return</span> IPPROTO_ESP;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SATYPE_IPCOMP</span>:
			<span class="enscript-keyword">return</span> IPPROTO_IPCOMP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * map IPPROTO_* to SADB_SATYPE_*
 * OUT:
 *	0: invalid protocol type.
 */</span>
<span class="enscript-type">static</span> u_int8_t
<span class="enscript-function-name">key_proto2satype</span>(
				 u_int16_t proto)
{
	<span class="enscript-keyword">switch</span> (proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			<span class="enscript-keyword">return</span> SADB_SATYPE_AH;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			<span class="enscript-keyword">return</span> SADB_SATYPE_ESP;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			<span class="enscript-keyword">return</span> SADB_X_SATYPE_IPCOMP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">static</span> ifnet_t
<span class="enscript-function-name">key_get_ipsec_if_from_message</span> (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp, <span class="enscript-type">int</span> message_type)
{
	<span class="enscript-type">struct</span> sadb_x_ipsecif *ipsecifopts = NULL;
	ifnet_t ipsec_if = NULL;
	
	ipsecifopts = (<span class="enscript-type">struct</span> sadb_x_ipsecif *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[message_type];
	<span class="enscript-keyword">if</span> (ipsecifopts != NULL) {
		<span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_ipsec_if[0]) {
			ifnet_find_by_name(ipsecifopts-&gt;sadb_x_ipsecif_ipsec_if, &amp;ipsec_if);
		}
	}
	
	<span class="enscript-keyword">return</span> ipsec_if;
}

<span class="enscript-type">static</span> u_int
<span class="enscript-function-name">key_get_outgoing_ifindex_from_message</span> (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp, <span class="enscript-type">int</span> message_type)
{
	<span class="enscript-type">struct</span> sadb_x_ipsecif *ipsecifopts = NULL;
	ifnet_t outgoing_if = NULL;
	
	ipsecifopts = (<span class="enscript-type">struct</span> sadb_x_ipsecif *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[message_type];
	<span class="enscript-keyword">if</span> (ipsecifopts != NULL) {
		<span class="enscript-keyword">if</span> (ipsecifopts-&gt;sadb_x_ipsecif_outgoing_if[0]) {
			ifnet_find_by_name(ipsecifopts-&gt;sadb_x_ipsecif_outgoing_if, &amp;outgoing_if);
        }
    }
	
	<span class="enscript-keyword">return</span> outgoing_if ? outgoing_if-&gt;if_index : 0;
}

<span class="enscript-comment">/* %%% PF_KEY */</span>
<span class="enscript-comment">/*
 * SADB_GETSPI processing is to receive
 *	&lt;base, (SA2), src address, dst address, (SPI range)&gt;
 * from the IKMPd, to assign a unique spi value, to hang on the INBOUND
 * tree with the status of LARVAL, and send
 *	&lt;base, SA(*), address(SD)&gt;
 * to the IKMPd.
 *
 * IN:	mhp: pointer to the pointer to each header.
 * OUT:	NULL if fail.
 *	other if success, return pointer to the message to send.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_getspi</span>(
		   <span class="enscript-type">struct</span> socket *so,
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *newsah;
	<span class="enscript-type">struct</span> secasvar *newsav;
	ifnet_t ipsec_if = NULL;
	u_int8_t proto;
	u_int32_t spi;
	u_int8_t mode;
	u_int32_t reqid;
	<span class="enscript-type">int</span> error;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_getspi: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_getspi: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_getspi: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_SA2] != NULL) {
		mode = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_mode;
		reqid = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				 (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_reqid;
	} <span class="enscript-keyword">else</span> {
		mode = IPSEC_MODE_ANY;
		reqid = 0;
	}
	
	src0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_SRC]);
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_DST]);
	
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_getspi: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-comment">/* make sure if port number is zero. */</span>
	<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)(src0 + 1))-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(src0 + 1))-&gt;sa_len !=
				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in))
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)(src0 + 1))-&gt;sin_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(src0 + 1))-&gt;sa_len !=
				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			((<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)(src0 + 1))-&gt;sin6_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			; <span class="enscript-comment">/*???*/</span>
	}
	<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)(dst0 + 1))-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(dst0 + 1))-&gt;sa_len !=
				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in))
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)(dst0 + 1))-&gt;sin_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)(dst0 + 1))-&gt;sa_len !=
				<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
			((<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)(dst0 + 1))-&gt;sin6_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			; <span class="enscript-comment">/*???*/</span>
	}
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, mode, reqid, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* SPI allocation */</span>
	spi = key_do_getnewspi((<span class="enscript-type">struct</span> sadb_spirange *)
						   (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SPIRANGE], &amp;saidx);
	<span class="enscript-keyword">if</span> (spi == 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-comment">/* get a SA index */</span>
	<span class="enscript-keyword">if</span> ((newsah = key_getsah(&amp;saidx)) == NULL) {
		<span class="enscript-comment">/* create a new SA index: key_addspi is always used for inbound spi */</span>
		<span class="enscript-keyword">if</span> ((newsah = key_newsah(&amp;saidx, ipsec_if, key_get_outgoing_ifindex_from_message(mhp, SADB_X_EXT_IPSECIF), IPSEC_DIR_INBOUND)) == NULL) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_getspi: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
	}
	
	<span class="enscript-comment">/* get a new SA */</span>
	<span class="enscript-comment">/* XXX rewrite */</span>
	newsav = key_newsav(m, mhp, newsah, &amp;error, so);
	<span class="enscript-keyword">if</span> (newsav == NULL) {
		<span class="enscript-comment">/* XXX don't free new SA index allocated in above. */</span>
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-comment">/* set spi */</span>
	key_setspi(newsav, htonl(spi));
	
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
	<span class="enscript-comment">/* delete the entry in acqtree */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_seq != 0) {
		<span class="enscript-type">struct</span> secacq *acq;
		<span class="enscript-keyword">if</span> ((acq = key_getacqbyseq(mhp-&gt;msg-&gt;sadb_msg_seq)) != NULL) {
			<span class="enscript-comment">/* reset counter in order to deletion by timehandler. */</span>
			<span class="enscript-type">struct</span> timeval tv;
			microtime(&amp;tv);
			acq-&gt;created = tv.tv_sec;
			acq-&gt;count = 0;
		}
	}
#<span class="enscript-reference">endif</span>
	
	lck_mtx_unlock(sadb_mutex);
	
    {
		<span class="enscript-type">struct</span> mbuf *n, *nn;
		<span class="enscript-type">struct</span> sadb_sa *m_sa;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> off, len;
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) +
	    PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa));
		<span class="enscript-keyword">if</span> (len &gt; MCLBYTES)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		MGETHDR(n, M_WAITOK, MT_DATA);
		<span class="enscript-keyword">if</span> (n &amp;&amp; len &gt; MHLEN) {
			MCLGET(n, M_WAITOK);
			<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
				m_freem(n);
				n = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		n-&gt;m_len = len;
		n-&gt;m_next = NULL;
		off = 0;
		
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg), mtod(n, caddr_t) + off);
		off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		
		m_sa = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + off);
		m_sa-&gt;sadb_sa_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa));
		m_sa-&gt;sadb_sa_exttype = SADB_EXT_SA;
		m_sa-&gt;sadb_sa_spi = htonl(spi);
		off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa));
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (off != len)
			panic(<span class="enscript-string">&quot;length inconsistency in key_getspi&quot;</span>);
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_ADDRESS_SRC, SADB_EXT_ADDRESS_DST};
			n-&gt;m_next = key_gather_mbuf(m, mhp, 0, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
			<span class="enscript-keyword">if</span> (!n-&gt;m_next) {
				m_freem(n);
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
			}
		}
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ONE);
		}
		
		n-&gt;m_pkthdr.len = 0;
		<span class="enscript-keyword">for</span> (nn = n; nn; nn = nn-&gt;m_next)
			n-&gt;m_pkthdr.len += nn-&gt;m_len;
		
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_seq = newsav-&gt;seq;
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ONE);
    }
}

u_int32_t
<span class="enscript-function-name">key_getspi2</span>(<span class="enscript-type">struct</span> sockaddr      *src,
			<span class="enscript-type">struct</span> sockaddr      *dst,
			u_int8_t              proto,
			u_int8_t              mode,
			u_int32_t             reqid,
			<span class="enscript-type">struct</span> sadb_spirange *spirange)
{
	u_int32_t         spi;
	<span class="enscript-type">struct</span> secasindex saidx;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, mode, reqid, src, dst, 0, &amp;saidx);
	
	<span class="enscript-comment">/* make sure if port number is zero. */</span>
	<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.src)-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.src)-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in))
				<span class="enscript-keyword">return</span> 0;
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx.src)-&gt;sin_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.src)-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
				<span class="enscript-keyword">return</span> 0;
			((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.src)-&gt;sin6_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			; <span class="enscript-comment">/*???*/</span>
	}
	<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.dst)-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.dst)-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in))
				<span class="enscript-keyword">return</span> 0;
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx.dst)-&gt;sin_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx.dst)-&gt;sa_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6))
				<span class="enscript-keyword">return</span> 0;
			((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.dst)-&gt;sin6_port = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			; <span class="enscript-comment">/*???*/</span>
	}
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* SPI allocation */</span>
	spi = key_do_getnewspi(spirange, &amp;saidx);
	
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">return</span> spi;
}

<span class="enscript-comment">/*
 * allocating new SPI
 * called by key_getspi() and key_getspi2().
 * OUT:
 *	0:	failure.
 *	others: success.
 */</span>
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">key_do_getnewspi</span>(
				 <span class="enscript-type">struct</span> sadb_spirange *spirange,
				 <span class="enscript-type">struct</span> secasindex *saidx)
{
	u_int32_t newspi;
	u_int32_t keymin, keymax;
	<span class="enscript-type">int</span> count = key_spi_trycnt;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* set spi range to allocate */</span>
	<span class="enscript-keyword">if</span> (spirange != NULL) {
		keymin = spirange-&gt;sadb_spirange_min;
		keymax = spirange-&gt;sadb_spirange_max;
	} <span class="enscript-keyword">else</span> {
		keymin = key_spi_minval;
		keymax = key_spi_maxval;
	}
	<span class="enscript-comment">/* IPCOMP needs 2-byte SPI */</span>
	<span class="enscript-keyword">if</span> (saidx-&gt;proto == IPPROTO_IPCOMP) {
		u_int32_t t;
		<span class="enscript-keyword">if</span> (keymin &gt;= 0x10000)
			keymin = 0xffff;
		<span class="enscript-keyword">if</span> (keymax &gt;= 0x10000)
			keymax = 0xffff;
		<span class="enscript-keyword">if</span> (keymin &gt; keymax) {
			t = keymin; keymin = keymax; keymax = t;
		}
	}
	
	<span class="enscript-keyword">if</span> (keymin == keymax) {
		<span class="enscript-keyword">if</span> (key_checkspidup(saidx, keymin) != NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_do_getnewspi: SPI %u exists already.\n&quot;</span>, keymin));
			<span class="enscript-keyword">return</span> 0;
		}
		
		count--; <span class="enscript-comment">/* taking one cost. */</span>
		newspi = keymin;
		
	} <span class="enscript-keyword">else</span> {
		
		u_int32_t range = keymax - keymin + 1;  <span class="enscript-comment">/* overflow value of zero means full range */</span>
		
		<span class="enscript-comment">/* init SPI */</span>
		newspi = 0;
		
		<span class="enscript-comment">/* when requesting to allocate spi ranged */</span>
		<span class="enscript-keyword">while</span> (count--) {
			u_int32_t rand_val = key_random();
			
			<span class="enscript-comment">/* generate pseudo-random SPI value ranged. */</span>
			newspi = (range == 0 ? rand_val : keymin + (rand_val % range));
			
			<span class="enscript-keyword">if</span> (key_checkspidup(saidx, newspi) == NULL)
				<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> (count == 0 || newspi == 0) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_do_getnewspi: to allocate spi is failed.\n&quot;</span>));
			<span class="enscript-keyword">return</span> 0;
		}
	}
	
	<span class="enscript-comment">/* statistics */</span>
	keystat.getspi_count =
	(keystat.getspi_count + key_spi_trycnt - count) / 2;
	
	<span class="enscript-keyword">return</span> newspi;
}

<span class="enscript-comment">/*
 * SADB_UPDATE processing
 * receive
 *   &lt;base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)
 *       key(AE), (identity(SD),) (sensitivity)&gt;
 * from the ikmpd, and update a secasvar entry whose status is SADB_SASTATE_LARVAL.
 * and send
 *   &lt;base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)
 *       (identity(SD),) (sensitivity)&gt;
 * to the ikmpd.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_update</span>(
		   <span class="enscript-type">struct</span> socket *so,
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_sa *sa0;
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int16_t proto;
	u_int8_t mode;
	u_int32_t reqid;
	u_int16_t flags2;
	<span class="enscript-type">int</span> error;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_update: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL ||
	    (mhp-&gt;msg-&gt;sadb_msg_satype == SADB_SATYPE_ESP &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_KEY_ENCRYPT] == NULL) ||
	    (mhp-&gt;msg-&gt;sadb_msg_satype == SADB_SATYPE_AH &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_KEY_AUTH] == NULL) ||
	    (mhp-&gt;ext[SADB_EXT_LIFETIME_HARD] != NULL &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_LIFETIME_SOFT] == NULL) ||
	    (mhp-&gt;ext[SADB_EXT_LIFETIME_HARD] == NULL &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_LIFETIME_SOFT] != NULL)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: invalid message is passed.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_SA2] != NULL) {
		mode = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_mode;
		reqid = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				 (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_reqid;
		flags2 = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_flags;
	} <span class="enscript-keyword">else</span> {
		mode = IPSEC_MODE_ANY;
		reqid = 0;
		flags2 = 0;
	}
	<span class="enscript-comment">/* XXX boundary checking for other extensions */</span>
	
	sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
	src0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_SRC]);
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_DST]);
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, mode, reqid, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* get a SA header */</span>
	<span class="enscript-keyword">if</span> ((sah = key_getsah(&amp;saidx)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: no SA index found.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	
	<span class="enscript-comment">/* set spidx if there */</span>
	<span class="enscript-comment">/* XXX rewrite */</span>
	error = key_setident(sah, m, mhp);
	<span class="enscript-keyword">if</span> (error) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-comment">/* find a SA with sequence number. */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_seq != 0
		&amp;&amp; (sav = key_getsavbyseq(sah, mhp-&gt;msg-&gt;sadb_msg_seq)) == NULL) {
	 	lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_update: no larval SA with sequence %u exists.\n&quot;</span>,
				  mhp-&gt;msg-&gt;sadb_msg_seq));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> ((sav = key_getsavbyspi(sah, sa0-&gt;sadb_sa_spi)) == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_update: no such a SA found (spi:%u)\n&quot;</span>,
				  (u_int32_t)ntohl(sa0-&gt;sadb_sa_spi)));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;saidx.proto != proto) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_update: protocol mismatched (DB=%u param=%u)\n&quot;</span>,
				  sav-&gt;sah-&gt;saidx.proto, proto));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
	<span class="enscript-keyword">if</span> (sav-&gt;spi != sa0-&gt;sadb_sa_spi) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_update: SPI mismatched (DB:%u param:%u)\n&quot;</span>,
				  (u_int32_t)ntohl(sav-&gt;spi),
				  (u_int32_t)ntohl(sa0-&gt;sadb_sa_spi)));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (sav-&gt;pid != mhp-&gt;msg-&gt;sadb_msg_pid) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_update: pid mismatched (DB:%u param:%u)\n&quot;</span>,
				  sav-&gt;pid, mhp-&gt;msg-&gt;sadb_msg_pid));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-comment">/* copy sav values */</span>
	error = key_setsaval(sav, m, mhp);
	<span class="enscript-keyword">if</span> (error) {
		key_freesav(sav, KEY_SADB_LOCKED);
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}

	sav-&gt;flags2 = flags2;
	<span class="enscript-keyword">if</span> (flags2 &amp; SADB_X_EXT_SA2_DELETE_ON_DETACH) {
		sav-&gt;so = so;
	}

	<span class="enscript-comment">/*
	 * Verify if SADB_X_EXT_NATT_MULTIPLEUSERS flag is set that
	 * this SA is for transport mode - otherwise clear it.
	 */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0 &amp;&amp;
		(sav-&gt;sah-&gt;saidx.mode != IPSEC_MODE_TRANSPORT ||
		 sav-&gt;sah-&gt;saidx.src.ss_family != AF_INET))
		sav-&gt;flags &amp;= ~SADB_X_EXT_NATT_MULTIPLEUSERS;
	
	<span class="enscript-comment">/* check SA values to be mature. */</span>
	<span class="enscript-keyword">if</span> ((error = key_mature(sav)) != 0) {
		key_freesav(sav, KEY_SADB_LOCKED);
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	lck_mtx_unlock(sadb_mutex);
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		
		<span class="enscript-comment">/* set msg buf from mhp */</span>
		n = key_getmsgbuf_x1(m, mhp);
		<span class="enscript-keyword">if</span> (n == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_migrate</span>(<span class="enscript-type">struct</span> socket *so,
			<span class="enscript-type">struct</span> mbuf *m,
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_sa *sa0 = NULL;
	<span class="enscript-type">struct</span> sadb_address *src0 = NULL;
	<span class="enscript-type">struct</span> sadb_address *dst0 = NULL;
	<span class="enscript-type">struct</span> sadb_address *src1 = NULL;
	<span class="enscript-type">struct</span> sadb_address *dst1 = NULL;
	ifnet_t ipsec_if0 = NULL;
	ifnet_t ipsec_if1 = NULL;
	<span class="enscript-type">struct</span> secasindex saidx0;
	<span class="enscript-type">struct</span> secasindex saidx1;
	<span class="enscript-type">struct</span> secashead *sah = NULL;
	<span class="enscript-type">struct</span> secashead *newsah = NULL;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	u_int16_t proto;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_migrate: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL ||
		mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
		mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL ||
		mhp-&gt;ext[SADB_EXT_MIGRATE_ADDRESS_SRC] == NULL ||
		mhp-&gt;ext[SADB_EXT_MIGRATE_ADDRESS_DST] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa) ||
		mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
		mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
		mhp-&gt;extlen[SADB_EXT_MIGRATE_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
		mhp-&gt;extlen[SADB_EXT_MIGRATE_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	lck_mtx_lock(sadb_mutex);
	
	sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
	src0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_SRC]);
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_DST]);
	src1 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_MIGRATE_ADDRESS_SRC]);
	dst1 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_MIGRATE_ADDRESS_DST]);
	ipsec_if0 = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	ipsec_if1 = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_MIGRATE_IPSECIF);
	
	<span class="enscript-comment">/* Find existing SAH and SAV */</span>
	KEY_SETSECASIDX(proto, IPSEC_MODE_ANY, 0, src0 + 1, dst0 + 1, ipsec_if0 ? ipsec_if0-&gt;if_index : 0, &amp;saidx0);
	
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state != SADB_SASTATE_MATURE)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx0, CMP_HEAD) == 0)
			<span class="enscript-keyword">continue</span>;
		
		sav = key_getsavbyspi(sah, sa0-&gt;sadb_sa_spi);
		<span class="enscript-keyword">if</span> (sav &amp;&amp; sav-&gt;state == SADB_SASTATE_MATURE)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (sah == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: no mature SAH found.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	
	<span class="enscript-keyword">if</span> (sav == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: no SA found.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	
	<span class="enscript-comment">/* Find or create new SAH */</span>
	KEY_SETSECASIDX(proto, sah-&gt;saidx.mode, sah-&gt;saidx.reqid, src1 + 1, dst1 + 1, ipsec_if1 ? ipsec_if1-&gt;if_index : 0, &amp;saidx1);
	
	<span class="enscript-keyword">if</span> ((newsah = key_getsah(&amp;saidx1)) == NULL) {
		<span class="enscript-keyword">if</span> ((newsah = key_newsah(&amp;saidx1, ipsec_if1, key_get_outgoing_ifindex_from_message(mhp, SADB_X_EXT_MIGRATE_IPSECIF), sah-&gt;dir)) == NULL) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
	}
	
	<span class="enscript-comment">/* Migrate SAV in to new SAH */</span>
	<span class="enscript-keyword">if</span> (key_migratesav(sav, newsah) != 0) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_migrate: Failed to migrate SA to new SAH.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-comment">/* Reset NAT values */</span>
	sav-&gt;flags = sa0-&gt;sadb_sa_flags;
	sav-&gt;remote_ike_port = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_port;
	sav-&gt;natt_interval = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_interval;
	sav-&gt;natt_offload_interval = ((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_sa_2*)(sa0))-&gt;sadb_sa_natt_offload_interval;
	sav-&gt;natt_last_activity = natt_now;
	
	<span class="enscript-comment">/*
	 * Verify if SADB_X_EXT_NATT_MULTIPLEUSERS flag is set that
	 * SADB_X_EXT_NATT is set and SADB_X_EXT_NATT_KEEPALIVE is not
	 * set (we're not behind nat) - otherwise clear it.
	 */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0)
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) == 0 ||
			(sav-&gt;flags &amp; SADB_X_EXT_NATT_KEEPALIVE) != 0)
			sav-&gt;flags &amp;= ~SADB_X_EXT_NATT_MULTIPLEUSERS;
	
	lck_mtx_unlock(sadb_mutex);
	{
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_EXT_SA,
			SADB_EXT_ADDRESS_SRC, SADB_EXT_ADDRESS_DST, SADB_X_EXT_IPSECIF,
			SADB_EXT_MIGRATE_ADDRESS_SRC, SADB_EXT_MIGRATE_ADDRESS_DST, SADB_X_EXT_MIGRATE_IPSECIF};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
	}
}

<span class="enscript-comment">/*
 * search SAD with sequence for a SA which state is SADB_SASTATE_LARVAL.
 * only called by key_update().
 * OUT:
 *	NULL	: not found
 *	others	: found, pointer to a SA.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DOSEQCHECK</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secasvar *
<span class="enscript-function-name">key_getsavbyseq</span>(
				<span class="enscript-type">struct</span> secashead *sah,
				u_int32_t seq)
{
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int state;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	state = SADB_SASTATE_LARVAL;
	
	<span class="enscript-comment">/* search SAD with sequence number ? */</span>
	LIST_FOREACH(sav, &amp;sah-&gt;savtree[state], chain) {
		
		KEY_CHKSASTATE(state, sav-&gt;state, <span class="enscript-string">&quot;key_getsabyseq&quot;</span>);
		
		<span class="enscript-keyword">if</span> (sav-&gt;seq == seq) {
			sav-&gt;refcnt++;
			KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
			    printf(<span class="enscript-string">&quot;DP key_getsavbyseq cause &quot;</span>
			    <span class="enscript-string">&quot;refcnt++:%d SA:0x%llx\n&quot;</span>, sav-&gt;refcnt,
			    (uint64_t)VM_KERNEL_ADDRPERM(sav)));
			<span class="enscript-keyword">return</span> sav;
		}
	}
	
	<span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * SADB_ADD processing
 * add a entry to SA database, when received
 *   &lt;base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)
 *       key(AE), (identity(SD),) (sensitivity)&gt;
 * from the ikmpd,
 * and send
 *   &lt;base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)
 *       (identity(SD),) (sensitivity)&gt;
 * to the ikmpd.
 *
 * IGNORE identity and sensitivity messages.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_add</span>(
		<span class="enscript-type">struct</span> socket *so,
		<span class="enscript-type">struct</span> mbuf *m,
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_sa *sa0;
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *newsah;
	<span class="enscript-type">struct</span> secasvar *newsav;
	u_int16_t proto;
	u_int8_t mode;
	u_int32_t reqid;
	<span class="enscript-type">int</span> error;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_add: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_add: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL ||
	    (mhp-&gt;msg-&gt;sadb_msg_satype == SADB_SATYPE_ESP &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_KEY_ENCRYPT] == NULL) ||
	    (mhp-&gt;msg-&gt;sadb_msg_satype == SADB_SATYPE_AH &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_KEY_AUTH] == NULL) ||
	    (mhp-&gt;ext[SADB_EXT_LIFETIME_HARD] != NULL &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_LIFETIME_SOFT] == NULL) ||
	    (mhp-&gt;ext[SADB_EXT_LIFETIME_HARD] == NULL &amp;&amp;
	     mhp-&gt;ext[SADB_EXT_LIFETIME_SOFT] != NULL)) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_add: invalid message is passed.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		<span class="enscript-comment">/* XXX need more */</span>
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_add: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_X_EXT_SA2] != NULL) {
		mode = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_mode;
		reqid = ((<span class="enscript-type">struct</span> sadb_x_sa2 *)
				 (<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_X_EXT_SA2])-&gt;sadb_x_sa2_reqid;
	} <span class="enscript-keyword">else</span> {
		mode = IPSEC_MODE_ANY;
		reqid = 0;
	}
	
	sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
	src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_SRC];
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_DST];
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, mode, reqid, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* get a SA header */</span>
	<span class="enscript-keyword">if</span> ((newsah = key_getsah(&amp;saidx)) == NULL) {
		<span class="enscript-comment">/* create a new SA header: key_addspi is always used for outbound spi */</span>
		<span class="enscript-keyword">if</span> ((newsah = key_newsah(&amp;saidx, ipsec_if, key_get_outgoing_ifindex_from_message(mhp, SADB_X_EXT_IPSECIF), IPSEC_DIR_OUTBOUND)) == NULL) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_add: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
	}
	
	<span class="enscript-comment">/* set spidx if there */</span>
	<span class="enscript-comment">/* XXX rewrite */</span>
	error = key_setident(newsah, m, mhp);
	<span class="enscript-keyword">if</span> (error) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-comment">/* create new SA entry. */</span>
	<span class="enscript-comment">/* We can create new SA only if SPI is different. */</span>
	<span class="enscript-keyword">if</span> (key_getsavbyspi(newsah, sa0-&gt;sadb_sa_spi)) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_add: SA already exists.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EEXIST);
	}
	newsav = key_newsav(m, mhp, newsah, &amp;error, so);
	<span class="enscript-keyword">if</span> (newsav == NULL) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-comment">/*
	 * Verify if SADB_X_EXT_NATT_MULTIPLEUSERS flag is set that
	 * this SA is for transport mode - otherwise clear it.
	 */</span>
	<span class="enscript-keyword">if</span> ((newsav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0 &amp;&amp;
		(newsah-&gt;saidx.mode != IPSEC_MODE_TRANSPORT ||
		 newsah-&gt;saidx.dst.ss_family != AF_INET))
		newsav-&gt;flags &amp;= ~SADB_X_EXT_NATT_MULTIPLEUSERS;
	
	<span class="enscript-comment">/* check SA values to be mature. */</span>
	<span class="enscript-keyword">if</span> ((error = key_mature(newsav)) != 0) {
		key_freesav(newsav, KEY_SADB_LOCKED);
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-comment">/*
	 * don't call key_freesav() here, as we would like to keep the SA
	 * in the database on success.
	 */</span>
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		
		<span class="enscript-comment">/* set msg buf from mhp */</span>
		n = key_getmsgbuf_x1(m, mhp);
		<span class="enscript-keyword">if</span> (n == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_update: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/* m is retained */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_setident</span>(
			 <span class="enscript-type">struct</span> secashead *sah,
			 <span class="enscript-type">struct</span> mbuf *m,
			 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_ident *idsrc, *iddst;
	<span class="enscript-type">int</span> idsrclen, iddstlen;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sah == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_setident: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* don't make buffer if not there */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_IDENTITY_SRC] == NULL &amp;&amp;
	    mhp-&gt;ext[SADB_EXT_IDENTITY_DST] == NULL) {
		sah-&gt;idents = NULL;
		sah-&gt;identd = NULL;
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_IDENTITY_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_IDENTITY_DST] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setident: invalid identity.\n&quot;</span>));
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	idsrc = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_ident *)
	(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_IDENTITY_SRC];
	iddst = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_ident *)
	(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_IDENTITY_DST];
	idsrclen = mhp-&gt;extlen[SADB_EXT_IDENTITY_SRC];
	iddstlen = mhp-&gt;extlen[SADB_EXT_IDENTITY_DST];
	
	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (idsrc-&gt;sadb_ident_type != iddst-&gt;sadb_ident_type) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setident: ident type mismatch.\n&quot;</span>));
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-keyword">switch</span> (idsrc-&gt;sadb_ident_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_IDENTTYPE_PREFIX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_IDENTTYPE_FQDN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_IDENTTYPE_USERFQDN</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* XXX do nothing */</span>
			sah-&gt;idents = NULL;
			sah-&gt;identd = NULL;
			<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* make structure */</span>
	KMALLOC_NOWAIT(sah-&gt;idents, <span class="enscript-type">struct</span> sadb_ident *, idsrclen);
	<span class="enscript-keyword">if</span> (sah-&gt;idents == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(sah-&gt;idents, <span class="enscript-type">struct</span> sadb_ident *, idsrclen);
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (sah-&gt;idents == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setident: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
	}
	KMALLOC_NOWAIT(sah-&gt;identd, <span class="enscript-type">struct</span> sadb_ident *, iddstlen);
	<span class="enscript-keyword">if</span> (sah-&gt;identd == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(sah-&gt;identd, <span class="enscript-type">struct</span> sadb_ident *, iddstlen);
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (sah-&gt;identd == NULL) {
			KFREE(sah-&gt;idents);
			sah-&gt;idents = NULL;
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_setident: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
	}
	bcopy(idsrc, sah-&gt;idents, idsrclen);
	bcopy(iddst, sah-&gt;identd, iddstlen);
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * m will not be freed on return.
 * it is caller's responsibility to free the result.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_getmsgbuf_x1</span>(
				 <span class="enscript-type">struct</span> mbuf *m,
				 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_EXT_SA,
		SADB_X_EXT_SA2, SADB_EXT_ADDRESS_SRC,
		SADB_EXT_ADDRESS_DST, SADB_EXT_LIFETIME_HARD,
		SADB_EXT_LIFETIME_SOFT, SADB_EXT_IDENTITY_SRC,
		SADB_EXT_IDENTITY_DST};
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_getmsgbuf_x1: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
	n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
	<span class="enscript-keyword">if</span> (!n)
		<span class="enscript-keyword">return</span> NULL;
	
	<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">return</span> NULL;
	}
	mtod(n, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_errno = 0;
	mtod(n, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(n-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> n;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">key_delete_all</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *, u_int16_t);

<span class="enscript-comment">/*
 * SADB_DELETE processing
 * receive
 *   &lt;base, SA(*), address(SD)&gt;
 * from the ikmpd, and set SADB_SASTATE_DEAD,
 * and send,
 *   &lt;base, SA(*), address(SD)&gt;
 * to the ikmpd.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_delete</span>(
		   <span class="enscript-type">struct</span> socket *so,
		   <span class="enscript-type">struct</span> mbuf *m,
		   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_sa *sa0;
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	u_int16_t proto;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_delete: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL) {
		<span class="enscript-comment">/*
		 * Caller wants us to delete all non-LARVAL SAs
		 * that match the src/dst.  This is used during
		 * IKE INITIAL-CONTACT.
		 */</span>
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: doing delete all.\n&quot;</span>));
		<span class="enscript-comment">/* key_delete_all will unlock sadb_mutex  */</span>
		<span class="enscript-keyword">return</span> key_delete_all(so, m, mhp, proto);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa)) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
	src0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_SRC]);
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_DST]);
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, IPSEC_MODE_ANY, 0, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	<span class="enscript-comment">/* get a SA header */</span>
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx, CMP_HEAD) == 0)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* get a SA with SPI. */</span>
		sav = key_getsavbyspi(sah, sa0-&gt;sadb_sa_spi);
		<span class="enscript-keyword">if</span> (sav)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (sah == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete: no SA found.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	
	key_sa_chgstate(sav, SADB_SASTATE_DEAD);
	key_freesav(sav, KEY_SADB_LOCKED);
	
	lck_mtx_unlock(sadb_mutex);
	sav = NULL;
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_EXT_SA,
			SADB_EXT_ADDRESS_SRC, SADB_EXT_ADDRESS_DST};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/*
 * delete all SAs for src/dst.  Called from key_delete().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_delete_all</span>(
			   <span class="enscript-type">struct</span> socket *so,
			   <span class="enscript-type">struct</span> mbuf *m,
			   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp,
			   u_int16_t proto)
{
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
	u_int stateidx, state;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	src0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_SRC]);
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mhp-&gt;ext[SADB_EXT_ADDRESS_DST]);
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, IPSEC_MODE_ANY, 0, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx, CMP_HEAD) == 0)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* Delete all non-LARVAL SAs. */</span>
		<span class="enscript-keyword">for</span> (stateidx = 0;
		     stateidx &lt; _ARRAYLEN(saorder_state_alive);
		     stateidx++) {
			state = saorder_state_alive[stateidx];
			<span class="enscript-keyword">if</span> (state == SADB_SASTATE_LARVAL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[state]);
			     sav != NULL; sav = nextsav) {
				nextsav = LIST_NEXT(sav, chain);
				<span class="enscript-comment">/* sanity check */</span>
				<span class="enscript-keyword">if</span> (sav-&gt;state != state) {
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_delete_all: &quot;</span>
							  <span class="enscript-string">&quot;invalid sav-&gt;state &quot;</span>
							  <span class="enscript-string">&quot;(queue: %d SA: %d)\n&quot;</span>,
							  state, sav-&gt;state));
					<span class="enscript-keyword">continue</span>;
				}
				
				key_sa_chgstate(sav, SADB_SASTATE_DEAD);
				key_freesav(sav, KEY_SADB_LOCKED);
			}
		}
	}
	lck_mtx_unlock(sadb_mutex);
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">int</span> mbufItems[] = {SADB_EXT_RESERVED, SADB_EXT_ADDRESS_SRC,
			SADB_EXT_ADDRESS_DST};
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_gather_mbuf(m, mhp, 1, <span class="enscript-keyword">sizeof</span>(mbufItems)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), mbufItems);
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		<span class="enscript-keyword">if</span> (n-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
			n = m_pullup(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		}
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(n-&gt;m_pkthdr.len);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
    }
}

<span class="enscript-comment">/*
 * SADB_GET processing
 * receive
 *   &lt;base, SA(*), address(SD)&gt;
 * from the ikmpd, and get a SP and a SA to respond,
 * and send,
 *   &lt;base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE),
 *       (identity(SD),) (sensitivity)&gt;
 * to the ikmpd.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_get</span>(
		<span class="enscript-type">struct</span> socket *so,
		<span class="enscript-type">struct</span> mbuf *m,
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_sa *sa0;
	<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	u_int16_t proto;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_get: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_get: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SA] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_get: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SA] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_sa) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_get: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	sa0 = (<span class="enscript-type">struct</span> sadb_sa *)(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SA];
	src0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_SRC];
	dst0 = (<span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_DST];
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	KEY_SETSECASIDX(proto, IPSEC_MODE_ANY, 0, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* get a SA header */</span>
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx, CMP_HEAD) == 0)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* get a SA with SPI. */</span>
		sav = key_getsavbyspi(sah, sa0-&gt;sadb_sa_spi);
		<span class="enscript-keyword">if</span> (sav)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (sah == NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_get: no SA found.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOENT);
	}
	
    {
		<span class="enscript-type">struct</span> mbuf *n;
		u_int8_t satype;
		
		<span class="enscript-comment">/* map proto to satype */</span>
		<span class="enscript-keyword">if</span> ((satype = key_proto2satype(sah-&gt;saidx.proto)) == 0) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_get: there was invalid proto in SAD.\n&quot;</span>));
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
		lck_mtx_unlock(sadb_mutex);
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		n = key_setdumpsa(sav, SADB_GET, satype, mhp-&gt;msg-&gt;sadb_msg_seq,
						  mhp-&gt;msg-&gt;sadb_msg_pid);
		
		
		
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_ONE);
    }
}

<span class="enscript-comment">/*
 * get SA stats by spi.
 * OUT:	-1	: not found
 *	0	: found, arg pointer to a SA stats is updated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_getsastatbyspi_one</span> (u_int32_t      spi,
						<span class="enscript-type">struct</span> sastat *stat)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar  *sav = NULL;
	
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">void</span> *)stat == NULL) {
		<span class="enscript-keyword">return</span> -1;
	}
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* get a SA header */</span>
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* get a SA with SPI. */</span>
		sav = key_getsavbyspi(sah, spi);
		<span class="enscript-keyword">if</span> (sav) {
			stat-&gt;spi = sav-&gt;spi;
			stat-&gt;created = sav-&gt;created;
			<span class="enscript-keyword">if</span> (sav-&gt;lft_c) {
				bcopy(sav-&gt;lft_c,&amp;stat-&gt;lft_c, <span class="enscript-keyword">sizeof</span>(stat-&gt;lft_c));
			} <span class="enscript-keyword">else</span> {
				bzero(&amp;stat-&gt;lft_c, <span class="enscript-keyword">sizeof</span>(stat-&gt;lft_c));
			}
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 0;
		}
	}
	
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">/*
 * get SA stats collection by indices.
 * OUT:	-1	: not found
 *	0	: found, arg pointers to a SA stats and 'maximum stats' are updated.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_getsastatbyspi</span> (<span class="enscript-type">struct</span> sastat *stat_arg,
					u_int32_t      max_stat_arg,
					<span class="enscript-type">struct</span> sastat *stat_res,
					u_int32_t     *max_stat_res)
{
	<span class="enscript-type">int</span> cur, found = 0;
	
	<span class="enscript-keyword">if</span> (stat_arg == NULL ||
	    stat_res == NULL ||
	    max_stat_res == NULL) {
		<span class="enscript-keyword">return</span> -1;
	}
	
	<span class="enscript-keyword">for</span> (cur = 0; cur &lt; max_stat_arg; cur++) {
		<span class="enscript-keyword">if</span> (key_getsastatbyspi_one(stat_arg[cur].spi,
								   &amp;stat_res[found]) == 0) {
			found++;
		}
	}
	*max_stat_res = found;
	
	<span class="enscript-keyword">if</span> (found) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">/* XXX make it sysctl-configurable? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_getcomb_setlifetime</span>(
						<span class="enscript-type">struct</span> sadb_comb *comb)
{
	
	comb-&gt;sadb_comb_soft_allocations = 1;
	comb-&gt;sadb_comb_hard_allocations = 1;
	comb-&gt;sadb_comb_soft_bytes = 0;
	comb-&gt;sadb_comb_hard_bytes = 0;
	comb-&gt;sadb_comb_hard_addtime = 86400;	<span class="enscript-comment">/* 1 day */</span>
	comb-&gt;sadb_comb_soft_addtime = comb-&gt;sadb_comb_soft_addtime * 80 / 100;
	comb-&gt;sadb_comb_soft_usetime = 28800;	<span class="enscript-comment">/* 8 hours */</span>
	comb-&gt;sadb_comb_hard_usetime = comb-&gt;sadb_comb_hard_usetime * 80 / 100;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
<span class="enscript-comment">/*
 * XXX reorder combinations by preference
 * XXX no idea if the user wants ESP authentication or not
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_getcomb_esp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> sadb_comb *comb;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m, *n;
	<span class="enscript-type">int</span> encmin;
	<span class="enscript-type">int</span> i, off, o;
	<span class="enscript-type">int</span> totlen;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> l = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_comb));
	
	m = NULL;
	<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_EALG_MAX; i++) {
		algo = esp_algorithm_lookup(i);
		<span class="enscript-keyword">if</span> (!algo)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (algo-&gt;keymax &lt; ipsec_esp_keymin)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (algo-&gt;keymin &lt; ipsec_esp_keymin)
			encmin = ipsec_esp_keymin;
		<span class="enscript-keyword">else</span>
			encmin = algo-&gt;keymin;
		
		<span class="enscript-keyword">if</span> (ipsec_esp_auth)
			m = key_getcomb_ah();
		<span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (l &gt; MLEN)
				panic(<span class="enscript-string">&quot;assumption failed in key_getcomb_esp&quot;</span>);
#<span class="enscript-reference">endif</span>
			MGET(m, M_WAITOK, MT_DATA);
			<span class="enscript-keyword">if</span> (m) {
				M_ALIGN(m, l);
				m-&gt;m_len = l;
				m-&gt;m_next = NULL;
				bzero(mtod(m, caddr_t), m-&gt;m_len);
			}
		}
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		
		totlen = 0;
		<span class="enscript-keyword">for</span> (n = m; n; n = n-&gt;m_next)
			totlen += n-&gt;m_len;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (totlen % l)
			panic(<span class="enscript-string">&quot;assumption failed in key_getcomb_esp&quot;</span>);
#<span class="enscript-reference">endif</span>
		
		<span class="enscript-keyword">for</span> (off = 0; off &lt; totlen; off += l) {
			n = m_pulldown(m, off, l, &amp;o);
			<span class="enscript-keyword">if</span> (!n) {
				<span class="enscript-comment">/* m is already freed */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			comb = (<span class="enscript-type">struct</span> sadb_comb *)
			(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + o);
			bzero(comb, <span class="enscript-keyword">sizeof</span>(*comb));
			key_getcomb_setlifetime(comb);
			comb-&gt;sadb_comb_encrypt = i;
			comb-&gt;sadb_comb_encrypt_minbits = encmin;
			comb-&gt;sadb_comb_encrypt_maxbits = algo-&gt;keymax;
		}
		
		<span class="enscript-keyword">if</span> (!result)
			result = m;
		<span class="enscript-keyword">else</span>
			m_cat(result, m);
	}
	
	<span class="enscript-keyword">return</span> result;
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_freem(result);
	<span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * XXX reorder combinations by preference
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_getcomb_ah</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> sadb_comb *comb;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> keymin;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> l = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_comb));
	
	m = NULL;
	<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_AALG_MAX; i++) {
#<span class="enscript-reference">if</span> 1
		<span class="enscript-comment">/* we prefer HMAC algorithms, not old algorithms */</span>
		<span class="enscript-keyword">if</span> (i != SADB_AALG_SHA1HMAC &amp;&amp; i != SADB_AALG_MD5HMAC)
			<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">endif</span>
		algo = ah_algorithm_lookup(i);
		<span class="enscript-keyword">if</span> (!algo)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (algo-&gt;keymax &lt; ipsec_ah_keymin)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (algo-&gt;keymin &lt; ipsec_ah_keymin)
			keymin = ipsec_ah_keymin;
		<span class="enscript-keyword">else</span>
			keymin = algo-&gt;keymin;
		
		<span class="enscript-keyword">if</span> (!m) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (l &gt; MLEN)
				panic(<span class="enscript-string">&quot;assumption failed in key_getcomb_ah&quot;</span>);
#<span class="enscript-reference">endif</span>
			MGET(m, M_WAITOK, MT_DATA);
			<span class="enscript-keyword">if</span> (m) {
				M_ALIGN(m, l);
				m-&gt;m_len = l;
				m-&gt;m_next = NULL;
			}
		} <span class="enscript-keyword">else</span>
			M_PREPEND(m, l, M_WAITOK, 1);
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> NULL;
		
		comb = mtod(m, <span class="enscript-type">struct</span> sadb_comb *);
		bzero(comb, <span class="enscript-keyword">sizeof</span>(*comb));
		key_getcomb_setlifetime(comb);
		comb-&gt;sadb_comb_auth = i;
		comb-&gt;sadb_comb_auth_minbits = keymin;
		comb-&gt;sadb_comb_auth_maxbits = algo-&gt;keymax;
	}
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * not really an official behavior.  discussed in <a href="mailto:pf_key@inner.net">pf_key@inner.net</a> in Sep2000.
 * XXX reorder combinations by preference
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_getcomb_ipcomp</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> sadb_comb *comb;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ipcomp_algorithm *algo;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> l = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_comb));
	
	m = NULL;
	<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_X_CALG_MAX; i++) {
		algo = ipcomp_algorithm_lookup(i);
		<span class="enscript-keyword">if</span> (!algo)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (!m) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (l &gt; MLEN)
				panic(<span class="enscript-string">&quot;assumption failed in key_getcomb_ipcomp&quot;</span>);
#<span class="enscript-reference">endif</span>
			MGET(m, M_WAITOK, MT_DATA);
			<span class="enscript-keyword">if</span> (m) {
				M_ALIGN(m, l);
				m-&gt;m_len = l;
				m-&gt;m_next = NULL;
			}
		} <span class="enscript-keyword">else</span>
			M_PREPEND(m, l, M_WAITOK, 1);
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> NULL;
		
		comb = mtod(m, <span class="enscript-type">struct</span> sadb_comb *);
		bzero(comb, <span class="enscript-keyword">sizeof</span>(*comb));
		key_getcomb_setlifetime(comb);
		comb-&gt;sadb_comb_encrypt = i;
		<span class="enscript-comment">/* what should we set into sadb_comb_*_{min,max}bits? */</span>
	}
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * XXX no way to pass mode (transport/tunnel) to userland
 * XXX replay checking?
 * XXX sysctl interface to ipsec_{ah,esp}_keymin
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_getprop</span>(
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> secasindex *saidx)
{
	<span class="enscript-type">struct</span> sadb_prop *prop;
	<span class="enscript-type">struct</span> mbuf *m, *n;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> l = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_prop));
	<span class="enscript-type">int</span> totlen;
	
	<span class="enscript-keyword">switch</span> (saidx-&gt;proto)  {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			m = key_getcomb_esp();
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			m = key_getcomb_ah();
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			m = key_getcomb_ipcomp();
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">return</span> NULL;
	M_PREPEND(m, l, M_WAITOK, 1);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">return</span> NULL;
	
	totlen = 0;
	<span class="enscript-keyword">for</span> (n = m; n; n = n-&gt;m_next)
		totlen += n-&gt;m_len;
	
	prop = mtod(m, <span class="enscript-type">struct</span> sadb_prop *);
	bzero(prop, <span class="enscript-keyword">sizeof</span>(*prop));
	prop-&gt;sadb_prop_len = PFKEY_UNIT64(totlen);
	prop-&gt;sadb_prop_exttype = SADB_EXT_PROPOSAL;
	prop-&gt;sadb_prop_replay = 32;	<span class="enscript-comment">/* XXX */</span>
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-comment">/*
 * SADB_ACQUIRE processing called by key_checkrequest() and key_acquire2().
 * send
 *   &lt;base, SA, address(SD), (address(P)), x_policy,
 *       (identity(SD),) (sensitivity,) proposal&gt;
 * to KMD, and expect to receive
 *   &lt;base&gt; with SADB_ACQUIRE if error occurred,
 * or
 *   &lt;base, src address, dst address, (SPI range)&gt; with SADB_GETSPI
 * from KMD by PF_KEY.
 *
 * XXX x_policy is outside of RFC2367 (KAME extension).
 * XXX sensitivity is not supported.
 * XXX for ipcomp, RFC2367 does not define how to fill in proposal.
 * see comment for key_getcomb_ipcomp().
 *
 * OUT:
 *    0     : succeed
 *    others: error number
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_acquire</span>(
			<span class="enscript-type">struct</span> secasindex *saidx,
			<span class="enscript-type">struct</span> secpolicy *sp)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m;
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
	<span class="enscript-type">struct</span> secacq *newacq;
#<span class="enscript-reference">endif</span>
	u_int8_t satype;
	<span class="enscript-type">int</span> error = -1;
	u_int32_t seq;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (saidx == NULL)
		panic(<span class="enscript-string">&quot;key_acquire: NULL pointer is passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> ((satype = key_proto2satype(saidx-&gt;proto)) == 0)
		panic(<span class="enscript-string">&quot;key_acquire: invalid proto is passed.\n&quot;</span>);
	
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
	<span class="enscript-comment">/*
	 * We never do anything about acquirng SA.  There is anather
	 * solution that kernel blocks to send SADB_ACQUIRE message until
	 * getting something message from IKEd.  In later case, to be
	 * managed with ACQUIRING list.
	 */</span>
	<span class="enscript-comment">/* get a entry to check whether sending message or not. */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> ((newacq = key_getacq(saidx)) != NULL) {
		<span class="enscript-keyword">if</span> (key_blockacq_count &lt; newacq-&gt;count) {
			<span class="enscript-comment">/* reset counter and do send message. */</span>
			newacq-&gt;count = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* increment counter and do nothing. */</span>
			newacq-&gt;count++;
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 0;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* make new entry for blocking to send SADB_ACQUIRE. */</span>
		<span class="enscript-keyword">if</span> ((newacq = key_newacq(saidx)) == NULL) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		
		<span class="enscript-comment">/* add to acqtree */</span>
		LIST_INSERT_HEAD(&amp;acqtree, newacq, chain);
		key_start_timehandler();
	}
	seq = newacq-&gt;seq;
	lck_mtx_unlock(sadb_mutex);
	
#<span class="enscript-reference">else</span>
	seq = (acq_seq = (acq_seq == ~0 ? 1 : ++acq_seq));
#<span class="enscript-reference">endif</span>
	m = key_setsadbmsg(SADB_ACQUIRE, 0, satype, seq, 0, 0);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	result = m;
	
	<span class="enscript-comment">/* set sadb_address for saidx's. */</span>
	m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;saidx-&gt;src, FULLMASK, IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;saidx-&gt;dst, FULLMASK, IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-comment">/* XXX proxy address (optional) */</span>
	
	<span class="enscript-comment">/* set sadb_x_policy */</span>
	<span class="enscript-keyword">if</span> (sp) {
		m = key_setsadbxpolicy(sp-&gt;policy, sp-&gt;spidx.dir, sp-&gt;id);
		<span class="enscript-keyword">if</span> (!m) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		m_cat(result, m);
	}
	
	<span class="enscript-comment">/* XXX identity (optional) */</span>
#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span> (idexttype &amp;&amp; fqdn) {
		<span class="enscript-comment">/* create identity extension (FQDN) */</span>
		<span class="enscript-type">struct</span> sadb_ident *id;
		<span class="enscript-type">int</span> fqdnlen;
		
		fqdnlen = strlen(fqdn) + 1;	<span class="enscript-comment">/* +1 for terminating-NUL */</span>
		id = (<span class="enscript-type">struct</span> sadb_ident *)p;
		bzero(id, <span class="enscript-keyword">sizeof</span>(*id) + PFKEY_ALIGN8(fqdnlen));
		id-&gt;sadb_ident_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(*id) + PFKEY_ALIGN8(fqdnlen));
		id-&gt;sadb_ident_exttype = idexttype;
		id-&gt;sadb_ident_type = SADB_IDENTTYPE_FQDN;
		bcopy(fqdn, id + 1, fqdnlen);
		p += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident) + PFKEY_ALIGN8(fqdnlen);
	}
	
	<span class="enscript-keyword">if</span> (idexttype) {
		<span class="enscript-comment">/* create identity extension (USERFQDN) */</span>
		<span class="enscript-type">struct</span> sadb_ident *id;
		<span class="enscript-type">int</span> userfqdnlen;
		
		<span class="enscript-keyword">if</span> (userfqdn) {
			<span class="enscript-comment">/* +1 for terminating-NUL */</span>
			userfqdnlen = strlen(userfqdn) + 1;
		} <span class="enscript-keyword">else</span>
			userfqdnlen = 0;
		id = (<span class="enscript-type">struct</span> sadb_ident *)p;
		bzero(id, <span class="enscript-keyword">sizeof</span>(*id) + PFKEY_ALIGN8(userfqdnlen));
		id-&gt;sadb_ident_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(*id) + PFKEY_ALIGN8(userfqdnlen));
		id-&gt;sadb_ident_exttype = idexttype;
		id-&gt;sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
		<span class="enscript-comment">/* XXX is it correct? */</span>
		<span class="enscript-keyword">if</span> (curproc &amp;&amp; curproc-&gt;p_cred)
			id-&gt;sadb_ident_id = curproc-&gt;p_cred-&gt;p_ruid;
		<span class="enscript-keyword">if</span> (userfqdn &amp;&amp; userfqdnlen)
			bcopy(userfqdn, id + 1, userfqdnlen);
		p += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident) + PFKEY_ALIGN8(userfqdnlen);
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/* XXX sensitivity (optional) */</span>
	
	<span class="enscript-comment">/* create proposal/combination extension */</span>
	m = key_getprop(saidx);
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * spec conformant: always attach proposal/combination extension,
	 * the problem is that we have no way to attach it for ipcomp,
	 * due to the way sadb_comb is declared in RFC2367.
	 */</span>
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/*
	 * outside of spec; make proposal/combination extension optional.
	 */</span>
	<span class="enscript-keyword">if</span> (m)
		m_cat(result, m);
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(NULL, result, KEY_SENDUP_REGISTERED);
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_freem(result);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *
<span class="enscript-function-name">key_newacq</span>(
		   <span class="enscript-type">struct</span> secasindex *saidx)
{
	<span class="enscript-type">struct</span> secacq *newacq;
	<span class="enscript-type">struct</span> timeval tv;
	
	<span class="enscript-comment">/* get new entry */</span>
	KMALLOC_NOWAIT(newacq, <span class="enscript-type">struct</span> secacq *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secacq));
	<span class="enscript-keyword">if</span> (newacq == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(newacq, <span class="enscript-type">struct</span> secacq *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secacq));
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (newacq == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newacq: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	bzero(newacq, <span class="enscript-keyword">sizeof</span>(*newacq));
	
	<span class="enscript-comment">/* copy secindex */</span>
	bcopy(saidx, &amp;newacq-&gt;saidx, <span class="enscript-keyword">sizeof</span>(newacq-&gt;saidx));
	newacq-&gt;seq = (acq_seq == ~0 ? 1 : ++acq_seq);
	microtime(&amp;tv);
	newacq-&gt;created = tv.tv_sec;
	newacq-&gt;count = 0;
	
	<span class="enscript-keyword">return</span> newacq;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *
<span class="enscript-function-name">key_getacq</span>(
		   <span class="enscript-type">struct</span> secasindex *saidx)
{
	<span class="enscript-type">struct</span> secacq *acq;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	LIST_FOREACH(acq, &amp;acqtree, chain) {
		<span class="enscript-keyword">if</span> (key_cmpsaidx(saidx, &amp;acq-&gt;saidx, CMP_EXACTLY))
			<span class="enscript-keyword">return</span> acq;
	}
	
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secacq *
<span class="enscript-function-name">key_getacqbyseq</span>(
				u_int32_t seq)
{
	<span class="enscript-type">struct</span> secacq *acq;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	LIST_FOREACH(acq, &amp;acqtree, chain) {
		<span class="enscript-keyword">if</span> (acq-&gt;seq == seq)
			<span class="enscript-keyword">return</span> acq;
	}
	
	<span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secspacq *
<span class="enscript-function-name">key_newspacq</span>(
			 <span class="enscript-type">struct</span> secpolicyindex *spidx)
{
	<span class="enscript-type">struct</span> secspacq *acq;
	<span class="enscript-type">struct</span> timeval tv;
	
	<span class="enscript-comment">/* get new entry */</span>
	KMALLOC_NOWAIT(acq, <span class="enscript-type">struct</span> secspacq *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secspacq));
	<span class="enscript-keyword">if</span> (acq == NULL) {
		lck_mtx_unlock(sadb_mutex);
		KMALLOC_WAIT(acq, <span class="enscript-type">struct</span> secspacq *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> secspacq));
		lck_mtx_lock(sadb_mutex);
		<span class="enscript-keyword">if</span> (acq == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_newspacq: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> NULL;
		}
	}
	bzero(acq, <span class="enscript-keyword">sizeof</span>(*acq));
	
	<span class="enscript-comment">/* copy secindex */</span>
	bcopy(spidx, &amp;acq-&gt;spidx, <span class="enscript-keyword">sizeof</span>(acq-&gt;spidx));
	microtime(&amp;tv);
	acq-&gt;created = tv.tv_sec;
	acq-&gt;count = 0;
	
	<span class="enscript-keyword">return</span> acq;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secspacq *
<span class="enscript-function-name">key_getspacq</span>(
			 <span class="enscript-type">struct</span> secpolicyindex *spidx)
{
	<span class="enscript-type">struct</span> secspacq *acq;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	LIST_FOREACH(acq, &amp;spacqtree, chain) {
		<span class="enscript-keyword">if</span> (key_cmpspidx_exactly(spidx, &amp;acq-&gt;spidx))
			<span class="enscript-keyword">return</span> acq;
	}
	
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * SADB_ACQUIRE processing,
 * in first situation, is receiving
 *   &lt;base&gt;
 * from the ikmpd, and clear sequence of its secasvar entry.
 *
 * In second situation, is receiving
 *   &lt;base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal&gt;
 * from a user land process, and return
 *   &lt;base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal&gt;
 * to the socket.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_acquire2</span>(
			 <span class="enscript-type">struct</span> socket *so,
			 <span class="enscript-type">struct</span> mbuf *m,
			 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_address *src0, *dst0;
	ifnet_t ipsec_if = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secashead *sah;
	u_int16_t proto;
	<span class="enscript-type">int</span> error;
	
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_acquire2: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/*
	 * Error message from KMd.
	 * We assume that if error was occurred in IKEd, the length of PFKEY
	 * message is equal to the size of sadb_msg structure.
	 * We do not raise error even if error occurred in this function.
	 */</span>
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_len == PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg))) {
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPSEC_NONBLOCK_ACQUIRE</span>
		<span class="enscript-type">struct</span> secacq *acq;
		<span class="enscript-type">struct</span> timeval tv;
		
		<span class="enscript-comment">/* check sequence number */</span>
		<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_seq == 0) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: must specify sequence number.\n&quot;</span>));
			m_freem(m);
			<span class="enscript-keyword">return</span> 0;
		}
		
		<span class="enscript-keyword">if</span> ((acq = key_getacqbyseq(mhp-&gt;msg-&gt;sadb_msg_seq)) == NULL) {
			<span class="enscript-comment">/*
			 * the specified larval SA is already gone, or we got
			 * a bogus sequence number.  we can silently ignore it.
			 */</span>
			lck_mtx_unlock(sadb_mutex);
			m_freem(m);
			<span class="enscript-keyword">return</span> 0;
		}
		
		<span class="enscript-comment">/* reset acq counter in order to deletion by timehander. */</span>
		microtime(&amp;tv);
		acq-&gt;created = tv.tv_sec;
		acq-&gt;count = 0;
#<span class="enscript-reference">endif</span>
		lck_mtx_unlock(sadb_mutex);
		m_freem(m);
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/*
	 * This message is from user land.
	 */</span>
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_ADDRESS_SRC] == NULL ||
	    mhp-&gt;ext[SADB_EXT_ADDRESS_DST] == NULL ||
	    mhp-&gt;ext[SADB_EXT_PROPOSAL] == NULL) {
		<span class="enscript-comment">/* error */</span>
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_ADDRESS_SRC] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_ADDRESS_DST] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address) ||
	    mhp-&gt;extlen[SADB_EXT_PROPOSAL] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_prop)) {
		<span class="enscript-comment">/* error */</span>
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: invalid message is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	src0 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_SRC];
	dst0 = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_address *)mhp-&gt;ext[SADB_EXT_ADDRESS_DST];
	ipsec_if = key_get_ipsec_if_from_message(mhp, SADB_X_EXT_IPSECIF);
	
	<span class="enscript-comment">/* XXX boundary check against sa_len */</span>
	<span class="enscript-comment">/* cast warnings */</span>
	KEY_SETSECASIDX(proto, IPSEC_MODE_ANY, 0, src0 + 1, dst0 + 1, ipsec_if ? ipsec_if-&gt;if_index : 0, &amp;saidx);
	
	<span class="enscript-comment">/* get a SA index */</span>
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;state == SADB_SASTATE_DEAD)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sah-&gt;saidx, &amp;saidx, CMP_MODE | CMP_REQID))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (sah != NULL) {
		lck_mtx_unlock(sadb_mutex);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: a SA exists already.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EEXIST);
	}
	lck_mtx_unlock(sadb_mutex);
	error = key_acquire(&amp;saidx, NULL);
	<span class="enscript-keyword">if</span> (error != 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_acquire2: error %d returned &quot;</span>
				  <span class="enscript-string">&quot;from key_acquire.\n&quot;</span>, mhp-&gt;msg-&gt;sadb_msg_errno));
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	}
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_REGISTERED);
}

<span class="enscript-comment">/*
 * SADB_REGISTER processing.
 * If SATYPE_UNSPEC has been passed as satype, only return sadb_supported.
 * receive
 *   &lt;base&gt;
 * from the ikmpd, and register a socket to send PF_KEY messages,
 * and send
 *   &lt;base, supported&gt;
 * to KMD by PF_KEY.
 * If socket is detached, must free from regnode.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_register</span>(
			 <span class="enscript-type">struct</span> socket *so,
			 <span class="enscript-type">struct</span> mbuf *m,
			 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> secreg *reg, *newreg = 0;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_register: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* check for invalid register message */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_satype &gt;= <span class="enscript-keyword">sizeof</span>(regtree)/<span class="enscript-keyword">sizeof</span>(regtree[0]))
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	
	<span class="enscript-comment">/* When SATYPE_UNSPEC is specified, only return sadb_supported. */</span>
	<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_satype == SADB_SATYPE_UNSPEC)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">setmsg</span>;
	
	<span class="enscript-comment">/* create regnode */</span>
	KMALLOC_WAIT(newreg, <span class="enscript-type">struct</span> secreg *, <span class="enscript-keyword">sizeof</span>(*newreg));
	<span class="enscript-keyword">if</span> (newreg == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_register: No more memory.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
	}
	bzero((caddr_t)newreg, <span class="enscript-keyword">sizeof</span>(*newreg));
	
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* check whether existing or not */</span>
	LIST_FOREACH(reg, &amp;regtree[mhp-&gt;msg-&gt;sadb_msg_satype], chain) {
		<span class="enscript-keyword">if</span> (reg-&gt;so == so) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_register: socket exists already.\n&quot;</span>));
			KFREE(newreg);
			<span class="enscript-keyword">return</span> key_senderror(so, m, EEXIST);
		}
	}
	
	socket_lock(so, 1);
	newreg-&gt;so = so;
	((<span class="enscript-type">struct</span> keycb *)sotorawcb(so))-&gt;kp_registered++;
	socket_unlock(so, 1);
	
	<span class="enscript-comment">/* add regnode to regtree. */</span>
	LIST_INSERT_HEAD(&amp;regtree[mhp-&gt;msg-&gt;sadb_msg_satype], newreg, chain);
	lck_mtx_unlock(sadb_mutex);
<span class="enscript-reference">setmsg</span>:
    {
		<span class="enscript-type">struct</span> mbuf *n;
		<span class="enscript-type">struct</span> sadb_msg *newmsg;
		<span class="enscript-type">struct</span> sadb_supported *sup;
		u_int len, alen, elen;
		<span class="enscript-type">int</span> off;
		<span class="enscript-type">int</span> i;
		<span class="enscript-type">struct</span> sadb_alg *alg;
		
		<span class="enscript-comment">/* create new sadb_msg to reply. */</span>
		alen = 0;
		<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_AALG_MAX; i++) {
			<span class="enscript-keyword">if</span> (ah_algorithm_lookup(i))
				alen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_alg);
		}
		<span class="enscript-keyword">if</span> (alen)
			alen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_supported);
		elen = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_EALG_MAX; i++) {
			<span class="enscript-keyword">if</span> (esp_algorithm_lookup(i))
				elen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_alg);
		}
		<span class="enscript-keyword">if</span> (elen)
			elen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_supported);
#<span class="enscript-reference">endif</span>
		
		len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg) + alen + elen;
		
		<span class="enscript-keyword">if</span> (len &gt; MCLBYTES)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		MGETHDR(n, M_WAITOK, MT_DATA);
		<span class="enscript-keyword">if</span> (n &amp;&amp; len &gt; MHLEN) {
			MCLGET(n, M_WAITOK);
			<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
				m_freem(n);
				n = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!n)
			<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
		
		n-&gt;m_pkthdr.len = n-&gt;m_len = len;
		n-&gt;m_next = NULL;
		off = 0;
		
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg), mtod(n, caddr_t) + off);
		newmsg = mtod(n, <span class="enscript-type">struct</span> sadb_msg *);
		newmsg-&gt;sadb_msg_errno = 0;
		newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(len);
		off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		
		<span class="enscript-comment">/* for authentication algorithm */</span>
		<span class="enscript-keyword">if</span> (alen) {
			sup = (<span class="enscript-type">struct</span> sadb_supported *)(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + off);
			sup-&gt;sadb_supported_len = PFKEY_UNIT64(alen);
			sup-&gt;sadb_supported_exttype = SADB_EXT_SUPPORTED_AUTH;
			off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*sup));
			
			<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_AALG_MAX; i++) {
				<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *aalgo;
				
				aalgo = ah_algorithm_lookup(i);
				<span class="enscript-keyword">if</span> (!aalgo)
					<span class="enscript-keyword">continue</span>;
				alg = (<span class="enscript-type">struct</span> sadb_alg *)
			    (<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + off);
				alg-&gt;sadb_alg_id = i;
				alg-&gt;sadb_alg_ivlen = 0;
				alg-&gt;sadb_alg_minbits = aalgo-&gt;keymin;
				alg-&gt;sadb_alg_maxbits = aalgo-&gt;keymax;
				off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*alg));
			}
		}
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		<span class="enscript-comment">/* for encryption algorithm */</span>
		<span class="enscript-keyword">if</span> (elen) {
			sup = (<span class="enscript-type">struct</span> sadb_supported *)(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + off);
			sup-&gt;sadb_supported_len = PFKEY_UNIT64(elen);
			sup-&gt;sadb_supported_exttype = SADB_EXT_SUPPORTED_ENCRYPT;
			off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*sup));
			
			<span class="enscript-keyword">for</span> (i = 1; i &lt;= SADB_EALG_MAX; i++) {
				<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *ealgo;
				
				ealgo = esp_algorithm_lookup(i);
				<span class="enscript-keyword">if</span> (!ealgo)
					<span class="enscript-keyword">continue</span>;
				alg = (<span class="enscript-type">struct</span> sadb_alg *)
			    (<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + off);
				alg-&gt;sadb_alg_id = i;
				<span class="enscript-keyword">if</span> (ealgo &amp;&amp; ealgo-&gt;ivlen) {
					<span class="enscript-comment">/*
					 * give NULL to get the value preferred by
					 * algorithm XXX SADB_X_EXT_DERIV ?
					 */</span>
					alg-&gt;sadb_alg_ivlen =
				    (*ealgo-&gt;ivlen)(ealgo, NULL);
				} <span class="enscript-keyword">else</span>
					alg-&gt;sadb_alg_ivlen = 0;
				alg-&gt;sadb_alg_minbits = ealgo-&gt;keymin;
				alg-&gt;sadb_alg_maxbits = ealgo-&gt;keymax;
				off += PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_alg));
			}
		}
#<span class="enscript-reference">endif</span>
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIGAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (off != len)
			panic(<span class="enscript-string">&quot;length assumption failed in key_register&quot;</span>);
#<span class="enscript-reference">endif</span>
		
		m_freem(m);
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, n, KEY_SENDUP_REGISTERED);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_delete_all_for_socket</span> (<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> secashead *sah, *nextsah;
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
	u_int stateidx;
	u_int state;

	<span class="enscript-keyword">for</span> (sah = LIST_FIRST(&amp;sahtree);
		 sah != NULL;
		 sah = nextsah) {
		nextsah = LIST_NEXT(sah, chain);
		<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; _ARRAYLEN(saorder_state_alive); stateidx++) {
			state = saorder_state_any[stateidx];
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[state]); sav != NULL; sav = nextsav) {
				nextsav = LIST_NEXT(sav, chain);
				<span class="enscript-keyword">if</span> (sav-&gt;flags2 &amp; SADB_X_EXT_SA2_DELETE_ON_DETACH &amp;&amp;
					sav-&gt;so == so) {
					key_sa_chgstate(sav, SADB_SASTATE_DEAD);
					key_freesav(sav, KEY_SADB_LOCKED);
				}
			}
		}
	}
}

<span class="enscript-comment">/*
 * free secreg entry registered.
 * XXX: I want to do free a socket marked done SADB_RESIGER to socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_freereg</span>(
			<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> secreg *reg;
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL)
		panic(<span class="enscript-string">&quot;key_freereg: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/*
	 * check whether existing or not.
	 * check all type of SA, because there is a potential that
	 * one socket is registered to multiple type of SA.
	 */</span>
	lck_mtx_lock(sadb_mutex);
	key_delete_all_for_socket(so);
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= SADB_SATYPE_MAX; i++) {
		LIST_FOREACH(reg, &amp;regtree[i], chain) {
			<span class="enscript-keyword">if</span> (reg-&gt;so == so
				&amp;&amp; __LIST_CHAINED(reg)) {
				LIST_REMOVE(reg, chain);
				KFREE(reg);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * SADB_EXPIRE processing
 * send
 *   &lt;base, SA, SA2, lifetime(C and one of HS), address(SD)&gt;
 * to KMD by PF_KEY.
 * NOTE: We send only soft lifetime extension.
 *
 * OUT:	0	: succeed
 *	others	: error number
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_expire</span>(
		   <span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">int</span> satype;
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m;
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">int</span> error = -1;
	<span class="enscript-type">struct</span> sadb_lifetime *lt;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;key_expire: NULL pointer is passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (sav-&gt;sah == NULL)
		panic(<span class="enscript-string">&quot;key_expire: Why was SA index in SA NULL.\n&quot;</span>);
	<span class="enscript-keyword">if</span> ((satype = key_proto2satype(sav-&gt;sah-&gt;saidx.proto)) == 0)
		panic(<span class="enscript-string">&quot;key_expire: invalid proto is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* set msg header */</span>
	m = key_setsadbmsg(SADB_EXPIRE, 0, satype, sav-&gt;seq, 0, sav-&gt;refcnt);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	result = m;
	
	<span class="enscript-comment">/* create SA extension */</span>
	m = key_setsadbsa(sav);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-comment">/* create SA extension */</span>
	m = key_setsadbxsa2(sav-&gt;sah-&gt;saidx.mode,
						sav-&gt;replay ? sav-&gt;replay-&gt;count : 0,
						sav-&gt;sah-&gt;saidx.reqid,
						sav-&gt;flags2);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-comment">/* create lifetime extension (current and soft) */</span>
	len = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(*lt)) * 2;
	m = key_alloc_mbuf(len);
	<span class="enscript-keyword">if</span> (!m || m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">if</span> (m)
			m_freem(m);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	bzero(mtod(m, caddr_t), len);
	lt = mtod(m, <span class="enscript-type">struct</span> sadb_lifetime *);
	lt-&gt;sadb_lifetime_len = PFKEY_UNIT64(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_lifetime));
	lt-&gt;sadb_lifetime_exttype = SADB_EXT_LIFETIME_CURRENT;
	lt-&gt;sadb_lifetime_allocations = sav-&gt;lft_c-&gt;sadb_lifetime_allocations;
	lt-&gt;sadb_lifetime_bytes = sav-&gt;lft_c-&gt;sadb_lifetime_bytes;
	lt-&gt;sadb_lifetime_addtime = sav-&gt;lft_c-&gt;sadb_lifetime_addtime;
	lt-&gt;sadb_lifetime_usetime = sav-&gt;lft_c-&gt;sadb_lifetime_usetime;
	lt = (<span class="enscript-type">struct</span> sadb_lifetime *)(<span class="enscript-type">void</span> *)(mtod(m, caddr_t) + len / 2);
	bcopy(sav-&gt;lft_s, lt, <span class="enscript-keyword">sizeof</span>(*lt));
	m_cat(result, m);
	
	<span class="enscript-comment">/* set sadb_address for source */</span>
	m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src,
						FULLMASK, IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-comment">/* set sadb_address for destination */</span>
	m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
						(<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst,
						FULLMASK, IPSEC_ULPROTO_ANY);
	<span class="enscript-keyword">if</span> (!m) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(NULL, result, KEY_SENDUP_REGISTERED);
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_freem(result);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * SADB_FLUSH processing
 * receive
 *   &lt;base&gt;
 * from the ikmpd, and free all entries in secastree.
 * and send,
 *   &lt;base&gt;
 * to the ikmpd.
 * NOTE: to do is only marking SADB_SASTATE_DEAD.
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_flush</span>(
		  <span class="enscript-type">struct</span> socket *so,
		  <span class="enscript-type">struct</span> mbuf *m,
		  <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_msg *newmsg;
	<span class="enscript-type">struct</span> secashead *sah, *nextsah;
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
	u_int16_t proto;
	u_int8_t state;
	u_int stateidx;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_flush: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_flush: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	lck_mtx_lock(sadb_mutex);
	
	<span class="enscript-comment">/* no SATYPE specified, i.e. flushing all SA. */</span>
	<span class="enscript-keyword">for</span> (sah = LIST_FIRST(&amp;sahtree);
	     sah != NULL;
	     sah = nextsah) {
		nextsah = LIST_NEXT(sah, chain);
		
		<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_satype != SADB_SATYPE_UNSPEC
			&amp;&amp; proto != sah-&gt;saidx.proto)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">for</span> (stateidx = 0;
		     stateidx &lt; _ARRAYLEN(saorder_state_alive);
		     stateidx++) {
			state = saorder_state_any[stateidx];
			<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[state]);
			     sav != NULL;
			     sav = nextsav) {
				
				nextsav = LIST_NEXT(sav, chain);
				
				key_sa_chgstate(sav, SADB_SASTATE_DEAD);
				key_freesav(sav, KEY_SADB_LOCKED);
			}
		}
		
		sah-&gt;state = SADB_SASTATE_DEAD;
	}
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg) ||
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg) &gt; m-&gt;m_len + M_TRAILINGSPACE(m)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_flush: No more memory.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, ENOBUFS);
	}
	
	<span class="enscript-keyword">if</span> (m-&gt;m_next)
		m_freem(m-&gt;m_next);
	m-&gt;m_next = NULL;
	m-&gt;m_pkthdr.len = m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg);
	newmsg = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	newmsg-&gt;sadb_msg_errno = 0;
	newmsg-&gt;sadb_msg_len = PFKEY_UNIT64(m-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ALL);
}

<span class="enscript-comment">/*
 * SADB_DUMP processing
 * dump all entries including status of DEAD in SAD.
 * receive
 *   &lt;base&gt;
 * from the ikmpd, and dump all secasvar leaves
 * and send,
 *   &lt;base&gt; .....
 * to the ikmpd.
 *
 * m will always be freed.
 */</span>

<span class="enscript-type">struct</span> sav_dump_elem {
	<span class="enscript-type">struct</span> secasvar *sav;
	u_int8_t satype;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_dump</span>(
		 <span class="enscript-type">struct</span> socket *so,
		 <span class="enscript-type">struct</span> mbuf *m,
		 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">struct</span> sav_dump_elem *savbuf = NULL, *elem_ptr;
	u_int16_t proto;
	u_int stateidx;
	u_int8_t satype;
	u_int8_t state;
	<span class="enscript-type">int</span> cnt = 0, cnt2, bufcount;
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">int</span> error = 0;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_dump: NULL pointer is passed.\n&quot;</span>);
	
	<span class="enscript-comment">/* map satype to proto */</span>
	<span class="enscript-keyword">if</span> ((proto = key_satype2proto(mhp-&gt;msg-&gt;sadb_msg_satype)) == 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_dump: invalid satype is passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	<span class="enscript-keyword">if</span> ((bufcount = ipsec_sav_count) &lt;= 0) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bufcount += 512;	<span class="enscript-comment">/* extra */</span>
	KMALLOC_WAIT(savbuf, <span class="enscript-type">struct</span> sav_dump_elem*, bufcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sav_dump_elem));
	<span class="enscript-keyword">if</span> (savbuf == NULL) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_dump: No more memory.\n&quot;</span>));
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	
	<span class="enscript-comment">/* count sav entries to be sent to the userland. */</span>
	lck_mtx_lock(sadb_mutex);
	elem_ptr = savbuf;
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (mhp-&gt;msg-&gt;sadb_msg_satype != SADB_SATYPE_UNSPEC
			&amp;&amp; proto != sah-&gt;saidx.proto)
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* map proto to satype */</span>
		<span class="enscript-keyword">if</span> ((satype = key_proto2satype(sah-&gt;saidx.proto)) == 0) {
			lck_mtx_unlock(sadb_mutex);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_dump: there was invalid proto in SAD.\n&quot;</span>));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		}
		
		<span class="enscript-keyword">for</span> (stateidx = 0;
		     stateidx &lt; _ARRAYLEN(saorder_state_any);
		     stateidx++) {
			state = saorder_state_any[stateidx];
			LIST_FOREACH(sav, &amp;sah-&gt;savtree[state], chain) {
				<span class="enscript-keyword">if</span> (cnt == bufcount)
					<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* out of buffer space */</span>
				elem_ptr-&gt;sav = sav;
				elem_ptr-&gt;satype = satype;
				sav-&gt;refcnt++;
				elem_ptr++;
				cnt++;
			}
		}
	}
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">if</span> (cnt == 0) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	
	<span class="enscript-comment">/* send this to the userland, one at a time. */</span>
	elem_ptr = savbuf;
	cnt2 = cnt;
	<span class="enscript-keyword">while</span> (cnt2) {
		n = key_setdumpsa(elem_ptr-&gt;sav, SADB_DUMP, elem_ptr-&gt;satype,
						  --cnt2, mhp-&gt;msg-&gt;sadb_msg_pid);
		
		<span class="enscript-keyword">if</span> (!n) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		}
		
		key_sendup_mbuf(so, n, KEY_SENDUP_ONE);
		elem_ptr++;
	}
	
<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (savbuf) {
		<span class="enscript-keyword">if</span> (cnt) {
			elem_ptr = savbuf;
			lck_mtx_lock(sadb_mutex);
			<span class="enscript-keyword">while</span> (cnt--)
				key_freesav((elem_ptr++)-&gt;sav, KEY_SADB_LOCKED);
			lck_mtx_unlock(sadb_mutex);
		}
		KFREE(savbuf);
	}
	
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	
	m_freem(m);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * SADB_X_PROMISC processing
 *
 * m will always be freed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_promisc</span>(
			<span class="enscript-type">struct</span> socket *so,
			<span class="enscript-type">struct</span> mbuf *m,
			<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">int</span> olen;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;key_promisc: NULL pointer is passed.\n&quot;</span>);
	
	olen = PFKEY_UNUNIT64(mhp-&gt;msg-&gt;sadb_msg_len);
	
	<span class="enscript-keyword">if</span> (olen &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
#<span class="enscript-reference">if</span> 1
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
#<span class="enscript-reference">else</span>
		m_freem(m);
		<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (olen == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		<span class="enscript-comment">/* enable/disable promisc mode */</span>
		<span class="enscript-type">struct</span> keycb *kp;
		
		socket_lock(so, 1);
		<span class="enscript-keyword">if</span> ((kp = (<span class="enscript-type">struct</span> keycb *)sotorawcb(so)) == NULL)
			<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		mhp-&gt;msg-&gt;sadb_msg_errno = 0;
		<span class="enscript-keyword">switch</span> (mhp-&gt;msg-&gt;sadb_msg_satype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
				kp-&gt;kp_promisc = mhp-&gt;msg-&gt;sadb_msg_satype;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				socket_unlock(so, 1);
				<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
		}
		socket_unlock(so, 1);
		
		<span class="enscript-comment">/* send the original message back to everyone */</span>
		mhp-&gt;msg-&gt;sadb_msg_errno = 0;
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ALL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* send packet as is */</span>
		
		m_adj(m, PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)));
		
		<span class="enscript-comment">/* TODO: if sadb_msg_seq is specified, send to specific pid */</span>
		<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ALL);
	}
}

<span class="enscript-type">static</span> <span class="enscript-function-name">int</span> (*key_typesw[])(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> mbuf *,
						   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *) = {
	NULL,		<span class="enscript-comment">/* SADB_RESERVED */</span>
	key_getspi,	<span class="enscript-comment">/* SADB_GETSPI */</span>
	key_update,	<span class="enscript-comment">/* SADB_UPDATE */</span>
	key_add,	<span class="enscript-comment">/* SADB_ADD */</span>
	key_delete,	<span class="enscript-comment">/* SADB_DELETE */</span>
	key_get,	<span class="enscript-comment">/* SADB_GET */</span>
	key_acquire2,	<span class="enscript-comment">/* SADB_ACQUIRE */</span>
	key_register,	<span class="enscript-comment">/* SADB_REGISTER */</span>
	NULL,		<span class="enscript-comment">/* SADB_EXPIRE */</span>
	key_flush,	<span class="enscript-comment">/* SADB_FLUSH */</span>
	key_dump,	<span class="enscript-comment">/* SADB_DUMP */</span>
	key_promisc,	<span class="enscript-comment">/* SADB_X_PROMISC */</span>
	NULL,		<span class="enscript-comment">/* SADB_X_PCHANGE */</span>
	key_spdadd,	<span class="enscript-comment">/* SADB_X_SPDUPDATE */</span>
	key_spdadd,	<span class="enscript-comment">/* SADB_X_SPDADD */</span>
	key_spddelete,	<span class="enscript-comment">/* SADB_X_SPDDELETE */</span>
	key_spdget,	<span class="enscript-comment">/* SADB_X_SPDGET */</span>
	NULL,		<span class="enscript-comment">/* SADB_X_SPDACQUIRE */</span>
	key_spddump,	<span class="enscript-comment">/* SADB_X_SPDDUMP */</span>
	key_spdflush,	<span class="enscript-comment">/* SADB_X_SPDFLUSH */</span>
	key_spdadd,	<span class="enscript-comment">/* SADB_X_SPDSETIDX */</span>
	NULL,		<span class="enscript-comment">/* SADB_X_SPDEXPIRE */</span>
	key_spddelete2,	<span class="enscript-comment">/* SADB_X_SPDDELETE2 */</span>
	key_getsastat,   <span class="enscript-comment">/* SADB_GETSASTAT */</span>
	key_spdenable,   <span class="enscript-comment">/* SADB_X_SPDENABLE */</span>
	key_spddisable,   <span class="enscript-comment">/* SADB_X_SPDDISABLE */</span>
	key_migrate,   <span class="enscript-comment">/* SADB_MIGRATE */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bzero_mbuf</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *mptr  = m;
	<span class="enscript-type">struct</span> sadb_msg *msg = NULL;
	<span class="enscript-type">int</span> offset = 0;

	<span class="enscript-keyword">if</span> (!mptr) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (mptr-&gt;m_len &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		msg = mtod(mptr, <span class="enscript-type">struct</span> sadb_msg *);
		<span class="enscript-keyword">if</span> (msg-&gt;sadb_msg_type != SADB_ADD &amp;&amp;
		    msg-&gt;sadb_msg_type != SADB_UPDATE) {
			<span class="enscript-keyword">return</span>;
		}
		offset = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg);
	}
	bzero(mptr-&gt;m_data+offset, mptr-&gt;m_len-offset);
	mptr = mptr-&gt;m_next;
	<span class="enscript-keyword">while</span> (mptr != NULL) {
		bzero(mptr-&gt;m_data, mptr-&gt;m_len);
		mptr = mptr-&gt;m_next;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bzero_keys</span>(<span class="enscript-type">struct</span> sadb_msghdr *mh)
{
	<span class="enscript-type">int</span> extlen = 0;
	<span class="enscript-type">int</span> offset = 0;

	<span class="enscript-keyword">if</span> (!mh) {
		<span class="enscript-keyword">return</span>;
	}
	offset = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_key);

	<span class="enscript-keyword">if</span> (mh-&gt;ext[SADB_EXT_KEY_ENCRYPT]) {
		<span class="enscript-type">struct</span> sadb_key *key = (<span class="enscript-type">struct</span> sadb_key*)mh-&gt;ext[SADB_EXT_KEY_ENCRYPT];
		extlen = key-&gt;sadb_key_bits &gt;&gt; 3;

		<span class="enscript-keyword">if</span> (mh-&gt;extlen[SADB_EXT_KEY_ENCRYPT] &gt;= offset + extlen) {
			bzero((uint8_t *)mh-&gt;ext[SADB_EXT_KEY_ENCRYPT]+offset, extlen);
		} <span class="enscript-keyword">else</span> {
			bzero(mh-&gt;ext[SADB_EXT_KEY_ENCRYPT], mh-&gt;extlen[SADB_EXT_KEY_ENCRYPT]);
		}
	}
	<span class="enscript-keyword">if</span> (mh-&gt;ext[SADB_EXT_KEY_AUTH]) {
		<span class="enscript-type">struct</span> sadb_key *key = (<span class="enscript-type">struct</span> sadb_key*)mh-&gt;ext[SADB_EXT_KEY_AUTH];
		extlen = key-&gt;sadb_key_bits &gt;&gt; 3;

		<span class="enscript-keyword">if</span> (mh-&gt;extlen[SADB_EXT_KEY_AUTH] &gt;= offset + extlen) {
			bzero((uint8_t *)mh-&gt;ext[SADB_EXT_KEY_AUTH]+offset, extlen);
		} <span class="enscript-keyword">else</span> {
			bzero(mh-&gt;ext[SADB_EXT_KEY_AUTH], mh-&gt;extlen[SADB_EXT_KEY_AUTH]);
		}
	}
}

<span class="enscript-comment">/*
 * parse sadb_msg buffer to process PFKEYv2,
 * and create a data to response if needed.
 * I think to be dealed with mbuf directly.
 * IN:
 *     msgp  : pointer to pointer to a received buffer pulluped.
 *             This is rewrited to response.
 *     so    : pointer to socket.
 * OUT:
 *    length for buffer to send to user process.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_parse</span>(
		  <span class="enscript-type">struct</span> mbuf *m,
		  <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> sadb_msg *msg;
	<span class="enscript-type">struct</span> sadb_msghdr mh;
	u_int orglen;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> target;
	Boolean keyAligned = FALSE;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || so == NULL)
		panic(<span class="enscript-string">&quot;key_parse: NULL pointer is passed.\n&quot;</span>);
	
#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/*kdebug_sadb assumes msg in linear buffer*/</span>
	KEYDEBUG(KEYDEBUG_KEY_DUMP,
			 ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: passed sadb_msg\n&quot;</span>));
			 kdebug_sadb(msg));
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> ENOBUFS;
	}
	msg = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	orglen = PFKEY_UNUNIT64(msg-&gt;sadb_msg_len);
	target = KEY_SENDUP_ONE;
	
	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PKTHDR) == 0 ||
	    m-&gt;m_pkthdr.len != m-&gt;m_pkthdr.len) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: invalid message length.\n&quot;</span>));
		PFKEY_STAT_INCREMENT(pfkeystat.out_invlen);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
	}
	
	<span class="enscript-keyword">if</span> (msg-&gt;sadb_msg_version != PF_KEY_V2) {
		ipseclog((LOG_DEBUG,
				  <span class="enscript-string">&quot;key_parse: PF_KEY version %u is mismatched.\n&quot;</span>,
				  msg-&gt;sadb_msg_version));
		PFKEY_STAT_INCREMENT(pfkeystat.out_invver);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
	}
	
	<span class="enscript-keyword">if</span> (msg-&gt;sadb_msg_type &gt; SADB_MAX) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: invalid type %u is passed.\n&quot;</span>,
				  msg-&gt;sadb_msg_type));
		PFKEY_STAT_INCREMENT(pfkeystat.out_invmsgtype);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
	}
	
	<span class="enscript-comment">/* for old-fashioned code - should be nuked */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; MCLBYTES) {
		m_freem(m);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_next) {
		<span class="enscript-type">struct</span> mbuf *n;
		
		MGETHDR(n, M_WAITOK, MT_DATA);
		<span class="enscript-keyword">if</span> (n &amp;&amp; m-&gt;m_pkthdr.len &gt; MHLEN) {
			MCLGET(n, M_WAITOK);
			<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
				m_free(n);
				n = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!n) {
			bzero_mbuf(m);
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		m_copydata(m, 0, m-&gt;m_pkthdr.len, mtod(n, caddr_t));
		n-&gt;m_pkthdr.len = n-&gt;m_len = m-&gt;m_pkthdr.len;
		n-&gt;m_next = NULL;
		bzero_mbuf(m);
		m_freem(m);
		m = n;
	}
	
	<span class="enscript-comment">/* align the mbuf chain so that extensions are in contiguous region. */</span>
	error = key_align(m, &amp;mh);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	
	<span class="enscript-keyword">if</span> (m-&gt;m_next) {	<span class="enscript-comment">/*XXX*/</span>
		bzero_mbuf(m);
		m_freem(m);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	
	keyAligned = TRUE;
	msg = mh.msg;
	
	<span class="enscript-comment">/* check SA type */</span>
	<span class="enscript-keyword">switch</span> (msg-&gt;sadb_msg_satype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_UNSPEC</span>:
			<span class="enscript-keyword">switch</span> (msg-&gt;sadb_msg_type) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_GETSPI</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_UPDATE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_ADD</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_DELETE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_GET</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_ACQUIRE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXPIRE</span>:
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: must specify satype &quot;</span>
							  <span class="enscript-string">&quot;when msg type=%u.\n&quot;</span>, msg-&gt;sadb_msg_type));
					PFKEY_STAT_INCREMENT(pfkeystat.out_invsatype);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_AH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_ESP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SATYPE_IPCOMP</span>:
			<span class="enscript-keyword">switch</span> (msg-&gt;sadb_msg_type) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDADD</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDDELETE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDGET</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDDUMP</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDFLUSH</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDSETIDX</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDUPDATE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDDELETE2</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDENABLE</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_SPDDISABLE</span>:
					ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: illegal satype=%u\n&quot;</span>,
							  msg-&gt;sadb_msg_type));
					PFKEY_STAT_INCREMENT(pfkeystat.out_invsatype);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_RSVP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_OSPFV2</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_RIPV2</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_SATYPE_MIP</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: type %u isn't supported.\n&quot;</span>,
					  msg-&gt;sadb_msg_satype));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invsatype);
			error = EOPNOTSUPP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:	<span class="enscript-comment">/* XXX: What does it do? */</span>
			<span class="enscript-keyword">if</span> (msg-&gt;sadb_msg_type == SADB_X_PROMISC)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: invalid type %u is passed.\n&quot;</span>,
					  msg-&gt;sadb_msg_satype));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invsatype);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
	}
	
	<span class="enscript-comment">/* check field of upper layer protocol and address family */</span>
	<span class="enscript-keyword">if</span> (mh.ext[SADB_EXT_ADDRESS_SRC] != NULL
		&amp;&amp; mh.ext[SADB_EXT_ADDRESS_DST] != NULL) {
		<span class="enscript-type">struct</span> sadb_address *src0, *dst0;
		u_int plen;
		
		src0 = (<span class="enscript-type">struct</span> sadb_address *)(mh.ext[SADB_EXT_ADDRESS_SRC]);
		dst0 = (<span class="enscript-type">struct</span> sadb_address *)(mh.ext[SADB_EXT_ADDRESS_DST]);
		
		<span class="enscript-comment">/* check upper layer protocol */</span>
		<span class="enscript-keyword">if</span> (src0-&gt;sadb_address_proto != dst0-&gt;sadb_address_proto) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: upper layer protocol mismatched.\n&quot;</span>));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		}
		
		<span class="enscript-comment">/* check family */</span>
		<span class="enscript-keyword">if</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_family !=
		    PFKEY_ADDR_SADDR(dst0)-&gt;sa_family) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;key_parse: address family mismatched.\n&quot;</span>));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		}
		<span class="enscript-keyword">if</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_len !=
		    PFKEY_ADDR_SADDR(dst0)-&gt;sa_len) {
			ipseclog((LOG_DEBUG,
					  <span class="enscript-string">&quot;key_parse: address struct size mismatched.\n&quot;</span>));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		}
		
		<span class="enscript-keyword">switch</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				<span class="enscript-keyword">if</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_len !=
					<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in)) {
					PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				<span class="enscript-keyword">if</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_len !=
					<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6)) {
					PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				ipseclog((LOG_DEBUG,
						  <span class="enscript-string">&quot;key_parse: unsupported address family.\n&quot;</span>));
				PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
				error = EAFNOSUPPORT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		}
		
		<span class="enscript-keyword">switch</span> (PFKEY_ADDR_SADDR(src0)-&gt;sa_family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				plen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) &lt;&lt; 3;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				plen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) &lt;&lt; 3;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				plen = 0;	<span class="enscript-comment">/*fool gcc*/</span>
				<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* check max prefix length */</span>
		<span class="enscript-keyword">if</span> (src0-&gt;sadb_address_prefixlen &gt; plen ||
		    dst0-&gt;sadb_address_prefixlen &gt; plen) {
			ipseclog((LOG_DEBUG,
					  <span class="enscript-string">&quot;key_parse: illegal prefixlen.\n&quot;</span>));
			PFKEY_STAT_INCREMENT(pfkeystat.out_invaddr);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
		}
		
		<span class="enscript-comment">/*
		 * prefixlen == 0 is valid because there can be a case when
		 * all addresses are matched.
		 */</span>
	}
	
	<span class="enscript-keyword">if</span> (msg-&gt;sadb_msg_type &gt;= <span class="enscript-keyword">sizeof</span>(key_typesw)/<span class="enscript-keyword">sizeof</span>(key_typesw[0]) ||
	    key_typesw[msg-&gt;sadb_msg_type] == NULL) {
		PFKEY_STAT_INCREMENT(pfkeystat.out_invmsgtype);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderror</span>;
	}
	
	error = (*key_typesw[msg-&gt;sadb_msg_type])(so, m, &amp;mh);

	<span class="enscript-comment">// mh.ext points to the mbuf content.
</span>	<span class="enscript-comment">// Zero out Encryption and Integrity keys if present.
</span>	bzero_keys(&amp;mh);
	
	<span class="enscript-keyword">return</span> error;

<span class="enscript-reference">senderror</span>:
	<span class="enscript-keyword">if</span> (keyAligned) {
		bzero_keys(&amp;mh);
	} <span class="enscript-keyword">else</span> {
		bzero_mbuf(m);
	}
	msg-&gt;sadb_msg_errno = error;
	<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, target);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_senderror</span>(
			  <span class="enscript-type">struct</span> socket *so,
			  <span class="enscript-type">struct</span> mbuf *m,
			  <span class="enscript-type">int</span> code)
{
	<span class="enscript-type">struct</span> sadb_msg *msg;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg))
		panic(<span class="enscript-string">&quot;invalid mbuf passed to key_senderror&quot;</span>);
	
	msg = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	msg-&gt;sadb_msg_errno = code;
	<span class="enscript-keyword">return</span> key_sendup_mbuf(so, m, KEY_SENDUP_ONE);
}

<span class="enscript-comment">/*
 * set the pointer to each header into message buffer.
 * m will be freed on error.
 * XXX larger-than-MCLBYTES extension?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_align</span>(
		  <span class="enscript-type">struct</span> mbuf *m,
		  <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">struct</span> sadb_ext *ext;
	size_t off, end;
	<span class="enscript-type">int</span> extlen;
	<span class="enscript-type">int</span> toff;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || mhp == NULL)
		panic(<span class="enscript-string">&quot;key_align: NULL pointer is passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg))
		panic(<span class="enscript-string">&quot;invalid mbuf passed to key_align&quot;</span>);
	
	<span class="enscript-comment">/* initialize */</span>
	bzero(mhp, <span class="enscript-keyword">sizeof</span>(*mhp));
	
	mhp-&gt;msg = mtod(m, <span class="enscript-type">struct</span> sadb_msg *);
	mhp-&gt;ext[0] = (<span class="enscript-type">struct</span> sadb_ext *)mhp-&gt;msg;	<span class="enscript-comment">/*XXX backward compat */</span>
	
	end = PFKEY_UNUNIT64(mhp-&gt;msg-&gt;sadb_msg_len);
	extlen = end;	<span class="enscript-comment">/*just in case extlen is not updated*/</span>
	<span class="enscript-keyword">for</span> (off = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg); off &lt; end; off += extlen) {
		n = m_pulldown(m, off, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ext), &amp;toff);
		<span class="enscript-keyword">if</span> (!n) {
			<span class="enscript-comment">/* m is already freed */</span>
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		ext = (<span class="enscript-type">struct</span> sadb_ext *)(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + toff);
		
		<span class="enscript-comment">/* set pointer */</span>
		<span class="enscript-keyword">switch</span> (ext-&gt;sadb_ext_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SA</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_SRC</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_DST</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_PROXY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_CURRENT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_HARD</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_LIFETIME_SOFT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_KEY_AUTH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_KEY_ENCRYPT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_SRC</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_DST</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SENSITIVITY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_PROPOSAL</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SUPPORTED_AUTH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SUPPORTED_ENCRYPT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SPIRANGE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_POLICY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_SA2</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SESSION_ID</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_SASTAT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_IPSECIF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_SRC_START</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_SRC_END</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_DST_START</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_DST_END</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_MIGRATE_ADDRESS_SRC</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_MIGRATE_ADDRESS_DST</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_MIGRATE_IPSECIF</span>:
				<span class="enscript-comment">/* duplicate check */</span>
				<span class="enscript-comment">/*
				 * XXX Are there duplication payloads of either
				 * KEY_AUTH or KEY_ENCRYPT ?
				 */</span>
				<span class="enscript-keyword">if</span> (mhp-&gt;ext[ext-&gt;sadb_ext_type] != NULL) {
					ipseclog((LOG_DEBUG,
							  <span class="enscript-string">&quot;key_align: duplicate ext_type %u &quot;</span>
							  <span class="enscript-string">&quot;is passed.\n&quot;</span>, ext-&gt;sadb_ext_type));
					bzero_mbuf(m);
					m_freem(m);
					PFKEY_STAT_INCREMENT(pfkeystat.out_dupext);
					<span class="enscript-keyword">return</span> EINVAL;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				ipseclog((LOG_DEBUG,
						  <span class="enscript-string">&quot;key_align: invalid ext_type %u is passed.\n&quot;</span>,
						  ext-&gt;sadb_ext_type));
				bzero_mbuf(m);
				m_freem(m);
				PFKEY_STAT_INCREMENT(pfkeystat.out_invexttype);
				<span class="enscript-keyword">return</span> EINVAL;
		}
		
		extlen = PFKEY_UNUNIT64(ext-&gt;sadb_ext_len);
		
		<span class="enscript-keyword">if</span> (key_validate_ext(ext, extlen)) {
			bzero_mbuf(m);
			m_freem(m);
			PFKEY_STAT_INCREMENT(pfkeystat.out_invlen);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		n = m_pulldown(m, off, extlen, &amp;toff);
		<span class="enscript-keyword">if</span> (!n) {
			<span class="enscript-comment">/* m is already freed */</span>
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		ext = (<span class="enscript-type">struct</span> sadb_ext *)(<span class="enscript-type">void</span> *)(mtod(n, caddr_t) + toff);
		
		mhp-&gt;ext[ext-&gt;sadb_ext_type] = ext;
		mhp-&gt;extoff[ext-&gt;sadb_ext_type] = off;
		mhp-&gt;extlen[ext-&gt;sadb_ext_type] = extlen;
	}
	
	<span class="enscript-keyword">if</span> (off != end) {
		bzero_mbuf(m);
		m_freem(m);
		PFKEY_STAT_INCREMENT(pfkeystat.out_invlen);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_validate_ext</span>(
				 <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_ext *ext,
				 <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">struct</span> sockaddr *sa;
	<span class="enscript-type">enum</span> { NONE, ADDR } checktype = NONE;
	<span class="enscript-type">int</span> baselen;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> sal = offsetof(<span class="enscript-type">struct</span> sockaddr, sa_len) + <span class="enscript-keyword">sizeof</span>(sa-&gt;sa_len);
	
	<span class="enscript-keyword">if</span> (len != PFKEY_UNUNIT64(ext-&gt;sadb_ext_len))
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-comment">/* if it does not match minimum/maximum length, bail */</span>
	<span class="enscript-keyword">if</span> (ext-&gt;sadb_ext_type &gt;= <span class="enscript-keyword">sizeof</span>(minsize) / <span class="enscript-keyword">sizeof</span>(minsize[0]) ||
	    ext-&gt;sadb_ext_type &gt;= <span class="enscript-keyword">sizeof</span>(maxsize) / <span class="enscript-keyword">sizeof</span>(maxsize[0]))
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (!minsize[ext-&gt;sadb_ext_type] || len &lt; minsize[ext-&gt;sadb_ext_type])
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (maxsize[ext-&gt;sadb_ext_type] &amp;&amp; len &gt; maxsize[ext-&gt;sadb_ext_type])
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-comment">/* more checks based on sadb_ext_type XXX need more */</span>
	<span class="enscript-keyword">switch</span> (ext-&gt;sadb_ext_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_SRC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_DST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_ADDRESS_PROXY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_SRC_START</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_SRC_END</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_DST_START</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_ADDR_RANGE_DST_END</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_MIGRATE_ADDRESS_SRC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_MIGRATE_ADDRESS_DST</span>:
			baselen = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_address));
			checktype = ADDR;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_SRC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EXT_IDENTITY_DST</span>:
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sadb_ident *)(uintptr_t)(size_t)ext)-&gt;
				sadb_ident_type == SADB_X_IDENTTYPE_ADDR) {
				baselen = PFKEY_ALIGN8(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_ident));
				checktype = ADDR;
			} <span class="enscript-keyword">else</span>
				checktype = NONE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			checktype = NONE;
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">switch</span> (checktype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NONE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ADDR</span>:
			sa = (<span class="enscript-type">struct</span> sockaddr *)((caddr_t)(uintptr_t)ext + baselen);
			
			<span class="enscript-keyword">if</span> (len &lt; baselen + sal)
				<span class="enscript-keyword">return</span> EINVAL;
			<span class="enscript-keyword">if</span> (baselen + PFKEY_ALIGN8(sa-&gt;sa_len) != len)
				<span class="enscript-keyword">return</span> EINVAL;
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * XXX: maybe This function is called after INBOUND IPsec processing.
 *
 * Special check for tunnel-mode packets.
 * We must make some checks for consistency between inner and outer IP header.
 *
 * xxx more checks to be provided
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">key_checktunnelsanity</span>(
					  <span class="enscript-type">struct</span> secasvar *sav,
					  __unused u_int family,
					  __unused caddr_t src,
					  __unused caddr_t dst)
{
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;sah == NULL)
		panic(<span class="enscript-string">&quot;sav-&gt;sah == NULL at key_checktunnelsanity&quot;</span>);
	
	<span class="enscript-comment">/* XXX: check inner IP header */</span>
	
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/* record data transfer on SA, and update timestamps */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_sa_recordxfer</span>(
				  <span class="enscript-type">struct</span> secasvar *sav,
				  <span class="enscript-type">struct</span> mbuf *m)
{
	
	
	<span class="enscript-keyword">if</span> (!sav)
		panic(<span class="enscript-string">&quot;key_sa_recordxfer called with sav == NULL&quot;</span>);
	<span class="enscript-keyword">if</span> (!m)
		panic(<span class="enscript-string">&quot;key_sa_recordxfer called with m == NULL&quot;</span>);
	<span class="enscript-keyword">if</span> (!sav-&gt;lft_c)
		<span class="enscript-keyword">return</span>;
	
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/*
	 * XXX Currently, there is a difference of bytes size
	 * between inbound and outbound processing.
	 */</span>
	sav-&gt;lft_c-&gt;sadb_lifetime_bytes += m-&gt;m_pkthdr.len;
	<span class="enscript-comment">/* to check bytes lifetime is done in key_timehandler(). */</span>
	
	<span class="enscript-comment">/*
	 * We use the number of packets as the unit of
	 * sadb_lifetime_allocations.  We increment the variable
	 * whenever {esp,ah}_{in,out}put is called.
	 */</span>
	sav-&gt;lft_c-&gt;sadb_lifetime_allocations++;
	<span class="enscript-comment">/* XXX check for expires? */</span>
	
	<span class="enscript-comment">/*
	 * NOTE: We record CURRENT sadb_lifetime_usetime by using wall clock,
	 * in seconds.  HARD and SOFT lifetime are measured by the time
	 * difference (again in seconds) from sadb_lifetime_usetime.
	 *
	 *	usetime
	 *	v     expire   expire
	 * -----+-----+--------+---&gt; t
	 *	&lt;--------------&gt; HARD
	 *	&lt;-----&gt; SOFT
	 */</span>
    {
		<span class="enscript-type">struct</span> timeval tv;
		microtime(&amp;tv);
		sav-&gt;lft_c-&gt;sadb_lifetime_usetime = tv.tv_sec;
		<span class="enscript-comment">/* XXX check for expires? */</span>
    }
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* dumb version */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">key_sa_routechange</span>(
				   <span class="enscript-type">struct</span> sockaddr *dst)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> route *ro;
	
	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		ro = &amp;sah-&gt;sa_route;
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt &amp;&amp; dst-&gt;sa_len == ro-&gt;ro_dst.sa_len
			&amp;&amp; bcmp(dst, &amp;ro-&gt;ro_dst, dst-&gt;sa_len) == 0) {
			ROUTE_RELEASE(ro);
		}
	}
	lck_mtx_unlock(sadb_mutex);
	
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">key_sa_chgstate</span>(
				<span class="enscript-type">struct</span> secasvar *sav,
				u_int8_t state)
{
	
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;key_sa_chgstate called with sav == NULL&quot;</span>);
	
	<span class="enscript-keyword">if</span> (sav-&gt;state == state)
		<span class="enscript-keyword">return</span>;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	
	<span class="enscript-keyword">if</span> (__LIST_CHAINED(sav))
		LIST_REMOVE(sav, chain);
	
	sav-&gt;state = state;
	LIST_INSERT_HEAD(&amp;sav-&gt;sah-&gt;savtree[state], sav, chain);
	
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">key_sa_stir_iv</span>(
			   <span class="enscript-type">struct</span> secasvar *sav)
{
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (!sav-&gt;iv)
		panic(<span class="enscript-string">&quot;key_sa_stir_iv called with sav == NULL&quot;</span>);
	key_randomfill(sav-&gt;iv, sav-&gt;ivlen);
	lck_mtx_unlock(sadb_mutex);
}

<span class="enscript-comment">/* XXX too much? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_alloc_mbuf</span>(
			   <span class="enscript-type">int</span> l)
{
	<span class="enscript-type">struct</span> mbuf *m = NULL, *n;
	<span class="enscript-type">int</span> len, t;
	
	len = l;
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (n &amp;&amp; len &gt; MLEN)
			MCLGET(n, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> NULL;
		}
		
		n-&gt;m_next = NULL;
		n-&gt;m_len = 0;
		n-&gt;m_len = M_TRAILINGSPACE(n);
		<span class="enscript-comment">/* use the bottom of mbuf, hoping we can prepend afterwards */</span>
		<span class="enscript-keyword">if</span> (n-&gt;m_len &gt; len) {
			t = (n-&gt;m_len - len) &amp; ~(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">long</span>) - 1);
			n-&gt;m_data += t;
			n-&gt;m_len = len;
		}
		
		len -= n-&gt;m_len;
		
		<span class="enscript-keyword">if</span> (m)
			m_cat(m, n);
		<span class="enscript-keyword">else</span>
			m = n;
	}
	
	<span class="enscript-keyword">return</span> m;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">key_setdumpsastats</span> (u_int32_t      dir,
					<span class="enscript-type">struct</span> sastat *stats,
					u_int32_t      max_stats,
					u_int64_t      session_ids[],
					u_int32_t      seq,
					u_int32_t      pid)
{
	<span class="enscript-type">struct</span> mbuf *result = NULL, *m = NULL;
	
	m = key_setsadbmsg(SADB_GETSASTAT, 0, 0, seq, pid, 0);
	<span class="enscript-keyword">if</span> (!m) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	result = m;
	
	m = key_setsadbsession_id(session_ids);
	<span class="enscript-keyword">if</span> (!m) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	m = key_setsadbsastat(dir,
						  stats,
						  max_stats);
	<span class="enscript-keyword">if</span> (!m) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	m_cat(result, m);
	
	<span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	
	<span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
		result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
		<span class="enscript-keyword">if</span> (result == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next) {
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	}
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len =
	PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> result;
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result) {
		m_freem(result);
	}
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * SADB_GETSASTAT processing
 * dump all stats for matching entries in SAD.
 *
 * m will always be freed.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_getsastat</span> (<span class="enscript-type">struct</span> socket *so,
			   <span class="enscript-type">struct</span> mbuf *m,
			   <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sadb_msghdr *mhp)
{
	<span class="enscript-type">struct</span> sadb_session_id *session_id;
	u_int32_t               bufsize, arg_count, res_count;
	<span class="enscript-type">struct</span> sadb_sastat     *sa_stats_arg;
	<span class="enscript-type">struct</span> sastat          *sa_stats_sav = NULL;
	<span class="enscript-type">struct</span> mbuf            *n;
	<span class="enscript-type">int</span>                     error = 0;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (so == NULL || m == NULL || mhp == NULL || mhp-&gt;msg == NULL)
		panic(<span class="enscript-string">&quot;%s: NULL pointer is passed.\n&quot;</span>, __FUNCTION__);
	
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SESSION_ID] == NULL) {
		printf(<span class="enscript-string">&quot;%s: invalid message is passed. missing session-id.\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SESSION_ID] &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_session_id)) {
		printf(<span class="enscript-string">&quot;%s: invalid message is passed. short session-id.\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;ext[SADB_EXT_SASTAT] == NULL) {
		printf(<span class="enscript-string">&quot;%s: invalid message is passed. missing stat args.\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	<span class="enscript-keyword">if</span> (mhp-&gt;extlen[SADB_EXT_SASTAT] &lt; <span class="enscript-keyword">sizeof</span>(*sa_stats_arg)) {
		printf(<span class="enscript-string">&quot;%s: invalid message is passed. short stat args.\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span> key_senderror(so, m, EINVAL);
	}
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">// exit early if there are no active SAs
</span>	<span class="enscript-keyword">if</span> (ipsec_sav_count &lt;= 0) {
		printf(<span class="enscript-string">&quot;%s: No active SAs.\n&quot;</span>, __FUNCTION__);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bufsize = (ipsec_sav_count + 1) * <span class="enscript-keyword">sizeof</span>(*sa_stats_sav);
	
	KMALLOC_WAIT(sa_stats_sav, __typeof__(sa_stats_sav), bufsize);
	<span class="enscript-keyword">if</span> (sa_stats_sav == NULL) {
		printf(<span class="enscript-string">&quot;%s: No more memory.\n&quot;</span>, __FUNCTION__);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	bzero(sa_stats_sav, bufsize);
	
	sa_stats_arg = (__typeof__(sa_stats_arg))
	(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SASTAT];
	arg_count = sa_stats_arg-&gt;sadb_sastat_list_len;
	<span class="enscript-comment">// exit early if there are no requested SAs
</span>	<span class="enscript-keyword">if</span> (arg_count == 0) {
		printf(<span class="enscript-string">&quot;%s: No SAs requested.\n&quot;</span>, __FUNCTION__);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	res_count = 0;
	
	<span class="enscript-keyword">if</span> (key_getsastatbyspi((<span class="enscript-type">struct</span> sastat *)(sa_stats_arg + 1),
						   arg_count,
						   sa_stats_sav,
						   &amp;res_count)) {
		printf(<span class="enscript-string">&quot;%s: Error finding SAs.\n&quot;</span>, __FUNCTION__);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	<span class="enscript-keyword">if</span> (!res_count) {
		printf(<span class="enscript-string">&quot;%s: No SAs found.\n&quot;</span>, __FUNCTION__);
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	
	session_id = (__typeof__(session_id))
	(<span class="enscript-type">void</span> *)mhp-&gt;ext[SADB_EXT_SESSION_ID];
	
	<span class="enscript-comment">/* send this to the userland. */</span>
	n = key_setdumpsastats(sa_stats_arg-&gt;sadb_sastat_dir,
						   sa_stats_sav,
						   res_count,
						   session_id-&gt;sadb_session_id_v,
						   mhp-&gt;msg-&gt;sadb_msg_seq,
						   mhp-&gt;msg-&gt;sadb_msg_pid);
	<span class="enscript-keyword">if</span> (!n) {
		printf(<span class="enscript-string">&quot;%s: No bufs to dump stats.\n&quot;</span>, __FUNCTION__);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
	
	key_sendup_mbuf(so, n, KEY_SENDUP_ALL);
<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (sa_stats_sav) {
		KFREE(sa_stats_sav);
	}
	
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> key_senderror(so, m, error);
	
	m_freem(m);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">key_update_natt_keepalive_timestamp</span> (<span class="enscript-type">struct</span> secasvar *sav_sent,
									 <span class="enscript-type">struct</span> secasvar *sav_update)
{
	<span class="enscript-type">struct</span> secasindex saidx_swap_sent_addr;
	
	<span class="enscript-comment">// exit early if two SAs are identical, or if sav_update is current
</span>	<span class="enscript-keyword">if</span> (sav_sent == sav_update ||
	    sav_update-&gt;natt_last_activity == natt_now) {
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-comment">// assuming that (sav_update-&gt;remote_ike_port != 0 &amp;&amp; (esp_udp_encap_port &amp; 0xFFFF) != 0)
</span>	
	bzero(&amp;saidx_swap_sent_addr, <span class="enscript-keyword">sizeof</span>(saidx_swap_sent_addr));
	memcpy(&amp;saidx_swap_sent_addr.src, &amp;sav_sent-&gt;sah-&gt;saidx.dst, <span class="enscript-keyword">sizeof</span>(saidx_swap_sent_addr.src));
	memcpy(&amp;saidx_swap_sent_addr.dst, &amp;sav_sent-&gt;sah-&gt;saidx.src, <span class="enscript-keyword">sizeof</span>(saidx_swap_sent_addr.dst));
	saidx_swap_sent_addr.proto = sav_sent-&gt;sah-&gt;saidx.proto;
	saidx_swap_sent_addr.mode = sav_sent-&gt;sah-&gt;saidx.mode;
	<span class="enscript-comment">// we ignore reqid for split-tunnel setups
</span>	
	<span class="enscript-keyword">if</span> (key_cmpsaidx(&amp;sav_sent-&gt;sah-&gt;saidx, &amp;sav_update-&gt;sah-&gt;saidx, CMP_MODE | CMP_PORT) ||
	    key_cmpsaidx(&amp;saidx_swap_sent_addr, &amp;sav_update-&gt;sah-&gt;saidx, CMP_MODE | CMP_PORT)) {
		sav_update-&gt;natt_last_activity = natt_now;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">key_send_delsp</span> (<span class="enscript-type">struct</span> secpolicy *sp)
{
    <span class="enscript-type">struct</span> mbuf *result = NULL, *m;
    
    <span class="enscript-keyword">if</span> (sp == NULL)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    
    <span class="enscript-comment">/* set msg header */</span>
    m = key_setsadbmsg(SADB_X_SPDDELETE, 0, 0, 0, 0, 0);
    <span class="enscript-keyword">if</span> (!m) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }
    result = m;
    
    <span class="enscript-comment">/* set sadb_address(es) for source */</span>
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.src_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.start, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_SRC_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src_range.end, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_SRC,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.src, sp-&gt;spidx.prefs,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
    
    <span class="enscript-comment">/* set sadb_address(es) for destination */</span>
    <span class="enscript-keyword">if</span> (sp-&gt;spidx.dst_range.start.ss_len &gt; 0) {
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_START,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.start, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
        
        m = key_setsadbaddr(SADB_X_EXT_ADDR_RANGE_DST_END,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst_range.end, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    } <span class="enscript-keyword">else</span> {
        m = key_setsadbaddr(SADB_EXT_ADDRESS_DST,
                            (<span class="enscript-type">struct</span> sockaddr *)&amp;sp-&gt;spidx.dst, sp-&gt;spidx.prefd,
                            sp-&gt;spidx.ul_proto);
        <span class="enscript-keyword">if</span> (!m)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        m_cat(result, m);
    }
    
    <span class="enscript-comment">/* set secpolicy */</span>
    m = key_sp2msg(sp);
    <span class="enscript-keyword">if</span> (!m) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }
    m_cat(result, m);
    
    <span class="enscript-keyword">if</span> ((result-&gt;m_flags &amp; M_PKTHDR) == 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
    }
    
    <span class="enscript-keyword">if</span> (result-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg)) {
        result = m_pullup(result, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sadb_msg));
        <span class="enscript-keyword">if</span> (result == NULL) {
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
        }
	}
	
	result-&gt;m_pkthdr.len = 0;
	<span class="enscript-keyword">for</span> (m = result; m; m = m-&gt;m_next)
		result-&gt;m_pkthdr.len += m-&gt;m_len;
	
	mtod(result, <span class="enscript-type">struct</span> sadb_msg *)-&gt;sadb_msg_len = PFKEY_UNIT64(result-&gt;m_pkthdr.len);
	
	<span class="enscript-keyword">return</span> key_sendup_mbuf(NULL, result, KEY_SENDUP_REGISTERED);
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (result)
		m_free(result);
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">key_delsp_for_ipsec_if</span> (ifnet_t ipsec_if)
{
	<span class="enscript-type">struct</span> secashead *sah;
	<span class="enscript-type">struct</span> secasvar *sav, *nextsav;
	u_int stateidx;
	u_int state;
	<span class="enscript-type">struct</span> secpolicy *sp, *nextsp;
	<span class="enscript-type">int</span> dir;
    
	<span class="enscript-keyword">if</span> (ipsec_if == NULL)
        <span class="enscript-keyword">return</span>;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	lck_mtx_lock(sadb_mutex);
    
	<span class="enscript-keyword">for</span> (dir = 0; dir &lt; IPSEC_DIR_MAX; dir++) {
		<span class="enscript-keyword">for</span> (sp = LIST_FIRST(&amp;sptree[dir]);
			 sp != NULL;
			 sp = nextsp) {
			
			nextsp = LIST_NEXT(sp, chain);
			
			<span class="enscript-keyword">if</span> (sp-&gt;ipsec_if == ipsec_if) {
				ifnet_release(sp-&gt;ipsec_if);
				sp-&gt;ipsec_if = NULL;
				
				key_send_delsp(sp);
                
				sp-&gt;state = IPSEC_SPSTATE_DEAD;
				key_freesp(sp, KEY_SADB_LOCKED);   
			}
		}
	}
	
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		<span class="enscript-keyword">if</span> (sah-&gt;ipsec_if == ipsec_if) {
			<span class="enscript-comment">/* This SAH is linked to the IPSec interface. It now needs to close. */</span>
			ifnet_release(sah-&gt;ipsec_if);
			sah-&gt;ipsec_if = NULL;
			
			<span class="enscript-keyword">for</span> (stateidx = 0; stateidx &lt; _ARRAYLEN(saorder_state_alive); stateidx++) {
				state = saorder_state_any[stateidx];
				<span class="enscript-keyword">for</span> (sav = LIST_FIRST(&amp;sah-&gt;savtree[state]); sav != NULL; sav = nextsav) {
					nextsav = LIST_NEXT(sav, chain);
					
					key_sa_chgstate(sav, SADB_SASTATE_DEAD);
					key_freesav(sav, KEY_SADB_LOCKED);
				}
			}
			
			sah-&gt;state = SADB_SASTATE_DEAD;
		}
	}
	
	lck_mtx_unlock(sadb_mutex);
}

__private_extern__ u_int32_t
<span class="enscript-function-name">key_fill_offload_frames_for_savs</span> (ifnet_t ifp,
    <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frames_array,
    u_int32_t frames_array_count,
    size_t frame_data_offset)
{
	<span class="enscript-type">struct</span> secashead *sah = NULL;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	<span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frame = frames_array;
	u_int32_t frame_index = 0;

	<span class="enscript-keyword">if</span> (frame == NULL || frames_array_count == 0) {
		<span class="enscript-keyword">return</span> (frame_index);
	}

	lck_mtx_lock(sadb_mutex);
	LIST_FOREACH(sah, &amp;sahtree, chain) {
		LIST_FOREACH(sav, &amp;sah-&gt;savtree[SADB_SASTATE_MATURE], chain) {
			<span class="enscript-keyword">if</span> (ipsec_fill_offload_frame(ifp, sav, frame, frame_data_offset)) {
				frame_index++;
				<span class="enscript-keyword">if</span> (frame_index &gt;= frames_array_count) {
					lck_mtx_unlock(sadb_mutex);
					<span class="enscript-keyword">return</span> (frame_index);
				}
				frame = &amp;(frames_array[frame_index]);
			}
		}
	}
	lck_mtx_unlock(sadb_mutex);

	<span class="enscript-keyword">return</span> (frame_index);
}
</pre>
<hr />
</body></html>