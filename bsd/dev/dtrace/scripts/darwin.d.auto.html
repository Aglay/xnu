<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>darwin.d</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">darwin.d&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 * Copyright (c) 2005-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * &quot;License&quot;).  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * <a href="http://www.apple.com/publicsource">http://www.apple.com/publicsource</a> and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an &quot;AS IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

inline int UT_VFORK = 0x02000000;  /* thread has vfork children */
#pragma D binding &quot;1.0&quot; UT_VFORK

inline uthread_t uthread = (mach_kernel`uthread_t)(curthread-&gt;uthread); /* ` */
#pragma D binding &quot;1.0&quot; uthread

inline struct proc * curproc = 
	(uthread &amp;&amp; (uthread-&gt;uu_flag &amp; UT_VFORK) &amp;&amp; uthread-&gt;uu_proc) ? (struct proc *)uthread-&gt;uu_proc :
	((struct proc *)(curthread-&gt;task-&gt;bsd_info)) != NULL ? ((struct proc *)(curthread-&gt;task-&gt;bsd_info)) : 
	mach_kernel`kernproc; /* ` */
#pragma D binding &quot;1.0&quot; curproc

/*
 * curthread-&gt;thread_tag will have this set if the thread is the main thread
 */   
inline uint32_t THREAD_TAG_MAINTHREAD = 0x1;
inline uint32_t THREAD_TAG_CALLOUT = 0x2;
inline uint32_t THREAD_TAG_IOWORKLOOP = 0x4;

/*
 * mach thread scheduler state
 */
inline int TH_WAIT		= 0x01;
#pragma D binding &quot;1.0&quot; TH_WAIT
inline int TH_SUSP		= 0x02;
#pragma D binding &quot;1.0&quot; TH_SUSP
inline int TH_RUN		= 0x04;
#pragma D binding &quot;1.0&quot; TH_RUN
inline int TH_UNINT		= 0x08;
#pragma D binding &quot;1.0&quot; TH_UNINT
inline int TH_TERMINATE  	= 0x10;
#pragma D binding &quot;1.0&quot; TH_TERMINATE
inline int TH_TERMINATE2	= 0x20;
#pragma D binding &quot;1.0&quot; TH_TERMINATE2
inline int TH_IDLE		= 0x80;
#pragma D binding &quot;1.0&quot; TH_IDLE

/*
 * The following miscellaneous constants are used by the proc(4) translators
 * defined below.
 */
inline char SIDL = 1;
#pragma D binding &quot;1.0&quot; SIDL
inline char SRUN = 2;
#pragma D binding &quot;1.0&quot; SRUN
inline char SSLEEP = 3;
#pragma D binding &quot;1.0&quot; SSLEEP
inline char SSTOP = 4;
#pragma D binding &quot;1.0&quot; SSTOP
inline char SZOMB = 5;
#pragma D binding &quot;1.0&quot; SZOMB
/*
 * SONPROC defined here for compatability with ported scripts
 */
inline char SONPROC = 6;
#pragma D binding &quot;1.0&quot; SONPROC

inline char SOBJ_NONE = 0;
#pragma D binding &quot;1.0&quot; SOBJ_NONE
/*
 * SOBJ_* defined here for compatability with ported scripts
 */
inline char SOBJ_MUTEX = 1;
#pragma D binding &quot;1.0&quot; SOBJ_MUTEX
inline char SOBJ_RWLOCK = 2;
#pragma D binding &quot;1.0&quot; SOBJ_RWLOCK
inline char SOBJ_CV = 3;
#pragma D binding &quot;1.0&quot; SOBJ_CV
inline char SOBJ_SEMA = 4;
#pragma D binding &quot;1.0&quot; SOBJ_SEMA
inline char SOBJ_USER = 5;
#pragma D binding &quot;1.0&quot; SOBJ_USER
inline char SOBJ_USER_PI = 6;
#pragma D binding &quot;1.0&quot; SOBJ_USER_PI
inline char SOBJ_SHUTTLE = 7;
#pragma D binding &quot;1.0&quot; SOBJ_SHUTTLE

inline char PR_MODEL_ILP32 = 1;
#pragma D binding &quot;1.0&quot; PR_MODEL_ILP32
inline char PR_MODEL_LP64 = 2;
#pragma D binding &quot;1.0&quot; PR_MODEL_LP64

/*
 * PR_* defined here for compatability with ported scripts
 */
inline int PR_STOPPED = 0x00000001;
#pragma D binding &quot;1.0&quot; PR_STOPPED
inline int PR_ISTOP = 0x00000002;
#pragma D binding &quot;1.0&quot; PR_ISTOP
inline int PR_DSTOP = 0x00000004;
#pragma D binding &quot;1.0&quot; PR_DSTOP
inline int PR_STEP = 0x00000008;
#pragma D binding &quot;1.0&quot; PR_STEP
inline int PR_ASLEEP = 0x00000010;
#pragma D binding &quot;1.0&quot; PR_ASLEEP
inline int PR_PCINVAL = 0x00000020;
#pragma D binding &quot;1.0&quot; PR_PCINVAL
inline int PR_ASLWP = 0x00000040;
#pragma D binding &quot;1.0&quot; PR_ASLWP
inline int PR_AGENT = 0x00000080;
#pragma D binding &quot;1.0&quot; PR_AGENT
inline int PR_DETACH = 0x00000100;
#pragma D binding &quot;1.0&quot; PR_DETACH
inline int PR_DAEMON = 0x00000200;
#pragma D binding &quot;1.0&quot; PR_DAEMON
inline int PR_ISSYS = 0x00001000;
#pragma D binding &quot;1.0&quot; PR_ISSYS
inline int PR_VFORKP = 0x00002000;
#pragma D binding &quot;1.0&quot; PR_VFORKP
inline int PR_ORPHAN = 0x00004000;
#pragma D binding &quot;1.0&quot; PR_ORPHAN
inline int PR_FORK = 0x00100000;
#pragma D binding &quot;1.0&quot; PR_FORK
inline int PR_RLC = 0x00200000;
#pragma D binding &quot;1.0&quot; PR_RLC
inline int PR_KLC = 0x00400000;
#pragma D binding &quot;1.0&quot; PR_KLC
inline int PR_ASYNC = 0x00800000;
#pragma D binding &quot;1.0&quot; PR_ASYNC
inline int PR_MSACCT = 0x01000000;
#pragma D binding &quot;1.0&quot; PR_MSACCT
inline int PR_BPTADJ = 0x02000000;
#pragma D binding &quot;1.0&quot; PR_BPTADJ
inline int PR_PTRACE = 0x04000000;
#pragma D binding &quot;1.0&quot; PR_PTRACE
inline int PR_MSFORK = 0x08000000;
#pragma D binding &quot;1.0&quot; PR_MSFORK
inline int PR_IDLE = 0x10000000;
#pragma D binding &quot;1.0&quot; PR_IDLE

/*
 * Translate from the kernel's proc_t structure to a proc(4) psinfo_t struct.
 * We do not provide support for pr_size, pr_rssize, pr_pctcpu, and pr_pctmem.
 * We also do not fill in pr_lwp (the lwpsinfo_t for the representative LWP)
 * because we do not have the ability to select and stop any representative.
 * Also, for the moment, pr_wstat, pr_time, and pr_ctime are not supported,
 * but these could be supported by DTrace in the future using subroutines.
 * Note that any member added to this translator should also be added to the
 * kthread_t-to-psinfo_t translator, below.
 */
typedef int taskid_t;
typedef int projid_t;
typedef int poolid_t;
typedef struct timespec timestruc_t; /* (SECONDS, NANOSECONDS) */

typedef struct psinfo {
	int	pr_nlwp;	/* number of active lwps in the process */
	pid_t	pr_pid;		/* unique process id */
	pid_t	pr_ppid;	/* process id of parent */
	pid_t	pr_pgid;	/* pid of process group leader */
	pid_t	pr_sid;		/* session id */
	uid_t	pr_uid;		/* real user id */
	uid_t	pr_euid;	/* effective user id */
	gid_t	pr_gid;		/* real group id */
	gid_t	pr_egid;	/* effective group id */
	uintptr_t pr_addr;	/* address of process */
	dev_t	pr_ttydev;	/* controlling tty device (or PRNODEV) */
	timestruc_t pr_start;/* process start time, DEPRECATED, see pr_start_tv below */
	char pr_fname[16];	/* name of execed file */
	char pr_psargs[80];	/* initial characters of arg list */
	int pr_argc;    	/* initial argument count */
	user_addr_t pr_argv;  /* address of initial argument vector */
	user_addr_t pr_envp;  /* address of initial environment vector */
	char    pr_dmodel;  /* data model of the process */
	taskid_t pr_taskid; /* task id */
	projid_t pr_projid; /* project id */
	poolid_t pr_poolid; /* pool id */
	zoneid_t pr_zoneid; /* zone id */

	struct timeval pr_start_tv; /* process start time, from the epoch (SECONDS, MICROSECONDS) */
} psinfo_t;

inline int P_LP64 = 0x00000004;  /* Process is LP64 */
#pragma D binding &quot;1.0&quot; P_LP64

#pragma D binding &quot;1.0&quot; translator
translator psinfo_t &lt; struct proc * P &gt; {
	pr_nlwp = 	((struct task *)(P-&gt;task))-&gt;thread_count;
	pr_pid = 	P-&gt;p_pid;
	pr_ppid = 	P-&gt;p_ppid;
	pr_pgid = 	P-&gt;p_pgrp-&gt;pg_id;
	pr_sid = 	P-&gt;p_pgrp-&gt;pg_session-&gt;s_sid;
 	pr_uid = 	P-&gt;p_ucred-&gt;cr_posix.cr_ruid;
 	pr_euid = 	P-&gt;p_ucred-&gt;cr_posix.cr_uid;
 	pr_gid = 	P-&gt;p_ucred-&gt;cr_posix.cr_rgid;
 	pr_egid = 	P-&gt;p_ucred-&gt;cr_posix.cr_groups[0];
	pr_addr = 	(uintptr_t)P;

	pr_ttydev = (P-&gt;p_pgrp-&gt;pg_session-&gt;s_ttyvp == NULL) ? (dev_t)-1 :
		P-&gt;p_pgrp-&gt;pg_session-&gt;s_ttyp-&gt;t_dev;

	/*
	 * timestruct_t (SECONDS, NANOSECONDS) is not available directly nor can a further translation
	 * be specified here. Zero the structure. Use pr_start_tv instead.
	 */
	pr_start = *((timestruc_t *)`dtrace_zero); /* ` */

	pr_fname = 	P-&gt;p_comm;
	pr_psargs = P-&gt;p_comm; /* XXX omits command line arguments XXX */
	pr_argc = P-&gt;p_argc;
	pr_argv = P-&gt;p_dtrace_argv;
	pr_envp = P-&gt;p_dtrace_envp;

	pr_dmodel = (P-&gt;p_flag &amp; P_LP64) ? PR_MODEL_LP64 : PR_MODEL_ILP32;

	pr_taskid = 0;
	pr_projid = 0;
	pr_poolid = 0;
	pr_zoneid = 0;

	/*
	 * pstats-&gt;pstart is a struct timeval: (SECONDS, MICROSECONDS).
	 */
	pr_start_tv = P-&gt;p_start;
};

/*
 * Translate from the kernel's kthread_t structure to a proc(4) psinfo_t
 * struct.  Lacking a facility to define one translator only in terms of
 * another, we explicitly define each member by using the proc_t-to-psinfo_t
 * translator, above; any members added to that translator should also be
 * added here.  (The only exception to this is pr_start, which -- due to it
 * being a structure -- cannot be defined in terms of a translator at all.)
 */
#pragma D binding &quot;1.0&quot; translator
translator psinfo_t &lt; thread_t T &gt; {
	pr_nlwp = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_nlwp;
	pr_pid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_pid;
	pr_ppid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_ppid;
	pr_pgid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_pgid;
	pr_sid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_sid;
	pr_uid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_uid;
	pr_euid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_euid;
	pr_gid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_gid;
	pr_egid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_egid;
	pr_addr = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_addr;
	pr_ttydev = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_ttydev;
	pr_start = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_start; 
	pr_fname = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_fname;
	pr_psargs = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_psargs; /* XXX omits command line arguments XXX */
	pr_argc = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_argc;
	pr_argv = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_argv;
	pr_envp = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_envp;
	pr_dmodel = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_dmodel;
	pr_taskid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_taskid;
	pr_projid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_projid;
	pr_poolid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_poolid;
	pr_zoneid = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_zoneid;

	pr_start_tv = xlate &lt;psinfo_t&gt; ((struct proc *)(T-&gt;task-&gt;bsd_info)).pr_start_tv; 
};

/*
 * Translate from the kernel's kthread_t structure to a proc(4) lwpsinfo_t.
 * We do not provide support for pr_nice, pr_oldpri, pr_cpu, or pr_pctcpu.
 * Also, for the moment, pr_start and pr_time are not supported, but these
 * could be supported by DTrace in the future using subroutines.
 */

inline processor_t PROCESSOR_NULL = ((processor_t) 0);
#pragma D binding &quot;1.0&quot; PROCESSOR_NULL

typedef int psetid_t;

typedef struct lwpsinfo {
	int	pr_flag;	/* lwp flags (DEPRECATED; do not use) */
	id_t	pr_lwpid;	/* lwp id */
	uintptr_t pr_addr;	/* internal address of lwp */
	uintptr_t pr_wchan;	/* wait addr for sleeping lwp */
	char	pr_stype;	/* synchronization event type */
	char	pr_state;	/* numeric lwp state */
	char	pr_sname;	/* printable character for pr_state */
	short	pr_syscall;	/* system call number (if in syscall) */
	int	pr_pri;		/* priority, high value is high priority */
	char	pr_clname[8];	/* scheduling class name */
	int	pr_thstate;		/* mach thread scheduler state */
	processorid_t pr_onpro;		/* processor which last ran this lwp */
	processorid_t pr_bindpro;	/* processor to which lwp is bound */
	psetid_t pr_bindpset;	/* processor set to which lwp is bound */
} lwpsinfo_t;

#pragma D binding &quot;1.0&quot; translator
translator lwpsinfo_t &lt; thread_t T &gt; {
	pr_flag = 0; /* lwp flags (DEPRECATED; do not use) */
	pr_lwpid = (id_t)T-&gt;thread_id;
	pr_addr = (uintptr_t)T;
	pr_wchan = (uintptr_t)(((uthread_t)(T-&gt;uthread))-&gt;uu_wchan);

	pr_stype = SOBJ_NONE; /* XXX Undefined synch object (or none) XXX */
	pr_state = curproc-&gt;p_stat;
	pr_sname = (curproc-&gt;p_stat == SIDL) ? 'I' :
			(curproc-&gt;p_stat == SRUN) ? 'R' :
			(curproc-&gt;p_stat == SSLEEP) ? 'S' :
			(curproc-&gt;p_stat == SSTOP) ? 'T' :
			(curproc-&gt;p_stat == SZOMB) ? 'Z' : '?';

	pr_syscall = ((uthread_t)(T-&gt;uthread))-&gt;uu_code;
	pr_pri = T-&gt;sched_pri;

	pr_clname = (T-&gt;sched_mode &amp; 0x0001) ? &quot;RT&quot; :
			(T-&gt;sched_mode &amp; 0x0002) ? &quot;TS&quot; : &quot;SYS&quot;;

	pr_onpro = (T-&gt;last_processor == PROCESSOR_NULL) ? -1 : T-&gt;last_processor-&gt;cpu_id;
	pr_bindpro = -1; /* Darwin does not bind threads to processors. */
	pr_bindpset = -1; /* Darwin does not partition processors. */
	pr_thstate = T-&gt;state;
};

inline psinfo_t *curpsinfo = xlate &lt;psinfo_t *&gt; (curproc);
#pragma D attributes Stable/Stable/Common curpsinfo
#pragma D binding &quot;1.0&quot; curpsinfo

inline lwpsinfo_t *curlwpsinfo = xlate &lt;lwpsinfo_t *&gt; (curthread);
#pragma D attributes Stable/Stable/Common curlwpsinfo
#pragma D binding &quot;1.0&quot; curlwpsinfo

/* XXX Really want vn_getpath(curproc-&gt;p_fd-&gt;fd_cdir, , ) but that takes namecache_rw_lock XXX */
inline string cwd = curproc-&gt;p_fd-&gt;fd_cdir-&gt;v_name == NULL ?
	&quot;&lt;unknown&gt;&quot; : stringof(curproc-&gt;p_fd-&gt;fd_cdir-&gt;v_name);
#pragma D attributes Stable/Stable/Common cwd
#pragma D binding &quot;1.0&quot; cwd

/* XXX Really want vn_getpath(curproc-&gt;p_fd-&gt;fd_rdir, , ) but that takes namecache_rw_lock XXX */
inline string root = curproc-&gt;p_fd-&gt;fd_rdir == NULL ? &quot;/&quot; :
	curproc-&gt;p_fd-&gt;fd_rdir-&gt;v_name == NULL ? &quot;&lt;unknown&gt;&quot; :
	stringof(curproc-&gt;p_fd-&gt;fd_rdir-&gt;v_name);
#pragma D attributes Stable/Stable/Common root
#pragma D binding &quot;1.0&quot; root
</pre>
<hr />
</body></html>