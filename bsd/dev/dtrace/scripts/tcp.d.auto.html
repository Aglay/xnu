<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tcp.d</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tcp.d&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
/*
 * Copyright (c) 2006-2008 Apple Computer, Inc.  All Rights Reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#pragma D depends_on library darwin.d
#pragma D depends_on module mach_kernel
#pragma D depends_on provider tcp

/*
 * TCP flags
 */
inline int TH_FIN = 0x01;
#pragma D binding &quot;1.0&quot; TH_FIN
inline int TH_SYN = 0x02;
#pragma D binding &quot;1.0&quot; TH_SYN
inline int TH_RST = 0x04;
#pragma D binding &quot;1.0&quot; TH_RST
inline int TH_PUSH = 0x08;
#pragma D binding &quot;1.0&quot; TH_PUSH
inline int TH_ACK = 0x10;
#pragma D binding &quot;1.0&quot; TH_ACK
inline int TH_URG = 0x20;
#pragma D binding &quot;1.0&quot; TH_URG
inline int TH_ECE = 0x40;
#pragma D binding &quot;1.0&quot; TH_ECE
inline int TH_CWR = 0x80;
#pragma D binding &quot;1.0&quot; TH_CWR

/*
 * TCP states
 */
inline int TCPS_CLOSED = 0;
#pragma D binding &quot;1.0&quot; TCPS_CLOSED
inline int TCPS_LISTEN = 1;
#pragma D binding &quot;1.0&quot; TCPS_LISTEN
inline int TCPS_SYN_SENT = 2;
#pragma D binding &quot;1.0&quot; TCPS_SYN_SENT
inline int TCPS_SYN_RECEIVED = 3;
#pragma D binding &quot;1.0&quot; TCPS_SYN_RECEIVED
inline int TCPS_ESTABLISHED = 4;
#pragma D binding &quot;1.0&quot; TCPS_ESTABLISHED
inline int TCPS_CLOSE_WAIT = 5;
#pragma D binding &quot;1.0&quot; TCPS_CLOSE_WAIT
inline int TCPS_FIN_WAIT_1 = 6;
#pragma D binding &quot;1.0&quot; TCPS_FIN_WAIT_1
inline int TCPS_CLOSING = 7;
#pragma D binding &quot;1.0&quot; TCPS_CLOSING
inline int TCPS_LAST_ACK = 8;
#pragma D binding &quot;1.0&quot; TCPS_LAST_ACK
inline int TCPS_FIN_WAIT_2 = 9;
#pragma D binding &quot;1.0&quot; TCPS_FIN_WAIT_2
inline int TCPS_TIME_WAIT = 10;
#pragma D binding &quot;1.0&quot; TCPS_TIME_WAIT

/*
 * TCP congestion control events
 */
inline int TCP_CC_CWND_INIT = 0;
#pragma D binding &quot;1.0&quot; TCP_CC_CWND_INIT
inline int TCP_CC_INSEQ_ACK_RCVD = 1;
#pragma D binding &quot;1.0&quot; TCP_CC_INSEQ_ACK_RCVD
inline int TCP_CC_ACK_RCVD = 2;
#pragma D binding &quot;1.0&quot; TCP_CC_ACK_RCVD
inline int TCP_CC_ENTER_FASTRECOVERY = 3;
#pragma D binding &quot;1.0&quot; TCP_CC_ENTER_FASTRECOVERY
inline int TCP_CC_IN_FASTRECOVERY = 4;
#pragma D binding &quot;1.0&quot; TCP_CC_IN_FASTRECOVERY
inline int TCP_CC_EXIT_FASTRECOVERY = 5;
#pragma D binding &quot;1.0&quot; TCP_CC_EXIT_FASTRECOVERY
inline int TCP_CC_PARTIAL_ACK = 6;
#pragma D binding &quot;1.0&quot; TCP_CC_PARTIAL_ACK
inline int TCP_CC_IDLE_TIMEOUT = 7;
#pragma D binding &quot;1.0&quot; TCP_CC_IDLE_TIMEOUT
inline int TCP_CC_REXMT_TIMEOUT = 8;
#pragma D binding &quot;1.0&quot; TCP_CC_REXMT_TIMEOUT
inline int TCP_CC_ECN_RCVD = 9;
#pragma D binding &quot;1.0&quot; TCP_CC_ECN_RCVD
inline int TCP_CC_BAD_REXMT_RECOVERY = 10;
#pragma D binding &quot;1.0&quot; TCP_CC_BAD_REXMT_RECOVERY
inline int TCP_CC_OUTPUT_ERROR = 11;
#pragma D binding &quot;1.0&quot; TCP_CC_OUTPUT_ERROR
inline int TCP_CC_CHANGE_ALGO = 12;
#pragma D binding &quot;1.0&quot; TCP_CC_CHANGE_ALGO
inline int TCP_CC_FLOW_CONTROL = 13;
#pragma D binding &quot;1.0&quot; TCP_CC_FLOW_CONTROL
inline int TCP_CC_SUSPEND = 14;
#pragma D binding &quot;1.0&quot; TCP_CC_SUSPEND
inline int TCP_CC_LIMITED_TRANSMIT = 15;
#pragma D binding &quot;1.0&quot; TCP_CC_LIMITED_TRANSMIT
inline int TCP_CC_EARLY_RETRANSMIT = 16;
#pragma D binding &quot;1.0&quot; TCP_CC_EARLY_RETRANSMIT


/*
 * tcpinfo is the TCP header field
 */
typedef struct tcpinfo {
	uint16_t tcp_sport;	/* source port */
	uint16_t tcp_dport;	/* destination port */
	uint32_t tcp_seq;	/* sequence number */
	uint32_t tcp_ack;	/* acknowledgement number */
	uint8_t tcp_offset;	/* data offset, in bytes */
	uint8_t tcp_flags;	/* flags */
	uint16_t tcp_window;	/* window size */
	uint16_t tcp_checksum;	/* checksum */
	uint16_t tcp_urgent;	/* urgent data pointer */
	struct tcphdr *tcp_hdr;	/* raw TCP header */
} tcpinfo_t;

#pragma D binding &quot;1.0&quot; translator
translator tcpinfo_t &lt; struct tcphdr *T &gt; {
	tcp_sport = ntohs(T-&gt;th_sport);
	tcp_dport = ntohs(T-&gt;th_dport);
	tcp_seq = ntohl(T-&gt;th_seq);
	tcp_ack = ntohl(T-&gt;th_ack);
	tcp_offset = T-&gt;th_off &lt;&lt; 2;
	tcp_flags = T-&gt;th_flags;
	tcp_window = ntohs(T-&gt;th_win);
	tcp_checksum = ntohs(T-&gt;th_sum);
	tcp_urgent = ntohs(T-&gt;th_urp);
	tcp_hdr = T;
};

/*
 * tcpsinfo contains stable TCP details from TCP control block
 */
typedef struct tcpsinfo {
	int tcps_local;		/* is delivered locally, boolean */
	int tcps_active;	/* active open, boolean */
	string tcps_state;	/* TCP state, as a string */
	u_int t_flags;		/* flags */
	uint32_t rcv_nxt;	/* receive next */
	uint32_t rcv_adv;	/* advertised window */
	uint32_t rcv_wnd;	/* receive window */
	uint32_t snd_wnd;	/* send window */
	uint32_t snd_cwnd;	/* congestion controlled window */
	uint32_t snd_ssthresh;	/* slow-start threshold */
	uint32_t snd_una;	/* send unacknowledged */
	uint32_t snd_nxt;	/* send next */
	uint32_t snd_max;	/* send max */
	uint32_t snd_recover;	/* send recover for NewReno */
	int	t_rxtcur;	/* retransmit timeout in ms */
	u_int	t_maxseg;	/* maximum segment size */
	u_int	t_rttbest;	/* best rtt we have seen */
	int	rcv_numsacks;	/* number of sack blocks present */
	int	snd_numholes;	/* number of holes seen by sender */
	struct tcpcb* tcpcb;	/* Pointer to tcp control block */
} tcpsinfo_t;

#pragma D binding &quot;1.0&quot; translator
translator tcpsinfo_t &lt; struct tcpcb *T&gt; {
	tcps_local = 0;		/* Not used */
	tcps_active = 0;
	tcps_state = T ? 
		T-&gt;t_state == TCPS_CLOSED ? &quot;state-closed&quot; :
		T-&gt;t_state == TCPS_LISTEN ? &quot;state-listen&quot; :
		T-&gt;t_state == TCPS_SYN_SENT ? &quot;state-syn-sent&quot; :
		T-&gt;t_state == TCPS_SYN_RECEIVED ? &quot;state-syn-received&quot; :
		T-&gt;t_state == TCPS_ESTABLISHED ? &quot;state-established&quot; :
		T-&gt;t_state == TCPS_CLOSE_WAIT ? &quot;state-close-wait&quot; :
		T-&gt;t_state == TCPS_FIN_WAIT_1 ? &quot;state-fin-wait1&quot; :
		T-&gt;t_state == TCPS_CLOSING ? &quot;state-closing&quot; :
		T-&gt;t_state == TCPS_LAST_ACK ? &quot;state-last-ack&quot; :
		T-&gt;t_state == TCPS_FIN_WAIT_2 ? &quot;state-fin-wait2&quot; :
		T-&gt;t_state == TCPS_TIME_WAIT ? &quot;state-time-wait&quot; :
		&quot;&lt;unknown&gt;&quot; : &quot;&lt;null&gt;&quot;;
	t_flags = T-&gt;t_flags;
	rcv_nxt = T-&gt;rcv_nxt;
	rcv_adv = T-&gt;rcv_adv;
	rcv_wnd = T-&gt;rcv_wnd;
	snd_wnd = T-&gt;snd_wnd;
	snd_cwnd = T-&gt;snd_cwnd;
	snd_ssthresh = T-&gt;snd_ssthresh;
	snd_una = T-&gt;snd_una;
	snd_nxt = T-&gt;snd_nxt;
	snd_max = T-&gt;snd_max;
	snd_recover = T-&gt;snd_recover;
	t_rxtcur = T-&gt;t_rxtcur;
	t_maxseg = T-&gt;t_maxseg;
	t_rttbest = T-&gt;t_rttbest;
	rcv_numsacks = T-&gt;rcv_numsacks;
	snd_numholes = T-&gt;snd_numholes;
	tcpcb = T;
};

/*
 * tcpnsinfo provides the new tcp state for state changes.
 */
typedef struct tcpnsinfo {
	string tcps_state;	/* TCP state, as a string */
} tcpnsinfo_t;

#pragma D binding &quot;1.0&quot; translator
translator tcpnsinfo_t &lt; int32_t I &gt; {
	tcps_state = I ? 
		I == TCPS_LISTEN ? &quot;state-listen&quot; :
		I == TCPS_SYN_SENT ? &quot;state-syn-sent&quot; :
		I == TCPS_SYN_RECEIVED ? &quot;state-syn-received&quot; :
		I == TCPS_ESTABLISHED ? &quot;state-established&quot; :
		I == TCPS_CLOSE_WAIT ? &quot;state-close-wait&quot; :
		I == TCPS_FIN_WAIT_1 ? &quot;state-fin-wait1&quot; :
		I == TCPS_CLOSING ? &quot;state-closing&quot; :
		I == TCPS_LAST_ACK ? &quot;state-last-ack&quot; :
		I == TCPS_FIN_WAIT_2 ? &quot;state-fin-wait2&quot; :
		I == TCPS_TIME_WAIT ? &quot;state-time-wait&quot; :
		&quot;&lt;unknown&gt;&quot; : &quot;state-closed&quot;;
};

/* 
 * tcpccevent provides the congestion control event for TCP cc probes
 */
typedef struct tcpccevent {
	string tcp_cc;		/* TCP congestion control event, as a string */
} tcpccevent_t;

#pragma D binding &quot;1.0&quot; translator
translator tcpccevent_t &lt; int32_t I &gt; {
	tcp_cc = I ?
		I == TCP_CC_INSEQ_ACK_RCVD ? &quot;inseq-ack-rcvd&quot; :
		I == TCP_CC_ACK_RCVD ? &quot;ack-rcvd&quot; :
		I == TCP_CC_ENTER_FASTRECOVERY ? &quot;enter-fastrecovery&quot; :
		I == TCP_CC_EXIT_FASTRECOVERY ? &quot;exit-fastrecovery&quot; :
		I == TCP_CC_PARTIAL_ACK ? &quot;partial-ack&quot; :
		I == TCP_CC_IDLE_TIMEOUT ? &quot;idle-timeout&quot; :
		I == TCP_CC_REXMT_TIMEOUT ? &quot;rexmt-timeout&quot; :
		I == TCP_CC_ECN_RCVD ? &quot;ecn-rcvd&quot; :
		I == TCP_CC_BAD_REXMT_RECOVERY ? &quot;bad-rexmt&quot; :
		I == TCP_CC_OUTPUT_ERROR ? &quot;output-error&quot; :
		I == TCP_CC_CHANGE_ALGO ? &quot;change-algo&quot; :
		I == TCP_CC_FLOW_CONTROL ? &quot;flow-control&quot; :
		I == TCP_CC_SUSPEND ? &quot;suspend&quot; :
		I == TCP_CC_LIMITED_TRANSMIT ? &quot;limited-transmit&quot; :
		I == TCP_CC_EARLY_RETRANSMIT ? &quot;early-rexmt&quot; :
		&quot;&lt;unknown&gt;&quot; : &quot;cwnd-init&quot;;
};
</pre>
<hr />
</body></html>